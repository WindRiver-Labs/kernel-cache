From 4e2499fc9f7914897878b3ae1e661d7abadd789c Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 22 Jul 2014 18:05:50 -0700
Subject: [PATCH 825/974] MIPS: OCTEON: Update S.E. files.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c |  135 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  858 +++-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   28 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |   10 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |   11 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |   82 +-
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |  324 +-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c |   42 +-
 .../cavium-octeon/executive/cvmx-pko3-resources.c  |    2 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |   48 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   94 +-
 arch/mips/cavium-octeon/executive/cvmx-srio.c      |   10 +-
 .../cavium-octeon/executive/cvmx-sso-resources.c   |   76 +-
 arch/mips/cavium-octeon/executive/octeon-model.c   |   13 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |   29 +
 arch/mips/include/asm/octeon/cvmx-bch-defs.h       |   21 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  521 ++-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   28 +
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   66 +-
 arch/mips/include/asm/octeon/cvmx-clock.h          |    6 +-
 arch/mips/include/asm/octeon/cvmx-cmd-queue.h      |  244 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  230 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       | 1368 +++++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  113 +-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |    6 +-
 .../include/asm/octeon/cvmx-global-resources.h     |    6 +
 arch/mips/include/asm/octeon/cvmx-gmx.h            |    4 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |   73 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  748 +++-
 arch/mips/include/asm/octeon/cvmx-helper-bgx.h     |    6 +
 arch/mips/include/asm/octeon/cvmx-helper-util.h    |    4 +-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |   59 +
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |   66 +-
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       |   76 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |   47 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h      |   20 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  281 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |   20 +
 arch/mips/include/asm/octeon/cvmx-lbk-defs.h       |   28 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |  645 ++-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  468 +-
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |   47 +-
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |   23 +-
 arch/mips/include/asm/octeon/cvmx-ndf-defs.h       |   30 +-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |  114 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  127 +-
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |    7 +
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |  177 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   | 1043 ++++-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  335 ++
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |  354 +-
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      |   76 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  397 +-
 arch/mips/include/asm/octeon/cvmx-pki.h            |    4 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 1617 +++++--
 arch/mips/include/asm/octeon/cvmx-pko3.h           |   29 +-
 arch/mips/include/asm/octeon/cvmx-pow.h            |   10 +-
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   21 +-
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h       |   20 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |   78 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |  446 +-
 arch/mips/include/asm/octeon/cvmx-smix-defs.h      |   20 +
 .../mips/include/asm/octeon/cvmx-sriomaintx-defs.h | 4663 +++++++++++++-------
 arch/mips/include/asm/octeon/cvmx-sriox-defs.h     | 3393 +++++++++-----
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  326 +-
 arch/mips/include/asm/octeon/cvmx-uahcx-defs.h     |   79 +
 arch/mips/include/asm/octeon/cvmx-uctlx-defs.h     |   12 +
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   |  424 +-
 arch/mips/include/asm/octeon/octeon-feature.h      |   24 +-
 arch/mips/include/asm/octeon/octeon-model.h        |    8 +-
 70 files changed, 15981 insertions(+), 4839 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
index 5c73812..6101027 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
@@ -43,7 +43,7 @@
  * Support functions for managing command queues used for
  * various hardware blocks.
  *
- * <hr>$Revision: 110896 $<hr>
+ * <hr>$Revision: 112009 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/export.h>
@@ -110,12 +110,13 @@ cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(unsigned node)
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32
 	{
-	/* Special address range for SE-UM apps in 32-bit mode */
-	extern uint64_t octeon_reserve32_memory;
-	if (octeon_reserve32_memory)
-		paddr_min = octeon_reserve32_memory;
-		paddr_max = octeon_reserve32_memory +
-			(CONFIG_CAVIUM_RESERVE32 << 20) - 1,
+		/* Special address range for SE-UM apps in 32-bit mode */
+		extern uint64_t octeon_reserve32_memory;
+		if (octeon_reserve32_memory) {
+			paddr_min = octeon_reserve32_memory;
+			paddr_max = octeon_reserve32_memory +
+				(CONFIG_CAVIUM_RESERVE32 << 20) - 1;
+		}
 	}
 #endif
 #endif
@@ -191,20 +192,25 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 	if ((fpa_pool < fpa_pool_min) || (fpa_pool >= fpa_pool_max))
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
 
-	if ((pool_size < 128) || (pool_size > 65536))
+	if ((pool_size < 128) || (pool_size > (1<<17)))
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
+
 	if (pool_size & 3)
 		cvmx_dprintf("WARNING: %s: pool_size %d not multiple of 8\n",
 			__func__, pool_size);
 
 	/* See if someone else has already initialized the queue */
 	if (qstate->base_paddr) {
+		int depth;
 		static const char emsg[] = /* Common error message part */
 			"Queue already initialized with different ";
 
-		if (max_depth != (int)qstate->max_depth) {
+		depth = (max_depth + qstate->pool_size_m1 - 1) /
+			qstate->pool_size_m1;
+		if (depth != qstate->max_depth) {
+			depth = qstate->max_depth * qstate->pool_size_m1;
 			cvmx_dprintf("ERROR: %s: %s max_depth (%d).\n",
-				__func__, emsg, (int)qstate->max_depth);
+				__func__, emsg, depth);
 			return CVMX_CMD_QUEUE_INVALID_PARAM;
 		}
 		if (fpa_pool != qstate->fpa_pool) {
@@ -231,17 +237,18 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 				return CVMX_CMD_QUEUE_NO_MEMORY;
 			}
 		}
-		buffer = __cvmx_cmd_queue_alloc_buffer(fpa_pool);
+		buffer = cvmx_fpa_alloc(fpa_pool);
 		if (buffer == NULL) {
 			cvmx_dprintf("ERROR: %s: allocating first buffer.\n",
 				__func__);
 			return CVMX_CMD_QUEUE_NO_MEMORY;
 		}
 
-		memset(qstate, 0, sizeof(*qstate));
-		qstate->max_depth = max_depth;
+		index = (pool_size >> 3) - 1;
+		qstate->pool_size_m1 = index;
+		qstate->max_depth = (max_depth + index -1) / index;
+		qstate->index = 0;
 		qstate->fpa_pool = fpa_pool;
-		qstate->pool_size_m1 = (pool_size >> 3) - 1;
 		qstate->base_paddr = cvmx_ptr_to_phys(buffer);
 
 		/* Initialize lock */
@@ -373,3 +380,103 @@ void *cvmx_cmd_queue_buffer(cvmx_cmd_queue_id_t queue_id)
 		return NULL;
 }
 EXPORT_SYMBOL(cvmx_cmd_queue_buffer);
+
+static uint64_t *__cvmx_cmd_queue_add_blk(__cvmx_cmd_queue_state_t *qptr)
+{
+	uint64_t *cmd_ptr;
+	uint64_t *new_buffer;
+	uint64_t new_paddr;
+
+	/* Get base vaddr of current (full) block */
+	cmd_ptr = cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
+
+	/* Allocate a new block from the per-queue pool */
+	new_buffer = cvmx_fpa_alloc(qptr->fpa_pool);
+
+	/* Check for allocation failure */
+	if (cvmx_unlikely(new_buffer == NULL))
+		return NULL;
+
+	/* Zero out the new block link pointer,
+	 * in case this block will be filled to the rim
+	 */
+	new_buffer[ qptr->pool_size_m1 ] = ~0ull;
+
+	/* Get physical address of the new buffer */
+	new_paddr = cvmx_ptr_to_phys(new_buffer);
+
+	/* Store the physical link address at the end of current full block */
+	cmd_ptr[ qptr->pool_size_m1] = new_paddr;
+
+	/* Store the physical address in the queue state structure */
+	qptr->base_paddr = new_paddr;
+	qptr->index = 0;
+
+	/* Return the virtual base of the new block */
+	return new_buffer;
+}
+
+/**
+ * @INTERNAL
+ * Add command words into a queue, handles all the corener cases
+ * where only some of the words might fit into the current block,
+ * and a new block may need to be allocated.
+ * Locking and argument checks are done in the front-end in-line
+ * functions that call this one for the rare corner cases.
+ */
+cvmx_cmd_queue_result_t
+__cvmx_cmd_queue_write_raw(cvmx_cmd_queue_id_t queue_id,
+	__cvmx_cmd_queue_state_t *qptr,
+	int cmd_count, const uint64_t *cmds)
+{
+	uint64_t *cmd_ptr;
+	unsigned index;
+
+	cmd_ptr = cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
+	index = qptr->index;
+
+	/* Enforce queue depth limit, if enabled, once per block */
+	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH &&
+	    cvmx_unlikely(qptr->max_depth)) {
+		unsigned depth = cvmx_cmd_queue_length(queue_id);
+		depth /= qptr->pool_size_m1;
+
+		if (cvmx_unlikely(depth > qptr->max_depth)) {
+			return CVMX_CMD_QUEUE_FULL;
+		}
+	}
+
+	/*
+	 * If the block allocation fails, even the words that we wrote
+	 * to the current block will not count because the 'index' will
+	 * not be comitted.
+	 * The loop is run 'count + 1' times to take care of the tail
+	 * case, where the buffer is full to the rim, so the link
+	 * pointer must be filled with a valid address.
+	 */
+	while (cmd_count >= 0) {
+		if (index >= qptr->pool_size_m1) {
+			/* Block is full, get another one and proceed */
+			cmd_ptr = __cvmx_cmd_queue_add_blk(qptr);
+
+			/* Baul on allocation error w/o comitting anything */
+			if (cvmx_unlikely(cmd_ptr == NULL))
+				return CVMX_CMD_QUEUE_NO_MEMORY;
+
+			/* Reset index for start of new block */
+			index = 0;
+		}
+		/* Exit Loop on 'count + 1' iterations */
+		if (cmd_count <= 0)
+			break;
+		/* Store commands into queue block while there is space */
+		cmd_ptr[ index ++ ] = *cmds++;
+		cmd_count --;
+	} /* while cmd_count */
+
+	/* Commit added words if all is well */
+	qptr->index = index;
+
+	return CVMX_CMD_QUEUE_SUCCESS;
+}
+EXPORT_SYMBOL(__cvmx_cmd_queue_write_raw);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 7266fd8..f46e9bf 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -63,6 +63,8 @@
 #include "cvmx-qlm.h"
 #endif
 
+static const int debug = 0;
+
 int __cvmx_helper_bgx_enumerate(int xiface)
 {
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
@@ -70,6 +72,17 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	int qlm;
 	enum cvmx_qlm_mode mode;
 
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		/* CN75XX only supports single-lane modes
+		 * hence each interface, which is half-bgx
+		 * has two ports exactly
+		 */
+		if (xi.interface < 2)
+			return 2;
+
+		return -1;
+	}
+
 	/*
 	 * Check the QLM is configured correctly for SGMII, verify the
 	 * speed as well as the mode.
@@ -100,6 +113,32 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 
 /**
  * @INTERNAL
+ *
+ * Convert global interface and port index into
+ * a BGX block number and LMAC within that block.
+ * Returns -1 if the interface is not mapped to BGX.
+ */
+static int cvmx_helper_bgx_index(int xiface, int index,
+	unsigned *block, unsigned *lmac)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int max = __cvmx_helper_bgx_enumerate(xiface);
+
+	if (max < 0 || index >= max)
+		return -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		*lmac = ((xi.interface & 1 ) << 1) + (index & 1);
+		*block = xi.interface >> 1;
+	} else {
+		*block = xi.interface;
+		*lmac = index;
+	}
+	return 0;
+}
+
+/**
+ * @INTERNAL
  * Disable the BGX port
  *
  * @param xipd_port IPD port of the BGX interface to disable
@@ -109,17 +148,20 @@ void cvmx_helper_bgx_disable(int xipd_port)
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_cmrx_config_t cmr_config;
+	unsigned unit, lmac;
 
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0) || index)
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
+
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
+	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0) || lmac)
 		cmr_config.s.enable = 0;
 	cmr_config.s.data_pkt_tx_en = 0;
 	cmr_config.s.data_pkt_rx_en = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 }
 
 
@@ -140,13 +182,27 @@ static void __cvmx_bgx_common_init(int xiface, int index)
 	int num_ports;
 	int lmac_type = 0;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
 	int node = xi.node;
-	int lane_to_sds = 0;
+	unsigned lane_to_sds = 0;
+	unsigned unit, lmac, num_lmacs;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
 
 	num_ports = cvmx_helper_ports_on_interface(xiface);
 	mode = cvmx_helper_interface_get_mode(xiface);
 
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		num_lmacs = 4;	/* Only SGMII/XFI supported on o75 */
+	} else {
+		num_lmacs = num_ports;
+	}
+
+
 	switch (mode) {
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 		lmac_type = 0;
@@ -175,61 +231,79 @@ static void __cvmx_bgx_common_init(int xiface, int index)
 
 	/* Set mode and lanes for all interface ports */
 	cmr_config.u64 =
-		cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 	cmr_config.s.enable = 0;
 	cmr_config.s.data_pkt_tx_en = 0;
 	cmr_config.s.data_pkt_rx_en = 0;
 	cmr_config.s.lmac_type = lmac_type;
-	cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? index
+	//XXX This logic is obscore, needs clarification! FIXME.
+	cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? lmac
 				: ((lane_to_sds == 0)
-				? (index ? 0xe : 4) : lane_to_sds));
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+				? (lmac ? 0xe : 4) : lane_to_sds));
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
+
+	if (debug)
+		cvmx_dprintf("%s: lane_to_sds=%#x\n",
+		__func__, cmr_config.s.lane_to_sds);
 
-	if (index == 0) {
+	if (lmac == 0) {
 		bgx_cmr_rx_lmacs.u64 = 0;
-		bgx_cmr_rx_lmacs.s.lmacs = num_ports;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_LMACS(interface), bgx_cmr_rx_lmacs.u64);
+		bgx_cmr_rx_lmacs.s.lmacs = num_lmacs;
+		cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_LMACS(unit), bgx_cmr_rx_lmacs.u64);
 
 		bgx_cmr_tx_lmacs.u64 = 0;
-		bgx_cmr_tx_lmacs.s.lmacs = num_ports;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_TX_LMACS(interface), bgx_cmr_tx_lmacs.u64);
+		bgx_cmr_tx_lmacs.s.lmacs = num_lmacs;
+		cvmx_write_csr_node(node, CVMX_BGXX_CMR_TX_LMACS(unit), bgx_cmr_tx_lmacs.u64);
 	}
 }
 
 static void __cvmx_bgx_common_init_pknd(int xiface, int index)
 {
 	int num_ports;
-	int num_chl = 16; /*modify it to 64 for xlaui and xaui*/
+	int num_chl = 16; /* FIXME: modify it to 64 for xlaui and xaui*/
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
 	int node = xi.node;
 	int pknd;
+	unsigned lmac, unit;
 	cvmx_bgxx_cmrx_rx_bp_on_t bgx_rx_bp_on;
 	cvmx_bgxx_cmrx_rx_id_map_t cmr_rx_id_map;
 	cvmx_bgxx_cmr_chan_msk_and_t chan_msk_and;
 	cvmx_bgxx_cmr_chan_msk_or_t chan_msk_or;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
+
 	num_ports = cvmx_helper_ports_on_interface(xiface);
 	/* Modify bp_on mark, depending on number of LMACS on that interface
 	and write it for every port */
 	bgx_rx_bp_on.u64 = 0;
 	bgx_rx_bp_on.s.mark = (CVMX_BGX_RX_FIFO_SIZE / (num_ports * 4 * 16));
 
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		/* o75 always uses 4 LMACs */
+		bgx_rx_bp_on.s.mark = (CVMX_BGX_RX_FIFO_SIZE / (4 * 4 * 16));
+	}
+
+
 	/* Setup pkind */
 	pknd = cvmx_helper_get_pknd(xiface, index);
-	cmr_rx_id_map.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, interface));
+	cmr_rx_id_map.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(lmac, unit));
 	cmr_rx_id_map.s.pknd = pknd;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, interface),
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(lmac, unit),
 			    cmr_rx_id_map.u64);
 	/* Set backpressure channel mask AND/OR registers */
-	chan_msk_and.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface));
-	chan_msk_or.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface));
-	chan_msk_and.s.msk_and |= ((1 << num_chl) - 1) << (16 * index);
-	chan_msk_or.s.msk_or |= ((1 << num_chl) - 1) << (16 * index);
-	cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface), chan_msk_and.u64);
-	cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface), chan_msk_or.u64);
+	chan_msk_and.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(unit));
+	chan_msk_or.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(unit));
+	chan_msk_and.s.msk_and |= ((1 << num_chl) - 1) << (16 * lmac);
+	chan_msk_or.s.msk_or |= ((1 << num_chl) - 1) << (16 * lmac);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(unit), chan_msk_and.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(unit), chan_msk_or.u64);
 	/* set rx back pressure (bp_on) on value */
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_BP_ON(index, interface), bgx_rx_bp_on.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_BP_ON(lmac, unit), bgx_rx_bp_on.u64);
 }
 
 /**
@@ -265,29 +339,36 @@ EXPORT_SYMBOL(__cvmx_helper_bgx_probe);
 static int __cvmx_helper_bgx_sgmii_hardware_init_one_time(int xiface, int index)
 {
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
 	int node = xi.node;
 	const uint64_t clock_mhz = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK) / 1000000;
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
 	cvmx_bgxx_gmp_pcs_linkx_timer_t gmp_timer;
+	unsigned unit, lmac;
 
-	if (!cvmx_helper_is_port_valid(interface, index))
+	if (!cvmx_helper_is_port_valid(xi.interface, index))
 		return 0;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
 	/*
 	 * Write PCS*_LINK*_TIMER_COUNT_REG[COUNT] with the
 	 * appropriate value. 1000BASE-X specifies a 10ms
 	 * interval. SGMII specifies a 1.6ms interval.
 	 */
-	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 	/* Adjust the MAC mode if requested by device tree */
 	gmp_misc_ctl.s.mac_phy =
 		cvmx_helper_get_mac_phy_mode(xiface, index);
 	gmp_misc_ctl.s.mode =
 		cvmx_helper_get_1000x_mode(xiface, index);
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface), gmp_misc_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit), gmp_misc_ctl.u64);
 
-	gmp_timer.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_LINKX_TIMER(index, interface));
+	gmp_timer.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_LINKX_TIMER(lmac, unit));
 	if (gmp_misc_ctl.s.mode)
 		/* 1000BASE-X */
 		gmp_timer.s.count = (10000ull * clock_mhz) >> 10;
@@ -295,7 +376,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_one_time(int xiface, int index)
 		/* SGMII */
 		gmp_timer.s.count = (1600ull * clock_mhz) >> 10;
 
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_LINKX_TIMER(index, interface), gmp_timer.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_LINKX_TIMER(lmac, unit), gmp_timer.u64);
 
 	/*
 	 * Write the advertisement register to be used as the
@@ -309,20 +390,20 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_one_time(int xiface, int index)
 	if (gmp_misc_ctl.s.mode) {
 		/* 1000BASE-X */
 		cvmx_bgxx_gmp_pcs_anx_adv_t gmp_an_adv;
-		gmp_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_ANX_ADV(index, interface));
+		gmp_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_ANX_ADV(lmac, unit));
 		gmp_an_adv.s.rem_flt = 0;
 		gmp_an_adv.s.pause = 3;
 		gmp_an_adv.s.hfd = 1;
 		gmp_an_adv.s.fd = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_ANX_ADV(index, interface), gmp_an_adv.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_ANX_ADV(lmac, unit), gmp_an_adv.u64);
 	} else {
 		if (gmp_misc_ctl.s.mac_phy) {
 			/* PHY Mode */
 			cvmx_bgxx_gmp_pcs_sgmx_an_adv_t gmp_sgmx_an_adv;
-			gmp_sgmx_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(index, interface));
+			gmp_sgmx_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(lmac, unit));
 			gmp_sgmx_an_adv.s.dup = 1;
 			gmp_sgmx_an_adv.s.speed = 2;
-			cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(index, interface),
+			cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(lmac, unit),
 				       gmp_sgmx_an_adv.u64);
 		} else {
 			/* MAC Mode - Nothing to do */
@@ -413,42 +494,50 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	unsigned lmac, unit;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
-	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
+	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 	/* Take PCS through a reset sequence */
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		gmp_control.s.reset = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit),
 		       					     gmp_control.u64);
 
 		/* Wait until GMP_PCS_MRX_CONTROL[reset] comes out of reset */
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit),
 				cvmx_bgxx_gmp_pcs_mrx_control_t, reset, ==, 0, 10000)) {
-			cvmx_dprintf("SGMII%d: Timeout waiting for port %d to finish reset\n", interface, index);
+			cvmx_dprintf("SGMII%d: Timeout waiting for port %d to finish reset\n", interface, lmac);
 			return -1;
 		}
 	}
 
 	/* Write GMP_PCS_MR*_CONTROL[RST_AN]=1 to ensure a fresh SGMII
 	   negotiation starts. */
-	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 	gmp_control.s.rst_an = 1;
 	gmp_control.s.an_en = 1;
 	gmp_control.s.pwr_dn = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface),
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit),
 		       gmp_control.u64);
 
 
 	phy_mode = cvmx_helper_get_mac_phy_mode(xiface, index);
 	mode_1000x = cvmx_helper_get_1000x_mode(xiface, index);
 
-	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 	gmp_misc_ctl.s.mac_phy = phy_mode;
 	gmp_misc_ctl.s.mode = mode_1000x;
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface), gmp_misc_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit), gmp_misc_ctl.u64);
 
 	if (phy_mode)
 		/* In PHY mode we can't query the link status so we just
@@ -460,7 +549,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 	   ethernet link, but a link between OCTEON and PHY. */
 
 	if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
-	     CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_PCS_MRX_STATUS(index, interface),
+	     CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_PCS_MRX_STATUS(lmac, unit),
 				   cvmx_bgxx_gmp_pcs_mrx_status_t, an_cpt,
 				   ==, 1, 10000)) {
 		cvmx_dprintf("SGMII%d: Port %d link timeout\n", interface, index);
@@ -492,23 +581,31 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	unsigned unit, lmac;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
 	/* Errata bgx-22429*/
 	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || index) {
 		/* Disable GMX before we make any changes. Remember the enable state */
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 		is_enabled = cmr_config.s.enable;
 		cmr_config.s.enable = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 	}
 
 	/* Wait for GMX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
+	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit),
 				  cvmx_bgxx_gmp_gmi_prtx_cfg_t, rx_idle, ==, 1, 10000) ||
-	    CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
+	    CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit),
 				  cvmx_bgxx_gmp_gmi_prtx_cfg_t, tx_idle, ==, 1, 10000)) {
 		cvmx_dprintf("SGMII%d:%d: Timeout waiting for port %d to be idle\n",
 			     node, interface, index);
@@ -516,13 +613,13 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 	}
 
 	/* Read GMX CFG again to make sure the disable completed */
-	gmp_prtx_cfg.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface));
+	gmp_prtx_cfg.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit));
 
 	/*
 	 * Get the misc control for PCS. We will need to set the
 	 * duplication amount.
 	 */
-	gmp_miscx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+	gmp_miscx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 
 	/*
 	 * Use GMXENO to force the link down if the status we get says
@@ -542,54 +639,54 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 		gmp_prtx_cfg.s.slottime = 0;
 		/* Setting from GMX-603 */
 		gmp_miscx_ctl.s.samp_pt = 25;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(index, interface), 64);
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(index, interface), 0);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(lmac, unit), 64);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(lmac, unit), 0);
 		break;
 	case 100:
 		gmp_prtx_cfg.s.speed = 0;
 		gmp_prtx_cfg.s.speed_msb = 0;
 		gmp_prtx_cfg.s.slottime = 0;
 		gmp_miscx_ctl.s.samp_pt = 0x5;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(index, interface), 64);
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(index, interface), 0);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(lmac, unit), 64);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(lmac, unit), 0);
 		break;
 	case 1000:
 		gmp_prtx_cfg.s.speed = 1;
 		gmp_prtx_cfg.s.speed_msb = 0;
 		gmp_prtx_cfg.s.slottime = 1;
 		gmp_miscx_ctl.s.samp_pt = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(index, interface), 512);
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SLOT(lmac, unit), 512);
 		if (gmp_prtx_cfg.s.duplex)
 			/* full duplex */
-			cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(index, interface), 0);
+			cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(lmac, unit), 0);
 		else
 			/* half duplex */
-			cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(index, interface), 8192);
+			cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_BURST(lmac, unit), 8192);
 		break;
 	default:
 		break;
 	}
 
 	/* Write the new misc control for PCS */
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface),
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit),
 		       gmp_miscx_ctl.u64);
 
 	/* Write the new GMX settings with the port still disabled */
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface), gmp_prtx_cfg.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit), gmp_prtx_cfg.u64);
 
 	/* Read GMX CFG again to make sure the config completed */
-	cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface));
+	cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit));
 
 	/* Restore the enabled/disabled state */
 	/* bgx-22429 */
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || index)
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
+	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || lmac)
 		cmr_config.s.enable = is_enabled;
 #ifndef CVMX_BUILD_FOR_UBOOT
 	cmr_config.s.data_pkt_tx_en = 1;
 	cmr_config.s.data_pkt_rx_en = 1;
 #endif
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 
 	return 0;
 }
@@ -614,16 +711,23 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	int speed = 1000;
+	unsigned unit, lmac;
 
 	result.u64 = 0;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return result;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return result;
+
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM) {
 		/* The simulator gives you a simulated 1Gbps full duplex link */
 		result.s.link_up = 1;
@@ -634,7 +738,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 
 	speed = cvmx_qlm_get_gbaud_mhz(0) * 8 / 10;
 
-	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 	if (gmp_control.s.loopbck1) {
 		/* Force 1Gbps full duplex link for internal loopback */
 		result.s.link_up = 1;
@@ -643,7 +747,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 		return result;
 	}
 
-	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 	if (gmp_misc_ctl.s.mac_phy) {
 		/* PHY Mode */
 		/* Note that this also works for 1000base-X mode */
@@ -716,44 +820,53 @@ int __cvmx_helper_bgx_sgmii_link_set(int xipd_port,
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
+	unsigned unit, lmac;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
-	cvmx_helper_bgx_errata_22429(xipd_port, link_info.s.link_up);
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		cvmx_helper_bgx_errata_22429(xipd_port, link_info.s.link_up);
+	}
 
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 	if (link_info.s.link_up) {
 		cmr_config.s.enable = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 		__cvmx_helper_bgx_sgmii_hardware_init_link(xiface, index);
 	} else {
 		cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
 		cmr_config.s.data_pkt_tx_en = 0;
 		cmr_config.s.data_pkt_rx_en = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-		gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
+		gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 
 		/* Disable autonegotiation only when MAC mode. */
 		if (gmp_misc_ctl.s.mac_phy == 0) {
 			cvmx_bgxx_gmp_pcs_mrx_control_t gmp_control;
 
-			gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+			gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 			gmp_control.s.an_en = 0;
-			cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface), gmp_control.u64);
-			cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+			cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit), gmp_control.u64);
+			cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 		}
 		/*
 		 * Use GMXENO to force the link down it will get
 		 * reenabled later...
 		 */
 		gmp_misc_ctl.s.gmxeno = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit),
 			       gmp_misc_ctl.u64);
-		cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+		cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 		return 0;
 	}
 	return __cvmx_helper_bgx_sgmii_hardware_init_link_speed(xiface, index, link_info);
@@ -788,6 +901,14 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	int use_auto_neg = 0;
 	int use_training = 0;
 	int xipd_port = cvmx_helper_get_ipd_port(xiface, index);
+	unsigned unit, lmac;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
@@ -806,12 +927,12 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	   BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1 to disable
 	   reception. */
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 		spu_control1.s.reset = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 
 		/* 1. Wait for PCS to come out of reset */
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit),
 				cvmx_bgxx_spux_control1_t, reset, ==, 0, 10000)) {
 			cvmx_dprintf("BGX%d:%d: SPU stuck in reset\n", node, interface);
 			return -1;
@@ -821,29 +942,29 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
 		      BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
 		if (!cvmx_helper_bgx_errata_22429(xipd_port, 0)) {
-			cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+			cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 			cmr_config.s.enable = 0;
-			cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+			cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 		}
-		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 		spu_control1.s.lo_pwr = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 
-		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit));
 		spu_misc_control.s.rx_packet_dis = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit), spu_misc_control.u64);
 
 		/* 3. At this point, it may be appropriate to disable all BGX and SMU/SPU
 		    interrupts, as a number of them will occur during bring-up of the Link.
 		    - zero BGX(0..5)_SMU(0..3)_RX_INT
 		    - zero BGX(0..5)_SMU(0..3)_TX_INT
 		    - zero BGX(0..5)_SPU(0..3)_INT */
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface),
-			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface)));
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface),
-			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface)));
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface),
-			cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface)));
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(lmac, unit),
+			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_INT(lmac, unit)));
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(lmac, unit),
+			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_INT(lmac, unit)));
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit),
+			cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit)));
 
 		/* 4. Configure the BGX LMAC. */
 		/* 4a. Configure the LMAC type (40GBASE-R/10GBASE-R/RXAUI/XAUI) and
@@ -853,13 +974,13 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 		/* 4b. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
 		     BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
-		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 		spu_control1.s.lo_pwr = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 
-		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit));
 		spu_misc_control.s.rx_packet_dis = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit), spu_misc_control.u64);
 
 		/* 4b. Initialize the selected SerDes lane(s) in the QLM. See Section
 		      28.1.2.2 in the GSER chapter. */
@@ -869,42 +990,42 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		     BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] = 1. */
 		if (use_training) {
 			cvmx_bgxx_spux_br_pmd_control_t spu_br_pmd_control;
-			spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+			spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
 			spu_br_pmd_control.s.train_en = 1;
-			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_br_pmd_control.u64);
+			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), spu_br_pmd_control.u64);
 
 		}
 	} else { /* enable for simulator */
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 		cmr_config.s.enable = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 	}
 
 	/* 4d. Program all other relevant BGX configuration while
 	       BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 0. This includes all things
 	       described in this chapter. */
 	/* Always add FCS to PAUSE frames */
-	smu_tx_append.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface));
+	smu_tx_append.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(lmac, unit));
 	smu_tx_append.s.fcs_d = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface), smu_tx_append.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(lmac, unit), smu_tx_append.u64);
 
 	/* 4e. If Forward Error Correction is desired for 10GBASE-R or 40GBASE-R,
 	       enable it by writing BGX(0..5)_SPU(0..3)_FEC_CONTROL[FEC_EN] = 1. */
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		/* FEC is optional for 10GBASE-KR, 40GBASE-KR4, and XLAUI. We're going
 		to disable it by default */
-		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
 		spu_fec_control.s.fec_en = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_fec_control.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), spu_fec_control.u64);
 
 		/* 4f. If Auto-Negotiation is desired, configure and enable
 		      Auto-Negotiation as described in Section 33.6.2. */
-		spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
+		spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(lmac, unit));
 		spu_an_control.s.an_en = use_auto_neg;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface), spu_an_control.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(lmac, unit), spu_an_control.u64);
 
-		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_FEC_CONTROL(index, interface));
-		spu_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface));
+		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_FEC_CONTROL(lmac, unit));
+		spu_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(lmac, unit));
 		spu_an_adv.s.fec_req = spu_fec_control.s.fec_en;
 		spu_an_adv.s.fec_able = 1;
 		spu_an_adv.s.a100g_cr10 = 0;
@@ -914,12 +1035,12 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		spu_an_adv.s.a10g_kx4 = 0;
 		spu_an_adv.s.a1g_kx = 0;
 		spu_an_adv.s.rf = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface), spu_an_adv.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(lmac, unit), spu_an_adv.u64);
 
 		/* 3. Set BGX(0..5)_SPU_DBG_CONTROL[AN_ARB_LINK_CHK_EN] = 1. */
-		spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface));
+		spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(unit));
 		spu_dbg_control.s.an_arb_link_chk_en = use_auto_neg;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface), spu_dbg_control.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(unit), spu_dbg_control.u64);
 
 		/* 4. Execute the link bring-up sequence in Section 33.6.3. */
 
@@ -930,13 +1051,13 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		/* 3h. Set BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 1 and
 		    BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0 to enable the LMAC. */
 		cvmx_helper_bgx_errata_22429(xipd_port, 1);
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 		cmr_config.s.enable = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 
-		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 		spu_control1.s.lo_pwr = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 	}
 
 	/* 4g. Set the polarity and lane swapping of the QLM SerDes. Refer to
@@ -944,16 +1065,16 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	   and BGX(0..5)_SPU(0..3)_MISC_CONTROL[TXPLRT,RXPLRT]. */
 
 	/* 4c. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0. */
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 	spu_control1.s.lo_pwr = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 
 	/* 4d. Select Deficit Idle Count mode and unidirectional enable/disable
 	   via BGX(0..5)_SMU(0..3)_TX_CTL[DIC_EN,UNI_EN]. */
-	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
+	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(lmac, unit));
 	smu_tx_ctl.s.dic_en = 1;
 	smu_tx_ctl.s.uni_en = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface), smu_tx_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(lmac, unit), smu_tx_ctl.u64);
 
 	return 0;
 }
@@ -967,6 +1088,14 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_helper_interface_mode_t mode;
+	unsigned unit, lmac;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
@@ -980,14 +1109,14 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 		/* Set TX Threshold */
 		gmi_tx_thresh.u64 = 0;
 		gmi_tx_thresh.s.cnt = 0x20;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_THRESH(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_THRESH(lmac, unit),
 				    gmi_tx_thresh.u64);
 		__cvmx_helper_bgx_sgmii_hardware_init_one_time(xiface, index);
 		gmp_txx_append.u64 = cvmx_read_csr_node(node,
-					CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface));
-		gmp_sgmii_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(index, interface));
+					CVMX_BGXX_GMP_GMI_TXX_APPEND(lmac, unit));
+		gmp_sgmii_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(lmac, unit));
 		gmp_sgmii_ctl.s.align = gmp_txx_append.s.preamble ? 0 : 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(lmac, unit),
 			    gmp_sgmii_ctl.u64);
 
 	} else {
@@ -1005,16 +1134,16 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 		* big to adversly effect shaping.
 		*/
 		smu_tx_thresh.s.cnt = 0x100;
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(lmac, unit),
 				    smu_tx_thresh.u64);
 		/* Set disparity for RXAUI interface as described in the
 		Marvell RXAUI Interface specification. */
 		if (mode == CVMX_HELPER_INTERFACE_MODE_RXAUI && phy_pres) {
 			cvmx_bgxx_spux_misc_control_t misc_control;
 			misc_control.u64 = cvmx_read_csr_node(node,
-					CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+					CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit));
 			misc_control.s.intlv_rdisp = 1;
-			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface),
+			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit),
 					    misc_control.u64);
 		}
 	}
@@ -1044,22 +1173,29 @@ int __cvmx_helper_bgx_sgmii_configure_loopback(int xipd_port, int enable_interna
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_gmp_pcs_mrx_control_t gmp_mrx_control;
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
+	unsigned unit, lmac;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
-	gmp_mrx_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface));
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
+	gmp_mrx_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit));
 	gmp_mrx_control.s.loopbck1 = enable_internal;
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, interface), gmp_mrx_control.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(lmac, unit), gmp_mrx_control.u64);
 
-	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface));
+	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit));
 	gmp_misc_ctl.s.loopbck2 = enable_external;
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, interface), gmp_misc_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(lmac, unit), gmp_misc_ctl.u64);
 
 	__cvmx_helper_bgx_sgmii_hardware_init_link(xiface, index);
 
@@ -1077,21 +1213,29 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	cvmx_bgxx_spux_misc_control_t spu_misc_control;
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_helper_interface_mode_t mode;
+	unsigned unit, lmac;
 	int use_training = 0;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
 	mode = cvmx_helper_interface_get_mode(xiface);
 
 	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
 		use_training = 1;
 
 	/* Disable packet reception */
-	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit));
 	spu_misc_control.s.rx_packet_dis = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit), spu_misc_control.u64);
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		if (use_training) {
-			spu_int.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface));
+			spu_int.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit));
 			if (!spu_int.s.training_done) {
 				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 				/* Clear the training interrupts (W1C) */
@@ -1099,20 +1243,20 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 				spu_int.u64 = 0;
 				spu_int.s.training_failure = 1;
 				spu_int.s.training_done = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
 
 				/* Restart training */
 				pmd_control.u64 = cvmx_read_csr_node(node,
-							CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+							CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
 				pmd_control.s.train_restart = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
 
 				/*cvmx_dprintf("Restarting link training\n"); */
 				return -1;
 			}
 		}
 
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit),
 					  cvmx_bgxx_spux_control1_t, reset, ==, 0, 10000)) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS in reset", node, interface, index);
 			return -1;
@@ -1122,7 +1266,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		    || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
 		    || mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
 		    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
-			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface),
+			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(lmac, unit),
 					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000)) {
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
                 		return -1;
@@ -1130,7 +1274,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		} else {
 			/* (5) Check to make sure that the link appears up and stable. */
 			/* Wait for PCS to be aligned */
-			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(index, interface),
+			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(lmac, unit),
 				  cvmx_bgxx_spux_bx_status_t, alignd, ==, 1, 10000)) {
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS not aligned\n", node, interface, index);
 				return -1;
@@ -1138,11 +1282,11 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		}
 
 		/* Clear rcvflt bit (latching high) and read it back */
-		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(lmac, unit));
 		spu_status2.s.rcvflt = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface), spu_status2.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS2(lmac, unit), spu_status2.u64);
 
-		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(lmac, unit));
 		if (spu_status2.s.rcvflt) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n",
 					node, interface, index);
@@ -1152,52 +1296,52 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 				spu_int.u64 = 0;
 				spu_int.s.training_failure = 1;
 				spu_int.s.training_done = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
 
 				/* Restart training */
 				pmd_control.u64 = cvmx_read_csr_node(node,
-							CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+							CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
 				pmd_control.s.train_restart = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
 			}
 			/*cvmx_dprintf("training restarting\n"); */
 			return -1;
 		}
 
 		/* Wait for MAC RX to be ready */
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_RX_CTL(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_RX_CTL(lmac, unit),
 					  cvmx_bgxx_smux_rx_ctl_t, status, ==, 0, 10000)) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not ready\n", node, interface, index);
 			return -1;
 		}
 
 		/* Wait for BGX RX to be idle */
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(lmac, unit),
 				  cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000)) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not idle\n", node, interface, index);
 			return -1;
 		}
 
 		/* Wait for GMX TX to be idle */
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(lmac, unit),
 				  cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000)) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: TX not idle\n", node, interface, index);
 			return -1;
 		}
 
 		/* rcvflt should still be 0 */
-		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(lmac, unit));
 		if (spu_status2.s.rcvflt) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n", node, interface, index);
 			return -1;
 		}
 
 		/* Receive link is latching low. Force it high and verify it */
-		spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
+		spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(lmac, unit));
 		spu_status1.s.rcv_lnk = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface), spu_status1.u64);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS1(lmac, unit), spu_status1.u64);
 
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_STATUS1(index, interface),
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_STATUS1(lmac, unit),
 				cvmx_bgxx_spux_status1_t, rcv_lnk, ==, 1, 10000)) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive link down\n", node, interface, index);
 			return -1;
@@ -1205,14 +1349,14 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	}
 
 	/* (7) Enable packet transmit and receive */
-	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit));
 	spu_misc_control.s.rx_packet_dis = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit), spu_misc_control.u64);
 
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 	cmr_config.s.data_pkt_tx_en = 1;
 	cmr_config.s.data_pkt_rx_en = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 
 	return 0;
 }
@@ -1264,12 +1408,26 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_helper_link_info_t result;
+	unsigned unit, lmac;
 
 	result.u64 = 0;
 
-	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
-	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
-	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return result;
+
+	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(lmac, unit));
+	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(lmac, unit));
+	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(lmac, unit));
+
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		cvmx_printf("ERROR: %s: unimplemented for this model\n",__func__);
+		/* FIXME: o75 needs below logic revised */
+		return result;
+	}
 
 	if ((smu_tx_ctl.s.ls == 0)
 	    && (smu_rx_ctl.s.status == 0)
@@ -1316,16 +1474,23 @@ int __cvmx_helper_bgx_xaui_link_set(int xipd_port, cvmx_helper_link_info_t link_
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_bgxx_spux_status1_t spu_status1;
+	unsigned lmac, unit;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
 
-	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
-	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
-	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
+	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(lmac, unit));
+	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(lmac, unit));
+	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(lmac, unit));
 
 	/* If the link shouldn't be up, then just return */
 	if (!link_info.s.link_up)
@@ -1346,20 +1511,27 @@ int __cvmx_helper_bgx_xaui_configure_loopback(int xipd_port,
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
-	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_spux_control1_t spu_control1;
 	cvmx_bgxx_smux_ext_loopback_t smu_ext_loopback;
+	unsigned unit, lmac;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
 
 	/* Set the internal loop */
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit));
 	spu_control1.s.loopbck = enable_internal;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit), spu_control1.u64);
 	/* Set the external loop */
-	smu_ext_loopback.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_EXT_LOOPBACK(index, interface));
+	smu_ext_loopback.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_EXT_LOOPBACK(lmac, unit));
 	smu_ext_loopback.s.en = enable_external;
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_EXT_LOOPBACK(index, interface), smu_ext_loopback.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_EXT_LOOPBACK(lmac, unit), smu_ext_loopback.u64);
 
 	return __cvmx_helper_bgx_xaui_link_init(index, xiface);
 }
@@ -1370,12 +1542,22 @@ int __cvmx_helper_bgx_xaui_configure_loopback(int xipd_port,
  * on a specific BGX interface/port.
  */
 void __cvmx_helper_bgx_xaui_config_pfc(unsigned node,
-		unsigned interface, unsigned port, bool pfc_enable)
+		unsigned interface, unsigned index, bool pfc_enable)
 {
+	int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned lmac, unit;
 	cvmx_bgxx_smux_cbfc_ctl_t cbfc_ctl;
 
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
+
 	cbfc_ctl.u64 = cvmx_read_csr_node(node,
-		CVMX_BGXX_SMUX_CBFC_CTL(port, interface)
+		CVMX_BGXX_SMUX_CBFC_CTL(lmac, unit)
 		);
 
 	/* Enable all PFC controls if requiested */
@@ -1387,12 +1569,11 @@ void __cvmx_helper_bgx_xaui_config_pfc(unsigned node,
 	cbfc_ctl.s.logl_en = 0xff;
 	cbfc_ctl.s.drp_en = pfc_enable;
 #endif
-#ifdef DEBUG
-	printf("%s: CVMX_BGXX_SMUX_CBFC_CTL(%d,%d)=%#llx\n",
-		__func__, port, interface, (unsigned long long)cbfc_ctl.u64);
-#endif
+	if (debug)
+		cvmx_dprintf("%s: CVMX_BGXX_SMUX_CBFC_CTL(%d,%d)=%#llx\n",
+			__func__, lmac, unit, (unsigned long long)cbfc_ctl.u64);
 	cvmx_write_csr_node(node,
-		CVMX_BGXX_SMUX_CBFC_CTL(port, interface),
+		CVMX_BGXX_SMUX_CBFC_CTL(lmac, unit),
 		cbfc_ctl.u64);
 }
 
@@ -1412,12 +1593,23 @@ void __cvmx_helper_bgx_xaui_config_pfc(unsigned node,
 void cvmx_helper_bgx_rx_pause_ctl(unsigned node, unsigned interface,
 			unsigned port, unsigned ctl_bck, unsigned ctl_drp)
 {
+	int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned lmac, unit;
 	cvmx_bgxx_smux_rx_frm_ctl_t frm_ctl;
 
-	frm_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(port, interface));
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, port);
+
+	if (cvmx_helper_bgx_index(xiface, port, &unit, &lmac) < 0)
+		return;
+
+
+	frm_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(lmac, unit));
 	frm_ctl.s.ctl_bck = ctl_bck;
 	frm_ctl.s.ctl_drp = ctl_drp;
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(port, interface), frm_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(lmac, unit), frm_ctl.u64);
 }
 
 /**
@@ -1437,14 +1629,24 @@ void cvmx_helper_bgx_rx_pause_ctl(unsigned node, unsigned interface,
 void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port,
                                  unsigned cam_accept, unsigned mcast_mode, unsigned bcast_accept)
 {
+	int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned lmac, unit;
         cvmx_bgxx_cmrx_rx_adr_ctl_t adr_ctl;
 
-        adr_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(port, interface));
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, port);
+
+	if (cvmx_helper_bgx_index(xiface, port, &unit, &lmac) < 0)
+		return;
+
+        adr_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(lmac, unit));
         adr_ctl.s.cam_accept = cam_accept;
         adr_ctl.s.mcst_mode = mcast_mode;
         adr_ctl.s.bcst_accept = bcast_accept;
 
-        cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(port, interface), adr_ctl.u64);
+        cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(lmac, unit), adr_ctl.u64);
 }
 
 /**
@@ -1456,54 +1658,60 @@ void cvmx_helper_bgx_tx_options(unsigned node,
 	bool fcs_enable, bool pad_enable)
 {
 	cvmx_bgxx_cmrx_config_t cmr_config;
-	cvmx_bgxx_cmrx_config_t cmr_config0;
 	cvmx_bgxx_gmp_gmi_txx_append_t gmp_txx_append;
 	cvmx_bgxx_gmp_gmi_txx_min_pkt_t gmp_min_pkt;
 	cvmx_bgxx_smux_tx_min_pkt_t smu_min_pkt;
 	cvmx_bgxx_smux_tx_append_t  smu_tx_append;
+	int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned unit, lmac;
+
+	if (__cvmx_helper_bgx_enumerate(xiface) < 0)
+		return;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
 
-	cmr_config0.u64 = cvmx_read_csr_node(node,
-		CVMX_BGXX_CMRX_CONFIG(0, interface));
 	cmr_config.u64 = cvmx_read_csr_node(node,
-		CVMX_BGXX_CMRX_CONFIG(index, interface));
-
-	/* Temp: initial mode setting is only applied to LMAC(0), use that */
-	if (cmr_config0.s.lmac_type != cmr_config.s.lmac_type) {
-		cvmx_dprintf("WARNING: %s: "
-			"%d:BGX(%d).CMR(0).LMAC_TYPE != BGX(%d).CMR(%d).LMAC_TYPE\n",
-			__func__, node, interface, interface, index);
-		cmr_config.s.lmac_type = cmr_config0.s.lmac_type;
-	}
+		CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 
-	if (cmr_config.s.lmac_type == 0) {
-		gmp_min_pkt.u64 = 0;
-		/* per HRM Sec 34.3.4.4 */
-		gmp_min_pkt.s.min_size = 59;
-		cvmx_write_csr_node(node,
-                        CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(index, interface),
-			gmp_min_pkt.u64);
-		gmp_txx_append.u64 = cvmx_read_csr_node(node,
-			CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface));
-		gmp_txx_append.s.fcs = fcs_enable;
-		gmp_txx_append.s.pad = pad_enable;
-		cvmx_write_csr_node(node,
-			CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface),
-			gmp_txx_append.u64);
-	} else {
-		smu_min_pkt.u64 = 0;
-		/* HRM Sec 33.3.4.3 should read 64 */
-		 smu_min_pkt.s.min_size = 0x40;
-		cvmx_write_csr_node(node,
-                        CVMX_BGXX_SMUX_TX_MIN_PKT(index, interface),
-			smu_min_pkt.u64);
-		smu_tx_append.u64 = cvmx_read_csr_node(node,
-			CVMX_BGXX_SMUX_TX_APPEND(index, interface));
-		smu_tx_append.s.fcs_c = fcs_enable;
-		smu_tx_append.s.pad = pad_enable;
-		cvmx_write_csr_node(node,
-			CVMX_BGXX_SMUX_TX_APPEND(index, interface),
-			smu_tx_append.u64);
-	}
+	(void) cmr_config;	/* In case we need LMAC_TYPE later */
+
+	/* Setting options for both BGX subsystems, regardless of LMAC type */
+
+	/* Set GMP (SGMII) Tx options */
+	gmp_min_pkt.u64 = 0;
+	/* per HRM Sec 34.3.4.4 */
+	gmp_min_pkt.s.min_size = 59;
+	cvmx_write_csr_node(node,
+		CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(lmac, unit),
+		gmp_min_pkt.u64);
+	gmp_txx_append.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_GMP_GMI_TXX_APPEND(lmac, unit));
+	gmp_txx_append.s.fcs = fcs_enable;
+	gmp_txx_append.s.pad = pad_enable;
+	cvmx_write_csr_node(node,
+		CVMX_BGXX_GMP_GMI_TXX_APPEND(lmac, unit),
+		gmp_txx_append.u64);
+
+	/* Set SMUX (XAUI/XFI) Tx options */
+	smu_min_pkt.u64 = 0;
+	/* HRM Sec 33.3.4.3 should read 64 */
+	 smu_min_pkt.s.min_size = 0x40;
+	cvmx_write_csr_node(node,
+		CVMX_BGXX_SMUX_TX_MIN_PKT(lmac, unit),
+		smu_min_pkt.u64);
+	smu_tx_append.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_SMUX_TX_APPEND(lmac, unit));
+	smu_tx_append.s.fcs_c = fcs_enable;
+	smu_tx_append.s.pad = pad_enable;
+	cvmx_write_csr_node(node,
+		CVMX_BGXX_SMUX_TX_APPEND(lmac, unit),
+		smu_tx_append.u64);
 }
 
 /**
@@ -1515,41 +1723,221 @@ void cvmx_helper_bgx_tx_options(unsigned node,
  * 		    0 = Force reject all multicast packets
  * 		    1 = Force accept all multicast packets
  * 		    2 = use the address filter CAM.
- * @param mac       mac address for the ipd_port
+ * @param mac       mac address for the ipd_port, or 0 to disable MAC filtering
  */
 void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac)
 {
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
 	int node = xi.node;
-	int index = (xipd_port >> 4) & 0xf;
+	int index;
 	cvmx_bgxx_cmr_rx_adrx_cam_t adr_cam;
 	cvmx_bgxx_cmrx_rx_adr_ctl_t adr_ctl;
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	int saved_state;
+	unsigned unit, lmac;
+
+	if (__cvmx_helper_bgx_enumerate(xiface) < 0)
+		return;
+
+	index = cvmx_helper_get_interface_index_num(xipd_port);
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, xi.node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
 
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 	saved_state = cmr_config.s.enable;
 	cmr_config.s.enable = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
 
 	/* Set the mac */
 	adr_cam.u64 = 0;
-	adr_cam.s.id = index;
-	adr_cam.s.en = 1;
+	adr_cam.s.id = lmac;
+
+	if (mac != 0ull)
+		adr_cam.s.en = 1;
 	adr_cam.s.adr = mac;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8, interface), adr_cam.u64);
 
-	adr_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(index, interface));
-	adr_ctl.s.cam_accept = 1;  /* Accept the packet on DMAC CAM address */
+	cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_ADRX_CAM(lmac * 8, unit), adr_cam.u64);
+
+	adr_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(lmac, unit));
+	if (mac != 0ull)
+		adr_ctl.s.cam_accept = 1;  /* Accept the packet on DMAC CAM address */
+	else
+		adr_ctl.s.cam_accept = 0;  /* No filtering, promiscous */
+
 	adr_ctl.s.mcst_mode = mcst;   /* Use the address filter CAM */
 	adr_ctl.s.bcst_accept = bcst; /* Accept all broadcast packets */
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(index, interface), adr_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(lmac, unit), adr_ctl.u64);
 	/* Set SMAC for PAUSE frames */
-	cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_SMACX(index, interface), mac);
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_SMACX(lmac, unit), mac);
 
 	/* Restore back the interface state */
 	cmr_config.s.enable = saved_state;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit), cmr_config.u64);
+}
+
+/**
+ * Disables the sending of flow control (pause) frames on the specified
+ * BGX port(s).
+ *
+ * @param interface Which interface (0 or 1)
+ * @param port_mask Mask (4bits) of which ports on the interface to disable
+ *                  backpressure on.
+ *                  1 => disable backpressure
+ *                  0 => enable backpressure
+ *
+ * @return 0 on success
+ *         -1 on error
+ *
+ * FIXME: Should change the API to handle a single port in every
+ * invokation, for consistency with other API calls.
+ */
+int cvmx_bgx_set_backpressure_override(int xiface, unsigned port_mask)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	cvmx_bgxx_cmr_rx_ovr_bp_t rx_ovr_bp;
+	int node = xi.node;
+	unsigned unit, lmac;
+	const unsigned index = 0;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d port_mask=%#x\n",
+			__func__, xi.node, xi.interface, (unsigned int)port_mask);
+
+	if (__cvmx_helper_bgx_enumerate(xiface) <= 0)
+		return -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		lmac = ((xi.interface & 1 ) << 1) + (index & 1);
+		unit = xi.interface >> 1;
+		port_mask = port_mask << lmac;
+	} else {
+		unit = xi.interface;
+		lmac = index;
+	}
+
+
+	/* Check for valid arguments */
+	rx_ovr_bp.u64 = 0;
+	rx_ovr_bp.s.en = port_mask;	/* Per port Enable back pressure override */
+	rx_ovr_bp.s.ign_fifo_bp = port_mask;	/* Ignore the RX FIFO full when computing BP */
+
+	cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_OVR_BP(unit), rx_ovr_bp.u64);
+	return 0;
+}
+
+/**
+ * Set maximum packet size for a BGX port
+ *
+ */
+void cvmx_helper_bgx_set_jabber(int xiface, unsigned index,
+	unsigned size)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	unsigned unit, lmac, node;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_BGX))
+		return;
+
+	node = xi.node;
+
+	/* check number of BGX unit against per-model max */
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return;
+
+	/* Get LMAC type from common config */
+	cmr_config.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_CMRX_CONFIG(lmac, unit));
+
+	/* Set GMI or SMUX register based on lmac_type */
+	if (cmr_config.s.lmac_type == 0) {
+		cvmx_write_csr_node(node,
+				CVMX_BGXX_GMP_GMI_RXX_JABBER(lmac, unit), size);
+	} else {
+		cvmx_write_csr_node(node,
+			CVMX_BGXX_SMUX_RX_JABBER(lmac, unit), size);
+	}
 }
+
+/**
+ * Shutdown a BGX port
+ *
+ */
+int cvmx_helper_bgx_shutdown_port(int xiface, int index)
+{
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	unsigned unit, lmac, node;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	node = xi.node;
+
+	if (debug)
+		cvmx_dprintf("%s: interface %u:%d/%d\n",
+		__func__, node, xi.interface, index);
+
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
+
+	/* Disable BGX CMR before we make any changes. */
+	cmr_config.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_CMRX_CONFIG(lmac, unit));
+
+	cmr_config.s.enable = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit),
+		cmr_config.u64);
+
+	/* Clear pending common interrupts */
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_INT(lmac, unit), 0x7);
+
+	if (cmr_config.s.lmac_type == 0) {	/* SGMII */
+		/* Clear GMP interrupts */
+		cvmx_write_csr_node(node,
+			CVMX_BGXX_GMP_GMI_RXX_INT(lmac, unit), 0xfff);
+		cvmx_write_csr_node(node,
+			CVMX_BGXX_GMP_GMI_TXX_INT(lmac, unit), 0x1f);
+		/* Wait for GMX to be idle */
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node,
+			CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit),
+			cvmx_bgxx_gmp_gmi_prtx_cfg_t, rx_idle, ==, 1, 10000) ||
+		    CVMX_WAIT_FOR_FIELD64_NODE(node,
+			CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit),
+			cvmx_bgxx_gmp_gmi_prtx_cfg_t, tx_idle, ==, 1, 10000)) {
+				cvmx_printf("ERROR: %s: SGMII: "
+				"Timeout waiting for port %u:%d/%d to stop\n",
+				__func__, node, xi.interface, index);
+				return -1;
+			}
+		/* Read GMX CFG again to make sure the disable completed */
+		cvmx_read_csr_node(node,
+			CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit));
+	} else {		/* XAUI/XFI/10-KR */
+		/* Clear all pending SMUX interrupts */
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(lmac, unit),
+			0xfff);
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(lmac, unit),
+			0x1f);
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit),
+			0x7fff);
+
+		/* Wait for GMX RX to be idle */
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node,
+			CVMX_BGXX_SMUX_CTRL(lmac, unit),
+			cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000) ||
+		    CVMX_WAIT_FOR_FIELD64_NODE(node,
+			CVMX_BGXX_SMUX_CTRL(lmac, unit),
+			cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000)) {
+				cvmx_printf("ERROR: %s: XAUI: "
+				"Timeout waiting for port %u:%d/%d to stop\n",
+				__func__, node, xi.interface, index);
+				return -1;
+		}
+	}
+	return 0;
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 5c726ea..2c360d1 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -52,6 +52,7 @@
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-helper-ilk.h>
+#include <asm/octeon/cvmx-helper-bgx.h>
 #include <asm/octeon/cvmx-ilk.h>
 #include <asm/octeon/cvmx-range.h>
 #include <asm/octeon/cvmx-global-resources.h>
@@ -66,6 +67,7 @@
 #include "cvmx-ilk.h"
 #include "cvmx-adma.h"
 #include "cvmx-helper-ilk.h"
+#include "cvmx-helper-bgx.h"
 #include "cvmx-pip.h"
 #include "cvmx-range.h"
 #include "cvmx-global-resources.h"
@@ -157,7 +159,10 @@ static const int dbg = 0;
 int __cvmx_helper_cfg_pknd(int xiface, int index)
 {
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	return cvmx_cfg_port[xi.node][xi.interface][index].ccpp_pknd;
+	int pkind;
+
+	pkind = cvmx_cfg_port[xi.node][xi.interface][index].ccpp_pknd;
+	return pkind;
 }
 
 int __cvmx_helper_cfg_bpid(int xiface, int index)
@@ -505,27 +510,22 @@ void cvmx_helper_cfg_init_pko_port_map(void)
 void cvmx_helper_cfg_set_jabber_and_frame_max()
 {
 	int interface, port;
+	/*Set the frame max size and jabber size to 65535. */
+	const unsigned max_frame = 65535;
 
+	// FIXME: should support node argument for remote node init
 	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
 		int ipd_port;
 		int node = cvmx_get_node_num();
 
-		/*Set the frame max size and jabber size to 65535. */
 		for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
-			/* Set the frame max size and jabber size to 65535, as the defaults
-		   	are too small. */
 			int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 			cvmx_helper_interface_mode_t imode = cvmx_helper_interface_get_mode(xiface);
 			int num_ports = cvmx_helper_ports_on_interface(interface);
-
+			// FIXME: should be an easier way to determine
+			// that an interface is Ethernet/BGX
 			switch (imode) {
 			case CVMX_HELPER_INTERFACE_MODE_SGMII:
-				for (port = 0; port < num_ports; port++) {
-					ipd_port = cvmx_helper_get_ipd_port(xiface, port);
-					cvmx_pki_set_max_frm_len(ipd_port, -1);
-					cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_RXX_JABBER(port, interface), 65535);
-				}
-				break;
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XLAUI:
@@ -534,8 +534,10 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				for (port = 0; port < num_ports; port++) {
 					ipd_port = cvmx_helper_get_ipd_port(xiface, port);
-					cvmx_pki_set_max_frm_len(ipd_port, -1);
-					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_JABBER(port, interface), 65535);
+					cvmx_pki_set_max_frm_len(
+						ipd_port, max_frame);
+					cvmx_helper_bgx_set_jabber(
+						xiface, port, max_frame);
 				}
 				break;
 			default:
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index a04ac3d..a5a5958 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -292,7 +292,7 @@ int __cvmx_helper_pki_setup_sso_groups(int node)
 	uint8_t core_mask_set;
 
 	/* try to reserve sso groups and configure them if they are not configured */
-	grp = cvmx_sso_allocate_group_range(node, &pki_dflt_sso_grp[node].group, 1);
+	grp = cvmx_sso_reserve_group_range(node, &pki_dflt_sso_grp[node].group, 1);
 	if (grp == CVMX_RESOURCE_ALLOC_FAILED)
 		return -1;
 	else if (grp == CVMX_RESOURCE_ALREADY_RESERVED)
@@ -755,7 +755,7 @@ int __cvmx_helper_pki_qos_rsrcs(int node, struct cvmx_pki_qos_schd *qossch)
 	if (qossch->sso_grp_per_qos && qossch->sso_grp < 0) {
 		//unsigned grp_node;
 		//grp_node = (abs)(qossch->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
-		rs = cvmx_sso_allocate_group(node);
+		rs = cvmx_sso_reserve_group(node);
 		if (rs < 0) {
 			cvmx_dprintf("pki-helper:qos-rsrc: ERROR: sso grp not available\n");
 			return rs;
@@ -816,7 +816,7 @@ int __cvmx_helper_pki_port_rsrcs(int node, struct cvmx_pki_prt_schd *prtsch)
 	if (prtsch->sso_grp_per_prt && prtsch->sso_grp < 0) {
 		//unsigned grp_node;
 		//grp_node = (abs)(prtsch->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
-		rs = cvmx_sso_allocate_group(node);
+		rs = cvmx_sso_reserve_group(node);
 		if (rs < 0) {
 			cvmx_printf("ERROR: %s: sso grp not available\n", __func__);
 			return rs;
@@ -878,7 +878,7 @@ int __cvmx_helper_pki_intf_rsrcs(int node, struct cvmx_pki_intf_schd *intf)
 	if (intf->sso_grp_per_intf && intf->sso_grp < 0) {
 		//unsigned grp_node;
 		//grp_node = (abs)(intf->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
-		rs = cvmx_sso_allocate_group(node);
+		rs = cvmx_sso_reserve_group(node);
 		if (rs < 0) {
 			cvmx_printf("ERROR: %s: sso grp not available\n", __func__);
 			return rs;
@@ -984,7 +984,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
 	if (gblsch->setup_sso_grp && gblsch->sso_grp < 0) {
 		//unsigned grp_node;
 		//grp_node = (abs)(gblsch->setup_sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);/*vinita_to_do to extract node*/
-		rs = cvmx_sso_allocate_group(node);
+		rs = cvmx_sso_reserve_group(node);
 		if (rs < 0) {
 			cvmx_dprintf("pki-helper:gbl: ERROR: sso grp not available\n");
 			return rs;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 63911b0..dd63171 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -696,7 +696,8 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 
 	if(OCTEON_IS_MODEL(OCTEON_CN78XX))
 		pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
-	else if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+		OCTEON_IS_MODEL(OCTEON_CN75XX))
 		pko_mac_num = 0x0F; /* MAC# 16 !? virtual MAC for NULL */
 	else
 		return -1;
@@ -975,7 +976,8 @@ int cvmx_helper_pko3_init_interface(int xiface)
 	fcs_enable = __cvmx_helper_get_has_fcs(xiface);
 	pad_enable = __cvmx_helper_get_pko_padding(xiface);
 
-	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+	// XXX for some reason, turning off BGX FCS does not work on o75
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CN75XX))
 		pad_enable_pko = false;
 	else
 		pad_enable_pko = pad_enable;
@@ -991,8 +993,11 @@ int cvmx_helper_pko3_init_interface(int xiface)
 
 		if(OCTEON_IS_MODEL(OCTEON_CN78XX))
 			num_bgx_interfaces = 6;
+		/* o73/o75 has every half-BGX as a separate interface */
 		if(OCTEON_IS_MODEL(OCTEON_CN73XX))
-			num_bgx_interfaces = 3;
+			num_bgx_interfaces = 6;
+		if(OCTEON_IS_MODEL(OCTEON_CN75XX))
+			num_bgx_interfaces = 2;
 
 		/* Open interface/port DQs to allow transmission to begin */
 		res = __cvmx_pko3_helper_dqs_activate(xiface,
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 3c5cdb0..a3611b6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -144,7 +144,7 @@ static const struct ipd_port_map ipd_port_map_68xx[CVMX_HELPER_MAX_IFACE] = {
  * Interface number to ipd port map for the octeon 78xx.
  *
  * This mapping corresponds to WQE(CHAN) enumeration in
- * HRM Sections 11.15, MKI_CHAN_E, Section 11.6
+ * HRM Sections 11.15, PKI_CHAN_E, Section 11.6
  *
  */
 static const struct ipd_port_map ipd_port_map_78xx[CVMX_HELPER_MAX_IFACE] = {
@@ -162,18 +162,28 @@ static const struct ipd_port_map ipd_port_map_78xx[CVMX_HELPER_MAX_IFACE] = {
 
 /**
  * @INTERNAL
- * Interface number to ipd port map for the octeon 78xx.
- *
- * This mapping corresponds to WQE(CHAN) enumeration in
- * HRM Sections 11.15, MKI_CHAN_E, Section 11.6
- *
+ * Interface number to ipd port map for the octeon 73xx.
  */
 static const struct ipd_port_map ipd_port_map_73xx[CVMX_HELPER_MAX_IFACE] = {
-	{GMII,	0x800,	0x83f,	0x00},		/* Interface 0 - BGX0 */
-	{GMII,	0x900,	0x93f,	0x00},		/* Interface 1  -BGX1 */
-	{GMII,	0xa00,	0xa3f,	0x00},		/* Interface 2  -BGX2 */
-	{NPI,	0x100,	0x13f,	0x00},		/* Interface 3 - DPI */
-	{LB,	0x000,	0x03f,	0x00},		/* Interface 4 - LOOPBACK */
+	{GMII,	0x800,	0x81f,	0x00},		/* Interface 0 - BGX(0,0-1) */
+	{GMII,	0x820,	0x83f,	0x00},		/* Interface 1 - BGX(0,2-3) */
+	{GMII,	0x900,	0x91f,	0x00},		/* Interface 2  -BGX(1,0-1) */
+	{GMII,	0x920,	0x93f,	0x00},		/* Interface 3  -BGX(1,2-3) */
+	{GMII,	0xa00,	0xa1f,	0x00},		/* Interface 4  -BGX(2,0-1) */
+	{GMII,	0xa20,	0xa3f,	0x00},		/* Interface 5  -BGX(2,2-3) */
+	{NPI,	0x100,	0x13f,	0x00},		/* Interface 6 - DPI */
+	{LB,	0x000,	0x03f,	0x00},		/* Interface 7 - LOOPBACK */
+};
+
+/**
+ * @INTERNAL
+ * Interface number to ipd port map for the octeon 75xx.
+ */
+static const struct ipd_port_map ipd_port_map_75xx[CVMX_HELPER_MAX_IFACE] = {
+	{GMII,	0x800,	0x81f,	0x00},		/* Interface 0 - BGX0,0-1 */
+	{GMII,	0x820,	0x83f,	0x00},		/* Interface 1 - BGX0,2-3 */
+	{NPI,	0x100,	0x13f,	0x00},		/* Interface 2 - DPI */
+	{LB,	0x000,	0x03f,	0x00},		/* Interface 3 - LOOPBACK */
 };
 
 
@@ -962,6 +972,9 @@ int cvmx_helper_get_ipd_port(int xiface, int index)
 		} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
 			port_map = ipd_port_map_73xx;
 			ipd_port = 0;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+			port_map = ipd_port_map_75xx;
+			ipd_port = 0;
 		}
 		else
 			return -1;
@@ -1105,6 +1118,17 @@ int cvmx_helper_get_interface_num(int ipd_port)
 				return cvmx_helper_node_interface_to_xiface(xp.node, i);
 		}
 		return -1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		const struct ipd_port_map	*port_map;
+		int				i;
+		struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+		port_map = ipd_port_map_75xx;
+		for (i = 0; i < CVMX_HELPER_MAX_IFACE; i++) {
+			if (xp.port >= port_map[i].first_ipd_port &&
+			    xp.port <= port_map[i].last_ipd_port)
+				return cvmx_helper_node_interface_to_xiface(xp.node, i);
+		}
+		return -1;
 	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX) && ipd_port == 24) {
 		return 4;
 	} else {
@@ -1160,6 +1184,11 @@ int cvmx_helper_get_interface_index_num(int ipd_port)
 			port_map = ipd_port_map_73xx;
 			ipd_port = xp.port;
 		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+			struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+			port_map = ipd_port_map_75xx;
+			ipd_port = xp.port;
+		}
 		else
 			return -1;
 
@@ -1176,20 +1205,37 @@ int cvmx_helper_get_interface_index_num(int ipd_port)
 
 		/* Convert the ipd port to the interface port */
 		switch (type) {
+		/* Ethernet interfaces have a channel in lower 4 bits
+		 * that is does not discriminate traffic, and is ignored.
+		 */
 		case GMII:
-			port = ((ipd_port & 0xff) >> 6);
-			return port ? (port - 1) : ((ipd_port & 0xff) >> 4);
-			break;
+			port = ipd_port - port_map[i].first_ipd_port;
 
+			/* CN68XX adds 0x40 to IPD_PORT when in XAUI/RXAUI 
+			 * mode of operation, adjust for that case
+			 */
+			if (port >= port_map[i].ipd_port_adj)
+				port -= port_map[i].ipd_port_adj;
+
+			port >>= 4;
+//	cvmx_dprintf("%s: ipd_port=%#x port=%d\n", __func__, ipd_port, port);
+			return port;
+
+		/*
+		 * These interfaces do not have physical ports,
+		 * but have logical channels instead that separate
+		 * traffic into logical streams
+		 */
 		case ILK:
 		case NPI:
 		case LB:
-			return ipd_port & 0xff;
-			break;
+			port = ipd_port - port_map[i].first_ipd_port;
+//	cvmx_dprintf("%s: ipd_port=%#x port=%d\n", __func__, ipd_port, port);
+			return port;
 
 		default:
-			cvmx_dprintf("cvmx_helper_get_interface_index_num: "
-				     "Illegal IPD port number %d\n", ipd_port);
+			cvmx_printf("ERROR: %s: Illegal IPD port number %#x\n",
+				__func__, ipd_port);
 			return -1;
 		}
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 5ab09ba..c489b88 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -683,8 +683,10 @@ int cvmx_helper_get_number_of_interfaces(void)
 		return 5;
 	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 10;
+	else if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return 4;
 	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
-		return 5;
+		return 8;
 	else
 		return 3;
 }
@@ -831,7 +833,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 static cvmx_helper_interface_mode_t __cvmx_get_mode_cn73xx(int interface)
 {
 	/* SGMII/XAUI/XLAUI/XFI */
-	if (interface < 3) {
+	if (interface < 6) {
 		int qlm = cvmx_qlm_interface(interface);
 		enum cvmx_qlm_mode qlm_mode;
 
@@ -841,25 +843,170 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn73xx(int interface)
 		}
 		qlm_mode = cvmx_qlm_get_mode(qlm);
 
-		if (qlm_mode == CVMX_QLM_MODE_SGMII)
+		switch (qlm_mode) {
+		case CVMX_QLM_MODE_SGMII:
+		case CVMX_QLM_MODE_RGMII_SGMII:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_sgmii;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_XAUI:
+		case CVMX_QLM_MODE_RGMII_XAUI:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_xaui;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_RXAUI:
+		case CVMX_QLM_MODE_RGMII_RXAUI:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_XLAUI:
+		case CVMX_QLM_MODE_RGMII_XLAUI:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_xlaui;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_XFI:
+		case CVMX_QLM_MODE_RGMII_XFI:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_xfi;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_10G_KR:
+		case CVMX_QLM_MODE_RGMII_10G_KR:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_10G_KR;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_40G_KR4:
+		case CVMX_QLM_MODE_RGMII_40G_KR4:
+			if ((interface & 0x1) == 0)
+				iface_ops[interface] = &iface_ops_bgx_40G_KR4;
+			else
+				iface_ops[interface] = &iface_ops_dis;
+			break;
+		case CVMX_QLM_MODE_SGMII_10G_KR:
+		case CVMX_QLM_MODE_RGMII_SGMII_10G_KR:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_sgmii;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_10G_KR;
+			break;
+		case CVMX_QLM_MODE_SGMII_XFI:
+		case CVMX_QLM_MODE_RGMII_SGMII_XFI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_sgmii;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_xfi;
+			break;
+		case CVMX_QLM_MODE_SGMII_RXAUI:
+		case CVMX_QLM_MODE_RGMII_SGMII_RXAUI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_sgmii;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			break;
+		case CVMX_QLM_MODE_40G_KR4_RXAUI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_40G_KR4;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			break;
+		case CVMX_QLM_MODE_XLAUI_RXAUI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_xlaui;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			break;
+		case CVMX_QLM_MODE_RGMII_10G_KR_SGMII:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_10G_KR;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_sgmii;
+			break;
+		case CVMX_QLM_MODE_RGMII_XFI_SGMII:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_xfi;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_sgmii;
+			break;
+		case CVMX_QLM_MODE_RGMII_10G_KR_RXAUI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_10G_KR;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			break;
+		case CVMX_QLM_MODE_RGMII_XFI_RXAUI:
+			if (interface & 0x1)
+				iface_ops[interface] = &iface_ops_bgx_xfi;	
+			else
+				iface_ops[interface] = &iface_ops_bgx_rxaui;
+			break;
+		default:
+			iface_ops[interface] = &iface_ops_dis;
+			break;
+		}
+	} else if (interface == 6) /* DPI */
+		iface_ops[interface] = &iface_ops_npi;
+	else if (interface == 7) /* LOOP */
+		iface_ops[interface] = &iface_ops_loop;
+	else
+		iface_ops[interface] = &iface_ops_dis;
+
+	return iface_ops[interface]->mode;
+}
+
+
+/**
+ * @INTERNAL
+ * Return interface mode for CN75XX.
+ *
+ * CN75XX has a single BGX block, which is attached to two DLMs,
+ * the first, GSER4 only supports SGMII mode, while the second,
+ * GSER5 supports 1G/10G single late modes, i.e. SGMII, XFI, 10G-KR.
+ * Each half-BGX is thus designated as a separate interface with two ports each.
+ */
+static cvmx_helper_interface_mode_t __cvmx_get_mode_cn75xx(int interface)
+{
+	/* BGX0: SGMII/XFI */
+	if (interface < 2) {
+		// int qlm = cvmx_qlm_interface(interface);
+		enum cvmx_qlm_mode qlm_mode;
+
+		if (interface == 0) {
+			qlm_mode =  CVMX_QLM_MODE_SGMII;
+		} else {
+			qlm_mode = CVMX_QLM_MODE_XFI;
+		}
+
+		// FIXME: DLM3 could be either SGMII or XFI mode
+		// should detect dynamically from GSER5 configuration
+
+		switch (qlm_mode) {
+		case CVMX_QLM_MODE_SGMII:
 			iface_ops[interface] = &iface_ops_bgx_sgmii;
-		else if (qlm_mode == CVMX_QLM_MODE_XAUI)
-			iface_ops[interface] = &iface_ops_bgx_xaui;
-		else if (qlm_mode == CVMX_QLM_MODE_RXAUI)
-			iface_ops[interface] = &iface_ops_bgx_rxaui;
-		else if (qlm_mode == CVMX_QLM_MODE_XLAUI)
-			iface_ops[interface] = &iface_ops_bgx_xlaui;
-		else if (qlm_mode == CVMX_QLM_MODE_XFI)
+			break;
+		case CVMX_QLM_MODE_XFI:
 			iface_ops[interface] = &iface_ops_bgx_xfi;
-		else if (qlm_mode == CVMX_QLM_MODE_10G_KR)
+			break;
+		case CVMX_QLM_MODE_10G_KR:
 			iface_ops[interface] = &iface_ops_bgx_10G_KR;
-		else if (qlm_mode == CVMX_QLM_MODE_40G_KR4)
-			iface_ops[interface] = &iface_ops_bgx_40G_KR4;
-		else
+			break;
+		default:
 			iface_ops[interface] = &iface_ops_dis;
-	} else if (interface == 3) /* DPI */
+			break;
+		}
+	} else if (interface == 2) /* DPI */
 		iface_ops[interface] = &iface_ops_npi;
-	else if (interface == 4) /* LOOP */
+	else if (interface == 3) /* LOOP */
 		iface_ops[interface] = &iface_ops_loop;
 	else
 		iface_ops[interface] = &iface_ops_dis;
@@ -1094,7 +1241,6 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_octeon2(int interface)
  */
 cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int xiface)
 {
-	union cvmx_gmxx_inf_mode mode;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	if (xi.interface < 0 ||
@@ -1106,8 +1252,11 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int xiface)
 	 * simply return it. Otherwise, fall through the rest of the code to
 	 * determine the interface mode and cache it in iface_ops.
 	 */
-	if (iface_node_ops[xi.node][xi.interface] != NULL)
-		return iface_node_ops[xi.node][xi.interface]->mode;
+	if (iface_node_ops[xi.node][xi.interface] != NULL) {
+		cvmx_helper_interface_mode_t mode;
+		mode = iface_node_ops[xi.node][xi.interface]->mode;
+		return mode;
+	}
 
 	/*
 	 * OCTEON III models
@@ -1118,6 +1267,12 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int xiface)
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return __cvmx_get_mode_cn78xx(xiface);
 
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
+		cvmx_helper_interface_mode_t mode;
+		mode = __cvmx_get_mode_cn75xx(xiface);
+		return mode;
+	}
+
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return __cvmx_get_mode_cn73xx(xiface);
 
@@ -1162,6 +1317,7 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int xiface)
 		/* Interface 1 is always disabled on CN31XX and CN30XX */
 		iface_ops[xi.interface] = &iface_ops_dis;
 	else {
+		union cvmx_gmxx_inf_mode mode;
 		mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(xi.interface));
 
 		if (OCTEON_IS_MODEL(OCTEON_CN56XX) ||
@@ -1636,7 +1792,8 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 		if (OCTEON_IS_MODEL(OCTEON_CN68XX) ||
 		    OCTEON_IS_MODEL(OCTEON_CN78XX))
 			smi_inf = 4;
-		else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		else if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+			OCTEON_IS_MODEL(OCTEON_CN75XX))
 			smi_inf = 2;
 		else if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
 			 OCTEON_IS_MODEL(OCTEON_CN58XX) ||
@@ -1802,34 +1959,6 @@ int cvmx_agl_set_backpressure_override(uint32_t interface, uint32_t port_mask)
 }
 
 /**
- * Disables the sending of flow control (pause) frames on the specified
- * BGX port(s).
- *
- * @param interface Which interface (0 or 1)
- * @param port_mask Mask (4bits) of which ports on the interface to disable
- *                  backpressure on.
- *                  1 => disable backpressure
- *                  0 => enable backpressure
- *
- * @return 0 on success
- *         -1 on error
- */
-int cvmx_bgx_set_backpressure_override(uint32_t xiface, uint32_t port_mask)
-{
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	cvmx_bgxx_cmr_rx_ovr_bp_t rx_ovr_bp;
-	int node = xi.node;
-	int interface = xi.interface;
-
-	/* Check for valid arguments */
-	rx_ovr_bp.u64 = 0;
-	rx_ovr_bp.s.en = port_mask;	/* Per port Enable back pressure override */
-	rx_ovr_bp.s.ign_fifo_bp = port_mask;	/* Ignore the RX FIFO full when computing BP */
-	cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_OVR_BP(interface), rx_ovr_bp.u64);
-	return 0;
-}
-
-/**
  * Helper function for global packet IO shutdown
  */
 int cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
@@ -1841,85 +1970,15 @@ int cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 	/* Shut down all interfaces and disable TX and RX on all ports */
 	for (interface = 0; interface < num_interfaces; interface++) {
 		int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
-		switch (cvmx_helper_interface_get_mode(xiface)) {
-		case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
-		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
-		case CVMX_HELPER_INTERFACE_MODE_XFI:
-		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
-		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
-		{
-			cvmx_bgxx_cmrx_config_t cmr_config;
-			int index;
-			int num_ports = cvmx_helper_ports_on_interface(xiface);
-			if (num_ports > 4)
-				num_ports = 4;
+		int index;
+		int num_ports = cvmx_helper_ports_on_interface(xiface);
 
-			cvmx_bgx_set_backpressure_override(xiface, 0xf);
-			for (index = 0; index < num_ports; index++) {
-				if (!cvmx_helper_is_port_valid(xiface, index))
-					continue;
+		for (index = 0; index < num_ports; index++) {
+			if (!cvmx_helper_is_port_valid(xiface, index))
+				continue;
 
-				/* Disable GMX before we make any changes. Remember the enable state */
-				cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-				cmr_config.s.enable = 0;
-				cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-
-				/* Clear all error interrupts before enabling the interface. */
-				if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface), ~0x0ull);
-					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface), ~0x0ull);
-					cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), ~0x0ull);
-				}
-
-				/* Wait for GMX RX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
-				  			cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000))
-					return -1;
-
-				/* Wait for GMX TX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
-				  			cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000))
-					return -1;
-
-
-			}
-			break;
-		}
-		case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		{
-			cvmx_bgxx_cmrx_config_t cmr_config;
-			int index;
-			int num_ports = cvmx_helper_ports_on_interface(xiface);
-			if (num_ports > 4)
-				num_ports = 4;
-
-			cvmx_bgx_set_backpressure_override(xiface, 0xf);
-			for (index = 0; index < num_ports; index++) {
-				if (!cvmx_helper_is_port_valid(xiface, index))
-					continue;
-				/* Disable GMX before we make any changes. Remember the enable state */
-				cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-				cmr_config.s.enable = 0;
-				cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-
-				/* Wait for GMX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
-				  		cvmx_bgxx_gmp_gmi_prtx_cfg_t, rx_idle, ==, 1, 10000) ||
-	    		    	CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
-						cvmx_bgxx_gmp_gmi_prtx_cfg_t, tx_idle, ==, 1, 10000)) {
-					cvmx_dprintf("%d:SGMII%d: Timeout waiting for port %d to be idle\n",
-			     				node, interface, index);
-					return -1;
-				}
-
-				/* Read GMX CFG again to make sure the disable completed */
-				cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface));
-			}
-			break;
-		}
-		default:
-			break;
+			cvmx_bgx_set_backpressure_override(xiface, 1 << index);
+			cvmx_helper_bgx_shutdown_port(xiface, index);
 		}
 	}
 
@@ -1943,22 +2002,15 @@ int cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 		case CVMX_HELPER_INTERFACE_MODE_SGMII:
 		{
-			cvmx_bgxx_cmr_rx_adrx_cam_t cmr_rx_adr;
 			int index;
 			int num_ports = cvmx_helper_ports_on_interface(xiface);
-			if (num_ports > 4)
-				num_ports = 4;
 
 			for (index = 0; index < num_ports; index++) {
 				if (!cvmx_helper_is_port_valid(xiface, index))
 					continue;
-				cmr_rx_adr.u64 = 0;
-				cmr_rx_adr.s.id = index;
-				cmr_rx_adr.s.en = 0;
-				cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8, interface),
-					       cmr_rx_adr.u64);
-				/* Disable multicast and broadcast packets */
-				cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(index, interface), 0);
+
+				/* Reset MAC filtering */
+				cvmx_helper_bgx_rx_adr_ctl(node, interface, index, 0, 0, 0);
 			}
 			break;
 		}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 46d2bc8..03fa623 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -109,7 +109,7 @@ int cvmx_pko3_get_queue_base(int ipd_port)
 	if (cvmx_likely(dq_table[i].dq_count > 0))
 		ret = xp.node << 10 | dq_table[i].dq_base;
 	else if (debug)
-		cvmx_dprintf("ERROR: %s: no queues for ipd_port=%#x\n",
+		cvmx_printf("ERROR: %s: no queues for ipd_port=%#x\n",
 			__func__, ipd_port);
 
 	return ret;
@@ -226,7 +226,7 @@ int __cvmx_pko3_ipd_dq_register(int xiface, int index,
 		int p;
 		p = cvmx_helper_get_ipd_port(xiface, index);
 		if (p < 0) {
-			cvmx_dprintf("ERROR: %s: xiface %#x has no IPD port\n",
+			cvmx_printf("ERROR: %s: xiface %#x has no IPD port\n",
 			__func__, xiface);
 			return -1;
 		}
@@ -249,7 +249,7 @@ int __cvmx_pko3_ipd_dq_register(int xiface, int index,
 
 	/* Check the IPD port has not already been configured */
 	if(dq_table[i].dq_count > 0 ) {
-		cvmx_dprintf("%s: ERROR: IPD %#x already registered\n",
+		cvmx_printf("%s: ERROR: IPD %#x already registered\n",
 			__func__, ipd_port);
 		return -1;
 	}
@@ -282,7 +282,7 @@ int __cvmx_pko3_ipd_dq_unregister(int xiface, int index)
 		int p;
 		p = cvmx_helper_get_ipd_port(xiface, index);
 		if (p < 0) {
-			cvmx_dprintf("ERROR: %s: xiface %#x has no IPD port\n",
+			cvmx_printf("ERROR: %s: xiface %#x has no IPD port\n",
 			__func__, xiface);
 			return -1;
 		}
@@ -301,7 +301,7 @@ int __cvmx_pko3_ipd_dq_unregister(int xiface, int index)
 	dq_table = __cvmx_pko3_dq_table + CVMX_PKO3_IPD_NUM_MAX * xi.node;
 
 	if (dq_table[i].dq_count == 0) {
-		cvmx_dprintf("%s:ipd=%#x already released\n",
+		cvmx_printf("WARNING: %s:ipd=%#x already released\n",
 			__func__, ipd_port);
 		return -1;
 	}
@@ -365,9 +365,30 @@ static uint16_t cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
 	};
+	// FIXME: These values are wild guess, check with CSR again!
+	static const uint8_t xchan_base_cn75xx[16] = {
+		/* IPD 0x000 */ 0x080 >> 4,	/* LBK */
+		/* IPD 0x100 */ 0x0c0 >> 4,	/* DPI */
+		/* IPD 0x200 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x300 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x400 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x500 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x600 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x700 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x800 */ 0x000 >> 4,	/* BGX0 */
+		/* IPD 0x900 */ 0x040 >> 4,	/* BGX1 */
+		/* IPD 0xa00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xb00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xc00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xd00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
+	};
 
         if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		xchan_base = xchan_base_cn73xx;
+        if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		xchan_base = xchan_base_cn75xx;
         if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		xchan_base = xchan_base_cn78xx;
 
@@ -421,8 +442,11 @@ void cvmx_pko3_map_channel(unsigned node,
 	/* Convert CHAN_E into compressed channel */
 	xchan =  cvmx_pko3_chan_2_xchan(channel);
 
+	if (debug)
+		cvmx_dprintf("%s: ipd_port=%#x xchan=%#x\n", __func__, channel, xchan);
+
 	if(xchan & 0xf000) {
-		cvmx_dprintf("%s: ERROR: channel %#x not recognized\n",
+		cvmx_printf("%s: ERROR: channel %#x not recognized\n",
 			__func__, channel);
 		return;
 	}
@@ -860,13 +884,13 @@ int cvmx_pko3_sq_config_children(unsigned int node,
 		num_elem = NUM_ELEMENTS(pko3_cn78xx_cfg.lvl);
 		cfg_tbl = &pko3_cn78xx_cfg;
 	}
-        if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		num_elem = NUM_ELEMENTS(pko3_cn73xx_cfg.lvl);
 		cfg_tbl = &pko3_cn73xx_cfg;
 	}
 
 	if (cfg_tbl == NULL || child_level >= num_elem) {
-		cvmx_dprintf("ERROR: %s: model or level %#x invalid\n",
+		cvmx_printf("ERROR: %s: model or level %#x invalid\n",
 			__func__, child_level);
 		return -1;
 	}
@@ -875,7 +899,7 @@ int cvmx_pko3_sq_config_children(unsigned int node,
 
 	if (cfg_tbl->lvl[child_level].cfg_sq_func == NULL ||
 	    cfg_tbl->lvl[child_level].parent_level == 0) {
-		cvmx_dprintf("ERROR: %s: queue level %#x invalid\n",
+		cvmx_printf("ERROR: %s: queue level %#x invalid\n",
 			__func__, child_level);
 		return -1;
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
index 62c952e..2c5bbbc 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
@@ -94,7 +94,7 @@ static inline int __cvmx_pko3_get_num_queues(enum cvmx_pko3_level_e level)
 		ne = NUM_ELEMENTS(cvmx_pko_num_queues_78XX);
 		nq =  cvmx_pko_num_queues_78XX[level];
 	}
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		ne = NUM_ELEMENTS(cvmx_pko_num_queues_73XX);
 		nq =  cvmx_pko_num_queues_73XX[level];
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 64d0ca7..7edc2b6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -135,11 +135,11 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	const unsigned timeout = 100;	/* 100 milliseconds */
 
 	if (node != (aura >> 10))
-		cvmx_dprintf("WARNING: AURA vs PKO node mismatch\n");
+		cvmx_printf("WARNING: AURA vs PKO node mismatch\n");
 
 	pko_enable.u64 = cvmx_read_csr_node(node, CVMX_PKO_ENABLE);
 	if (pko_enable.s.enable) {
-		cvmx_dprintf("WARNING: %s: PKO already enabled on node %u\n",
+		cvmx_printf("WARNING: %s: PKO already enabled on node %u\n",
 			__func__, node);
 		return 0;
 	}
@@ -174,7 +174,7 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 
 	if (!pko_status.s.pko_rdy) {
 		dpfi_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
-		cvmx_dprintf("ERROR: %s: PKO DFPI failed, "
+		cvmx_printf("ERROR: %s: PKO DFPI failed, "
 			"PKO_STATUS=%#llx DPFI_STATUS=%#llx\n", __func__,
 			(unsigned long long) pko_status.u64,
 			(unsigned long long) dpfi_status.u64);
@@ -204,7 +204,7 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	if (pko_status.s.pko_rdy)
 		return 0;
 
-	cvmx_dprintf("ERROR: %s: failed, PKO_STATUS=%#llx\n", __func__,
+	cvmx_printf("ERROR: %s: failed, PKO_STATUS=%#llx\n", __func__,
 		(unsigned long long) pko_status.u64);
 	return -1;
 }
@@ -239,7 +239,7 @@ int cvmx_pko3_hw_disable(int node)
 		if (ptf_status.s.mac_num == 0x1f)
 			continue;
 		if (ptf_status.s.in_flight_cnt != 0) {
-			cvmx_dprintf("%s: MAC %d in-flight %d\n",
+			cvmx_printf("WARNING: %s: MAC %d in-flight %d\n",
 				__func__, mac_num, ptf_status.s.in_flight_cnt);
 			mac_num --;
 			cvmx_wait(1000);
@@ -252,7 +252,7 @@ int cvmx_pko3_hw_disable(int node)
 	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
 
 	/* Assign NULL MAC# for L1/SQ disabled state */
-        if(OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		null_mac_num = 0x0f;
 		null_fifo_num = 0x1f;
 		fifo_grp_count = 4;
@@ -339,7 +339,7 @@ int cvmx_pko3_hw_disable(int node)
 	CVMX_DUMP_REGX(CVMX_PKO_DPFI_FLUSH);
 
 	if (dpfi_status.s.cache_flushed == 0) {
-		cvmx_dprintf("%s: ERROR: timeout waiting for PKO3 ptr flush\n",
+		cvmx_printf("%s: ERROR: timeout waiting for PKO3 ptr flush\n",
 			__FUNCTION__);
 		return -1;
 	}
@@ -394,7 +394,7 @@ int cvmx_pko_dq_open(int node, int dq)
 	if (dqstatus == PKO_DQSTATUS_ALREADY)
 		return 0;
 	if (dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("%s: ERROR: Failed to open dq :%u: %s\n",
+		cvmx_printf("%s: ERROR: Failed to open dq :%u: %s\n",
 				__FUNCTION__, dq,
 				pko_dqstatus_error(dqstatus));
 		return -1;
@@ -430,7 +430,7 @@ int cvmx_pko3_dq_close(int node, int dq)
 		return 0;
 
 	if (dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("WARNING: %s: Failed to close dq :%u: %s\n",
+		cvmx_printf("WARNING: %s: Failed to close dq :%u: %s\n",
 				__FUNCTION__, dq,
 				pko_dqstatus_error(dqstatus));
 		cvmx_dprintf("DEBUG: %s: dq %u depth %u\n",
@@ -487,7 +487,7 @@ int cvmx_pko3_dq_query(int node, int dq)
 	dqstatus = pko_status.s.dqstatus;
 
 	if (dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("%s: ERROR: Failed to query dq :%u: %s\n",
+		cvmx_printf("%s: ERROR: Failed to query dq :%u: %s\n",
 				__FUNCTION__, dq,
 				pko_dqstatus_error(dqstatus));
 		return -1;
@@ -537,7 +537,7 @@ static int cvmx_pko_setup_macs(int node)
 		max_fifos = 28;	/* exclusive of NULL FIFO */
 		fifo_groups = 8;/* inclusive of NULL PTGF */
 	}
-        if(OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		max_fifos = 16;
 		fifo_groups = 5;
 	}
@@ -577,7 +577,7 @@ static int cvmx_pko_setup_macs(int node)
 			/* convert interface/port to mac number */
 			i = __cvmx_pko3_get_mac_num(xiface, port);
 			if (i < 0 || i >= (int) __cvmx_pko3_num_macs()) {
-				cvmx_dprintf("%s: ERROR: interface %d:%u "
+				cvmx_printf("%s: ERROR: interface %d:%u "
 				    "port %d has no MAC %d/%d\n",
 				    __func__, node, interface, port,
 				    i, __cvmx_pko3_num_macs());
@@ -696,7 +696,7 @@ static int cvmx_pko_setup_macs(int node)
 			else if (cnt == 1)
 				fifo_group_cfg[g] = 0; /* 2.5k x 4 */
 			else
-				cvmx_dprintf("%s: internal error\n",__func__);
+				cvmx_printf("ERROR: %s: internal error\n",__func__);
 
 			fifo += cnt;
 		}
@@ -819,7 +819,7 @@ static int cvmx_pko_setup_macs(int node)
 
 		/* Check for overflow */
 		if (pko_mci0_max_cred.s.max_cred_lim != tmp) {
-			cvmx_dprintf("%s: MCI0 credit overflow\n",__FUNCTION__);
+			cvmx_printf("WARNING: %s: MCI0 credit overflow\n",__func__);
 			pko_mci0_max_cred.s.max_cred_lim = 0xfff;
 		}
 
@@ -836,7 +836,7 @@ static int cvmx_pko_setup_macs(int node)
 
 		/* Check for overflow */
 		if (pko_mci1_max_cred.s.max_cred_lim != tmp) {
-			cvmx_dprintf("%s: MCI1 credit overflow\n",__FUNCTION__);
+			cvmx_printf("WARNING: %s: MCI1 credit overflow\n",__func__);
 			pko_mci1_max_cred.s.max_cred_lim = 0xfff;
 		}
 
@@ -933,7 +933,7 @@ int cvmx_pko3_interface_options(int xiface, int index,
 
 	mac_num = __cvmx_pko3_get_mac_num(xiface, index);
 	if(mac_num < 0) {
-		cvmx_dprintf("ERROR: %s: invalid interface %u:%u/%u\n",
+		cvmx_printf("ERROR: %s: invalid interface %u:%u/%u\n",
 			__func__, xi.node, xi.interface, index);
 		return -1;
 	}
@@ -942,7 +942,7 @@ int cvmx_pko3_interface_options(int xiface, int index,
 
 	/* If MAC is not assigned, return an error */
 	if (pko_mac_cfg.s.fifo_num == 0x1f) {
-		cvmx_dprintf("ERROR: %s: unused interface %u:%u/%u\n",
+		cvmx_printf("ERROR: %s: unused interface %u:%u/%u\n",
 			__func__, xi.node, xi.interface, index);
 		return -1;
 	}
@@ -1198,7 +1198,7 @@ int cvmx_pko3_pdesc_from_wqe(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe,
 
 	/* Verufy the WQE is legit */
 	if (cvmx_unlikely(wqe->word2.software || wqe->pki_wqe_translated)) {
-		cvmx_dprintf("%s: ERROR: invalid WQE\n", __func__);
+		cvmx_printf("%s: ERROR: invalid WQE\n", __func__);
 		return -1;
 	}
 
@@ -1242,7 +1242,7 @@ int cvmx_pko3_pdesc_from_wqe(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe,
 	hdr_s->s.le = style_buf_reg.s.pkt_lend;
 #if	CVMX_ENABLE_PARAMETER_CHECKING
 	if (hdr_s->s.le != __native_le)
-		cvmx_dprintf("%s: WARNING: "
+		cvmx_printf("%s: WARNING: "
 			"packet endianness mismatch\n",__func__);
 #endif
 
@@ -1319,7 +1319,7 @@ static int cvmx_pko3_pdesc_subdc_add(cvmx_pko3_pdesc_t *pdesc,
 
         /* SEND_JUMP_S missing on Pass1 */
         if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
-                cvmx_dprintf("%s: ERROR: too many segments\n",__func__);
+                cvmx_printf("%s: ERROR: too many segments\n",__func__);
                 return -E2BIG;
         }
 
@@ -1363,7 +1363,7 @@ static int cvmx_pko3_pdesc_subdc_add(cvmx_pko3_pdesc_t *pdesc,
 
 	/* Avoid overrunning jump buffer */
 	if (i >= (jump_buf_size-2)) {
-                cvmx_dprintf("%s: ERROR: too many segments\n",__func__);
+                cvmx_printf("%s: ERROR: too many segments\n",__func__);
 		return -E2BIG;
 	}
 
@@ -1438,7 +1438,7 @@ int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq,
                 return 0;
 
 #if 0
-        cvmx_dprintf("%s: ERROR: failed to enqueue: %s\n",
+        cvmx_printf("%s: ERROR: failed to enqueue: %s\n",
                                 __FUNCTION__,
                                 pko_dqstatus_error(pko_status.s.dqstatus));
 #endif
@@ -1511,7 +1511,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
 	int rc;
 
 	if (pdesc->mem_s_ix > 0) {
-		cvmx_dprintf("%s: subcommand restriction violated\n", __func__);
+		cvmx_printf("ERROR: %s: subcommand restriction violated\n", __func__);
 		return -1;
 	}
 
@@ -1589,7 +1589,7 @@ int cvmx_pko3_pdesc_notify_wqe(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe,
 	 * and it must be the very last subcommand
 	 */
 	if (pdesc->send_work_s != 0) {
-		cvmx_dprintf("%s: Only one SEND_WORK_S is allowed\n", __func__);
+		cvmx_printf("ERROR: %s: Only one SEND_WORK_S is allowed\n", __func__);
 		return -1;
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index d603929..a5da608 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 110744 $<hr>
+ * <hr>$Revision: 111541 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -219,8 +219,15 @@ int cvmx_qlm_interface(int xiface)
 		cvmx_gserx_cfg_t gserx_cfg;
 		int qlm;
 
-		if (xi.interface < 2) {
-			qlm = xi.interface + 2;
+		if (xi.interface < 6) {
+			if (xi.interface < 2)
+				qlm = 2;
+			else if (xi.interface < 4)
+				qlm = 3;
+			else if	(xi.interface == 4)
+				qlm = 5;
+			else
+				qlm = 6;
 
 			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
 			if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset) {
@@ -231,20 +238,6 @@ int cvmx_qlm_interface(int xiface)
 				return qlm;
 			else
 				return -1;
-		} else if (xi.interface == 2) {
-			qlm = 5;	/* Represents GSER 5,6 DLM pair */
-			/* If either of the two DLMs is set to BGX, match */
-			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
-			gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
-			if (! phy_ctl.s.phy_pd && !phy_ctl.s.phy_reset &&
-			    gserx_cfg.s.bgx)
-				return qlm;
-			qlm = 6;
-			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
-			gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
-			if (! phy_ctl.s.phy_pd && !phy_ctl.s.phy_reset &&
-			    gserx_cfg.s.bgx)
-				return qlm;
 		}
 	} else {
 		/* Must be cn68XX */
@@ -1418,27 +1411,70 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
 		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
-		int bgx = (qlm < 4) ? qlm - 2 : qlm - 3;
-		
-		cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(0, bgx));
-		pmd_control.u64 = cvmx_read_csr(CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx));
+		int bgx = 0;
+		int index;
+		int lane_mask = 0, train_mask = 0;
+		if (qlm < 4)
+			bgx = qlm - 2;
+		else if (qlm == 5 || qlm == 6)
+			bgx = qlm - 3;
+
+		for (index = 0; index < 4; index++) {
+			cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(index, bgx));
+			pmd_control.u64 = cvmx_read_csr(CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, bgx));
+			lane_mask |= (cmr_config.s.lmac_type << (index * 4));
+			train_mask |= (pmd_control.s.train_en << (index * 4));
+		}
 		
-		switch(cmr_config.s.lmac_type) {
-		case 0: return CVMX_QLM_MODE_SGMII;
-		case 1:	return CVMX_QLM_MODE_XAUI;
-		case 2:	return CVMX_QLM_MODE_RXAUI;
-		case 3:	
+		switch(lane_mask) {
+		case 0:		return CVMX_QLM_MODE_SGMII;
+		case 0x1111:	return CVMX_QLM_MODE_XAUI;
+		case 0x2222:	return CVMX_QLM_MODE_RXAUI;
+		case 0x3333:	
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
-			if (pmd_control.s.train_en)
+			if (train_mask)
 				return CVMX_QLM_MODE_10G_KR;
 			else
 				return CVMX_QLM_MODE_XFI;
-		case 4:	
+		case 0x4444:	
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
-			if (pmd_control.s.train_en)
+			if (train_mask)
 				return CVMX_QLM_MODE_40G_KR4;
 			else
 				return CVMX_QLM_MODE_XLAUI;
+		case 0x0005:	return CVMX_QLM_MODE_RGMII_SGMII;
+		case 0x3335:	if (train_mask)
+					return CVMX_QLM_MODE_RGMII_10G_KR;
+				else
+					return CVMX_QLM_MODE_RGMII_XFI;
+		case 0x4445:	if (train_mask)
+					return CVMX_QLM_MODE_RGMII_40G_KR4;
+				else
+					return CVMX_QLM_MODE_RGMII_XLAUI;
+		case 0x2225:	return CVMX_QLM_MODE_RGMII_RXAUI;
+		case 0x1115:	return CVMX_QLM_MODE_RGMII_XAUI;
+		case 0x3330:	if (train_mask)
+					return CVMX_QLM_MODE_SGMII_10G_KR;
+				else
+					return CVMX_QLM_MODE_SGMII_XFI;
+		case 0x2200:	return CVMX_QLM_MODE_SGMII_RXAUI;
+		case 0x2244:	if (train_mask)
+					return CVMX_QLM_MODE_40G_KR4_RXAUI;
+				else
+					return CVMX_QLM_MODE_XLAUI_RXAUI;
+		case 0x3305:	if (train_mask)
+					return CVMX_QLM_MODE_RGMII_SGMII_10G_KR;
+				else
+					return CVMX_QLM_MODE_RGMII_SGMII_XFI;
+		case 0x2205:	return CVMX_QLM_MODE_RGMII_SGMII_RXAUI;
+		case 0x0035:	if (train_mask)
+					return CVMX_QLM_MODE_RGMII_10G_KR_SGMII;
+				else
+					return CVMX_QLM_MODE_RGMII_XFI_SGMII;
+		case 0x2235:	if (train_mask)
+					return CVMX_QLM_MODE_RGMII_10G_KR_RXAUI;
+				else
+					return CVMX_QLM_MODE_RGMII_XFI_RXAUI;
 		default: return CVMX_QLM_MODE_DISABLED;
 		}
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
index 3bf4b7f..d8a84e7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-srio.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -521,7 +521,7 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
 	port_0_ctl.s.o_enable = 0;
 	port_0_ctl.s.i_enable = 0;
 	port_0_ctl.s.prt_lock = 1;
-	port_0_ctl.s.disable = 0;
+	port_0_ctl.cn63xx.disable = 0;
 	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
 		return -1;
 
@@ -734,7 +734,7 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
 		return -1;
 	port_0_ctl.s.o_enable = 1;
 	port_0_ctl.s.i_enable = 1;
-	port_0_ctl.s.disable = 0;
+	port_0_ctl.cn63xx.disable = 0;
 	port_0_ctl.s.prt_lock = 0;
 	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
 		return -1;
@@ -1199,7 +1199,7 @@ int cvmx_srio_send_doorbell(int srio_port, int srcid_index, int destid, int is16
 	tx_bell.s.dest_id = destid;
 	tx_bell.s.src_id = srcid_index;
 	tx_bell.s.id16 = ! !is16bit;
-	tx_bell.s.priority = priority;
+	tx_bell.cn63xx.priority = priority;
 
 	/* Make sure the previous doorbell has completed */
 	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_TX_BELL(srio_port), cvmx_sriox_tx_bell_t, pending, ==, 0, CVMX_SRIO_DOORBELL_TIMEOUT)) {
@@ -1298,14 +1298,14 @@ cvmx_srio_doorbell_status_t cvmx_srio_receive_doorbell(int srio_port, int *desti
 	rx_bell.u64 = cvmx_read_csr(CVMX_SRIOX_RX_BELL(srio_port));
 	*sequence_num = rx_bell_seq.s.seq;
 	*srcid = rx_bell.s.src_id;
-	*priority = rx_bell.s.priority;
+	*priority = rx_bell.cn63xx.priority;
 	*is16bit = rx_bell.s.id16;
 	*data = rx_bell.s.data;
 	*destid_index = rx_bell.s.dest_id;
 
 	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
 		cvmx_dprintf("SRIO%d: Receive doorbell sequence=0x%x, srcid=0x%x, priority=%d, data=0x%x\n",
-			     srio_port, rx_bell_seq.s.seq, rx_bell.s.src_id, rx_bell.s.priority, rx_bell.s.data);
+			     srio_port, rx_bell_seq.s.seq, rx_bell.s.src_id, rx_bell.cn63xx.priority, rx_bell.s.data);
 
 	return CVMX_SRIO_DOORBELL_DONE;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
index ceb5c56..1035054 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
@@ -50,45 +50,55 @@ static struct global_resource_tag get_sso_resource_tag(int node)
 {
 	switch(node) {
 	case 0:
-		return cvmx_get_gr_tag('c','v','m','_','s','s','o','_','0','0','.','.','.','.','.','.');
 	case 1:
-		return cvmx_get_gr_tag('c','v','m','_','s','s','o','_','0','1','.','.','.','.','.','.');
 	case 2:
-		return cvmx_get_gr_tag('c','v','m','_','s','s','o','_','0','2','.','.','.','.','.','.');
 	case 3:
-		return cvmx_get_gr_tag('c','v','m','_','s','s','o','_','0','3','.','.','.','.','.','.');
+		return CVMX_GR_TAG_SSO_GRP(node);
 	default:
 		/* Add a panic?? */
-		return cvmx_get_gr_tag('i','n','v','a','l','i','d','.','.','.','.','.','.','.','.','.');
+		return CVMX_GR_TAG_INVALID;
 	}
 }
 
-int cvmx_sso_allocate_group_range(int node, int *base_group, int count)
+static int cvmx_sso_get_num_groups(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return 256;
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 64;
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 64;
+	return 16;
+}
+
+static struct global_resource_tag cvmx_sso_get_resource(int node)
 {
-	int num_grp;
-	int start;
-	uint64_t owner = 0;
 	struct global_resource_tag tag = get_sso_resource_tag(node);
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		num_grp = 256;
-	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
-		num_grp = 64;
-	else if (OCTEON_IS_MODEL(OCTEON_CN68XX))
-		num_grp = 64;
-	else
-		num_grp = 16;
-
-	if (cvmx_create_global_resource_range(tag, num_grp) != 0) {
+	if (cvmx_create_global_resource_range(tag, cvmx_sso_get_num_groups()) != 0) {
 		cvmx_dprintf("ERROR: failed to create sso global resource for node=%d\n", node);
-		return -1;
+		return CVMX_GR_TAG_INVALID;
 	}
 
+	return tag;
+}
+
+int cvmx_sso_reserve_group_range(int node, int *base_group, int count)
+{
+	int start;
+	uint64_t owner = 0;
+	struct global_resource_tag tag = cvmx_sso_get_resource(node);
+
+	if (cvmx_gr_same_tag(tag, CVMX_GR_TAG_INVALID))
+		return CVMX_RESOURCE_ALLOC_FAILED;
+
 	if (*base_group >= 0) {
 		start = cvmx_reserve_global_resource_range(tag, owner, *base_group, count);
-		if (start != *base_group)
+		if (start != *base_group) {
+			cvmx_printf("Warning: SSO groups %i-%i already reserved.\n",
+				    *base_group, *base_group + count);
 			return CVMX_RESOURCE_ALREADY_RESERVED;
-		else
+		} else
 			return 0;
 	} else {
 		start = cvmx_allocate_global_resource_range(tag, owner, count, 1);
@@ -100,15 +110,29 @@ int cvmx_sso_allocate_group_range(int node, int *base_group, int count)
 		}
 	}
 }
-EXPORT_SYMBOL(cvmx_sso_allocate_group_range);
+EXPORT_SYMBOL(cvmx_sso_reserve_group_range);
 
-int cvmx_sso_allocate_group(int node)
+int cvmx_sso_reserve_group(int node)
 {
 	int r;
 	int grp = -1;
 
-	r = cvmx_sso_allocate_group_range(node, &grp, 1);
+	r = cvmx_sso_reserve_group_range(node, &grp, 1);
 
 	return r == 0 ? grp : -1;
 }
-EXPORT_SYMBOL(cvmx_sso_allocate_group);
+EXPORT_SYMBOL(cvmx_sso_reserve_group);
+
+int cvmx_sso_release_group_range(int node, int base_group, int count)
+{
+	struct global_resource_tag tag = cvmx_sso_get_resource(node);
+	
+	return cvmx_free_global_resource_range_with_base(tag, base_group, count);
+}
+EXPORT_SYMBOL(cvmx_sso_release_group_range);
+
+int cvmx_sso_release_group(int node, int group)
+{
+	return cvmx_sso_release_group_range(node, group, 1);
+}
+EXPORT_SYMBOL(cvmx_sso_release_group);
diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index b7ca2be..444b2ac 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -43,7 +43,7 @@
  * File defining functions for working with different Octeon
  * models.
  *
- * <hr>$Revision: 110379 $<hr>
+ * <hr>$Revision: 111709 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/octeon.h>
@@ -483,6 +483,15 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 		else
 			suffix = "AAP";
 		break;
+	case 0x98:		/* CN75XX */
+		family = "75";
+		if (fus_dat3.cn78xx.nozip
+		    && fus_dat3.cn78xx.nodfa_dte
+		    && fus_dat3.cn78xx.nohna_dte)
+			suffix = "SCP";
+		else
+			suffix = "AAP";
+		break;
 	default:
 		family = "XX";
 		core_model = "XX";
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index e74b14d..c3a703d 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -398,6 +398,7 @@ union cvmx_ase_backdoor_req_ctl {
 #endif
 	} s;
 	struct cvmx_ase_backdoor_req_ctl_s    cn78xx;
+	struct cvmx_ase_backdoor_req_ctl_s    cn78xxp2;
 };
 typedef union cvmx_ase_backdoor_req_ctl cvmx_ase_backdoor_req_ctl_t;
 
@@ -418,6 +419,7 @@ union cvmx_ase_backdoor_req_datax {
 #endif
 	} s;
 	struct cvmx_ase_backdoor_req_datax_s  cn78xx;
+	struct cvmx_ase_backdoor_req_datax_s  cn78xxp2;
 };
 typedef union cvmx_ase_backdoor_req_datax cvmx_ase_backdoor_req_datax_t;
 
@@ -444,6 +446,7 @@ union cvmx_ase_backdoor_rsp_ctl {
 #endif
 	} s;
 	struct cvmx_ase_backdoor_rsp_ctl_s    cn78xx;
+	struct cvmx_ase_backdoor_rsp_ctl_s    cn78xxp2;
 };
 typedef union cvmx_ase_backdoor_rsp_ctl cvmx_ase_backdoor_rsp_ctl_t;
 
@@ -464,6 +467,7 @@ union cvmx_ase_backdoor_rsp_datax {
 #endif
 	} s;
 	struct cvmx_ase_backdoor_rsp_datax_s  cn78xx;
+	struct cvmx_ase_backdoor_rsp_datax_s  cn78xxp2;
 };
 typedef union cvmx_ase_backdoor_rsp_datax cvmx_ase_backdoor_rsp_datax_t;
 
@@ -529,6 +533,7 @@ union cvmx_ase_bist_status0 {
 #endif
 	} s;
 	struct cvmx_ase_bist_status0_s        cn78xx;
+	struct cvmx_ase_bist_status0_s        cn78xxp2;
 };
 typedef union cvmx_ase_bist_status0 cvmx_ase_bist_status0_t;
 
@@ -580,6 +585,7 @@ union cvmx_ase_bist_status1 {
 #endif
 	} s;
 	struct cvmx_ase_bist_status1_s        cn78xx;
+	struct cvmx_ase_bist_status1_s        cn78xxp2;
 };
 typedef union cvmx_ase_bist_status1 cvmx_ase_bist_status1_t;
 
@@ -610,6 +616,7 @@ union cvmx_ase_config {
 #endif
 	} s;
 	struct cvmx_ase_config_s              cn78xx;
+	struct cvmx_ase_config_s              cn78xxp2;
 };
 typedef union cvmx_ase_config cvmx_ase_config_t;
 
@@ -689,6 +696,7 @@ union cvmx_ase_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_ase_ecc_ctl_s             cn78xx;
+	struct cvmx_ase_ecc_ctl_s             cn78xxp2;
 };
 typedef union cvmx_ase_ecc_ctl cvmx_ase_ecc_ctl_t;
 
@@ -772,6 +780,7 @@ union cvmx_ase_ecc_int {
 #endif
 	} s;
 	struct cvmx_ase_ecc_int_s             cn78xx;
+	struct cvmx_ase_ecc_int_s             cn78xxp2;
 };
 typedef union cvmx_ase_ecc_int cvmx_ase_ecc_int_t;
 
@@ -847,6 +856,7 @@ union cvmx_ase_gen_int {
 #endif
 	} s;
 	struct cvmx_ase_gen_int_s             cn78xx;
+	struct cvmx_ase_gen_int_s             cn78xxp2;
 };
 typedef union cvmx_ase_gen_int cvmx_ase_gen_int_t;
 
@@ -878,6 +888,7 @@ union cvmx_ase_lip_config {
 #endif
 	} s;
 	struct cvmx_ase_lip_config_s          cn78xx;
+	struct cvmx_ase_lip_config_s          cn78xxp2;
 };
 typedef union cvmx_ase_lip_config cvmx_ase_lip_config_t;
 
@@ -897,6 +908,7 @@ union cvmx_ase_lip_spare {
 #endif
 	} s;
 	struct cvmx_ase_lip_spare_s           cn78xx;
+	struct cvmx_ase_lip_spare_s           cn78xxp2;
 };
 typedef union cvmx_ase_lip_spare cvmx_ase_lip_spare_t;
 
@@ -932,6 +944,7 @@ union cvmx_ase_lop_config {
 #endif
 	} s;
 	struct cvmx_ase_lop_config_s          cn78xx;
+	struct cvmx_ase_lop_config_s          cn78xxp2;
 };
 typedef union cvmx_ase_lop_config cvmx_ase_lop_config_t;
 
@@ -951,6 +964,7 @@ union cvmx_ase_lop_spare {
 #endif
 	} s;
 	struct cvmx_ase_lop_spare_s           cn78xx;
+	struct cvmx_ase_lop_spare_s           cn78xxp2;
 };
 typedef union cvmx_ase_lop_spare cvmx_ase_lop_spare_t;
 
@@ -1001,6 +1015,7 @@ union cvmx_ase_lue_config {
 #endif
 	} s;
 	struct cvmx_ase_lue_config_s          cn78xx;
+	struct cvmx_ase_lue_config_s          cn78xxp2;
 };
 typedef union cvmx_ase_lue_config cvmx_ase_lue_config_t;
 
@@ -1060,6 +1075,7 @@ union cvmx_ase_lue_dbg_ctl0 {
 #endif
 	} s;
 	struct cvmx_ase_lue_dbg_ctl0_s        cn78xx;
+	struct cvmx_ase_lue_dbg_ctl0_s        cn78xxp2;
 };
 typedef union cvmx_ase_lue_dbg_ctl0 cvmx_ase_lue_dbg_ctl0_t;
 
@@ -1123,6 +1139,7 @@ union cvmx_ase_lue_dbg_ctl1 {
 #endif
 	} s;
 	struct cvmx_ase_lue_dbg_ctl1_s        cn78xx;
+	struct cvmx_ase_lue_dbg_ctl1_s        cn78xxp2;
 };
 typedef union cvmx_ase_lue_dbg_ctl1 cvmx_ase_lue_dbg_ctl1_t;
 
@@ -1174,6 +1191,7 @@ union cvmx_ase_lue_error_log {
 #endif
 	} s;
 	struct cvmx_ase_lue_error_log_s       cn78xx;
+	struct cvmx_ase_lue_error_log_s       cn78xxp2;
 };
 typedef union cvmx_ase_lue_error_log cvmx_ase_lue_error_log_t;
 
@@ -1233,6 +1251,7 @@ union cvmx_ase_lue_error_log_enable {
 #endif
 	} s;
 	struct cvmx_ase_lue_error_log_enable_s cn78xx;
+	struct cvmx_ase_lue_error_log_enable_s cn78xxp2;
 };
 typedef union cvmx_ase_lue_error_log_enable cvmx_ase_lue_error_log_enable_t;
 
@@ -1287,6 +1306,7 @@ union cvmx_ase_lue_perf_filt {
 #endif
 	} s;
 	struct cvmx_ase_lue_perf_filt_s       cn78xx;
+	struct cvmx_ase_lue_perf_filt_s       cn78xxp2;
 };
 typedef union cvmx_ase_lue_perf_filt cvmx_ase_lue_perf_filt_t;
 
@@ -1335,6 +1355,7 @@ union cvmx_ase_lue_performance_controlx {
 #endif
 	} s;
 	struct cvmx_ase_lue_performance_controlx_s cn78xx;
+	struct cvmx_ase_lue_performance_controlx_s cn78xxp2;
 };
 typedef union cvmx_ase_lue_performance_controlx cvmx_ase_lue_performance_controlx_t;
 
@@ -1386,6 +1407,7 @@ union cvmx_ase_lue_performance_control0 {
 #endif
 	} s;
 	struct cvmx_ase_lue_performance_control0_s cn78xx;
+	struct cvmx_ase_lue_performance_control0_s cn78xxp2;
 };
 typedef union cvmx_ase_lue_performance_control0 cvmx_ase_lue_performance_control0_t;
 
@@ -1439,6 +1461,7 @@ union cvmx_ase_lue_performance_control1 {
 #endif
 	} s;
 	struct cvmx_ase_lue_performance_control1_s cn78xx;
+	struct cvmx_ase_lue_performance_control1_s cn78xxp2;
 };
 typedef union cvmx_ase_lue_performance_control1 cvmx_ase_lue_performance_control1_t;
 
@@ -1457,6 +1480,7 @@ union cvmx_ase_lue_performance_counterx {
 #endif
 	} s;
 	struct cvmx_ase_lue_performance_counterx_s cn78xx;
+	struct cvmx_ase_lue_performance_counterx_s cn78xxp2;
 };
 typedef union cvmx_ase_lue_performance_counterx cvmx_ase_lue_performance_counterx_t;
 
@@ -1476,6 +1500,7 @@ union cvmx_ase_lue_spare {
 #endif
 	} s;
 	struct cvmx_ase_lue_spare_s           cn78xx;
+	struct cvmx_ase_lue_spare_s           cn78xxp2;
 };
 typedef union cvmx_ase_lue_spare cvmx_ase_lue_spare_t;
 
@@ -1503,6 +1528,7 @@ union cvmx_ase_lue_twe_bwe_enable {
 #endif
 	} s;
 	struct cvmx_ase_lue_twe_bwe_enable_s  cn78xx;
+	struct cvmx_ase_lue_twe_bwe_enable_s  cn78xxp2;
 };
 typedef union cvmx_ase_lue_twe_bwe_enable cvmx_ase_lue_twe_bwe_enable_t;
 
@@ -1535,6 +1561,7 @@ union cvmx_ase_luf_error_log {
 #endif
 	} s;
 	struct cvmx_ase_luf_error_log_s       cn78xx;
+	struct cvmx_ase_luf_error_log_s       cn78xxp2;
 };
 typedef union cvmx_ase_luf_error_log cvmx_ase_luf_error_log_t;
 
@@ -1561,6 +1588,7 @@ union cvmx_ase_sft_rst {
 #endif
 	} s;
 	struct cvmx_ase_sft_rst_s             cn78xx;
+	struct cvmx_ase_sft_rst_s             cn78xxp2;
 };
 typedef union cvmx_ase_sft_rst cvmx_ase_sft_rst_t;
 
@@ -1580,6 +1608,7 @@ union cvmx_ase_spare {
 #endif
 	} s;
 	struct cvmx_ase_spare_s               cn78xx;
+	struct cvmx_ase_spare_s               cn78xxp2;
 };
 typedef union cvmx_ase_spare cvmx_ase_spare_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index aa8c420..d9bf4e4 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_BCH_BIST_RESULT CVMX_BCH_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000080ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 #define CVMX_BCH_CMD_BUF CVMX_BCH_CMD_BUF_FUNC()
 static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_CMD_BUF not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000008ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 #define CVMX_BCH_CMD_PTR CVMX_BCH_CMD_PTR_FUNC()
 static inline uint64_t CVMX_BCH_CMD_PTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_CMD_PTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000020ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_BCH_CMD_PTR_FUNC(void)
 #define CVMX_BCH_CTL CVMX_BCH_CTL_FUNC()
 static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000000ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 #define CVMX_BCH_ECO CVMX_BCH_ECO_FUNC()
 static inline uint64_t CVMX_BCH_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000030ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_BCH_ECO_FUNC(void)
 #define CVMX_BCH_ERR_CFG CVMX_BCH_ERR_CFG_FUNC()
 static inline uint64_t CVMX_BCH_ERR_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_ERR_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000010ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_BCH_GEN_INT_EN_FUNC(void)
 #define CVMX_BCH_REG_ERROR CVMX_BCH_REG_ERROR_FUNC()
 static inline uint64_t CVMX_BCH_REG_ERROR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_BCH_REG_ERROR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000088ull);
 }
@@ -176,6 +176,7 @@ union cvmx_bch_bist_result {
 	struct cvmx_bch_bist_result_s         cn70xx;
 	struct cvmx_bch_bist_result_s         cn70xxp1;
 	struct cvmx_bch_bist_result_s         cn73xx;
+	struct cvmx_bch_bist_result_s         cn75xx;
 };
 typedef union cvmx_bch_bist_result cvmx_bch_bist_result_t;
 
@@ -231,6 +232,7 @@ union cvmx_bch_cmd_buf {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_bch_cmd_buf_cn73xx        cn75xx;
 };
 typedef union cvmx_bch_cmd_buf cvmx_bch_cmd_buf_t;
 
@@ -255,6 +257,7 @@ union cvmx_bch_cmd_ptr {
 #endif
 	} s;
 	struct cvmx_bch_cmd_ptr_s             cn73xx;
+	struct cvmx_bch_cmd_ptr_s             cn75xx;
 };
 typedef union cvmx_bch_cmd_ptr cvmx_bch_cmd_ptr_t;
 
@@ -321,6 +324,7 @@ union cvmx_bch_ctl {
 	uint64_t reserved_22_63               : 42;
 #endif
 	} cn73xx;
+	struct cvmx_bch_ctl_cn73xx            cn75xx;
 };
 typedef union cvmx_bch_ctl cvmx_bch_ctl_t;
 
@@ -339,6 +343,7 @@ union cvmx_bch_eco {
 #endif
 	} s;
 	struct cvmx_bch_eco_s                 cn73xx;
+	struct cvmx_bch_eco_s                 cn75xx;
 };
 typedef union cvmx_bch_eco cvmx_bch_eco_t;
 
@@ -364,6 +369,7 @@ union cvmx_bch_err_cfg {
 	struct cvmx_bch_err_cfg_s             cn70xx;
 	struct cvmx_bch_err_cfg_s             cn70xxp1;
 	struct cvmx_bch_err_cfg_s             cn73xx;
+	struct cvmx_bch_err_cfg_s             cn75xx;
 };
 typedef union cvmx_bch_err_cfg cvmx_bch_err_cfg_t;
 
@@ -438,6 +444,7 @@ union cvmx_bch_reg_error {
 #endif
 	} s;
 	struct cvmx_bch_reg_error_s           cn73xx;
+	struct cvmx_bch_reg_error_s           cn75xx;
 };
 typedef union cvmx_bch_reg_error cvmx_bch_reg_error_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 49085f9..09e52fa 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_CONFIG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -69,6 +70,7 @@ static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -81,6 +83,7 @@ static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_PRT_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000408ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -93,6 +96,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ADR_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -105,6 +109,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_DROP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -117,6 +122,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_OFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -129,6 +135,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_ON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -141,6 +148,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -153,6 +161,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -165,6 +174,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ID_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -177,6 +187,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XOFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -189,6 +200,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -201,6 +213,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -213,6 +226,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -225,6 +239,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -237,6 +252,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -249,6 +265,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -261,6 +278,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -273,6 +291,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -285,6 +304,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -297,6 +317,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -309,6 +330,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -321,6 +343,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_WEIGHT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -333,6 +356,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_CHANNEL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000400ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -345,6 +369,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000418ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -357,6 +382,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_HG2_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000410ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -369,6 +395,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_OVR_BP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000420ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -381,6 +408,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000508ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -393,6 +421,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000510ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -405,6 +434,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT10(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000558ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -417,6 +447,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT11(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000560ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -429,6 +460,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT12(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000568ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -441,6 +473,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT13(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000570ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -453,6 +486,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT14(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000578ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -465,6 +499,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT15(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000580ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -477,6 +512,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT16(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000588ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -489,6 +525,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT17(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000590ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -501,6 +538,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000518ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -513,6 +551,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000520ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -525,6 +564,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000528ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -537,6 +577,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000530ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -549,6 +590,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000538ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -561,6 +603,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000540ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -573,6 +616,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000548ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -585,6 +629,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT9(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000550ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -597,6 +642,7 @@ static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((offset) & 7) * 0x1000000ull;
@@ -609,6 +655,7 @@ static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((offset) & 7) * 0x1000000ull;
@@ -621,6 +668,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((offset) & 7) * 0x1000000ull;
@@ -633,6 +681,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((offset) & 7) * 0x1000000ull;
@@ -645,6 +694,7 @@ static inline uint64_t CVMX_BGXX_CMR_ECO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((offset) & 7) * 0x1000000ull;
@@ -657,6 +707,7 @@ static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((offset) & 7) * 0x1000000ull;
@@ -669,6 +720,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((offset) & 7) * 0x1000000ull;
@@ -681,6 +733,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((offset) & 7) * 0x1000000ull;
@@ -693,6 +746,7 @@ static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((offset) & 7) * 0x1000000ull;
@@ -705,6 +759,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 31)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_ADRX_CAM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000100ull) + (((offset) & 31) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -717,6 +772,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((offset) & 7) * 0x1000000ull;
@@ -729,6 +785,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((offset) & 7) * 0x1000000ull;
@@ -741,6 +798,7 @@ static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((offset) & 7) * 0x1000000ull;
@@ -753,6 +811,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_PRTX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -765,6 +824,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -777,6 +837,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -789,6 +850,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -801,6 +863,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -813,6 +876,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -825,6 +889,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -837,6 +902,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -849,6 +915,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_SMACX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038230ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -861,6 +928,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -873,6 +941,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_BURST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038228ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -885,6 +954,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038270ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -897,6 +967,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038500ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -909,6 +980,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038240ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -921,6 +993,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long of
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038248ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -933,6 +1006,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038238ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -945,6 +1019,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038258ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -957,6 +1032,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038260ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -969,6 +1045,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038300ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -981,6 +1058,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SLOT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -993,6 +1071,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038250ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1005,6 +1084,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1017,6 +1097,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((offset) & 7) * 0x1000000ull;
@@ -1029,6 +1110,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((offset) & 7) * 0x1000000ull;
@@ -1041,6 +1123,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((offset) & 7) * 0x1000000ull;
@@ -1053,6 +1136,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((offset) & 7) * 0x1000000ull;
@@ -1065,6 +1149,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((offset) & 7) * 0x1000000ull;
@@ -1077,6 +1162,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((offset) & 7) * 0x1000000ull;
@@ -1089,6 +1175,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1101,6 +1188,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_EXT_ST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1113,6 +1201,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1125,6 +1214,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_RESULTS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1137,6 +1227,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_INTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1149,6 +1240,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_LINKX_TIMER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1161,6 +1253,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MISCX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1173,6 +1266,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1185,6 +1279,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1197,6 +1292,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1209,6 +1305,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_SYNC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1221,6 +1318,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1233,6 +1331,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1245,6 +1344,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1257,6 +1357,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1269,6 +1370,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1281,6 +1383,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020200ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1293,6 +1396,7 @@ static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_EXT_LOOPBACK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1305,6 +1409,7 @@ static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_HG2_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1317,6 +1422,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_HI(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1329,6 +1435,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_LO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1341,6 +1448,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1353,6 +1461,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1365,6 +1474,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1377,6 +1487,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1389,6 +1500,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1401,6 +1513,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1413,6 +1526,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1425,6 +1539,7 @@ static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_SMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020108ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1437,6 +1552,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020100ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1449,6 +1565,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020160ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1461,6 +1578,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020148ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1473,6 +1591,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1485,6 +1604,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020118ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1497,6 +1617,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020150ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1509,6 +1630,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020120ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1521,6 +1643,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020110ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1533,6 +1656,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020158ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1545,6 +1669,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1557,6 +1682,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1569,6 +1695,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020128ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1581,6 +1708,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020168ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1593,6 +1721,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1605,6 +1734,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1617,6 +1747,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1629,6 +1760,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_BASE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1641,6 +1773,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_XNP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1653,6 +1786,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1665,6 +1799,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_XNP_TX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1677,6 +1812,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_ALGN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1689,6 +1825,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1701,6 +1838,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_LANE_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1713,6 +1851,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1725,6 +1864,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1737,6 +1877,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1749,6 +1890,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1761,6 +1903,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1773,6 +1916,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1785,6 +1929,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1797,6 +1942,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1809,6 +1955,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1821,6 +1968,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1833,6 +1981,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1845,6 +1994,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1857,6 +2007,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1869,6 +2020,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1881,6 +2033,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1893,6 +2046,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1905,6 +2059,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1917,6 +2072,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1929,6 +2085,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1941,6 +2098,7 @@ static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1953,6 +2111,7 @@ static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_LPCS_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1965,6 +2124,7 @@ static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_MISC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1977,6 +2137,7 @@ static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_SPD_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1989,6 +2150,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -2001,6 +2163,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -2013,6 +2176,7 @@ static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((offset) & 7) * 0x1000000ull;
@@ -2025,6 +2189,7 @@ static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((offset) & 7) * 0x1000000ull;
@@ -2037,6 +2202,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((offset) & 7) * 0x1000000ull;
@@ -2049,6 +2215,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((offset) & 7) * 0x1000000ull;
@@ -2061,6 +2228,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_SKEW_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010320ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -2073,6 +2241,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010340ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -2213,7 +2382,9 @@ union cvmx_bgxx_cmrx_config {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_config_s        cn73xx;
+	struct cvmx_bgxx_cmrx_config_s        cn75xx;
 	struct cvmx_bgxx_cmrx_config_s        cn78xx;
+	struct cvmx_bgxx_cmrx_config_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_config cvmx_bgxx_cmrx_config_t;
 
@@ -2237,7 +2408,9 @@ union cvmx_bgxx_cmrx_int {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_int_s           cn73xx;
+	struct cvmx_bgxx_cmrx_int_s           cn75xx;
 	struct cvmx_bgxx_cmrx_int_s           cn78xx;
+	struct cvmx_bgxx_cmrx_int_s           cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_int cvmx_bgxx_cmrx_int_t;
 
@@ -2264,7 +2437,9 @@ union cvmx_bgxx_cmrx_prt_cbfc_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn73xx;
+	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn75xx;
 	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn78xx;
+	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_prt_cbfc_ctl cvmx_bgxx_cmrx_prt_cbfc_ctl_t;
 
@@ -2283,7 +2458,8 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
                                                          0x0 = Force reject all multicast packets.
                                                          0x1 = Force accept all multicast packets.
                                                          0x2 = Use the address filter CAM.
-                                                         0x3 = Reserved. */
+                                                         0x3 = Reserved.
+                                                         Reset value changed in pass 2. */
 	uint64_t bcst_accept                  : 1;  /**< Allow or deny broadcast packets.
                                                          0 = Reject all broadcast packets.
                                                          1 = Accept all broadcast Packets. */
@@ -2295,7 +2471,9 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn73xx;
+	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn75xx;
 	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn78xx;
+	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_adr_ctl cvmx_bgxx_cmrx_rx_adr_ctl_t;
 
@@ -2318,7 +2496,9 @@ union cvmx_bgxx_cmrx_rx_bp_drop {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn73xx;
+	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn75xx;
 	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn78xx;
+	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_drop cvmx_bgxx_cmrx_rx_bp_drop_t;
 
@@ -2338,7 +2518,9 @@ union cvmx_bgxx_cmrx_rx_bp_off {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn73xx;
+	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn75xx;
 	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn78xx;
+	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_off cvmx_bgxx_cmrx_rx_bp_off_t;
 
@@ -2366,7 +2548,9 @@ union cvmx_bgxx_cmrx_rx_bp_on {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_on cvmx_bgxx_cmrx_rx_bp_on_t;
 
@@ -2387,7 +2571,9 @@ union cvmx_bgxx_cmrx_rx_bp_status {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn73xx;
+	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn75xx;
 	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn78xx;
+	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_status cvmx_bgxx_cmrx_rx_bp_status_t;
 
@@ -2406,7 +2592,9 @@ union cvmx_bgxx_cmrx_rx_fifo_len {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn73xx;
+	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn75xx;
 	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn78xx;
+	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_fifo_len cvmx_bgxx_cmrx_rx_fifo_len_t;
 
@@ -2428,8 +2616,7 @@ union cvmx_bgxx_cmrx_rx_id_map {
                                                          _ RID reset value = 4*(BGX_ID + 1) + LMAC_ID
                                                          Changes to RID must only occur when the LMAC is quiescent (i.e. the LMAC receive interface
                                                          is down and the RX FIFO is empty). */
-	uint64_t pknd                         : 8;  /**< Port kind for this LMAC.  Only bits [5:0] are used.  Bits [7:6] are not used and should
-                                                         not be changed from the reset value of 0. */
+	uint64_t pknd                         : 8;  /**< Port kind for this LMAC. Usable 6 bit field of PKND in pass 2. */
 #else
 	uint64_t pknd                         : 8;
 	uint64_t rid                          : 7;
@@ -2455,7 +2642,9 @@ union cvmx_bgxx_cmrx_rx_id_map {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} cn73xx;
+	struct cvmx_bgxx_cmrx_rx_id_map_cn73xx cn75xx;
 	struct cvmx_bgxx_cmrx_rx_id_map_s     cn78xx;
+	struct cvmx_bgxx_cmrx_rx_id_map_cn73xx cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_id_map cvmx_bgxx_cmrx_rx_id_map_t;
 
@@ -2477,7 +2666,9 @@ union cvmx_bgxx_cmrx_rx_logl_xoff {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn73xx;
+	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn75xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn78xx;
+	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xoff cvmx_bgxx_cmrx_rx_logl_xoff_t;
 
@@ -2499,7 +2690,9 @@ union cvmx_bgxx_cmrx_rx_logl_xon {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn73xx;
+	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn75xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn78xx;
+	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xon cvmx_bgxx_cmrx_rx_logl_xon_t;
 
@@ -2518,7 +2711,9 @@ union cvmx_bgxx_cmrx_rx_pause_drop_time {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn73xx;
+	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn75xx;
 	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn78xx;
+	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_pause_drop_time cvmx_bgxx_cmrx_rx_pause_drop_time_t;
 
@@ -2544,7 +2739,9 @@ union cvmx_bgxx_cmrx_rx_stat0 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat0_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat0_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat0_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat0_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat0 cvmx_bgxx_cmrx_rx_stat0_t;
 
@@ -2567,7 +2764,9 @@ union cvmx_bgxx_cmrx_rx_stat1 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat1_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat1_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat1_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat1_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat1 cvmx_bgxx_cmrx_rx_stat1_t;
 
@@ -2594,7 +2793,9 @@ union cvmx_bgxx_cmrx_rx_stat2 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat2_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat2_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat2_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat2_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat2 cvmx_bgxx_cmrx_rx_stat2_t;
 
@@ -2617,7 +2818,9 @@ union cvmx_bgxx_cmrx_rx_stat3 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat3_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat3_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat3_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat3_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat3 cvmx_bgxx_cmrx_rx_stat3_t;
 
@@ -2643,7 +2846,9 @@ union cvmx_bgxx_cmrx_rx_stat4 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat4_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat4_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat4_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat4_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat4 cvmx_bgxx_cmrx_rx_stat4_t;
 
@@ -2666,7 +2871,9 @@ union cvmx_bgxx_cmrx_rx_stat5 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat5_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat5_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat5_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat5_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat5 cvmx_bgxx_cmrx_rx_stat5_t;
 
@@ -2691,7 +2898,9 @@ union cvmx_bgxx_cmrx_rx_stat6 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat6_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat6_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat6_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat6_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat6 cvmx_bgxx_cmrx_rx_stat6_t;
 
@@ -2714,7 +2923,9 @@ union cvmx_bgxx_cmrx_rx_stat7 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat7_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat7_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat7_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat7_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
 
@@ -2754,7 +2965,9 @@ union cvmx_bgxx_cmrx_rx_stat8 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_stat8_s      cn73xx;
+	struct cvmx_bgxx_cmrx_rx_stat8_s      cn75xx;
 	struct cvmx_bgxx_cmrx_rx_stat8_s      cn78xx;
+	struct cvmx_bgxx_cmrx_rx_stat8_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat8 cvmx_bgxx_cmrx_rx_stat8_t;
 
@@ -2775,7 +2988,9 @@ union cvmx_bgxx_cmrx_rx_weight {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_rx_weight_s     cn73xx;
+	struct cvmx_bgxx_cmrx_rx_weight_s     cn75xx;
 	struct cvmx_bgxx_cmrx_rx_weight_s     cn78xx;
+	struct cvmx_bgxx_cmrx_rx_weight_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_rx_weight cvmx_bgxx_cmrx_rx_weight_t;
 
@@ -2800,7 +3015,9 @@ union cvmx_bgxx_cmrx_tx_channel {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_channel_s    cn73xx;
+	struct cvmx_bgxx_cmrx_tx_channel_s    cn75xx;
 	struct cvmx_bgxx_cmrx_tx_channel_s    cn78xx;
+	struct cvmx_bgxx_cmrx_tx_channel_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_channel cvmx_bgxx_cmrx_tx_channel_t;
 
@@ -2823,7 +3040,9 @@ union cvmx_bgxx_cmrx_tx_fifo_len {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn73xx;
+	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn75xx;
 	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn78xx;
+	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_fifo_len cvmx_bgxx_cmrx_tx_fifo_len_t;
 
@@ -2847,7 +3066,9 @@ union cvmx_bgxx_cmrx_tx_hg2_status {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn73xx;
+	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn75xx;
 	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn78xx;
+	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_hg2_status cvmx_bgxx_cmrx_tx_hg2_status_t;
 
@@ -2868,7 +3089,9 @@ union cvmx_bgxx_cmrx_tx_ovr_bp {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_ovr_bp cvmx_bgxx_cmrx_tx_ovr_bp_t;
 
@@ -2891,7 +3114,9 @@ union cvmx_bgxx_cmrx_tx_stat0 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat0_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat0_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat0_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat0_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat0 cvmx_bgxx_cmrx_tx_stat0_t;
 
@@ -2905,7 +3130,7 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t xsdef                        : 48; /**< A count of the number of times any frame was deferred for an excessive period of time.
                                                          See maxDeferTime in the IEEE 802.3 specification. Half-duplex mode only and not updated
-                                                         for late collision
+                                                         for late collisions.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2914,7 +3139,9 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat1_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat1_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat1_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat1_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat1 cvmx_bgxx_cmrx_tx_stat1_t;
 
@@ -2937,7 +3164,9 @@ union cvmx_bgxx_cmrx_tx_stat10 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat10_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat10_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat10_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat10_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat10 cvmx_bgxx_cmrx_tx_stat10_t;
 
@@ -2960,7 +3189,9 @@ union cvmx_bgxx_cmrx_tx_stat11 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat11_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat11_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat11_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat11_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat11 cvmx_bgxx_cmrx_tx_stat11_t;
 
@@ -2983,7 +3214,9 @@ union cvmx_bgxx_cmrx_tx_stat12 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat12_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat12_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat12_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat12_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat12 cvmx_bgxx_cmrx_tx_stat12_t;
 
@@ -3006,7 +3239,9 @@ union cvmx_bgxx_cmrx_tx_stat13 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat13_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat13_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat13_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat13_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat13 cvmx_bgxx_cmrx_tx_stat13_t;
 
@@ -3032,7 +3267,9 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat14_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat14_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat14_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat14_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat14 cvmx_bgxx_cmrx_tx_stat14_t;
 
@@ -3058,7 +3295,9 @@ union cvmx_bgxx_cmrx_tx_stat15 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat15_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat15_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat15_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat15_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat15 cvmx_bgxx_cmrx_tx_stat15_t;
 
@@ -3079,7 +3318,9 @@ union cvmx_bgxx_cmrx_tx_stat16 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat16_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat16_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat16_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat16_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat16 cvmx_bgxx_cmrx_tx_stat16_t;
 
@@ -3102,7 +3343,9 @@ union cvmx_bgxx_cmrx_tx_stat17 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat17_s     cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat17_s     cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat17_s     cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat17_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat17 cvmx_bgxx_cmrx_tx_stat17_t;
 
@@ -3125,7 +3368,9 @@ union cvmx_bgxx_cmrx_tx_stat2 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat2_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat2_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat2_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat2_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat2 cvmx_bgxx_cmrx_tx_stat2_t;
 
@@ -3147,7 +3392,9 @@ union cvmx_bgxx_cmrx_tx_stat3 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat3_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat3_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat3_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat3_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat3 cvmx_bgxx_cmrx_tx_stat3_t;
 
@@ -3173,7 +3420,9 @@ union cvmx_bgxx_cmrx_tx_stat4 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat4_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat4_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat4_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat4_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat4 cvmx_bgxx_cmrx_tx_stat4_t;
 
@@ -3196,7 +3445,9 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat5_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat5_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat5_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat5_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat5 cvmx_bgxx_cmrx_tx_stat5_t;
 
@@ -3220,7 +3471,9 @@ union cvmx_bgxx_cmrx_tx_stat6 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat6_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat6_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat6_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat6_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat6 cvmx_bgxx_cmrx_tx_stat6_t;
 
@@ -3244,7 +3497,9 @@ union cvmx_bgxx_cmrx_tx_stat7 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat7_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat7_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat7_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat7_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat7 cvmx_bgxx_cmrx_tx_stat7_t;
 
@@ -3267,7 +3522,9 @@ union cvmx_bgxx_cmrx_tx_stat8 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat8_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat8_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat8_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat8_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat8 cvmx_bgxx_cmrx_tx_stat8_t;
 
@@ -3290,7 +3547,9 @@ union cvmx_bgxx_cmrx_tx_stat9 {
 #endif
 	} s;
 	struct cvmx_bgxx_cmrx_tx_stat9_s      cn73xx;
+	struct cvmx_bgxx_cmrx_tx_stat9_s      cn75xx;
 	struct cvmx_bgxx_cmrx_tx_stat9_s      cn78xx;
+	struct cvmx_bgxx_cmrx_tx_stat9_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat9 cvmx_bgxx_cmrx_tx_stat9_t;
 
@@ -3309,7 +3568,9 @@ union cvmx_bgxx_cmr_bad {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_bad_s            cn73xx;
+	struct cvmx_bgxx_cmr_bad_s            cn75xx;
 	struct cvmx_bgxx_cmr_bad_s            cn78xx;
+	struct cvmx_bgxx_cmr_bad_s            cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_bad cvmx_bgxx_cmr_bad_t;
 
@@ -3345,7 +3606,9 @@ union cvmx_bgxx_cmr_bist_status {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_bist_status_s    cn73xx;
+	struct cvmx_bgxx_cmr_bist_status_s    cn75xx;
 	struct cvmx_bgxx_cmr_bist_status_s    cn78xx;
+	struct cvmx_bgxx_cmr_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_bist_status cvmx_bgxx_cmr_bist_status_t;
 
@@ -3371,7 +3634,9 @@ union cvmx_bgxx_cmr_chan_msk_and {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_chan_msk_and_s   cn73xx;
+	struct cvmx_bgxx_cmr_chan_msk_and_s   cn75xx;
 	struct cvmx_bgxx_cmr_chan_msk_and_s   cn78xx;
+	struct cvmx_bgxx_cmr_chan_msk_and_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_and cvmx_bgxx_cmr_chan_msk_and_t;
 
@@ -3397,7 +3662,9 @@ union cvmx_bgxx_cmr_chan_msk_or {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_chan_msk_or_s    cn73xx;
+	struct cvmx_bgxx_cmr_chan_msk_or_s    cn75xx;
 	struct cvmx_bgxx_cmr_chan_msk_or_s    cn78xx;
+	struct cvmx_bgxx_cmr_chan_msk_or_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_or cvmx_bgxx_cmr_chan_msk_or_t;
 
@@ -3416,7 +3683,9 @@ union cvmx_bgxx_cmr_eco {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_eco_s            cn73xx;
+	struct cvmx_bgxx_cmr_eco_s            cn75xx;
 	struct cvmx_bgxx_cmr_eco_s            cn78xx;
+	struct cvmx_bgxx_cmr_eco_s            cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_eco cvmx_bgxx_cmr_eco_t;
 
@@ -3473,7 +3742,9 @@ union cvmx_bgxx_cmr_global_config {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_global_config_s  cn73xx;
+	struct cvmx_bgxx_cmr_global_config_s  cn75xx;
 	struct cvmx_bgxx_cmr_global_config_s  cn78xx;
+	struct cvmx_bgxx_cmr_global_config_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_global_config cvmx_bgxx_cmr_global_config_t;
 
@@ -3522,7 +3793,9 @@ union cvmx_bgxx_cmr_mem_ctrl {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_mem_ctrl_s       cn73xx;
+	struct cvmx_bgxx_cmr_mem_ctrl_s       cn75xx;
 	struct cvmx_bgxx_cmr_mem_ctrl_s       cn78xx;
+	struct cvmx_bgxx_cmr_mem_ctrl_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_mem_ctrl cvmx_bgxx_cmr_mem_ctrl_t;
 
@@ -3575,7 +3848,9 @@ union cvmx_bgxx_cmr_mem_int {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_mem_int_s        cn73xx;
+	struct cvmx_bgxx_cmr_mem_int_s        cn75xx;
 	struct cvmx_bgxx_cmr_mem_int_s        cn78xx;
+	struct cvmx_bgxx_cmr_mem_int_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_mem_int cvmx_bgxx_cmr_mem_int_t;
 
@@ -3596,7 +3871,9 @@ union cvmx_bgxx_cmr_nxc_adr {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_nxc_adr_s        cn73xx;
+	struct cvmx_bgxx_cmr_nxc_adr_s        cn75xx;
 	struct cvmx_bgxx_cmr_nxc_adr_s        cn78xx;
+	struct cvmx_bgxx_cmr_nxc_adr_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_nxc_adr cvmx_bgxx_cmr_nxc_adr_t;
 
@@ -3623,7 +3900,8 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 	uint64_t reserved_49_51               : 3;
 	uint64_t en                           : 1;  /**< CAM entry enable for this DMAC address.
                                                          1 = Include this address in the matching algorithm.
-                                                         0 = Don't include this address in the matching algorithm. */
+                                                         0 = Don't include this address in the matching algorithm.
+                                                         Reset value changed in pass 2. */
 	uint64_t adr                          : 48; /**< DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                          ADR[47:40] is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                          multicast DMAC addresses. All BGX()_CMR_RX_ADR()_CAM CSRs can be used in any of the LMAC
@@ -3637,7 +3915,9 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn73xx;
+	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn75xx;
 	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn78xx;
+	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_rx_adrx_cam cvmx_bgxx_cmr_rx_adrx_cam_t;
 
@@ -3667,7 +3947,9 @@ union cvmx_bgxx_cmr_rx_lmacs {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_rx_lmacs_s       cn73xx;
+	struct cvmx_bgxx_cmr_rx_lmacs_s       cn75xx;
 	struct cvmx_bgxx_cmr_rx_lmacs_s       cn78xx;
+	struct cvmx_bgxx_cmr_rx_lmacs_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_rx_lmacs cvmx_bgxx_cmr_rx_lmacs_t;
 
@@ -3704,7 +3986,9 @@ union cvmx_bgxx_cmr_rx_ovr_bp {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn73xx;
+	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn75xx;
 	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn78xx;
+	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_rx_ovr_bp cvmx_bgxx_cmr_rx_ovr_bp_t;
 
@@ -3737,7 +4021,9 @@ union cvmx_bgxx_cmr_tx_lmacs {
 #endif
 	} s;
 	struct cvmx_bgxx_cmr_tx_lmacs_s       cn73xx;
+	struct cvmx_bgxx_cmr_tx_lmacs_s       cn75xx;
 	struct cvmx_bgxx_cmr_tx_lmacs_s       cn78xx;
+	struct cvmx_bgxx_cmr_tx_lmacs_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_cmr_tx_lmacs cvmx_bgxx_cmr_tx_lmacs_t;
 
@@ -3785,7 +4071,9 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn73xx;
+	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn75xx;
 	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn78xx;
+	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
 
@@ -3831,7 +4119,9 @@ union cvmx_bgxx_gmp_gmi_rxx_decision {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_decision cvmx_bgxx_gmp_gmi_rxx_decision_t;
 
@@ -3864,7 +4154,9 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_chk {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
 
@@ -3959,7 +4251,9 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_ctl cvmx_bgxx_gmp_gmi_rxx_frm_ctl_t;
 
@@ -3986,7 +4280,9 @@ union cvmx_bgxx_gmp_gmi_rxx_ifg {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
 
@@ -4102,7 +4398,9 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_int cvmx_bgxx_gmp_gmi_rxx_int_t;
 
@@ -4126,7 +4424,9 @@ union cvmx_bgxx_gmp_gmi_rxx_jabber {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_jabber cvmx_bgxx_gmp_gmi_rxx_jabber_t;
 
@@ -4186,7 +4486,9 @@ union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_udd_skp cvmx_bgxx_gmp_gmi_rxx_udd_skp_t;
 
@@ -4205,7 +4507,9 @@ union cvmx_bgxx_gmp_gmi_smacx {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_smacx_s      cn73xx;
+	struct cvmx_bgxx_gmp_gmi_smacx_s      cn75xx;
 	struct cvmx_bgxx_gmp_gmi_smacx_s      cn78xx;
+	struct cvmx_bgxx_gmp_gmi_smacx_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_smacx cvmx_bgxx_gmp_gmi_smacx_t;
 
@@ -4230,7 +4534,9 @@ union cvmx_bgxx_gmp_gmi_txx_append {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_append_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_append_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_append_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_append_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_append cvmx_bgxx_gmp_gmi_txx_append_t;
 
@@ -4253,7 +4559,9 @@ union cvmx_bgxx_gmp_gmi_txx_burst {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_burst cvmx_bgxx_gmp_gmi_txx_burst_t;
 
@@ -4276,7 +4584,9 @@ union cvmx_bgxx_gmp_gmi_txx_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_ctl cvmx_bgxx_gmp_gmi_txx_ctl_t;
 
@@ -4303,7 +4613,9 @@ union cvmx_bgxx_gmp_gmi_txx_int {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_int cvmx_bgxx_gmp_gmi_txx_int_t;
 
@@ -4325,7 +4637,9 @@ union cvmx_bgxx_gmp_gmi_txx_min_pkt {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_min_pkt cvmx_bgxx_gmp_gmi_txx_min_pkt_t;
 
@@ -4367,7 +4681,9 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_t;
 
@@ -4389,7 +4705,9 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_t;
 
@@ -4408,7 +4726,9 @@ union cvmx_bgxx_gmp_gmi_txx_pause_togo {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_togo cvmx_bgxx_gmp_gmi_txx_pause_togo_t;
 
@@ -4428,7 +4748,9 @@ union cvmx_bgxx_gmp_gmi_txx_pause_zero {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_zero cvmx_bgxx_gmp_gmi_txx_pause_zero_t;
 
@@ -4457,7 +4779,9 @@ union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_t;
 
@@ -4479,7 +4803,9 @@ union cvmx_bgxx_gmp_gmi_txx_slot {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_slot cvmx_bgxx_gmp_gmi_txx_slot_t;
 
@@ -4498,7 +4824,9 @@ union cvmx_bgxx_gmp_gmi_txx_soft_pause {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_soft_pause cvmx_bgxx_gmp_gmi_txx_soft_pause_t;
 
@@ -4524,7 +4852,9 @@ union cvmx_bgxx_gmp_gmi_txx_thresh {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_thresh cvmx_bgxx_gmp_gmi_txx_thresh_t;
 
@@ -4543,7 +4873,9 @@ union cvmx_bgxx_gmp_gmi_tx_col_attempt {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_col_attempt cvmx_bgxx_gmp_gmi_tx_col_attempt_t;
 
@@ -4576,7 +4908,9 @@ union cvmx_bgxx_gmp_gmi_tx_ifg {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_ifg cvmx_bgxx_gmp_gmi_tx_ifg_t;
 
@@ -4598,7 +4932,9 @@ union cvmx_bgxx_gmp_gmi_tx_jam {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_jam cvmx_bgxx_gmp_gmi_tx_jam_t;
 
@@ -4621,7 +4957,9 @@ union cvmx_bgxx_gmp_gmi_tx_lfsr {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_lfsr cvmx_bgxx_gmp_gmi_tx_lfsr_t;
 
@@ -4640,7 +4978,9 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_t;
 
@@ -4662,7 +5002,9 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn73xx;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn75xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn78xx;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_t;
 
@@ -4704,7 +5046,9 @@ union cvmx_bgxx_gmp_pcs_anx_adv {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn73xx;
+	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn75xx;
 	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn78xx;
+	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_adv cvmx_bgxx_gmp_pcs_anx_adv_t;
 
@@ -4731,7 +5075,9 @@ union cvmx_bgxx_gmp_pcs_anx_ext_st {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_ext_st cvmx_bgxx_gmp_pcs_anx_ext_st_t;
 
@@ -4777,7 +5123,9 @@ union cvmx_bgxx_gmp_pcs_anx_lp_abil {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_lp_abil cvmx_bgxx_gmp_pcs_anx_lp_abil_t;
 
@@ -4818,7 +5166,9 @@ union cvmx_bgxx_gmp_pcs_anx_results {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_anx_results_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_anx_results_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_anx_results_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_anx_results_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_results cvmx_bgxx_gmp_pcs_anx_results_t;
 
@@ -4871,7 +5221,9 @@ union cvmx_bgxx_gmp_pcs_intx {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_intx_s       cn73xx;
+	struct cvmx_bgxx_gmp_pcs_intx_s       cn75xx;
 	struct cvmx_bgxx_gmp_pcs_intx_s       cn78xx;
+	struct cvmx_bgxx_gmp_pcs_intx_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_intx cvmx_bgxx_gmp_pcs_intx_t;
 
@@ -4895,7 +5247,9 @@ union cvmx_bgxx_gmp_pcs_linkx_timer {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
 
@@ -4960,7 +5314,9 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn73xx;
+	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn75xx;
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn78xx;
+	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_miscx_ctl cvmx_bgxx_gmp_pcs_miscx_ctl_t;
 
@@ -5032,7 +5388,9 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_control cvmx_bgxx_gmp_pcs_mrx_control_t;
 
@@ -5097,7 +5455,9 @@ union cvmx_bgxx_gmp_pcs_mrx_status {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_status cvmx_bgxx_gmp_pcs_mrx_status_t;
 
@@ -5126,7 +5486,9 @@ union cvmx_bgxx_gmp_pcs_rxx_states {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_states cvmx_bgxx_gmp_pcs_rxx_states_t;
 
@@ -5147,7 +5509,9 @@ union cvmx_bgxx_gmp_pcs_rxx_sync {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn73xx;
+	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn75xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn78xx;
+	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
 
@@ -5188,7 +5552,9 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_an_adv cvmx_bgxx_gmp_pcs_sgmx_an_adv_t;
 
@@ -5224,7 +5590,9 @@ union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_lp_adv cvmx_bgxx_gmp_pcs_sgmx_lp_adv_t;
 
@@ -5250,7 +5618,9 @@ union cvmx_bgxx_gmp_pcs_txx_states {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_txx_states_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_txx_states_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_txx_states_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_txx_states_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_txx_states cvmx_bgxx_gmp_pcs_txx_states_t;
 
@@ -5284,7 +5654,9 @@ union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
 #endif
 	} s;
 	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn73xx;
+	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn75xx;
 	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn78xx;
+	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn78xxp2;
 };
 typedef union cvmx_bgxx_gmp_pcs_tx_rxx_polarity cvmx_bgxx_gmp_pcs_tx_rxx_polarity_t;
 
@@ -5321,7 +5693,9 @@ union cvmx_bgxx_smux_cbfc_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_cbfc_ctl_s      cn73xx;
+	struct cvmx_bgxx_smux_cbfc_ctl_s      cn75xx;
 	struct cvmx_bgxx_smux_cbfc_ctl_s      cn78xx;
+	struct cvmx_bgxx_smux_cbfc_ctl_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_cbfc_ctl cvmx_bgxx_smux_cbfc_ctl_t;
 
@@ -5344,7 +5718,9 @@ union cvmx_bgxx_smux_ctrl {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_ctrl_s          cn73xx;
+	struct cvmx_bgxx_smux_ctrl_s          cn75xx;
 	struct cvmx_bgxx_smux_ctrl_s          cn78xx;
+	struct cvmx_bgxx_smux_ctrl_s          cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_ctrl cvmx_bgxx_smux_ctrl_t;
 
@@ -5370,7 +5746,9 @@ union cvmx_bgxx_smux_ext_loopback {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_ext_loopback_s  cn73xx;
+	struct cvmx_bgxx_smux_ext_loopback_s  cn75xx;
 	struct cvmx_bgxx_smux_ext_loopback_s  cn78xx;
+	struct cvmx_bgxx_smux_ext_loopback_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_ext_loopback cvmx_bgxx_smux_ext_loopback_t;
 
@@ -5423,7 +5801,9 @@ union cvmx_bgxx_smux_hg2_control {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_hg2_control_s   cn73xx;
+	struct cvmx_bgxx_smux_hg2_control_s   cn75xx;
 	struct cvmx_bgxx_smux_hg2_control_s   cn78xx;
+	struct cvmx_bgxx_smux_hg2_control_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_hg2_control cvmx_bgxx_smux_hg2_control_t;
 
@@ -5447,7 +5827,9 @@ union cvmx_bgxx_smux_rx_bad_col_hi {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn73xx;
+	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn75xx;
 	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn78xx;
+	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_hi cvmx_bgxx_smux_rx_bad_col_hi_t;
 
@@ -5465,7 +5847,9 @@ union cvmx_bgxx_smux_rx_bad_col_lo {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn73xx;
+	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn75xx;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn78xx;
+	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_lo cvmx_bgxx_smux_rx_bad_col_lo_t;
 
@@ -5488,7 +5872,9 @@ union cvmx_bgxx_smux_rx_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_ctl_s        cn73xx;
+	struct cvmx_bgxx_smux_rx_ctl_s        cn75xx;
 	struct cvmx_bgxx_smux_rx_ctl_s        cn78xx;
+	struct cvmx_bgxx_smux_rx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_ctl cvmx_bgxx_smux_rx_ctl_t;
 
@@ -5513,7 +5899,9 @@ union cvmx_bgxx_smux_rx_decision {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_decision_s   cn73xx;
+	struct cvmx_bgxx_smux_rx_decision_s   cn75xx;
 	struct cvmx_bgxx_smux_rx_decision_s   cn78xx;
+	struct cvmx_bgxx_smux_rx_decision_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_decision cvmx_bgxx_smux_rx_decision_t;
 
@@ -5547,7 +5935,9 @@ union cvmx_bgxx_smux_rx_frm_chk {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_frm_chk_s    cn73xx;
+	struct cvmx_bgxx_smux_rx_frm_chk_s    cn75xx;
 	struct cvmx_bgxx_smux_rx_frm_chk_s    cn78xx;
+	struct cvmx_bgxx_smux_rx_frm_chk_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_frm_chk cvmx_bgxx_smux_rx_frm_chk_t;
 
@@ -5619,7 +6009,9 @@ union cvmx_bgxx_smux_rx_frm_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn73xx;
+	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn75xx;
 	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn78xx;
+	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_frm_ctl cvmx_bgxx_smux_rx_frm_ctl_t;
 
@@ -5681,7 +6073,9 @@ union cvmx_bgxx_smux_rx_int {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_int_s        cn73xx;
+	struct cvmx_bgxx_smux_rx_int_s        cn75xx;
 	struct cvmx_bgxx_smux_rx_int_s        cn78xx;
+	struct cvmx_bgxx_smux_rx_int_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_int cvmx_bgxx_smux_rx_int_t;
 
@@ -5714,7 +6108,9 @@ union cvmx_bgxx_smux_rx_jabber {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_jabber_s     cn73xx;
+	struct cvmx_bgxx_smux_rx_jabber_s     cn75xx;
 	struct cvmx_bgxx_smux_rx_jabber_s     cn78xx;
+	struct cvmx_bgxx_smux_rx_jabber_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_jabber cvmx_bgxx_smux_rx_jabber_t;
 
@@ -5771,7 +6167,9 @@ union cvmx_bgxx_smux_rx_udd_skp {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_rx_udd_skp_s    cn73xx;
+	struct cvmx_bgxx_smux_rx_udd_skp_s    cn75xx;
 	struct cvmx_bgxx_smux_rx_udd_skp_s    cn78xx;
+	struct cvmx_bgxx_smux_rx_udd_skp_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_rx_udd_skp cvmx_bgxx_smux_rx_udd_skp_t;
 
@@ -5790,7 +6188,9 @@ union cvmx_bgxx_smux_smac {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_smac_s          cn73xx;
+	struct cvmx_bgxx_smux_smac_s          cn75xx;
 	struct cvmx_bgxx_smux_smac_s          cn78xx;
+	struct cvmx_bgxx_smux_smac_s          cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_smac cvmx_bgxx_smux_smac_t;
 
@@ -5820,7 +6220,9 @@ union cvmx_bgxx_smux_tx_append {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_append_s     cn73xx;
+	struct cvmx_bgxx_smux_tx_append_s     cn75xx;
 	struct cvmx_bgxx_smux_tx_append_s     cn78xx;
+	struct cvmx_bgxx_smux_tx_append_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_append cvmx_bgxx_smux_tx_append_t;
 
@@ -5867,7 +6269,8 @@ union cvmx_bgxx_smux_tx_ctl {
                                                          2 = Remote fault. RS layer sends continuous idle sequences.
                                                          3 = Link drain. RS layer drops full packets to allow BGX and PKO to drain their FIFOs. */
 	uint64_t reserved_3_3                 : 1;
-	uint64_t x4a_dis                      : 1;  /**< Reserved. */
+	uint64_t x4a_dis                      : 1;  /**< Disable 4-byte SOP align (effectively force 8-byte SOP align) for all 10G variants
+                                                         (XAUI, RXAUI, 10G). Added in pass 2. */
 	uint64_t uni_en                       : 1;  /**< Enable unidirectional mode (IEEE Clause 66). */
 	uint64_t dic_en                       : 1;  /**< Enable the deficit idle counter for IFG averaging. */
 #else
@@ -5885,7 +6288,9 @@ union cvmx_bgxx_smux_tx_ctl {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_ctl_s        cn73xx;
+	struct cvmx_bgxx_smux_tx_ctl_s        cn75xx;
 	struct cvmx_bgxx_smux_tx_ctl_s        cn78xx;
+	struct cvmx_bgxx_smux_tx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_ctl cvmx_bgxx_smux_tx_ctl_t;
 
@@ -5912,7 +6317,9 @@ union cvmx_bgxx_smux_tx_ifg {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_ifg_s        cn73xx;
+	struct cvmx_bgxx_smux_tx_ifg_s        cn75xx;
 	struct cvmx_bgxx_smux_tx_ifg_s        cn78xx;
+	struct cvmx_bgxx_smux_tx_ifg_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_ifg cvmx_bgxx_smux_tx_ifg_t;
 
@@ -5940,7 +6347,9 @@ union cvmx_bgxx_smux_tx_int {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_int_s        cn73xx;
+	struct cvmx_bgxx_smux_tx_int_s        cn75xx;
 	struct cvmx_bgxx_smux_tx_int_s        cn78xx;
+	struct cvmx_bgxx_smux_tx_int_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_int cvmx_bgxx_smux_tx_int_t;
 
@@ -5961,7 +6370,9 @@ union cvmx_bgxx_smux_tx_min_pkt {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_min_pkt_s    cn73xx;
+	struct cvmx_bgxx_smux_tx_min_pkt_s    cn75xx;
 	struct cvmx_bgxx_smux_tx_min_pkt_s    cn78xx;
+	struct cvmx_bgxx_smux_tx_min_pkt_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_min_pkt cvmx_bgxx_smux_tx_min_pkt_t;
 
@@ -5983,7 +6394,9 @@ union cvmx_bgxx_smux_tx_pause_pkt_dmac {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_dmac cvmx_bgxx_smux_tx_pause_pkt_dmac_t;
 
@@ -6015,7 +6428,9 @@ union cvmx_bgxx_smux_tx_pause_pkt_interval {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_interval cvmx_bgxx_smux_tx_pause_pkt_interval_t;
 
@@ -6037,7 +6452,9 @@ union cvmx_bgxx_smux_tx_pause_pkt_time {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_time cvmx_bgxx_smux_tx_pause_pkt_time_t;
 
@@ -6059,7 +6476,9 @@ union cvmx_bgxx_smux_tx_pause_pkt_type {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_type cvmx_bgxx_smux_tx_pause_pkt_type_t;
 
@@ -6081,7 +6500,9 @@ union cvmx_bgxx_smux_tx_pause_togo {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_togo_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_togo_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_togo_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_togo_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_togo cvmx_bgxx_smux_tx_pause_togo_t;
 
@@ -6101,7 +6522,9 @@ union cvmx_bgxx_smux_tx_pause_zero {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_pause_zero_s cn73xx;
+	struct cvmx_bgxx_smux_tx_pause_zero_s cn75xx;
 	struct cvmx_bgxx_smux_tx_pause_zero_s cn78xx;
+	struct cvmx_bgxx_smux_tx_pause_zero_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_pause_zero cvmx_bgxx_smux_tx_pause_zero_t;
 
@@ -6120,7 +6543,9 @@ union cvmx_bgxx_smux_tx_soft_pause {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_soft_pause_s cn73xx;
+	struct cvmx_bgxx_smux_tx_soft_pause_s cn75xx;
 	struct cvmx_bgxx_smux_tx_soft_pause_s cn78xx;
+	struct cvmx_bgxx_smux_tx_soft_pause_s cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_soft_pause cvmx_bgxx_smux_tx_soft_pause_t;
 
@@ -6147,7 +6572,9 @@ union cvmx_bgxx_smux_tx_thresh {
 #endif
 	} s;
 	struct cvmx_bgxx_smux_tx_thresh_s     cn73xx;
+	struct cvmx_bgxx_smux_tx_thresh_s     cn75xx;
 	struct cvmx_bgxx_smux_tx_thresh_s     cn78xx;
+	struct cvmx_bgxx_smux_tx_thresh_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
 
@@ -6211,7 +6638,9 @@ union cvmx_bgxx_spux_an_adv {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_adv_s        cn73xx;
+	struct cvmx_bgxx_spux_an_adv_s        cn75xx;
 	struct cvmx_bgxx_spux_an_adv_s        cn78xx;
+	struct cvmx_bgxx_spux_an_adv_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
 
@@ -6253,7 +6682,9 @@ union cvmx_bgxx_spux_an_bp_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_bp_status_s  cn73xx;
+	struct cvmx_bgxx_spux_an_bp_status_s  cn75xx;
 	struct cvmx_bgxx_spux_an_bp_status_s  cn78xx;
+	struct cvmx_bgxx_spux_an_bp_status_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_bp_status cvmx_bgxx_spux_an_bp_status_t;
 
@@ -6293,7 +6724,9 @@ union cvmx_bgxx_spux_an_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_control_s    cn73xx;
+	struct cvmx_bgxx_spux_an_control_s    cn75xx;
 	struct cvmx_bgxx_spux_an_control_s    cn78xx;
+	struct cvmx_bgxx_spux_an_control_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
 
@@ -6350,7 +6783,9 @@ union cvmx_bgxx_spux_an_lp_base {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_lp_base_s    cn73xx;
+	struct cvmx_bgxx_spux_an_lp_base_s    cn75xx;
 	struct cvmx_bgxx_spux_an_lp_base_s    cn78xx;
+	struct cvmx_bgxx_spux_an_lp_base_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_lp_base cvmx_bgxx_spux_an_lp_base_t;
 
@@ -6384,7 +6819,9 @@ union cvmx_bgxx_spux_an_lp_xnp {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_lp_xnp_s     cn73xx;
+	struct cvmx_bgxx_spux_an_lp_xnp_s     cn75xx;
 	struct cvmx_bgxx_spux_an_lp_xnp_s     cn78xx;
+	struct cvmx_bgxx_spux_an_lp_xnp_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_lp_xnp cvmx_bgxx_spux_an_lp_xnp_t;
 
@@ -6439,7 +6876,9 @@ union cvmx_bgxx_spux_an_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_status_s     cn73xx;
+	struct cvmx_bgxx_spux_an_status_s     cn75xx;
 	struct cvmx_bgxx_spux_an_status_s     cn78xx;
+	struct cvmx_bgxx_spux_an_status_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_status cvmx_bgxx_spux_an_status_t;
 
@@ -6484,7 +6923,9 @@ union cvmx_bgxx_spux_an_xnp_tx {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_an_xnp_tx_s     cn73xx;
+	struct cvmx_bgxx_spux_an_xnp_tx_s     cn75xx;
 	struct cvmx_bgxx_spux_an_xnp_tx_s     cn78xx;
+	struct cvmx_bgxx_spux_an_xnp_tx_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
 
@@ -6524,7 +6965,9 @@ union cvmx_bgxx_spux_br_algn_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_algn_status_s cn73xx;
+	struct cvmx_bgxx_spux_br_algn_status_s cn75xx;
 	struct cvmx_bgxx_spux_br_algn_status_s cn78xx;
+	struct cvmx_bgxx_spux_br_algn_status_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
 
@@ -6560,7 +7003,9 @@ union cvmx_bgxx_spux_br_bip_err_cnt {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn73xx;
+	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn75xx;
 	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn78xx;
+	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
 
@@ -6606,7 +7051,9 @@ union cvmx_bgxx_spux_br_lane_map {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_lane_map_s   cn73xx;
+	struct cvmx_bgxx_spux_br_lane_map_s   cn75xx;
 	struct cvmx_bgxx_spux_br_lane_map_s   cn78xx;
+	struct cvmx_bgxx_spux_br_lane_map_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_lane_map cvmx_bgxx_spux_br_lane_map_t;
 
@@ -6630,7 +7077,9 @@ union cvmx_bgxx_spux_br_pmd_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_control_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_control_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_control_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_control_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_control cvmx_bgxx_spux_br_pmd_control_t;
 
@@ -6674,7 +7123,9 @@ union cvmx_bgxx_spux_br_pmd_ld_cup {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_cup cvmx_bgxx_spux_br_pmd_ld_cup_t;
 
@@ -6715,7 +7166,9 @@ union cvmx_bgxx_spux_br_pmd_ld_rep {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_rep cvmx_bgxx_spux_br_pmd_ld_rep_t;
 
@@ -6752,7 +7205,9 @@ union cvmx_bgxx_spux_br_pmd_lp_cup {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_cup cvmx_bgxx_spux_br_pmd_lp_cup_t;
 
@@ -6789,7 +7244,9 @@ union cvmx_bgxx_spux_br_pmd_lp_rep {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_rep cvmx_bgxx_spux_br_pmd_lp_rep_t;
 
@@ -6821,7 +7278,9 @@ union cvmx_bgxx_spux_br_pmd_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_pmd_status_s cn73xx;
+	struct cvmx_bgxx_spux_br_pmd_status_s cn75xx;
 	struct cvmx_bgxx_spux_br_pmd_status_s cn78xx;
+	struct cvmx_bgxx_spux_br_pmd_status_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_pmd_status cvmx_bgxx_spux_br_pmd_status_t;
 
@@ -6865,7 +7324,9 @@ union cvmx_bgxx_spux_br_status1 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_status1_s    cn73xx;
+	struct cvmx_bgxx_spux_br_status1_s    cn75xx;
 	struct cvmx_bgxx_spux_br_status1_s    cn78xx;
+	struct cvmx_bgxx_spux_br_status1_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
 
@@ -6933,7 +7394,9 @@ union cvmx_bgxx_spux_br_status2 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_status2_s    cn73xx;
+	struct cvmx_bgxx_spux_br_status2_s    cn75xx;
 	struct cvmx_bgxx_spux_br_status2_s    cn78xx;
+	struct cvmx_bgxx_spux_br_status2_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_status2 cvmx_bgxx_spux_br_status2_t;
 
@@ -6974,7 +7437,9 @@ union cvmx_bgxx_spux_br_tp_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_tp_control_s cn73xx;
+	struct cvmx_bgxx_spux_br_tp_control_s cn75xx;
 	struct cvmx_bgxx_spux_br_tp_control_s cn78xx;
+	struct cvmx_bgxx_spux_br_tp_control_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_tp_control cvmx_bgxx_spux_br_tp_control_t;
 
@@ -7004,7 +7469,9 @@ union cvmx_bgxx_spux_br_tp_err_cnt {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn73xx;
+	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn75xx;
 	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn78xx;
+	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_br_tp_err_cnt cvmx_bgxx_spux_br_tp_err_cnt_t;
 
@@ -7034,7 +7501,9 @@ union cvmx_bgxx_spux_bx_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_bx_status_s     cn73xx;
+	struct cvmx_bgxx_spux_bx_status_s     cn75xx;
 	struct cvmx_bgxx_spux_bx_status_s     cn78xx;
+	struct cvmx_bgxx_spux_bx_status_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_bx_status cvmx_bgxx_spux_bx_status_t;
 
@@ -7092,7 +7561,9 @@ union cvmx_bgxx_spux_control1 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_control1_s      cn73xx;
+	struct cvmx_bgxx_spux_control1_s      cn75xx;
 	struct cvmx_bgxx_spux_control1_s      cn78xx;
+	struct cvmx_bgxx_spux_control1_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_control1 cvmx_bgxx_spux_control1_t;
 
@@ -7126,7 +7597,9 @@ union cvmx_bgxx_spux_control2 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_control2_s      cn73xx;
+	struct cvmx_bgxx_spux_control2_s      cn75xx;
 	struct cvmx_bgxx_spux_control2_s      cn78xx;
+	struct cvmx_bgxx_spux_control2_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_control2 cvmx_bgxx_spux_control2_t;
 
@@ -7149,7 +7622,9 @@ union cvmx_bgxx_spux_fec_abil {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_abil_s      cn73xx;
+	struct cvmx_bgxx_spux_fec_abil_s      cn75xx;
 	struct cvmx_bgxx_spux_fec_abil_s      cn78xx;
+	struct cvmx_bgxx_spux_fec_abil_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_abil cvmx_bgxx_spux_fec_abil_t;
 
@@ -7178,7 +7653,9 @@ union cvmx_bgxx_spux_fec_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_control_s   cn73xx;
+	struct cvmx_bgxx_spux_fec_control_s   cn75xx;
 	struct cvmx_bgxx_spux_fec_control_s   cn78xx;
+	struct cvmx_bgxx_spux_fec_control_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
 
@@ -7216,7 +7693,9 @@ union cvmx_bgxx_spux_fec_corr_blks01 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_corr_blks01_s cn73xx;
+	struct cvmx_bgxx_spux_fec_corr_blks01_s cn75xx;
 	struct cvmx_bgxx_spux_fec_corr_blks01_s cn78xx;
+	struct cvmx_bgxx_spux_fec_corr_blks01_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
 
@@ -7249,7 +7728,9 @@ union cvmx_bgxx_spux_fec_corr_blks23 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_corr_blks23_s cn73xx;
+	struct cvmx_bgxx_spux_fec_corr_blks23_s cn75xx;
 	struct cvmx_bgxx_spux_fec_corr_blks23_s cn78xx;
+	struct cvmx_bgxx_spux_fec_corr_blks23_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
 
@@ -7287,7 +7768,9 @@ union cvmx_bgxx_spux_fec_uncorr_blks01 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn73xx;
+	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn75xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn78xx;
+	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_t;
 
@@ -7320,7 +7803,9 @@ union cvmx_bgxx_spux_fec_uncorr_blks23 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn73xx;
+	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn75xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn78xx;
+	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks23 cvmx_bgxx_spux_fec_uncorr_blks23_t;
 
@@ -7407,7 +7892,9 @@ union cvmx_bgxx_spux_int {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_int_s           cn73xx;
+	struct cvmx_bgxx_spux_int_s           cn75xx;
 	struct cvmx_bgxx_spux_int_s           cn78xx;
+	struct cvmx_bgxx_spux_int_s           cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_int cvmx_bgxx_spux_int_t;
 
@@ -7436,7 +7923,9 @@ union cvmx_bgxx_spux_lpcs_states {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_lpcs_states_s   cn73xx;
+	struct cvmx_bgxx_spux_lpcs_states_s   cn75xx;
 	struct cvmx_bgxx_spux_lpcs_states_s   cn78xx;
+	struct cvmx_bgxx_spux_lpcs_states_s   cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_lpcs_states cvmx_bgxx_spux_lpcs_states_t;
 
@@ -7509,7 +7998,9 @@ union cvmx_bgxx_spux_misc_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_misc_control_s  cn73xx;
+	struct cvmx_bgxx_spux_misc_control_s  cn75xx;
 	struct cvmx_bgxx_spux_misc_control_s  cn78xx;
+	struct cvmx_bgxx_spux_misc_control_s  cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_misc_control cvmx_bgxx_spux_misc_control_t;
 
@@ -7534,7 +8025,9 @@ union cvmx_bgxx_spux_spd_abil {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_spd_abil_s      cn73xx;
+	struct cvmx_bgxx_spux_spd_abil_s      cn75xx;
 	struct cvmx_bgxx_spux_spd_abil_s      cn78xx;
+	struct cvmx_bgxx_spux_spd_abil_s      cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_spd_abil cvmx_bgxx_spux_spd_abil_t;
 
@@ -7572,7 +8065,9 @@ union cvmx_bgxx_spux_status1 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_status1_s       cn73xx;
+	struct cvmx_bgxx_spux_status1_s       cn75xx;
 	struct cvmx_bgxx_spux_status1_s       cn78xx;
+	struct cvmx_bgxx_spux_status1_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_status1 cvmx_bgxx_spux_status1_t;
 
@@ -7614,7 +8109,9 @@ union cvmx_bgxx_spux_status2 {
 #endif
 	} s;
 	struct cvmx_bgxx_spux_status2_s       cn73xx;
+	struct cvmx_bgxx_spux_status2_s       cn75xx;
 	struct cvmx_bgxx_spux_status2_s       cn78xx;
+	struct cvmx_bgxx_spux_status2_s       cn78xxp2;
 };
 typedef union cvmx_bgxx_spux_status2 cvmx_bgxx_spux_status2_t;
 
@@ -7637,7 +8134,9 @@ union cvmx_bgxx_spu_bist_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_bist_status_s    cn73xx;
+	struct cvmx_bgxx_spu_bist_status_s    cn75xx;
 	struct cvmx_bgxx_spu_bist_status_s    cn78xx;
+	struct cvmx_bgxx_spu_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_bist_status cvmx_bgxx_spu_bist_status_t;
 
@@ -7755,7 +8254,9 @@ union cvmx_bgxx_spu_dbg_control {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_dbg_control_s    cn73xx;
+	struct cvmx_bgxx_spu_dbg_control_s    cn75xx;
 	struct cvmx_bgxx_spu_dbg_control_s    cn78xx;
+	struct cvmx_bgxx_spu_dbg_control_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_dbg_control cvmx_bgxx_spu_dbg_control_t;
 
@@ -7778,7 +8279,9 @@ union cvmx_bgxx_spu_mem_int {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_mem_int_s        cn73xx;
+	struct cvmx_bgxx_spu_mem_int_s        cn75xx;
 	struct cvmx_bgxx_spu_mem_int_s        cn78xx;
+	struct cvmx_bgxx_spu_mem_int_s        cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_mem_int cvmx_bgxx_spu_mem_int_t;
 
@@ -7803,7 +8306,9 @@ union cvmx_bgxx_spu_mem_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_mem_status_s     cn73xx;
+	struct cvmx_bgxx_spu_mem_status_s     cn75xx;
 	struct cvmx_bgxx_spu_mem_status_s     cn78xx;
+	struct cvmx_bgxx_spu_mem_status_s     cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_mem_status cvmx_bgxx_spu_mem_status_t;
 
@@ -7825,7 +8330,9 @@ union cvmx_bgxx_spu_sdsx_skew_status {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_sdsx_skew_status_s cn73xx;
+	struct cvmx_bgxx_spu_sdsx_skew_status_s cn75xx;
 	struct cvmx_bgxx_spu_sdsx_skew_status_s cn78xx;
+	struct cvmx_bgxx_spu_sdsx_skew_status_s cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_sdsx_skew_status cvmx_bgxx_spu_sdsx_skew_status_t;
 
@@ -7883,7 +8390,9 @@ union cvmx_bgxx_spu_sdsx_states {
 #endif
 	} s;
 	struct cvmx_bgxx_spu_sdsx_states_s    cn73xx;
+	struct cvmx_bgxx_spu_sdsx_states_s    cn75xx;
 	struct cvmx_bgxx_spu_sdsx_states_s    cn78xx;
+	struct cvmx_bgxx_spu_sdsx_states_s    cn78xxp2;
 };
 typedef union cvmx_bgxx_spu_sdsx_states cvmx_bgxx_spu_sdsx_states_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index ab2aa80..c91d383 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -218,6 +218,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			break;
 	}
@@ -245,6 +246,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000720ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000720ull);
@@ -440,6 +442,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			break;
 	}
@@ -467,6 +470,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000728ull);
@@ -967,6 +971,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			break;
 	}
@@ -994,6 +999,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000708ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000708ull);
@@ -1041,6 +1047,7 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 15))
 				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 15) * 8;
 			break;
@@ -1078,6 +1085,7 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
@@ -1107,6 +1115,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			break;
 	}
@@ -1134,6 +1143,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000700ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000700ull);
@@ -1149,6 +1159,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			break;
 	}
@@ -1164,6 +1175,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000110ull);
@@ -1502,6 +1514,7 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 15))
 				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 15) * 8;
 			break;
@@ -1539,6 +1552,7 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
@@ -2782,7 +2796,9 @@ union cvmx_ciu_dint {
 	struct cvmx_ciu_dint_cn52xx           cn70xx;
 	struct cvmx_ciu_dint_cn52xx           cn70xxp1;
 	struct cvmx_ciu_dint_cn38xx           cn73xx;
+	struct cvmx_ciu_dint_cn38xx           cn75xx;
 	struct cvmx_ciu_dint_s                cn78xx;
+	struct cvmx_ciu_dint_s                cn78xxp2;
 	struct cvmx_ciu_dint_cn52xx           cnf71xx;
 };
 typedef union cvmx_ciu_dint cvmx_ciu_dint_t;
@@ -3960,7 +3976,9 @@ union cvmx_ciu_fuse {
 	struct cvmx_ciu_fuse_cn52xx           cn70xx;
 	struct cvmx_ciu_fuse_cn52xx           cn70xxp1;
 	struct cvmx_ciu_fuse_cn38xx           cn73xx;
+	struct cvmx_ciu_fuse_cn38xx           cn75xx;
 	struct cvmx_ciu_fuse_s                cn78xx;
+	struct cvmx_ciu_fuse_s                cn78xxp2;
 	struct cvmx_ciu_fuse_cn52xx           cnf71xx;
 };
 typedef union cvmx_ciu_fuse cvmx_ciu_fuse_t;
@@ -12945,7 +12963,9 @@ union cvmx_ciu_pp_dbg {
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xxp1;
 	struct cvmx_ciu_pp_dbg_cn38xx         cn73xx;
+	struct cvmx_ciu_pp_dbg_cn38xx         cn75xx;
 	struct cvmx_ciu_pp_dbg_s              cn78xx;
+	struct cvmx_ciu_pp_dbg_s              cn78xxp2;
 	struct cvmx_ciu_pp_dbg_cn52xx         cnf71xx;
 };
 typedef union cvmx_ciu_pp_dbg cvmx_ciu_pp_dbg_t;
@@ -12997,7 +13017,9 @@ union cvmx_ciu_pp_pokex {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} cn73xx;
+	struct cvmx_ciu_pp_pokex_cn73xx       cn75xx;
 	struct cvmx_ciu_pp_pokex_cn73xx       cn78xx;
+	struct cvmx_ciu_pp_pokex_cn73xx       cn78xxp2;
 	struct cvmx_ciu_pp_pokex_s            cnf71xx;
 };
 typedef union cvmx_ciu_pp_pokex cvmx_ciu_pp_pokex_t;
@@ -13130,7 +13152,9 @@ union cvmx_ciu_pp_rst {
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xxp1;
 	struct cvmx_ciu_pp_rst_cn38xx         cn73xx;
+	struct cvmx_ciu_pp_rst_cn38xx         cn75xx;
 	struct cvmx_ciu_pp_rst_s              cn78xx;
+	struct cvmx_ciu_pp_rst_s              cn78xxp2;
 	struct cvmx_ciu_pp_rst_cn52xx         cnf71xx;
 };
 typedef union cvmx_ciu_pp_rst cvmx_ciu_pp_rst_t;
@@ -13169,7 +13193,9 @@ union cvmx_ciu_pp_rst_pending {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_ciu_pp_rst_pending_cn73xx cn75xx;
 	struct cvmx_ciu_pp_rst_pending_s      cn78xx;
+	struct cvmx_ciu_pp_rst_pending_s      cn78xxp2;
 };
 typedef union cvmx_ciu_pp_rst_pending cvmx_ciu_pp_rst_pending_t;
 
@@ -16800,7 +16826,9 @@ union cvmx_ciu_wdogx {
 	struct cvmx_ciu_wdogx_s               cn70xx;
 	struct cvmx_ciu_wdogx_s               cn70xxp1;
 	struct cvmx_ciu_wdogx_s               cn73xx;
+	struct cvmx_ciu_wdogx_s               cn75xx;
 	struct cvmx_ciu_wdogx_s               cn78xx;
+	struct cvmx_ciu_wdogx_s               cn78xxp2;
 	struct cvmx_ciu_wdogx_s               cnf71xx;
 };
 typedef union cvmx_ciu_wdogx cvmx_ciu_wdogx_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 3be9e88..5e0d178 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_CIU3_BIST CVMX_CIU3_BIST_FUNC()
 static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_BIST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000001C0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 #define CVMX_CIU3_CONST CVMX_CIU3_CONST_FUNC()
 static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CONST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000220ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 #define CVMX_CIU3_CTL CVMX_CIU3_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000000E0ull);
 }
@@ -90,6 +90,7 @@ static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_CIU3_DESTX_IO_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000210000ull) + ((offset) & 7) * 8;
@@ -102,6 +103,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 47))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 143)))))
 		cvmx_warn("CVMX_CIU3_DESTX_PP_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000200000ull) + ((offset) & 255) * 8;
@@ -113,7 +115,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 #define CVMX_CIU3_GSTOP CVMX_CIU3_GSTOP_FUNC()
 static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_GSTOP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000140ull);
 }
@@ -125,6 +127,7 @@ static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000110000ull) + ((offset) & 255) * 8;
@@ -137,6 +140,7 @@ static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_IO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000130000ull) + ((offset) & 255) * 8;
@@ -149,6 +153,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 255)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 255)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id <= 255))))))
 		cvmx_warn("CVMX_CIU3_IDTX_PPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001010000120000ull) + ((block_id) & 255) * 0x20ull;
@@ -160,7 +165,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 #define CVMX_CIU3_INTR_RAM_ECC_CTL CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000260ull);
 }
@@ -171,7 +176,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 #define CVMX_CIU3_INTR_RAM_ECC_ST CVMX_CIU3_INTR_RAM_ECC_ST_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_ST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000280ull);
 }
@@ -182,7 +187,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 #define CVMX_CIU3_INTR_READY CVMX_CIU3_INTR_READY_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_READY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000002A0ull);
 }
@@ -193,7 +198,7 @@ static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN CVMX_CIU3_INTR_SLOWDOWN_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_SLOWDOWN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000240ull);
 }
@@ -205,6 +210,7 @@ static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010080000000ull) + ((offset) & 1048575) * 8;
@@ -217,6 +223,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010090000000ull) + ((offset) & 1048575) * 8;
@@ -229,6 +236,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010100A0000000ull) + ((offset) & 1048575) * 8;
@@ -240,7 +248,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 #define CVMX_CIU3_NMI CVMX_CIU3_NMI_FUNC()
 static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_NMI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000160ull);
 }
@@ -252,6 +260,7 @@ static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 191))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 191))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_CIU3_SISCX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000220000ull) + ((offset) & 255) * 8;
@@ -264,6 +273,7 @@ static inline uint64_t CVMX_CIU3_TIMX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 9))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_CIU3_TIMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000010000ull) + ((offset) & 15) * 8;
@@ -296,7 +306,9 @@ union cvmx_ciu3_bist {
 #endif
 	} s;
 	struct cvmx_ciu3_bist_s               cn73xx;
+	struct cvmx_ciu3_bist_s               cn75xx;
 	struct cvmx_ciu3_bist_s               cn78xx;
+	struct cvmx_ciu3_bist_s               cn78xxp2;
 };
 typedef union cvmx_ciu3_bist cvmx_ciu3_bist_t;
 
@@ -319,7 +331,9 @@ union cvmx_ciu3_const {
 #endif
 	} s;
 	struct cvmx_ciu3_const_s              cn73xx;
+	struct cvmx_ciu3_const_s              cn75xx;
 	struct cvmx_ciu3_const_s              cn78xx;
+	struct cvmx_ciu3_const_s              cn78xxp2;
 };
 typedef union cvmx_ciu3_const cvmx_ciu3_const_t;
 
@@ -349,7 +363,9 @@ union cvmx_ciu3_ctl {
 #endif
 	} s;
 	struct cvmx_ciu3_ctl_s                cn73xx;
+	struct cvmx_ciu3_ctl_s                cn75xx;
 	struct cvmx_ciu3_ctl_s                cn78xx;
+	struct cvmx_ciu3_ctl_s                cn78xxp2;
 };
 typedef union cvmx_ciu3_ctl cvmx_ciu3_ctl_t;
 
@@ -382,7 +398,9 @@ union cvmx_ciu3_destx_io_int {
 #endif
 	} s;
 	struct cvmx_ciu3_destx_io_int_s       cn73xx;
+	struct cvmx_ciu3_destx_io_int_s       cn75xx;
 	struct cvmx_ciu3_destx_io_int_s       cn78xx;
+	struct cvmx_ciu3_destx_io_int_s       cn78xxp2;
 };
 typedef union cvmx_ciu3_destx_io_int cvmx_ciu3_destx_io_int_t;
 
@@ -415,7 +433,9 @@ union cvmx_ciu3_destx_pp_int {
 #endif
 	} s;
 	struct cvmx_ciu3_destx_pp_int_s       cn73xx;
+	struct cvmx_ciu3_destx_pp_int_s       cn75xx;
 	struct cvmx_ciu3_destx_pp_int_s       cn78xx;
+	struct cvmx_ciu3_destx_pp_int_s       cn78xxp2;
 };
 typedef union cvmx_ciu3_destx_pp_int cvmx_ciu3_destx_pp_int_t;
 
@@ -434,7 +454,9 @@ union cvmx_ciu3_gstop {
 #endif
 	} s;
 	struct cvmx_ciu3_gstop_s              cn73xx;
+	struct cvmx_ciu3_gstop_s              cn75xx;
 	struct cvmx_ciu3_gstop_s              cn78xx;
+	struct cvmx_ciu3_gstop_s              cn78xxp2;
 };
 typedef union cvmx_ciu3_gstop cvmx_ciu3_gstop_t;
 
@@ -471,7 +493,9 @@ union cvmx_ciu3_idtx_ctl {
 #endif
 	} s;
 	struct cvmx_ciu3_idtx_ctl_s           cn73xx;
+	struct cvmx_ciu3_idtx_ctl_s           cn75xx;
 	struct cvmx_ciu3_idtx_ctl_s           cn78xx;
+	struct cvmx_ciu3_idtx_ctl_s           cn78xxp2;
 };
 typedef union cvmx_ciu3_idtx_ctl cvmx_ciu3_idtx_ctl_t;
 
@@ -494,7 +518,9 @@ union cvmx_ciu3_idtx_io {
 #endif
 	} s;
 	struct cvmx_ciu3_idtx_io_s            cn73xx;
+	struct cvmx_ciu3_idtx_io_s            cn75xx;
 	struct cvmx_ciu3_idtx_io_s            cn78xx;
+	struct cvmx_ciu3_idtx_io_s            cn78xxp2;
 };
 typedef union cvmx_ciu3_idtx_io cvmx_ciu3_idtx_io_t;
 
@@ -524,7 +550,9 @@ union cvmx_ciu3_idtx_ppx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_ciu3_idtx_ppx_cn73xx      cn75xx;
 	struct cvmx_ciu3_idtx_ppx_s           cn78xx;
+	struct cvmx_ciu3_idtx_ppx_s           cn78xxp2;
 };
 typedef union cvmx_ciu3_idtx_ppx cvmx_ciu3_idtx_ppx_t;
 
@@ -548,7 +576,9 @@ union cvmx_ciu3_intr_ram_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn73xx;
+	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn75xx;
 	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn78xx;
+	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn78xxp2;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_ctl cvmx_ciu3_intr_ram_ecc_ctl_t;
 
@@ -581,7 +611,9 @@ union cvmx_ciu3_intr_ram_ecc_st {
 #endif
 	} s;
 	struct cvmx_ciu3_intr_ram_ecc_st_s    cn73xx;
+	struct cvmx_ciu3_intr_ram_ecc_st_s    cn75xx;
 	struct cvmx_ciu3_intr_ram_ecc_st_s    cn78xx;
+	struct cvmx_ciu3_intr_ram_ecc_st_s    cn78xxp2;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_st cvmx_ciu3_intr_ram_ecc_st_t;
 
@@ -606,7 +638,9 @@ union cvmx_ciu3_intr_ready {
 #endif
 	} s;
 	struct cvmx_ciu3_intr_ready_s         cn73xx;
+	struct cvmx_ciu3_intr_ready_s         cn75xx;
 	struct cvmx_ciu3_intr_ready_s         cn78xx;
+	struct cvmx_ciu3_intr_ready_s         cn78xxp2;
 };
 typedef union cvmx_ciu3_intr_ready cvmx_ciu3_intr_ready_t;
 
@@ -630,7 +664,9 @@ union cvmx_ciu3_intr_slowdown {
 #endif
 	} s;
 	struct cvmx_ciu3_intr_slowdown_s      cn73xx;
+	struct cvmx_ciu3_intr_slowdown_s      cn75xx;
 	struct cvmx_ciu3_intr_slowdown_s      cn78xx;
+	struct cvmx_ciu3_intr_slowdown_s      cn78xxp2;
 };
 typedef union cvmx_ciu3_intr_slowdown cvmx_ciu3_intr_slowdown_t;
 
@@ -670,7 +706,9 @@ union cvmx_ciu3_iscx_ctl {
 #endif
 	} s;
 	struct cvmx_ciu3_iscx_ctl_s           cn73xx;
+	struct cvmx_ciu3_iscx_ctl_s           cn75xx;
 	struct cvmx_ciu3_iscx_ctl_s           cn78xx;
+	struct cvmx_ciu3_iscx_ctl_s           cn78xxp2;
 };
 typedef union cvmx_ciu3_iscx_ctl cvmx_ciu3_iscx_ctl_t;
 
@@ -691,7 +729,9 @@ union cvmx_ciu3_iscx_w1c {
 #endif
 	} s;
 	struct cvmx_ciu3_iscx_w1c_s           cn73xx;
+	struct cvmx_ciu3_iscx_w1c_s           cn75xx;
 	struct cvmx_ciu3_iscx_w1c_s           cn78xx;
+	struct cvmx_ciu3_iscx_w1c_s           cn78xxp2;
 };
 typedef union cvmx_ciu3_iscx_w1c cvmx_ciu3_iscx_w1c_t;
 
@@ -712,7 +752,9 @@ union cvmx_ciu3_iscx_w1s {
 #endif
 	} s;
 	struct cvmx_ciu3_iscx_w1s_s           cn73xx;
+	struct cvmx_ciu3_iscx_w1s_s           cn75xx;
 	struct cvmx_ciu3_iscx_w1s_s           cn78xx;
+	struct cvmx_ciu3_iscx_w1s_s           cn78xxp2;
 };
 typedef union cvmx_ciu3_iscx_w1s cvmx_ciu3_iscx_w1s_t;
 
@@ -739,7 +781,9 @@ union cvmx_ciu3_nmi {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_ciu3_nmi_cn73xx           cn75xx;
 	struct cvmx_ciu3_nmi_s                cn78xx;
+	struct cvmx_ciu3_nmi_s                cn78xxp2;
 };
 typedef union cvmx_ciu3_nmi cvmx_ciu3_nmi_t;
 
@@ -756,7 +800,9 @@ union cvmx_ciu3_siscx {
 #endif
 	} s;
 	struct cvmx_ciu3_siscx_s              cn73xx;
+	struct cvmx_ciu3_siscx_s              cn75xx;
 	struct cvmx_ciu3_siscx_s              cn78xx;
+	struct cvmx_ciu3_siscx_s              cn78xxp2;
 };
 typedef union cvmx_ciu3_siscx cvmx_ciu3_siscx_t;
 
@@ -780,7 +826,9 @@ union cvmx_ciu3_timx {
 #endif
 	} s;
 	struct cvmx_ciu3_timx_s               cn73xx;
+	struct cvmx_ciu3_timx_s               cn75xx;
 	struct cvmx_ciu3_timx_s               cn78xx;
+	struct cvmx_ciu3_timx_s               cn78xxp2;
 };
 typedef union cvmx_ciu3_timx cvmx_ciu3_timx_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-clock.h b/arch/mips/include/asm/octeon/cvmx-clock.h
index 275ff5f..564fdbc 100644
--- a/arch/mips/include/asm/octeon/cvmx-clock.h
+++ b/arch/mips/include/asm/octeon/cvmx-clock.h
@@ -115,12 +115,14 @@ static inline uint64_t cvmx_clock_get_count(cvmx_clock_t clock)
 	case CVMX_CLOCK_SCLK:
 	case CVMX_CLOCK_IPD:
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)
-		    || OCTEON_IS_MODEL(OCTEON_CN73XX))
+		    || OCTEON_IS_MODEL(OCTEON_CN73XX)
+		    || OCTEON_IS_MODEL(OCTEON_CN75XX))
 			return cvmx_read_csr(CVMX_FPA_CLK_COUNT);
 		return cvmx_read_csr(CVMX_IPD_CLK_COUNT);
 	case CVMX_CLOCK_TIM:
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)
-		    || OCTEON_IS_MODEL(OCTEON_CN73XX))
+		    || OCTEON_IS_MODEL(OCTEON_CN73XX)
+		    || OCTEON_IS_MODEL(OCTEON_CN75XX))
 			return cvmx_read_csr(CVMX_TIM_FR_RN_CYCLES);
 		return cvmx_read_csr(CVMX_IPD_CLK_COUNT);
 
diff --git a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
index 51dd1ff..6eb0bf3 100644
--- a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
@@ -82,7 +82,7 @@
  * internal cycle counter to completely eliminate any causes of
  * bus traffic.
  *
- * <hr> $Revision: 110896 $ <hr>
+ * <hr> $Revision: 111003 $ <hr>
  */
 
 #ifndef __CVMX_CMD_QUEUE_H__
@@ -151,17 +151,17 @@ typedef struct {
 	uint64_t fpa_pool:16;		/**< FPA1:POOL/FPA3:GAURA for buffers */
 	uint64_t base_paddr:48;		/**< command buffer physical address */
 	/* Second 64-bit word: */
-	uint64_t max_depth: 32;		/**< Maximum outstanding cmd words */
-	uint64_t pool_size_m1:16;	/**< FPA buffer size in dwords - 1 */
-	uint64_t index:16;		/**< Number of cmd words in buffer */
+	int32_t index;			/**< Number of cmd words in buffer */
+	uint16_t max_depth;		/**< Maximum outstanding blocks */
+	uint16_t pool_size_m1;		/**< FPA buffer size in dwords - 1 */
 #else
 	/* First 64-bit word: */
 	uint64_t base_paddr:48;
 	uint64_t fpa_pool:16;
 	/* Second 64-bit word: */
-	uint64_t index:16;
-	uint64_t pool_size_m1:16;
-	uint64_t max_depth: 32;
+	uint16_t pool_size_m1;
+	uint16_t max_depth;
+	int32_t index;
 #endif
 } __cvmx_cmd_queue_state_t;
 
@@ -177,6 +177,7 @@ typedef struct {
 } __cvmx_cmd_queue_lock_t;
 
 /**
+ * @INTERNAL
  * This structure contains the global state of all command queues.
  * It is stored in a bootmem named block and shared by all
  * applications running on Octeon. Tickets are stored in a different
@@ -193,6 +194,18 @@ extern CVMX_SHARED __cvmx_cmd_queue_all_state_t *
 __cvmx_cmd_queue_state_ptrs[CVMX_MAX_NODES];
 
 /**
+ * @INTERNAL
+ * Internal function to handle the corner cases
+ * of adding command words to a queue when the current
+ * block is getting full.
+ */
+extern cvmx_cmd_queue_result_t
+		__cvmx_cmd_queue_write_raw(cvmx_cmd_queue_id_t queue_id,
+			__cvmx_cmd_queue_state_t *qptr,
+			int cmd_count, const uint64_t *cmds);
+
+
+/**
  * Initialize a command queue for use. The initial FPA buffer is
  * allocated and the hardware unit is configured to point to the
  * new command queue.
@@ -396,13 +409,6 @@ __cvmx_cmd_queue_get_state(cvmx_cmd_queue_id_t queue_id)
 	return qptr;
 }
 
-static inline uint64_t *__cvmx_cmd_queue_alloc_buffer(int pool)
-{
-	uint64_t *new_buffer;
-	new_buffer = cvmx_fpa_alloc(pool);
-	return new_buffer;
-}
-
 /**
  * Write an arbitrary number of command words to a command queue.
  * This is a generic function; the fixed number of command word
@@ -419,9 +425,12 @@ static inline uint64_t *__cvmx_cmd_queue_alloc_buffer(int pool)
  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code
  */
 static inline cvmx_cmd_queue_result_t
-cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
-		     int cmd_count, uint64_t * cmds)
+cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, bool use_locking,
+		     int cmd_count, const uint64_t *cmds)
 {
+	cvmx_cmd_queue_result_t ret = CVMX_CMD_QUEUE_SUCCESS;
+	uint64_t *cmd_ptr;
+
 	__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);
 
 	if (CVMX_ENABLE_PARAMETER_CHECKING) {
@@ -437,52 +446,19 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (cvmx_likely(use_locking))
 		__cvmx_cmd_queue_lock(queue_id);
 
-	/* If a max queue length was specified then make sure we don't
-	   exceed it. If any part of the command would be below the limit
-	   we allow it */
-	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
-		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_FULL;
-		}
-	}
-
-	/* Normally there is plenty of room in the current buffer for the command */
-	if (cvmx_likely(qptr->index + cmd_count < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		ptr += qptr->index;
-		qptr->index += cmd_count;
-		while (cmd_count--)
-			*ptr++ = *cmds++;
+	/* Most of the time there is lots of free words in current block */
+	if (cvmx_unlikely(
+	    (qptr->index + cmd_count) >= qptr->pool_size_m1)) {
+		/* The rare case when nearing end of block */
+		ret = __cvmx_cmd_queue_write_raw(queue_id, qptr,
+			cmd_count, cmds);
 	} else {
-		uint64_t *ptr;
-		int count;
-		/* We need a new command buffer. Fail if there isn't one available */
-		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
-		if (cvmx_unlikely(new_buffer == NULL)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_NO_MEMORY;
+		cmd_ptr = cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
+		/* Loop easy for compiler to unroll for the likely case */
+		while (cmd_count > 0) {
+			cmd_ptr[ qptr->index ++ ] = *cmds++;
+			cmd_count --;
 		}
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		/* Figure out how many command words will fit in this buffer.
-		 * One location will be needed for the next buffer pointer
-		 */
-		count = qptr->pool_size_m1 - qptr->index;
-		ptr += qptr->index;
-		cmd_count -= count;
-		while (count--)
-			*ptr++ = *cmds++;
-		*ptr = cvmx_ptr_to_phys(new_buffer);
-		/* The current buffer is full and has a link to the next buffer.
-		 * Time to write the rest of the commands into the new buffer
-		 */
-		qptr->base_paddr = *ptr;
-		qptr->index = cmd_count;
-		ptr = new_buffer;
-		while (cmd_count--)
-			*ptr++ = *cmds++;
 	}
 
 	/* All updates are complete. Release the lock and return */
@@ -491,12 +467,11 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	else
 		CVMX_SYNCWS;
 
-	return CVMX_CMD_QUEUE_SUCCESS;
+	return ret;
 }
 
 /**
- * Simple function to write two command words to a command
- * queue.
+ * Simple function to write two command words to a command queue.
  *
  * @param queue_id Hardware command queue to write to
  * @param use_locking
@@ -509,9 +484,12 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code
  */
 static inline cvmx_cmd_queue_result_t
-cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
+cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, bool use_locking,
 		      uint64_t cmd1, uint64_t cmd2)
 {
+	cvmx_cmd_queue_result_t ret = CVMX_CMD_QUEUE_SUCCESS;
+	uint64_t *cmd_ptr;
+
 	__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);
 
 	if (CVMX_ENABLE_PARAMETER_CHECKING) {
@@ -523,51 +501,19 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (cvmx_likely(use_locking))
 		__cvmx_cmd_queue_lock(queue_id);
 
-	/* If a max queue length was specified then make sure we don't
-	   exceed it. If any part of the command would be below the limit
-	   we allow it */
-	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
-		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_FULL;
-		}
-	}
-
-	/* Normally there is plenty of room in the current buffer for the command */
-	if (cvmx_likely(qptr->index + 2 < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		ptr += qptr->index;
-		qptr->index += 2;
-		ptr[0] = cmd1;
-		ptr[1] = cmd2;
+	if (cvmx_unlikely((qptr->index + 2) >= qptr->pool_size_m1)) {
+		/* The rare case when nearing end of block */
+		uint64_t cmds[2];
+		cmds[0] = cmd1;
+		cmds[1] = cmd2;
+		ret = __cvmx_cmd_queue_write_raw(queue_id, qptr, 2, cmds);
 	} else {
-		uint64_t *ptr;
-		/* Figure out how many command words will fit in this buffer. One
-		   location will be needed for the next buffer pointer */
-		int count = qptr->pool_size_m1 - qptr->index;
-		/* We need a new command buffer. Fail if there isn't one available */
-		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
-		if (cvmx_unlikely(new_buffer == NULL)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_NO_MEMORY;
-		}
-		count--;
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		ptr += qptr->index;
-		*ptr++ = cmd1;
-		if (cvmx_likely(count))
-			*ptr++ = cmd2;
-		*ptr = cvmx_ptr_to_phys(new_buffer);
-		/* The current buffer is full and has a link to the next buffer. Time
-		   to write the rest of the commands into the new buffer */
-		qptr->base_paddr = *ptr;
-		qptr->index = 0;
-		if (cvmx_unlikely(count == 0)) {
-			qptr->index = 1;
-			new_buffer[0] = cmd2;
-		}
+		/* Likely case to work fast */
+		cmd_ptr = cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
+		cmd_ptr += qptr->index;
+		qptr->index += 2;
+		cmd_ptr[0] = cmd1;
+		cmd_ptr[1] = cmd2;
 	}
 
 	/* All updates are complete. Release the lock and return */
@@ -575,12 +521,12 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		__cvmx_cmd_queue_unlock(queue_id);
 	else
 		CVMX_SYNCWS;
-	return CVMX_CMD_QUEUE_SUCCESS;
+
+	return ret;
 }
 
 /**
- * Simple function to write three command words to a command
- * queue.
+ * Simple function to write three command words to a command queue.
  *
  * @param queue_id Hardware command queue to write to
  * @param use_locking
@@ -594,9 +540,12 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code
  */
 static inline cvmx_cmd_queue_result_t
-cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
+cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, bool use_locking,
 		      uint64_t cmd1, uint64_t cmd2, uint64_t cmd3)
 {
+	cvmx_cmd_queue_result_t ret = CVMX_CMD_QUEUE_SUCCESS;
+	uint64_t *cmd_ptr;
+
 	__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);
 
 	if (CVMX_ENABLE_PARAMETER_CHECKING) {
@@ -608,62 +557,20 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (cvmx_likely(use_locking))
 		__cvmx_cmd_queue_lock(queue_id);
 
-	/* If a max queue length was specified then make sure we don't
-	   exceed it. If any part of the command would be below the limit
-	   we allow it */
-	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
-		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_FULL;
-		}
-	}
-
-	/* Normally there is plenty of room in the current buffer for the command */
-	if (cvmx_likely(qptr->index + 3 < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		ptr += qptr->index;
-		qptr->index += 3;
-		ptr[0] = cmd1;
-		ptr[1] = cmd2;
-		ptr[2] = cmd3;
+	if (cvmx_unlikely((qptr->index + 3) >= qptr->pool_size_m1)) {
+	/* Most of the time there is lots of free words in current block */
+		uint64_t cmds[3];
+		cmds[0] = cmd1;
+		cmds[1] = cmd2;
+		cmds[2] = cmd3;
+		ret = __cvmx_cmd_queue_write_raw(queue_id, qptr, 3, cmds);
 	} else {
-		uint64_t *ptr;
-		/* Figure out how many command words will fit in this buffer.
-		 * One location will be needed for the next buffer pointer
-		 */
-		int count = qptr->pool_size_m1 - qptr->index;
-		/* We need a new command buffer. Fail if there isn't one available */
-		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
-		if (cvmx_unlikely(new_buffer == NULL)) {
-			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(queue_id);
-			return CVMX_CMD_QUEUE_NO_MEMORY;
-		}
-		count--;
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
-		ptr += qptr->index;
-		*ptr++ = cmd1;
-		if (count) {
-			*ptr++ = cmd2;
-			if (count > 1)
-				*ptr++ = cmd3;
-		}
-		*ptr = cvmx_ptr_to_phys(new_buffer);
-		/* The current buffer is full and has a link to the next buffer.
-		 * Time to write the rest of the commands into the new buffer
-		 */
-		qptr->base_paddr = *ptr;
-		qptr->index = 0;
-		ptr = new_buffer;
-		if (count == 0) {
-			*ptr++ = cmd2;
-			qptr->index++;
-		}
-		if (count < 2) {
-			*ptr++ = cmd3;
-			qptr->index++;
-		}
+		cmd_ptr = cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
+		cmd_ptr += qptr->index;
+		qptr->index += 3;
+		cmd_ptr[0] = cmd1;
+		cmd_ptr[1] = cmd2;
+		cmd_ptr[2] = cmd3;
 	}
 
 	/* All updates are complete. Release the lock and return */
@@ -671,7 +578,8 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		__cvmx_cmd_queue_unlock(queue_id);
 	else
 		CVMX_SYNCWS;
-	return CVMX_CMD_QUEUE_SUCCESS;
+
+	return ret;
 }
 
 #ifdef	__cplusplus
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index f8610db..2055d62 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_DPI_BIST_STATUS CVMX_DPI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000000ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 #define CVMX_DPI_CTL CVMX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000040ull);
 }
@@ -84,6 +84,7 @@ static inline uint64_t CVMX_DPI_DMAX_COUNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_COUNTS(%lu) is invalid on this chip\n", offset);
@@ -102,6 +103,7 @@ static inline uint64_t CVMX_DPI_DMAX_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_DBELL(%lu) is invalid on this chip\n", offset);
@@ -119,6 +121,7 @@ static inline uint64_t CVMX_DPI_DMAX_ERR_RSP_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_ERR_RSP_STATUS(%lu) is invalid on this chip\n", offset);
@@ -137,6 +140,7 @@ static inline uint64_t CVMX_DPI_DMAX_IBUFF_SADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IBUFF_SADDR(%lu) is invalid on this chip\n", offset);
@@ -154,6 +158,7 @@ static inline uint64_t CVMX_DPI_DMAX_IFLIGHT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IFLIGHT(%lu) is invalid on this chip\n", offset);
@@ -172,6 +177,7 @@ static inline uint64_t CVMX_DPI_DMAX_NADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_NADDR(%lu) is invalid on this chip\n", offset);
@@ -190,6 +196,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK0(%lu) is invalid on this chip\n", offset);
@@ -208,6 +215,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK1(%lu) is invalid on this chip\n", offset);
@@ -221,6 +229,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQQ_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000180ull) + ((offset) & 7) * 8;
@@ -232,7 +241,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 #define CVMX_DPI_DMA_CONTROL CVMX_DPI_DMA_CONTROL_FUNC()
 static inline uint64_t CVMX_DPI_DMA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_DMA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000048ull);
 }
@@ -249,6 +258,7 @@ static inline uint64_t CVMX_DPI_DMA_ENGX_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_DMA_ENGX_EN(%lu) is invalid on this chip\n", offset);
@@ -276,6 +286,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 15))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 15) * 8;
 			break;
@@ -296,6 +307,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + (offset) * 8;
@@ -305,7 +317,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 #define CVMX_DPI_DMA_PP_INT CVMX_DPI_DMA_PP_INT_FUNC()
 static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_DMA_PP_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000038ull);
 }
@@ -316,7 +328,7 @@ static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 #define CVMX_DPI_ECC_CTL CVMX_DPI_ECC_CTL_FUNC()
 static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000018ull);
 }
@@ -327,7 +339,7 @@ static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 #define CVMX_DPI_ECC_INT CVMX_DPI_ECC_INT_FUNC()
 static inline uint64_t CVMX_DPI_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000020ull);
 }
@@ -344,6 +356,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_ENGX_BUF(%lu) is invalid on this chip\n", offset);
@@ -356,7 +369,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 #define CVMX_DPI_INFO_REG CVMX_DPI_INFO_REG_FUNC()
 static inline uint64_t CVMX_DPI_INFO_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INFO_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000980ull);
 }
@@ -378,7 +391,7 @@ static inline uint64_t CVMX_DPI_INT_EN_FUNC(void)
 #define CVMX_DPI_INT_REG CVMX_DPI_INT_REG_FUNC()
 static inline uint64_t CVMX_DPI_INT_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INT_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000008ull);
 }
@@ -394,6 +407,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DPI_NCBX_CFG(%lu) is invalid on this chip\n", offset);
@@ -406,7 +420,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long offset)
 #define CVMX_DPI_NCB_CTL CVMX_DPI_NCB_CTL_FUNC()
 static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_NCB_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000028ull);
 }
@@ -417,7 +431,7 @@ static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 #define CVMX_DPI_PINT_INFO CVMX_DPI_PINT_INFO_FUNC()
 static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PINT_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000830ull);
 }
@@ -428,7 +442,7 @@ static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 #define CVMX_DPI_PKT_ERR_RSP CVMX_DPI_PKT_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PKT_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000078ull);
 }
@@ -439,7 +453,7 @@ static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP CVMX_DPI_REQ_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000058ull);
 }
@@ -450,7 +464,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP_EN CVMX_DPI_REQ_ERR_RSP_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000068ull);
 }
@@ -461,7 +475,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST CVMX_DPI_REQ_ERR_RST_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000060ull);
 }
@@ -472,7 +486,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST_EN CVMX_DPI_REQ_ERR_RST_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000070ull);
 }
@@ -483,7 +497,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_SKIP_COMP CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_SKIP_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000838ull);
 }
@@ -494,7 +508,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 #define CVMX_DPI_REQ_GBL_EN CVMX_DPI_REQ_GBL_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_GBL_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_GBL_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000050ull);
 }
@@ -511,6 +525,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_CFG(%lu) is invalid on this chip\n", offset);
@@ -540,6 +555,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
 			break;
@@ -572,6 +588,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
@@ -591,6 +608,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_ERR_INFO(%lu) is invalid on this chip\n", offset);
@@ -603,7 +621,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 #define CVMX_DPI_SWA_Q_VMID CVMX_DPI_SWA_Q_VMID_FUNC()
 static inline uint64_t CVMX_DPI_SWA_Q_VMID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_SWA_Q_VMID not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000030ull);
 }
@@ -669,7 +687,9 @@ union cvmx_dpi_bist_status {
 	struct cvmx_dpi_bist_status_cn61xx    cn70xx;
 	struct cvmx_dpi_bist_status_cn61xx    cn70xxp1;
 	struct cvmx_dpi_bist_status_s         cn73xx;
+	struct cvmx_dpi_bist_status_s         cn75xx;
 	struct cvmx_dpi_bist_status_s         cn78xx;
+	struct cvmx_dpi_bist_status_s         cn78xxp2;
 	struct cvmx_dpi_bist_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_bist_status cvmx_dpi_bist_status_t;
@@ -710,7 +730,9 @@ union cvmx_dpi_ctl {
 	struct cvmx_dpi_ctl_cn61xx            cn70xx;
 	struct cvmx_dpi_ctl_cn61xx            cn70xxp1;
 	struct cvmx_dpi_ctl_cn61xx            cn73xx;
+	struct cvmx_dpi_ctl_cn61xx            cn75xx;
 	struct cvmx_dpi_ctl_cn61xx            cn78xx;
+	struct cvmx_dpi_ctl_cn61xx            cn78xxp2;
 	struct cvmx_dpi_ctl_cn61xx            cnf71xx;
 };
 typedef union cvmx_dpi_ctl cvmx_dpi_ctl_t;
@@ -744,7 +766,9 @@ union cvmx_dpi_dmax_counts {
 	struct cvmx_dpi_dmax_counts_s         cn70xx;
 	struct cvmx_dpi_dmax_counts_s         cn70xxp1;
 	struct cvmx_dpi_dmax_counts_s         cn73xx;
+	struct cvmx_dpi_dmax_counts_s         cn75xx;
 	struct cvmx_dpi_dmax_counts_s         cn78xx;
+	struct cvmx_dpi_dmax_counts_s         cn78xxp2;
 	struct cvmx_dpi_dmax_counts_s         cnf71xx;
 };
 typedef union cvmx_dpi_dmax_counts cvmx_dpi_dmax_counts_t;
@@ -777,7 +801,9 @@ union cvmx_dpi_dmax_dbell {
 	struct cvmx_dpi_dmax_dbell_s          cn70xx;
 	struct cvmx_dpi_dmax_dbell_s          cn70xxp1;
 	struct cvmx_dpi_dmax_dbell_s          cn73xx;
+	struct cvmx_dpi_dmax_dbell_s          cn75xx;
 	struct cvmx_dpi_dmax_dbell_s          cn78xx;
+	struct cvmx_dpi_dmax_dbell_s          cn78xxp2;
 	struct cvmx_dpi_dmax_dbell_s          cnf71xx;
 };
 typedef union cvmx_dpi_dmax_dbell cvmx_dpi_dmax_dbell_t;
@@ -810,7 +836,9 @@ union cvmx_dpi_dmax_err_rsp_status {
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xxp1;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn73xx;
+	struct cvmx_dpi_dmax_err_rsp_status_s cn75xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn78xx;
+	struct cvmx_dpi_dmax_err_rsp_status_s cn78xxp2;
 	struct cvmx_dpi_dmax_err_rsp_status_s cnf71xx;
 };
 typedef union cvmx_dpi_dmax_err_rsp_status cvmx_dpi_dmax_err_rsp_status_t;
@@ -922,7 +950,9 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	uint64_t idle                         : 1;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx cn75xx;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx cn78xx;
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx cn78xxp2;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cnf71xx;
 };
 typedef union cvmx_dpi_dmax_ibuff_saddr cvmx_dpi_dmax_ibuff_saddr_t;
@@ -950,7 +980,9 @@ union cvmx_dpi_dmax_iflight {
 	struct cvmx_dpi_dmax_iflight_s        cn70xx;
 	struct cvmx_dpi_dmax_iflight_s        cn70xxp1;
 	struct cvmx_dpi_dmax_iflight_s        cn73xx;
+	struct cvmx_dpi_dmax_iflight_s        cn75xx;
 	struct cvmx_dpi_dmax_iflight_s        cn78xx;
+	struct cvmx_dpi_dmax_iflight_s        cn78xxp2;
 	struct cvmx_dpi_dmax_iflight_s        cnf71xx;
 };
 typedef union cvmx_dpi_dmax_iflight cvmx_dpi_dmax_iflight_t;
@@ -1000,7 +1032,9 @@ union cvmx_dpi_dmax_naddr {
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xx;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xxp1;
 	struct cvmx_dpi_dmax_naddr_s          cn73xx;
+	struct cvmx_dpi_dmax_naddr_s          cn75xx;
 	struct cvmx_dpi_dmax_naddr_s          cn78xx;
+	struct cvmx_dpi_dmax_naddr_s          cn78xxp2;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cnf71xx;
 };
 typedef union cvmx_dpi_dmax_naddr cvmx_dpi_dmax_naddr_t;
@@ -1029,7 +1063,9 @@ union cvmx_dpi_dmax_reqbnk0 {
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xxp1;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn73xx;
+	struct cvmx_dpi_dmax_reqbnk0_s        cn75xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn78xx;
+	struct cvmx_dpi_dmax_reqbnk0_s        cn78xxp2;
 	struct cvmx_dpi_dmax_reqbnk0_s        cnf71xx;
 };
 typedef union cvmx_dpi_dmax_reqbnk0 cvmx_dpi_dmax_reqbnk0_t;
@@ -1058,7 +1094,9 @@ union cvmx_dpi_dmax_reqbnk1 {
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xxp1;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn73xx;
+	struct cvmx_dpi_dmax_reqbnk1_s        cn75xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn78xx;
+	struct cvmx_dpi_dmax_reqbnk1_s        cn78xxp2;
 	struct cvmx_dpi_dmax_reqbnk1_s        cnf71xx;
 };
 typedef union cvmx_dpi_dmax_reqbnk1 cvmx_dpi_dmax_reqbnk1_t;
@@ -1093,7 +1131,9 @@ union cvmx_dpi_dmax_reqq_ctl {
 #endif
 	} s;
 	struct cvmx_dpi_dmax_reqq_ctl_s       cn73xx;
+	struct cvmx_dpi_dmax_reqq_ctl_s       cn75xx;
 	struct cvmx_dpi_dmax_reqq_ctl_s       cn78xx;
+	struct cvmx_dpi_dmax_reqq_ctl_s       cn78xxp2;
 };
 typedef union cvmx_dpi_dmax_reqq_ctl cvmx_dpi_dmax_reqq_ctl_t;
 
@@ -1155,11 +1195,22 @@ union cvmx_dpi_dma_control {
                                                          not be disabled while processing instructions.
                                                          When PKT_EN=1,  then DMA_ENB<5>=0.
                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
-	uint64_t wqecsdis                     : 1;  /**< Reserved. */
-	uint64_t wqecsoff                     : 7;  /**< Reserved. */
-	uint64_t zbwcsen                      : 1;  /**< Reserved. */
-	uint64_t reserved_35_38               : 4;
-	uint64_t ncb_tag                      : 1;  /**< Reserved. */
+	uint64_t wqecsdis                     : 1;  /**< Work queue completion status disable. */
+	uint64_t wqecsoff                     : 7;  /**< Work queue completion status offset. */
+	uint64_t zbwcsen                      : 1;  /**< Zero-byte-write completion status enable. */
+	uint64_t wqecsmode                    : 2;  /**< WQE completion status mode.
+                                                         0x0 = Default behavior. Only instructions with exceptions will issue completion
+                                                         status write and must wait for commit.
+                                                         0x1 = All DPI_DMA_INSTR_HDR_S[PT]=0x2 instructions will have a completion status
+                                                         write.
+                                                         0x2 = DPI will not wait for the completion status write commit before issuing
+                                                         SSO work queue add.
+                                                         0x3 = Both debug modes specified above (under 0x1 and 0x2) are enabled. */
+	uint64_t reserved_35_36               : 2;
+	uint64_t ncb_tag                      : 1;  /**< NCB tag enable. It allows DMA Read/Write transactions over NCB to be mapped to
+                                                         individual request queues by using tags. This enables more parallelism, giving a
+                                                         performance boost.
+                                                         Added in pass 2. */
 	uint64_t b0_lend                      : 1;  /**< When set '1' and the DPI is in the mode to write
                                                          0 to L2C memory when a DMA is done, the address
                                                          to be written to will be treated as a Little
@@ -1190,7 +1241,8 @@ union cvmx_dpi_dma_control {
 	uint64_t reserved_20_32               : 13;
 	uint64_t b0_lend                      : 1;
 	uint64_t ncb_tag                      : 1;
-	uint64_t reserved_35_38               : 4;
+	uint64_t reserved_35_36               : 2;
+	uint64_t wqecsmode                    : 2;
 	uint64_t zbwcsen                      : 1;
 	uint64_t wqecsoff                     : 7;
 	uint64_t wqecsdis                     : 1;
@@ -1515,7 +1567,15 @@ union cvmx_dpi_dma_control {
 	uint64_t wqecsdis                     : 1;  /**< Work queue completion status disable. */
 	uint64_t wqecsoff                     : 7;  /**< Work queue completion status offset. */
 	uint64_t zbwcsen                      : 1;  /**< Zero-byte-write completion status enable. */
-	uint64_t reserved_35_38               : 4;
+	uint64_t wqecsmode                    : 2;  /**< WQE completion status mode.
+                                                         0x0 = Default behavior. Only instructions with exceptions will issue completion
+                                                         status write and must wait for commit.
+                                                         0x1 = All DPI_DMA_INSTR_HDR_S[PT]=0x2 instructions will have a completion status
+                                                         write.
+                                                         0x2 = DPI will not wait for the completion status write commit before issuing
+                                                         SSO work queue add.
+                                                         0x3 = Both debug modes specified above (under 0x1 and 0x2) are enabled. */
+	uint64_t reserved_35_36               : 2;
 	uint64_t ncb_tag                      : 1;  /**< NCB tag enable. It allows DMA Read/Write transactions over NCB to be mapped to
                                                          individual request queues by using tags. This enables more parallelism, giving a
                                                          performance boost. */
@@ -1554,7 +1614,8 @@ union cvmx_dpi_dma_control {
 	uint64_t ldwb                         : 1;
 	uint64_t b0_lend                      : 1;
 	uint64_t ncb_tag                      : 1;
-	uint64_t reserved_35_38               : 4;
+	uint64_t reserved_35_36               : 2;
+	uint64_t wqecsmode                    : 2;
 	uint64_t zbwcsen                      : 1;
 	uint64_t wqecsoff                     : 7;
 	uint64_t wqecsdis                     : 1;
@@ -1567,7 +1628,9 @@ union cvmx_dpi_dma_control {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_dma_control_cn73xx    cn75xx;
 	struct cvmx_dpi_dma_control_cn73xx    cn78xx;
+	struct cvmx_dpi_dma_control_cn73xx    cn78xxp2;
 	struct cvmx_dpi_dma_control_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_dma_control cvmx_dpi_dma_control_t;
@@ -1582,6 +1645,26 @@ union cvmx_dpi_dma_engx_en {
 	uint64_t u64;
 	struct cvmx_dpi_dma_engx_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_39_63               : 25;
+	uint64_t eng_molr                     : 7;  /**< Per-engine maximum outstanding read request. 0x0 means no maximum per engine
+                                                         (although it will be still limited by the per port MOLR value.) */
+	uint64_t reserved_8_31                : 24;
+	uint64_t qen                          : 8;  /**< Controls which logical instruction queues can be
+                                                         serviced by the DMA engine. Setting QEN==0
+                                                         effectively disables the engine.
+                                                         When DPI_DMA_CONTROL[PKT_EN] = 1, then
+                                                         DPI_DMA_ENG5_EN[QEN] must be zero.
+                                                         When DPI_DMA_CONTROL[PKT_EN1] = 1, then
+                                                         DPI_DMA_ENG4_EN[QEN] must be zero. */
+#else
+	uint64_t qen                          : 8;
+	uint64_t reserved_8_31                : 24;
+	uint64_t eng_molr                     : 7;
+	uint64_t reserved_39_63               : 25;
+#endif
+	} s;
+	struct cvmx_dpi_dma_engx_en_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t qen                          : 8;  /**< Controls which logical instruction queues can be
                                                          serviced by the DMA engine. Setting QEN==0
@@ -1594,18 +1677,19 @@ union cvmx_dpi_dma_engx_en {
 	uint64_t qen                          : 8;
 	uint64_t reserved_8_63                : 56;
 #endif
-	} s;
-	struct cvmx_dpi_dma_engx_en_s         cn61xx;
-	struct cvmx_dpi_dma_engx_en_s         cn63xx;
-	struct cvmx_dpi_dma_engx_en_s         cn63xxp1;
-	struct cvmx_dpi_dma_engx_en_s         cn66xx;
-	struct cvmx_dpi_dma_engx_en_s         cn68xx;
-	struct cvmx_dpi_dma_engx_en_s         cn68xxp1;
-	struct cvmx_dpi_dma_engx_en_s         cn70xx;
-	struct cvmx_dpi_dma_engx_en_s         cn70xxp1;
+	} cn61xx;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn63xx;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn63xxp1;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn66xx;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn68xx;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn68xxp1;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn70xx;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cn70xxp1;
 	struct cvmx_dpi_dma_engx_en_s         cn73xx;
+	struct cvmx_dpi_dma_engx_en_s         cn75xx;
 	struct cvmx_dpi_dma_engx_en_s         cn78xx;
-	struct cvmx_dpi_dma_engx_en_s         cnf71xx;
+	struct cvmx_dpi_dma_engx_en_s         cn78xxp2;
+	struct cvmx_dpi_dma_engx_en_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_dma_engx_en cvmx_dpi_dma_engx_en_t;
 
@@ -1639,7 +1723,9 @@ union cvmx_dpi_dma_ppx_cnt {
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xxp1;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn73xx;
+	struct cvmx_dpi_dma_ppx_cnt_s         cn75xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn78xx;
+	struct cvmx_dpi_dma_ppx_cnt_s         cn78xxp2;
 	struct cvmx_dpi_dma_ppx_cnt_s         cnf71xx;
 };
 typedef union cvmx_dpi_dma_ppx_cnt cvmx_dpi_dma_ppx_cnt_t;
@@ -1667,7 +1753,9 @@ union cvmx_dpi_dma_pp_int {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_dma_pp_int_cn73xx     cn75xx;
 	struct cvmx_dpi_dma_pp_int_s          cn78xx;
+	struct cvmx_dpi_dma_pp_int_s          cn78xxp2;
 };
 typedef union cvmx_dpi_dma_pp_int cvmx_dpi_dma_pp_int_t;
 
@@ -1699,7 +1787,9 @@ union cvmx_dpi_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_dpi_ecc_ctl_s             cn73xx;
+	struct cvmx_dpi_ecc_ctl_s             cn75xx;
 	struct cvmx_dpi_ecc_ctl_s             cn78xx;
+	struct cvmx_dpi_ecc_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
 
@@ -1715,7 +1805,7 @@ typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
  * RAM[10] = dpi.pnl.pkt.sli_pkt_csr.pcsr_pout_size
  * RAM[ 9] = dpi.pnl.pkt.sli_pkt_csr.pcsr_slist
  * RAM[ 8] = dpi.pnl.pkt.sli_pkt_csr.pout_int
- * RAM[ 7] = dpi.pnl.pkt.sli_pkt_csr.pout_signal
+ * RAM[ 7] = dpi.pnl.pkt.sli_pkt_msix.msix_mailbox
  * RAM[ 6] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_poi.poi_fifo
  * RAM[ 5] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_psf.psf_fifo
  * RAM[ 4] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_pdf.pdf_fifo
@@ -1758,7 +1848,9 @@ union cvmx_dpi_ecc_int {
 #endif
 	} s;
 	struct cvmx_dpi_ecc_int_s             cn73xx;
+	struct cvmx_dpi_ecc_int_s             cn75xx;
 	struct cvmx_dpi_ecc_int_s             cn78xx;
+	struct cvmx_dpi_ecc_int_s             cn78xxp2;
 };
 typedef union cvmx_dpi_ecc_int cvmx_dpi_ecc_int_t;
 
@@ -1853,7 +1945,9 @@ union cvmx_dpi_engx_buf {
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xx;
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xxp1;
 	struct cvmx_dpi_engx_buf_s            cn73xx;
+	struct cvmx_dpi_engx_buf_s            cn75xx;
 	struct cvmx_dpi_engx_buf_s            cn78xx;
+	struct cvmx_dpi_engx_buf_s            cn78xxp2;
 	struct cvmx_dpi_engx_buf_cn61xx       cnf71xx;
 };
 typedef union cvmx_dpi_engx_buf cvmx_dpi_engx_buf_t;
@@ -1909,7 +2003,9 @@ union cvmx_dpi_info_reg {
 	struct cvmx_dpi_info_reg_s            cn70xx;
 	struct cvmx_dpi_info_reg_s            cn70xxp1;
 	struct cvmx_dpi_info_reg_s            cn73xx;
+	struct cvmx_dpi_info_reg_s            cn75xx;
 	struct cvmx_dpi_info_reg_s            cn78xx;
+	struct cvmx_dpi_info_reg_s            cn78xxp2;
 	struct cvmx_dpi_info_reg_s            cnf71xx;
 };
 typedef union cvmx_dpi_info_reg cvmx_dpi_info_reg_t;
@@ -2202,7 +2298,9 @@ union cvmx_dpi_int_reg {
 	struct cvmx_dpi_int_reg_s             cn70xx;
 	struct cvmx_dpi_int_reg_s             cn70xxp1;
 	struct cvmx_dpi_int_reg_s             cn73xx;
+	struct cvmx_dpi_int_reg_s             cn75xx;
 	struct cvmx_dpi_int_reg_s             cn78xx;
+	struct cvmx_dpi_int_reg_s             cn78xxp2;
 	struct cvmx_dpi_int_reg_s             cnf71xx;
 };
 typedef union cvmx_dpi_int_reg cvmx_dpi_int_reg_t;
@@ -2232,7 +2330,9 @@ union cvmx_dpi_ncbx_cfg {
 	struct cvmx_dpi_ncbx_cfg_s            cn70xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn70xxp1;
 	struct cvmx_dpi_ncbx_cfg_s            cn73xx;
+	struct cvmx_dpi_ncbx_cfg_s            cn75xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn78xx;
+	struct cvmx_dpi_ncbx_cfg_s            cn78xxp2;
 	struct cvmx_dpi_ncbx_cfg_s            cnf71xx;
 };
 typedef union cvmx_dpi_ncbx_cfg cvmx_dpi_ncbx_cfg_t;
@@ -2248,17 +2348,30 @@ union cvmx_dpi_ncb_ctl {
 	struct cvmx_dpi_ncb_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t ncbsel_prt_xor_dis           : 1;  /**< Reserved. */
+	uint64_t ncbsel_prt_xor_dis           : 1;  /**< Disable the inclusion of the instruction header LPORT field when computing the NCB bus.
+                                                         Added in pass 2. */
 	uint64_t reserved_21_23               : 3;
-	uint64_t ncbsel_zbw                   : 1;  /**< Reserved. */
+	uint64_t ncbsel_zbw                   : 1;  /**< ZBW select.
+                                                         0 = Zero-byte-write transaction will make requests and receive responses using NCB2.
+                                                         1 = Zero-byte-write transaction will make requests and receive responses using NCB3.
+                                                         Added in pass 2. */
 	uint64_t reserved_17_19               : 3;
-	uint64_t ncbsel_req                   : 1;  /**< Reserved. */
+	uint64_t ncbsel_req                   : 1;  /**< Request select.
+                                                         0 = Instruction request transaction will make requests and receive responses using NCB2.
+                                                         1 = Instruction request transaction will make requests and receive responses using NCB3.
+                                                         Added in pass 2. */
 	uint64_t reserved_13_15               : 3;
-	uint64_t ncbsel_dst                   : 1;  /**< Reserved. */
+	uint64_t ncbsel_dst                   : 1;  /**< Destination select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3.
+                                                         Added in pass 2. */
 	uint64_t reserved_9_11                : 3;
-	uint64_t ncbsel_src                   : 1;  /**< Reserved. */
+	uint64_t ncbsel_src                   : 1;  /**< Source select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3.
+                                                         Added in pass 2. */
 	uint64_t reserved_1_7                 : 7;
-	uint64_t prt                          : 1;  /**< Directs traffic to the specified NCB unit. (Pass 1 only) */
+	uint64_t prt                          : 1;  /**< Reserved. */
 #else
 	uint64_t prt                          : 1;
 	uint64_t reserved_1_7                 : 7;
@@ -2309,7 +2422,9 @@ union cvmx_dpi_ncb_ctl {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_ncb_ctl_cn73xx        cn75xx;
 	struct cvmx_dpi_ncb_ctl_s             cn78xx;
+	struct cvmx_dpi_ncb_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dpi_ncb_ctl cvmx_dpi_ncb_ctl_t;
 
@@ -2343,7 +2458,9 @@ union cvmx_dpi_pint_info {
 	struct cvmx_dpi_pint_info_s           cn70xx;
 	struct cvmx_dpi_pint_info_s           cn70xxp1;
 	struct cvmx_dpi_pint_info_s           cn73xx;
+	struct cvmx_dpi_pint_info_s           cn75xx;
 	struct cvmx_dpi_pint_info_s           cn78xx;
+	struct cvmx_dpi_pint_info_s           cn78xxp2;
 	struct cvmx_dpi_pint_info_s           cnf71xx;
 };
 typedef union cvmx_dpi_pint_info cvmx_dpi_pint_info_t;
@@ -2372,7 +2489,9 @@ union cvmx_dpi_pkt_err_rsp {
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xxp1;
 	struct cvmx_dpi_pkt_err_rsp_s         cn73xx;
+	struct cvmx_dpi_pkt_err_rsp_s         cn75xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn78xx;
+	struct cvmx_dpi_pkt_err_rsp_s         cn78xxp2;
 	struct cvmx_dpi_pkt_err_rsp_s         cnf71xx;
 };
 typedef union cvmx_dpi_pkt_err_rsp cvmx_dpi_pkt_err_rsp_t;
@@ -2404,7 +2523,9 @@ union cvmx_dpi_req_err_rsp {
 	struct cvmx_dpi_req_err_rsp_s         cn70xx;
 	struct cvmx_dpi_req_err_rsp_s         cn70xxp1;
 	struct cvmx_dpi_req_err_rsp_s         cn73xx;
+	struct cvmx_dpi_req_err_rsp_s         cn75xx;
 	struct cvmx_dpi_req_err_rsp_s         cn78xx;
+	struct cvmx_dpi_req_err_rsp_s         cn78xxp2;
 	struct cvmx_dpi_req_err_rsp_s         cnf71xx;
 };
 typedef union cvmx_dpi_req_err_rsp cvmx_dpi_req_err_rsp_t;
@@ -2434,7 +2555,9 @@ union cvmx_dpi_req_err_rsp_en {
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xxp1;
 	struct cvmx_dpi_req_err_rsp_en_s      cn73xx;
+	struct cvmx_dpi_req_err_rsp_en_s      cn75xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn78xx;
+	struct cvmx_dpi_req_err_rsp_en_s      cn78xxp2;
 	struct cvmx_dpi_req_err_rsp_en_s      cnf71xx;
 };
 typedef union cvmx_dpi_req_err_rsp_en cvmx_dpi_req_err_rsp_en_t;
@@ -2467,7 +2590,9 @@ union cvmx_dpi_req_err_rst {
 	struct cvmx_dpi_req_err_rst_s         cn70xx;
 	struct cvmx_dpi_req_err_rst_s         cn70xxp1;
 	struct cvmx_dpi_req_err_rst_s         cn73xx;
+	struct cvmx_dpi_req_err_rst_s         cn75xx;
 	struct cvmx_dpi_req_err_rst_s         cn78xx;
+	struct cvmx_dpi_req_err_rst_s         cn78xxp2;
 	struct cvmx_dpi_req_err_rst_s         cnf71xx;
 };
 typedef union cvmx_dpi_req_err_rst cvmx_dpi_req_err_rst_t;
@@ -2498,7 +2623,9 @@ union cvmx_dpi_req_err_rst_en {
 	struct cvmx_dpi_req_err_rst_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn70xxp1;
 	struct cvmx_dpi_req_err_rst_en_s      cn73xx;
+	struct cvmx_dpi_req_err_rst_en_s      cn75xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn78xx;
+	struct cvmx_dpi_req_err_rst_en_s      cn78xxp2;
 	struct cvmx_dpi_req_err_rst_en_s      cnf71xx;
 };
 typedef union cvmx_dpi_req_err_rst_en cvmx_dpi_req_err_rst_en_t;
@@ -2542,7 +2669,9 @@ union cvmx_dpi_req_err_skip_comp {
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xxp1;
 	struct cvmx_dpi_req_err_skip_comp_s   cn73xx;
+	struct cvmx_dpi_req_err_skip_comp_s   cn75xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn78xx;
+	struct cvmx_dpi_req_err_skip_comp_s   cn78xxp2;
 	struct cvmx_dpi_req_err_skip_comp_s   cnf71xx;
 };
 typedef union cvmx_dpi_req_err_skip_comp cvmx_dpi_req_err_skip_comp_t;
@@ -2571,7 +2700,9 @@ union cvmx_dpi_req_gbl_en {
 	struct cvmx_dpi_req_gbl_en_s          cn70xx;
 	struct cvmx_dpi_req_gbl_en_s          cn70xxp1;
 	struct cvmx_dpi_req_gbl_en_s          cn73xx;
+	struct cvmx_dpi_req_gbl_en_s          cn75xx;
 	struct cvmx_dpi_req_gbl_en_s          cn78xx;
+	struct cvmx_dpi_req_gbl_en_s          cn78xxp2;
 	struct cvmx_dpi_req_gbl_en_s          cnf71xx;
 };
 typedef union cvmx_dpi_req_gbl_en cvmx_dpi_req_gbl_en_t;
@@ -2587,7 +2718,10 @@ union cvmx_dpi_sli_prtx_cfg {
 	struct cvmx_dpi_sli_prtx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t ncbsel                       : 1;  /**< Reserved. */
+	uint64_t ncbsel                       : 1;  /**< NCB select.
+                                                         0 = Inbound/outbound transaction will make requests and receive responses using NCB2.
+                                                         1 = Inbound/outbound transaction will make requests and receive responses using NCB3.
+                                                         Added in pass 2. */
 	uint64_t reserved_25_27               : 3;
 	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected
                                                          a reset condition. No further instructions that
@@ -3053,7 +3187,9 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx   cn75xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn73xx   cn78xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx   cn78xxp2;
 	struct cvmx_dpi_sli_prtx_cfg_cn61xx   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_cfg cvmx_dpi_sli_prtx_cfg_t;
@@ -3088,7 +3224,9 @@ union cvmx_dpi_sli_prtx_err {
 	struct cvmx_dpi_sli_prtx_err_s        cn70xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn70xxp1;
 	struct cvmx_dpi_sli_prtx_err_s        cn73xx;
+	struct cvmx_dpi_sli_prtx_err_s        cn75xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn78xx;
+	struct cvmx_dpi_sli_prtx_err_s        cn78xxp2;
 	struct cvmx_dpi_sli_prtx_err_s        cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_err cvmx_dpi_sli_prtx_err_t;
@@ -3176,6 +3314,7 @@ union cvmx_dpi_sli_prtx_err_info {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} cn73xx;
+	struct cvmx_dpi_sli_prtx_err_info_cn73xx cn75xx;
 	struct cvmx_dpi_sli_prtx_err_info_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_23_63               : 41;
@@ -3208,6 +3347,7 @@ union cvmx_dpi_sli_prtx_err_info {
 	uint64_t reserved_23_63               : 41;
 #endif
 	} cn78xx;
+	struct cvmx_dpi_sli_prtx_err_info_cn73xx cn78xxp2;
 	struct cvmx_dpi_sli_prtx_err_info_s   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_err_info cvmx_dpi_sli_prtx_err_info_t;
@@ -3242,7 +3382,9 @@ union cvmx_dpi_swa_q_vmid {
 #endif
 	} s;
 	struct cvmx_dpi_swa_q_vmid_s          cn73xx;
+	struct cvmx_dpi_swa_q_vmid_s          cn75xx;
 	struct cvmx_dpi_swa_q_vmid_s          cn78xx;
+	struct cvmx_dpi_swa_q_vmid_s          cn78xxp2;
 };
 typedef union cvmx_dpi_swa_q_vmid cvmx_dpi_swa_q_vmid_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 9c2ae8d..f70a2fa 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -166,7 +166,7 @@ static inline uint64_t CVMX_DTX_ASE_SELX(unsigned long offset)
 #define CVMX_DTX_BCH_BCST_RSP CVMX_DTX_BCH_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_BCH_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_BCH_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE388080ull);
 }
@@ -177,7 +177,7 @@ static inline uint64_t CVMX_DTX_BCH_BCST_RSP_FUNC(void)
 #define CVMX_DTX_BCH_CTL CVMX_DTX_BCH_CTL_FUNC()
 static inline uint64_t CVMX_DTX_BCH_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_BCH_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE388060ull);
 }
@@ -188,7 +188,8 @@ static inline uint64_t CVMX_DTX_BCH_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_BCH_DATX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BCH_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE388040ull) + ((offset) & 1) * 8;
 }
@@ -199,7 +200,8 @@ static inline uint64_t CVMX_DTX_BCH_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_BCH_ENAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BCH_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE388020ull) + ((offset) & 1) * 8;
 }
@@ -210,7 +212,8 @@ static inline uint64_t CVMX_DTX_BCH_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_BCH_SELX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BCH_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE388000ull) + ((offset) & 1) * 8;
 }
@@ -222,6 +225,7 @@ static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768;
@@ -234,6 +238,7 @@ static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768;
@@ -246,6 +251,7 @@ static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -258,6 +264,7 @@ static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -270,6 +277,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -281,7 +289,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_BROADCAST_CTL CVMX_DTX_BROADCAST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_BROADCAST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_BROADCAST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0060ull);
 }
@@ -294,6 +302,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0020ull) + ((offset) & 1) * 8;
@@ -307,6 +316,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0000ull) + ((offset) & 1) * 8;
@@ -318,7 +328,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 #define CVMX_DTX_CIU_BCST_RSP CVMX_DTX_CIU_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808080ull);
 }
@@ -329,7 +339,7 @@ static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 #define CVMX_DTX_CIU_CTL CVMX_DTX_CIU_CTL_FUNC()
 static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808060ull);
 }
@@ -341,6 +351,7 @@ static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808040ull) + ((offset) & 1) * 8;
@@ -353,6 +364,7 @@ static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808020ull) + ((offset) & 1) * 8;
@@ -365,6 +377,7 @@ static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808000ull) + ((offset) & 1) * 8;
@@ -376,7 +389,7 @@ static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 #define CVMX_DTX_DFA_BCST_RSP CVMX_DTX_DFA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8080ull);
 }
@@ -387,7 +400,7 @@ static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DFA_CTL CVMX_DTX_DFA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DFA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8060ull);
 }
@@ -400,6 +413,7 @@ static inline uint64_t CVMX_DTX_DFA_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8;
@@ -413,6 +427,7 @@ static inline uint64_t CVMX_DTX_DFA_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8;
@@ -426,6 +441,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8;
@@ -437,7 +453,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 #define CVMX_DTX_DPI_BCST_RSP CVMX_DTX_DPI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8080ull);
 }
@@ -448,7 +464,7 @@ static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DPI_CTL CVMX_DTX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8060ull);
 }
@@ -461,6 +477,7 @@ static inline uint64_t CVMX_DTX_DPI_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8040ull) + ((offset) & 1) * 8;
@@ -474,6 +491,7 @@ static inline uint64_t CVMX_DTX_DPI_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8020ull) + ((offset) & 1) * 8;
@@ -487,6 +505,7 @@ static inline uint64_t CVMX_DTX_DPI_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8000ull) + ((offset) & 1) * 8;
@@ -504,6 +523,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			break;
 	}
@@ -519,6 +539,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
@@ -534,6 +555,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			break;
 	}
@@ -549,6 +571,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
@@ -564,6 +587,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
 			break;
@@ -579,6 +603,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
@@ -594,6 +619,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
 			break;
@@ -609,6 +635,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
@@ -624,6 +651,7 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
 			break;
@@ -639,6 +667,7 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
@@ -704,6 +733,7 @@ static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768;
@@ -716,6 +746,7 @@ static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768;
@@ -728,6 +759,7 @@ static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -740,6 +772,7 @@ static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -752,6 +785,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -763,7 +797,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_HNA_BCST_RSP CVMX_DTX_HNA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238080ull);
 }
@@ -774,7 +808,7 @@ static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_HNA_CTL CVMX_DTX_HNA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238060ull);
 }
@@ -786,6 +820,7 @@ static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8;
@@ -798,6 +833,7 @@ static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8;
@@ -810,6 +846,7 @@ static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8;
@@ -931,7 +968,7 @@ static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 #define CVMX_DTX_IOBN_BCST_RSP CVMX_DTX_IOBN_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
 }
@@ -942,7 +979,7 @@ static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBN_CTL CVMX_DTX_IOBN_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
 }
@@ -954,6 +991,7 @@ static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8;
@@ -966,6 +1004,7 @@ static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8;
@@ -978,6 +1017,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8;
@@ -989,7 +1029,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 #define CVMX_DTX_IOBP_BCST_RSP CVMX_DTX_IOBP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0080ull);
 }
@@ -1000,7 +1040,7 @@ static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBP_CTL CVMX_DTX_IOBP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0060ull);
 }
@@ -1012,6 +1052,7 @@ static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0040ull) + ((offset) & 1) * 8;
@@ -1024,6 +1065,7 @@ static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0020ull) + ((offset) & 1) * 8;
@@ -1036,6 +1078,7 @@ static inline uint64_t CVMX_DTX_IOBP_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0000ull) + ((offset) & 1) * 8;
@@ -1157,7 +1200,7 @@ static inline uint64_t CVMX_DTX_IPD_SELX(unsigned long offset)
 #define CVMX_DTX_KEY_BCST_RSP CVMX_DTX_KEY_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_KEY_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_KEY_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE100080ull);
 }
@@ -1168,7 +1211,7 @@ static inline uint64_t CVMX_DTX_KEY_BCST_RSP_FUNC(void)
 #define CVMX_DTX_KEY_CTL CVMX_DTX_KEY_CTL_FUNC()
 static inline uint64_t CVMX_DTX_KEY_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_KEY_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE100060ull);
 }
@@ -1179,7 +1222,9 @@ static inline uint64_t CVMX_DTX_KEY_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_KEY_DATX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE100040ull) + ((offset) & 1) * 8;
 }
@@ -1190,7 +1235,9 @@ static inline uint64_t CVMX_DTX_KEY_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_KEY_ENAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE100020ull) + ((offset) & 1) * 8;
 }
@@ -1201,7 +1248,9 @@ static inline uint64_t CVMX_DTX_KEY_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_KEY_SELX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE100000ull) + ((offset) & 1) * 8;
 }
@@ -1214,6 +1263,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420080ull) + ((offset) & 3) * 32768;
@@ -1227,6 +1277,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420060ull) + ((offset) & 3) * 32768;
@@ -1240,6 +1291,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1253,6 +1305,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1266,6 +1319,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1279,6 +1333,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0080ull) + ((offset) & 3) * 32768;
@@ -1292,6 +1347,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0060ull) + ((offset) & 3) * 32768;
@@ -1305,6 +1361,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1318,6 +1375,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1331,6 +1389,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1344,6 +1403,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240080ull) + ((offset) & 7) * 32768;
@@ -1357,6 +1417,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240060ull) + ((offset) & 7) * 32768;
@@ -1370,6 +1431,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1383,6 +1445,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1396,6 +1459,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1462,7 +1526,7 @@ static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_LBK_BCST_RSP CVMX_DTX_LBK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090080ull);
 }
@@ -1473,7 +1537,7 @@ static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_LBK_CTL CVMX_DTX_LBK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090060ull);
 }
@@ -1485,6 +1549,7 @@ static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090040ull) + ((offset) & 1) * 8;
@@ -1497,6 +1562,7 @@ static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090020ull) + ((offset) & 1) * 8;
@@ -1509,6 +1575,7 @@ static inline uint64_t CVMX_DTX_LBK_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090000ull) + ((offset) & 1) * 8;
@@ -1522,6 +1589,7 @@ static inline uint64_t CVMX_DTX_LMCX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440080ull) + ((offset) & 3) * 32768;
@@ -1535,6 +1603,7 @@ static inline uint64_t CVMX_DTX_LMCX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440060ull) + ((offset) & 3) * 32768;
@@ -1548,6 +1617,7 @@ static inline uint64_t CVMX_DTX_LMCX_DATX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1561,6 +1631,7 @@ static inline uint64_t CVMX_DTX_LMCX_ENAX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1574,6 +1645,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1582,10 +1654,65 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_LMCX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_MHBW_BCST_RSP CVMX_DTX_MHBW_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_MHBW_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_MHBW_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE598080ull);
+}
+#else
+#define CVMX_DTX_MHBW_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE598080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_MHBW_CTL CVMX_DTX_MHBW_CTL_FUNC()
+static inline uint64_t CVMX_DTX_MHBW_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_MHBW_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE598060ull);
+}
+#else
+#define CVMX_DTX_MHBW_CTL (CVMX_ADD_IO_SEG(0x00011800FE598060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MHBW_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MHBW_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE598040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MHBW_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE598040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MHBW_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MHBW_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE598020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MHBW_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE598020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MHBW_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MHBW_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE598000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MHBW_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE598000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DTX_MIO_BCST_RSP CVMX_DTX_MIO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000080ull);
 }
@@ -1596,7 +1723,7 @@ static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_MIO_CTL CVMX_DTX_MIO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_MIO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000060ull);
 }
@@ -1609,6 +1736,7 @@ static inline uint64_t CVMX_DTX_MIO_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000040ull) + ((offset) & 1) * 8;
@@ -1622,6 +1750,7 @@ static inline uint64_t CVMX_DTX_MIO_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000020ull) + ((offset) & 1) * 8;
@@ -1635,6 +1764,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8;
@@ -1816,6 +1946,7 @@ static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
 			break;
 	}
@@ -1830,6 +1961,7 @@ static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
@@ -1844,6 +1976,7 @@ static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
 			break;
 	}
@@ -1858,6 +1991,7 @@ static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
@@ -1872,6 +2006,7 @@ static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + ((offset) & 1) * 8;
 			break;
@@ -1886,6 +2021,7 @@ static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
@@ -1900,6 +2036,7 @@ static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + ((offset) & 1) * 8;
 			break;
@@ -1914,6 +2051,7 @@ static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
@@ -1928,6 +2066,7 @@ static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + ((offset) & 1) * 8;
 			break;
@@ -1942,6 +2081,7 @@ static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
@@ -2008,6 +2148,7 @@ static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768;
@@ -2021,6 +2162,7 @@ static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768;
@@ -2034,6 +2176,7 @@ static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2047,6 +2190,7 @@ static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2060,6 +2204,7 @@ static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2126,7 +2271,7 @@ static inline uint64_t CVMX_DTX_PIP_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PBE_BCST_RSP CVMX_DTX_PKI_PBE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228080ull);
 }
@@ -2137,7 +2282,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PBE_CTL CVMX_DTX_PKI_PBE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228060ull);
 }
@@ -2149,6 +2294,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228040ull) + ((offset) & 1) * 8;
@@ -2161,6 +2307,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228020ull) + ((offset) & 1) * 8;
@@ -2173,6 +2320,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228000ull) + ((offset) & 1) * 8;
@@ -2184,7 +2332,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PFE_BCST_RSP CVMX_DTX_PKI_PFE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220080ull);
 }
@@ -2195,7 +2343,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PFE_CTL CVMX_DTX_PKI_PFE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220060ull);
 }
@@ -2207,6 +2355,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220040ull) + ((offset) & 1) * 8;
@@ -2219,6 +2368,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220020ull) + ((offset) & 1) * 8;
@@ -2231,6 +2381,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220000ull) + ((offset) & 1) * 8;
@@ -2242,7 +2393,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PIX_BCST_RSP CVMX_DTX_PKI_PIX_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230080ull);
 }
@@ -2253,7 +2404,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PIX_CTL CVMX_DTX_PKI_PIX_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230060ull);
 }
@@ -2265,6 +2416,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230040ull) + ((offset) & 1) * 8;
@@ -2277,6 +2429,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230020ull) + ((offset) & 1) * 8;
@@ -2289,6 +2442,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230000ull) + ((offset) & 1) * 8;
@@ -2306,6 +2460,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			break;
 	}
@@ -2321,6 +2476,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
@@ -2336,6 +2492,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			break;
 	}
@@ -2351,6 +2508,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
@@ -2366,6 +2524,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
 			break;
@@ -2381,6 +2540,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
@@ -2396,6 +2556,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
 			break;
@@ -2411,6 +2572,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
@@ -2426,6 +2588,7 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
 			break;
@@ -2441,12 +2604,68 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PNBX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PNBX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_PNBX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PNBX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PNBX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_PNBX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PNBX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PNBX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PNBX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PNBX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PNBX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PNBX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PNBX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PNBX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PNBX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DTX_POW_BCST_RSP CVMX_DTX_POW_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_POW_BCST_RSP_FUNC(void)
 {
@@ -2505,7 +2724,7 @@ static inline uint64_t CVMX_DTX_POW_SELX(unsigned long offset)
 #define CVMX_DTX_RAD_BCST_RSP CVMX_DTX_RAD_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380080ull);
 }
@@ -2516,7 +2735,7 @@ static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RAD_CTL CVMX_DTX_RAD_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380060ull);
 }
@@ -2528,6 +2747,7 @@ static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8;
@@ -2540,6 +2760,7 @@ static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8;
@@ -2552,6 +2773,7 @@ static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8;
@@ -2560,10 +2782,120 @@ static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 #define CVMX_DTX_RAD_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RDEC_BCST_RSP CVMX_DTX_RDEC_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_RDEC_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_RDEC_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FED68080ull);
+}
+#else
+#define CVMX_DTX_RDEC_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FED68080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RDEC_CTL CVMX_DTX_RDEC_CTL_FUNC()
+static inline uint64_t CVMX_DTX_RDEC_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_RDEC_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FED68060ull);
+}
+#else
+#define CVMX_DTX_RDEC_CTL (CVMX_ADD_IO_SEG(0x00011800FED68060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RDEC_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RDEC_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FED68040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RDEC_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FED68040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RDEC_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RDEC_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FED68020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RDEC_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FED68020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RDEC_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RDEC_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FED68000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RDEC_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FED68000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RMAP_BCST_RSP CVMX_DTX_RMAP_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_RMAP_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_RMAP_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEC40080ull);
+}
+#else
+#define CVMX_DTX_RMAP_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FEC40080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RMAP_CTL CVMX_DTX_RMAP_CTL_FUNC()
+static inline uint64_t CVMX_DTX_RMAP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_DTX_RMAP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEC40060ull);
+}
+#else
+#define CVMX_DTX_RMAP_CTL (CVMX_ADD_IO_SEG(0x00011800FEC40060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RMAP_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RMAP_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEC40040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RMAP_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FEC40040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RMAP_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RMAP_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEC40020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RMAP_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FEC40020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RMAP_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RMAP_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEC40000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RMAP_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FEC40000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DTX_RNM_BCST_RSP CVMX_DTX_RNM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200080ull);
 }
@@ -2574,7 +2906,7 @@ static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RNM_CTL CVMX_DTX_RNM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200060ull);
 }
@@ -2586,6 +2918,7 @@ static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200040ull) + ((offset) & 1) * 8;
@@ -2598,6 +2931,7 @@ static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200020ull) + ((offset) & 1) * 8;
@@ -2610,6 +2944,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200000ull) + ((offset) & 1) * 8;
@@ -2621,7 +2956,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 #define CVMX_DTX_RST_BCST_RSP CVMX_DTX_RST_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030080ull);
 }
@@ -2632,7 +2967,7 @@ static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RST_CTL CVMX_DTX_RST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030060ull);
 }
@@ -2645,6 +2980,7 @@ static inline uint64_t CVMX_DTX_RST_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030040ull) + ((offset) & 1) * 8;
@@ -2658,6 +2994,7 @@ static inline uint64_t CVMX_DTX_RST_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030020ull) + ((offset) & 1) * 8;
@@ -2671,6 +3008,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030000ull) + ((offset) & 1) * 8;
@@ -2682,7 +3020,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 #define CVMX_DTX_SATA_BCST_RSP CVMX_DTX_SATA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SATA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_SATA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE360080ull);
 }
@@ -2693,7 +3031,7 @@ static inline uint64_t CVMX_DTX_SATA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SATA_CTL CVMX_DTX_SATA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SATA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_DTX_SATA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE360060ull);
 }
@@ -2705,7 +3043,8 @@ static inline uint64_t CVMX_DTX_SATA_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360040ull) + ((offset) & 1) * 8;
 }
@@ -2717,7 +3056,8 @@ static inline uint64_t CVMX_DTX_SATA_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360020ull) + ((offset) & 1) * 8;
 }
@@ -2729,7 +3069,8 @@ static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360000ull) + ((offset) & 1) * 8;
 }
@@ -2740,7 +3081,7 @@ static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 #define CVMX_DTX_SLI_BCST_RSP CVMX_DTX_SLI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8080ull);
 }
@@ -2751,7 +3092,7 @@ static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SLI_CTL CVMX_DTX_SLI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SLI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8060ull);
 }
@@ -2764,6 +3105,7 @@ static inline uint64_t CVMX_DTX_SLI_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8040ull) + ((offset) & 1) * 8;
@@ -2777,6 +3119,7 @@ static inline uint64_t CVMX_DTX_SLI_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8020ull) + ((offset) & 1) * 8;
@@ -2790,6 +3133,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8000ull) + ((offset) & 1) * 8;
@@ -2801,7 +3145,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 #define CVMX_DTX_SSO_BCST_RSP CVMX_DTX_SSO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38080ull);
 }
@@ -2812,7 +3156,7 @@ static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SSO_CTL CVMX_DTX_SSO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38060ull);
 }
@@ -2824,6 +3168,7 @@ static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38040ull) + ((offset) & 1) * 8;
@@ -2836,6 +3181,7 @@ static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38020ull) + ((offset) & 1) * 8;
@@ -2848,6 +3194,7 @@ static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38000ull) + ((offset) & 1) * 8;
@@ -2859,7 +3206,7 @@ static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 #define CVMX_DTX_TIM_BCST_RSP CVMX_DTX_TIM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0080ull);
 }
@@ -2870,7 +3217,7 @@ static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_TIM_CTL CVMX_DTX_TIM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0060ull);
 }
@@ -2883,6 +3230,7 @@ static inline uint64_t CVMX_DTX_TIM_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0040ull) + ((offset) & 1) * 8;
@@ -2896,6 +3244,7 @@ static inline uint64_t CVMX_DTX_TIM_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0020ull) + ((offset) & 1) * 8;
@@ -2909,6 +3258,7 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0000ull) + ((offset) & 1) * 8;
@@ -2919,67 +3269,158 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + ((offset) & 1) * 32768;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + ((offset) & 1) * 32768;
 }
 #else
-#define CVMX_DTX_USBDRDX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768)
+static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + (offset) * 32768;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + (offset) * 32768;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + (offset) * 32768;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_USBDRDX_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + ((offset) & 1) * 32768;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + ((offset) & 1) * 32768;
 }
 #else
-#define CVMX_DTX_USBDRDX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768)
+static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + (offset) * 32768;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + (offset) * 32768;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + (offset) * 32768;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_DATX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_ENAX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_SELX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340080ull);
@@ -2991,6 +3432,7 @@ static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340060ull);
@@ -3002,6 +3444,7 @@ static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -3013,6 +3456,7 @@ static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -3024,6 +3468,7 @@ static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -3035,7 +3480,7 @@ static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_ZIP_BCST_RSP CVMX_DTX_ZIP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0080ull);
 }
@@ -3046,7 +3491,7 @@ static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ZIP_CTL CVMX_DTX_ZIP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0060ull);
 }
@@ -3058,6 +3503,7 @@ static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8;
@@ -3070,6 +3516,7 @@ static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8;
@@ -3082,6 +3529,7 @@ static inline uint64_t CVMX_DTX_ZIP_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8;
@@ -3210,6 +3658,7 @@ union cvmx_dtx_ase_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ase_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_ase_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ase_bcst_rsp cvmx_dtx_ase_bcst_rsp_t;
 
@@ -3236,6 +3685,7 @@ union cvmx_dtx_ase_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ase_ctl_s             cn78xx;
+	struct cvmx_dtx_ase_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_ase_ctl cvmx_dtx_ase_ctl_t;
 
@@ -3255,6 +3705,7 @@ union cvmx_dtx_ase_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ase_datx_s            cn78xx;
+	struct cvmx_dtx_ase_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ase_datx cvmx_dtx_ase_datx_t;
 
@@ -3274,6 +3725,7 @@ union cvmx_dtx_ase_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ase_enax_s            cn78xx;
+	struct cvmx_dtx_ase_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ase_enax cvmx_dtx_ase_enax_t;
 
@@ -3292,6 +3744,7 @@ union cvmx_dtx_ase_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ase_selx_s            cn78xx;
+	struct cvmx_dtx_ase_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ase_selx cvmx_dtx_ase_selx_t;
 
@@ -3310,6 +3763,7 @@ union cvmx_dtx_bch_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_bch_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_bch_bcst_rsp_s        cn75xx;
 };
 typedef union cvmx_dtx_bch_bcst_rsp cvmx_dtx_bch_bcst_rsp_t;
 
@@ -3336,6 +3790,7 @@ union cvmx_dtx_bch_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_bch_ctl_s             cn73xx;
+	struct cvmx_dtx_bch_ctl_s             cn75xx;
 };
 typedef union cvmx_dtx_bch_ctl cvmx_dtx_bch_ctl_t;
 
@@ -3355,6 +3810,7 @@ union cvmx_dtx_bch_datx {
 #endif
 	} s;
 	struct cvmx_dtx_bch_datx_s            cn73xx;
+	struct cvmx_dtx_bch_datx_s            cn75xx;
 };
 typedef union cvmx_dtx_bch_datx cvmx_dtx_bch_datx_t;
 
@@ -3374,6 +3830,7 @@ union cvmx_dtx_bch_enax {
 #endif
 	} s;
 	struct cvmx_dtx_bch_enax_s            cn73xx;
+	struct cvmx_dtx_bch_enax_s            cn75xx;
 };
 typedef union cvmx_dtx_bch_enax cvmx_dtx_bch_enax_t;
 
@@ -3392,6 +3849,7 @@ union cvmx_dtx_bch_selx {
 #endif
 	} s;
 	struct cvmx_dtx_bch_selx_s            cn73xx;
+	struct cvmx_dtx_bch_selx_s            cn75xx;
 };
 typedef union cvmx_dtx_bch_selx cvmx_dtx_bch_selx_t;
 
@@ -3410,7 +3868,9 @@ union cvmx_dtx_bgxx_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_bgxx_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_bgxx_bcst_rsp_s       cn75xx;
 	struct cvmx_dtx_bgxx_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_bgxx_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_bgxx_bcst_rsp cvmx_dtx_bgxx_bcst_rsp_t;
 
@@ -3437,7 +3897,9 @@ union cvmx_dtx_bgxx_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_bgxx_ctl_s            cn73xx;
+	struct cvmx_dtx_bgxx_ctl_s            cn75xx;
 	struct cvmx_dtx_bgxx_ctl_s            cn78xx;
+	struct cvmx_dtx_bgxx_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_bgxx_ctl cvmx_dtx_bgxx_ctl_t;
 
@@ -3457,7 +3919,9 @@ union cvmx_dtx_bgxx_datx {
 #endif
 	} s;
 	struct cvmx_dtx_bgxx_datx_s           cn73xx;
+	struct cvmx_dtx_bgxx_datx_s           cn75xx;
 	struct cvmx_dtx_bgxx_datx_s           cn78xx;
+	struct cvmx_dtx_bgxx_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_bgxx_datx cvmx_dtx_bgxx_datx_t;
 
@@ -3477,7 +3941,9 @@ union cvmx_dtx_bgxx_enax {
 #endif
 	} s;
 	struct cvmx_dtx_bgxx_enax_s           cn73xx;
+	struct cvmx_dtx_bgxx_enax_s           cn75xx;
 	struct cvmx_dtx_bgxx_enax_s           cn78xx;
+	struct cvmx_dtx_bgxx_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_bgxx_enax cvmx_dtx_bgxx_enax_t;
 
@@ -3496,7 +3962,9 @@ union cvmx_dtx_bgxx_selx {
 #endif
 	} s;
 	struct cvmx_dtx_bgxx_selx_s           cn73xx;
+	struct cvmx_dtx_bgxx_selx_s           cn75xx;
 	struct cvmx_dtx_bgxx_selx_s           cn78xx;
+	struct cvmx_dtx_bgxx_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_bgxx_selx cvmx_dtx_bgxx_selx_t;
 
@@ -3525,7 +3993,9 @@ union cvmx_dtx_broadcast_ctl {
 	struct cvmx_dtx_broadcast_ctl_s       cn70xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn70xxp1;
 	struct cvmx_dtx_broadcast_ctl_s       cn73xx;
+	struct cvmx_dtx_broadcast_ctl_s       cn75xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn78xx;
+	struct cvmx_dtx_broadcast_ctl_s       cn78xxp2;
 };
 typedef union cvmx_dtx_broadcast_ctl cvmx_dtx_broadcast_ctl_t;
 
@@ -3547,7 +4017,9 @@ union cvmx_dtx_broadcast_enax {
 	struct cvmx_dtx_broadcast_enax_s      cn70xx;
 	struct cvmx_dtx_broadcast_enax_s      cn70xxp1;
 	struct cvmx_dtx_broadcast_enax_s      cn73xx;
+	struct cvmx_dtx_broadcast_enax_s      cn75xx;
 	struct cvmx_dtx_broadcast_enax_s      cn78xx;
+	struct cvmx_dtx_broadcast_enax_s      cn78xxp2;
 };
 typedef union cvmx_dtx_broadcast_enax cvmx_dtx_broadcast_enax_t;
 
@@ -3568,7 +4040,9 @@ union cvmx_dtx_broadcast_selx {
 	struct cvmx_dtx_broadcast_selx_s      cn70xx;
 	struct cvmx_dtx_broadcast_selx_s      cn70xxp1;
 	struct cvmx_dtx_broadcast_selx_s      cn73xx;
+	struct cvmx_dtx_broadcast_selx_s      cn75xx;
 	struct cvmx_dtx_broadcast_selx_s      cn78xx;
+	struct cvmx_dtx_broadcast_selx_s      cn78xxp2;
 };
 typedef union cvmx_dtx_broadcast_selx cvmx_dtx_broadcast_selx_t;
 
@@ -3587,7 +4061,9 @@ union cvmx_dtx_ciu_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ciu_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_ciu_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_ciu_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_ciu_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ciu_bcst_rsp cvmx_dtx_ciu_bcst_rsp_t;
 
@@ -3614,7 +4090,9 @@ union cvmx_dtx_ciu_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ciu_ctl_s             cn73xx;
+	struct cvmx_dtx_ciu_ctl_s             cn75xx;
 	struct cvmx_dtx_ciu_ctl_s             cn78xx;
+	struct cvmx_dtx_ciu_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_ciu_ctl cvmx_dtx_ciu_ctl_t;
 
@@ -3634,7 +4112,9 @@ union cvmx_dtx_ciu_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ciu_datx_s            cn73xx;
+	struct cvmx_dtx_ciu_datx_s            cn75xx;
 	struct cvmx_dtx_ciu_datx_s            cn78xx;
+	struct cvmx_dtx_ciu_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ciu_datx cvmx_dtx_ciu_datx_t;
 
@@ -3654,7 +4134,9 @@ union cvmx_dtx_ciu_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ciu_enax_s            cn73xx;
+	struct cvmx_dtx_ciu_enax_s            cn75xx;
 	struct cvmx_dtx_ciu_enax_s            cn78xx;
+	struct cvmx_dtx_ciu_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ciu_enax cvmx_dtx_ciu_enax_t;
 
@@ -3673,7 +4155,9 @@ union cvmx_dtx_ciu_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ciu_selx_s            cn73xx;
+	struct cvmx_dtx_ciu_selx_s            cn75xx;
 	struct cvmx_dtx_ciu_selx_s            cn78xx;
+	struct cvmx_dtx_ciu_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ciu_selx cvmx_dtx_ciu_selx_t;
 
@@ -3694,7 +4178,9 @@ union cvmx_dtx_dfa_bcst_rsp {
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_dfa_bcst_rsp cvmx_dtx_dfa_bcst_rsp_t;
 
@@ -3723,7 +4209,9 @@ union cvmx_dtx_dfa_ctl {
 	struct cvmx_dtx_dfa_ctl_s             cn70xx;
 	struct cvmx_dtx_dfa_ctl_s             cn70xxp1;
 	struct cvmx_dtx_dfa_ctl_s             cn73xx;
+	struct cvmx_dtx_dfa_ctl_s             cn75xx;
 	struct cvmx_dtx_dfa_ctl_s             cn78xx;
+	struct cvmx_dtx_dfa_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_dfa_ctl cvmx_dtx_dfa_ctl_t;
 
@@ -3745,7 +4233,9 @@ union cvmx_dtx_dfa_datx {
 	struct cvmx_dtx_dfa_datx_s            cn70xx;
 	struct cvmx_dtx_dfa_datx_s            cn70xxp1;
 	struct cvmx_dtx_dfa_datx_s            cn73xx;
+	struct cvmx_dtx_dfa_datx_s            cn75xx;
 	struct cvmx_dtx_dfa_datx_s            cn78xx;
+	struct cvmx_dtx_dfa_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dfa_datx cvmx_dtx_dfa_datx_t;
 
@@ -3767,7 +4257,9 @@ union cvmx_dtx_dfa_enax {
 	struct cvmx_dtx_dfa_enax_s            cn70xx;
 	struct cvmx_dtx_dfa_enax_s            cn70xxp1;
 	struct cvmx_dtx_dfa_enax_s            cn73xx;
+	struct cvmx_dtx_dfa_enax_s            cn75xx;
 	struct cvmx_dtx_dfa_enax_s            cn78xx;
+	struct cvmx_dtx_dfa_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dfa_enax cvmx_dtx_dfa_enax_t;
 
@@ -3788,7 +4280,9 @@ union cvmx_dtx_dfa_selx {
 	struct cvmx_dtx_dfa_selx_s            cn70xx;
 	struct cvmx_dtx_dfa_selx_s            cn70xxp1;
 	struct cvmx_dtx_dfa_selx_s            cn73xx;
+	struct cvmx_dtx_dfa_selx_s            cn75xx;
 	struct cvmx_dtx_dfa_selx_s            cn78xx;
+	struct cvmx_dtx_dfa_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dfa_selx cvmx_dtx_dfa_selx_t;
 
@@ -3809,7 +4303,9 @@ union cvmx_dtx_dpi_bcst_rsp {
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_dpi_bcst_rsp cvmx_dtx_dpi_bcst_rsp_t;
 
@@ -3838,7 +4334,9 @@ union cvmx_dtx_dpi_ctl {
 	struct cvmx_dtx_dpi_ctl_s             cn70xx;
 	struct cvmx_dtx_dpi_ctl_s             cn70xxp1;
 	struct cvmx_dtx_dpi_ctl_s             cn73xx;
+	struct cvmx_dtx_dpi_ctl_s             cn75xx;
 	struct cvmx_dtx_dpi_ctl_s             cn78xx;
+	struct cvmx_dtx_dpi_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_dpi_ctl cvmx_dtx_dpi_ctl_t;
 
@@ -3860,7 +4358,9 @@ union cvmx_dtx_dpi_datx {
 	struct cvmx_dtx_dpi_datx_s            cn70xx;
 	struct cvmx_dtx_dpi_datx_s            cn70xxp1;
 	struct cvmx_dtx_dpi_datx_s            cn73xx;
+	struct cvmx_dtx_dpi_datx_s            cn75xx;
 	struct cvmx_dtx_dpi_datx_s            cn78xx;
+	struct cvmx_dtx_dpi_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dpi_datx cvmx_dtx_dpi_datx_t;
 
@@ -3882,7 +4382,9 @@ union cvmx_dtx_dpi_enax {
 	struct cvmx_dtx_dpi_enax_s            cn70xx;
 	struct cvmx_dtx_dpi_enax_s            cn70xxp1;
 	struct cvmx_dtx_dpi_enax_s            cn73xx;
+	struct cvmx_dtx_dpi_enax_s            cn75xx;
 	struct cvmx_dtx_dpi_enax_s            cn78xx;
+	struct cvmx_dtx_dpi_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dpi_enax cvmx_dtx_dpi_enax_t;
 
@@ -3903,7 +4405,9 @@ union cvmx_dtx_dpi_selx {
 	struct cvmx_dtx_dpi_selx_s            cn70xx;
 	struct cvmx_dtx_dpi_selx_s            cn70xxp1;
 	struct cvmx_dtx_dpi_selx_s            cn73xx;
+	struct cvmx_dtx_dpi_selx_s            cn75xx;
 	struct cvmx_dtx_dpi_selx_s            cn78xx;
+	struct cvmx_dtx_dpi_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_dpi_selx cvmx_dtx_dpi_selx_t;
 
@@ -3924,7 +4428,9 @@ union cvmx_dtx_fpa_bcst_rsp {
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_fpa_bcst_rsp cvmx_dtx_fpa_bcst_rsp_t;
 
@@ -3953,7 +4459,9 @@ union cvmx_dtx_fpa_ctl {
 	struct cvmx_dtx_fpa_ctl_s             cn70xx;
 	struct cvmx_dtx_fpa_ctl_s             cn70xxp1;
 	struct cvmx_dtx_fpa_ctl_s             cn73xx;
+	struct cvmx_dtx_fpa_ctl_s             cn75xx;
 	struct cvmx_dtx_fpa_ctl_s             cn78xx;
+	struct cvmx_dtx_fpa_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_fpa_ctl cvmx_dtx_fpa_ctl_t;
 
@@ -3975,7 +4483,9 @@ union cvmx_dtx_fpa_datx {
 	struct cvmx_dtx_fpa_datx_s            cn70xx;
 	struct cvmx_dtx_fpa_datx_s            cn70xxp1;
 	struct cvmx_dtx_fpa_datx_s            cn73xx;
+	struct cvmx_dtx_fpa_datx_s            cn75xx;
 	struct cvmx_dtx_fpa_datx_s            cn78xx;
+	struct cvmx_dtx_fpa_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_fpa_datx cvmx_dtx_fpa_datx_t;
 
@@ -3997,7 +4507,9 @@ union cvmx_dtx_fpa_enax {
 	struct cvmx_dtx_fpa_enax_s            cn70xx;
 	struct cvmx_dtx_fpa_enax_s            cn70xxp1;
 	struct cvmx_dtx_fpa_enax_s            cn73xx;
+	struct cvmx_dtx_fpa_enax_s            cn75xx;
 	struct cvmx_dtx_fpa_enax_s            cn78xx;
+	struct cvmx_dtx_fpa_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_fpa_enax cvmx_dtx_fpa_enax_t;
 
@@ -4018,7 +4530,9 @@ union cvmx_dtx_fpa_selx {
 	struct cvmx_dtx_fpa_selx_s            cn70xx;
 	struct cvmx_dtx_fpa_selx_s            cn70xxp1;
 	struct cvmx_dtx_fpa_selx_s            cn73xx;
+	struct cvmx_dtx_fpa_selx_s            cn75xx;
 	struct cvmx_dtx_fpa_selx_s            cn78xx;
+	struct cvmx_dtx_fpa_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_fpa_selx cvmx_dtx_fpa_selx_t;
 
@@ -4142,7 +4656,9 @@ union cvmx_dtx_gserx_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_gserx_bcst_rsp_s      cn73xx;
+	struct cvmx_dtx_gserx_bcst_rsp_s      cn75xx;
 	struct cvmx_dtx_gserx_bcst_rsp_s      cn78xx;
+	struct cvmx_dtx_gserx_bcst_rsp_s      cn78xxp2;
 };
 typedef union cvmx_dtx_gserx_bcst_rsp cvmx_dtx_gserx_bcst_rsp_t;
 
@@ -4169,7 +4685,9 @@ union cvmx_dtx_gserx_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_gserx_ctl_s           cn73xx;
+	struct cvmx_dtx_gserx_ctl_s           cn75xx;
 	struct cvmx_dtx_gserx_ctl_s           cn78xx;
+	struct cvmx_dtx_gserx_ctl_s           cn78xxp2;
 };
 typedef union cvmx_dtx_gserx_ctl cvmx_dtx_gserx_ctl_t;
 
@@ -4189,7 +4707,9 @@ union cvmx_dtx_gserx_datx {
 #endif
 	} s;
 	struct cvmx_dtx_gserx_datx_s          cn73xx;
+	struct cvmx_dtx_gserx_datx_s          cn75xx;
 	struct cvmx_dtx_gserx_datx_s          cn78xx;
+	struct cvmx_dtx_gserx_datx_s          cn78xxp2;
 };
 typedef union cvmx_dtx_gserx_datx cvmx_dtx_gserx_datx_t;
 
@@ -4209,7 +4729,9 @@ union cvmx_dtx_gserx_enax {
 #endif
 	} s;
 	struct cvmx_dtx_gserx_enax_s          cn73xx;
+	struct cvmx_dtx_gserx_enax_s          cn75xx;
 	struct cvmx_dtx_gserx_enax_s          cn78xx;
+	struct cvmx_dtx_gserx_enax_s          cn78xxp2;
 };
 typedef union cvmx_dtx_gserx_enax cvmx_dtx_gserx_enax_t;
 
@@ -4228,7 +4750,9 @@ union cvmx_dtx_gserx_selx {
 #endif
 	} s;
 	struct cvmx_dtx_gserx_selx_s          cn73xx;
+	struct cvmx_dtx_gserx_selx_s          cn75xx;
 	struct cvmx_dtx_gserx_selx_s          cn78xx;
+	struct cvmx_dtx_gserx_selx_s          cn78xxp2;
 };
 typedef union cvmx_dtx_gserx_selx cvmx_dtx_gserx_selx_t;
 
@@ -4247,7 +4771,9 @@ union cvmx_dtx_hna_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_hna_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_hna_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_hna_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_hna_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_hna_bcst_rsp cvmx_dtx_hna_bcst_rsp_t;
 
@@ -4274,7 +4800,9 @@ union cvmx_dtx_hna_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_hna_ctl_s             cn73xx;
+	struct cvmx_dtx_hna_ctl_s             cn75xx;
 	struct cvmx_dtx_hna_ctl_s             cn78xx;
+	struct cvmx_dtx_hna_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_hna_ctl cvmx_dtx_hna_ctl_t;
 
@@ -4294,7 +4822,9 @@ union cvmx_dtx_hna_datx {
 #endif
 	} s;
 	struct cvmx_dtx_hna_datx_s            cn73xx;
+	struct cvmx_dtx_hna_datx_s            cn75xx;
 	struct cvmx_dtx_hna_datx_s            cn78xx;
+	struct cvmx_dtx_hna_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_hna_datx cvmx_dtx_hna_datx_t;
 
@@ -4314,7 +4844,9 @@ union cvmx_dtx_hna_enax {
 #endif
 	} s;
 	struct cvmx_dtx_hna_enax_s            cn73xx;
+	struct cvmx_dtx_hna_enax_s            cn75xx;
 	struct cvmx_dtx_hna_enax_s            cn78xx;
+	struct cvmx_dtx_hna_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_hna_enax cvmx_dtx_hna_enax_t;
 
@@ -4333,7 +4865,9 @@ union cvmx_dtx_hna_selx {
 #endif
 	} s;
 	struct cvmx_dtx_hna_selx_s            cn73xx;
+	struct cvmx_dtx_hna_selx_s            cn75xx;
 	struct cvmx_dtx_hna_selx_s            cn78xx;
+	struct cvmx_dtx_hna_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_hna_selx cvmx_dtx_hna_selx_t;
 
@@ -4352,6 +4886,7 @@ union cvmx_dtx_ila_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ila_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_ila_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ila_bcst_rsp cvmx_dtx_ila_bcst_rsp_t;
 
@@ -4378,6 +4913,7 @@ union cvmx_dtx_ila_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ila_ctl_s             cn78xx;
+	struct cvmx_dtx_ila_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_ila_ctl cvmx_dtx_ila_ctl_t;
 
@@ -4397,6 +4933,7 @@ union cvmx_dtx_ila_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ila_datx_s            cn78xx;
+	struct cvmx_dtx_ila_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ila_datx cvmx_dtx_ila_datx_t;
 
@@ -4416,6 +4953,7 @@ union cvmx_dtx_ila_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ila_enax_s            cn78xx;
+	struct cvmx_dtx_ila_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ila_enax cvmx_dtx_ila_enax_t;
 
@@ -4434,6 +4972,7 @@ union cvmx_dtx_ila_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ila_selx_s            cn78xx;
+	struct cvmx_dtx_ila_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ila_selx cvmx_dtx_ila_selx_t;
 
@@ -4452,6 +4991,7 @@ union cvmx_dtx_ilk_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ilk_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_ilk_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ilk_bcst_rsp cvmx_dtx_ilk_bcst_rsp_t;
 
@@ -4478,6 +5018,7 @@ union cvmx_dtx_ilk_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ilk_ctl_s             cn78xx;
+	struct cvmx_dtx_ilk_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_ilk_ctl cvmx_dtx_ilk_ctl_t;
 
@@ -4497,6 +5038,7 @@ union cvmx_dtx_ilk_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ilk_datx_s            cn78xx;
+	struct cvmx_dtx_ilk_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ilk_datx cvmx_dtx_ilk_datx_t;
 
@@ -4516,6 +5058,7 @@ union cvmx_dtx_ilk_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ilk_enax_s            cn78xx;
+	struct cvmx_dtx_ilk_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ilk_enax cvmx_dtx_ilk_enax_t;
 
@@ -4534,6 +5077,7 @@ union cvmx_dtx_ilk_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ilk_selx_s            cn78xx;
+	struct cvmx_dtx_ilk_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_ilk_selx cvmx_dtx_ilk_selx_t;
 
@@ -4657,7 +5201,9 @@ union cvmx_dtx_iobn_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_iobn_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_iobn_bcst_rsp_s       cn75xx;
 	struct cvmx_dtx_iobn_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_iobn_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_iobn_bcst_rsp cvmx_dtx_iobn_bcst_rsp_t;
 
@@ -4684,7 +5230,9 @@ union cvmx_dtx_iobn_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_iobn_ctl_s            cn73xx;
+	struct cvmx_dtx_iobn_ctl_s            cn75xx;
 	struct cvmx_dtx_iobn_ctl_s            cn78xx;
+	struct cvmx_dtx_iobn_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_iobn_ctl cvmx_dtx_iobn_ctl_t;
 
@@ -4704,7 +5252,9 @@ union cvmx_dtx_iobn_datx {
 #endif
 	} s;
 	struct cvmx_dtx_iobn_datx_s           cn73xx;
+	struct cvmx_dtx_iobn_datx_s           cn75xx;
 	struct cvmx_dtx_iobn_datx_s           cn78xx;
+	struct cvmx_dtx_iobn_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobn_datx cvmx_dtx_iobn_datx_t;
 
@@ -4724,7 +5274,9 @@ union cvmx_dtx_iobn_enax {
 #endif
 	} s;
 	struct cvmx_dtx_iobn_enax_s           cn73xx;
+	struct cvmx_dtx_iobn_enax_s           cn75xx;
 	struct cvmx_dtx_iobn_enax_s           cn78xx;
+	struct cvmx_dtx_iobn_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobn_enax cvmx_dtx_iobn_enax_t;
 
@@ -4743,7 +5295,9 @@ union cvmx_dtx_iobn_selx {
 #endif
 	} s;
 	struct cvmx_dtx_iobn_selx_s           cn73xx;
+	struct cvmx_dtx_iobn_selx_s           cn75xx;
 	struct cvmx_dtx_iobn_selx_s           cn78xx;
+	struct cvmx_dtx_iobn_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobn_selx cvmx_dtx_iobn_selx_t;
 
@@ -4762,7 +5316,9 @@ union cvmx_dtx_iobp_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_iobp_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_iobp_bcst_rsp_s       cn75xx;
 	struct cvmx_dtx_iobp_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_iobp_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_iobp_bcst_rsp cvmx_dtx_iobp_bcst_rsp_t;
 
@@ -4789,7 +5345,9 @@ union cvmx_dtx_iobp_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_iobp_ctl_s            cn73xx;
+	struct cvmx_dtx_iobp_ctl_s            cn75xx;
 	struct cvmx_dtx_iobp_ctl_s            cn78xx;
+	struct cvmx_dtx_iobp_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_iobp_ctl cvmx_dtx_iobp_ctl_t;
 
@@ -4809,7 +5367,9 @@ union cvmx_dtx_iobp_datx {
 #endif
 	} s;
 	struct cvmx_dtx_iobp_datx_s           cn73xx;
+	struct cvmx_dtx_iobp_datx_s           cn75xx;
 	struct cvmx_dtx_iobp_datx_s           cn78xx;
+	struct cvmx_dtx_iobp_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobp_datx cvmx_dtx_iobp_datx_t;
 
@@ -4829,7 +5389,9 @@ union cvmx_dtx_iobp_enax {
 #endif
 	} s;
 	struct cvmx_dtx_iobp_enax_s           cn73xx;
+	struct cvmx_dtx_iobp_enax_s           cn75xx;
 	struct cvmx_dtx_iobp_enax_s           cn78xx;
+	struct cvmx_dtx_iobp_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobp_enax cvmx_dtx_iobp_enax_t;
 
@@ -4848,7 +5410,9 @@ union cvmx_dtx_iobp_selx {
 #endif
 	} s;
 	struct cvmx_dtx_iobp_selx_s           cn73xx;
+	struct cvmx_dtx_iobp_selx_s           cn75xx;
 	struct cvmx_dtx_iobp_selx_s           cn78xx;
+	struct cvmx_dtx_iobp_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_iobp_selx cvmx_dtx_iobp_selx_t;
 
@@ -4973,6 +5537,8 @@ union cvmx_dtx_key_bcst_rsp {
 	} s;
 	struct cvmx_dtx_key_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_key_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_key_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_key_bcst_rsp_s        cn75xx;
 };
 typedef union cvmx_dtx_key_bcst_rsp cvmx_dtx_key_bcst_rsp_t;
 
@@ -5000,6 +5566,8 @@ union cvmx_dtx_key_ctl {
 	} s;
 	struct cvmx_dtx_key_ctl_s             cn70xx;
 	struct cvmx_dtx_key_ctl_s             cn70xxp1;
+	struct cvmx_dtx_key_ctl_s             cn73xx;
+	struct cvmx_dtx_key_ctl_s             cn75xx;
 };
 typedef union cvmx_dtx_key_ctl cvmx_dtx_key_ctl_t;
 
@@ -5020,6 +5588,8 @@ union cvmx_dtx_key_datx {
 	} s;
 	struct cvmx_dtx_key_datx_s            cn70xx;
 	struct cvmx_dtx_key_datx_s            cn70xxp1;
+	struct cvmx_dtx_key_datx_s            cn73xx;
+	struct cvmx_dtx_key_datx_s            cn75xx;
 };
 typedef union cvmx_dtx_key_datx cvmx_dtx_key_datx_t;
 
@@ -5040,6 +5610,8 @@ union cvmx_dtx_key_enax {
 	} s;
 	struct cvmx_dtx_key_enax_s            cn70xx;
 	struct cvmx_dtx_key_enax_s            cn70xxp1;
+	struct cvmx_dtx_key_enax_s            cn73xx;
+	struct cvmx_dtx_key_enax_s            cn75xx;
 };
 typedef union cvmx_dtx_key_enax cvmx_dtx_key_enax_t;
 
@@ -5059,6 +5631,8 @@ union cvmx_dtx_key_selx {
 	} s;
 	struct cvmx_dtx_key_selx_s            cn70xx;
 	struct cvmx_dtx_key_selx_s            cn70xxp1;
+	struct cvmx_dtx_key_selx_s            cn73xx;
+	struct cvmx_dtx_key_selx_s            cn75xx;
 };
 typedef union cvmx_dtx_key_selx cvmx_dtx_key_selx_t;
 
@@ -5079,7 +5653,9 @@ union cvmx_dtx_l2c_cbcx_bcst_rsp {
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xxp1;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn73xx;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn75xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn78xx;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_cbcx_bcst_rsp cvmx_dtx_l2c_cbcx_bcst_rsp_t;
 
@@ -5108,7 +5684,9 @@ union cvmx_dtx_l2c_cbcx_ctl {
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xxp1;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn73xx;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn75xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn78xx;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_cbcx_ctl cvmx_dtx_l2c_cbcx_ctl_t;
 
@@ -5130,7 +5708,9 @@ union cvmx_dtx_l2c_cbcx_datx {
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn73xx;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn75xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn78xx;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_cbcx_datx cvmx_dtx_l2c_cbcx_datx_t;
 
@@ -5152,7 +5732,9 @@ union cvmx_dtx_l2c_cbcx_enax {
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xxp1;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn73xx;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn75xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn78xx;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_cbcx_enax cvmx_dtx_l2c_cbcx_enax_t;
 
@@ -5173,7 +5755,9 @@ union cvmx_dtx_l2c_cbcx_selx {
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn73xx;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn75xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn78xx;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_cbcx_selx cvmx_dtx_l2c_cbcx_selx_t;
 
@@ -5194,7 +5778,9 @@ union cvmx_dtx_l2c_mcix_bcst_rsp {
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xxp1;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn73xx;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn75xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn78xx;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_mcix_bcst_rsp cvmx_dtx_l2c_mcix_bcst_rsp_t;
 
@@ -5223,7 +5809,9 @@ union cvmx_dtx_l2c_mcix_ctl {
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xxp1;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn73xx;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn75xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn78xx;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_mcix_ctl cvmx_dtx_l2c_mcix_ctl_t;
 
@@ -5245,7 +5833,9 @@ union cvmx_dtx_l2c_mcix_datx {
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn73xx;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn75xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn78xx;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_mcix_datx cvmx_dtx_l2c_mcix_datx_t;
 
@@ -5267,7 +5857,9 @@ union cvmx_dtx_l2c_mcix_enax {
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xxp1;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn73xx;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn75xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn78xx;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_mcix_enax cvmx_dtx_l2c_mcix_enax_t;
 
@@ -5288,7 +5880,9 @@ union cvmx_dtx_l2c_mcix_selx {
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn73xx;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn75xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn78xx;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_mcix_selx cvmx_dtx_l2c_mcix_selx_t;
 
@@ -5309,7 +5903,9 @@ union cvmx_dtx_l2c_tadx_bcst_rsp {
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xxp1;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn73xx;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn75xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn78xx;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_tadx_bcst_rsp cvmx_dtx_l2c_tadx_bcst_rsp_t;
 
@@ -5338,7 +5934,9 @@ union cvmx_dtx_l2c_tadx_ctl {
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xxp1;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn73xx;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn75xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn78xx;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_tadx_ctl cvmx_dtx_l2c_tadx_ctl_t;
 
@@ -5360,7 +5958,9 @@ union cvmx_dtx_l2c_tadx_datx {
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn73xx;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn75xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn78xx;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_tadx_datx cvmx_dtx_l2c_tadx_datx_t;
 
@@ -5382,7 +5982,9 @@ union cvmx_dtx_l2c_tadx_enax {
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xxp1;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn73xx;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn75xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn78xx;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_tadx_enax cvmx_dtx_l2c_tadx_enax_t;
 
@@ -5403,7 +6005,9 @@ union cvmx_dtx_l2c_tadx_selx {
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xxp1;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn73xx;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn75xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn78xx;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_l2c_tadx_selx cvmx_dtx_l2c_tadx_selx_t;
 
@@ -5422,6 +6026,7 @@ union cvmx_dtx_lapx_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_lapx_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_lapx_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_lapx_bcst_rsp cvmx_dtx_lapx_bcst_rsp_t;
 
@@ -5448,6 +6053,7 @@ union cvmx_dtx_lapx_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_lapx_ctl_s            cn78xx;
+	struct cvmx_dtx_lapx_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_lapx_ctl cvmx_dtx_lapx_ctl_t;
 
@@ -5467,6 +6073,7 @@ union cvmx_dtx_lapx_datx {
 #endif
 	} s;
 	struct cvmx_dtx_lapx_datx_s           cn78xx;
+	struct cvmx_dtx_lapx_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lapx_datx cvmx_dtx_lapx_datx_t;
 
@@ -5486,6 +6093,7 @@ union cvmx_dtx_lapx_enax {
 #endif
 	} s;
 	struct cvmx_dtx_lapx_enax_s           cn78xx;
+	struct cvmx_dtx_lapx_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lapx_enax cvmx_dtx_lapx_enax_t;
 
@@ -5504,6 +6112,7 @@ union cvmx_dtx_lapx_selx {
 #endif
 	} s;
 	struct cvmx_dtx_lapx_selx_s           cn78xx;
+	struct cvmx_dtx_lapx_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lapx_selx cvmx_dtx_lapx_selx_t;
 
@@ -5522,7 +6131,9 @@ union cvmx_dtx_lbk_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_lbk_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_lbk_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_lbk_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_lbk_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_lbk_bcst_rsp cvmx_dtx_lbk_bcst_rsp_t;
 
@@ -5549,7 +6160,9 @@ union cvmx_dtx_lbk_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_lbk_ctl_s             cn73xx;
+	struct cvmx_dtx_lbk_ctl_s             cn75xx;
 	struct cvmx_dtx_lbk_ctl_s             cn78xx;
+	struct cvmx_dtx_lbk_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_lbk_ctl cvmx_dtx_lbk_ctl_t;
 
@@ -5569,7 +6182,9 @@ union cvmx_dtx_lbk_datx {
 #endif
 	} s;
 	struct cvmx_dtx_lbk_datx_s            cn73xx;
+	struct cvmx_dtx_lbk_datx_s            cn75xx;
 	struct cvmx_dtx_lbk_datx_s            cn78xx;
+	struct cvmx_dtx_lbk_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_lbk_datx cvmx_dtx_lbk_datx_t;
 
@@ -5589,7 +6204,9 @@ union cvmx_dtx_lbk_enax {
 #endif
 	} s;
 	struct cvmx_dtx_lbk_enax_s            cn73xx;
+	struct cvmx_dtx_lbk_enax_s            cn75xx;
 	struct cvmx_dtx_lbk_enax_s            cn78xx;
+	struct cvmx_dtx_lbk_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_lbk_enax cvmx_dtx_lbk_enax_t;
 
@@ -5608,7 +6225,9 @@ union cvmx_dtx_lbk_selx {
 #endif
 	} s;
 	struct cvmx_dtx_lbk_selx_s            cn73xx;
+	struct cvmx_dtx_lbk_selx_s            cn75xx;
 	struct cvmx_dtx_lbk_selx_s            cn78xx;
+	struct cvmx_dtx_lbk_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_lbk_selx cvmx_dtx_lbk_selx_t;
 
@@ -5629,7 +6248,9 @@ union cvmx_dtx_lmcx_bcst_rsp {
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xxp1;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn75xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_lmcx_bcst_rsp cvmx_dtx_lmcx_bcst_rsp_t;
 
@@ -5658,7 +6279,9 @@ union cvmx_dtx_lmcx_ctl {
 	struct cvmx_dtx_lmcx_ctl_s            cn70xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn70xxp1;
 	struct cvmx_dtx_lmcx_ctl_s            cn73xx;
+	struct cvmx_dtx_lmcx_ctl_s            cn75xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn78xx;
+	struct cvmx_dtx_lmcx_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_lmcx_ctl cvmx_dtx_lmcx_ctl_t;
 
@@ -5680,7 +6303,9 @@ union cvmx_dtx_lmcx_datx {
 	struct cvmx_dtx_lmcx_datx_s           cn70xx;
 	struct cvmx_dtx_lmcx_datx_s           cn70xxp1;
 	struct cvmx_dtx_lmcx_datx_s           cn73xx;
+	struct cvmx_dtx_lmcx_datx_s           cn75xx;
 	struct cvmx_dtx_lmcx_datx_s           cn78xx;
+	struct cvmx_dtx_lmcx_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lmcx_datx cvmx_dtx_lmcx_datx_t;
 
@@ -5702,7 +6327,9 @@ union cvmx_dtx_lmcx_enax {
 	struct cvmx_dtx_lmcx_enax_s           cn70xx;
 	struct cvmx_dtx_lmcx_enax_s           cn70xxp1;
 	struct cvmx_dtx_lmcx_enax_s           cn73xx;
+	struct cvmx_dtx_lmcx_enax_s           cn75xx;
 	struct cvmx_dtx_lmcx_enax_s           cn78xx;
+	struct cvmx_dtx_lmcx_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lmcx_enax cvmx_dtx_lmcx_enax_t;
 
@@ -5723,11 +6350,113 @@ union cvmx_dtx_lmcx_selx {
 	struct cvmx_dtx_lmcx_selx_s           cn70xx;
 	struct cvmx_dtx_lmcx_selx_s           cn70xxp1;
 	struct cvmx_dtx_lmcx_selx_s           cn73xx;
+	struct cvmx_dtx_lmcx_selx_s           cn75xx;
 	struct cvmx_dtx_lmcx_selx_s           cn78xx;
+	struct cvmx_dtx_lmcx_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_lmcx_selx cvmx_dtx_lmcx_selx_t;
 
 /**
+ * cvmx_dtx_mhbw_bcst_rsp
+ */
+union cvmx_dtx_mhbw_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_mhbw_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_mhbw_bcst_rsp_s       cn75xx;
+};
+typedef union cvmx_dtx_mhbw_bcst_rsp cvmx_dtx_mhbw_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_mhbw_ctl
+ */
+union cvmx_dtx_mhbw_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_mhbw_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_mhbw_ctl_s            cn75xx;
+};
+typedef union cvmx_dtx_mhbw_ctl cvmx_dtx_mhbw_ctl_t;
+
+/**
+ * cvmx_dtx_mhbw_dat#
+ */
+union cvmx_dtx_mhbw_datx {
+	uint64_t u64;
+	struct cvmx_dtx_mhbw_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_mhbw_datx_s           cn75xx;
+};
+typedef union cvmx_dtx_mhbw_datx cvmx_dtx_mhbw_datx_t;
+
+/**
+ * cvmx_dtx_mhbw_ena#
+ */
+union cvmx_dtx_mhbw_enax {
+	uint64_t u64;
+	struct cvmx_dtx_mhbw_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_mhbw_enax_s           cn75xx;
+};
+typedef union cvmx_dtx_mhbw_enax cvmx_dtx_mhbw_enax_t;
+
+/**
+ * cvmx_dtx_mhbw_sel#
+ */
+union cvmx_dtx_mhbw_selx {
+	uint64_t u64;
+	struct cvmx_dtx_mhbw_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_mhbw_selx_s           cn75xx;
+};
+typedef union cvmx_dtx_mhbw_selx cvmx_dtx_mhbw_selx_t;
+
+/**
  * cvmx_dtx_mio_bcst_rsp
  */
 union cvmx_dtx_mio_bcst_rsp {
@@ -5744,7 +6473,9 @@ union cvmx_dtx_mio_bcst_rsp {
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_mio_bcst_rsp cvmx_dtx_mio_bcst_rsp_t;
 
@@ -5773,7 +6504,9 @@ union cvmx_dtx_mio_ctl {
 	struct cvmx_dtx_mio_ctl_s             cn70xx;
 	struct cvmx_dtx_mio_ctl_s             cn70xxp1;
 	struct cvmx_dtx_mio_ctl_s             cn73xx;
+	struct cvmx_dtx_mio_ctl_s             cn75xx;
 	struct cvmx_dtx_mio_ctl_s             cn78xx;
+	struct cvmx_dtx_mio_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_mio_ctl cvmx_dtx_mio_ctl_t;
 
@@ -5795,7 +6528,9 @@ union cvmx_dtx_mio_datx {
 	struct cvmx_dtx_mio_datx_s            cn70xx;
 	struct cvmx_dtx_mio_datx_s            cn70xxp1;
 	struct cvmx_dtx_mio_datx_s            cn73xx;
+	struct cvmx_dtx_mio_datx_s            cn75xx;
 	struct cvmx_dtx_mio_datx_s            cn78xx;
+	struct cvmx_dtx_mio_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_mio_datx cvmx_dtx_mio_datx_t;
 
@@ -5817,7 +6552,9 @@ union cvmx_dtx_mio_enax {
 	struct cvmx_dtx_mio_enax_s            cn70xx;
 	struct cvmx_dtx_mio_enax_s            cn70xxp1;
 	struct cvmx_dtx_mio_enax_s            cn73xx;
+	struct cvmx_dtx_mio_enax_s            cn75xx;
 	struct cvmx_dtx_mio_enax_s            cn78xx;
+	struct cvmx_dtx_mio_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_mio_enax cvmx_dtx_mio_enax_t;
 
@@ -5838,7 +6575,9 @@ union cvmx_dtx_mio_selx {
 	struct cvmx_dtx_mio_selx_s            cn70xx;
 	struct cvmx_dtx_mio_selx_s            cn70xxp1;
 	struct cvmx_dtx_mio_selx_s            cn73xx;
+	struct cvmx_dtx_mio_selx_s            cn75xx;
 	struct cvmx_dtx_mio_selx_s            cn78xx;
+	struct cvmx_dtx_mio_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_mio_selx cvmx_dtx_mio_selx_t;
 
@@ -5857,6 +6596,7 @@ union cvmx_dtx_ocx_lnkx_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s   cn78xx;
+	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s   cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_lnkx_bcst_rsp cvmx_dtx_ocx_lnkx_bcst_rsp_t;
 
@@ -5883,6 +6623,7 @@ union cvmx_dtx_ocx_lnkx_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_lnkx_ctl_s        cn78xx;
+	struct cvmx_dtx_ocx_lnkx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_lnkx_ctl cvmx_dtx_ocx_lnkx_ctl_t;
 
@@ -5902,6 +6643,7 @@ union cvmx_dtx_ocx_lnkx_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_lnkx_datx_s       cn78xx;
+	struct cvmx_dtx_ocx_lnkx_datx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_lnkx_datx cvmx_dtx_ocx_lnkx_datx_t;
 
@@ -5921,6 +6663,7 @@ union cvmx_dtx_ocx_lnkx_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_lnkx_enax_s       cn78xx;
+	struct cvmx_dtx_ocx_lnkx_enax_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_lnkx_enax cvmx_dtx_ocx_lnkx_enax_t;
 
@@ -5939,6 +6682,7 @@ union cvmx_dtx_ocx_lnkx_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_lnkx_selx_s       cn78xx;
+	struct cvmx_dtx_ocx_lnkx_selx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_lnkx_selx cvmx_dtx_ocx_lnkx_selx_t;
 
@@ -5957,6 +6701,7 @@ union cvmx_dtx_ocx_olex_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_olex_bcst_rsp_s   cn78xx;
+	struct cvmx_dtx_ocx_olex_bcst_rsp_s   cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_olex_bcst_rsp cvmx_dtx_ocx_olex_bcst_rsp_t;
 
@@ -5983,6 +6728,7 @@ union cvmx_dtx_ocx_olex_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_olex_ctl_s        cn78xx;
+	struct cvmx_dtx_ocx_olex_ctl_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_olex_ctl cvmx_dtx_ocx_olex_ctl_t;
 
@@ -6002,6 +6748,7 @@ union cvmx_dtx_ocx_olex_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_olex_datx_s       cn78xx;
+	struct cvmx_dtx_ocx_olex_datx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_olex_datx cvmx_dtx_ocx_olex_datx_t;
 
@@ -6021,6 +6768,7 @@ union cvmx_dtx_ocx_olex_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_olex_enax_s       cn78xx;
+	struct cvmx_dtx_ocx_olex_enax_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_olex_enax cvmx_dtx_ocx_olex_enax_t;
 
@@ -6039,6 +6787,7 @@ union cvmx_dtx_ocx_olex_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_olex_selx_s       cn78xx;
+	struct cvmx_dtx_ocx_olex_selx_s       cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_olex_selx cvmx_dtx_ocx_olex_selx_t;
 
@@ -6057,6 +6806,7 @@ union cvmx_dtx_ocx_top_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_top_bcst_rsp_s    cn78xx;
+	struct cvmx_dtx_ocx_top_bcst_rsp_s    cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_top_bcst_rsp cvmx_dtx_ocx_top_bcst_rsp_t;
 
@@ -6083,6 +6833,7 @@ union cvmx_dtx_ocx_top_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_top_ctl_s         cn78xx;
+	struct cvmx_dtx_ocx_top_ctl_s         cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_top_ctl cvmx_dtx_ocx_top_ctl_t;
 
@@ -6102,6 +6853,7 @@ union cvmx_dtx_ocx_top_datx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_top_datx_s        cn78xx;
+	struct cvmx_dtx_ocx_top_datx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_top_datx cvmx_dtx_ocx_top_datx_t;
 
@@ -6121,6 +6873,7 @@ union cvmx_dtx_ocx_top_enax {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_top_enax_s        cn78xx;
+	struct cvmx_dtx_ocx_top_enax_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_top_enax cvmx_dtx_ocx_top_enax_t;
 
@@ -6139,6 +6892,7 @@ union cvmx_dtx_ocx_top_selx {
 #endif
 	} s;
 	struct cvmx_dtx_ocx_top_selx_s        cn78xx;
+	struct cvmx_dtx_ocx_top_selx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_ocx_top_selx cvmx_dtx_ocx_top_selx_t;
 
@@ -6157,7 +6911,9 @@ union cvmx_dtx_osm_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_osm_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_osm_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_osm_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_osm_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_osm_bcst_rsp cvmx_dtx_osm_bcst_rsp_t;
 
@@ -6184,7 +6940,9 @@ union cvmx_dtx_osm_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_osm_ctl_s             cn73xx;
+	struct cvmx_dtx_osm_ctl_s             cn75xx;
 	struct cvmx_dtx_osm_ctl_s             cn78xx;
+	struct cvmx_dtx_osm_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_osm_ctl cvmx_dtx_osm_ctl_t;
 
@@ -6204,7 +6962,9 @@ union cvmx_dtx_osm_datx {
 #endif
 	} s;
 	struct cvmx_dtx_osm_datx_s            cn73xx;
+	struct cvmx_dtx_osm_datx_s            cn75xx;
 	struct cvmx_dtx_osm_datx_s            cn78xx;
+	struct cvmx_dtx_osm_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_osm_datx cvmx_dtx_osm_datx_t;
 
@@ -6224,7 +6984,9 @@ union cvmx_dtx_osm_enax {
 #endif
 	} s;
 	struct cvmx_dtx_osm_enax_s            cn73xx;
+	struct cvmx_dtx_osm_enax_s            cn75xx;
 	struct cvmx_dtx_osm_enax_s            cn78xx;
+	struct cvmx_dtx_osm_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_osm_enax cvmx_dtx_osm_enax_t;
 
@@ -6243,7 +7005,9 @@ union cvmx_dtx_osm_selx {
 #endif
 	} s;
 	struct cvmx_dtx_osm_selx_s            cn73xx;
+	struct cvmx_dtx_osm_selx_s            cn75xx;
 	struct cvmx_dtx_osm_selx_s            cn78xx;
+	struct cvmx_dtx_osm_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_osm_selx cvmx_dtx_osm_selx_t;
 
@@ -6369,7 +7133,9 @@ union cvmx_dtx_pemx_bcst_rsp {
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xxp1;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn75xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn78xx;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn78xxp2;
 };
 typedef union cvmx_dtx_pemx_bcst_rsp cvmx_dtx_pemx_bcst_rsp_t;
 
@@ -6398,7 +7164,9 @@ union cvmx_dtx_pemx_ctl {
 	struct cvmx_dtx_pemx_ctl_s            cn70xx;
 	struct cvmx_dtx_pemx_ctl_s            cn70xxp1;
 	struct cvmx_dtx_pemx_ctl_s            cn73xx;
+	struct cvmx_dtx_pemx_ctl_s            cn75xx;
 	struct cvmx_dtx_pemx_ctl_s            cn78xx;
+	struct cvmx_dtx_pemx_ctl_s            cn78xxp2;
 };
 typedef union cvmx_dtx_pemx_ctl cvmx_dtx_pemx_ctl_t;
 
@@ -6420,7 +7188,9 @@ union cvmx_dtx_pemx_datx {
 	struct cvmx_dtx_pemx_datx_s           cn70xx;
 	struct cvmx_dtx_pemx_datx_s           cn70xxp1;
 	struct cvmx_dtx_pemx_datx_s           cn73xx;
+	struct cvmx_dtx_pemx_datx_s           cn75xx;
 	struct cvmx_dtx_pemx_datx_s           cn78xx;
+	struct cvmx_dtx_pemx_datx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_pemx_datx cvmx_dtx_pemx_datx_t;
 
@@ -6442,7 +7212,9 @@ union cvmx_dtx_pemx_enax {
 	struct cvmx_dtx_pemx_enax_s           cn70xx;
 	struct cvmx_dtx_pemx_enax_s           cn70xxp1;
 	struct cvmx_dtx_pemx_enax_s           cn73xx;
+	struct cvmx_dtx_pemx_enax_s           cn75xx;
 	struct cvmx_dtx_pemx_enax_s           cn78xx;
+	struct cvmx_dtx_pemx_enax_s           cn78xxp2;
 };
 typedef union cvmx_dtx_pemx_enax cvmx_dtx_pemx_enax_t;
 
@@ -6463,7 +7235,9 @@ union cvmx_dtx_pemx_selx {
 	struct cvmx_dtx_pemx_selx_s           cn70xx;
 	struct cvmx_dtx_pemx_selx_s           cn70xxp1;
 	struct cvmx_dtx_pemx_selx_s           cn73xx;
+	struct cvmx_dtx_pemx_selx_s           cn75xx;
 	struct cvmx_dtx_pemx_selx_s           cn78xx;
+	struct cvmx_dtx_pemx_selx_s           cn78xxp2;
 };
 typedef union cvmx_dtx_pemx_selx cvmx_dtx_pemx_selx_t;
 
@@ -6587,7 +7361,9 @@ union cvmx_dtx_pki_pbe_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn73xx;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn75xx;
 	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn78xx;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pbe_bcst_rsp cvmx_dtx_pki_pbe_bcst_rsp_t;
 
@@ -6614,7 +7390,9 @@ union cvmx_dtx_pki_pbe_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pbe_ctl_s         cn73xx;
+	struct cvmx_dtx_pki_pbe_ctl_s         cn75xx;
 	struct cvmx_dtx_pki_pbe_ctl_s         cn78xx;
+	struct cvmx_dtx_pki_pbe_ctl_s         cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pbe_ctl cvmx_dtx_pki_pbe_ctl_t;
 
@@ -6634,7 +7412,9 @@ union cvmx_dtx_pki_pbe_datx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pbe_datx_s        cn73xx;
+	struct cvmx_dtx_pki_pbe_datx_s        cn75xx;
 	struct cvmx_dtx_pki_pbe_datx_s        cn78xx;
+	struct cvmx_dtx_pki_pbe_datx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pbe_datx cvmx_dtx_pki_pbe_datx_t;
 
@@ -6654,7 +7434,9 @@ union cvmx_dtx_pki_pbe_enax {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pbe_enax_s        cn73xx;
+	struct cvmx_dtx_pki_pbe_enax_s        cn75xx;
 	struct cvmx_dtx_pki_pbe_enax_s        cn78xx;
+	struct cvmx_dtx_pki_pbe_enax_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pbe_enax cvmx_dtx_pki_pbe_enax_t;
 
@@ -6673,7 +7455,9 @@ union cvmx_dtx_pki_pbe_selx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pbe_selx_s        cn73xx;
+	struct cvmx_dtx_pki_pbe_selx_s        cn75xx;
 	struct cvmx_dtx_pki_pbe_selx_s        cn78xx;
+	struct cvmx_dtx_pki_pbe_selx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pbe_selx cvmx_dtx_pki_pbe_selx_t;
 
@@ -6692,7 +7476,9 @@ union cvmx_dtx_pki_pfe_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn73xx;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn75xx;
 	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn78xx;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pfe_bcst_rsp cvmx_dtx_pki_pfe_bcst_rsp_t;
 
@@ -6719,7 +7505,9 @@ union cvmx_dtx_pki_pfe_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pfe_ctl_s         cn73xx;
+	struct cvmx_dtx_pki_pfe_ctl_s         cn75xx;
 	struct cvmx_dtx_pki_pfe_ctl_s         cn78xx;
+	struct cvmx_dtx_pki_pfe_ctl_s         cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pfe_ctl cvmx_dtx_pki_pfe_ctl_t;
 
@@ -6739,7 +7527,9 @@ union cvmx_dtx_pki_pfe_datx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pfe_datx_s        cn73xx;
+	struct cvmx_dtx_pki_pfe_datx_s        cn75xx;
 	struct cvmx_dtx_pki_pfe_datx_s        cn78xx;
+	struct cvmx_dtx_pki_pfe_datx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pfe_datx cvmx_dtx_pki_pfe_datx_t;
 
@@ -6759,7 +7549,9 @@ union cvmx_dtx_pki_pfe_enax {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pfe_enax_s        cn73xx;
+	struct cvmx_dtx_pki_pfe_enax_s        cn75xx;
 	struct cvmx_dtx_pki_pfe_enax_s        cn78xx;
+	struct cvmx_dtx_pki_pfe_enax_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pfe_enax cvmx_dtx_pki_pfe_enax_t;
 
@@ -6778,7 +7570,9 @@ union cvmx_dtx_pki_pfe_selx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pfe_selx_s        cn73xx;
+	struct cvmx_dtx_pki_pfe_selx_s        cn75xx;
 	struct cvmx_dtx_pki_pfe_selx_s        cn78xx;
+	struct cvmx_dtx_pki_pfe_selx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pfe_selx cvmx_dtx_pki_pfe_selx_t;
 
@@ -6797,7 +7591,9 @@ union cvmx_dtx_pki_pix_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn73xx;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn75xx;
 	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn78xx;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pix_bcst_rsp cvmx_dtx_pki_pix_bcst_rsp_t;
 
@@ -6824,7 +7620,9 @@ union cvmx_dtx_pki_pix_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pix_ctl_s         cn73xx;
+	struct cvmx_dtx_pki_pix_ctl_s         cn75xx;
 	struct cvmx_dtx_pki_pix_ctl_s         cn78xx;
+	struct cvmx_dtx_pki_pix_ctl_s         cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pix_ctl cvmx_dtx_pki_pix_ctl_t;
 
@@ -6844,7 +7642,9 @@ union cvmx_dtx_pki_pix_datx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pix_datx_s        cn73xx;
+	struct cvmx_dtx_pki_pix_datx_s        cn75xx;
 	struct cvmx_dtx_pki_pix_datx_s        cn78xx;
+	struct cvmx_dtx_pki_pix_datx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pix_datx cvmx_dtx_pki_pix_datx_t;
 
@@ -6864,7 +7664,9 @@ union cvmx_dtx_pki_pix_enax {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pix_enax_s        cn73xx;
+	struct cvmx_dtx_pki_pix_enax_s        cn75xx;
 	struct cvmx_dtx_pki_pix_enax_s        cn78xx;
+	struct cvmx_dtx_pki_pix_enax_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pix_enax cvmx_dtx_pki_pix_enax_t;
 
@@ -6883,7 +7685,9 @@ union cvmx_dtx_pki_pix_selx {
 #endif
 	} s;
 	struct cvmx_dtx_pki_pix_selx_s        cn73xx;
+	struct cvmx_dtx_pki_pix_selx_s        cn75xx;
 	struct cvmx_dtx_pki_pix_selx_s        cn78xx;
+	struct cvmx_dtx_pki_pix_selx_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pki_pix_selx cvmx_dtx_pki_pix_selx_t;
 
@@ -6904,7 +7708,9 @@ union cvmx_dtx_pko_bcst_rsp {
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_pko_bcst_rsp cvmx_dtx_pko_bcst_rsp_t;
 
@@ -6933,7 +7739,9 @@ union cvmx_dtx_pko_ctl {
 	struct cvmx_dtx_pko_ctl_s             cn70xx;
 	struct cvmx_dtx_pko_ctl_s             cn70xxp1;
 	struct cvmx_dtx_pko_ctl_s             cn73xx;
+	struct cvmx_dtx_pko_ctl_s             cn75xx;
 	struct cvmx_dtx_pko_ctl_s             cn78xx;
+	struct cvmx_dtx_pko_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_pko_ctl cvmx_dtx_pko_ctl_t;
 
@@ -6955,7 +7763,9 @@ union cvmx_dtx_pko_datx {
 	struct cvmx_dtx_pko_datx_s            cn70xx;
 	struct cvmx_dtx_pko_datx_s            cn70xxp1;
 	struct cvmx_dtx_pko_datx_s            cn73xx;
+	struct cvmx_dtx_pko_datx_s            cn75xx;
 	struct cvmx_dtx_pko_datx_s            cn78xx;
+	struct cvmx_dtx_pko_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_pko_datx cvmx_dtx_pko_datx_t;
 
@@ -6977,7 +7787,9 @@ union cvmx_dtx_pko_enax {
 	struct cvmx_dtx_pko_enax_s            cn70xx;
 	struct cvmx_dtx_pko_enax_s            cn70xxp1;
 	struct cvmx_dtx_pko_enax_s            cn73xx;
+	struct cvmx_dtx_pko_enax_s            cn75xx;
 	struct cvmx_dtx_pko_enax_s            cn78xx;
+	struct cvmx_dtx_pko_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_pko_enax cvmx_dtx_pko_enax_t;
 
@@ -6998,11 +7810,113 @@ union cvmx_dtx_pko_selx {
 	struct cvmx_dtx_pko_selx_s            cn70xx;
 	struct cvmx_dtx_pko_selx_s            cn70xxp1;
 	struct cvmx_dtx_pko_selx_s            cn73xx;
+	struct cvmx_dtx_pko_selx_s            cn75xx;
 	struct cvmx_dtx_pko_selx_s            cn78xx;
+	struct cvmx_dtx_pko_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_pko_selx cvmx_dtx_pko_selx_t;
 
 /**
+ * cvmx_dtx_pnb#_bcst_rsp
+ */
+union cvmx_dtx_pnbx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pnbx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pnbx_bcst_rsp_s       cn75xx;
+};
+typedef union cvmx_dtx_pnbx_bcst_rsp cvmx_dtx_pnbx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pnb#_ctl
+ */
+union cvmx_dtx_pnbx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pnbx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pnbx_ctl_s            cn75xx;
+};
+typedef union cvmx_dtx_pnbx_ctl cvmx_dtx_pnbx_ctl_t;
+
+/**
+ * cvmx_dtx_pnb#_dat#
+ */
+union cvmx_dtx_pnbx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pnbx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pnbx_datx_s           cn75xx;
+};
+typedef union cvmx_dtx_pnbx_datx cvmx_dtx_pnbx_datx_t;
+
+/**
+ * cvmx_dtx_pnb#_ena#
+ */
+union cvmx_dtx_pnbx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pnbx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pnbx_enax_s           cn75xx;
+};
+typedef union cvmx_dtx_pnbx_enax cvmx_dtx_pnbx_enax_t;
+
+/**
+ * cvmx_dtx_pnb#_sel#
+ */
+union cvmx_dtx_pnbx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pnbx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pnbx_selx_s           cn75xx;
+};
+typedef union cvmx_dtx_pnbx_selx cvmx_dtx_pnbx_selx_t;
+
+/**
  * cvmx_dtx_pow_bcst_rsp
  */
 union cvmx_dtx_pow_bcst_rsp {
@@ -7122,7 +8036,9 @@ union cvmx_dtx_rad_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_rad_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_rad_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_rad_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_rad_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_rad_bcst_rsp cvmx_dtx_rad_bcst_rsp_t;
 
@@ -7149,7 +8065,9 @@ union cvmx_dtx_rad_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_rad_ctl_s             cn73xx;
+	struct cvmx_dtx_rad_ctl_s             cn75xx;
 	struct cvmx_dtx_rad_ctl_s             cn78xx;
+	struct cvmx_dtx_rad_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_rad_ctl cvmx_dtx_rad_ctl_t;
 
@@ -7169,7 +8087,9 @@ union cvmx_dtx_rad_datx {
 #endif
 	} s;
 	struct cvmx_dtx_rad_datx_s            cn73xx;
+	struct cvmx_dtx_rad_datx_s            cn75xx;
 	struct cvmx_dtx_rad_datx_s            cn78xx;
+	struct cvmx_dtx_rad_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rad_datx cvmx_dtx_rad_datx_t;
 
@@ -7189,7 +8109,9 @@ union cvmx_dtx_rad_enax {
 #endif
 	} s;
 	struct cvmx_dtx_rad_enax_s            cn73xx;
+	struct cvmx_dtx_rad_enax_s            cn75xx;
 	struct cvmx_dtx_rad_enax_s            cn78xx;
+	struct cvmx_dtx_rad_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rad_enax cvmx_dtx_rad_enax_t;
 
@@ -7208,11 +8130,213 @@ union cvmx_dtx_rad_selx {
 #endif
 	} s;
 	struct cvmx_dtx_rad_selx_s            cn73xx;
+	struct cvmx_dtx_rad_selx_s            cn75xx;
 	struct cvmx_dtx_rad_selx_s            cn78xx;
+	struct cvmx_dtx_rad_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rad_selx cvmx_dtx_rad_selx_t;
 
 /**
+ * cvmx_dtx_rdec_bcst_rsp
+ */
+union cvmx_dtx_rdec_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_rdec_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_rdec_bcst_rsp_s       cn75xx;
+};
+typedef union cvmx_dtx_rdec_bcst_rsp cvmx_dtx_rdec_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_rdec_ctl
+ */
+union cvmx_dtx_rdec_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_rdec_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_rdec_ctl_s            cn75xx;
+};
+typedef union cvmx_dtx_rdec_ctl cvmx_dtx_rdec_ctl_t;
+
+/**
+ * cvmx_dtx_rdec_dat#
+ */
+union cvmx_dtx_rdec_datx {
+	uint64_t u64;
+	struct cvmx_dtx_rdec_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rdec_datx_s           cn75xx;
+};
+typedef union cvmx_dtx_rdec_datx cvmx_dtx_rdec_datx_t;
+
+/**
+ * cvmx_dtx_rdec_ena#
+ */
+union cvmx_dtx_rdec_enax {
+	uint64_t u64;
+	struct cvmx_dtx_rdec_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rdec_enax_s           cn75xx;
+};
+typedef union cvmx_dtx_rdec_enax cvmx_dtx_rdec_enax_t;
+
+/**
+ * cvmx_dtx_rdec_sel#
+ */
+union cvmx_dtx_rdec_selx {
+	uint64_t u64;
+	struct cvmx_dtx_rdec_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_rdec_selx_s           cn75xx;
+};
+typedef union cvmx_dtx_rdec_selx cvmx_dtx_rdec_selx_t;
+
+/**
+ * cvmx_dtx_rmap_bcst_rsp
+ */
+union cvmx_dtx_rmap_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_rmap_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_rmap_bcst_rsp_s       cn75xx;
+};
+typedef union cvmx_dtx_rmap_bcst_rsp cvmx_dtx_rmap_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_rmap_ctl
+ */
+union cvmx_dtx_rmap_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_rmap_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_rmap_ctl_s            cn75xx;
+};
+typedef union cvmx_dtx_rmap_ctl cvmx_dtx_rmap_ctl_t;
+
+/**
+ * cvmx_dtx_rmap_dat#
+ */
+union cvmx_dtx_rmap_datx {
+	uint64_t u64;
+	struct cvmx_dtx_rmap_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rmap_datx_s           cn75xx;
+};
+typedef union cvmx_dtx_rmap_datx cvmx_dtx_rmap_datx_t;
+
+/**
+ * cvmx_dtx_rmap_ena#
+ */
+union cvmx_dtx_rmap_enax {
+	uint64_t u64;
+	struct cvmx_dtx_rmap_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rmap_enax_s           cn75xx;
+};
+typedef union cvmx_dtx_rmap_enax cvmx_dtx_rmap_enax_t;
+
+/**
+ * cvmx_dtx_rmap_sel#
+ */
+union cvmx_dtx_rmap_selx {
+	uint64_t u64;
+	struct cvmx_dtx_rmap_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_rmap_selx_s           cn75xx;
+};
+typedef union cvmx_dtx_rmap_selx cvmx_dtx_rmap_selx_t;
+
+/**
  * cvmx_dtx_rnm_bcst_rsp
  */
 union cvmx_dtx_rnm_bcst_rsp {
@@ -7227,7 +8351,9 @@ union cvmx_dtx_rnm_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_rnm_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_rnm_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_rnm_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_rnm_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_rnm_bcst_rsp cvmx_dtx_rnm_bcst_rsp_t;
 
@@ -7254,7 +8380,9 @@ union cvmx_dtx_rnm_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_rnm_ctl_s             cn73xx;
+	struct cvmx_dtx_rnm_ctl_s             cn75xx;
 	struct cvmx_dtx_rnm_ctl_s             cn78xx;
+	struct cvmx_dtx_rnm_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_rnm_ctl cvmx_dtx_rnm_ctl_t;
 
@@ -7274,7 +8402,9 @@ union cvmx_dtx_rnm_datx {
 #endif
 	} s;
 	struct cvmx_dtx_rnm_datx_s            cn73xx;
+	struct cvmx_dtx_rnm_datx_s            cn75xx;
 	struct cvmx_dtx_rnm_datx_s            cn78xx;
+	struct cvmx_dtx_rnm_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rnm_datx cvmx_dtx_rnm_datx_t;
 
@@ -7294,7 +8424,9 @@ union cvmx_dtx_rnm_enax {
 #endif
 	} s;
 	struct cvmx_dtx_rnm_enax_s            cn73xx;
+	struct cvmx_dtx_rnm_enax_s            cn75xx;
 	struct cvmx_dtx_rnm_enax_s            cn78xx;
+	struct cvmx_dtx_rnm_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rnm_enax cvmx_dtx_rnm_enax_t;
 
@@ -7313,7 +8445,9 @@ union cvmx_dtx_rnm_selx {
 #endif
 	} s;
 	struct cvmx_dtx_rnm_selx_s            cn73xx;
+	struct cvmx_dtx_rnm_selx_s            cn75xx;
 	struct cvmx_dtx_rnm_selx_s            cn78xx;
+	struct cvmx_dtx_rnm_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rnm_selx cvmx_dtx_rnm_selx_t;
 
@@ -7334,7 +8468,9 @@ union cvmx_dtx_rst_bcst_rsp {
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_rst_bcst_rsp cvmx_dtx_rst_bcst_rsp_t;
 
@@ -7363,7 +8499,9 @@ union cvmx_dtx_rst_ctl {
 	struct cvmx_dtx_rst_ctl_s             cn70xx;
 	struct cvmx_dtx_rst_ctl_s             cn70xxp1;
 	struct cvmx_dtx_rst_ctl_s             cn73xx;
+	struct cvmx_dtx_rst_ctl_s             cn75xx;
 	struct cvmx_dtx_rst_ctl_s             cn78xx;
+	struct cvmx_dtx_rst_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_rst_ctl cvmx_dtx_rst_ctl_t;
 
@@ -7385,7 +8523,9 @@ union cvmx_dtx_rst_datx {
 	struct cvmx_dtx_rst_datx_s            cn70xx;
 	struct cvmx_dtx_rst_datx_s            cn70xxp1;
 	struct cvmx_dtx_rst_datx_s            cn73xx;
+	struct cvmx_dtx_rst_datx_s            cn75xx;
 	struct cvmx_dtx_rst_datx_s            cn78xx;
+	struct cvmx_dtx_rst_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rst_datx cvmx_dtx_rst_datx_t;
 
@@ -7407,7 +8547,9 @@ union cvmx_dtx_rst_enax {
 	struct cvmx_dtx_rst_enax_s            cn70xx;
 	struct cvmx_dtx_rst_enax_s            cn70xxp1;
 	struct cvmx_dtx_rst_enax_s            cn73xx;
+	struct cvmx_dtx_rst_enax_s            cn75xx;
 	struct cvmx_dtx_rst_enax_s            cn78xx;
+	struct cvmx_dtx_rst_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rst_enax cvmx_dtx_rst_enax_t;
 
@@ -7428,7 +8570,9 @@ union cvmx_dtx_rst_selx {
 	struct cvmx_dtx_rst_selx_s            cn70xx;
 	struct cvmx_dtx_rst_selx_s            cn70xxp1;
 	struct cvmx_dtx_rst_selx_s            cn73xx;
+	struct cvmx_dtx_rst_selx_s            cn75xx;
 	struct cvmx_dtx_rst_selx_s            cn78xx;
+	struct cvmx_dtx_rst_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_rst_selx cvmx_dtx_rst_selx_t;
 
@@ -7449,6 +8593,7 @@ union cvmx_dtx_sata_bcst_rsp {
 	struct cvmx_dtx_sata_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_sata_bcst_rsp_s       cn70xxp1;
 	struct cvmx_dtx_sata_bcst_rsp_s       cn73xx;
+	struct cvmx_dtx_sata_bcst_rsp_s       cn75xx;
 };
 typedef union cvmx_dtx_sata_bcst_rsp cvmx_dtx_sata_bcst_rsp_t;
 
@@ -7477,6 +8622,7 @@ union cvmx_dtx_sata_ctl {
 	struct cvmx_dtx_sata_ctl_s            cn70xx;
 	struct cvmx_dtx_sata_ctl_s            cn70xxp1;
 	struct cvmx_dtx_sata_ctl_s            cn73xx;
+	struct cvmx_dtx_sata_ctl_s            cn75xx;
 };
 typedef union cvmx_dtx_sata_ctl cvmx_dtx_sata_ctl_t;
 
@@ -7498,6 +8644,7 @@ union cvmx_dtx_sata_datx {
 	struct cvmx_dtx_sata_datx_s           cn70xx;
 	struct cvmx_dtx_sata_datx_s           cn70xxp1;
 	struct cvmx_dtx_sata_datx_s           cn73xx;
+	struct cvmx_dtx_sata_datx_s           cn75xx;
 };
 typedef union cvmx_dtx_sata_datx cvmx_dtx_sata_datx_t;
 
@@ -7519,6 +8666,7 @@ union cvmx_dtx_sata_enax {
 	struct cvmx_dtx_sata_enax_s           cn70xx;
 	struct cvmx_dtx_sata_enax_s           cn70xxp1;
 	struct cvmx_dtx_sata_enax_s           cn73xx;
+	struct cvmx_dtx_sata_enax_s           cn75xx;
 };
 typedef union cvmx_dtx_sata_enax cvmx_dtx_sata_enax_t;
 
@@ -7539,6 +8687,7 @@ union cvmx_dtx_sata_selx {
 	struct cvmx_dtx_sata_selx_s           cn70xx;
 	struct cvmx_dtx_sata_selx_s           cn70xxp1;
 	struct cvmx_dtx_sata_selx_s           cn73xx;
+	struct cvmx_dtx_sata_selx_s           cn75xx;
 };
 typedef union cvmx_dtx_sata_selx cvmx_dtx_sata_selx_t;
 
@@ -7559,7 +8708,9 @@ union cvmx_dtx_sli_bcst_rsp {
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_sli_bcst_rsp cvmx_dtx_sli_bcst_rsp_t;
 
@@ -7588,7 +8739,9 @@ union cvmx_dtx_sli_ctl {
 	struct cvmx_dtx_sli_ctl_s             cn70xx;
 	struct cvmx_dtx_sli_ctl_s             cn70xxp1;
 	struct cvmx_dtx_sli_ctl_s             cn73xx;
+	struct cvmx_dtx_sli_ctl_s             cn75xx;
 	struct cvmx_dtx_sli_ctl_s             cn78xx;
+	struct cvmx_dtx_sli_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_sli_ctl cvmx_dtx_sli_ctl_t;
 
@@ -7610,7 +8763,9 @@ union cvmx_dtx_sli_datx {
 	struct cvmx_dtx_sli_datx_s            cn70xx;
 	struct cvmx_dtx_sli_datx_s            cn70xxp1;
 	struct cvmx_dtx_sli_datx_s            cn73xx;
+	struct cvmx_dtx_sli_datx_s            cn75xx;
 	struct cvmx_dtx_sli_datx_s            cn78xx;
+	struct cvmx_dtx_sli_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sli_datx cvmx_dtx_sli_datx_t;
 
@@ -7632,7 +8787,9 @@ union cvmx_dtx_sli_enax {
 	struct cvmx_dtx_sli_enax_s            cn70xx;
 	struct cvmx_dtx_sli_enax_s            cn70xxp1;
 	struct cvmx_dtx_sli_enax_s            cn73xx;
+	struct cvmx_dtx_sli_enax_s            cn75xx;
 	struct cvmx_dtx_sli_enax_s            cn78xx;
+	struct cvmx_dtx_sli_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sli_enax cvmx_dtx_sli_enax_t;
 
@@ -7653,7 +8810,9 @@ union cvmx_dtx_sli_selx {
 	struct cvmx_dtx_sli_selx_s            cn70xx;
 	struct cvmx_dtx_sli_selx_s            cn70xxp1;
 	struct cvmx_dtx_sli_selx_s            cn73xx;
+	struct cvmx_dtx_sli_selx_s            cn75xx;
 	struct cvmx_dtx_sli_selx_s            cn78xx;
+	struct cvmx_dtx_sli_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sli_selx cvmx_dtx_sli_selx_t;
 
@@ -7672,7 +8831,9 @@ union cvmx_dtx_sso_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_sso_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_sso_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_sso_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_sso_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_sso_bcst_rsp cvmx_dtx_sso_bcst_rsp_t;
 
@@ -7699,7 +8860,9 @@ union cvmx_dtx_sso_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_sso_ctl_s             cn73xx;
+	struct cvmx_dtx_sso_ctl_s             cn75xx;
 	struct cvmx_dtx_sso_ctl_s             cn78xx;
+	struct cvmx_dtx_sso_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_sso_ctl cvmx_dtx_sso_ctl_t;
 
@@ -7719,7 +8882,9 @@ union cvmx_dtx_sso_datx {
 #endif
 	} s;
 	struct cvmx_dtx_sso_datx_s            cn73xx;
+	struct cvmx_dtx_sso_datx_s            cn75xx;
 	struct cvmx_dtx_sso_datx_s            cn78xx;
+	struct cvmx_dtx_sso_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sso_datx cvmx_dtx_sso_datx_t;
 
@@ -7739,7 +8904,9 @@ union cvmx_dtx_sso_enax {
 #endif
 	} s;
 	struct cvmx_dtx_sso_enax_s            cn73xx;
+	struct cvmx_dtx_sso_enax_s            cn75xx;
 	struct cvmx_dtx_sso_enax_s            cn78xx;
+	struct cvmx_dtx_sso_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sso_enax cvmx_dtx_sso_enax_t;
 
@@ -7758,7 +8925,9 @@ union cvmx_dtx_sso_selx {
 #endif
 	} s;
 	struct cvmx_dtx_sso_selx_s            cn73xx;
+	struct cvmx_dtx_sso_selx_s            cn75xx;
 	struct cvmx_dtx_sso_selx_s            cn78xx;
+	struct cvmx_dtx_sso_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_sso_selx cvmx_dtx_sso_selx_t;
 
@@ -7779,7 +8948,9 @@ union cvmx_dtx_tim_bcst_rsp {
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xxp1;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_tim_bcst_rsp cvmx_dtx_tim_bcst_rsp_t;
 
@@ -7808,7 +8979,9 @@ union cvmx_dtx_tim_ctl {
 	struct cvmx_dtx_tim_ctl_s             cn70xx;
 	struct cvmx_dtx_tim_ctl_s             cn70xxp1;
 	struct cvmx_dtx_tim_ctl_s             cn73xx;
+	struct cvmx_dtx_tim_ctl_s             cn75xx;
 	struct cvmx_dtx_tim_ctl_s             cn78xx;
+	struct cvmx_dtx_tim_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_tim_ctl cvmx_dtx_tim_ctl_t;
 
@@ -7830,7 +9003,9 @@ union cvmx_dtx_tim_datx {
 	struct cvmx_dtx_tim_datx_s            cn70xx;
 	struct cvmx_dtx_tim_datx_s            cn70xxp1;
 	struct cvmx_dtx_tim_datx_s            cn73xx;
+	struct cvmx_dtx_tim_datx_s            cn75xx;
 	struct cvmx_dtx_tim_datx_s            cn78xx;
+	struct cvmx_dtx_tim_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_tim_datx cvmx_dtx_tim_datx_t;
 
@@ -7852,7 +9027,9 @@ union cvmx_dtx_tim_enax {
 	struct cvmx_dtx_tim_enax_s            cn70xx;
 	struct cvmx_dtx_tim_enax_s            cn70xxp1;
 	struct cvmx_dtx_tim_enax_s            cn73xx;
+	struct cvmx_dtx_tim_enax_s            cn75xx;
 	struct cvmx_dtx_tim_enax_s            cn78xx;
+	struct cvmx_dtx_tim_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_tim_enax cvmx_dtx_tim_enax_t;
 
@@ -7873,7 +9050,9 @@ union cvmx_dtx_tim_selx {
 	struct cvmx_dtx_tim_selx_s            cn70xx;
 	struct cvmx_dtx_tim_selx_s            cn70xxp1;
 	struct cvmx_dtx_tim_selx_s            cn73xx;
+	struct cvmx_dtx_tim_selx_s            cn75xx;
 	struct cvmx_dtx_tim_selx_s            cn78xx;
+	struct cvmx_dtx_tim_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_tim_selx cvmx_dtx_tim_selx_t;
 
@@ -7894,6 +9073,7 @@ union cvmx_dtx_usbdrdx_bcst_rsp {
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xx;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xxp1;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn73xx;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn75xx;
 };
 typedef union cvmx_dtx_usbdrdx_bcst_rsp cvmx_dtx_usbdrdx_bcst_rsp_t;
 
@@ -7922,6 +9102,7 @@ union cvmx_dtx_usbdrdx_ctl {
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xx;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xxp1;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn73xx;
+	struct cvmx_dtx_usbdrdx_ctl_s         cn75xx;
 };
 typedef union cvmx_dtx_usbdrdx_ctl cvmx_dtx_usbdrdx_ctl_t;
 
@@ -7943,6 +9124,7 @@ union cvmx_dtx_usbdrdx_datx {
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xxp1;
 	struct cvmx_dtx_usbdrdx_datx_s        cn73xx;
+	struct cvmx_dtx_usbdrdx_datx_s        cn75xx;
 };
 typedef union cvmx_dtx_usbdrdx_datx cvmx_dtx_usbdrdx_datx_t;
 
@@ -7964,6 +9146,7 @@ union cvmx_dtx_usbdrdx_enax {
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xxp1;
 	struct cvmx_dtx_usbdrdx_enax_s        cn73xx;
+	struct cvmx_dtx_usbdrdx_enax_s        cn75xx;
 };
 typedef union cvmx_dtx_usbdrdx_enax cvmx_dtx_usbdrdx_enax_t;
 
@@ -7984,6 +9167,7 @@ union cvmx_dtx_usbdrdx_selx {
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xxp1;
 	struct cvmx_dtx_usbdrdx_selx_s        cn73xx;
+	struct cvmx_dtx_usbdrdx_selx_s        cn75xx;
 };
 typedef union cvmx_dtx_usbdrdx_selx cvmx_dtx_usbdrdx_selx_t;
 
@@ -8001,7 +9185,9 @@ union cvmx_dtx_usbhx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_bcst_rsp_s      cn75xx;
 	struct cvmx_dtx_usbhx_bcst_rsp_s      cn78xx;
+	struct cvmx_dtx_usbhx_bcst_rsp_s      cn78xxp2;
 };
 typedef union cvmx_dtx_usbhx_bcst_rsp cvmx_dtx_usbhx_bcst_rsp_t;
 
@@ -8027,7 +9213,9 @@ union cvmx_dtx_usbhx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_ctl_s           cn75xx;
 	struct cvmx_dtx_usbhx_ctl_s           cn78xx;
+	struct cvmx_dtx_usbhx_ctl_s           cn78xxp2;
 };
 typedef union cvmx_dtx_usbhx_ctl cvmx_dtx_usbhx_ctl_t;
 
@@ -8046,7 +9234,9 @@ union cvmx_dtx_usbhx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_datx_s          cn75xx;
 	struct cvmx_dtx_usbhx_datx_s          cn78xx;
+	struct cvmx_dtx_usbhx_datx_s          cn78xxp2;
 };
 typedef union cvmx_dtx_usbhx_datx cvmx_dtx_usbhx_datx_t;
 
@@ -8065,7 +9255,9 @@ union cvmx_dtx_usbhx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_enax_s          cn75xx;
 	struct cvmx_dtx_usbhx_enax_s          cn78xx;
+	struct cvmx_dtx_usbhx_enax_s          cn78xxp2;
 };
 typedef union cvmx_dtx_usbhx_enax cvmx_dtx_usbhx_enax_t;
 
@@ -8083,7 +9275,9 @@ union cvmx_dtx_usbhx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_selx_s          cn75xx;
 	struct cvmx_dtx_usbhx_selx_s          cn78xx;
+	struct cvmx_dtx_usbhx_selx_s          cn78xxp2;
 };
 typedef union cvmx_dtx_usbhx_selx cvmx_dtx_usbhx_selx_t;
 
@@ -8102,7 +9296,9 @@ union cvmx_dtx_zip_bcst_rsp {
 #endif
 	} s;
 	struct cvmx_dtx_zip_bcst_rsp_s        cn73xx;
+	struct cvmx_dtx_zip_bcst_rsp_s        cn75xx;
 	struct cvmx_dtx_zip_bcst_rsp_s        cn78xx;
+	struct cvmx_dtx_zip_bcst_rsp_s        cn78xxp2;
 };
 typedef union cvmx_dtx_zip_bcst_rsp cvmx_dtx_zip_bcst_rsp_t;
 
@@ -8129,7 +9325,9 @@ union cvmx_dtx_zip_ctl {
 #endif
 	} s;
 	struct cvmx_dtx_zip_ctl_s             cn73xx;
+	struct cvmx_dtx_zip_ctl_s             cn75xx;
 	struct cvmx_dtx_zip_ctl_s             cn78xx;
+	struct cvmx_dtx_zip_ctl_s             cn78xxp2;
 };
 typedef union cvmx_dtx_zip_ctl cvmx_dtx_zip_ctl_t;
 
@@ -8149,7 +9347,9 @@ union cvmx_dtx_zip_datx {
 #endif
 	} s;
 	struct cvmx_dtx_zip_datx_s            cn73xx;
+	struct cvmx_dtx_zip_datx_s            cn75xx;
 	struct cvmx_dtx_zip_datx_s            cn78xx;
+	struct cvmx_dtx_zip_datx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_zip_datx cvmx_dtx_zip_datx_t;
 
@@ -8169,7 +9369,9 @@ union cvmx_dtx_zip_enax {
 #endif
 	} s;
 	struct cvmx_dtx_zip_enax_s            cn73xx;
+	struct cvmx_dtx_zip_enax_s            cn75xx;
 	struct cvmx_dtx_zip_enax_s            cn78xx;
+	struct cvmx_dtx_zip_enax_s            cn78xxp2;
 };
 typedef union cvmx_dtx_zip_enax cvmx_dtx_zip_enax_t;
 
@@ -8188,7 +9390,9 @@ union cvmx_dtx_zip_selx {
 #endif
 	} s;
 	struct cvmx_dtx_zip_selx_s            cn73xx;
+	struct cvmx_dtx_zip_selx_s            cn75xx;
 	struct cvmx_dtx_zip_selx_s            cn78xx;
+	struct cvmx_dtx_zip_selx_s            cn78xxp2;
 };
 typedef union cvmx_dtx_zip_selx cvmx_dtx_zip_selx_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 9a203a2..f145ca0 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -66,6 +66,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			break;
 	}
@@ -85,6 +86,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001180028000458ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000458ull);
@@ -95,6 +97,7 @@ static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020100000ull) + ((offset) & 1023) * 8;
@@ -107,6 +110,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020200000ull) + ((offset) & 1023) * 8;
@@ -119,6 +123,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_ADD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020300000ull) + ((offset) & 1023) * 8;
@@ -131,6 +136,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020800000ull) + ((offset) & 1023) * 8;
@@ -143,6 +149,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LIMIT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020400000ull) + ((offset) & 1023) * 8;
@@ -155,6 +162,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_THRESHOLD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020500000ull) + ((offset) & 1023) * 8;
@@ -167,6 +175,7 @@ static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020600000ull) + ((offset) & 1023) * 8;
@@ -179,6 +188,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020000000ull) + ((offset) & 1023) * 8;
@@ -191,6 +201,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL_LEVELS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020700000ull) + ((offset) & 1023) * 8;
@@ -220,6 +231,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			break;
 	}
@@ -247,6 +259,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
@@ -256,7 +269,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 #define CVMX_FPA_CLK_COUNT CVMX_FPA_CLK_COUNT_FUNC()
 static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_CLK_COUNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00012800000000F0ull);
 }
@@ -268,7 +281,7 @@ static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 #define CVMX_FPA_ECC_CTL CVMX_FPA_ECC_CTL_FUNC()
 static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000058ull);
 }
@@ -279,7 +292,7 @@ static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 #define CVMX_FPA_ECC_INT CVMX_FPA_ECC_INT_FUNC()
 static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000068ull);
 }
@@ -290,7 +303,7 @@ static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 #define CVMX_FPA_ERR_INT CVMX_FPA_ERR_INT_FUNC()
 static inline uint64_t CVMX_FPA_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000040ull);
 }
@@ -390,7 +403,7 @@ static inline uint64_t CVMX_FPA_FPFX_SIZE(unsigned long offset)
 #define CVMX_FPA_GEN_CFG CVMX_FPA_GEN_CFG_FUNC()
 static inline uint64_t CVMX_FPA_GEN_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_GEN_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000050ull);
 }
@@ -415,6 +428,7 @@ static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_AVAILABLE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010300000ull) + ((offset) & 63) * 8;
@@ -427,6 +441,7 @@ static inline uint64_t CVMX_FPA_POOLX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010000000ull) + ((offset) & 63) * 8;
@@ -454,6 +469,7 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 31) * 8;
 			break;
@@ -475,6 +491,7 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000358ull) + (offset) * 8;
@@ -485,6 +502,7 @@ static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_FPF_MARKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010100000ull) + ((offset) & 63) * 8;
@@ -497,6 +515,7 @@ static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010A00000ull) + ((offset) & 63) * 8;
@@ -509,6 +528,7 @@ static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_OP_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010F00000ull) + ((offset) & 63) * 8;
@@ -521,6 +541,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010900000ull) + ((offset) & 63) * 8;
@@ -533,6 +554,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_BASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010700000ull) + ((offset) & 63) * 8;
@@ -545,6 +567,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_END(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_END(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010800000ull) + ((offset) & 63) * 8;
@@ -572,6 +595,7 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 31) * 8;
 			break;
@@ -593,6 +617,7 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000258ull) + (offset) * 8;
@@ -619,6 +644,7 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 31) * 8;
 			break;
@@ -641,6 +667,7 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000140ull) + (offset) * 8;
@@ -717,7 +744,7 @@ static inline uint64_t CVMX_FPA_QUEX_PAGE_INDEX(unsigned long offset)
 #define CVMX_FPA_RD_LATENCY_PC CVMX_FPA_RD_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000610ull);
 }
@@ -728,7 +755,7 @@ static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 #define CVMX_FPA_RD_REQ_PC CVMX_FPA_RD_REQ_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000600ull);
 }
@@ -739,7 +766,7 @@ static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 #define CVMX_FPA_RED_DELAY CVMX_FPA_RED_DELAY_FUNC()
 static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RED_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000100ull);
 }
@@ -750,7 +777,7 @@ static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 #define CVMX_FPA_SFT_RST CVMX_FPA_SFT_RST_FUNC()
 static inline uint64_t CVMX_FPA_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000000ull);
 }
@@ -835,7 +862,9 @@ union cvmx_fpa_addr_range_error {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} cn73xx;
+	struct cvmx_fpa_addr_range_error_cn73xx cn75xx;
 	struct cvmx_fpa_addr_range_error_cn73xx cn78xx;
+	struct cvmx_fpa_addr_range_error_cn73xx cn78xxp2;
 	struct cvmx_fpa_addr_range_error_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_addr_range_error cvmx_fpa_addr_range_error_t;
@@ -877,7 +906,9 @@ union cvmx_fpa_aurax_cfg {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cfg_s           cn73xx;
+	struct cvmx_fpa_aurax_cfg_s           cn75xx;
 	struct cvmx_fpa_aurax_cfg_s           cn78xx;
+	struct cvmx_fpa_aurax_cfg_s           cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cfg cvmx_fpa_aurax_cfg_t;
 
@@ -896,7 +927,9 @@ union cvmx_fpa_aurax_cnt {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_s           cn73xx;
+	struct cvmx_fpa_aurax_cnt_s           cn75xx;
 	struct cvmx_fpa_aurax_cnt_s           cn78xx;
+	struct cvmx_fpa_aurax_cnt_s           cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cnt cvmx_fpa_aurax_cnt_t;
 
@@ -921,7 +954,9 @@ union cvmx_fpa_aurax_cnt_add {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_add_s       cn73xx;
+	struct cvmx_fpa_aurax_cnt_add_s       cn75xx;
 	struct cvmx_fpa_aurax_cnt_add_s       cn78xx;
+	struct cvmx_fpa_aurax_cnt_add_s       cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cnt_add cvmx_fpa_aurax_cnt_add_t;
 
@@ -933,7 +968,8 @@ union cvmx_fpa_aurax_cnt_levels {
 	struct cvmx_fpa_aurax_cnt_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t drop_dis                     : 1;  /**< Reserved. */
+	uint64_t drop_dis                     : 1;  /**< Disable aura DROP based on the [DROP] level.
+                                                         Added in pass 2. */
 	uint64_t bp_ena                       : 1;  /**< Enable backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must be nonzero.
                                                          PKI_AURA()_CFG[ENA_BP] must also be set for backpressure to propagate through PKI. */
 	uint64_t red_ena                      : 1;  /**< Enable aura RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY] must be
@@ -973,7 +1009,9 @@ union cvmx_fpa_aurax_cnt_levels {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_levels_s    cn73xx;
+	struct cvmx_fpa_aurax_cnt_levels_s    cn75xx;
 	struct cvmx_fpa_aurax_cnt_levels_s    cn78xx;
+	struct cvmx_fpa_aurax_cnt_levels_s    cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cnt_levels cvmx_fpa_aurax_cnt_levels_t;
 
@@ -994,7 +1032,9 @@ union cvmx_fpa_aurax_cnt_limit {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_limit_s     cn73xx;
+	struct cvmx_fpa_aurax_cnt_limit_s     cn75xx;
 	struct cvmx_fpa_aurax_cnt_limit_s     cn78xx;
+	struct cvmx_fpa_aurax_cnt_limit_s     cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cnt_limit cvmx_fpa_aurax_cnt_limit_t;
 
@@ -1015,7 +1055,9 @@ union cvmx_fpa_aurax_cnt_threshold {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_threshold_s cn73xx;
+	struct cvmx_fpa_aurax_cnt_threshold_s cn75xx;
 	struct cvmx_fpa_aurax_cnt_threshold_s cn78xx;
+	struct cvmx_fpa_aurax_cnt_threshold_s cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_cnt_threshold cvmx_fpa_aurax_cnt_threshold_t;
 
@@ -1037,7 +1079,9 @@ union cvmx_fpa_aurax_int {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_int_s           cn73xx;
+	struct cvmx_fpa_aurax_int_s           cn75xx;
 	struct cvmx_fpa_aurax_int_s           cn78xx;
+	struct cvmx_fpa_aurax_int_s           cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_int cvmx_fpa_aurax_int_t;
 
@@ -1059,7 +1103,9 @@ union cvmx_fpa_aurax_pool {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_pool_s          cn73xx;
+	struct cvmx_fpa_aurax_pool_s          cn75xx;
 	struct cvmx_fpa_aurax_pool_s          cn78xx;
+	struct cvmx_fpa_aurax_pool_s          cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_pool cvmx_fpa_aurax_pool_t;
 
@@ -1071,7 +1117,8 @@ union cvmx_fpa_aurax_pool_levels {
 	struct cvmx_fpa_aurax_pool_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t drop_dis                     : 1;  /**< Reserved. */
+	uint64_t drop_dis                     : 1;  /**< Disables aura-unique pool DROP based on the [DROP] level.
+                                                         Added in pass 2. */
 	uint64_t bp_ena                       : 1;  /**< Enable aura-unique pool backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must
                                                          be nonzero. */
 	uint64_t red_ena                      : 1;  /**< Enable aura-unique pool RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY]
@@ -1117,7 +1164,9 @@ union cvmx_fpa_aurax_pool_levels {
 #endif
 	} s;
 	struct cvmx_fpa_aurax_pool_levels_s   cn73xx;
+	struct cvmx_fpa_aurax_pool_levels_s   cn75xx;
 	struct cvmx_fpa_aurax_pool_levels_s   cn78xx;
+	struct cvmx_fpa_aurax_pool_levels_s   cn78xxp2;
 };
 typedef union cvmx_fpa_aurax_pool_levels cvmx_fpa_aurax_pool_levels_t;
 
@@ -1180,7 +1229,9 @@ union cvmx_fpa_bist_status {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} cn73xx;
+	struct cvmx_fpa_bist_status_cn73xx    cn75xx;
 	struct cvmx_fpa_bist_status_cn73xx    cn78xx;
+	struct cvmx_fpa_bist_status_cn73xx    cn78xxp2;
 	struct cvmx_fpa_bist_status_cn30xx    cnf71xx;
 };
 typedef union cvmx_fpa_bist_status cvmx_fpa_bist_status_t;
@@ -1202,7 +1253,9 @@ union cvmx_fpa_clk_count {
 #endif
 	} s;
 	struct cvmx_fpa_clk_count_s           cn73xx;
+	struct cvmx_fpa_clk_count_s           cn75xx;
 	struct cvmx_fpa_clk_count_s           cn78xx;
+	struct cvmx_fpa_clk_count_s           cn78xxp2;
 };
 typedef union cvmx_fpa_clk_count cvmx_fpa_clk_count_t;
 
@@ -1329,7 +1382,9 @@ union cvmx_fpa_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_fpa_ecc_ctl_s             cn73xx;
+	struct cvmx_fpa_ecc_ctl_s             cn75xx;
 	struct cvmx_fpa_ecc_ctl_s             cn78xx;
+	struct cvmx_fpa_ecc_ctl_s             cn78xxp2;
 };
 typedef union cvmx_fpa_ecc_ctl cvmx_fpa_ecc_ctl_t;
 
@@ -1357,7 +1412,9 @@ union cvmx_fpa_ecc_int {
 #endif
 	} s;
 	struct cvmx_fpa_ecc_int_s             cn73xx;
+	struct cvmx_fpa_ecc_int_s             cn75xx;
 	struct cvmx_fpa_ecc_int_s             cn78xx;
+	struct cvmx_fpa_ecc_int_s             cn78xxp2;
 };
 typedef union cvmx_fpa_ecc_int cvmx_fpa_ecc_int_t;
 
@@ -1389,7 +1446,9 @@ union cvmx_fpa_err_int {
 #endif
 	} s;
 	struct cvmx_fpa_err_int_s             cn73xx;
+	struct cvmx_fpa_err_int_s             cn75xx;
 	struct cvmx_fpa_err_int_s             cn78xx;
+	struct cvmx_fpa_err_int_s             cn78xxp2;
 };
 typedef union cvmx_fpa_err_int cvmx_fpa_err_int_t;
 
@@ -1700,7 +1759,9 @@ union cvmx_fpa_gen_cfg {
 #endif
 	} s;
 	struct cvmx_fpa_gen_cfg_s             cn73xx;
+	struct cvmx_fpa_gen_cfg_s             cn75xx;
 	struct cvmx_fpa_gen_cfg_s             cn78xx;
+	struct cvmx_fpa_gen_cfg_s             cn78xxp2;
 };
 typedef union cvmx_fpa_gen_cfg cvmx_fpa_gen_cfg_t;
 
@@ -3243,7 +3304,9 @@ union cvmx_fpa_poolx_available {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_available_s     cn73xx;
+	struct cvmx_fpa_poolx_available_s     cn75xx;
 	struct cvmx_fpa_poolx_available_s     cn78xx;
+	struct cvmx_fpa_poolx_available_s     cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_available cvmx_fpa_poolx_available_t;
 
@@ -3293,7 +3356,9 @@ union cvmx_fpa_poolx_cfg {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_cfg_s           cn73xx;
+	struct cvmx_fpa_poolx_cfg_s           cn75xx;
 	struct cvmx_fpa_poolx_cfg_s           cn78xx;
+	struct cvmx_fpa_poolx_cfg_s           cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_cfg cvmx_fpa_poolx_cfg_t;
 
@@ -3337,7 +3402,9 @@ union cvmx_fpa_poolx_end_addr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} cn73xx;
+	struct cvmx_fpa_poolx_end_addr_cn73xx cn75xx;
 	struct cvmx_fpa_poolx_end_addr_cn73xx cn78xx;
+	struct cvmx_fpa_poolx_end_addr_cn73xx cn78xxp2;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_end_addr cvmx_fpa_poolx_end_addr_t;
@@ -3373,7 +3440,9 @@ union cvmx_fpa_poolx_fpf_marks {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_fpf_marks_s     cn73xx;
+	struct cvmx_fpa_poolx_fpf_marks_s     cn75xx;
 	struct cvmx_fpa_poolx_fpf_marks_s     cn78xx;
+	struct cvmx_fpa_poolx_fpf_marks_s     cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_fpf_marks cvmx_fpa_poolx_fpf_marks_t;
 
@@ -3407,7 +3476,9 @@ union cvmx_fpa_poolx_int {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_int_s           cn73xx;
+	struct cvmx_fpa_poolx_int_s           cn75xx;
 	struct cvmx_fpa_poolx_int_s           cn78xx;
+	struct cvmx_fpa_poolx_int_s           cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_int cvmx_fpa_poolx_int_t;
 
@@ -3424,7 +3495,9 @@ union cvmx_fpa_poolx_op_pc {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_op_pc_s         cn73xx;
+	struct cvmx_fpa_poolx_op_pc_s         cn75xx;
 	struct cvmx_fpa_poolx_op_pc_s         cn78xx;
+	struct cvmx_fpa_poolx_op_pc_s         cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_op_pc cvmx_fpa_poolx_op_pc_t;
 
@@ -3446,7 +3519,9 @@ union cvmx_fpa_poolx_stack_addr {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_stack_addr_s    cn73xx;
+	struct cvmx_fpa_poolx_stack_addr_s    cn75xx;
 	struct cvmx_fpa_poolx_stack_addr_s    cn78xx;
+	struct cvmx_fpa_poolx_stack_addr_s    cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_stack_addr cvmx_fpa_poolx_stack_addr_t;
 
@@ -3467,7 +3542,9 @@ union cvmx_fpa_poolx_stack_base {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_stack_base_s    cn73xx;
+	struct cvmx_fpa_poolx_stack_base_s    cn75xx;
 	struct cvmx_fpa_poolx_stack_base_s    cn78xx;
+	struct cvmx_fpa_poolx_stack_base_s    cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_stack_base cvmx_fpa_poolx_stack_base_t;
 
@@ -3489,7 +3566,9 @@ union cvmx_fpa_poolx_stack_end {
 #endif
 	} s;
 	struct cvmx_fpa_poolx_stack_end_s     cn73xx;
+	struct cvmx_fpa_poolx_stack_end_s     cn75xx;
 	struct cvmx_fpa_poolx_stack_end_s     cn78xx;
+	struct cvmx_fpa_poolx_stack_end_s     cn78xxp2;
 };
 typedef union cvmx_fpa_poolx_stack_end cvmx_fpa_poolx_stack_end_t;
 
@@ -3533,7 +3612,9 @@ union cvmx_fpa_poolx_start_addr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} cn73xx;
+	struct cvmx_fpa_poolx_start_addr_cn73xx cn75xx;
 	struct cvmx_fpa_poolx_start_addr_cn73xx cn78xx;
+	struct cvmx_fpa_poolx_start_addr_cn73xx cn78xxp2;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_start_addr cvmx_fpa_poolx_start_addr_t;
@@ -3581,7 +3662,9 @@ union cvmx_fpa_poolx_threshold {
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xxp1;
 	struct cvmx_fpa_poolx_threshold_s     cn73xx;
+	struct cvmx_fpa_poolx_threshold_s     cn75xx;
 	struct cvmx_fpa_poolx_threshold_s     cn78xx;
+	struct cvmx_fpa_poolx_threshold_s     cn78xxp2;
 	struct cvmx_fpa_poolx_threshold_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_threshold cvmx_fpa_poolx_threshold_t;
@@ -3801,7 +3884,9 @@ union cvmx_fpa_rd_latency_pc {
 #endif
 	} s;
 	struct cvmx_fpa_rd_latency_pc_s       cn73xx;
+	struct cvmx_fpa_rd_latency_pc_s       cn75xx;
 	struct cvmx_fpa_rd_latency_pc_s       cn78xx;
+	struct cvmx_fpa_rd_latency_pc_s       cn78xxp2;
 };
 typedef union cvmx_fpa_rd_latency_pc cvmx_fpa_rd_latency_pc_t;
 
@@ -3818,7 +3903,9 @@ union cvmx_fpa_rd_req_pc {
 #endif
 	} s;
 	struct cvmx_fpa_rd_req_pc_s           cn73xx;
+	struct cvmx_fpa_rd_req_pc_s           cn75xx;
 	struct cvmx_fpa_rd_req_pc_s           cn78xx;
+	struct cvmx_fpa_rd_req_pc_s           cn78xxp2;
 };
 typedef union cvmx_fpa_rd_req_pc cvmx_fpa_rd_req_pc_t;
 
@@ -3847,7 +3934,9 @@ union cvmx_fpa_red_delay {
 #endif
 	} s;
 	struct cvmx_fpa_red_delay_s           cn73xx;
+	struct cvmx_fpa_red_delay_s           cn75xx;
 	struct cvmx_fpa_red_delay_s           cn78xx;
+	struct cvmx_fpa_red_delay_s           cn78xxp2;
 };
 typedef union cvmx_fpa_red_delay cvmx_fpa_red_delay_t;
 
@@ -3874,7 +3963,9 @@ union cvmx_fpa_sft_rst {
 #endif
 	} s;
 	struct cvmx_fpa_sft_rst_s             cn73xx;
+	struct cvmx_fpa_sft_rst_s             cn75xx;
 	struct cvmx_fpa_sft_rst_s             cn78xx;
+	struct cvmx_fpa_sft_rst_s             cn78xxp2;
 };
 typedef union cvmx_fpa_sft_rst cvmx_fpa_sft_rst_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index e265bf3..18b85d2 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -42,7 +42,7 @@
  *
  * Interface to the CN78XX Free Pool Allocator, a.k.a. FPA3
  *
- * <hr>$Revision: 110934 $<hr>
+ * <hr>$Revision: 111763 $<hr>
  *
  */
 
@@ -255,6 +255,8 @@ static inline int cvmx_fpa3_num_pools(void)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 64;
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return 32;
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 32;
 	cvmx_printf("ERROR: %s: Unknowm model\n",__func__);
@@ -271,6 +273,8 @@ static inline int cvmx_fpa3_num_auras(void)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 1024;
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return 512;
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 512;
 	cvmx_printf("ERROR: %s: Unknowm model\n",__func__);
diff --git a/arch/mips/include/asm/octeon/cvmx-global-resources.h b/arch/mips/include/asm/octeon/cvmx-global-resources.h
index 60440f4..3e39f6b 100644
--- a/arch/mips/include/asm/octeon/cvmx-global-resources.h
+++ b/arch/mips/include/asm/octeon/cvmx-global-resources.h
@@ -11,6 +11,7 @@
 #define CVMX_GR_TAG_PKO_IPORTS cvmx_get_gr_tag('c','v','m','_','p','k','o','_','i','p','o','r','t','.','.','.')
 #define CVMX_GR_TAG_FPA        cvmx_get_gr_tag('c','v','m','_','f','p','a','.','.','.','.','.','.','.','.','.')
 #define CVMX_GR_TAG_FAU        cvmx_get_gr_tag('c','v','m','_','f','a','u','.','.','.','.','.','.','.','.','.')
+#define CVMX_GR_TAG_SSO_GRP(n) cvmx_get_gr_tag('c','v','m','_','s','s','o','_','0',(n)+'0','.','.','.','.','.','.');
 #define CVMX_GR_TAG_TIM(n)     cvmx_get_gr_tag('c','v','m','_','t','i','m','_',(n)+'0','.','.','.','.','.','.','.')
 #define CVMX_GR_TAG_CLUSTERS(x)	    cvmx_get_gr_tag('c','v','m','_','c','l','u','s','t','e','r','_',(x+'0'),'.','.','.')
 #define CVMX_GR_TAG_CLUSTER_GRP(x)  cvmx_get_gr_tag('c','v','m','_','c','l','g','r','p','_',(x+'0'),'.','.','.','.','.')
@@ -58,6 +59,11 @@ cvmx_get_gr_tag(char a, char b, char c, char d, char e, char f, char g, char h,
 	return tag;
 }
 
+static inline int cvmx_gr_same_tag(struct global_resource_tag gr1, struct global_resource_tag gr2)
+{
+	return (gr1.hi == gr2.hi) && (gr1.lo == gr2.lo);
+}
+
 /*
  * @INTERNAL
  * Creates a global resource range that can hold the specified number of
diff --git a/arch/mips/include/asm/octeon/cvmx-gmx.h b/arch/mips/include/asm/octeon/cvmx-gmx.h
index 6d8a600..35b87de 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmx.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmx.h
@@ -42,7 +42,7 @@
  *
  * Interface to the GMX hardware.
  *
- * <hr>$Revision: 109572 $<hr>
+ * <hr>$Revision: 112021 $<hr>
  */
 
 #ifndef __CVMX_GMX_H__
@@ -60,8 +60,6 @@ int cvmx_gmx_set_backpressure_override(uint32_t interface, uint32_t port_mask);
 
 int cvmx_agl_set_backpressure_override(uint32_t interface, uint32_t port_mask);
 
-int cvmx_bgx_set_backpressure_override(uint32_t xiface, uint32_t port_mask);
-
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index 6823819..f3f6b19 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -77,6 +77,7 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
 			break;
@@ -105,6 +106,7 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000800ull) + (offset) * 8;
@@ -133,6 +135,7 @@ static inline uint64_t CVMX_GPIO_CLK_GENX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_GPIO_CLK_GENX(%lu) is invalid on this chip\n", offset);
@@ -162,6 +165,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_CLK_SYNCEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010700000008E0ull) + ((offset) & 1) * 8;
@@ -173,7 +177,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 #define CVMX_GPIO_COMP CVMX_GPIO_COMP_FUNC()
 static inline uint64_t CVMX_GPIO_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000D00ull);
 }
@@ -196,6 +200,7 @@ static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_GPIO_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000A00ull) + ((offset) & 15) * 8;
@@ -209,6 +214,7 @@ static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset >= 4) && (offset <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 4) && (offset <= 7))))))
 		cvmx_warn("CVMX_GPIO_MC_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000C20ull) + ((offset) & 7) * 8 - 8*4;
@@ -220,7 +226,8 @@ static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 static inline uint64_t CVMX_GPIO_MC_INTRX_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset >= 4) && (offset <= 7))))))
 		cvmx_warn("CVMX_GPIO_MC_INTRX_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000E20ull) + ((offset) & 7) * 8 - 8*4;
 }
@@ -231,7 +238,7 @@ static inline uint64_t CVMX_GPIO_MC_INTRX_W1S(unsigned long offset)
 #define CVMX_GPIO_MULTI_CAST CVMX_GPIO_MULTI_CAST_FUNC()
 static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_GPIO_MULTI_CAST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B0ull);
 }
@@ -242,7 +249,7 @@ static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 #define CVMX_GPIO_OCLA_EXTEN_TRIG CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC()
 static inline uint64_t CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_OCLA_EXTEN_TRIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B8ull);
 }
@@ -276,7 +283,8 @@ static inline uint64_t CVMX_GPIO_SATA_CTL_FUNC(void)
 static inline uint64_t CVMX_GPIO_SATA_CTLX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_SATA_CTLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000D80ull) + ((offset) & 1) * 8;
 }
@@ -287,7 +295,7 @@ static inline uint64_t CVMX_GPIO_SATA_CTLX(unsigned long offset)
 #define CVMX_GPIO_SATA_LAB_LB CVMX_GPIO_SATA_LAB_LB_FUNC()
 static inline uint64_t CVMX_GPIO_SATA_LAB_LB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_GPIO_SATA_LAB_LB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000D40ull);
 }
@@ -298,7 +306,7 @@ static inline uint64_t CVMX_GPIO_SATA_LAB_LB_FUNC(void)
 #define CVMX_GPIO_TIM_CTL CVMX_GPIO_TIM_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 }
@@ -311,7 +319,8 @@ static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 static inline uint64_t CVMX_GPIO_USBDRD_CTLX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_USBDRD_CTLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000D20ull) + ((offset) & 1) * 8;
 }
@@ -510,7 +519,9 @@ union cvmx_gpio_bit_cfgx {
 	} cn70xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn70xxp1;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn73xx;
+	struct cvmx_gpio_bit_cfgx_cn70xx      cn75xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn78xx;
+	struct cvmx_gpio_bit_cfgx_cn70xx      cn78xxp2;
 	struct cvmx_gpio_bit_cfgx_cn61xx      cnf71xx;
 };
 typedef union cvmx_gpio_bit_cfgx cvmx_gpio_bit_cfgx_t;
@@ -568,7 +579,9 @@ union cvmx_gpio_clk_genx {
 	struct cvmx_gpio_clk_genx_s           cn70xx;
 	struct cvmx_gpio_clk_genx_s           cn70xxp1;
 	struct cvmx_gpio_clk_genx_s           cn73xx;
+	struct cvmx_gpio_clk_genx_s           cn75xx;
 	struct cvmx_gpio_clk_genx_s           cn78xx;
+	struct cvmx_gpio_clk_genx_s           cn78xxp2;
 	struct cvmx_gpio_clk_genx_s           cnf71xx;
 };
 typedef union cvmx_gpio_clk_genx cvmx_gpio_clk_genx_t;
@@ -749,7 +762,9 @@ union cvmx_gpio_clk_syncex {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} cn73xx;
+	struct cvmx_gpio_clk_syncex_cn73xx    cn75xx;
 	struct cvmx_gpio_clk_syncex_cn73xx    cn78xx;
+	struct cvmx_gpio_clk_syncex_cn73xx    cn78xxp2;
 };
 typedef union cvmx_gpio_clk_syncex cvmx_gpio_clk_syncex_t;
 
@@ -778,7 +793,9 @@ union cvmx_gpio_comp {
 #endif
 	} s;
 	struct cvmx_gpio_comp_s               cn73xx;
+	struct cvmx_gpio_comp_s               cn75xx;
 	struct cvmx_gpio_comp_s               cn78xx;
+	struct cvmx_gpio_comp_s               cn78xxp2;
 };
 typedef union cvmx_gpio_comp cvmx_gpio_comp_t;
 
@@ -856,7 +873,8 @@ union cvmx_gpio_intrx {
 	uint64_t intr_w1s                     : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to set, otherwise
                                                          will clear automatically when GPIO pin de-asserts. Read out value is INTR.
                                                          GPIO_INTR(4..7)[INTR_W1S] can also introduce GPIO_MC_INTR(4..7) when multicast mode is
-                                                         enabled. */
+                                                         enabled.
+                                                         Added in pass 2. */
 	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
                                                          will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
 #else
@@ -866,6 +884,7 @@ union cvmx_gpio_intrx {
 #endif
 	} s;
 	struct cvmx_gpio_intrx_s              cn73xx;
+	struct cvmx_gpio_intrx_s              cn75xx;
 	struct cvmx_gpio_intrx_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
@@ -876,6 +895,7 @@ union cvmx_gpio_intrx {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} cn78xx;
+	struct cvmx_gpio_intrx_s              cn78xxp2;
 };
 typedef union cvmx_gpio_intrx cvmx_gpio_intrx_t;
 
@@ -911,7 +931,9 @@ union cvmx_gpio_mc_intrx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_gpio_mc_intrx_cn73xx      cn75xx;
 	struct cvmx_gpio_mc_intrx_s           cn78xx;
+	struct cvmx_gpio_mc_intrx_s           cn78xxp2;
 };
 typedef union cvmx_gpio_mc_intrx cvmx_gpio_mc_intrx_t;
 
@@ -922,6 +944,18 @@ union cvmx_gpio_mc_intrx_w1s {
 	uint64_t u64;
 	struct cvmx_gpio_mc_intrx_w1s_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t intr                         : 48; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
+                                                         is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
+                                                         interrupt a different core using the CIU, and each core will then write one to clear its
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
+#else
+	uint64_t intr                         : 48;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_gpio_mc_intrx_w1s_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t intr                         : 16; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
                                                          is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
@@ -931,8 +965,9 @@ union cvmx_gpio_mc_intrx_w1s {
 	uint64_t intr                         : 16;
 	uint64_t reserved_16_63               : 48;
 #endif
-	} s;
-	struct cvmx_gpio_mc_intrx_w1s_s       cn73xx;
+	} cn73xx;
+	struct cvmx_gpio_mc_intrx_w1s_cn73xx  cn75xx;
+	struct cvmx_gpio_mc_intrx_w1s_s       cn78xxp2;
 };
 typedef union cvmx_gpio_mc_intrx_w1s cvmx_gpio_mc_intrx_w1s_t;
 
@@ -963,7 +998,9 @@ union cvmx_gpio_multi_cast {
 	struct cvmx_gpio_multi_cast_s         cn70xx;
 	struct cvmx_gpio_multi_cast_s         cn70xxp1;
 	struct cvmx_gpio_multi_cast_s         cn73xx;
+	struct cvmx_gpio_multi_cast_s         cn75xx;
 	struct cvmx_gpio_multi_cast_s         cn78xx;
+	struct cvmx_gpio_multi_cast_s         cn78xxp2;
 	struct cvmx_gpio_multi_cast_s         cnf71xx;
 };
 typedef union cvmx_gpio_multi_cast cvmx_gpio_multi_cast_t;
@@ -988,7 +1025,9 @@ union cvmx_gpio_ocla_exten_trig {
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xxp1;
 	struct cvmx_gpio_ocla_exten_trig_s    cn73xx;
+	struct cvmx_gpio_ocla_exten_trig_s    cn75xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn78xx;
+	struct cvmx_gpio_ocla_exten_trig_s    cn78xxp2;
 };
 typedef union cvmx_gpio_ocla_exten_trig cvmx_gpio_ocla_exten_trig_t;
 
@@ -1082,7 +1121,9 @@ union cvmx_gpio_rx_dat {
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xxp1;
 	struct cvmx_gpio_rx_dat_s             cn73xx;
+	struct cvmx_gpio_rx_dat_s             cn75xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn78xx;
+	struct cvmx_gpio_rx_dat_cn61xx        cn78xxp2;
 	struct cvmx_gpio_rx_dat_cn61xx        cnf71xx;
 };
 typedef union cvmx_gpio_rx_dat cvmx_gpio_rx_dat_t;
@@ -1150,6 +1191,7 @@ union cvmx_gpio_sata_ctlx {
 #endif
 	} s;
 	struct cvmx_gpio_sata_ctlx_s          cn73xx;
+	struct cvmx_gpio_sata_ctlx_s          cn75xx;
 };
 typedef union cvmx_gpio_sata_ctlx cvmx_gpio_sata_ctlx_t;
 
@@ -1169,6 +1211,7 @@ union cvmx_gpio_sata_lab_lb {
 #endif
 	} s;
 	struct cvmx_gpio_sata_lab_lb_s        cn73xx;
+	struct cvmx_gpio_sata_lab_lb_s        cn75xx;
 };
 typedef union cvmx_gpio_sata_lab_lb cvmx_gpio_sata_lab_lb_t;
 
@@ -1197,7 +1240,9 @@ union cvmx_gpio_tim_ctl {
 	} cn68xx;
 	struct cvmx_gpio_tim_ctl_cn68xx       cn68xxp1;
 	struct cvmx_gpio_tim_ctl_s            cn73xx;
+	struct cvmx_gpio_tim_ctl_s            cn75xx;
 	struct cvmx_gpio_tim_ctl_s            cn78xx;
+	struct cvmx_gpio_tim_ctl_s            cn78xxp2;
 };
 typedef union cvmx_gpio_tim_ctl cvmx_gpio_tim_ctl_t;
 
@@ -1263,7 +1308,9 @@ union cvmx_gpio_tx_clr {
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xxp1;
 	struct cvmx_gpio_tx_clr_s             cn73xx;
+	struct cvmx_gpio_tx_clr_s             cn75xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn78xx;
+	struct cvmx_gpio_tx_clr_cn61xx        cn78xxp2;
 	struct cvmx_gpio_tx_clr_cn61xx        cnf71xx;
 };
 typedef union cvmx_gpio_tx_clr cvmx_gpio_tx_clr_t;
@@ -1330,7 +1377,9 @@ union cvmx_gpio_tx_set {
 	struct cvmx_gpio_tx_set_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn70xxp1;
 	struct cvmx_gpio_tx_set_s             cn73xx;
+	struct cvmx_gpio_tx_set_s             cn75xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn78xx;
+	struct cvmx_gpio_tx_set_cn61xx        cn78xxp2;
 	struct cvmx_gpio_tx_set_cn61xx        cnf71xx;
 };
 typedef union cvmx_gpio_tx_set cvmx_gpio_tx_set_t;
@@ -1350,6 +1399,7 @@ union cvmx_gpio_usbdrd_ctlx {
 #endif
 	} s;
 	struct cvmx_gpio_usbdrd_ctlx_s        cn73xx;
+	struct cvmx_gpio_usbdrd_ctlx_s        cn75xx;
 };
 typedef union cvmx_gpio_usbdrd_ctlx cvmx_gpio_usbdrd_ctlx_t;
 
@@ -1396,6 +1446,7 @@ union cvmx_gpio_usbh_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} cn78xx;
+	struct cvmx_gpio_usbh_ctl_cn78xx      cn78xxp2;
 };
 typedef union cvmx_gpio_usbh_ctl cvmx_gpio_usbh_ctl_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 62f87b3..069ae9d 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_ANA_ATEST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((offset) & 15) * 0x1000000ull;
@@ -69,6 +70,7 @@ static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_ANA_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((offset) & 15) * 0x1000000ull;
@@ -81,6 +83,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000400ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -93,6 +96,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_EER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000418ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -105,6 +109,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000420ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -117,6 +122,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CUR(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000438ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -128,18 +134,20 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_TXX_TAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_TAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128;
+	return CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
 }
 #else
-#define CVMX_GSERX_BR_TXX_TAP(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128)
+#define CVMX_GSERX_BR_TXX_TAP(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((offset) & 15) * 0x1000000ull;
@@ -152,6 +160,7 @@ static inline uint64_t CVMX_GSERX_DBG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_DBG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((offset) & 15) * 0x1000000ull;
@@ -516,6 +525,7 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((offset) & 15) * 0x1000000ull;
@@ -528,6 +538,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((offset) & 15) * 0x1000000ull;
@@ -540,6 +551,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((offset) & 15) * 0x1000000ull;
@@ -552,6 +564,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TM_ADMON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((offset) & 15) * 0x1000000ull;
@@ -564,6 +577,7 @@ static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_IDDQ_MODE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((offset) & 15) * 0x1000000ull;
@@ -576,6 +590,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -588,6 +603,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_ECNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -600,6 +616,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_PAT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -612,6 +629,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -624,6 +642,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -636,6 +655,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -648,6 +668,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0068ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -660,6 +681,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0070ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -672,6 +694,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -684,6 +707,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -696,6 +720,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440280ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -708,6 +733,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440288ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -720,6 +746,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -732,6 +759,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440038ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -744,6 +772,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440040ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -756,6 +785,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440208ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -768,6 +798,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -780,6 +811,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -792,6 +824,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -804,6 +837,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -816,6 +850,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440010ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -828,6 +863,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -840,6 +876,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -852,6 +889,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -864,6 +902,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CTLE_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -876,6 +915,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_LOOP_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440048ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -888,6 +928,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_MISC_OVRRD(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -900,6 +941,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -912,6 +954,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_VAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440078ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -924,6 +967,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440240ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -936,6 +980,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440248ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -948,6 +993,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440250ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -960,6 +1006,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -972,6 +1019,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -984,6 +1032,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -995,40 +1044,44 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6))))))
 		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+	return CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
 #else
-#define CVMX_GSERX_LANEX_SDS_PIN_MON_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6))))))
 		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+	return CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
 #else
-#define CVMX_GSERX_LANEX_SDS_PIN_MON_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6))))))
 		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+	return CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
 #else
-#define CVMX_GSERX_LANEX_SDS_PIN_MON_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400A8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1041,6 +1094,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1053,6 +1107,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1065,6 +1120,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1077,6 +1133,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1089,6 +1146,7 @@ static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((offset) & 15) * 0x1000000ull;
@@ -1101,6 +1159,7 @@ static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((offset) & 15) * 0x1000000ull;
@@ -1113,6 +1172,7 @@ static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((offset) & 15) * 0x1000000ull;
@@ -1125,6 +1185,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0040ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1137,6 +1198,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1149,6 +1211,7 @@ static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((offset) & 15) * 0x1000000ull;
@@ -1161,6 +1224,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((offset) & 15) * 0x1000000ull;
@@ -1173,6 +1237,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((offset) & 15) * 0x1000000ull;
@@ -1185,6 +1250,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((offset) & 15) * 0x1000000ull;
@@ -1197,6 +1263,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((offset) & 15) * 0x1000000ull;
@@ -1209,6 +1276,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((offset) & 15) * 0x1000000ull;
@@ -1221,6 +1289,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((offset) & 15) * 0x1000000ull;
@@ -1607,6 +1676,7 @@ static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_PHY_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((offset) & 15) * 0x1000000ull;
@@ -1619,6 +1689,7 @@ static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_PIPE_LPBK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((offset) & 15) * 0x1000000ull;
@@ -1631,6 +1702,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0030ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1643,6 +1715,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0038ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1655,6 +1728,7 @@ static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_PLL_STAT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((offset) & 15) * 0x1000000ull;
@@ -1667,6 +1741,7 @@ static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_QLM_STAT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((offset) & 15) * 0x1000000ull;
@@ -1679,6 +1754,7 @@ static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RDET_TIME(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((offset) & 15) * 0x1000000ull;
@@ -1690,29 +1766,32 @@ static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long offset)
 static inline uint64_t CVMX_GSERX_REFCLK_EVT_CNTR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6)))))
 		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CNTR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 7) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_REFCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 7) * 0x1000000ull)
+#define CVMX_GSERX_REFCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_REFCLK_EVT_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6)))))
 		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CTRL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 7) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_REFCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 7) * 0x1000000ull)
+#define CVMX_GSERX_REFCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_REFCLK_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((offset) & 15) * 0x1000000ull;
@@ -1725,6 +1804,7 @@ static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_COAST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((offset) & 15) * 0x1000000ull;
@@ -1737,6 +1817,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((offset) & 15) * 0x1000000ull;
@@ -1749,6 +1830,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((offset) & 15) * 0x1000000ull;
@@ -1761,6 +1843,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_FILTER(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((offset) & 15) * 0x1000000ull;
@@ -1773,6 +1856,7 @@ static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_POLARITY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((offset) & 15) * 0x1000000ull;
@@ -1785,6 +1869,7 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((offset) & 15) * 0x1000000ull;
@@ -1797,6 +1882,7 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904600B8ull) + ((offset) & 15) * 0x1000000ull;
@@ -1819,7 +1905,8 @@ static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long offset)
 static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_AMPX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
 		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_AMPX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180090000B00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
 }
@@ -1830,7 +1917,8 @@ static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_AMPX(unsigned long a, unsigned l
 static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
 		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180090000A00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
 }
@@ -1846,6 +1934,7 @@ static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180090100210ull) + ((offset) & 0) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 6))
 				return CVMX_ADD_IO_SEG(0x0001180090000908ull) + ((offset) & 7) * 0x1000000ull;
 			break;
@@ -1860,6 +1949,7 @@ static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090100210ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (offset) * 0x1000000ull;
@@ -1973,6 +2063,7 @@ static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180090100200ull) + ((offset) & 0) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 6))
 				return CVMX_ADD_IO_SEG(0x0001180090100900ull) + ((offset) & 7) * 0x1000000ull;
 			break;
@@ -1987,6 +2078,7 @@ static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090100200ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (offset) * 0x1000000ull;
@@ -2001,6 +2093,7 @@ static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180090100220ull) + ((offset) & 0) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 6))
 				return CVMX_ADD_IO_SEG(0x0001180090000910ull) + ((offset) & 7) * 0x1000000ull;
 			break;
@@ -2015,6 +2108,7 @@ static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090100220ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (offset) * 0x1000000ull;
@@ -2025,6 +2119,7 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_SCRATCH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((offset) & 15) * 0x1000000ull;
@@ -2037,6 +2132,7 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_RX_SDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
@@ -2049,6 +2145,7 @@ static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_SLICE_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((offset) & 15) * 0x1000000ull;
@@ -2061,6 +2158,7 @@ static inline uint64_t CVMX_GSERX_SPD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_SPD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((offset) & 15) * 0x1000000ull;
@@ -2073,6 +2171,7 @@ static inline uint64_t CVMX_GSERX_SRST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_SRST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((offset) & 15) * 0x1000000ull;
@@ -2084,29 +2183,32 @@ static inline uint64_t CVMX_GSERX_SRST(unsigned long offset)
 static inline uint64_t CVMX_GSERX_TXCLK_EVT_CNTR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6)))))
 		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CNTR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 7) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_TXCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 7) * 0x1000000ull)
+#define CVMX_GSERX_TXCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_TXCLK_EVT_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6)))))
 		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CTRL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 7) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_TXCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 7) * 0x1000000ull)
+#define CVMX_GSERX_TXCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_TX_VBOOST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_GSERX_TX_VBOOST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((offset) & 15) * 0x1000000ull;
@@ -2138,7 +2240,9 @@ union cvmx_gserx_ana_atest {
 #endif
 	} s;
 	struct cvmx_gserx_ana_atest_s         cn73xx;
+	struct cvmx_gserx_ana_atest_s         cn75xx;
 	struct cvmx_gserx_ana_atest_s         cn78xx;
+	struct cvmx_gserx_ana_atest_s         cn78xxp2;
 };
 typedef union cvmx_gserx_ana_atest cvmx_gserx_ana_atest_t;
 
@@ -2160,7 +2264,9 @@ union cvmx_gserx_ana_sel {
 #endif
 	} s;
 	struct cvmx_gserx_ana_sel_s           cn73xx;
+	struct cvmx_gserx_ana_sel_s           cn75xx;
 	struct cvmx_gserx_ana_sel_s           cn78xx;
+	struct cvmx_gserx_ana_sel_s           cn78xxp2;
 };
 typedef union cvmx_gserx_ana_sel cvmx_gserx_ana_sel_t;
 
@@ -2171,7 +2277,15 @@ union cvmx_gserx_br_rxx_ctl {
 	uint64_t u64;
 	struct cvmx_gserx_br_rxx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
+	uint64_t reserved_4_63                : 60;
+	uint64_t rxt_adtmout_disable          : 1;  /**< For Base-R links the terminating condition for link training receiver adaptation
+                                                         is a 330 milliseconds time-out timer.  When the receiver adaptation time-out timer
+                                                         expires the receiver adaptation process is concluded and the link is considered good.
+                                                         Note that when Base-R link training is performed under software control,
+                                                         (GSER()_BR_RX()_CTL[RXT_SWM] is set), the receiver adaptation time-out timer is disabled
+                                                         and not used.
+                                                         Set this bit to a one to disable the link training receiver adaptation time-out
+                                                         timer during Base-R link training under hardware control.  For diagnostic use only. */
 	uint64_t rxt_swm                      : 1;  /**< Set when RX Base-R Link Training is to be performed under software control. For diagnostic
                                                          use only. */
 	uint64_t rxt_preset                   : 1;  /**< For all link training, this bit determines how to configure the preset bit in the
@@ -2192,11 +2306,39 @@ union cvmx_gserx_br_rxx_ctl {
 	uint64_t rxt_initialize               : 1;
 	uint64_t rxt_preset                   : 1;
 	uint64_t rxt_swm                      : 1;
-	uint64_t reserved_3_63                : 61;
+	uint64_t rxt_adtmout_disable          : 1;
+	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
 	struct cvmx_gserx_br_rxx_ctl_s        cn73xx;
-	struct cvmx_gserx_br_rxx_ctl_s        cn78xx;
+	struct cvmx_gserx_br_rxx_ctl_s        cn75xx;
+	struct cvmx_gserx_br_rxx_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t rxt_swm                      : 1;  /**< Set when RX Base-R Link Training is to be performed under software control. For diagnostic
+                                                         use only. */
+	uint64_t rxt_preset                   : 1;  /**< For all link training, this bit determines how to configure the preset bit in the
+                                                         coefficient update message that is sent to the far end transmitter. When set, a one time
+                                                         request is made that the coefficients be set to a state where equalization is turned off.
+                                                         To perform a preset, set this bit prior to link training. Link training needs to be
+                                                         disabled to complete the request and get the rxtrain state machine back to idle. Note that
+                                                         it is illegal to set both the preset and initialize bits at the same time. For diagnostic
+                                                         use only. */
+	uint64_t rxt_initialize               : 1;  /**< For all link training, this bit determines how to configure the initialize bit in the
+                                                         coefficient update message that is sent to the far end transmitter of RX training. When
+                                                         set, a request is made that the coefficients be set to its INITIALIZE state. To perform an
+                                                         initialize prior to link training, set this bit prior to performing link training. Note
+                                                         that it is illegal to set both the preset and initialize bits at the same time. Since the
+                                                         far end transmitter is required to be initialized prior to starting link training, it is
+                                                         not expected that software will need to set this bit. For diagnostic use only. */
+#else
+	uint64_t rxt_initialize               : 1;
+	uint64_t rxt_preset                   : 1;
+	uint64_t rxt_swm                      : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} cn78xx;
+	struct cvmx_gserx_br_rxx_ctl_cn78xx   cn78xxp2;
 };
 typedef union cvmx_gserx_br_rxx_ctl cvmx_gserx_br_rxx_ctl_t;
 
@@ -2241,7 +2383,9 @@ union cvmx_gserx_br_rxx_eer {
 #endif
 	} s;
 	struct cvmx_gserx_br_rxx_eer_s        cn73xx;
+	struct cvmx_gserx_br_rxx_eer_s        cn75xx;
 	struct cvmx_gserx_br_rxx_eer_s        cn78xx;
+	struct cvmx_gserx_br_rxx_eer_s        cn78xxp2;
 };
 typedef union cvmx_gserx_br_rxx_eer cvmx_gserx_br_rxx_eer_t;
 
@@ -2261,7 +2405,9 @@ union cvmx_gserx_br_txx_ctl {
 #endif
 	} s;
 	struct cvmx_gserx_br_txx_ctl_s        cn73xx;
+	struct cvmx_gserx_br_txx_ctl_s        cn75xx;
 	struct cvmx_gserx_br_txx_ctl_s        cn78xx;
+	struct cvmx_gserx_br_txx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_gserx_br_txx_ctl cvmx_gserx_br_txx_ctl_t;
 
@@ -2286,12 +2432,17 @@ union cvmx_gserx_br_txx_cur {
 #endif
 	} s;
 	struct cvmx_gserx_br_txx_cur_s        cn73xx;
+	struct cvmx_gserx_br_txx_cur_s        cn75xx;
 	struct cvmx_gserx_br_txx_cur_s        cn78xx;
+	struct cvmx_gserx_br_txx_cur_s        cn78xxp2;
 };
 typedef union cvmx_gserx_br_txx_cur cvmx_gserx_br_txx_cur_t;
 
 /**
  * cvmx_gser#_br_tx#_tap
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_gserx_br_txx_tap {
 	uint64_t u64;
@@ -2318,6 +2469,8 @@ union cvmx_gserx_br_txx_tap {
 #endif
 	} s;
 	struct cvmx_gserx_br_txx_tap_s        cn73xx;
+	struct cvmx_gserx_br_txx_tap_s        cn75xx;
+	struct cvmx_gserx_br_txx_tap_s        cn78xxp2;
 };
 typedef union cvmx_gserx_br_txx_tap cvmx_gserx_br_txx_tap_t;
 
@@ -2355,6 +2508,7 @@ union cvmx_gserx_cfg {
 #endif
 	} s;
 	struct cvmx_gserx_cfg_s               cn73xx;
+	struct cvmx_gserx_cfg_s               cn75xx;
 	struct cvmx_gserx_cfg_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
@@ -2380,6 +2534,7 @@ union cvmx_gserx_cfg {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} cn78xx;
+	struct cvmx_gserx_cfg_cn78xx          cn78xxp2;
 };
 typedef union cvmx_gserx_cfg cvmx_gserx_cfg_t;
 
@@ -2399,7 +2554,9 @@ union cvmx_gserx_dbg {
 #endif
 	} s;
 	struct cvmx_gserx_dbg_s               cn73xx;
+	struct cvmx_gserx_dbg_s               cn75xx;
 	struct cvmx_gserx_dbg_s               cn78xx;
+	struct cvmx_gserx_dbg_s               cn78xxp2;
 };
 typedef union cvmx_gserx_dbg cvmx_gserx_dbg_t;
 
@@ -3283,7 +3440,9 @@ union cvmx_gserx_eq_wait_time {
 #endif
 	} s;
 	struct cvmx_gserx_eq_wait_time_s      cn73xx;
+	struct cvmx_gserx_eq_wait_time_s      cn75xx;
 	struct cvmx_gserx_eq_wait_time_s      cn78xx;
+	struct cvmx_gserx_eq_wait_time_s      cn78xxp2;
 };
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
 
@@ -3317,7 +3476,9 @@ union cvmx_gserx_glbl_pll_monitor {
 #endif
 	} s;
 	struct cvmx_gserx_glbl_pll_monitor_s  cn73xx;
+	struct cvmx_gserx_glbl_pll_monitor_s  cn75xx;
 	struct cvmx_gserx_glbl_pll_monitor_s  cn78xx;
+	struct cvmx_gserx_glbl_pll_monitor_s  cn78xxp2;
 };
 typedef union cvmx_gserx_glbl_pll_monitor cvmx_gserx_glbl_pll_monitor_t;
 
@@ -3386,7 +3547,9 @@ union cvmx_gserx_glbl_tad {
 #endif
 	} s;
 	struct cvmx_gserx_glbl_tad_s          cn73xx;
+	struct cvmx_gserx_glbl_tad_s          cn75xx;
 	struct cvmx_gserx_glbl_tad_s          cn78xx;
+	struct cvmx_gserx_glbl_tad_s          cn78xxp2;
 };
 typedef union cvmx_gserx_glbl_tad cvmx_gserx_glbl_tad_t;
 
@@ -3419,8 +3582,29 @@ union cvmx_gserx_glbl_tm_admon {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
-	struct cvmx_gserx_glbl_tm_admon_s     cn73xx;
+	struct cvmx_gserx_glbl_tm_admon_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t amon_on                      : 1;  /**< When set, AMON test mode is enabled; see GSER()_GLBL_TAD. */
+	uint64_t dmon_on                      : 1;  /**< When set, DMON test mode is enabled; see GSER()_GLBL_TAD. */
+	uint64_t reserved_5_3                 : 3;
+	uint64_t lsel                         : 3;  /**< Three bits to select 1 out of 4 lanes for AMON/DMON test.
+                                                         0x0 = Selects lane 0.
+                                                         0x1 = Selects lane 1.
+                                                         0x2 = Selects lane 2.  Lane 2 is unused in GSER4, GSER5, and GSER6.
+                                                         0x3 = Selects lane 3.  Lane 3 is unused in GSER4, GSER5, and GSER6.
+                                                         0x4-0x7 = Reserved. */
+#else
+	uint64_t lsel                         : 3;
+	uint64_t reserved_5_3                 : 3;
+	uint64_t dmon_on                      : 1;
+	uint64_t amon_on                      : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_glbl_tm_admon_cn73xx cn75xx;
 	struct cvmx_gserx_glbl_tm_admon_s     cn78xx;
+	struct cvmx_gserx_glbl_tm_admon_s     cn78xxp2;
 };
 typedef union cvmx_gserx_glbl_tm_admon cvmx_gserx_glbl_tm_admon_t;
 
@@ -3442,7 +3626,9 @@ union cvmx_gserx_iddq_mode {
 #endif
 	} s;
 	struct cvmx_gserx_iddq_mode_s         cn73xx;
+	struct cvmx_gserx_iddq_mode_s         cn75xx;
 	struct cvmx_gserx_iddq_mode_s         cn78xx;
+	struct cvmx_gserx_iddq_mode_s         cn78xxp2;
 };
 typedef union cvmx_gserx_iddq_mode cvmx_gserx_iddq_mode_t;
 
@@ -3517,7 +3703,9 @@ union cvmx_gserx_lanex_lbert_cfg {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_lbert_cfg_s   cn73xx;
+	struct cvmx_gserx_lanex_lbert_cfg_s   cn75xx;
 	struct cvmx_gserx_lanex_lbert_cfg_s   cn78xx;
+	struct cvmx_gserx_lanex_lbert_cfg_s   cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_lbert_cfg cvmx_gserx_lanex_lbert_cfg_t;
 
@@ -3548,7 +3736,9 @@ union cvmx_gserx_lanex_lbert_ecnt {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_lbert_ecnt_s  cn73xx;
+	struct cvmx_gserx_lanex_lbert_ecnt_s  cn75xx;
 	struct cvmx_gserx_lanex_lbert_ecnt_s  cn78xx;
+	struct cvmx_gserx_lanex_lbert_ecnt_s  cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_lbert_ecnt cvmx_gserx_lanex_lbert_ecnt_t;
 
@@ -3572,7 +3762,9 @@ union cvmx_gserx_lanex_lbert_pat_cfg {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn73xx;
+	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn75xx;
 	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn78xx;
+	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_lbert_pat_cfg cvmx_gserx_lanex_lbert_pat_cfg_t;
 
@@ -3619,7 +3811,9 @@ union cvmx_gserx_lanex_misc_cfg_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_misc_cfg_0_s  cn73xx;
+	struct cvmx_gserx_lanex_misc_cfg_0_s  cn75xx;
 	struct cvmx_gserx_lanex_misc_cfg_0_s  cn78xx;
+	struct cvmx_gserx_lanex_misc_cfg_0_s  cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_0 cvmx_gserx_lanex_misc_cfg_0_t;
 
@@ -3682,7 +3876,9 @@ union cvmx_gserx_lanex_misc_cfg_1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} cn73xx;
+	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn78xx;
+	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_1 cvmx_gserx_lanex_misc_cfg_1_t;
 
@@ -3734,7 +3930,9 @@ union cvmx_gserx_lanex_pcs_ctlifc_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn73xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn75xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn78xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_0 cvmx_gserx_lanex_pcs_ctlifc_0_t;
 
@@ -3766,8 +3964,28 @@ union cvmx_gserx_lanex_pcs_ctlifc_1 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn73xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;  /**< Override RX pstate request when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
+	uint64_t reserved_6_2                 : 5;
+	uint64_t cfg_rx_mode_ovrrd_val        : 2;  /**< Override PCS RX mode (data width) when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_MODE_OVRRD_EN].
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+#else
+	uint64_t cfg_rx_mode_ovrrd_val        : 2;
+	uint64_t reserved_6_2                 : 5;
+	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
 
@@ -3828,8 +4046,57 @@ union cvmx_gserx_lanex_pcs_ctlifc_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn73xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t ctlifc_ovrrd_req             : 1;  /**< Writing to set this bit initiates a state machine interface request
+                                                         for GSER()_LANE()_PCS_CTLIFC_0 and GSER()_LANE()_PCS_CTLIFC_1
+                                                         override values. */
+	uint64_t reserved_14_9                : 6;
+	uint64_t cfg_tx_vboost_en_ovrrd_en    : 1;  /**< Override mac_pcs_txX vboost_en signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_VAL]. */
+	uint64_t cfg_tx_coeff_req_ovrrd_en    : 1;  /**< Override mac_pcs_txX_coeff_req signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_0[CFG_TX_COEFF_REQ_OVRRD_VAL]. */
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_en : 1; /**< Override mac_pcs_rxX_cdr_coast signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_VAL]. */
+	uint64_t cfg_tx_detrx_en_req_ovrrd_en : 1;  /**< Override mac_pcs_txX_detrx_en signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_VAL]. */
+	uint64_t cfg_soft_reset_req_ovrrd_en  : 1;  /**< Override mac_pcs_laneX_soft_rst signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_VAL]. */
+	uint64_t cfg_lane_pwr_off_ovrrd_en    : 1;  /**< Override mac_pcs_laneX_pwr_off signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_VAL]. */
+	uint64_t cfg_tx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_txX_pstate[1:0] signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_VAL].
+                                                         When using this field to change the TX Power State, you must also set
+                                                         the override enable bits for the lane_mode, soft_reset and lane_pwr_off
+                                                         fields.  The corresponding orrd_val fields should be programmed so as
+                                                         not to cause undesired changes. */
+	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_rxX_pstate[1:0] signal with the value specified in
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_PSTATE_REQ_OVRRD_VAL].
+                                                         When using this field to change the RX Power State, you must also set
+                                                         the override enable bits for the lane_mode, soft_reset and lane_pwr_off
+                                                         fields.  The corresponding orrd_val fields should be programmed so as
+                                                         not to cause undesired changes. */
+	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;  /**< Override mac_pcs_laneX_mode[3:0] signal with the value specified in
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_VAL]. */
+#else
+	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;
+	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;
+	uint64_t cfg_tx_pstate_req_ovrrd_en   : 1;
+	uint64_t cfg_lane_pwr_off_ovrrd_en    : 1;
+	uint64_t cfg_soft_reset_req_ovrrd_en  : 1;
+	uint64_t cfg_tx_detrx_en_req_ovrrd_en : 1;
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_en : 1;
+	uint64_t cfg_tx_coeff_req_ovrrd_en    : 1;
+	uint64_t cfg_tx_vboost_en_ovrrd_en    : 1;
+	uint64_t reserved_14_9                : 6;
+	uint64_t ctlifc_ovrrd_req             : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
 
@@ -3854,7 +4121,9 @@ union cvmx_gserx_lanex_pma_loopback_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn73xx;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn75xx;
 	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn78xx;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_ctrl_t;
 
@@ -3931,8 +4200,73 @@ union cvmx_gserx_lanex_pwr_ctrl {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_pwr_ctrl_s    cn73xx;
+	struct cvmx_gserx_lanex_pwr_ctrl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t tx_sds_fifo_reset_ovrrd_en   : 1;  /**< When asserted, TX_SDS_FIFO_RESET_OVVRD_VAL is used to specify the value of the reset
+                                                         signal for the TX FIFO supplying data to the SerDes p2s interface. */
+	uint64_t tx_sds_fifo_reset_ovrrd_val  : 1;  /**< When asserted, TX_SDS_FIFO_RESET_OVVRD_EN is asserted, this field is
+                                                         used to specify the value of the reset
+                                                         signal for the TX FIFO supplying data to the SerDes p2s interface. */
+	uint64_t tx_pcs_reset_ovrrd_val       : 1;  /**< When TX_PCS_RESET_OVRRD_EN is
+                                                         asserted, this field is used to specify the value of
+                                                         the reset signal for PCS TX logic. */
+	uint64_t rx_pcs_reset_ovrrd_val       : 1;  /**< When RX_PCS_RESET_OVRRD_EN is
+                                                         asserted, this field is used to specify the value of
+                                                         the reset signal for PCS RX logic. */
+	uint64_t reserved_10_9                : 2;
+	uint64_t rx_resetn_ovrrd_en           : 1;  /**< Override RX Power State machine rx_resetn
+                                                         control signal.  When set, the rx_resetn control signal is taken
+                                                         from the GSER()_LANE()_RX_CFG_0[RX_RESETN_OVRRD_VAL]
+                                                         control bit. */
+	uint64_t rx_resetn_ovrrd_val          : 1;  /**< Override RX Power State machine reset control
+                                                         signal. When set, reset control signals are specified in
+                                                         [RX_PCS_RESET_OVRRD_VAL]. */
+	uint64_t rx_lctrl_ovrrd_en            : 1;  /**< Override RX Power State machine loop control
+                                                         signals.  When set, the loop control settings are
+                                                         specified in the GSER()_LANE()_RX_LOOP_CTRL[CFG_RX_LCTRL] field. */
+	uint64_t rx_lctrl_ovrrd_val           : 1;  /**< Override RX Power State machine power down
+                                                         control signal. When set, the power down control signal is
+                                                         specified by GSER()_LANE()_RX_CFG_1[RX_CHPD_OVRRD_VAL]. */
+	uint64_t tx_tristate_en_ovrrd_en      : 1;  /**< Override TX Power State machine TX tristate
+                                                         control signal.  When set, TX tristate control signal is specified
+                                                         in GSER()_LANE()_TX_CFG_0[TX_TRISTATE_EN_OVRRD_VAL]. */
+	uint64_t tx_pcs_reset_ovrrd_en        : 1;  /**< Override TX Power State machine reset control
+                                                         signal.  When set, reset control signals is specified in
+                                                         [TX_PCS_RESET_OVRRD_VAL]. */
+	uint64_t tx_elec_idle_ovrrd_en        : 1;  /**< Override mac_pcs_txX_elec_idle signal
+                                                         When set, TX electrical idle is controlled from
+                                                         GSER()_LANE()_TX_CFG_1[TX_ELEC_IDLE_OVRRD_VAL]
+                                                         mac_pcs_txX_elec_idle signal is ignored. */
+	uint64_t tx_pd_ovrrd_en               : 1;  /**< Override TX Power State machine TX lane
+                                                         power-down control signal
+                                                         When set, TX lane power down is controlled by
+                                                         GSER()_LANE()_TX_CFG_0[TX_CHPD_OVRRD_VAL]. */
+	uint64_t tx_p2s_resetn_ovrrd_en       : 1;  /**< Override TX Power State machine TX reset
+                                                         control signal
+                                                         When set, TX reset is controlled by
+                                                         GSER()_LANE()_TX_CFG_0[TX_RESETN_OVRRD_VAL]. */
+#else
+	uint64_t tx_p2s_resetn_ovrrd_en       : 1;
+	uint64_t tx_pd_ovrrd_en               : 1;
+	uint64_t tx_elec_idle_ovrrd_en        : 1;
+	uint64_t tx_pcs_reset_ovrrd_en        : 1;
+	uint64_t tx_tristate_en_ovrrd_en      : 1;
+	uint64_t rx_lctrl_ovrrd_val           : 1;
+	uint64_t rx_lctrl_ovrrd_en            : 1;
+	uint64_t rx_resetn_ovrrd_val          : 1;
+	uint64_t rx_resetn_ovrrd_en           : 1;
+	uint64_t reserved_10_9                : 2;
+	uint64_t rx_pcs_reset_ovrrd_val       : 1;
+	uint64_t tx_pcs_reset_ovrrd_val       : 1;
+	uint64_t tx_sds_fifo_reset_ovrrd_val  : 1;
+	uint64_t tx_sds_fifo_reset_ovrrd_en   : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_pwr_ctrl_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xx;
+	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
 
@@ -3956,7 +4290,9 @@ union cvmx_gserx_lanex_rx_aeq_out_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn73xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn75xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn78xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_0 cvmx_gserx_lanex_rx_aeq_out_0_t;
 
@@ -3981,7 +4317,9 @@ union cvmx_gserx_lanex_rx_aeq_out_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn75xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_1 cvmx_gserx_lanex_rx_aeq_out_1_t;
 
@@ -4006,7 +4344,9 @@ union cvmx_gserx_lanex_rx_aeq_out_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn75xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn78xx;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
 
@@ -4035,7 +4375,9 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn75xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_1 cvmx_gserx_lanex_rx_cdr_ctrl_1_t;
 
@@ -4063,7 +4405,9 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn75xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn78xx;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_2 cvmx_gserx_lanex_rx_cdr_ctrl_2_t;
 
@@ -4091,7 +4435,9 @@ union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn73xx;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn75xx;
 	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_t;
 
@@ -4117,7 +4463,9 @@ union cvmx_gserx_lanex_rx_cdr_status_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn75xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_1 cvmx_gserx_lanex_rx_cdr_status_1_t;
 
@@ -4142,7 +4490,9 @@ union cvmx_gserx_lanex_rx_cdr_status_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn75xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn78xx;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_2 cvmx_gserx_lanex_rx_cdr_status_2_t;
 
@@ -4225,6 +4575,7 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -4260,6 +4611,7 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn78xx cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_0 cvmx_gserx_lanex_rx_cfg_0_t;
 
@@ -4306,7 +4658,9 @@ union cvmx_gserx_lanex_rx_cfg_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cfg_1_s    cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_1_s    cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_1_s    cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_1_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_1 cvmx_gserx_lanex_rx_cfg_1_t;
 
@@ -4349,7 +4703,9 @@ union cvmx_gserx_lanex_rx_cfg_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cfg_2_s    cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_2_s    cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_2_s    cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_2_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_2 cvmx_gserx_lanex_rx_cfg_2_t;
 
@@ -4385,7 +4741,9 @@ union cvmx_gserx_lanex_rx_cfg_3 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cfg_3_s    cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_3_s    cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_3_s    cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_3_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_3 cvmx_gserx_lanex_rx_cfg_3_t;
 
@@ -4421,7 +4779,9 @@ union cvmx_gserx_lanex_rx_cfg_4 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cfg_4_s    cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_4_s    cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_4_s    cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_4_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_4 cvmx_gserx_lanex_rx_cfg_4_t;
 
@@ -4454,7 +4814,9 @@ union cvmx_gserx_lanex_rx_cfg_5 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_cfg_5_s    cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_5_s    cn75xx;
 	struct cvmx_gserx_lanex_rx_cfg_5_s    cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_5_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_5 cvmx_gserx_lanex_rx_cfg_5_t;
 
@@ -4501,7 +4863,9 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn73xx;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn75xx;
 	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn78xx;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
 
@@ -4538,7 +4902,9 @@ union cvmx_gserx_lanex_rx_loop_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn73xx;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn75xx;
 	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn78xx;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_loop_ctrl cvmx_gserx_lanex_rx_loop_ctrl_t;
 
@@ -4592,7 +4958,48 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn73xx;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;  /**< Override value for RX OOB Clock Enable. */
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;  /**< Override enable for RX OOB Clock Enable. */
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;  /**< Override value for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Not supported. */
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;  /**< Training mode control in override mode. */
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;  /**< Override enable for RX-EQ Eval
+                                                         When asserted, training mode is controlled by
+                                                         CFG_RX_EQ_EVAL_OVRRD_VAL. */
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;  /**< When asserted, override DLL lock enable
+                                                         signal from the RX Power State machine with
+                                                         CFG_RX_DLL_LOCKEN in register
+                                                         GSER()_LANE()_RX_CFG_1. */
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
+                                                         to cfg_rx_errdet_ctrl in registers
+                                                         GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
+	uint64_t reserved_3_1                 : 3;
+	uint64_t cfg_rxeq_eval_restore_en     : 1;  /**< When asserted, AGC and CTLE use the RX EQ settings determined from RX EQ
+                                                         evaluation process when VMA is not in manual mode. Otherwise, default settings are used. */
+#else
+	uint64_t cfg_rxeq_eval_restore_en     : 1;
+	uint64_t reserved_3_1                 : 3;
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
@@ -4631,6 +5038,7 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} cn78xx;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
 
@@ -4664,7 +5072,9 @@ union cvmx_gserx_lanex_rx_precorr_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn73xx;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn75xx;
 	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn78xx;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_t;
 
@@ -4690,7 +5100,9 @@ union cvmx_gserx_lanex_rx_precorr_val {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_precorr_val_s cn73xx;
+	struct cvmx_gserx_lanex_rx_precorr_val_s cn75xx;
 	struct cvmx_gserx_lanex_rx_precorr_val_s cn78xx;
+	struct cvmx_gserx_lanex_rx_precorr_val_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_val cvmx_gserx_lanex_rx_precorr_val_t;
 
@@ -4726,7 +5138,9 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn73xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn75xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_0 cvmx_gserx_lanex_rx_valbbd_ctrl_0_t;
 
@@ -4769,7 +5183,9 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn75xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_1 cvmx_gserx_lanex_rx_valbbd_ctrl_1_t;
 
@@ -4821,7 +5237,9 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn75xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn78xx;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_2 cvmx_gserx_lanex_rx_valbbd_ctrl_2_t;
 
@@ -4862,7 +5280,9 @@ union cvmx_gserx_lanex_rx_vma_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn73xx;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn75xx;
 	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn78xx;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
 
@@ -4888,7 +5308,9 @@ union cvmx_gserx_lanex_rx_vma_status_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_vma_status_0_s cn73xx;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s cn75xx;
 	struct cvmx_gserx_lanex_rx_vma_status_0_s cn78xx;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_0 cvmx_gserx_lanex_rx_vma_status_0_t;
 
@@ -4919,7 +5341,9 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_vma_status_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s cn75xx;
 	struct cvmx_gserx_lanex_rx_vma_status_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_1 cvmx_gserx_lanex_rx_vma_status_1_t;
 
@@ -4964,7 +5388,40 @@ union cvmx_gserx_lanex_sds_pin_mon_0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_sds_pin_mon_0_s cn73xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t pcs_sds_tx_widthsel          : 2;  /**< TX parallel interface width settings (RAW PCS to
+                                                         SerDes TX).
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+	uint64_t pcs_sds_rx_pcie_mode         : 1;  /**< Selects between RX terminations:
+                                                         0x0 = pcs_sds_rx_terminate_to_vdda.
+                                                         0x1 = VSS. */
+	uint64_t reserved_6_5                 : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;  /**< Not Used. */
+	uint64_t tx_detrx_state               : 2;  /**< RX detection state:
+                                                         0x0 = IDLE.
+                                                         0x1 = Charge Up.
+                                                         0x2 = Detection.
+                                                         0x3 = Restore common mode. */
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;  /**< TX detect RX, mode disable. */
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;  /**< TX detect RX, pulse enable. */
+#else
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;
+	uint64_t tx_detrx_state               : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;
+	uint64_t reserved_6_5                 : 2;
+	uint64_t pcs_sds_rx_pcie_mode         : 1;
+	uint64_t pcs_sds_tx_widthsel          : 2;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_cn73xx cn75xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_sds_pin_mon_0 cvmx_gserx_lanex_sds_pin_mon_0_t;
 
@@ -5012,6 +5469,8 @@ union cvmx_gserx_lanex_sds_pin_mon_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_sds_pin_mon_1_s cn73xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s cn75xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_sds_pin_mon_1 cvmx_gserx_lanex_sds_pin_mon_1_t;
 
@@ -5041,6 +5500,8 @@ union cvmx_gserx_lanex_sds_pin_mon_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_sds_pin_mon_2_s cn73xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s cn75xx;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_sds_pin_mon_2 cvmx_gserx_lanex_sds_pin_mon_2_t;
 
@@ -5080,8 +5541,36 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_cfg_0_s    cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t tx_tristate_en_ovrd_val      : 1;  /**< TX termination high-Z enable. */
+	uint64_t tx_chpd_ovrd_val             : 1;  /**< TX lane power down. */
+	uint64_t reserved_13_10               : 4;
+	uint64_t tx_resetn_ovrd_val           : 1;  /**< TX P2S rest. */
+	uint64_t tx_cm_mode                   : 1;  /**< Assert to enable fast Common-Mode charge up. For simulation purposes only. */
+	uint64_t cfg_tx_swing                 : 5;  /**< TX output swing control.
+                                                         Default swing encoding when GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] is
+                                                         asserted. */
+	uint64_t fast_rdet_mode               : 1;  /**< Assert to enable fast RX Detection. For simulation purposes only. */
+	uint64_t fast_tristate_mode           : 1;  /**< Assert to enable fast Tristate power up. For simulation purposes only. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t fast_tristate_mode           : 1;
+	uint64_t fast_rdet_mode               : 1;
+	uint64_t cfg_tx_swing                 : 5;
+	uint64_t tx_cm_mode                   : 1;
+	uint64_t tx_resetn_ovrd_val           : 1;
+	uint64_t reserved_13_10               : 4;
+	uint64_t tx_chpd_ovrd_val             : 1;
+	uint64_t tx_tristate_en_ovrd_val      : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_0_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xx;
+	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
 
@@ -5143,7 +5632,9 @@ union cvmx_gserx_lanex_tx_cfg_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_tx_cfg_1_s    cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_1_s    cn75xx;
 	struct cvmx_gserx_lanex_tx_cfg_1_s    cn78xx;
+	struct cvmx_gserx_lanex_tx_cfg_1_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_1 cvmx_gserx_lanex_tx_cfg_1_t;
 
@@ -5174,8 +5665,27 @@ union cvmx_gserx_lanex_tx_cfg_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_cfg_2_s    cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_2_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_tx_dcc_en            : 1;  /**< DCC Enable. */
+	uint64_t reserved_14_3                : 12;
+	uint64_t rcvr_test_ovrd_en            : 1;  /**< Override RX detect disable and test pulse. */
+	uint64_t rcvr_test_ovrd_val           : 1;  /**< Override value for RX detect test pulse; used to create a pulse during which the receiver
+                                                         detect test operation is performed. */
+	uint64_t tx_rx_detect_dis_ovrd_val    : 1;  /**< Override value of RX detect disable. */
+#else
+	uint64_t tx_rx_detect_dis_ovrd_val    : 1;
+	uint64_t rcvr_test_ovrd_val           : 1;
+	uint64_t rcvr_test_ovrd_en            : 1;
+	uint64_t reserved_14_3                : 12;
+	uint64_t pcs_sds_tx_dcc_en            : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_2_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
+	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
 
@@ -5206,8 +5716,27 @@ union cvmx_gserx_lanex_tx_cfg_3 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_cfg_3_s    cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_3_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t cfg_tx_vboost_en             : 1;  /**< Specifies the value of TX VBoost enable when
+                                                         GSER()_LANE()_TX_CFG_1[TX_VBOOST_EN_OVRRD_EN] is asserted. */
+	uint64_t reserved_13_7                : 7;
+	uint64_t pcs_sds_tx_gain              : 3;  /**< TX Gain. For debug use only. */
+	uint64_t pcs_sds_tx_srate_sel         : 3;  /**< Reserved. */
+	uint64_t cfg_tx_turbo_en              : 1;  /**< Specifies value ot TX turbo enable when GSER()_LANE()_TX_CFG_1[TX_TURBO_EN] is set. */
+#else
+	uint64_t cfg_tx_turbo_en              : 1;
+	uint64_t pcs_sds_tx_srate_sel         : 3;
+	uint64_t pcs_sds_tx_gain              : 3;
+	uint64_t reserved_13_7                : 7;
+	uint64_t cfg_tx_vboost_en             : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_tx_cfg_3_cn73xx cn75xx;
 	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
+	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
 
@@ -5233,7 +5762,9 @@ union cvmx_gserx_lanex_tx_pre_emphasis {
 #endif
 	} s;
 	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn73xx;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn75xx;
 	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xx;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xxp2;
 };
 typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_t;
 
@@ -5260,7 +5791,9 @@ union cvmx_gserx_lane_lpbken {
 #endif
 	} s;
 	struct cvmx_gserx_lane_lpbken_s       cn73xx;
+	struct cvmx_gserx_lane_lpbken_s       cn75xx;
 	struct cvmx_gserx_lane_lpbken_s       cn78xx;
+	struct cvmx_gserx_lane_lpbken_s       cn78xxp2;
 };
 typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
 
@@ -5313,7 +5846,9 @@ union cvmx_gserx_lane_mode {
 #endif
 	} s;
 	struct cvmx_gserx_lane_mode_s         cn73xx;
+	struct cvmx_gserx_lane_mode_s         cn75xx;
 	struct cvmx_gserx_lane_mode_s         cn78xx;
+	struct cvmx_gserx_lane_mode_s         cn78xxp2;
 };
 typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
 
@@ -5434,7 +5969,9 @@ union cvmx_gserx_lane_px_mode_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_px_mode_0_s    cn73xx;
+	struct cvmx_gserx_lane_px_mode_0_s    cn75xx;
 	struct cvmx_gserx_lane_px_mode_0_s    cn78xx;
+	struct cvmx_gserx_lane_px_mode_0_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
 
@@ -5496,7 +6033,9 @@ union cvmx_gserx_lane_px_mode_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_px_mode_1_s    cn73xx;
+	struct cvmx_gserx_lane_px_mode_1_s    cn75xx;
 	struct cvmx_gserx_lane_px_mode_1_s    cn78xx;
+	struct cvmx_gserx_lane_px_mode_1_s    cn78xxp2;
 };
 typedef union cvmx_gserx_lane_px_mode_1 cvmx_gserx_lane_px_mode_1_t;
 
@@ -5523,7 +6062,9 @@ union cvmx_gserx_lane_poff {
 #endif
 	} s;
 	struct cvmx_gserx_lane_poff_s         cn73xx;
+	struct cvmx_gserx_lane_poff_s         cn75xx;
 	struct cvmx_gserx_lane_poff_s         cn78xx;
+	struct cvmx_gserx_lane_poff_s         cn78xxp2;
 };
 typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
 
@@ -5549,7 +6090,9 @@ union cvmx_gserx_lane_srst {
 #endif
 	} s;
 	struct cvmx_gserx_lane_srst_s         cn73xx;
+	struct cvmx_gserx_lane_srst_s         cn75xx;
 	struct cvmx_gserx_lane_srst_s         cn78xx;
+	struct cvmx_gserx_lane_srst_s         cn78xxp2;
 };
 typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
 
@@ -5581,7 +6124,9 @@ union cvmx_gserx_lane_vma_coarse_ctrl_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn73xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn75xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_0 cvmx_gserx_lane_vma_coarse_ctrl_0_t;
 
@@ -5608,7 +6153,9 @@ union cvmx_gserx_lane_vma_coarse_ctrl_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn73xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn75xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_1 cvmx_gserx_lane_vma_coarse_ctrl_1_t;
 
@@ -5635,7 +6182,9 @@ union cvmx_gserx_lane_vma_coarse_ctrl_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn73xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn75xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_2 cvmx_gserx_lane_vma_coarse_ctrl_2_t;
 
@@ -5676,7 +6225,9 @@ union cvmx_gserx_lane_vma_fine_ctrl_0 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn73xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn75xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_0 cvmx_gserx_lane_vma_fine_ctrl_0_t;
 
@@ -5706,7 +6257,9 @@ union cvmx_gserx_lane_vma_fine_ctrl_1 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn73xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn75xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_1 cvmx_gserx_lane_vma_fine_ctrl_1_t;
 
@@ -5736,7 +6289,9 @@ union cvmx_gserx_lane_vma_fine_ctrl_2 {
 #endif
 	} s;
 	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn73xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn75xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn78xxp2;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_2 cvmx_gserx_lane_vma_fine_ctrl_2_t;
 
@@ -6881,7 +7436,9 @@ union cvmx_gserx_phy_ctl {
 #endif
 	} s;
 	struct cvmx_gserx_phy_ctl_s           cn73xx;
+	struct cvmx_gserx_phy_ctl_s           cn75xx;
 	struct cvmx_gserx_phy_ctl_s           cn78xx;
+	struct cvmx_gserx_phy_ctl_s           cn78xxp2;
 };
 typedef union cvmx_gserx_phy_ctl cvmx_gserx_phy_ctl_t;
 
@@ -6902,7 +7459,9 @@ union cvmx_gserx_pipe_lpbk {
 #endif
 	} s;
 	struct cvmx_gserx_pipe_lpbk_s         cn73xx;
+	struct cvmx_gserx_pipe_lpbk_s         cn75xx;
 	struct cvmx_gserx_pipe_lpbk_s         cn78xx;
+	struct cvmx_gserx_pipe_lpbk_s         cn78xxp2;
 };
 typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
 
@@ -6965,7 +7524,9 @@ union cvmx_gserx_pll_px_mode_0 {
 #endif
 	} s;
 	struct cvmx_gserx_pll_px_mode_0_s     cn73xx;
+	struct cvmx_gserx_pll_px_mode_0_s     cn75xx;
 	struct cvmx_gserx_pll_px_mode_0_s     cn78xx;
+	struct cvmx_gserx_pll_px_mode_0_s     cn78xxp2;
 };
 typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
 
@@ -7039,7 +7600,9 @@ union cvmx_gserx_pll_px_mode_1 {
 #endif
 	} s;
 	struct cvmx_gserx_pll_px_mode_1_s     cn73xx;
+	struct cvmx_gserx_pll_px_mode_1_s     cn75xx;
 	struct cvmx_gserx_pll_px_mode_1_s     cn78xx;
+	struct cvmx_gserx_pll_px_mode_1_s     cn78xxp2;
 };
 typedef union cvmx_gserx_pll_px_mode_1 cvmx_gserx_pll_px_mode_1_t;
 
@@ -7058,7 +7621,9 @@ union cvmx_gserx_pll_stat {
 #endif
 	} s;
 	struct cvmx_gserx_pll_stat_s          cn73xx;
+	struct cvmx_gserx_pll_stat_s          cn75xx;
 	struct cvmx_gserx_pll_stat_s          cn78xx;
+	struct cvmx_gserx_pll_stat_s          cn78xxp2;
 };
 typedef union cvmx_gserx_pll_stat cvmx_gserx_pll_stat_t;
 
@@ -7080,7 +7645,9 @@ union cvmx_gserx_qlm_stat {
 #endif
 	} s;
 	struct cvmx_gserx_qlm_stat_s          cn73xx;
+	struct cvmx_gserx_qlm_stat_s          cn75xx;
 	struct cvmx_gserx_qlm_stat_s          cn78xx;
+	struct cvmx_gserx_qlm_stat_s          cn78xxp2;
 };
 typedef union cvmx_gserx_qlm_stat cvmx_gserx_qlm_stat_t;
 
@@ -7109,12 +7676,17 @@ union cvmx_gserx_rdet_time {
 #endif
 	} s;
 	struct cvmx_gserx_rdet_time_s         cn73xx;
+	struct cvmx_gserx_rdet_time_s         cn75xx;
 	struct cvmx_gserx_rdet_time_s         cn78xx;
+	struct cvmx_gserx_rdet_time_s         cn78xxp2;
 };
 typedef union cvmx_gserx_rdet_time cvmx_gserx_rdet_time_t;
 
 /**
  * cvmx_gser#_refclk_evt_cntr
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_gserx_refclk_evt_cntr {
 	uint64_t u64;
@@ -7134,11 +7706,16 @@ union cvmx_gserx_refclk_evt_cntr {
 #endif
 	} s;
 	struct cvmx_gserx_refclk_evt_cntr_s   cn73xx;
+	struct cvmx_gserx_refclk_evt_cntr_s   cn75xx;
+	struct cvmx_gserx_refclk_evt_cntr_s   cn78xxp2;
 };
 typedef union cvmx_gserx_refclk_evt_cntr cvmx_gserx_refclk_evt_cntr_t;
 
 /**
  * cvmx_gser#_refclk_evt_ctrl
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_gserx_refclk_evt_ctrl {
 	uint64_t u64;
@@ -7155,6 +7732,8 @@ union cvmx_gserx_refclk_evt_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_refclk_evt_ctrl_s   cn73xx;
+	struct cvmx_gserx_refclk_evt_ctrl_s   cn75xx;
+	struct cvmx_gserx_refclk_evt_ctrl_s   cn78xxp2;
 };
 typedef union cvmx_gserx_refclk_evt_ctrl cvmx_gserx_refclk_evt_ctrl_t;
 
@@ -7187,7 +7766,9 @@ union cvmx_gserx_refclk_sel {
 #endif
 	} s;
 	struct cvmx_gserx_refclk_sel_s        cn73xx;
+	struct cvmx_gserx_refclk_sel_s        cn75xx;
 	struct cvmx_gserx_refclk_sel_s        cn78xx;
+	struct cvmx_gserx_refclk_sel_s        cn78xxp2;
 };
 typedef union cvmx_gserx_refclk_sel cvmx_gserx_refclk_sel_t;
 
@@ -7218,7 +7799,9 @@ union cvmx_gserx_rx_coast {
 #endif
 	} s;
 	struct cvmx_gserx_rx_coast_s          cn73xx;
+	struct cvmx_gserx_rx_coast_s          cn75xx;
 	struct cvmx_gserx_rx_coast_s          cn78xx;
+	struct cvmx_gserx_rx_coast_s          cn78xxp2;
 };
 typedef union cvmx_gserx_rx_coast cvmx_gserx_rx_coast_t;
 
@@ -7248,7 +7831,9 @@ union cvmx_gserx_rx_eie_deten {
 #endif
 	} s;
 	struct cvmx_gserx_rx_eie_deten_s      cn73xx;
+	struct cvmx_gserx_rx_eie_deten_s      cn75xx;
 	struct cvmx_gserx_rx_eie_deten_s      cn78xx;
+	struct cvmx_gserx_rx_eie_deten_s      cn78xxp2;
 };
 typedef union cvmx_gserx_rx_eie_deten cvmx_gserx_rx_eie_deten_t;
 
@@ -7296,7 +7881,9 @@ union cvmx_gserx_rx_eie_detsts {
 #endif
 	} s;
 	struct cvmx_gserx_rx_eie_detsts_s     cn73xx;
+	struct cvmx_gserx_rx_eie_detsts_s     cn75xx;
 	struct cvmx_gserx_rx_eie_detsts_s     cn78xx;
+	struct cvmx_gserx_rx_eie_detsts_s     cn78xxp2;
 };
 typedef union cvmx_gserx_rx_eie_detsts cvmx_gserx_rx_eie_detsts_t;
 
@@ -7331,7 +7918,9 @@ union cvmx_gserx_rx_eie_filter {
 #endif
 	} s;
 	struct cvmx_gserx_rx_eie_filter_s     cn73xx;
+	struct cvmx_gserx_rx_eie_filter_s     cn75xx;
 	struct cvmx_gserx_rx_eie_filter_s     cn78xx;
+	struct cvmx_gserx_rx_eie_filter_s     cn78xxp2;
 };
 typedef union cvmx_gserx_rx_eie_filter cvmx_gserx_rx_eie_filter_t;
 
@@ -7359,7 +7948,9 @@ union cvmx_gserx_rx_polarity {
 #endif
 	} s;
 	struct cvmx_gserx_rx_polarity_s       cn73xx;
+	struct cvmx_gserx_rx_polarity_s       cn75xx;
 	struct cvmx_gserx_rx_polarity_s       cn78xx;
+	struct cvmx_gserx_rx_polarity_s       cn78xxp2;
 };
 typedef union cvmx_gserx_rx_polarity cvmx_gserx_rx_polarity_t;
 
@@ -7407,7 +7998,9 @@ union cvmx_gserx_rx_pwr_ctrl_p1 {
 #endif
 	} s;
 	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn73xx;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn75xx;
 	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn78xx;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn78xxp2;
 };
 typedef union cvmx_gserx_rx_pwr_ctrl_p1 cvmx_gserx_rx_pwr_ctrl_p1_t;
 
@@ -7455,7 +8048,9 @@ union cvmx_gserx_rx_pwr_ctrl_p2 {
 #endif
 	} s;
 	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn73xx;
+	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn75xx;
 	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn78xx;
+	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn78xxp2;
 };
 typedef union cvmx_gserx_rx_pwr_ctrl_p2 cvmx_gserx_rx_pwr_ctrl_p2_t;
 
@@ -7504,6 +8099,7 @@ union cvmx_gserx_sata_lanex_tx_ampx {
 #endif
 	} s;
 	struct cvmx_gserx_sata_lanex_tx_ampx_s cn73xx;
+	struct cvmx_gserx_sata_lanex_tx_ampx_s cn75xx;
 };
 typedef union cvmx_gserx_sata_lanex_tx_ampx cvmx_gserx_sata_lanex_tx_ampx_t;
 
@@ -7531,6 +8127,7 @@ union cvmx_gserx_sata_lanex_tx_preemphx {
 #endif
 	} s;
 	struct cvmx_gserx_sata_lanex_tx_preemphx_s cn73xx;
+	struct cvmx_gserx_sata_lanex_tx_preemphx_s cn75xx;
 };
 typedef union cvmx_gserx_sata_lanex_tx_preemphx cvmx_gserx_sata_lanex_tx_preemphx_t;
 
@@ -7558,6 +8155,7 @@ union cvmx_gserx_sata_lane_rst {
 	struct cvmx_gserx_sata_lane_rst_s     cn70xx;
 	struct cvmx_gserx_sata_lane_rst_s     cn70xxp1;
 	struct cvmx_gserx_sata_lane_rst_s     cn73xx;
+	struct cvmx_gserx_sata_lane_rst_s     cn75xx;
 };
 typedef union cvmx_gserx_sata_lane_rst cvmx_gserx_sata_lane_rst_t;
 
@@ -7813,6 +8411,7 @@ union cvmx_gserx_sata_status {
 	struct cvmx_gserx_sata_status_s       cn70xx;
 	struct cvmx_gserx_sata_status_s       cn70xxp1;
 	struct cvmx_gserx_sata_status_s       cn73xx;
+	struct cvmx_gserx_sata_status_s       cn75xx;
 };
 typedef union cvmx_gserx_sata_status cvmx_gserx_sata_status_t;
 
@@ -7864,6 +8463,7 @@ union cvmx_gserx_sata_tx_invert {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} cn73xx;
+	struct cvmx_gserx_sata_tx_invert_cn73xx cn75xx;
 };
 typedef union cvmx_gserx_sata_tx_invert cvmx_gserx_sata_tx_invert_t;
 
@@ -7885,7 +8485,9 @@ union cvmx_gserx_scratch {
 #endif
 	} s;
 	struct cvmx_gserx_scratch_s           cn73xx;
+	struct cvmx_gserx_scratch_s           cn75xx;
 	struct cvmx_gserx_scratch_s           cn78xx;
+	struct cvmx_gserx_scratch_s           cn78xxp2;
 };
 typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
 
@@ -7921,8 +8523,38 @@ union cvmx_gserx_slicex_rx_sdll_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn73xx;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_oob_clk_ctrl         : 2;  /**< OOB clock oscillator output frequency selection:
+                                                         0x0 = 506 Mhz (min) 682 Mhz (typ) 782 Mhz (max).
+                                                         0x1 = 439 Mhz (min) 554 Mhz (typ) 595 Mhz (max).
+                                                         0x2 = 379 Mhz (min) 453 Mhz (typ) 482 Mhz (max).
+                                                         0x3 = 303 Mhz (min) 378 Mhz (typ) 414 Mhz (max).
+                                                         This parameter is for debugging purposes and should not
+                                                         be written in normal operation. */
+	uint64_t reserved_13_7                : 7;
+	uint64_t pcs_sds_rx_sdll_tune         : 3;  /**< Tuning bits for the regulator and the loop filter. */
+	uint64_t pcs_sds_rx_sdll_swsel        : 4;  /**< DMON control; selects which signal is passed to the output
+                                                         of DMON.
+                                                         0x1 = dllout[0] (first output clock phase, out of 8 phases,
+                                                         of the Slice DLL).
+                                                         0x2 = dllout[1] (second output clock phase, out of 8 phases,
+                                                         of the Slice DLL).
+                                                         0x4 = piclk (output clock of the PI).
+                                                         0x8 = vdda_int.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t pcs_sds_rx_sdll_swsel        : 4;
+	uint64_t pcs_sds_rx_sdll_tune         : 3;
+	uint64_t reserved_13_7                : 7;
+	uint64_t pcs_sds_oob_clk_ctrl         : 2;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_cn73xx cn75xx;
 	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xx;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xxp2;
 };
 typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
 
@@ -7954,8 +8586,28 @@ union cvmx_gserx_slice_cfg {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
-	struct cvmx_gserx_slice_cfg_s         cn73xx;
+	struct cvmx_gserx_slice_cfg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t tx_rx_detect_lvl_enc         : 4;  /**< Determines the RX Detect level, pcs_sds_tx_rx_detect_lvl[9:0],
+                                                         (which is a 1-hot signal), where the level is equal to to
+                                                         2^TX_RX_DETECT_LVL_ENC. */
+	uint64_t reserved_7_6                 : 2;
+	uint64_t pcs_sds_rx_pcie_pterm        : 2;  /**< Reserved. */
+	uint64_t pcs_sds_rx_pcie_nterm        : 2;  /**< Reserved. */
+	uint64_t pcs_sds_tx_stress_eye        : 2;  /**< Controls TX stress eye. */
+#else
+	uint64_t pcs_sds_tx_stress_eye        : 2;
+	uint64_t pcs_sds_rx_pcie_nterm        : 2;
+	uint64_t pcs_sds_rx_pcie_pterm        : 2;
+	uint64_t reserved_7_6                 : 2;
+	uint64_t tx_rx_detect_lvl_enc         : 4;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_slice_cfg_cn73xx    cn75xx;
 	struct cvmx_gserx_slice_cfg_s         cn78xx;
+	struct cvmx_gserx_slice_cfg_s         cn78xxp2;
 };
 typedef union cvmx_gserx_slice_cfg cvmx_gserx_slice_cfg_t;
 
@@ -8019,7 +8671,9 @@ union cvmx_gserx_spd {
 	uint64_t reserved_0_63                : 64;
 #endif
 	} cn73xx;
+	struct cvmx_gserx_spd_cn73xx          cn75xx;
 	struct cvmx_gserx_spd_s               cn78xx;
+	struct cvmx_gserx_spd_s               cn78xxp2;
 };
 typedef union cvmx_gserx_spd cvmx_gserx_spd_t;
 
@@ -8042,7 +8696,9 @@ union cvmx_gserx_srst {
 #endif
 	} s;
 	struct cvmx_gserx_srst_s              cn73xx;
+	struct cvmx_gserx_srst_s              cn75xx;
 	struct cvmx_gserx_srst_s              cn78xx;
+	struct cvmx_gserx_srst_s              cn78xxp2;
 };
 typedef union cvmx_gserx_srst cvmx_gserx_srst_t;
 
@@ -8069,12 +8725,17 @@ union cvmx_gserx_tx_vboost {
 #endif
 	} s;
 	struct cvmx_gserx_tx_vboost_s         cn73xx;
+	struct cvmx_gserx_tx_vboost_s         cn75xx;
 	struct cvmx_gserx_tx_vboost_s         cn78xx;
+	struct cvmx_gserx_tx_vboost_s         cn78xxp2;
 };
 typedef union cvmx_gserx_tx_vboost cvmx_gserx_tx_vboost_t;
 
 /**
  * cvmx_gser#_txclk_evt_cntr
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_gserx_txclk_evt_cntr {
 	uint64_t u64;
@@ -8094,11 +8755,16 @@ union cvmx_gserx_txclk_evt_cntr {
 #endif
 	} s;
 	struct cvmx_gserx_txclk_evt_cntr_s    cn73xx;
+	struct cvmx_gserx_txclk_evt_cntr_s    cn75xx;
+	struct cvmx_gserx_txclk_evt_cntr_s    cn78xxp2;
 };
 typedef union cvmx_gserx_txclk_evt_cntr cvmx_gserx_txclk_evt_cntr_t;
 
 /**
  * cvmx_gser#_txclk_evt_ctrl
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_gserx_txclk_evt_ctrl {
 	uint64_t u64;
@@ -8115,6 +8781,8 @@ union cvmx_gserx_txclk_evt_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_txclk_evt_ctrl_s    cn73xx;
+	struct cvmx_gserx_txclk_evt_ctrl_s    cn75xx;
+	struct cvmx_gserx_txclk_evt_ctrl_s    cn78xxp2;
 };
 typedef union cvmx_gserx_txclk_evt_ctrl cvmx_gserx_txclk_evt_ctrl_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
index 393689d..8e635fd 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
@@ -256,5 +256,11 @@ extern void cvmx_helper_bgx_tx_options(unsigned node,
  * @param mac       mac address for the ipd_port
  */
 extern void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac);
+
+
 extern int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres);
+extern void cvmx_helper_bgx_set_jabber(int xiface, unsigned index, unsigned size);
+extern int cvmx_helper_bgx_shutdown_port(int xiface, int index);
+extern int cvmx_bgx_set_backpressure_override(int xiface, unsigned port_mask);
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index 49420ed..b10f4e6 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -42,7 +42,7 @@
  *
  * Small helper utilities.
  *
- * <hr>$Revision: 106932 $<hr>
+ * <hr>$Revision: 111417 $<hr>
  */
 
 #ifndef __CVMX_HELPER_UTIL_H__
@@ -201,7 +201,6 @@ static inline void cvmx_helper_free_pki_pkt_data(cvmx_wqe_t *work)
 	cvmx_wqe_78xx_t *wqe = (cvmx_wqe_78xx_t*)work;
 
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_dprintf("ERROR: free_pki_pkt_data: Supported only on 78xx\n");
 		return;
 	}
 	/* Make sure errata pki-20776 has been applied*/
@@ -239,7 +238,6 @@ static inline void cvmx_wqe_pki_free(cvmx_wqe_t *work)
 	cvmx_fpa3_gaura_t aura;
 
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_dprintf("ERROR: cvmx_wqe_free: Supported only on 78xx\n");
 		return;
 	}
 	/* Do nothing if the first packet buffer shares WQE buffer */
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index 5f156d8..5398ecd 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -130,6 +130,17 @@ static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 #define CVMX_HNA_DIFRDPTR (CVMX_ADD_IO_SEG(0x0001470200000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_ECO CVMX_HNA_ECO_FUNC()
+static inline uint64_t CVMX_HNA_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_HNA_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000D0ull);
+}
+#else
+#define CVMX_HNA_ECO (CVMX_ADD_IO_SEG(0x00011800470000D0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 {
@@ -418,6 +429,7 @@ union cvmx_hna_bist0 {
 	} s;
 	struct cvmx_hna_bist0_s               cn73xx;
 	struct cvmx_hna_bist0_s               cn78xx;
+	struct cvmx_hna_bist0_s               cn78xxp2;
 };
 typedef union cvmx_hna_bist0 cvmx_hna_bist0_t;
 
@@ -450,6 +462,7 @@ union cvmx_hna_bist1 {
 	} s;
 	struct cvmx_hna_bist1_s               cn73xx;
 	struct cvmx_hna_bist1_s               cn78xx;
+	struct cvmx_hna_bist1_s               cn78xxp2;
 };
 typedef union cvmx_hna_bist1 cvmx_hna_bist1_t;
 
@@ -648,6 +661,7 @@ union cvmx_hna_config {
 #endif
 	} cn73xx;
 	struct cvmx_hna_config_s              cn78xx;
+	struct cvmx_hna_config_s              cn78xxp2;
 };
 typedef union cvmx_hna_config cvmx_hna_config_t;
 
@@ -697,6 +711,7 @@ union cvmx_hna_control {
 	} s;
 	struct cvmx_hna_control_s             cn73xx;
 	struct cvmx_hna_control_s             cn78xx;
+	struct cvmx_hna_control_s             cn78xxp2;
 };
 typedef union cvmx_hna_control cvmx_hna_control_t;
 
@@ -730,6 +745,7 @@ union cvmx_hna_dbell {
 	} s;
 	struct cvmx_hna_dbell_s               cn73xx;
 	struct cvmx_hna_dbell_s               cn78xx;
+	struct cvmx_hna_dbell_s               cn78xxp2;
 };
 typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
 
@@ -779,6 +795,7 @@ union cvmx_hna_difctl {
 	} s;
 	struct cvmx_hna_difctl_s              cn73xx;
 	struct cvmx_hna_difctl_s              cn78xx;
+	struct cvmx_hna_difctl_s              cn78xxp2;
 };
 typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
 
@@ -814,10 +831,29 @@ union cvmx_hna_difrdptr {
 	} s;
 	struct cvmx_hna_difrdptr_s            cn73xx;
 	struct cvmx_hna_difrdptr_s            cn78xx;
+	struct cvmx_hna_difrdptr_s            cn78xxp2;
 };
 typedef union cvmx_hna_difrdptr cvmx_hna_difrdptr_t;
 
 /**
+ * cvmx_hna_eco
+ */
+union cvmx_hna_eco {
+	uint64_t u64;
+	struct cvmx_hna_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_hna_eco_s                 cn73xx;
+};
+typedef union cvmx_hna_eco cvmx_hna_eco_t;
+
+/**
  * cvmx_hna_error
  *
  * This register contains error status information.
@@ -901,6 +937,7 @@ union cvmx_hna_error {
 	} s;
 	struct cvmx_hna_error_s               cn73xx;
 	struct cvmx_hna_error_s               cn78xx;
+	struct cvmx_hna_error_s               cn78xxp2;
 };
 typedef union cvmx_hna_error cvmx_hna_error_t;
 
@@ -956,6 +993,7 @@ union cvmx_hna_error_capture_data {
 	} s;
 	struct cvmx_hna_error_capture_data_s  cn73xx;
 	struct cvmx_hna_error_capture_data_s  cn78xx;
+	struct cvmx_hna_error_capture_data_s  cn78xxp2;
 };
 typedef union cvmx_hna_error_capture_data cvmx_hna_error_capture_data_t;
 
@@ -990,6 +1028,7 @@ union cvmx_hna_error_capture_info {
 	} s;
 	struct cvmx_hna_error_capture_info_s  cn73xx;
 	struct cvmx_hna_error_capture_info_s  cn78xx;
+	struct cvmx_hna_error_capture_info_s  cn78xxp2;
 };
 typedef union cvmx_hna_error_capture_info cvmx_hna_error_capture_info_t;
 
@@ -1011,6 +1050,7 @@ union cvmx_hna_hnc0_ram1x {
 	} s;
 	struct cvmx_hna_hnc0_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram1x_s          cn78xx;
+	struct cvmx_hna_hnc0_ram1x_s          cn78xxp2;
 };
 typedef union cvmx_hna_hnc0_ram1x cvmx_hna_hnc0_ram1x_t;
 
@@ -1032,6 +1072,7 @@ union cvmx_hna_hnc0_ram2x {
 	} s;
 	struct cvmx_hna_hnc0_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram2x_s          cn78xx;
+	struct cvmx_hna_hnc0_ram2x_s          cn78xxp2;
 };
 typedef union cvmx_hna_hnc0_ram2x cvmx_hna_hnc0_ram2x_t;
 
@@ -1053,6 +1094,7 @@ union cvmx_hna_hnc1_ram1x {
 	} s;
 	struct cvmx_hna_hnc1_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram1x_s          cn78xx;
+	struct cvmx_hna_hnc1_ram1x_s          cn78xxp2;
 };
 typedef union cvmx_hna_hnc1_ram1x cvmx_hna_hnc1_ram1x_t;
 
@@ -1074,6 +1116,7 @@ union cvmx_hna_hnc1_ram2x {
 	} s;
 	struct cvmx_hna_hnc1_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram2x_s          cn78xx;
+	struct cvmx_hna_hnc1_ram2x_s          cn78xxp2;
 };
 typedef union cvmx_hna_hnc1_ram2x cvmx_hna_hnc1_ram2x_t;
 
@@ -1096,6 +1139,7 @@ union cvmx_hna_hpu_csr {
 	} s;
 	struct cvmx_hna_hpu_csr_s             cn73xx;
 	struct cvmx_hna_hpu_csr_s             cn78xx;
+	struct cvmx_hna_hpu_csr_s             cn78xxp2;
 };
 typedef union cvmx_hna_hpu_csr cvmx_hna_hpu_csr_t;
 
@@ -1125,6 +1169,7 @@ union cvmx_hna_hpu_dbg {
 	} s;
 	struct cvmx_hna_hpu_dbg_s             cn73xx;
 	struct cvmx_hna_hpu_dbg_s             cn78xx;
+	struct cvmx_hna_hpu_dbg_s             cn78xxp2;
 };
 typedef union cvmx_hna_hpu_dbg cvmx_hna_hpu_dbg_t;
 
@@ -1162,6 +1207,7 @@ union cvmx_hna_hpu_eir {
 	} s;
 	struct cvmx_hna_hpu_eir_s             cn73xx;
 	struct cvmx_hna_hpu_eir_s             cn78xx;
+	struct cvmx_hna_hpu_eir_s             cn78xxp2;
 };
 typedef union cvmx_hna_hpu_eir cvmx_hna_hpu_eir_t;
 
@@ -1181,6 +1227,7 @@ union cvmx_hna_pfc0_cnt {
 	} s;
 	struct cvmx_hna_pfc0_cnt_s            cn73xx;
 	struct cvmx_hna_pfc0_cnt_s            cn78xx;
+	struct cvmx_hna_pfc0_cnt_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc0_cnt cvmx_hna_pfc0_cnt_t;
 
@@ -1211,6 +1258,7 @@ union cvmx_hna_pfc0_ctl {
 	} s;
 	struct cvmx_hna_pfc0_ctl_s            cn73xx;
 	struct cvmx_hna_pfc0_ctl_s            cn78xx;
+	struct cvmx_hna_pfc0_ctl_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc0_ctl cvmx_hna_pfc0_ctl_t;
 
@@ -1230,6 +1278,7 @@ union cvmx_hna_pfc1_cnt {
 	} s;
 	struct cvmx_hna_pfc1_cnt_s            cn73xx;
 	struct cvmx_hna_pfc1_cnt_s            cn78xx;
+	struct cvmx_hna_pfc1_cnt_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc1_cnt cvmx_hna_pfc1_cnt_t;
 
@@ -1259,6 +1308,7 @@ union cvmx_hna_pfc1_ctl {
 	} s;
 	struct cvmx_hna_pfc1_ctl_s            cn73xx;
 	struct cvmx_hna_pfc1_ctl_s            cn78xx;
+	struct cvmx_hna_pfc1_ctl_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc1_ctl cvmx_hna_pfc1_ctl_t;
 
@@ -1278,6 +1328,7 @@ union cvmx_hna_pfc2_cnt {
 	} s;
 	struct cvmx_hna_pfc2_cnt_s            cn73xx;
 	struct cvmx_hna_pfc2_cnt_s            cn78xx;
+	struct cvmx_hna_pfc2_cnt_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc2_cnt cvmx_hna_pfc2_cnt_t;
 
@@ -1307,6 +1358,7 @@ union cvmx_hna_pfc2_ctl {
 	} s;
 	struct cvmx_hna_pfc2_ctl_s            cn73xx;
 	struct cvmx_hna_pfc2_ctl_s            cn78xx;
+	struct cvmx_hna_pfc2_ctl_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc2_ctl cvmx_hna_pfc2_ctl_t;
 
@@ -1326,6 +1378,7 @@ union cvmx_hna_pfc3_cnt {
 	} s;
 	struct cvmx_hna_pfc3_cnt_s            cn73xx;
 	struct cvmx_hna_pfc3_cnt_s            cn78xx;
+	struct cvmx_hna_pfc3_cnt_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc3_cnt cvmx_hna_pfc3_cnt_t;
 
@@ -1355,6 +1408,7 @@ union cvmx_hna_pfc3_ctl {
 	} s;
 	struct cvmx_hna_pfc3_ctl_s            cn73xx;
 	struct cvmx_hna_pfc3_ctl_s            cn78xx;
+	struct cvmx_hna_pfc3_ctl_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc3_ctl cvmx_hna_pfc3_ctl_t;
 
@@ -1415,6 +1469,7 @@ union cvmx_hna_pfc_gctl {
 	} s;
 	struct cvmx_hna_pfc_gctl_s            cn73xx;
 	struct cvmx_hna_pfc_gctl_s            cn78xx;
+	struct cvmx_hna_pfc_gctl_s            cn78xxp2;
 };
 typedef union cvmx_hna_pfc_gctl cvmx_hna_pfc_gctl_t;
 
@@ -1464,6 +1519,7 @@ union cvmx_hna_sbd_dbg0 {
 	} s;
 	struct cvmx_hna_sbd_dbg0_s            cn73xx;
 	struct cvmx_hna_sbd_dbg0_s            cn78xx;
+	struct cvmx_hna_sbd_dbg0_s            cn78xxp2;
 };
 typedef union cvmx_hna_sbd_dbg0 cvmx_hna_sbd_dbg0_t;
 
@@ -1489,6 +1545,7 @@ union cvmx_hna_sbd_dbg1 {
 	} s;
 	struct cvmx_hna_sbd_dbg1_s            cn73xx;
 	struct cvmx_hna_sbd_dbg1_s            cn78xx;
+	struct cvmx_hna_sbd_dbg1_s            cn78xxp2;
 };
 typedef union cvmx_hna_sbd_dbg1 cvmx_hna_sbd_dbg1_t;
 
@@ -1514,6 +1571,7 @@ union cvmx_hna_sbd_dbg2 {
 	} s;
 	struct cvmx_hna_sbd_dbg2_s            cn73xx;
 	struct cvmx_hna_sbd_dbg2_s            cn78xx;
+	struct cvmx_hna_sbd_dbg2_s            cn78xxp2;
 };
 typedef union cvmx_hna_sbd_dbg2 cvmx_hna_sbd_dbg2_t;
 
@@ -1549,6 +1607,7 @@ union cvmx_hna_sbd_dbg3 {
 	} s;
 	struct cvmx_hna_sbd_dbg3_s            cn73xx;
 	struct cvmx_hna_sbd_dbg3_s            cn78xx;
+	struct cvmx_hna_sbd_dbg3_s            cn78xxp2;
 };
 typedef union cvmx_hna_sbd_dbg3 cvmx_hna_sbd_dbg3_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index 9a2698a..39a647b 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -574,6 +574,7 @@ union cvmx_ila_bist_sum {
 #endif
 	} s;
 	struct cvmx_ila_bist_sum_s            cn78xx;
+	struct cvmx_ila_bist_sum_s            cn78xxp2;
 };
 typedef union cvmx_ila_bist_sum cvmx_ila_bist_sum_t;
 
@@ -596,6 +597,7 @@ union cvmx_ila_gbl_cfg {
 #endif
 	} s;
 	struct cvmx_ila_gbl_cfg_s             cn78xx;
+	struct cvmx_ila_gbl_cfg_s             cn78xxp2;
 };
 typedef union cvmx_ila_gbl_cfg cvmx_ila_gbl_cfg_t;
 
@@ -620,6 +622,7 @@ union cvmx_ila_lnex_trn_ctl {
 #endif
 	} s;
 	struct cvmx_ila_lnex_trn_ctl_s        cn78xx;
+	struct cvmx_ila_lnex_trn_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ila_lnex_trn_ctl cvmx_ila_lnex_trn_ctl_t;
 
@@ -646,6 +649,7 @@ union cvmx_ila_lnex_trn_ld {
 #endif
 	} s;
 	struct cvmx_ila_lnex_trn_ld_s         cn78xx;
+	struct cvmx_ila_lnex_trn_ld_s         cn78xxp2;
 };
 typedef union cvmx_ila_lnex_trn_ld cvmx_ila_lnex_trn_ld_t;
 
@@ -672,6 +676,7 @@ union cvmx_ila_lnex_trn_lp {
 #endif
 	} s;
 	struct cvmx_ila_lnex_trn_lp_s         cn78xx;
+	struct cvmx_ila_lnex_trn_lp_s         cn78xxp2;
 };
 typedef union cvmx_ila_lnex_trn_lp cvmx_ila_lnex_trn_lp_t;
 
@@ -708,6 +713,7 @@ union cvmx_ila_lne_dbg {
 #endif
 	} s;
 	struct cvmx_ila_lne_dbg_s             cn78xx;
+	struct cvmx_ila_lne_dbg_s             cn78xxp2;
 };
 typedef union cvmx_ila_lne_dbg cvmx_ila_lne_dbg_t;
 
@@ -742,6 +748,7 @@ union cvmx_ila_lne_sts_msg {
 #endif
 	} s;
 	struct cvmx_ila_lne_sts_msg_s         cn78xx;
+	struct cvmx_ila_lne_sts_msg_s         cn78xxp2;
 };
 typedef union cvmx_ila_lne_sts_msg cvmx_ila_lne_sts_msg_t;
 
@@ -761,6 +768,7 @@ union cvmx_ila_rxx_byte_cntx {
 #endif
 	} s;
 	struct cvmx_ila_rxx_byte_cntx_s       cn78xx;
+	struct cvmx_ila_rxx_byte_cntx_s       cn78xxp2;
 };
 typedef union cvmx_ila_rxx_byte_cntx cvmx_ila_rxx_byte_cntx_t;
 
@@ -828,6 +836,7 @@ union cvmx_ila_rxx_cfg0 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_cfg0_s            cn78xx;
+	struct cvmx_ila_rxx_cfg0_s            cn78xxp2;
 };
 typedef union cvmx_ila_rxx_cfg0 cvmx_ila_rxx_cfg0_t;
 
@@ -866,6 +875,7 @@ union cvmx_ila_rxx_cfg1 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_cfg1_s            cn78xx;
+	struct cvmx_ila_rxx_cfg1_s            cn78xxp2;
 };
 typedef union cvmx_ila_rxx_cfg1 cvmx_ila_rxx_cfg1_t;
 
@@ -888,6 +898,7 @@ union cvmx_ila_rxx_cha_xon {
 #endif
 	} s;
 	struct cvmx_ila_rxx_cha_xon_s         cn78xx;
+	struct cvmx_ila_rxx_cha_xon_s         cn78xxp2;
 };
 typedef union cvmx_ila_rxx_cha_xon cvmx_ila_rxx_cha_xon_t;
 
@@ -918,6 +929,7 @@ union cvmx_ila_rxx_int {
 #endif
 	} s;
 	struct cvmx_ila_rxx_int_s             cn78xx;
+	struct cvmx_ila_rxx_int_s             cn78xxp2;
 };
 typedef union cvmx_ila_rxx_int cvmx_ila_rxx_int_t;
 
@@ -937,6 +949,7 @@ union cvmx_ila_rxx_pkt_cntx {
 #endif
 	} s;
 	struct cvmx_ila_rxx_pkt_cntx_s        cn78xx;
+	struct cvmx_ila_rxx_pkt_cntx_s        cn78xxp2;
 };
 typedef union cvmx_ila_rxx_pkt_cntx cvmx_ila_rxx_pkt_cntx_t;
 
@@ -957,6 +970,7 @@ union cvmx_ila_rxx_stat0 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat0_s           cn78xx;
+	struct cvmx_ila_rxx_stat0_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat0 cvmx_ila_rxx_stat0_t;
 
@@ -977,6 +991,7 @@ union cvmx_ila_rxx_stat1 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat1_s           cn78xx;
+	struct cvmx_ila_rxx_stat1_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat1 cvmx_ila_rxx_stat1_t;
 
@@ -1003,6 +1018,7 @@ union cvmx_ila_rxx_stat2 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat2_s           cn78xx;
+	struct cvmx_ila_rxx_stat2_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat2 cvmx_ila_rxx_stat2_t;
 
@@ -1023,6 +1039,7 @@ union cvmx_ila_rxx_stat3 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat3_s           cn78xx;
+	struct cvmx_ila_rxx_stat3_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat3 cvmx_ila_rxx_stat3_t;
 
@@ -1043,6 +1060,7 @@ union cvmx_ila_rxx_stat4 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat4_s           cn78xx;
+	struct cvmx_ila_rxx_stat4_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat4 cvmx_ila_rxx_stat4_t;
 
@@ -1063,6 +1081,7 @@ union cvmx_ila_rxx_stat5 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat5_s           cn78xx;
+	struct cvmx_ila_rxx_stat5_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat5 cvmx_ila_rxx_stat5_t;
 
@@ -1083,6 +1102,7 @@ union cvmx_ila_rxx_stat6 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat6_s           cn78xx;
+	struct cvmx_ila_rxx_stat6_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat6 cvmx_ila_rxx_stat6_t;
 
@@ -1103,6 +1123,7 @@ union cvmx_ila_rxx_stat7 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat7_s           cn78xx;
+	struct cvmx_ila_rxx_stat7_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat7 cvmx_ila_rxx_stat7_t;
 
@@ -1122,6 +1143,7 @@ union cvmx_ila_rxx_stat8 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat8_s           cn78xx;
+	struct cvmx_ila_rxx_stat8_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat8 cvmx_ila_rxx_stat8_t;
 
@@ -1141,6 +1163,7 @@ union cvmx_ila_rxx_stat9 {
 #endif
 	} s;
 	struct cvmx_ila_rxx_stat9_s           cn78xx;
+	struct cvmx_ila_rxx_stat9_s           cn78xxp2;
 };
 typedef union cvmx_ila_rxx_stat9 cvmx_ila_rxx_stat9_t;
 
@@ -1180,6 +1203,7 @@ union cvmx_ila_rx_lnex_cfg {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_cfg_s         cn78xx;
+	struct cvmx_ila_rx_lnex_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_cfg cvmx_ila_rx_lnex_cfg_t;
 
@@ -1222,6 +1246,7 @@ union cvmx_ila_rx_lnex_int {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_int_s         cn78xx;
+	struct cvmx_ila_rx_lnex_int_s         cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_int cvmx_ila_rx_lnex_int_t;
 
@@ -1241,6 +1266,7 @@ union cvmx_ila_rx_lnex_stat0 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat0_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat0_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat0 cvmx_ila_rx_lnex_stat0_t;
 
@@ -1260,6 +1286,7 @@ union cvmx_ila_rx_lnex_stat1 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat1_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat1_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat1 cvmx_ila_rx_lnex_stat1_t;
 
@@ -1284,6 +1311,7 @@ union cvmx_ila_rx_lnex_stat10 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat10_s      cn78xx;
+	struct cvmx_ila_rx_lnex_stat10_s      cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat10 cvmx_ila_rx_lnex_stat10_t;
 
@@ -1308,6 +1336,7 @@ union cvmx_ila_rx_lnex_stat2 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat2_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat2_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat2 cvmx_ila_rx_lnex_stat2_t;
 
@@ -1327,6 +1356,7 @@ union cvmx_ila_rx_lnex_stat3 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat3_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat3_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat3 cvmx_ila_rx_lnex_stat3_t;
 
@@ -1351,6 +1381,7 @@ union cvmx_ila_rx_lnex_stat4 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat4_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat4_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat4 cvmx_ila_rx_lnex_stat4_t;
 
@@ -1370,6 +1401,7 @@ union cvmx_ila_rx_lnex_stat5 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat5_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat5_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat5 cvmx_ila_rx_lnex_stat5_t;
 
@@ -1390,6 +1422,7 @@ union cvmx_ila_rx_lnex_stat6 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat6_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat6_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat6 cvmx_ila_rx_lnex_stat6_t;
 
@@ -1409,6 +1442,7 @@ union cvmx_ila_rx_lnex_stat7 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat7_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat7_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat7 cvmx_ila_rx_lnex_stat7_t;
 
@@ -1428,6 +1462,7 @@ union cvmx_ila_rx_lnex_stat8 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat8_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat8_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat8 cvmx_ila_rx_lnex_stat8_t;
 
@@ -1452,6 +1487,7 @@ union cvmx_ila_rx_lnex_stat9 {
 #endif
 	} s;
 	struct cvmx_ila_rx_lnex_stat9_s       cn78xx;
+	struct cvmx_ila_rx_lnex_stat9_s       cn78xxp2;
 };
 typedef union cvmx_ila_rx_lnex_stat9 cvmx_ila_rx_lnex_stat9_t;
 
@@ -1488,6 +1524,7 @@ union cvmx_ila_ser_cfg {
 #endif
 	} s;
 	struct cvmx_ila_ser_cfg_s             cn78xx;
+	struct cvmx_ila_ser_cfg_s             cn78xxp2;
 };
 typedef union cvmx_ila_ser_cfg cvmx_ila_ser_cfg_t;
 
@@ -1507,6 +1544,7 @@ union cvmx_ila_txx_byte_cntx {
 #endif
 	} s;
 	struct cvmx_ila_txx_byte_cntx_s       cn78xx;
+	struct cvmx_ila_txx_byte_cntx_s       cn78xxp2;
 };
 typedef union cvmx_ila_txx_byte_cntx cvmx_ila_txx_byte_cntx_t;
 
@@ -1570,6 +1608,7 @@ union cvmx_ila_txx_cfg0 {
 #endif
 	} s;
 	struct cvmx_ila_txx_cfg0_s            cn78xx;
+	struct cvmx_ila_txx_cfg0_s            cn78xxp2;
 };
 typedef union cvmx_ila_txx_cfg0 cvmx_ila_txx_cfg0_t;
 
@@ -1580,14 +1619,10 @@ union cvmx_ila_txx_cfg1 {
 	uint64_t u64;
 	struct cvmx_ila_txx_cfg1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ser_low                      : 4;  /**< Reserved. */
+	uint64_t ser_low                      : 4;  /**< Reduce latency by limiting the amount of data in flight for each SerDes. Writting to 0
+                                                         causes hardware to determine a typically optimal value. Added in pass 2. */
 	uint64_t reserved_43_59               : 17;
-	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
-                                                         will compute it. Otherwise, SER_LIMIT must be set as follows:
-                                                         _ SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + NUM_LANES)
-                                                         For instance, for SCLK=1.1GHz,BAUD=10.3125,NUM_LANES=8:
-                                                         _ SER_LIMIT >= 148 + (10.3125 / 1.1 * (12+ 8))
-                                                         _ SER_LIMIT >= 336 */
+	uint64_t ser_limit                    : 10; /**< Reserved. */
 	uint64_t pkt_busy                     : 1;  /**< TX-link is transmitting data. */
 	uint64_t reserved_26_31               : 6;
 	uint64_t skip_cnt                     : 4;  /**< Number of skip words to insert after the scrambler state. */
@@ -1622,6 +1657,7 @@ union cvmx_ila_txx_cfg1 {
 #endif
 	} s;
 	struct cvmx_ila_txx_cfg1_s            cn78xx;
+	struct cvmx_ila_txx_cfg1_s            cn78xxp2;
 };
 typedef union cvmx_ila_txx_cfg1 cvmx_ila_txx_cfg1_t;
 
@@ -1646,6 +1682,7 @@ union cvmx_ila_txx_cha_xon {
 #endif
 	} s;
 	struct cvmx_ila_txx_cha_xon_s         cn78xx;
+	struct cvmx_ila_txx_cha_xon_s         cn78xxp2;
 };
 typedef union cvmx_ila_txx_cha_xon cvmx_ila_txx_cha_xon_t;
 
@@ -1657,8 +1694,14 @@ union cvmx_ila_txx_dbg {
 	struct cvmx_ila_txx_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t data_rate                    : 13; /**< Reserved. */
-	uint64_t low_delay                    : 6;  /**< Reserved. */
+	uint64_t data_rate                    : 13; /**< The number of coprocessor-clocks to transmit 32 words, where each word is 67 bits.  HW
+                                                         will automatically calculate a conservative value for this field.  SW can override the
+                                                         calculation by writing
+                                                         _ DAT_RATE = roundup((67*SCLK / GBAUD)*32).
+                                                         Added in pass 2. */
+	uint64_t low_delay                    : 6;  /**< The delay before reacting to a lane low data indication, as a multiple of 64
+                                                         coprocessor-clocks.
+                                                         Added in pass 2. */
 	uint64_t reserved_3_9                 : 7;
 	uint64_t tx_bad_crc24                 : 1;  /**< Send a control word with bad CRC24. Hardware clears this field once the injection is performed. */
 	uint64_t tx_bad_ctlw2                 : 1;  /**< Send a control word without the control bit set. */
@@ -1674,6 +1717,7 @@ union cvmx_ila_txx_dbg {
 #endif
 	} s;
 	struct cvmx_ila_txx_dbg_s             cn78xx;
+	struct cvmx_ila_txx_dbg_s             cn78xxp2;
 };
 typedef union cvmx_ila_txx_dbg cvmx_ila_txx_dbg_t;
 
@@ -1697,6 +1741,7 @@ union cvmx_ila_txx_err_cfg {
 #endif
 	} s;
 	struct cvmx_ila_txx_err_cfg_s         cn78xx;
+	struct cvmx_ila_txx_err_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ila_txx_err_cfg cvmx_ila_txx_err_cfg_t;
 
@@ -1723,6 +1768,7 @@ union cvmx_ila_txx_int {
 #endif
 	} s;
 	struct cvmx_ila_txx_int_s             cn78xx;
+	struct cvmx_ila_txx_int_s             cn78xxp2;
 };
 typedef union cvmx_ila_txx_int cvmx_ila_txx_int_t;
 
@@ -1742,6 +1788,7 @@ union cvmx_ila_txx_pkt_cntx {
 #endif
 	} s;
 	struct cvmx_ila_txx_pkt_cntx_s        cn78xx;
+	struct cvmx_ila_txx_pkt_cntx_s        cn78xxp2;
 };
 typedef union cvmx_ila_txx_pkt_cntx cvmx_ila_txx_pkt_cntx_t;
 
@@ -1767,6 +1814,7 @@ union cvmx_ila_txx_rmatch {
 #endif
 	} s;
 	struct cvmx_ila_txx_rmatch_s          cn78xx;
+	struct cvmx_ila_txx_rmatch_s          cn78xxp2;
 };
 typedef union cvmx_ila_txx_rmatch cvmx_ila_txx_rmatch_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index aa3b709..8ed88fb 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -1411,6 +1411,7 @@ union cvmx_ilk_bist_sum {
 	uint64_t rxf_x2p                      : 1;
 #endif
 	} cn78xx;
+	struct cvmx_ilk_bist_sum_cn78xx       cn78xxp2;
 };
 typedef union cvmx_ilk_bist_sum cvmx_ilk_bist_sum_t;
 
@@ -1449,6 +1450,7 @@ union cvmx_ilk_gbl_cfg {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_gbl_cfg_s             cn78xx;
+	struct cvmx_ilk_gbl_cfg_s             cn78xxp2;
 };
 typedef union cvmx_ilk_gbl_cfg cvmx_ilk_gbl_cfg_t;
 
@@ -1477,6 +1479,7 @@ union cvmx_ilk_gbl_err_cfg {
 #endif
 	} s;
 	struct cvmx_ilk_gbl_err_cfg_s         cn78xx;
+	struct cvmx_ilk_gbl_err_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ilk_gbl_err_cfg cvmx_ilk_gbl_err_cfg_t;
 
@@ -1532,6 +1535,7 @@ union cvmx_ilk_gbl_int {
 	} cn68xx;
 	struct cvmx_ilk_gbl_int_cn68xx        cn68xxp1;
 	struct cvmx_ilk_gbl_int_s             cn78xx;
+	struct cvmx_ilk_gbl_int_s             cn78xxp2;
 };
 typedef union cvmx_ilk_gbl_int cvmx_ilk_gbl_int_t;
 
@@ -1629,6 +1633,7 @@ union cvmx_ilk_lnex_trn_ctl {
 #endif
 	} s;
 	struct cvmx_ilk_lnex_trn_ctl_s        cn78xx;
+	struct cvmx_ilk_lnex_trn_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ilk_lnex_trn_ctl cvmx_ilk_lnex_trn_ctl_t;
 
@@ -1655,6 +1660,7 @@ union cvmx_ilk_lnex_trn_ld {
 #endif
 	} s;
 	struct cvmx_ilk_lnex_trn_ld_s         cn78xx;
+	struct cvmx_ilk_lnex_trn_ld_s         cn78xxp2;
 };
 typedef union cvmx_ilk_lnex_trn_ld cvmx_ilk_lnex_trn_ld_t;
 
@@ -1681,6 +1687,7 @@ union cvmx_ilk_lnex_trn_lp {
 #endif
 	} s;
 	struct cvmx_ilk_lnex_trn_lp_s         cn78xx;
+	struct cvmx_ilk_lnex_trn_lp_s         cn78xxp2;
 };
 typedef union cvmx_ilk_lnex_trn_lp cvmx_ilk_lnex_trn_lp_t;
 
@@ -1740,6 +1747,7 @@ union cvmx_ilk_lne_dbg {
 	} cn68xx;
 	struct cvmx_ilk_lne_dbg_cn68xx        cn68xxp1;
 	struct cvmx_ilk_lne_dbg_s             cn78xx;
+	struct cvmx_ilk_lne_dbg_s             cn78xxp2;
 };
 typedef union cvmx_ilk_lne_dbg cvmx_ilk_lne_dbg_t;
 
@@ -1792,6 +1800,7 @@ union cvmx_ilk_lne_sts_msg {
 	} cn68xx;
 	struct cvmx_ilk_lne_sts_msg_cn68xx    cn68xxp1;
 	struct cvmx_ilk_lne_sts_msg_s         cn78xx;
+	struct cvmx_ilk_lne_sts_msg_s         cn78xxp2;
 };
 typedef union cvmx_ilk_lne_sts_msg cvmx_ilk_lne_sts_msg_t;
 
@@ -1829,6 +1838,7 @@ union cvmx_ilk_rid_cfg {
 #endif
 	} s;
 	struct cvmx_ilk_rid_cfg_s             cn78xx;
+	struct cvmx_ilk_rid_cfg_s             cn78xxp2;
 };
 typedef union cvmx_ilk_rid_cfg cvmx_ilk_rid_cfg_t;
 
@@ -1848,6 +1858,7 @@ union cvmx_ilk_rxx_byte_cntx {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_byte_cntx_s       cn78xx;
+	struct cvmx_ilk_rxx_byte_cntx_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_byte_cntx cvmx_ilk_rxx_byte_cntx_t;
 
@@ -1875,6 +1886,7 @@ union cvmx_ilk_rxx_cal_entryx {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_cal_entryx_s      cn78xx;
+	struct cvmx_ilk_rxx_cal_entryx_s      cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_cal_entryx cvmx_ilk_rxx_cal_entryx_t;
 
@@ -2110,6 +2122,7 @@ union cvmx_ilk_rxx_cfg0 {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rxx_cfg0_s            cn78xx;
+	struct cvmx_ilk_rxx_cfg0_s            cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_cfg0 cvmx_ilk_rxx_cfg0_t;
 
@@ -2216,6 +2229,7 @@ union cvmx_ilk_rxx_cfg1 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_cfg1_cn68xx       cn68xxp1;
 	struct cvmx_ilk_rxx_cfg1_s            cn78xx;
+	struct cvmx_ilk_rxx_cfg1_s            cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_cfg1 cvmx_ilk_rxx_cfg1_t;
 
@@ -2234,6 +2248,7 @@ union cvmx_ilk_rxx_chax {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_chax_s            cn78xx;
+	struct cvmx_ilk_rxx_chax_s            cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_chax cvmx_ilk_rxx_chax_t;
 
@@ -2255,6 +2270,7 @@ union cvmx_ilk_rxx_cha_xonx {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_cha_xonx_s        cn78xx;
+	struct cvmx_ilk_rxx_cha_xonx_s        cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_cha_xonx cvmx_ilk_rxx_cha_xonx_t;
 
@@ -2283,6 +2299,7 @@ union cvmx_ilk_rxx_err_cfg {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_err_cfg_s         cn78xx;
+	struct cvmx_ilk_rxx_err_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_err_cfg cvmx_ilk_rxx_err_cfg_t;
 
@@ -2517,6 +2534,7 @@ union cvmx_ilk_rxx_int {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rxx_int_s             cn78xx;
+	struct cvmx_ilk_rxx_int_s             cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_int cvmx_ilk_rxx_int_t;
 
@@ -2607,6 +2625,7 @@ union cvmx_ilk_rxx_jabber {
 	struct cvmx_ilk_rxx_jabber_s          cn68xx;
 	struct cvmx_ilk_rxx_jabber_s          cn68xxp1;
 	struct cvmx_ilk_rxx_jabber_s          cn78xx;
+	struct cvmx_ilk_rxx_jabber_s          cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_jabber cvmx_ilk_rxx_jabber_t;
 
@@ -2952,6 +2971,7 @@ union cvmx_ilk_rxx_pkt_cntx {
 #endif
 	} s;
 	struct cvmx_ilk_rxx_pkt_cntx_s        cn78xx;
+	struct cvmx_ilk_rxx_pkt_cntx_s        cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_pkt_cntx cvmx_ilk_rxx_pkt_cntx_t;
 
@@ -2988,6 +3008,7 @@ union cvmx_ilk_rxx_rid {
 #endif
 	} cn68xx;
 	struct cvmx_ilk_rxx_rid_s             cn78xx;
+	struct cvmx_ilk_rxx_rid_s             cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_rid cvmx_ilk_rxx_rid_t;
 
@@ -3028,6 +3049,7 @@ union cvmx_ilk_rxx_stat0 {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rxx_stat0_s           cn78xx;
+	struct cvmx_ilk_rxx_stat0_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat0 cvmx_ilk_rxx_stat0_t;
 
@@ -3059,6 +3081,7 @@ union cvmx_ilk_rxx_stat1 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_stat1_cn68xx      cn68xxp1;
 	struct cvmx_ilk_rxx_stat1_s           cn78xx;
+	struct cvmx_ilk_rxx_stat1_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat1 cvmx_ilk_rxx_stat1_t;
 
@@ -3117,6 +3140,7 @@ union cvmx_ilk_rxx_stat2 {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rxx_stat2_s           cn78xx;
+	struct cvmx_ilk_rxx_stat2_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat2 cvmx_ilk_rxx_stat2_t;
 
@@ -3147,6 +3171,7 @@ union cvmx_ilk_rxx_stat3 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_stat3_cn68xx      cn68xxp1;
 	struct cvmx_ilk_rxx_stat3_s           cn78xx;
+	struct cvmx_ilk_rxx_stat3_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat3 cvmx_ilk_rxx_stat3_t;
 
@@ -3179,6 +3204,7 @@ union cvmx_ilk_rxx_stat4 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_stat4_cn68xx      cn68xxp1;
 	struct cvmx_ilk_rxx_stat4_s           cn78xx;
+	struct cvmx_ilk_rxx_stat4_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat4 cvmx_ilk_rxx_stat4_t;
 
@@ -3221,6 +3247,7 @@ union cvmx_ilk_rxx_stat5 {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rxx_stat5_s           cn78xx;
+	struct cvmx_ilk_rxx_stat5_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat5 cvmx_ilk_rxx_stat5_t;
 
@@ -3253,6 +3280,7 @@ union cvmx_ilk_rxx_stat6 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_stat6_cn68xx      cn68xxp1;
 	struct cvmx_ilk_rxx_stat6_s           cn78xx;
+	struct cvmx_ilk_rxx_stat6_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat6 cvmx_ilk_rxx_stat6_t;
 
@@ -3284,6 +3312,7 @@ union cvmx_ilk_rxx_stat7 {
 	} cn68xx;
 	struct cvmx_ilk_rxx_stat7_cn68xx      cn68xxp1;
 	struct cvmx_ilk_rxx_stat7_s           cn78xx;
+	struct cvmx_ilk_rxx_stat7_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat7 cvmx_ilk_rxx_stat7_t;
 
@@ -3310,6 +3339,7 @@ union cvmx_ilk_rxx_stat8 {
 	struct cvmx_ilk_rxx_stat8_s           cn68xx;
 	struct cvmx_ilk_rxx_stat8_s           cn68xxp1;
 	struct cvmx_ilk_rxx_stat8_s           cn78xx;
+	struct cvmx_ilk_rxx_stat8_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat8 cvmx_ilk_rxx_stat8_t;
 
@@ -3331,6 +3361,7 @@ union cvmx_ilk_rxx_stat9 {
 	struct cvmx_ilk_rxx_stat9_s           cn68xx;
 	struct cvmx_ilk_rxx_stat9_s           cn68xxp1;
 	struct cvmx_ilk_rxx_stat9_s           cn78xx;
+	struct cvmx_ilk_rxx_stat9_s           cn78xxp2;
 };
 typedef union cvmx_ilk_rxx_stat9 cvmx_ilk_rxx_stat9_t;
 
@@ -3427,6 +3458,7 @@ union cvmx_ilk_rx_lnex_cfg {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_rx_lnex_cfg_s         cn78xx;
+	struct cvmx_ilk_rx_lnex_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_cfg cvmx_ilk_rx_lnex_cfg_t;
 
@@ -3502,6 +3534,7 @@ union cvmx_ilk_rx_lnex_int {
 	} cn68xx;
 	struct cvmx_ilk_rx_lnex_int_cn68xx    cn68xxp1;
 	struct cvmx_ilk_rx_lnex_int_s         cn78xx;
+	struct cvmx_ilk_rx_lnex_int_s         cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_int cvmx_ilk_rx_lnex_int_t;
 
@@ -3565,6 +3598,7 @@ union cvmx_ilk_rx_lnex_stat0 {
 	struct cvmx_ilk_rx_lnex_stat0_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat0_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat0_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat0_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat0 cvmx_ilk_rx_lnex_stat0_t;
 
@@ -3586,6 +3620,7 @@ union cvmx_ilk_rx_lnex_stat1 {
 	struct cvmx_ilk_rx_lnex_stat1_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat1_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat1_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat1_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat1 cvmx_ilk_rx_lnex_stat1_t;
 
@@ -3610,6 +3645,7 @@ union cvmx_ilk_rx_lnex_stat10 {
 #endif
 	} s;
 	struct cvmx_ilk_rx_lnex_stat10_s      cn78xx;
+	struct cvmx_ilk_rx_lnex_stat10_s      cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat10 cvmx_ilk_rx_lnex_stat10_t;
 
@@ -3636,6 +3672,7 @@ union cvmx_ilk_rx_lnex_stat2 {
 	struct cvmx_ilk_rx_lnex_stat2_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat2_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat2_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat2_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat2 cvmx_ilk_rx_lnex_stat2_t;
 
@@ -3657,6 +3694,7 @@ union cvmx_ilk_rx_lnex_stat3 {
 	struct cvmx_ilk_rx_lnex_stat3_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat3_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat3_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat3_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat3 cvmx_ilk_rx_lnex_stat3_t;
 
@@ -3683,6 +3721,7 @@ union cvmx_ilk_rx_lnex_stat4 {
 	struct cvmx_ilk_rx_lnex_stat4_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat4_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat4_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat4_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat4 cvmx_ilk_rx_lnex_stat4_t;
 
@@ -3704,6 +3743,7 @@ union cvmx_ilk_rx_lnex_stat5 {
 	struct cvmx_ilk_rx_lnex_stat5_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat5_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat5_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat5_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat5 cvmx_ilk_rx_lnex_stat5_t;
 
@@ -3726,6 +3766,7 @@ union cvmx_ilk_rx_lnex_stat6 {
 	struct cvmx_ilk_rx_lnex_stat6_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat6_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat6_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat6_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat6 cvmx_ilk_rx_lnex_stat6_t;
 
@@ -3747,6 +3788,7 @@ union cvmx_ilk_rx_lnex_stat7 {
 	struct cvmx_ilk_rx_lnex_stat7_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat7_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat7_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat7_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat7 cvmx_ilk_rx_lnex_stat7_t;
 
@@ -3768,6 +3810,7 @@ union cvmx_ilk_rx_lnex_stat8 {
 	struct cvmx_ilk_rx_lnex_stat8_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat8_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat8_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat8_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat8 cvmx_ilk_rx_lnex_stat8_t;
 
@@ -3794,6 +3837,7 @@ union cvmx_ilk_rx_lnex_stat9 {
 	struct cvmx_ilk_rx_lnex_stat9_s       cn68xx;
 	struct cvmx_ilk_rx_lnex_stat9_s       cn68xxp1;
 	struct cvmx_ilk_rx_lnex_stat9_s       cn78xx;
+	struct cvmx_ilk_rx_lnex_stat9_s       cn78xxp2;
 };
 typedef union cvmx_ilk_rx_lnex_stat9 cvmx_ilk_rx_lnex_stat9_t;
 
@@ -3936,6 +3980,7 @@ union cvmx_ilk_ser_cfg {
 	} cn68xx;
 	struct cvmx_ilk_ser_cfg_cn68xx        cn68xxp1;
 	struct cvmx_ilk_ser_cfg_s             cn78xx;
+	struct cvmx_ilk_ser_cfg_s             cn78xxp2;
 };
 typedef union cvmx_ilk_ser_cfg cvmx_ilk_ser_cfg_t;
 
@@ -3955,6 +4000,7 @@ union cvmx_ilk_txx_byte_cntx {
 #endif
 	} s;
 	struct cvmx_ilk_txx_byte_cntx_s       cn78xx;
+	struct cvmx_ilk_txx_byte_cntx_s       cn78xxp2;
 };
 typedef union cvmx_ilk_txx_byte_cntx cvmx_ilk_txx_byte_cntx_t;
 
@@ -3982,6 +4028,7 @@ union cvmx_ilk_txx_cal_entryx {
 #endif
 	} s;
 	struct cvmx_ilk_txx_cal_entryx_s      cn78xx;
+	struct cvmx_ilk_txx_cal_entryx_s      cn78xxp2;
 };
 typedef union cvmx_ilk_txx_cal_entryx cvmx_ilk_txx_cal_entryx_t;
 
@@ -4166,6 +4213,7 @@ union cvmx_ilk_txx_cfg0 {
 	} cn68xx;
 	struct cvmx_ilk_txx_cfg0_cn68xx       cn68xxp1;
 	struct cvmx_ilk_txx_cfg0_s            cn78xx;
+	struct cvmx_ilk_txx_cfg0_s            cn78xxp2;
 };
 typedef union cvmx_ilk_txx_cfg0 cvmx_ilk_txx_cfg0_t;
 
@@ -4176,18 +4224,15 @@ union cvmx_ilk_txx_cfg1 {
 	uint64_t u64;
 	struct cvmx_ilk_txx_cfg1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ser_low                      : 4;  /**< Reserved. */
+	uint64_t ser_low                      : 4;  /**< Reduce latency by limiting the amount of data in flight for each SerDes.  Writting to 0
+                                                         causes
+                                                         hardware to determine a typically optimal value.   Added in pass 2. */
 	uint64_t reserved_53_59               : 7;
 	uint64_t brst_min                     : 5;  /**< Minimum size of a data burst, as a multiple of 32-byte blocks. 0 disables the scheduling
                                                          enhancement. When non-zero, must satisfy:
                                                          _ (BRST_SHRT*8) <= (BRST_MIN*32) <= (BRST_MAX*64)/2. */
 	uint64_t reserved_43_47               : 5;
-	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
-                                                         will compute it. Otherwise, SER_LIMIT must be set as follows:
-                                                         _ SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + (NUM_LANES/2))
-                                                         For instance, for sclk=1.1GHz,BAUD=10.3125,NUM_LANES=16 :
-                                                         _ SER_LIMIT >= 148 + (10.3125 / 1.1 * (12 + (12/2))
-                                                         _ SER_LIMIT >= 317 */
+	uint64_t ser_limit                    : 10; /**< Reserved. */
 	uint64_t pkt_busy                     : 1;  /**< Packet busy. When set to 1, indicates the TX-link is transmitting data. */
 	uint64_t pipe_crd_dis                 : 1;  /**< Disable channel credits. Should be set to 1 when PKO is configured to ignore channel credits. */
 	uint64_t ptp_delay                    : 5;  /**< Reserved. */
@@ -4337,6 +4382,7 @@ union cvmx_ilk_txx_cfg1 {
 #endif
 	} cn68xxp1;
 	struct cvmx_ilk_txx_cfg1_s            cn78xx;
+	struct cvmx_ilk_txx_cfg1_s            cn78xxp2;
 };
 typedef union cvmx_ilk_txx_cfg1 cvmx_ilk_txx_cfg1_t;
 
@@ -4358,6 +4404,7 @@ union cvmx_ilk_txx_cha_xonx {
 #endif
 	} s;
 	struct cvmx_ilk_txx_cha_xonx_s        cn78xx;
+	struct cvmx_ilk_txx_cha_xonx_s        cn78xxp2;
 };
 typedef union cvmx_ilk_txx_cha_xonx cvmx_ilk_txx_cha_xonx_t;
 
@@ -4369,8 +4416,14 @@ union cvmx_ilk_txx_dbg {
 	struct cvmx_ilk_txx_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t data_rate                    : 13; /**< Reserved. */
-	uint64_t low_delay                    : 6;  /**< Reserved. */
+	uint64_t data_rate                    : 13; /**< The number of coprocessor-clocks to transmit 32 words, where each word is 67 bits.  HW
+                                                         will automatically calculate a conservative value for this field.  SW can override the
+                                                         calculation by writing
+                                                                _ DAT_RATE = roundup((67*SCLK / GBAUD)*32).
+                                                         Added in pass 2. */
+	uint64_t low_delay                    : 6;  /**< The delay before reacting to a lane low data indication, as a multiple of 64
+                                                         coprocessor-clocks.
+                                                         Added in pass 2. */
 	uint64_t reserved_3_9                 : 7;
 	uint64_t tx_bad_crc24                 : 1;  /**< Send a control word with bad CRC24. Hardware clears this field once the injection is performed. */
 	uint64_t tx_bad_ctlw2                 : 1;  /**< Send a control word without the control bit set. */
@@ -4401,6 +4454,7 @@ union cvmx_ilk_txx_dbg {
 	} cn68xx;
 	struct cvmx_ilk_txx_dbg_cn68xx        cn68xxp1;
 	struct cvmx_ilk_txx_dbg_s             cn78xx;
+	struct cvmx_ilk_txx_dbg_s             cn78xxp2;
 };
 typedef union cvmx_ilk_txx_dbg cvmx_ilk_txx_dbg_t;
 
@@ -4429,6 +4483,7 @@ union cvmx_ilk_txx_err_cfg {
 #endif
 	} s;
 	struct cvmx_ilk_txx_err_cfg_s         cn78xx;
+	struct cvmx_ilk_txx_err_cfg_s         cn78xxp2;
 };
 typedef union cvmx_ilk_txx_err_cfg cvmx_ilk_txx_err_cfg_t;
 
@@ -4632,6 +4687,7 @@ union cvmx_ilk_txx_int {
 	} cn68xx;
 	struct cvmx_ilk_txx_int_cn68xx        cn68xxp1;
 	struct cvmx_ilk_txx_int_s             cn78xx;
+	struct cvmx_ilk_txx_int_s             cn78xxp2;
 };
 typedef union cvmx_ilk_txx_int cvmx_ilk_txx_int_t;
 
@@ -4947,6 +5003,7 @@ union cvmx_ilk_txx_pkt_cntx {
 #endif
 	} s;
 	struct cvmx_ilk_txx_pkt_cntx_s        cn78xx;
+	struct cvmx_ilk_txx_pkt_cntx_s        cn78xxp2;
 };
 typedef union cvmx_ilk_txx_pkt_cntx cvmx_ilk_txx_pkt_cntx_t;
 
@@ -4973,6 +5030,7 @@ union cvmx_ilk_txx_rmatch {
 	struct cvmx_ilk_txx_rmatch_s          cn68xx;
 	struct cvmx_ilk_txx_rmatch_s          cn68xxp1;
 	struct cvmx_ilk_txx_rmatch_s          cn78xx;
+	struct cvmx_ilk_txx_rmatch_s          cn78xxp2;
 };
 typedef union cvmx_ilk_txx_rmatch cvmx_ilk_txx_rmatch_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 14a17a6..b0859af 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBN_BIST_STATUS CVMX_IOBN_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 #define CVMX_IOBN_CHIP_CUR_PWR CVMX_IOBN_CHIP_CUR_PWR_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_CUR_PWR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000068ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 #define CVMX_IOBN_CHIP_GLB_PWR_THROTTLE CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_GLB_PWR_THROTTLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000038ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 #define CVMX_IOBN_CHIP_PWR_OUT CVMX_IOBN_CHIP_PWR_OUT_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_PWR_OUT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000048ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 #define CVMX_IOBN_CONTROL CVMX_IOBN_CONTROL_FUNC()
 static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000008ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 #define CVMX_IOBN_CREDITS CVMX_IOBN_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000028ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 #define CVMX_IOBN_ECC CVMX_IOBN_ECC_FUNC()
 static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000010ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 #define CVMX_IOBN_GBL_DLL CVMX_IOBN_GBL_DLL_FUNC()
 static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_GBL_DLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0001000ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 #define CVMX_IOBN_HIGH_PRIORITY CVMX_IOBN_HIGH_PRIORITY_FUNC()
 static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_HIGH_PRIORITY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000000ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 #define CVMX_IOBN_INT_SUM CVMX_IOBN_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000020ull);
 }
@@ -167,6 +167,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_IOBN_NCBX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800F0004000ull) + ((offset) & 3) * 8;
@@ -178,7 +179,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 #define CVMX_IOBN_PP_BIST_STATUS CVMX_IOBN_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000700ull);
 }
@@ -256,7 +257,9 @@ union cvmx_iobn_bist_status {
 #endif
 	} s;
 	struct cvmx_iobn_bist_status_s        cn73xx;
+	struct cvmx_iobn_bist_status_s        cn75xx;
 	struct cvmx_iobn_bist_status_s        cn78xx;
+	struct cvmx_iobn_bist_status_s        cn78xxp2;
 };
 typedef union cvmx_iobn_bist_status cvmx_iobn_bist_status_t;
 
@@ -289,7 +292,9 @@ union cvmx_iobn_chip_cur_pwr {
 #endif
 	} s;
 	struct cvmx_iobn_chip_cur_pwr_s       cn73xx;
+	struct cvmx_iobn_chip_cur_pwr_s       cn75xx;
 	struct cvmx_iobn_chip_cur_pwr_s       cn78xx;
+	struct cvmx_iobn_chip_cur_pwr_s       cn78xxp2;
 };
 typedef union cvmx_iobn_chip_cur_pwr cvmx_iobn_chip_cur_pwr_t;
 
@@ -332,7 +337,9 @@ union cvmx_iobn_chip_glb_pwr_throttle {
 #endif
 	} s;
 	struct cvmx_iobn_chip_glb_pwr_throttle_s cn73xx;
+	struct cvmx_iobn_chip_glb_pwr_throttle_s cn75xx;
 	struct cvmx_iobn_chip_glb_pwr_throttle_s cn78xx;
+	struct cvmx_iobn_chip_glb_pwr_throttle_s cn78xxp2;
 };
 typedef union cvmx_iobn_chip_glb_pwr_throttle cvmx_iobn_chip_glb_pwr_throttle_t;
 
@@ -365,7 +372,9 @@ union cvmx_iobn_chip_pwr_out {
 #endif
 	} s;
 	struct cvmx_iobn_chip_pwr_out_s       cn73xx;
+	struct cvmx_iobn_chip_pwr_out_s       cn75xx;
 	struct cvmx_iobn_chip_pwr_out_s       cn78xx;
+	struct cvmx_iobn_chip_pwr_out_s       cn78xxp2;
 };
 typedef union cvmx_iobn_chip_pwr_out cvmx_iobn_chip_pwr_out_t;
 
@@ -387,7 +396,9 @@ union cvmx_iobn_control {
 #endif
 	} s;
 	struct cvmx_iobn_control_s            cn73xx;
+	struct cvmx_iobn_control_s            cn75xx;
 	struct cvmx_iobn_control_s            cn78xx;
+	struct cvmx_iobn_control_s            cn78xxp2;
 };
 typedef union cvmx_iobn_control cvmx_iobn_control_t;
 
@@ -445,7 +456,9 @@ union cvmx_iobn_credits {
 #endif
 	} s;
 	struct cvmx_iobn_credits_s            cn73xx;
+	struct cvmx_iobn_credits_s            cn75xx;
 	struct cvmx_iobn_credits_s            cn78xx;
+	struct cvmx_iobn_credits_s            cn78xxp2;
 };
 typedef union cvmx_iobn_credits cvmx_iobn_credits_t;
 
@@ -545,7 +558,9 @@ union cvmx_iobn_ecc {
 #endif
 	} s;
 	struct cvmx_iobn_ecc_s                cn73xx;
+	struct cvmx_iobn_ecc_s                cn75xx;
 	struct cvmx_iobn_ecc_s                cn78xx;
+	struct cvmx_iobn_ecc_s                cn78xxp2;
 };
 typedef union cvmx_iobn_ecc cvmx_iobn_ecc_t;
 
@@ -585,7 +600,9 @@ union cvmx_iobn_gbl_dll {
 #endif
 	} s;
 	struct cvmx_iobn_gbl_dll_s            cn73xx;
+	struct cvmx_iobn_gbl_dll_s            cn75xx;
 	struct cvmx_iobn_gbl_dll_s            cn78xx;
+	struct cvmx_iobn_gbl_dll_s            cn78xxp2;
 };
 typedef union cvmx_iobn_gbl_dll cvmx_iobn_gbl_dll_t;
 
@@ -612,7 +629,9 @@ union cvmx_iobn_high_priority {
 #endif
 	} s;
 	struct cvmx_iobn_high_priority_s      cn73xx;
+	struct cvmx_iobn_high_priority_s      cn75xx;
 	struct cvmx_iobn_high_priority_s      cn78xx;
+	struct cvmx_iobn_high_priority_s      cn78xxp2;
 };
 typedef union cvmx_iobn_high_priority cvmx_iobn_high_priority_t;
 
@@ -788,7 +807,9 @@ union cvmx_iobn_int_sum {
 #endif
 	} s;
 	struct cvmx_iobn_int_sum_s            cn73xx;
+	struct cvmx_iobn_int_sum_s            cn75xx;
 	struct cvmx_iobn_int_sum_s            cn78xx;
+	struct cvmx_iobn_int_sum_s            cn78xxp2;
 };
 typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
 
@@ -822,7 +843,9 @@ union cvmx_iobn_ncbx_ctl {
 #endif
 	} s;
 	struct cvmx_iobn_ncbx_ctl_s           cn73xx;
+	struct cvmx_iobn_ncbx_ctl_s           cn75xx;
 	struct cvmx_iobn_ncbx_ctl_s           cn78xx;
+	struct cvmx_iobn_ncbx_ctl_s           cn78xxp2;
 };
 typedef union cvmx_iobn_ncbx_ctl cvmx_iobn_ncbx_ctl_t;
 
@@ -846,7 +869,9 @@ union cvmx_iobn_pp_bist_status {
 #endif
 	} s;
 	struct cvmx_iobn_pp_bist_status_s     cn73xx;
+	struct cvmx_iobn_pp_bist_status_s     cn75xx;
 	struct cvmx_iobn_pp_bist_status_s     cn78xx;
+	struct cvmx_iobn_pp_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_iobn_pp_bist_status cvmx_iobn_pp_bist_status_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index b716d79..5674dd0 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBP_BIST_STATUS CVMX_IOBP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 #define CVMX_IOBP_CREDITS CVMX_IOBP_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010028ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 #define CVMX_IOBP_ECC CVMX_IOBP_ECC_FUNC()
 static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010010ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 #define CVMX_IOBP_INT_SUM CVMX_IOBP_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 #define CVMX_IOBP_PP_BIST_STATUS CVMX_IOBP_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010700ull);
 }
@@ -146,7 +146,9 @@ union cvmx_iobp_bist_status {
 #endif
 	} s;
 	struct cvmx_iobp_bist_status_s        cn73xx;
+	struct cvmx_iobp_bist_status_s        cn75xx;
 	struct cvmx_iobp_bist_status_s        cn78xx;
+	struct cvmx_iobp_bist_status_s        cn78xxp2;
 };
 typedef union cvmx_iobp_bist_status cvmx_iobp_bist_status_t;
 
@@ -180,7 +182,9 @@ union cvmx_iobp_credits {
 #endif
 	} s;
 	struct cvmx_iobp_credits_s            cn73xx;
+	struct cvmx_iobp_credits_s            cn75xx;
 	struct cvmx_iobp_credits_s            cn78xx;
+	struct cvmx_iobp_credits_s            cn78xxp2;
 };
 typedef union cvmx_iobp_credits cvmx_iobp_credits_t;
 
@@ -230,7 +234,9 @@ union cvmx_iobp_ecc {
 #endif
 	} s;
 	struct cvmx_iobp_ecc_s                cn73xx;
+	struct cvmx_iobp_ecc_s                cn75xx;
 	struct cvmx_iobp_ecc_s                cn78xx;
+	struct cvmx_iobp_ecc_s                cn78xxp2;
 };
 typedef union cvmx_iobp_ecc cvmx_iobp_ecc_t;
 
@@ -316,7 +322,9 @@ union cvmx_iobp_int_sum {
 #endif
 	} s;
 	struct cvmx_iobp_int_sum_s            cn73xx;
+	struct cvmx_iobp_int_sum_s            cn75xx;
 	struct cvmx_iobp_int_sum_s            cn78xx;
+	struct cvmx_iobp_int_sum_s            cn78xxp2;
 };
 typedef union cvmx_iobp_int_sum cvmx_iobp_int_sum_t;
 
@@ -340,7 +348,9 @@ union cvmx_iobp_pp_bist_status {
 #endif
 	} s;
 	struct cvmx_iobp_pp_bist_status_s     cn73xx;
+	struct cvmx_iobp_pp_bist_status_s     cn75xx;
 	struct cvmx_iobp_pp_bist_status_s     cn78xx;
+	struct cvmx_iobp_pp_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_iobp_pp_bist_status cvmx_iobp_pp_bist_status_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 2b0b5a6..a0677a3 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_L2C_BIG_CTL CVMX_L2C_BIG_CTL_FUNC()
 static inline uint64_t CVMX_L2C_BIG_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_BIG_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800030ull);
 }
@@ -158,6 +158,7 @@ static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((offset) & 3) * 0x40000ull;
@@ -170,6 +171,7 @@ static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((offset) & 3) * 0x40000ull;
@@ -182,6 +184,7 @@ static inline uint64_t CVMX_L2C_CBCX_HOLEERR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_HOLEERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((offset) & 3) * 0x40000ull;
@@ -195,6 +198,7 @@ static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((offset) & 3) * 0x40000ull;
@@ -208,6 +212,7 @@ static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_IOCERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((offset) & 3) * 0x40000ull;
@@ -220,6 +225,7 @@ static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_IODISOCIERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((offset) & 3) * 0x40000ull;
@@ -239,6 +245,10 @@ static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 			if ((offset == 1))
 				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 1) * 0x40000ull - 262144*1;
 			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset == 1))
+				return CVMX_ADD_IO_SEG(0x0001180080E407E0ull) - 0*1;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_CBCX_MIBERR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
@@ -251,6 +261,8 @@ static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*1;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080E407E0ull) - 0*1;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
 }
@@ -261,6 +273,7 @@ static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_RSDERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((offset) & 3) * 0x40000ull;
@@ -283,7 +296,7 @@ static inline uint64_t CVMX_L2C_CFG_FUNC(void)
 #define CVMX_L2C_COP0_ADR CVMX_L2C_COP0_ADR_FUNC()
 static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800038ull);
 }
@@ -294,7 +307,7 @@ static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 #define CVMX_L2C_COP0_DAT CVMX_L2C_COP0_DAT_FUNC()
 static inline uint64_t CVMX_L2C_COP0_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800040ull);
 }
@@ -320,7 +333,7 @@ static inline uint64_t CVMX_L2C_COP0_MAPX(unsigned long offset)
 #define CVMX_L2C_CTL CVMX_L2C_CTL_FUNC()
 static inline uint64_t CVMX_L2C_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800000ull);
 }
@@ -368,7 +381,7 @@ static inline uint64_t CVMX_L2C_DUT_MAPX(unsigned long offset)
 #define CVMX_L2C_ECC_CTL CVMX_L2C_ECC_CTL_FUNC()
 static inline uint64_t CVMX_L2C_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800010ull);
 }
@@ -503,6 +516,7 @@ static inline uint64_t CVMX_L2C_INVX_PFC(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_INVX_PFC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800820ull) + ((offset) & 7) * 64;
@@ -525,6 +539,7 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			break;
@@ -545,6 +560,7 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset __attribute__ ((un
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800420ull);
@@ -565,6 +581,7 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			break;
@@ -585,6 +602,7 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset __attribute__ ((un
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800428ull);
@@ -662,6 +680,7 @@ static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull;
@@ -675,6 +694,7 @@ static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull;
@@ -688,6 +708,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((offset) & 3) * 0x40000ull;
@@ -699,7 +720,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 #define CVMX_L2C_OCI_CTL CVMX_L2C_OCI_CTL_FUNC()
 static inline uint64_t CVMX_L2C_OCI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_OCI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800020ull);
 }
@@ -803,6 +824,7 @@ static inline uint64_t CVMX_L2C_QOS_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_QOS_IOBX(%lu) is invalid on this chip\n", offset);
@@ -821,6 +843,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_QOS_PPX(%lu) is invalid on this chip\n", offset);
@@ -833,7 +856,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 #define CVMX_L2C_QOS_WGT CVMX_L2C_QOS_WGT_FUNC()
 static inline uint64_t CVMX_L2C_QOS_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_QOS_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800008ull);
 }
@@ -864,6 +887,7 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 3) * 64;
 			break;
@@ -887,6 +911,7 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800410ull) + (offset) * 64;
@@ -916,6 +941,7 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 3) * 64;
 			break;
@@ -939,12 +965,23 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800418ull) + (offset) * 64;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_L2C_RTGX_ERR(unsigned long offset)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS2_X))
+		cvmx_warn("CVMX_L2C_RTGX_ERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00800ull) + ((offset) & 7) * 0x40000ull;
+}
+#else
+#define CVMX_L2C_RTGX_ERR(offset) (CVMX_ADD_IO_SEG(0x0001180080A00800ull) + ((offset) & 7) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_SPAR0 CVMX_L2C_SPAR0_FUNC()
 static inline uint64_t CVMX_L2C_SPAR0_FUNC(void)
 {
@@ -1005,6 +1042,7 @@ static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((offset) & 7) * 0x40000ull;
@@ -1048,6 +1086,7 @@ static inline uint64_t CVMX_L2C_TADX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((offset) & 7) * 0x40000ull;
@@ -1080,6 +1119,7 @@ static inline uint64_t CVMX_L2C_TADX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_INT(%lu) is invalid on this chip\n", offset);
@@ -1154,6 +1194,7 @@ static inline uint64_t CVMX_L2C_TADX_PFCX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_L2C_TADX_PFCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A00400ull) + (((offset) & 3) + ((block_id) & 7) * 0x8000ull) * 8;
@@ -1171,6 +1212,7 @@ static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_PRF(%lu) is invalid on this chip\n", offset);
@@ -1183,12 +1225,13 @@ static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long offset)
 static inline uint64_t CVMX_L2C_TADX_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TADX_STAT(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull;
+	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long offset)
@@ -1200,6 +1243,7 @@ static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_TAG(%lu) is invalid on this chip\n", offset);
@@ -1213,6 +1257,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMEOUT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((offset) & 7) * 0x40000ull;
@@ -1225,6 +1270,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMETWO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((offset) & 7) * 0x40000ull;
@@ -1236,7 +1282,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long offset)
 #define CVMX_L2C_TAD_CTL CVMX_L2C_TAD_CTL_FUNC()
 static inline uint64_t CVMX_L2C_TAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_TAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800018ull);
 }
@@ -1249,6 +1295,7 @@ static inline uint64_t CVMX_L2C_TBFX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TBFX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((offset) & 7) * 0x40000ull;
@@ -1262,6 +1309,7 @@ static inline uint64_t CVMX_L2C_TDTX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TDTX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((offset) & 7) * 0x40000ull;
@@ -1275,6 +1323,7 @@ static inline uint64_t CVMX_L2C_TQDX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TQDX_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((offset) & 7) * 0x40000ull;
@@ -1288,6 +1337,7 @@ static inline uint64_t CVMX_L2C_TTGX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TTGX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((offset) & 7) * 0x40000ull;
@@ -1301,6 +1351,7 @@ static inline uint64_t CVMX_L2C_TTGX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_TTGX_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((offset) & 7) * 0x40000ull;
@@ -1418,6 +1469,7 @@ static inline uint64_t CVMX_L2C_WPAR_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_WPAR_IOBX(%lu) is invalid on this chip\n", offset);
@@ -1436,6 +1488,7 @@ static inline uint64_t CVMX_L2C_WPAR_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_WPAR_PPX(%lu) is invalid on this chip\n", offset);
@@ -1468,6 +1521,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 3) * 64;
 			break;
@@ -1491,6 +1545,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800400ull) + (offset) * 64;
@@ -1500,7 +1555,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 #define CVMX_L2C_XMC_CMD CVMX_L2C_XMC_CMD_FUNC()
 static inline uint64_t CVMX_L2C_XMC_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_XMC_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800028ull);
 }
@@ -1531,6 +1586,7 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 3) * 64;
 			break;
@@ -1554,6 +1610,7 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800408ull) + (offset) * 64;
@@ -1666,7 +1723,9 @@ union cvmx_l2c_big_ctl {
 	} cn70xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn70xxp1;
 	struct cvmx_l2c_big_ctl_cn70xx        cn73xx;
+	struct cvmx_l2c_big_ctl_cn70xx        cn75xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn78xx;
+	struct cvmx_l2c_big_ctl_cn70xx        cn78xxp2;
 	struct cvmx_l2c_big_ctl_cn61xx        cnf71xx;
 };
 typedef union cvmx_l2c_big_ctl cvmx_l2c_big_ctl_t;
@@ -2417,7 +2476,9 @@ union cvmx_l2c_cbcx_bist_status {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_cbcx_bist_status_cn73xx cn75xx;
 	struct cvmx_l2c_cbcx_bist_status_cn73xx cn78xx;
+	struct cvmx_l2c_cbcx_bist_status_cn73xx cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_bist_status cvmx_l2c_cbcx_bist_status_t;
 
@@ -2453,7 +2514,9 @@ union cvmx_l2c_cbcx_dll {
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_dll_s            cn73xx;
+	struct cvmx_l2c_cbcx_dll_s            cn75xx;
 	struct cvmx_l2c_cbcx_dll_s            cn78xx;
+	struct cvmx_l2c_cbcx_dll_s            cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_dll cvmx_l2c_cbcx_dll_t;
 
@@ -2491,7 +2554,9 @@ union cvmx_l2c_cbcx_holeerr {
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_holeerr_s        cn73xx;
+	struct cvmx_l2c_cbcx_holeerr_s        cn75xx;
 	struct cvmx_l2c_cbcx_holeerr_s        cn78xx;
+	struct cvmx_l2c_cbcx_holeerr_s        cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_holeerr cvmx_l2c_cbcx_holeerr_t;
 
@@ -2575,7 +2640,9 @@ union cvmx_l2c_cbcx_int {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_cbcx_int_cn73xx       cn75xx;
 	struct cvmx_l2c_cbcx_int_cn73xx       cn78xx;
+	struct cvmx_l2c_cbcx_int_cn73xx       cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_int cvmx_l2c_cbcx_int_t;
 
@@ -2613,7 +2680,9 @@ union cvmx_l2c_cbcx_iocerr {
 	uint64_t reserved_0_63                : 64;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_cbcx_iocerr_cn73xx    cn75xx;
 	struct cvmx_l2c_cbcx_iocerr_cn73xx    cn78xx;
+	struct cvmx_l2c_cbcx_iocerr_cn73xx    cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_iocerr cvmx_l2c_cbcx_iocerr_t;
 
@@ -2627,8 +2696,8 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t u64;
 	struct cvmx_l2c_cbcx_iodisocierr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iorddisoci                   : 1;  /**< Reserved. */
-	uint64_t iowrdisoci                   : 1;  /**< Reserved. */
+	uint64_t iorddisoci                   : 1;  /**< Logged information is for a IORDDISOCI error. Added in pass 2. */
+	uint64_t iowrdisoci                   : 1;  /**< Logged information is for a IOWRDISOCI error. Added in pass 2. */
 	uint64_t reserved_59_61               : 3;
 	uint64_t cmd                          : 7;  /**< Encoding of XMC command.  INTERNAL: Enumerated by XMC_CMD_E. */
 	uint64_t ppvid                        : 6;  /**< CMB source PPVID. */
@@ -2647,7 +2716,9 @@ union cvmx_l2c_cbcx_iodisocierr {
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_iodisocierr_s    cn73xx;
+	struct cvmx_l2c_cbcx_iodisocierr_s    cn75xx;
 	struct cvmx_l2c_cbcx_iodisocierr_s    cn78xx;
+	struct cvmx_l2c_cbcx_iodisocierr_s    cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_iodisocierr cvmx_l2c_cbcx_iodisocierr_t;
 
@@ -2683,7 +2754,9 @@ union cvmx_l2c_cbcx_miberr {
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_miberr_s         cn73xx;
+	struct cvmx_l2c_cbcx_miberr_s         cn75xx;
 	struct cvmx_l2c_cbcx_miberr_s         cn78xx;
+	struct cvmx_l2c_cbcx_miberr_s         cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_miberr cvmx_l2c_cbcx_miberr_t;
 
@@ -2723,7 +2796,9 @@ union cvmx_l2c_cbcx_rsderr {
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xxp1;
 	struct cvmx_l2c_cbcx_rsderr_s         cn73xx;
+	struct cvmx_l2c_cbcx_rsderr_s         cn75xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn78xx;
+	struct cvmx_l2c_cbcx_rsderr_s         cn78xxp2;
 };
 typedef union cvmx_l2c_cbcx_rsderr cvmx_l2c_cbcx_rsderr_t;
 
@@ -3435,7 +3510,9 @@ union cvmx_l2c_cop0_adr {
 	struct cvmx_l2c_cop0_adr_s            cn70xx;
 	struct cvmx_l2c_cop0_adr_s            cn70xxp1;
 	struct cvmx_l2c_cop0_adr_s            cn73xx;
+	struct cvmx_l2c_cop0_adr_s            cn75xx;
 	struct cvmx_l2c_cop0_adr_s            cn78xx;
+	struct cvmx_l2c_cop0_adr_s            cn78xxp2;
 };
 typedef union cvmx_l2c_cop0_adr cvmx_l2c_cop0_adr_t;
 
@@ -3457,7 +3534,9 @@ union cvmx_l2c_cop0_dat {
 	struct cvmx_l2c_cop0_dat_s            cn70xx;
 	struct cvmx_l2c_cop0_dat_s            cn70xxp1;
 	struct cvmx_l2c_cop0_dat_s            cn73xx;
+	struct cvmx_l2c_cop0_dat_s            cn75xx;
 	struct cvmx_l2c_cop0_dat_s            cn78xx;
+	struct cvmx_l2c_cop0_dat_s            cn78xxp2;
 };
 typedef union cvmx_l2c_cop0_dat cvmx_l2c_cop0_dat_t;
 
@@ -3995,7 +4074,9 @@ union cvmx_l2c_ctl {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_ctl_cn73xx            cn75xx;
 	struct cvmx_l2c_ctl_cn73xx            cn78xx;
+	struct cvmx_l2c_ctl_cn73xx            cn78xxp2;
 	struct cvmx_l2c_ctl_cn61xx            cnf71xx;
 };
 typedef union cvmx_l2c_ctl cvmx_l2c_ctl_t;
@@ -4707,7 +4788,9 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_ecc_ctl_cn73xx        cn75xx;
 	struct cvmx_l2c_ecc_ctl_cn73xx        cn78xx;
+	struct cvmx_l2c_ecc_ctl_cn73xx        cn78xxp2;
 };
 typedef union cvmx_l2c_ecc_ctl cvmx_l2c_ecc_ctl_t;
 
@@ -5553,7 +5636,9 @@ union cvmx_l2c_invx_pfc {
 	struct cvmx_l2c_invx_pfc_s            cn70xx;
 	struct cvmx_l2c_invx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_invx_pfc_s            cn73xx;
+	struct cvmx_l2c_invx_pfc_s            cn75xx;
 	struct cvmx_l2c_invx_pfc_s            cn78xx;
+	struct cvmx_l2c_invx_pfc_s            cn78xxp2;
 };
 typedef union cvmx_l2c_invx_pfc cvmx_l2c_invx_pfc_t;
 
@@ -5581,7 +5666,9 @@ union cvmx_l2c_iocx_pfc {
 	struct cvmx_l2c_iocx_pfc_s            cn70xx;
 	struct cvmx_l2c_iocx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_iocx_pfc_s            cn73xx;
+	struct cvmx_l2c_iocx_pfc_s            cn75xx;
 	struct cvmx_l2c_iocx_pfc_s            cn78xx;
+	struct cvmx_l2c_iocx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_iocx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_iocx_pfc cvmx_l2c_iocx_pfc_t;
@@ -5610,7 +5697,9 @@ union cvmx_l2c_iorx_pfc {
 	struct cvmx_l2c_iorx_pfc_s            cn70xx;
 	struct cvmx_l2c_iorx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_iorx_pfc_s            cn73xx;
+	struct cvmx_l2c_iorx_pfc_s            cn75xx;
 	struct cvmx_l2c_iorx_pfc_s            cn78xx;
+	struct cvmx_l2c_iorx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_iorx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_iorx_pfc cvmx_l2c_iorx_pfc_t;
@@ -6166,7 +6255,9 @@ union cvmx_l2c_mcix_bist_status {
 	struct cvmx_l2c_mcix_bist_status_s    cn70xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn70xxp1;
 	struct cvmx_l2c_mcix_bist_status_s    cn73xx;
+	struct cvmx_l2c_mcix_bist_status_s    cn75xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn78xx;
+	struct cvmx_l2c_mcix_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_l2c_mcix_bist_status cvmx_l2c_mcix_bist_status_t;
 
@@ -6212,7 +6303,9 @@ union cvmx_l2c_mcix_err {
 	struct cvmx_l2c_mcix_err_s            cn70xx;
 	struct cvmx_l2c_mcix_err_s            cn70xxp1;
 	struct cvmx_l2c_mcix_err_s            cn73xx;
+	struct cvmx_l2c_mcix_err_s            cn75xx;
 	struct cvmx_l2c_mcix_err_s            cn78xx;
+	struct cvmx_l2c_mcix_err_s            cn78xxp2;
 };
 typedef union cvmx_l2c_mcix_err cvmx_l2c_mcix_err_t;
 
@@ -6238,7 +6331,9 @@ union cvmx_l2c_mcix_int {
 	struct cvmx_l2c_mcix_int_s            cn70xx;
 	struct cvmx_l2c_mcix_int_s            cn70xxp1;
 	struct cvmx_l2c_mcix_int_s            cn73xx;
+	struct cvmx_l2c_mcix_int_s            cn75xx;
 	struct cvmx_l2c_mcix_int_s            cn78xx;
+	struct cvmx_l2c_mcix_int_s            cn78xxp2;
 };
 typedef union cvmx_l2c_mcix_int cvmx_l2c_mcix_int_t;
 
@@ -6249,7 +6344,10 @@ union cvmx_l2c_oci_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_oci_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_30_63               : 34;
+	uint64_t reserved_31_63               : 33;
+	uint64_t ncpend                       : 1;  /**< An indication that a node change is pending.  Hardware sets this bit when
+                                                         OCX_COM_NODE[ID] is changed and clears the bit when the node change has taken
+                                                         effect.  Added in pass 2. */
 	uint64_t lock_local_cas               : 1;  /**< When set, L2 CAS operations to remote addresses which miss at the requester will be
                                                          performed locally (if possible) on the requesting node. Default operation will instead
                                                          send the CAS request to be performed on the home node. For STC ops LOCK_LOCAL_STC. */
@@ -6306,13 +6404,14 @@ union cvmx_l2c_oci_ctl {
                                                          software. */
 	uint64_t enaoci                       : 4;  /**< Enable CCPI processing (one bit per node_id). When set, perform CCPI
                                                          processing. When clear, CCPI memory writes are blocked and CCPI memory reads
-                                                         return unpredictable data. When clear,
-                                                         CCPI I/O requests and MOC references are processed and sent to OCX where they are
-                                                         ultimately discarded. RDDISOCI/WRDISOCI/IORDDISOCI/IOWRDISOCI interrupts occur if and only
-                                                         if the corresponding ENAOCI<node> bit is clear. References to the local node (configured
-                                                         via OCX_COM_NODE[ID]) ignore the value of ENAOCI<node> because no CCPI processing is
-                                                         required. Similarly, all I/O references ignore the value of ENAOCI when
-                                                         L2C_OCI_CTL[IOFRCL] is set. */
+                                                         return unpredictable data. When clear, CCPI I/O requests and MOC references are
+                                                         processed and sent to OCX where they are ultimately
+                                                         discarded. RDDISOCI/WRDISOCI/IORDDISOCI/IOWRDISOCI interrupts occur if and only
+                                                         if the corresponding ENAOCI<node> bit is clear. References to the local node
+                                                         (configured via OCX_COM_NODE[ID]) ignore the value of ENAOCI<node> because no
+                                                         CCPI processing is required. Similarly, all I/O references ignore the value of
+                                                         ENAOCI when L2C_OCI_CTL[IOFRCL] is set.
+                                                         Changed in pass 2. */
 #else
 	uint64_t enaoci                       : 4;
 	uint64_t gksegnode                    : 2;
@@ -6329,11 +6428,50 @@ union cvmx_l2c_oci_ctl {
 	uint64_t lock_local_pp                : 1;
 	uint64_t lock_local_stc               : 1;
 	uint64_t lock_local_cas               : 1;
-	uint64_t reserved_30_63               : 34;
+	uint64_t ncpend                       : 1;
+	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
-	struct cvmx_l2c_oci_ctl_s             cn73xx;
-	struct cvmx_l2c_oci_ctl_s             cn78xx;
+	struct cvmx_l2c_oci_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t lock_local_cas               : 1;  /**< Reserved. */
+	uint64_t lock_local_stc               : 1;  /**< Reserved. */
+	uint64_t lock_local_pp                : 1;  /**< Reserved. */
+	uint64_t lngtolen                     : 5;  /**< Reserved. */
+	uint64_t shtolen                      : 5;  /**< Reserved. */
+	uint64_t shtoioen                     : 1;  /**< Reserved. */
+	uint64_t shtoen                       : 3;  /**< Reserved. */
+	uint64_t shto                         : 1;  /**< Reserved. */
+	uint64_t inv_mode                     : 2;  /**< Reserved. */
+	uint64_t cas_fdx                      : 1;  /**< Reserved. */
+	uint64_t rldd_psha                    : 1;  /**< Reserved. */
+	uint64_t lock_local_iob               : 1;  /**< Reserved. */
+	uint64_t iofrcl                       : 1;  /**< Reserved. */
+	uint64_t gksegnode                    : 2;  /**< Reserved. */
+	uint64_t enaoci                       : 4;  /**< CCPI is not present. Any attempt to enable it will be ignored. */
+#else
+	uint64_t enaoci                       : 4;
+	uint64_t gksegnode                    : 2;
+	uint64_t iofrcl                       : 1;
+	uint64_t lock_local_iob               : 1;
+	uint64_t rldd_psha                    : 1;
+	uint64_t cas_fdx                      : 1;
+	uint64_t inv_mode                     : 2;
+	uint64_t shto                         : 1;
+	uint64_t shtoen                       : 3;
+	uint64_t shtoioen                     : 1;
+	uint64_t shtolen                      : 5;
+	uint64_t lngtolen                     : 5;
+	uint64_t lock_local_pp                : 1;
+	uint64_t lock_local_stc               : 1;
+	uint64_t lock_local_cas               : 1;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} cn73xx;
+	struct cvmx_l2c_oci_ctl_cn73xx        cn75xx;
+	struct cvmx_l2c_oci_ctl_cn73xx        cn78xx;
+	struct cvmx_l2c_oci_ctl_s             cn78xxp2;
 };
 typedef union cvmx_l2c_oci_ctl cvmx_l2c_oci_ctl_t;
 
@@ -6838,7 +6976,9 @@ union cvmx_l2c_qos_iobx {
 	struct cvmx_l2c_qos_iobx_s            cn70xx;
 	struct cvmx_l2c_qos_iobx_s            cn70xxp1;
 	struct cvmx_l2c_qos_iobx_s            cn73xx;
+	struct cvmx_l2c_qos_iobx_s            cn75xx;
 	struct cvmx_l2c_qos_iobx_s            cn78xx;
+	struct cvmx_l2c_qos_iobx_s            cn78xxp2;
 	struct cvmx_l2c_qos_iobx_cn61xx       cnf71xx;
 };
 typedef union cvmx_l2c_qos_iobx cvmx_l2c_qos_iobx_t;
@@ -6878,7 +7018,9 @@ union cvmx_l2c_qos_ppx {
 	struct cvmx_l2c_qos_ppx_s             cn70xx;
 	struct cvmx_l2c_qos_ppx_s             cn70xxp1;
 	struct cvmx_l2c_qos_ppx_s             cn73xx;
+	struct cvmx_l2c_qos_ppx_s             cn75xx;
 	struct cvmx_l2c_qos_ppx_s             cn78xx;
+	struct cvmx_l2c_qos_ppx_s             cn78xxp2;
 	struct cvmx_l2c_qos_ppx_cn61xx        cnf71xx;
 };
 typedef union cvmx_l2c_qos_ppx cvmx_l2c_qos_ppx_t;
@@ -6935,7 +7077,9 @@ union cvmx_l2c_qos_wgt {
 	struct cvmx_l2c_qos_wgt_s             cn70xx;
 	struct cvmx_l2c_qos_wgt_s             cn70xxp1;
 	struct cvmx_l2c_qos_wgt_s             cn73xx;
+	struct cvmx_l2c_qos_wgt_s             cn75xx;
 	struct cvmx_l2c_qos_wgt_s             cn78xx;
+	struct cvmx_l2c_qos_wgt_s             cn78xxp2;
 	struct cvmx_l2c_qos_wgt_cn61xx        cnf71xx;
 };
 typedef union cvmx_l2c_qos_wgt cvmx_l2c_qos_wgt_t;
@@ -6964,7 +7108,9 @@ union cvmx_l2c_rscx_pfc {
 	struct cvmx_l2c_rscx_pfc_s            cn70xx;
 	struct cvmx_l2c_rscx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_rscx_pfc_s            cn73xx;
+	struct cvmx_l2c_rscx_pfc_s            cn75xx;
 	struct cvmx_l2c_rscx_pfc_s            cn78xx;
+	struct cvmx_l2c_rscx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_rscx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_rscx_pfc cvmx_l2c_rscx_pfc_t;
@@ -6993,12 +7139,51 @@ union cvmx_l2c_rsdx_pfc {
 	struct cvmx_l2c_rsdx_pfc_s            cn70xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_rsdx_pfc_s            cn73xx;
+	struct cvmx_l2c_rsdx_pfc_s            cn75xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn78xx;
+	struct cvmx_l2c_rsdx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_rsdx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_rsdx_pfc cvmx_l2c_rsdx_pfc_t;
 
 /**
+ * cvmx_l2c_rtg#_err
+ *
+ * This register records error information for all RTG SBE/DBE errors.
+ * The priority of errors (lowest to highest) is SBE, DBE. An error locks the SYN, WAY,
+ * and L2IDX fields for equal or lower priority errors until cleared by software.
+ * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
+ * L2IDX[19:7] is the L2 block index associated with the command which had no way to allocate.
+ * Added in pass 2.
+ */
+union cvmx_l2c_rtgx_err {
+	uint64_t u64;
+	struct cvmx_l2c_rtgx_err_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t rtgdbe                       : 1;  /**< Information refers to a double-bit RTG ECC error. */
+	uint64_t rtgsbe                       : 1;  /**< Information refers to a single-bit RTG ECC error. */
+	uint64_t reserved_39_61               : 23;
+	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t way                          : 4;  /**< Way of the L2 block containing the error */
+	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error */
+	uint64_t reserved_0_6                 : 7;
+#else
+	uint64_t reserved_0_6                 : 7;
+	uint64_t l2idx                        : 13;
+	uint64_t way                          : 4;
+	uint64_t reserved_24_31               : 8;
+	uint64_t syn                          : 7;
+	uint64_t reserved_39_61               : 23;
+	uint64_t rtgsbe                       : 1;
+	uint64_t rtgdbe                       : 1;
+#endif
+	} s;
+	struct cvmx_l2c_rtgx_err_s            cn78xxp2;
+};
+typedef union cvmx_l2c_rtgx_err cvmx_l2c_rtgx_err_t;
+
+/**
  * cvmx_l2c_spar0
  *
  * L2C_SPAR0 = L2 Set Partitioning Register (PP0-3)
@@ -7284,7 +7469,9 @@ union cvmx_l2c_tadx_dll {
 	} cn70xx;
 	struct cvmx_l2c_tadx_dll_cn70xx       cn70xxp1;
 	struct cvmx_l2c_tadx_dll_s            cn73xx;
+	struct cvmx_l2c_tadx_dll_s            cn75xx;
 	struct cvmx_l2c_tadx_dll_s            cn78xx;
+	struct cvmx_l2c_tadx_dll_s            cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_dll cvmx_l2c_tadx_dll_t;
 
@@ -7461,7 +7648,9 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigrd                        : 1;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_tadx_err_cn73xx       cn75xx;
 	struct cvmx_l2c_tadx_err_cn73xx       cn78xx;
+	struct cvmx_l2c_tadx_err_cn73xx       cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_err cvmx_l2c_tadx_err_t;
 
@@ -7777,7 +7966,9 @@ union cvmx_l2c_tadx_int {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_tadx_int_cn73xx       cn75xx;
 	struct cvmx_l2c_tadx_int_cn73xx       cn78xx;
+	struct cvmx_l2c_tadx_int_cn73xx       cn78xxp2;
 	struct cvmx_l2c_tadx_int_cn61xx       cnf71xx;
 };
 typedef union cvmx_l2c_tadx_int cvmx_l2c_tadx_int_t;
@@ -7797,7 +7988,9 @@ union cvmx_l2c_tadx_pfcx {
 	struct cvmx_l2c_tadx_pfcx_s           cn70xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn70xxp1;
 	struct cvmx_l2c_tadx_pfcx_s           cn73xx;
+	struct cvmx_l2c_tadx_pfcx_s           cn75xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn78xx;
+	struct cvmx_l2c_tadx_pfcx_s           cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_pfcx cvmx_l2c_tadx_pfcx_t;
 
@@ -7933,7 +8126,9 @@ union cvmx_l2c_tadx_prf {
 	struct cvmx_l2c_tadx_prf_s            cn70xx;
 	struct cvmx_l2c_tadx_prf_s            cn70xxp1;
 	struct cvmx_l2c_tadx_prf_s            cn73xx;
+	struct cvmx_l2c_tadx_prf_s            cn75xx;
 	struct cvmx_l2c_tadx_prf_s            cn78xx;
+	struct cvmx_l2c_tadx_prf_s            cn78xxp2;
 	struct cvmx_l2c_tadx_prf_s            cnf71xx;
 };
 typedef union cvmx_l2c_tadx_prf cvmx_l2c_tadx_prf_t;
@@ -7960,6 +8155,8 @@ union cvmx_l2c_tadx_stat {
 #endif
 	} s;
 	struct cvmx_l2c_tadx_stat_s           cn73xx;
+	struct cvmx_l2c_tadx_stat_s           cn75xx;
+	struct cvmx_l2c_tadx_stat_s           cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_stat cvmx_l2c_tadx_stat_t;
 
@@ -8092,6 +8289,7 @@ union cvmx_l2c_tadx_tag {
 	uint64_t sblkdty                      : 4;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_tadx_tag_cn73xx       cn75xx;
 	struct cvmx_l2c_tadx_tag_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. Ignored/loaded with 0 for RTG accesses. If TS is Invalid (0) SBLKDTY
@@ -8127,6 +8325,7 @@ union cvmx_l2c_tadx_tag {
 	uint64_t sblkdty                      : 4;
 #endif
 	} cn78xx;
+	struct cvmx_l2c_tadx_tag_cn78xx       cn78xxp2;
 	struct cvmx_l2c_tadx_tag_cn61xx       cnf71xx;
 };
 typedef union cvmx_l2c_tadx_tag cvmx_l2c_tadx_tag_t;
@@ -8175,7 +8374,9 @@ union cvmx_l2c_tadx_timeout {
 #endif
 	} s;
 	struct cvmx_l2c_tadx_timeout_s        cn73xx;
+	struct cvmx_l2c_tadx_timeout_s        cn75xx;
 	struct cvmx_l2c_tadx_timeout_s        cn78xx;
+	struct cvmx_l2c_tadx_timeout_s        cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_timeout cvmx_l2c_tadx_timeout_t;
 
@@ -8210,7 +8411,9 @@ union cvmx_l2c_tadx_timetwo {
 #endif
 	} s;
 	struct cvmx_l2c_tadx_timetwo_s        cn73xx;
+	struct cvmx_l2c_tadx_timetwo_s        cn75xx;
 	struct cvmx_l2c_tadx_timetwo_s        cn78xx;
+	struct cvmx_l2c_tadx_timetwo_s        cn78xxp2;
 };
 typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
 
@@ -8225,8 +8428,10 @@ union cvmx_l2c_tad_ctl {
 	struct cvmx_l2c_tad_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
-	uint64_t frcnalc                      : 1;  /**< Reserved. */
-	uint64_t disrstp                      : 1;  /**< When set, if the L2 receives an RSTP XMC command, it treats it as a STP. */
+	uint64_t frcnalc                      : 1;  /**< When set, all cache accesses are forced to not allocate in the local L2.
+                                                         Added in pass 2. */
+	uint64_t disrstp                      : 1;  /**< When set, if the L2 receives an RSTP XMC command, it treats it as a STP.
+                                                         Added in pass 2. */
 	uint64_t wtlmcwrdn                    : 1;  /**< Be more conservative with LFB done relative to LMC writes. */
 	uint64_t wtinvdn                      : 1;  /**< Be more conservative with LFB done relative to invalidates. */
 	uint64_t wtfilldn                     : 1;  /**< Be more conservative with LFB done relative to fills. */
@@ -8278,7 +8483,9 @@ union cvmx_l2c_tad_ctl {
 	} cn70xx;
 	struct cvmx_l2c_tad_ctl_cn70xx        cn70xxp1;
 	struct cvmx_l2c_tad_ctl_s             cn73xx;
+	struct cvmx_l2c_tad_ctl_s             cn75xx;
 	struct cvmx_l2c_tad_ctl_s             cn78xx;
+	struct cvmx_l2c_tad_ctl_s             cn78xxp2;
 };
 typedef union cvmx_l2c_tad_ctl cvmx_l2c_tad_ctl_t;
 
@@ -8303,7 +8510,9 @@ union cvmx_l2c_tbfx_bist_status {
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xxp1;
 	struct cvmx_l2c_tbfx_bist_status_s    cn73xx;
+	struct cvmx_l2c_tbfx_bist_status_s    cn75xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn78xx;
+	struct cvmx_l2c_tbfx_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_l2c_tbfx_bist_status cvmx_l2c_tbfx_bist_status_t;
 
@@ -8324,7 +8533,9 @@ union cvmx_l2c_tdtx_bist_status {
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xxp1;
 	struct cvmx_l2c_tdtx_bist_status_s    cn73xx;
+	struct cvmx_l2c_tdtx_bist_status_s    cn75xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn78xx;
+	struct cvmx_l2c_tdtx_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_l2c_tdtx_bist_status cvmx_l2c_tdtx_bist_status_t;
 
@@ -8372,7 +8583,9 @@ union cvmx_l2c_tqdx_err {
 	struct cvmx_l2c_tqdx_err_s            cn70xx;
 	struct cvmx_l2c_tqdx_err_s            cn70xxp1;
 	struct cvmx_l2c_tqdx_err_s            cn73xx;
+	struct cvmx_l2c_tqdx_err_s            cn75xx;
 	struct cvmx_l2c_tqdx_err_s            cn78xx;
+	struct cvmx_l2c_tqdx_err_s            cn78xxp2;
 };
 typedef union cvmx_l2c_tqdx_err cvmx_l2c_tqdx_err_t;
 
@@ -8419,7 +8632,9 @@ union cvmx_l2c_ttgx_bist_status {
 	} cn70xx;
 	struct cvmx_l2c_ttgx_bist_status_cn70xx cn70xxp1;
 	struct cvmx_l2c_ttgx_bist_status_s    cn73xx;
+	struct cvmx_l2c_ttgx_bist_status_s    cn75xx;
 	struct cvmx_l2c_ttgx_bist_status_s    cn78xx;
+	struct cvmx_l2c_ttgx_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_l2c_ttgx_bist_status cvmx_l2c_ttgx_bist_status_t;
 
@@ -8499,6 +8714,7 @@ union cvmx_l2c_ttgx_err {
 	uint64_t tagdbe                       : 1;
 #endif
 	} cn73xx;
+	struct cvmx_l2c_ttgx_err_cn73xx       cn75xx;
 	struct cvmx_l2c_ttgx_err_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tagdbe                       : 1;  /**< Information refers to a double-bit TAG ECC error. */
@@ -8522,6 +8738,7 @@ union cvmx_l2c_ttgx_err {
 	uint64_t tagdbe                       : 1;
 #endif
 	} cn78xx;
+	struct cvmx_l2c_ttgx_err_cn78xx       cn78xxp2;
 };
 typedef union cvmx_l2c_ttgx_err cvmx_l2c_ttgx_err_t;
 
@@ -8901,7 +9118,9 @@ union cvmx_l2c_wpar_iobx {
 	} cn70xx;
 	struct cvmx_l2c_wpar_iobx_cn70xx      cn70xxp1;
 	struct cvmx_l2c_wpar_iobx_s           cn73xx;
+	struct cvmx_l2c_wpar_iobx_s           cn75xx;
 	struct cvmx_l2c_wpar_iobx_s           cn78xx;
+	struct cvmx_l2c_wpar_iobx_s           cn78xxp2;
 	struct cvmx_l2c_wpar_iobx_s           cnf71xx;
 };
 typedef union cvmx_l2c_wpar_iobx cvmx_l2c_wpar_iobx_t;
@@ -8945,7 +9164,9 @@ union cvmx_l2c_wpar_ppx {
 	} cn70xx;
 	struct cvmx_l2c_wpar_ppx_cn70xx       cn70xxp1;
 	struct cvmx_l2c_wpar_ppx_s            cn73xx;
+	struct cvmx_l2c_wpar_ppx_s            cn75xx;
 	struct cvmx_l2c_wpar_ppx_s            cn78xx;
+	struct cvmx_l2c_wpar_ppx_s            cn78xxp2;
 	struct cvmx_l2c_wpar_ppx_s            cnf71xx;
 };
 typedef union cvmx_l2c_wpar_ppx cvmx_l2c_wpar_ppx_t;
@@ -8974,7 +9195,9 @@ union cvmx_l2c_xmcx_pfc {
 	struct cvmx_l2c_xmcx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_xmcx_pfc_s            cn73xx;
+	struct cvmx_l2c_xmcx_pfc_s            cn75xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn78xx;
+	struct cvmx_l2c_xmcx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_xmcx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_xmcx_pfc cvmx_l2c_xmcx_pfc_t;
@@ -9077,7 +9300,9 @@ union cvmx_l2c_xmc_cmd {
 	} cn70xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn70xxp1;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn73xx;
+	struct cvmx_l2c_xmc_cmd_cn70xx        cn75xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn78xx;
+	struct cvmx_l2c_xmc_cmd_cn70xx        cn78xxp2;
 	struct cvmx_l2c_xmc_cmd_cn61xx        cnf71xx;
 };
 typedef union cvmx_l2c_xmc_cmd cvmx_l2c_xmc_cmd_t;
@@ -9106,7 +9331,9 @@ union cvmx_l2c_xmdx_pfc {
 	struct cvmx_l2c_xmdx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn70xxp1;
 	struct cvmx_l2c_xmdx_pfc_s            cn73xx;
+	struct cvmx_l2c_xmdx_pfc_s            cn75xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn78xx;
+	struct cvmx_l2c_xmdx_pfc_s            cn78xxp2;
 	struct cvmx_l2c_xmdx_pfc_s            cnf71xx;
 };
 typedef union cvmx_l2c_xmdx_pfc cvmx_l2c_xmdx_pfc_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 131a6d0..ab38b7d 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -303,6 +303,7 @@ union cvmx_lapx_bist_result {
 #endif
 	} s;
 	struct cvmx_lapx_bist_result_s        cn78xx;
+	struct cvmx_lapx_bist_result_s        cn78xxp2;
 };
 typedef union cvmx_lapx_bist_result cvmx_lapx_bist_result_t;
 
@@ -352,6 +353,7 @@ union cvmx_lapx_cfg {
 #endif
 	} s;
 	struct cvmx_lapx_cfg_s                cn78xx;
+	struct cvmx_lapx_cfg_s                cn78xxp2;
 };
 typedef union cvmx_lapx_cfg cvmx_lapx_cfg_t;
 
@@ -379,6 +381,7 @@ union cvmx_lapx_edat_err_st {
 #endif
 	} s;
 	struct cvmx_lapx_edat_err_st_s        cn78xx;
+	struct cvmx_lapx_edat_err_st_s        cn78xxp2;
 };
 typedef union cvmx_lapx_edat_err_st cvmx_lapx_edat_err_st_t;
 
@@ -406,6 +409,7 @@ union cvmx_lapx_emsk_err_st {
 #endif
 	} s;
 	struct cvmx_lapx_emsk_err_st_s        cn78xx;
+	struct cvmx_lapx_emsk_err_st_s        cn78xxp2;
 };
 typedef union cvmx_lapx_emsk_err_st cvmx_lapx_emsk_err_st_t;
 
@@ -454,6 +458,7 @@ union cvmx_lapx_err_cfg {
 #endif
 	} s;
 	struct cvmx_lapx_err_cfg_s            cn78xx;
+	struct cvmx_lapx_err_cfg_s            cn78xxp2;
 };
 typedef union cvmx_lapx_err_cfg cvmx_lapx_err_cfg_t;
 
@@ -474,6 +479,7 @@ union cvmx_lapx_expx_data {
 #endif
 	} s;
 	struct cvmx_lapx_expx_data_s          cn78xx;
+	struct cvmx_lapx_expx_data_s          cn78xxp2;
 };
 typedef union cvmx_lapx_expx_data cvmx_lapx_expx_data_t;
 
@@ -497,6 +503,7 @@ union cvmx_lapx_expx_valid {
 #endif
 	} s;
 	struct cvmx_lapx_expx_valid_s         cn78xx;
+	struct cvmx_lapx_expx_valid_s         cn78xxp2;
 };
 typedef union cvmx_lapx_expx_valid cvmx_lapx_expx_valid_t;
 
@@ -526,6 +533,7 @@ union cvmx_lapx_free_state {
 #endif
 	} s;
 	struct cvmx_lapx_free_state_s         cn78xx;
+	struct cvmx_lapx_free_state_s         cn78xxp2;
 };
 typedef union cvmx_lapx_free_state cvmx_lapx_free_state_t;
 
@@ -600,6 +608,7 @@ union cvmx_lapx_gen_int {
 #endif
 	} s;
 	struct cvmx_lapx_gen_int_s            cn78xx;
+	struct cvmx_lapx_gen_int_s            cn78xxp2;
 };
 typedef union cvmx_lapx_gen_int cvmx_lapx_gen_int_t;
 
@@ -634,6 +643,7 @@ union cvmx_lapx_labx_state {
 #endif
 	} s;
 	struct cvmx_lapx_labx_state_s         cn78xx;
+	struct cvmx_lapx_labx_state_s         cn78xxp2;
 };
 typedef union cvmx_lapx_labx_state cvmx_lapx_labx_state_t;
 
@@ -653,6 +663,7 @@ union cvmx_lapx_lab_datax {
 #endif
 	} s;
 	struct cvmx_lapx_lab_datax_s          cn78xx;
+	struct cvmx_lapx_lab_datax_s          cn78xxp2;
 };
 typedef union cvmx_lapx_lab_datax cvmx_lapx_lab_datax_t;
 
@@ -678,6 +689,7 @@ union cvmx_lapx_lab_err_st {
 #endif
 	} s;
 	struct cvmx_lapx_lab_err_st_s         cn78xx;
+	struct cvmx_lapx_lab_err_st_s         cn78xxp2;
 };
 typedef union cvmx_lapx_lab_err_st cvmx_lapx_lab_err_st_t;
 
@@ -705,6 +717,7 @@ union cvmx_lapx_nxt_err_st {
 #endif
 	} s;
 	struct cvmx_lapx_nxt_err_st_s         cn78xx;
+	struct cvmx_lapx_nxt_err_st_s         cn78xxp2;
 };
 typedef union cvmx_lapx_nxt_err_st cvmx_lapx_nxt_err_st_t;
 
@@ -727,6 +740,7 @@ union cvmx_lapx_quex_cfg {
 #endif
 	} s;
 	struct cvmx_lapx_quex_cfg_s           cn78xx;
+	struct cvmx_lapx_quex_cfg_s           cn78xxp2;
 };
 typedef union cvmx_lapx_quex_cfg cvmx_lapx_quex_cfg_t;
 
@@ -765,6 +779,7 @@ union cvmx_lapx_quex_state {
 #endif
 	} s;
 	struct cvmx_lapx_quex_state_s         cn78xx;
+	struct cvmx_lapx_quex_state_s         cn78xxp2;
 };
 typedef union cvmx_lapx_quex_state cvmx_lapx_quex_state_t;
 
@@ -794,6 +809,7 @@ union cvmx_lapx_resp_state {
 #endif
 	} s;
 	struct cvmx_lapx_resp_state_s         cn78xx;
+	struct cvmx_lapx_resp_state_s         cn78xxp2;
 };
 typedef union cvmx_lapx_resp_state cvmx_lapx_resp_state_t;
 
@@ -816,6 +832,7 @@ union cvmx_lapx_sft_rst {
 #endif
 	} s;
 	struct cvmx_lapx_sft_rst_s            cn78xx;
+	struct cvmx_lapx_sft_rst_s            cn78xxp2;
 };
 typedef union cvmx_lapx_sft_rst cvmx_lapx_sft_rst_t;
 
@@ -841,6 +858,7 @@ union cvmx_lapx_sta_err_st {
 #endif
 	} s;
 	struct cvmx_lapx_sta_err_st_s         cn78xx;
+	struct cvmx_lapx_sta_err_st_s         cn78xxp2;
 };
 typedef union cvmx_lapx_sta_err_st cvmx_lapx_sta_err_st_t;
 
@@ -875,6 +893,7 @@ union cvmx_lapx_timeout {
 #endif
 	} s;
 	struct cvmx_lapx_timeout_s            cn78xx;
+	struct cvmx_lapx_timeout_s            cn78xxp2;
 };
 typedef union cvmx_lapx_timeout cvmx_lapx_timeout_t;
 
@@ -919,6 +938,7 @@ union cvmx_lapx_xid_pos {
 #endif
 	} s;
 	struct cvmx_lapx_xid_pos_s            cn78xx;
+	struct cvmx_lapx_xid_pos_s            cn78xxp2;
 };
 typedef union cvmx_lapx_xid_pos cvmx_lapx_xid_pos_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
index f1ec6ad..a8bc242 100644
--- a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_LBK_BIST_RESULT CVMX_LBK_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000020ull);
 }
@@ -68,6 +68,7 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_LBK_CHX_PKIND(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180012000200ull) + ((offset) & 63) * 8;
@@ -79,7 +80,7 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 #define CVMX_LBK_CLK_GATE_CTL CVMX_LBK_CLK_GATE_CTL_FUNC()
 static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_CLK_GATE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000008ull);
 }
@@ -90,7 +91,7 @@ static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
 #define CVMX_LBK_DAT_ERR_INFO CVMX_LBK_DAT_ERR_INFO_FUNC()
 static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_DAT_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000050ull);
 }
@@ -101,7 +102,7 @@ static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 #define CVMX_LBK_ECC_CFG CVMX_LBK_ECC_CFG_FUNC()
 static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_ECC_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000060ull);
 }
@@ -112,7 +113,7 @@ static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 #define CVMX_LBK_INT CVMX_LBK_INT_FUNC()
 static inline uint64_t CVMX_LBK_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000040ull);
 }
@@ -123,7 +124,7 @@ static inline uint64_t CVMX_LBK_INT_FUNC(void)
 #define CVMX_LBK_SFT_RST CVMX_LBK_SFT_RST_FUNC()
 static inline uint64_t CVMX_LBK_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000000ull);
 }
@@ -149,7 +150,9 @@ union cvmx_lbk_bist_result {
 #endif
 	} s;
 	struct cvmx_lbk_bist_result_s         cn73xx;
+	struct cvmx_lbk_bist_result_s         cn75xx;
 	struct cvmx_lbk_bist_result_s         cn78xx;
+	struct cvmx_lbk_bist_result_s         cn78xxp2;
 };
 typedef union cvmx_lbk_bist_result cvmx_lbk_bist_result_t;
 
@@ -168,7 +171,9 @@ union cvmx_lbk_chx_pkind {
 #endif
 	} s;
 	struct cvmx_lbk_chx_pkind_s           cn73xx;
+	struct cvmx_lbk_chx_pkind_s           cn75xx;
 	struct cvmx_lbk_chx_pkind_s           cn78xx;
+	struct cvmx_lbk_chx_pkind_s           cn78xxp2;
 };
 typedef union cvmx_lbk_chx_pkind cvmx_lbk_chx_pkind_t;
 
@@ -190,6 +195,9 @@ union cvmx_lbk_clk_gate_ctl {
 #endif
 	} s;
 	struct cvmx_lbk_clk_gate_ctl_s        cn73xx;
+	struct cvmx_lbk_clk_gate_ctl_s        cn75xx;
+	struct cvmx_lbk_clk_gate_ctl_s        cn78xx;
+	struct cvmx_lbk_clk_gate_ctl_s        cn78xxp2;
 };
 typedef union cvmx_lbk_clk_gate_ctl cvmx_lbk_clk_gate_ctl_t;
 
@@ -226,7 +234,9 @@ union cvmx_lbk_dat_err_info {
 #endif
 	} s;
 	struct cvmx_lbk_dat_err_info_s        cn73xx;
+	struct cvmx_lbk_dat_err_info_s        cn75xx;
 	struct cvmx_lbk_dat_err_info_s        cn78xx;
+	struct cvmx_lbk_dat_err_info_s        cn78xxp2;
 };
 typedef union cvmx_lbk_dat_err_info cvmx_lbk_dat_err_info_t;
 
@@ -248,7 +258,9 @@ union cvmx_lbk_ecc_cfg {
 #endif
 	} s;
 	struct cvmx_lbk_ecc_cfg_s             cn73xx;
+	struct cvmx_lbk_ecc_cfg_s             cn75xx;
 	struct cvmx_lbk_ecc_cfg_s             cn78xx;
+	struct cvmx_lbk_ecc_cfg_s             cn78xxp2;
 };
 typedef union cvmx_lbk_ecc_cfg cvmx_lbk_ecc_cfg_t;
 
@@ -281,7 +293,9 @@ union cvmx_lbk_int {
 #endif
 	} s;
 	struct cvmx_lbk_int_s                 cn73xx;
+	struct cvmx_lbk_int_s                 cn75xx;
 	struct cvmx_lbk_int_s                 cn78xx;
+	struct cvmx_lbk_int_s                 cn78xxp2;
 };
 typedef union cvmx_lbk_int cvmx_lbk_int_t;
 
@@ -300,7 +314,9 @@ union cvmx_lbk_sft_rst {
 #endif
 	} s;
 	struct cvmx_lbk_sft_rst_s             cn73xx;
+	struct cvmx_lbk_sft_rst_s             cn75xx;
 	struct cvmx_lbk_sft_rst_s             cn78xx;
+	struct cvmx_lbk_sft_rst_s             cn78xxp2;
 };
 typedef union cvmx_lbk_sft_rst cvmx_lbk_sft_rst_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 86bd5a1..22527b8 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -74,6 +74,7 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 1) * 0x1000000ull;
 			break;
@@ -95,6 +96,7 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
@@ -123,6 +125,7 @@ static inline uint64_t CVMX_LMCX_CHAR_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_CTL(%lu) is invalid on this chip\n", offset);
@@ -137,6 +140,7 @@ static inline uint64_t CVMX_LMCX_CHAR_DQ_ERR_COUNT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_CHAR_DQ_ERR_COUNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((offset) & 3) * 0x1000000ull;
@@ -154,6 +158,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK0(%lu) is invalid on this chip\n", offset);
@@ -172,6 +177,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK1(%lu) is invalid on this chip\n", offset);
@@ -190,6 +196,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK2(%lu) is invalid on this chip\n", offset);
@@ -208,6 +215,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK3(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK3(%lu) is invalid on this chip\n", offset);
@@ -226,6 +234,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK4(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK4(%lu) is invalid on this chip\n", offset);
@@ -261,6 +270,7 @@ static inline uint64_t CVMX_LMCX_COMP_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_COMP_CTL2(%lu) is invalid on this chip\n", offset);
@@ -279,6 +289,7 @@ static inline uint64_t CVMX_LMCX_CONFIG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CONFIG(%lu) is invalid on this chip\n", offset);
@@ -297,6 +308,7 @@ static inline uint64_t CVMX_LMCX_CONTROL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_CONTROL(%lu) is invalid on this chip\n", offset);
@@ -341,12 +353,13 @@ static inline uint64_t CVMX_LMCX_CTL1(unsigned long offset)
 static inline uint64_t CVMX_LMCX_DBTRAIN_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_DBTRAIN_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DBTRAIN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_DBTRAIN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long offset)
@@ -358,6 +371,7 @@ static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_DCLK_CNT(%lu) is invalid on this chip\n", offset);
@@ -434,6 +448,7 @@ static inline uint64_t CVMX_LMCX_DDR4_DIMM_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_DDR4_DIMM_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((offset) & 3) * 0x1000000ull;
@@ -451,6 +466,7 @@ static inline uint64_t CVMX_LMCX_DDR_PLL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_DDR_PLL_CTL(%lu) is invalid on this chip\n", offset);
@@ -481,6 +497,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS0(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800880000D0ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -494,6 +511,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS1(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000140ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -511,6 +529,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_PARAMS(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_PARAMS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -529,6 +548,7 @@ static inline uint64_t CVMX_LMCX_DIMM_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_DIMM_CTL(%lu) is invalid on this chip\n", offset);
@@ -559,6 +579,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_DLL_CTL2(%lu) is invalid on this chip\n", offset);
@@ -577,6 +598,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL3(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_DLL_CTL3(%lu) is invalid on this chip\n", offset);
@@ -610,6 +632,7 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 1) * 0x1000000ull;
 			break;
@@ -636,6 +659,7 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x60000000ull;
@@ -646,6 +670,7 @@ static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((offset) & 3) * 0x1000000ull;
@@ -677,6 +702,7 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 1) * 0x1000000ull;
 			break;
@@ -708,6 +734,7 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x60000000ull;
@@ -721,6 +748,7 @@ static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_EXT_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((offset) & 3) * 0x1000000ull;
@@ -732,12 +760,13 @@ static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long offset)
 static inline uint64_t CVMX_LMCX_EXT_CONFIG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_EXT_CONFIG2(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_EXT_CONFIG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_EXT_CONFIG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
@@ -763,6 +792,7 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 1) * 0x1000000ull;
 			break;
@@ -794,6 +824,7 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x60000000ull;
@@ -805,34 +836,37 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE0(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_GENERAL_PURPOSE0(offset) (CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_GENERAL_PURPOSE0(offset) (CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE1(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_GENERAL_PURPOSE1(offset) (CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_GENERAL_PURPOSE1(offset) (CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE2(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_GENERAL_PURPOSE2(offset) (CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_GENERAL_PURPOSE2(offset) (CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long offset)
@@ -844,6 +878,7 @@ static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_IFB_CNT(%lu) is invalid on this chip\n", offset);
@@ -896,6 +931,7 @@ static inline uint64_t CVMX_LMCX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_INT(%lu) is invalid on this chip\n", offset);
@@ -914,6 +950,7 @@ static inline uint64_t CVMX_LMCX_INT_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_INT_EN(%lu) is invalid on this chip\n", offset);
@@ -927,6 +964,7 @@ static inline uint64_t CVMX_LMCX_LANEX_CRC_SWIZ(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 8)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_LANEX_CRC_SWIZ(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000380ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -978,6 +1016,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS0(%lu) is invalid on this chip\n", offset);
@@ -996,6 +1035,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS1(%lu) is invalid on this chip\n", offset);
@@ -1010,6 +1050,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((offset) & 3) * 0x1000000ull;
@@ -1023,6 +1064,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS3(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((offset) & 3) * 0x1000000ull;
@@ -1036,6 +1078,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA0(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((offset) & 3) * 0x1000000ull;
@@ -1049,6 +1092,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA1(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((offset) & 3) * 0x1000000ull;
@@ -1062,6 +1106,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((offset) & 3) * 0x1000000ull;
@@ -1075,6 +1120,7 @@ static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_MR_MPR_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((offset) & 3) * 0x1000000ull;
@@ -1086,12 +1132,13 @@ static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long offset)
 static inline uint64_t CVMX_LMCX_NS_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_NS_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_NS_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_NS_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
@@ -1117,6 +1164,7 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 1) * 0x1000000ull;
 			break;
@@ -1142,6 +1190,7 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x60000000ull;
@@ -1153,6 +1202,7 @@ static inline uint64_t CVMX_LMCX_NXM_FADR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_NXM_FADR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((offset) & 3) * 0x1000000ull;
@@ -1170,6 +1220,7 @@ static inline uint64_t CVMX_LMCX_OPS_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_OPS_CNT(%lu) is invalid on this chip\n", offset);
@@ -1222,6 +1273,7 @@ static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_PHY_CTL(%lu) is invalid on this chip\n", offset);
@@ -1275,12 +1327,13 @@ static inline uint64_t CVMX_LMCX_PLL_STATUS(unsigned long offset)
 static inline uint64_t CVMX_LMCX_PPR_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_PPR_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_PPR_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_PPR_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_READ_LEVEL_CTL(unsigned long offset)
@@ -1322,12 +1375,13 @@ static inline uint64_t CVMX_LMCX_READ_LEVEL_RANKX(unsigned long offset, unsigned
 static inline uint64_t CVMX_LMCX_REF_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_REF_STATUS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_REF_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_REF_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long offset)
@@ -1339,6 +1393,7 @@ static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_RESET_CTL(%lu) is invalid on this chip\n", offset);
@@ -1351,23 +1406,25 @@ static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long offset)
 static inline uint64_t CVMX_LMCX_RETRY_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_RETRY_CONFIG(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RETRY_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_RETRY_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RETRY_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_RETRY_STATUS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RETRY_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_RETRY_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long offset)
@@ -1379,6 +1436,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_CTL(%lu) is invalid on this chip\n", offset);
@@ -1397,6 +1455,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_DBG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_DBG(%lu) is invalid on this chip\n", offset);
@@ -1415,6 +1474,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_RANKX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1464,6 +1524,7 @@ static inline uint64_t CVMX_LMCX_RODT_MASK(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_RODT_MASK(%lu) is invalid on this chip\n", offset);
@@ -1480,6 +1541,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLED_FADR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLED_FADR(%lu) is invalid on this chip\n", offset);
@@ -1496,6 +1558,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG0(%lu) is invalid on this chip\n", offset);
@@ -1512,6 +1575,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG1(%lu) is invalid on this chip\n", offset);
@@ -1524,12 +1588,13 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long offset)
 static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG2(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SCRAMBLE_CFG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_SCRAMBLE_CFG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long offset)
@@ -1537,6 +1602,7 @@ static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_SEQ_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((offset) & 3) * 0x1000000ull;
@@ -1554,6 +1620,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL0(%lu) is invalid on this chip\n", offset);
@@ -1572,6 +1639,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL1(%lu) is invalid on this chip\n", offset);
@@ -1590,6 +1658,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL2(%lu) is invalid on this chip\n", offset);
@@ -1602,12 +1671,13 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long offset)
 static inline uint64_t CVMX_LMCX_SLOT_CTL3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL3(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SLOT_CTL3(offset) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_LMCX_SLOT_CTL3(offset) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long offset)
@@ -1619,6 +1689,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS0(%lu) is invalid on this chip\n", offset);
@@ -1637,6 +1708,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS1(%lu) is invalid on this chip\n", offset);
@@ -1651,6 +1723,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((offset) & 3) * 0x1000000ull;
@@ -1698,6 +1771,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_WLEVEL_CTL(%lu) is invalid on this chip\n", offset);
@@ -1716,6 +1790,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_DBG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_WLEVEL_DBG(%lu) is invalid on this chip\n", offset);
@@ -1751,6 +1826,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if (((offset <= 3)) && ((block_id <= 1)))
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8;
 			break;
@@ -1775,6 +1851,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800880002B0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
@@ -1821,6 +1898,7 @@ static inline uint64_t CVMX_LMCX_WODT_MASK(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_LMCX_WODT_MASK(%lu) is invalid on this chip\n", offset);
@@ -1841,7 +1919,9 @@ union cvmx_lmcx_bist_ctl {
 	struct cvmx_lmcx_bist_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t macram_bist_status           : 1;  /**< Reserved. */
+	uint64_t macram_bist_status           : 1;  /**< Added in pass 2.0.
+                                                         Maximum Activate Counts RAM BIST status.
+                                                         1 means fail. */
 	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
 	uint64_t dlcram_bist_done             : 1;  /**< DLC and MAC RAM BIST complete indication;
                                                          1 means both RAMs have completed. */
@@ -1904,7 +1984,9 @@ union cvmx_lmcx_bist_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_bist_ctl_cn73xx      cn75xx;
 	struct cvmx_lmcx_bist_ctl_cn73xx      cn78xx;
+	struct cvmx_lmcx_bist_ctl_cn73xx      cn78xxp2;
 };
 typedef union cvmx_lmcx_bist_ctl cvmx_lmcx_bist_ctl_t;
 
@@ -1972,7 +2054,10 @@ union cvmx_lmcx_char_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_char_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
+	uint64_t reserved_54_63               : 10;
+	uint64_t dq_char_byte_check           : 1;  /**< Added in pass 2.0.
+                                                         When set, LMC perform loopback pattern check on a byte. The selection of the byte is
+                                                         controlled by the LMC()_CHAR_CTL[CSR DQ_CHAR_BYTE_SEL]. */
 	uint64_t dq_char_check_lock           : 1;  /**< Indicates if a lock has been achieved. Is set to 1 only if a lock is achieved during the
                                                          LFSR priming period after DQ_CHAR_CHECK_ENABLE is set to 1, and is forced back to 0 when
                                                          DQ_CHAR_CHECK_ENABLE is set to 0. */
@@ -1999,7 +2084,8 @@ union cvmx_lmcx_char_ctl {
 	uint64_t dq_char_bit_sel              : 3;
 	uint64_t dq_char_check_enable         : 1;
 	uint64_t dq_char_check_lock           : 1;
-	uint64_t reserved_53_63               : 11;
+	uint64_t dq_char_byte_check           : 1;
+	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
 	struct cvmx_lmcx_char_ctl_cn61xx {
@@ -2044,10 +2130,41 @@ union cvmx_lmcx_char_ctl {
 	struct cvmx_lmcx_char_ctl_cn61xx      cn66xx;
 	struct cvmx_lmcx_char_ctl_cn61xx      cn68xx;
 	struct cvmx_lmcx_char_ctl_cn63xx      cn68xxp1;
-	struct cvmx_lmcx_char_ctl_s           cn70xx;
-	struct cvmx_lmcx_char_ctl_s           cn70xxp1;
+	struct cvmx_lmcx_char_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_53_63               : 11;
+	uint64_t dq_char_check_lock           : 1;  /**< Indicates if a lock has been achieved. Is set to 1 only if a lock is achieved during the
+                                                         LFSR priming period after DQ_CHAR_CHECK_ENABLE is set to 1, and is forced back to 0 when
+                                                         DQ_CHAR_CHECK_ENABLE is set to 0. */
+	uint64_t dq_char_check_enable         : 1;  /**< Enable DQ pattern check. The transition from disabled to enabled clears
+                                                         LMC(0..0)_CHAR_DQ_ERR_COUNT. */
+	uint64_t dq_char_bit_sel              : 3;  /**< Select a bit within the byte for DQ characterization pattern check. */
+	uint64_t dq_char_byte_sel             : 4;  /**< Select a byte of data for DQ characterization pattern check. */
+	uint64_t dr                           : 1;  /**< Pattern at data rate (not clock rate). */
+	uint64_t skew_on                      : 1;  /**< Skew adjacent bits. */
+	uint64_t en                           : 1;  /**< Enable characterization. */
+	uint64_t sel                          : 1;  /**< Pattern select: 0 = PRBS, 1 = programmable pattern. */
+	uint64_t prog                         : 8;  /**< Programmable pattern. */
+	uint64_t prbs                         : 32; /**< PRBS polynomial. */
+#else
+	uint64_t prbs                         : 32;
+	uint64_t prog                         : 8;
+	uint64_t sel                          : 1;
+	uint64_t en                           : 1;
+	uint64_t skew_on                      : 1;
+	uint64_t dr                           : 1;
+	uint64_t dq_char_byte_sel             : 4;
+	uint64_t dq_char_bit_sel              : 3;
+	uint64_t dq_char_check_enable         : 1;
+	uint64_t dq_char_check_lock           : 1;
+	uint64_t reserved_53_63               : 11;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_char_ctl_cn70xx      cn70xxp1;
 	struct cvmx_lmcx_char_ctl_s           cn73xx;
+	struct cvmx_lmcx_char_ctl_s           cn75xx;
 	struct cvmx_lmcx_char_ctl_s           cn78xx;
+	struct cvmx_lmcx_char_ctl_s           cn78xxp2;
 	struct cvmx_lmcx_char_ctl_cn61xx      cnf71xx;
 };
 typedef union cvmx_lmcx_char_ctl cvmx_lmcx_char_ctl_t;
@@ -2072,7 +2189,9 @@ union cvmx_lmcx_char_dq_err_count {
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xxp1;
 	struct cvmx_lmcx_char_dq_err_count_s  cn73xx;
+	struct cvmx_lmcx_char_dq_err_count_s  cn75xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn78xx;
+	struct cvmx_lmcx_char_dq_err_count_s  cn78xxp2;
 };
 typedef union cvmx_lmcx_char_dq_err_count cvmx_lmcx_char_dq_err_count_t;
 
@@ -2100,7 +2219,9 @@ union cvmx_lmcx_char_mask0 {
 	struct cvmx_lmcx_char_mask0_s         cn70xx;
 	struct cvmx_lmcx_char_mask0_s         cn70xxp1;
 	struct cvmx_lmcx_char_mask0_s         cn73xx;
+	struct cvmx_lmcx_char_mask0_s         cn75xx;
 	struct cvmx_lmcx_char_mask0_s         cn78xx;
+	struct cvmx_lmcx_char_mask0_s         cn78xxp2;
 	struct cvmx_lmcx_char_mask0_s         cnf71xx;
 };
 typedef union cvmx_lmcx_char_mask0 cvmx_lmcx_char_mask0_t;
@@ -2131,7 +2252,9 @@ union cvmx_lmcx_char_mask1 {
 	struct cvmx_lmcx_char_mask1_s         cn70xx;
 	struct cvmx_lmcx_char_mask1_s         cn70xxp1;
 	struct cvmx_lmcx_char_mask1_s         cn73xx;
+	struct cvmx_lmcx_char_mask1_s         cn75xx;
 	struct cvmx_lmcx_char_mask1_s         cn78xx;
+	struct cvmx_lmcx_char_mask1_s         cn78xxp2;
 	struct cvmx_lmcx_char_mask1_s         cnf71xx;
 };
 typedef union cvmx_lmcx_char_mask1 cvmx_lmcx_char_mask1_t;
@@ -2160,7 +2283,9 @@ union cvmx_lmcx_char_mask2 {
 	struct cvmx_lmcx_char_mask2_s         cn70xx;
 	struct cvmx_lmcx_char_mask2_s         cn70xxp1;
 	struct cvmx_lmcx_char_mask2_s         cn73xx;
+	struct cvmx_lmcx_char_mask2_s         cn75xx;
 	struct cvmx_lmcx_char_mask2_s         cn78xx;
+	struct cvmx_lmcx_char_mask2_s         cn78xxp2;
 	struct cvmx_lmcx_char_mask2_s         cnf71xx;
 };
 typedef union cvmx_lmcx_char_mask2 cvmx_lmcx_char_mask2_t;
@@ -2191,7 +2316,9 @@ union cvmx_lmcx_char_mask3 {
 	struct cvmx_lmcx_char_mask3_s         cn70xx;
 	struct cvmx_lmcx_char_mask3_s         cn70xxp1;
 	struct cvmx_lmcx_char_mask3_s         cn73xx;
+	struct cvmx_lmcx_char_mask3_s         cn75xx;
 	struct cvmx_lmcx_char_mask3_s         cn78xx;
+	struct cvmx_lmcx_char_mask3_s         cn78xxp2;
 	struct cvmx_lmcx_char_mask3_s         cnf71xx;
 };
 typedef union cvmx_lmcx_char_mask3 cvmx_lmcx_char_mask3_t;
@@ -2326,7 +2453,9 @@ union cvmx_lmcx_char_mask4 {
 	} cn70xx;
 	struct cvmx_lmcx_char_mask4_cn70xx    cn70xxp1;
 	struct cvmx_lmcx_char_mask4_s         cn73xx;
+	struct cvmx_lmcx_char_mask4_s         cn75xx;
 	struct cvmx_lmcx_char_mask4_s         cn78xx;
+	struct cvmx_lmcx_char_mask4_s         cn78xxp2;
 	struct cvmx_lmcx_char_mask4_cn61xx    cnf71xx;
 };
 typedef union cvmx_lmcx_char_mask4 cvmx_lmcx_char_mask4_t;
@@ -2679,7 +2808,9 @@ union cvmx_lmcx_comp_ctl2 {
 	} cn70xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn70xxp1;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn73xx;
+	struct cvmx_lmcx_comp_ctl2_cn70xx     cn75xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn78xx;
+	struct cvmx_lmcx_comp_ctl2_cn70xx     cn78xxp2;
 	struct cvmx_lmcx_comp_ctl2_cn61xx     cnf71xx;
 };
 typedef union cvmx_lmcx_comp_ctl2 cvmx_lmcx_comp_ctl2_t;
@@ -2702,7 +2833,8 @@ union cvmx_lmcx_config {
 	uint64_t u64;
 	struct cvmx_lmcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lrdimm_ena                   : 1;  /**< Reserved. */
+	uint64_t lrdimm_ena                   : 1;  /**< Added in pass 2.0.
+                                                         Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
 	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
@@ -4234,7 +4366,9 @@ union cvmx_lmcx_config {
 	uint64_t lrdimm_ena                   : 1;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_config_cn73xx        cn75xx;
 	struct cvmx_lmcx_config_cn73xx        cn78xx;
+	struct cvmx_lmcx_config_cn73xx        cn78xxp2;
 	struct cvmx_lmcx_config_cn61xx        cnf71xx;
 };
 typedef union cvmx_lmcx_config cvmx_lmcx_config_t;
@@ -4647,7 +4781,9 @@ union cvmx_lmcx_control {
 	struct cvmx_lmcx_control_s            cn70xx;
 	struct cvmx_lmcx_control_s            cn70xxp1;
 	struct cvmx_lmcx_control_s            cn73xx;
+	struct cvmx_lmcx_control_s            cn75xx;
 	struct cvmx_lmcx_control_s            cn78xx;
+	struct cvmx_lmcx_control_s            cn78xxp2;
 	struct cvmx_lmcx_control_cn66xx       cnf71xx;
 };
 typedef union cvmx_lmcx_control cvmx_lmcx_control_t;
@@ -5576,6 +5712,8 @@ union cvmx_lmcx_dbtrain_ctl {
 #endif
 	} s;
 	struct cvmx_lmcx_dbtrain_ctl_s        cn73xx;
+	struct cvmx_lmcx_dbtrain_ctl_s        cn75xx;
+	struct cvmx_lmcx_dbtrain_ctl_s        cn78xxp2;
 };
 typedef union cvmx_lmcx_dbtrain_ctl cvmx_lmcx_dbtrain_ctl_t;
 
@@ -5604,7 +5742,9 @@ union cvmx_lmcx_dclk_cnt {
 	struct cvmx_lmcx_dclk_cnt_s           cn70xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn70xxp1;
 	struct cvmx_lmcx_dclk_cnt_s           cn73xx;
+	struct cvmx_lmcx_dclk_cnt_s           cn75xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn78xx;
+	struct cvmx_lmcx_dclk_cnt_s           cn78xxp2;
 	struct cvmx_lmcx_dclk_cnt_s           cnf71xx;
 };
 typedef union cvmx_lmcx_dclk_cnt cvmx_lmcx_dclk_cnt_t;
@@ -5976,12 +6116,23 @@ union cvmx_lmcx_ddr4_dimm_ctl {
 	struct cvmx_lmcx_ddr4_dimm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t rank_timing_enable           : 1;  /**< Reserved. */
-	uint64_t bodt_trans_mode              : 1;  /**< Reserved. */
-	uint64_t trans_mode_ena               : 1;  /**< Reserved. */
-	uint64_t read_preamble_mode           : 1;  /**< Reserved. */
-	uint64_t buff_config_da3              : 1;  /**< Reserved. */
-	uint64_t mpr_over_ena                 : 1;  /**< Reserved. */
+	uint64_t rank_timing_enable           : 1;  /**< Added in pass 2.0.
+                                                         Package Rank Timing Alignment Enable bit for the DDR4 LRDIMM Buffer Configuration Control
+                                                         Word F0BC1x DA[7]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t bodt_trans_mode              : 1;  /**< Added in pass 2.0.
+                                                         BODT input handling in Transparent Mode for the DDR4 LRDIMM Buffer Conifguration Control
+                                                         Word F0BC1x. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t trans_mode_ena               : 1;  /**< Added in pass 2.0.
+                                                         Transparent Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[5]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t read_preamble_mode           : 1;  /**< Added in pass 2.0.
+                                                         Read Preamble Training Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[4]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t buff_config_da3              : 1;  /**< Added in pass 2.0.
+                                                         Reserved setting value in F0BC1x DA3. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t mpr_over_ena                 : 1;  /**< Added in pass 2.0.
+                                                         MPR Override Mode Enable bit for the DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[1]. Used during PBA BCW Write through the MRW sequence. */
 	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
 	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
 #else
@@ -6009,7 +6160,9 @@ union cvmx_lmcx_ddr4_dimm_ctl {
 	} cn70xx;
 	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx cn70xxp1;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn73xx;
+	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn75xx;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn78xx;
+	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn78xxp2;
 };
 typedef union cvmx_lmcx_ddr4_dimm_ctl cvmx_lmcx_ddr4_dimm_ctl_t;
 
@@ -6042,7 +6195,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	struct cvmx_lmcx_ddr_pll_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_45_63               : 19;
-	uint64_t dclk_alt_refclk_sel          : 1;  /**< Reserved. */
+	uint64_t dclk_alt_refclk_sel          : 1;  /**< Added in pass 2.0.
+                                                         Select alternate reference clock for DCLK PLL. */
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
@@ -6254,7 +6408,9 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_45_63               : 19;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_ddr_pll_ctl_cn73xx   cn75xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn73xx   cn78xx;
+	struct cvmx_lmcx_ddr_pll_ctl_cn73xx   cn78xxp2;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx   cnf71xx;
 };
 typedef union cvmx_lmcx_ddr_pll_ctl cvmx_lmcx_ddr_pll_ctl_t;
@@ -6361,7 +6517,9 @@ union cvmx_lmcx_dimmx_ddr4_params0 {
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xxp1;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn73xx;
+	struct cvmx_lmcx_dimmx_ddr4_params0_s cn75xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn78xx;
+	struct cvmx_lmcx_dimmx_ddr4_params0_s cn78xxp2;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params0 cvmx_lmcx_dimmx_ddr4_params0_t;
 
@@ -6389,7 +6547,9 @@ union cvmx_lmcx_dimmx_ddr4_params1 {
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xxp1;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn73xx;
+	struct cvmx_lmcx_dimmx_ddr4_params1_s cn75xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn78xx;
+	struct cvmx_lmcx_dimmx_ddr4_params1_s cn78xxp2;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params1 cvmx_lmcx_dimmx_ddr4_params1_t;
 
@@ -6451,7 +6611,9 @@ union cvmx_lmcx_dimmx_params {
 	struct cvmx_lmcx_dimmx_params_s       cn70xx;
 	struct cvmx_lmcx_dimmx_params_s       cn70xxp1;
 	struct cvmx_lmcx_dimmx_params_s       cn73xx;
+	struct cvmx_lmcx_dimmx_params_s       cn75xx;
 	struct cvmx_lmcx_dimmx_params_s       cn78xx;
+	struct cvmx_lmcx_dimmx_params_s       cn78xxp2;
 	struct cvmx_lmcx_dimmx_params_s       cnf71xx;
 };
 typedef union cvmx_lmcx_dimmx_params cvmx_lmcx_dimmx_params_t;
@@ -6509,7 +6671,9 @@ union cvmx_lmcx_dimm_ctl {
 	struct cvmx_lmcx_dimm_ctl_s           cn70xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn70xxp1;
 	struct cvmx_lmcx_dimm_ctl_s           cn73xx;
+	struct cvmx_lmcx_dimm_ctl_s           cn75xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn78xx;
+	struct cvmx_lmcx_dimm_ctl_s           cn78xxp2;
 	struct cvmx_lmcx_dimm_ctl_s           cnf71xx;
 };
 typedef union cvmx_lmcx_dimm_ctl cvmx_lmcx_dimm_ctl_t;
@@ -6669,7 +6833,9 @@ union cvmx_lmcx_dll_ctl2 {
 	} cn70xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn70xxp1;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn73xx;
+	struct cvmx_lmcx_dll_ctl2_cn70xx      cn75xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn78xx;
+	struct cvmx_lmcx_dll_ctl2_cn70xx      cn78xxp2;
 	struct cvmx_lmcx_dll_ctl2_cn61xx      cnf71xx;
 };
 typedef union cvmx_lmcx_dll_ctl2 cvmx_lmcx_dll_ctl2_t;
@@ -6685,9 +6851,24 @@ union cvmx_lmcx_dll_ctl3 {
 	struct cvmx_lmcx_dll_ctl3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t wr_deskew_ena                : 1;  /**< Reserved. */
-	uint64_t wr_deskew_ld                 : 1;  /**< Reserved. */
-	uint64_t bit_select                   : 4;  /**< Reserved. */
+	uint64_t wr_deskew_ena                : 1;  /**< Added in pass 2.0.
+                                                         When set, it enables the write bit deskew feature. */
+	uint64_t wr_deskew_ld                 : 1;  /**< Added in pass 2.0.
+                                                         When set, the bit deskew settings in DLL_CTL3[OFFSET] gets loaded to
+                                                         the designated byte DLL_CTL3[BYTE_SEL] and bit DLL_CTL3[BIT_SELECT]
+                                                         for write bit deskew. This is a oneshot and clears itself each time
+                                                         it is set. */
+	uint64_t bit_select                   : 4;  /**< Added in pass 2.0.
+                                                         0x0-0x7 = Selects bit0-bit8 for write deskew setting assignment.
+                                                         0x8 = Selects dbi for write deskew setting assignment.
+                                                         0x9 = No-Op
+                                                         0xA = Reuse deskew setting on.
+                                                         0xB = Reuse deskew setting off.
+                                                         0xC = Vref bypass setting load.
+                                                         0xD = Vref bypass on.
+                                                         0xE = Vref bypass off.
+                                                         0xF = Bit select reset. Clear write deskew settings to default value 0x40 in each DQ bit.
+                                                         Also sets Vref bypass to off and deskew reuse setting to off. */
 	uint64_t reserved_0_43                : 44;
 #else
 	uint64_t reserved_0_43                : 44;
@@ -6945,7 +7126,9 @@ union cvmx_lmcx_dll_ctl3 {
 	uint64_t reserved_50_63               : 14;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_dll_ctl3_cn73xx      cn75xx;
 	struct cvmx_lmcx_dll_ctl3_cn73xx      cn78xx;
+	struct cvmx_lmcx_dll_ctl3_cn73xx      cn78xxp2;
 	struct cvmx_lmcx_dll_ctl3_cn61xx      cnf71xx;
 };
 typedef union cvmx_lmcx_dll_ctl3 cvmx_lmcx_dll_ctl3_t;
@@ -7043,7 +7226,9 @@ union cvmx_lmcx_dual_memcfg {
 	} cn70xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn70xxp1;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn73xx;
+	struct cvmx_lmcx_dual_memcfg_cn70xx   cn75xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn78xx;
+	struct cvmx_lmcx_dual_memcfg_cn70xx   cn78xxp2;
 	struct cvmx_lmcx_dual_memcfg_cn61xx   cnf71xx;
 };
 typedef union cvmx_lmcx_dual_memcfg cvmx_lmcx_dual_memcfg_t;
@@ -7081,7 +7266,9 @@ union cvmx_lmcx_ecc_parity_test {
 #endif
 	} s;
 	struct cvmx_lmcx_ecc_parity_test_s    cn73xx;
+	struct cvmx_lmcx_ecc_parity_test_s    cn75xx;
 	struct cvmx_lmcx_ecc_parity_test_s    cn78xx;
+	struct cvmx_lmcx_ecc_parity_test_s    cn78xxp2;
 };
 typedef union cvmx_lmcx_ecc_parity_test cvmx_lmcx_ecc_parity_test_t;
 
@@ -7144,7 +7331,9 @@ union cvmx_lmcx_ecc_synd {
 	struct cvmx_lmcx_ecc_synd_s           cn70xx;
 	struct cvmx_lmcx_ecc_synd_s           cn70xxp1;
 	struct cvmx_lmcx_ecc_synd_s           cn73xx;
+	struct cvmx_lmcx_ecc_synd_s           cn75xx;
 	struct cvmx_lmcx_ecc_synd_s           cn78xx;
+	struct cvmx_lmcx_ecc_synd_s           cn78xxp2;
 	struct cvmx_lmcx_ecc_synd_s           cnf71xx;
 };
 typedef union cvmx_lmcx_ecc_synd cvmx_lmcx_ecc_synd_t;
@@ -7160,15 +7349,63 @@ union cvmx_lmcx_ext_config {
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
-	uint64_t ref_block                    : 1;  /**< Reserved. */
-	uint64_t mrs_side                     : 1;  /**< Reserved. */
-	uint64_t mrs_one_side                 : 1;  /**< Reserved. */
-	uint64_t mrs_bside_invert_disable     : 1;  /**< Reserved. */
-	uint64_t dimm_sel_invert_off          : 1;  /**< Reserved. */
-	uint64_t dimm_sel_force_invert        : 1;  /**< Reserved. */
-	uint64_t coalesce_address_mode        : 1;  /**< Reserved. */
-	uint64_t dimm1_cid                    : 2;  /**< Reserved. */
-	uint64_t dimm0_cid                    : 2;  /**< Reserved. */
+	uint64_t ref_block                    : 1;  /**< Added in pass 2.0.
+                                                         When set, LMC is blocked to initiate any refresh sequence. LMC then will only
+                                                         allow refresh sequence to start when LMC()_REF_STATUS[REF_COUNT] has
+                                                         reached the maximum value of 0x7. */
+	uint64_t mrs_side                     : 1;  /**< Added in pass 2.0.
+                                                         Only applies when EXT_CONFIG[MRS_ONE_SIDE] is set.
+                                                         0 = MRS command is sent to the A side of an RDIMM/LRDIMM.
+                                                         1 = MRS command is sent to the B side of an RDIMM/LRDIMM. */
+	uint64_t mrs_one_side                 : 1;  /**< Added in pass 2.0.
+                                                         Only applies to DDR4 RDIMM/LRDIMM.
+                                                         When set, MRS commands are directed to either the A or B
+                                                         side of the RCD.
+                                                         PDA operation is NOT allowed when this bit is set. In
+                                                         other words, MR_MPR_CTL[MR_WR_PDA_ENABLE]
+                                                         must be cleared before running MRW sequence with this
+                                                         bit turned on. */
+	uint64_t mrs_bside_invert_disable     : 1;  /**< Added in pass 2.0.
+                                                         When set, the command decoder cancels the auto inversion of
+                                                         A3-A9, A11, A13, A17, BA0, BA1 and BG0 during MRS/MRS_PDA
+                                                         command to the B side of the RDIMM/LRDIMM.
+                                                         When set, make sure that the RCD's control word
+                                                         RC00 DA[0] = 1 so that the output inversion is disabled in
+                                                         the DDR4 RCD. */
+	uint64_t dimm_sel_invert_off          : 1;  /**< Added in pass 2.0.
+                                                         During coalesce_address_mode, the default logic would be to invert
+                                                         the pbank bit whenever NXM[MEM_MSB_D1_R0] > NXM[MEM_MSB_D0_R0].
+                                                         When this bit is set to 1, it disables this default behaviour.
+                                                         This configuration has lower priority compared to
+                                                         DIMM_SEL_FORCE_INVERT. */
+	uint64_t dimm_sel_force_invert        : 1;  /**< Added in pass 2.0.
+                                                         When set to 1, this bit forces the pbank bit to be inverted
+                                                         when in coalesce_address_mode. That is, pbank value of 0 selects
+                                                         DIMM1 instead of DIMM0.
+                                                         Intended to be use for the case of DIMM1 having bigger rank/s
+                                                         than DIMM0. This bit has priority over DIMM_SEL_INVERT_OFF. */
+	uint64_t coalesce_address_mode        : 1;  /**< Added in pass 2.0.
+                                                         When set to 1, this bit enables LMC to coalesce the cache-line
+                                                         address space into the DRAMs' address.
+                                                         INTERNAL: FIXME - more explanation */
+	uint64_t dimm1_cid                    : 2;  /**< Added in pass 2.0.
+                                                         DIMM1 configuration bits that represent the number of Chip
+                                                         ID of the DRAM. This value is use for decoding address
+                                                         as well as routing Chip IDs to the appropriate output
+                                                         pins.
+                                                         0x0 = 0 Chip ID  (Mono-Die stack).
+                                                         0x1 = 1 Chip ID  (2H 3DS).
+                                                         0x2 = 2 Chip IDs (4H 3DS).
+                                                         0x3 = 3 Chip IDs (8H 3DS). */
+	uint64_t dimm0_cid                    : 2;  /**< Added in pass 2.0.
+                                                         DIMM0 configuration bits that represent the number of Chip
+                                                         ID of the DRAM. This value is use for decoding address
+                                                         as well as routing Chip IDs to the appropriate output
+                                                         pins.
+                                                         0x0 = 0 Chip ID  (Mono-Die stack).
+                                                         0x1 = 1 Chip ID  (2H 3DS).
+                                                         0x2 = 2 Chip IDs (4H 3DS).
+                                                         0x3 = 3 Chip IDs (8H 3DS). */
 	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
                                                          RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
                                                          To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
@@ -7311,7 +7548,9 @@ union cvmx_lmcx_ext_config {
 	} cn70xx;
 	struct cvmx_lmcx_ext_config_cn70xx    cn70xxp1;
 	struct cvmx_lmcx_ext_config_s         cn73xx;
+	struct cvmx_lmcx_ext_config_s         cn75xx;
 	struct cvmx_lmcx_ext_config_s         cn78xx;
+	struct cvmx_lmcx_ext_config_s         cn78xxp2;
 };
 typedef union cvmx_lmcx_ext_config cvmx_lmcx_ext_config_t;
 
@@ -7363,6 +7602,8 @@ union cvmx_lmcx_ext_config2 {
 #endif
 	} s;
 	struct cvmx_lmcx_ext_config2_s        cn73xx;
+	struct cvmx_lmcx_ext_config2_s        cn75xx;
+	struct cvmx_lmcx_ext_config2_s        cn78xxp2;
 };
 typedef union cvmx_lmcx_ext_config2 cvmx_lmcx_ext_config2_t;
 
@@ -7387,7 +7628,8 @@ union cvmx_lmcx_fadr {
 	struct cvmx_lmcx_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved. */
+	uint64_t fcid                         : 3;  /**< Added in pass 2.0.
+                                                         Failing CID number. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_0_37                : 38;
 #else
@@ -7499,13 +7741,18 @@ union cvmx_lmcx_fadr {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_fadr_cn73xx          cn75xx;
 	struct cvmx_lmcx_fadr_cn73xx          cn78xx;
+	struct cvmx_lmcx_fadr_cn73xx          cn78xxp2;
 	struct cvmx_lmcx_fadr_cn61xx          cnf71xx;
 };
 typedef union cvmx_lmcx_fadr cvmx_lmcx_fadr_t;
 
 /**
  * cvmx_lmc#_general_purpose0
+ *
+ * Added in pass 2.0.
+ *
  */
 union cvmx_lmcx_general_purpose0 {
 	uint64_t u64;
@@ -7517,11 +7764,16 @@ union cvmx_lmcx_general_purpose0 {
 #endif
 	} s;
 	struct cvmx_lmcx_general_purpose0_s   cn73xx;
+	struct cvmx_lmcx_general_purpose0_s   cn75xx;
+	struct cvmx_lmcx_general_purpose0_s   cn78xxp2;
 };
 typedef union cvmx_lmcx_general_purpose0 cvmx_lmcx_general_purpose0_t;
 
 /**
  * cvmx_lmc#_general_purpose1
+ *
+ * Added in pass 2.0.
+ *
  */
 union cvmx_lmcx_general_purpose1 {
 	uint64_t u64;
@@ -7533,11 +7785,16 @@ union cvmx_lmcx_general_purpose1 {
 #endif
 	} s;
 	struct cvmx_lmcx_general_purpose1_s   cn73xx;
+	struct cvmx_lmcx_general_purpose1_s   cn75xx;
+	struct cvmx_lmcx_general_purpose1_s   cn78xxp2;
 };
 typedef union cvmx_lmcx_general_purpose1 cvmx_lmcx_general_purpose1_t;
 
 /**
  * cvmx_lmc#_general_purpose2
+ *
+ * Added in pass 2.0.
+ *
  */
 union cvmx_lmcx_general_purpose2 {
 	uint64_t u64;
@@ -7551,6 +7808,8 @@ union cvmx_lmcx_general_purpose2 {
 #endif
 	} s;
 	struct cvmx_lmcx_general_purpose2_s   cn73xx;
+	struct cvmx_lmcx_general_purpose2_s   cn75xx;
+	struct cvmx_lmcx_general_purpose2_s   cn78xxp2;
 };
 typedef union cvmx_lmcx_general_purpose2 cvmx_lmcx_general_purpose2_t;
 
@@ -7580,7 +7839,9 @@ union cvmx_lmcx_ifb_cnt {
 	struct cvmx_lmcx_ifb_cnt_s            cn70xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn70xxp1;
 	struct cvmx_lmcx_ifb_cnt_s            cn73xx;
+	struct cvmx_lmcx_ifb_cnt_s            cn75xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn78xx;
+	struct cvmx_lmcx_ifb_cnt_s            cn78xxp2;
 	struct cvmx_lmcx_ifb_cnt_s            cnf71xx;
 };
 typedef union cvmx_lmcx_ifb_cnt cvmx_lmcx_ifb_cnt_t;
@@ -7662,8 +7923,10 @@ union cvmx_lmcx_int {
 	struct cvmx_lmcx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t macram_ded_err               : 1;  /**< Reserved. */
-	uint64_t macram_sec_err               : 1;  /**< Reserved. */
+	uint64_t macram_ded_err               : 1;  /**< Added in pass 2.0.
+                                                         MAC RAM ECC double error detect (DED). */
+	uint64_t macram_sec_err               : 1;  /**< Added in pass 2.0.
+                                                         MAC RAM ECC single error correct (SEC). */
 	uint64_t ddr_err                      : 1;  /**< DDR RAM error alert interrupt. */
 	uint64_t dlcram_ded_err               : 1;  /**< DLC RAM ECC double error detect (DED). */
 	uint64_t dlcram_sec_err               : 1;  /**< DLC RAM ECC single error correct (SEC). */
@@ -7777,7 +8040,9 @@ union cvmx_lmcx_int {
 	} cn70xx;
 	struct cvmx_lmcx_int_cn70xx           cn70xxp1;
 	struct cvmx_lmcx_int_s                cn73xx;
+	struct cvmx_lmcx_int_s                cn75xx;
 	struct cvmx_lmcx_int_s                cn78xx;
+	struct cvmx_lmcx_int_s                cn78xxp2;
 	struct cvmx_lmcx_int_cn61xx           cnf71xx;
 };
 typedef union cvmx_lmcx_int cvmx_lmcx_int_t;
@@ -7846,7 +8111,9 @@ union cvmx_lmcx_int_en {
 	struct cvmx_lmcx_int_en_s             cn70xx;
 	struct cvmx_lmcx_int_en_s             cn70xxp1;
 	struct cvmx_lmcx_int_en_s             cn73xx;
+	struct cvmx_lmcx_int_en_s             cn75xx;
 	struct cvmx_lmcx_int_en_s             cn78xx;
+	struct cvmx_lmcx_int_en_s             cn78xxp2;
 	struct cvmx_lmcx_int_en_cn61xx        cnf71xx;
 };
 typedef union cvmx_lmcx_int_en cvmx_lmcx_int_en_t;
@@ -7901,7 +8168,9 @@ union cvmx_lmcx_lanex_crc_swiz {
 #endif
 	} s;
 	struct cvmx_lmcx_lanex_crc_swiz_s     cn73xx;
+	struct cvmx_lmcx_lanex_crc_swiz_s     cn75xx;
 	struct cvmx_lmcx_lanex_crc_swiz_s     cn78xx;
+	struct cvmx_lmcx_lanex_crc_swiz_s     cn78xxp2;
 };
 typedef union cvmx_lmcx_lanex_crc_swiz cvmx_lmcx_lanex_crc_swiz_t;
 
@@ -8308,9 +8577,22 @@ union cvmx_lmcx_modereg_params0 {
 	struct cvmx_lmcx_modereg_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t wrp_ext                      : 1;  /**< Reserved. */
-	uint64_t cl_ext                       : 1;  /**< Reserved. */
-	uint64_t al_ext                       : 1;  /**< Reserved. */
+	uint64_t wrp_ext                      : 1;  /**< Added in pass 2.0.
+                                                         A 1 bit extension to the WRP register. */
+	uint64_t cl_ext                       : 1;  /**< Added in pass 2.0.
+                                                         Reserved; must be zero.
+                                                         INTERNAL: The extended bit for the proposed CAS Latency spec change. The new
+                                                         CAS Latency in DDR4 DRAM is defined in MR0(A12,A6,A5,A4,A2). This bit sets
+                                                         the A12 bit.
+                                                         See LMC()_MODEREG_PARAMS0[CL]. */
+	uint64_t al_ext                       : 1;  /**< Added in pass 2.0.
+                                                          Reserved; must be zero.
+                                                          INTERNAL: The extended bit for the new Additive latency settings for DDR4 3DS.
+                                                          Together with LMC()_MODEREG_PARAMS0[AL], this covers additive latency settings
+                                                          of up to CL-6.
+                                                         - 0: CL - (LMC()_MODEREG_PARAMS0[AL])
+                                                         - 1: CL - (LMC()_MODEREG_PARAMS0[AL] + 4)
+                                                          See LMC()_MODEREG_PARAMS0[AL]. */
 	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
                                                          0 = Slow exit (DLL off)
                                                          1 = Fast exit (DLL on)
@@ -8687,7 +8969,9 @@ union cvmx_lmcx_modereg_params0 {
 	struct cvmx_lmcx_modereg_params0_cn61xx cn70xx;
 	struct cvmx_lmcx_modereg_params0_cn61xx cn70xxp1;
 	struct cvmx_lmcx_modereg_params0_s    cn73xx;
+	struct cvmx_lmcx_modereg_params0_s    cn75xx;
 	struct cvmx_lmcx_modereg_params0_s    cn78xx;
+	struct cvmx_lmcx_modereg_params0_s    cn78xxp2;
 	struct cvmx_lmcx_modereg_params0_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_modereg_params0 cvmx_lmcx_modereg_params0_t;
@@ -8703,7 +8987,14 @@ union cvmx_lmcx_modereg_params1 {
 	struct cvmx_lmcx_modereg_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t db_output_impedance          : 3;  /**< Reserved. */
+	uint64_t db_output_impedance          : 3;  /**< Added in pass 2.0.
+                                                         Host Interface DQ/DQS Output Driver Impedance control for DIMM0's Data Buffer.
+                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
+                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         0x0 = RZQ/6 (40 ohm).
+                                                         0x1 = RZQ/7 (34 ohm).
+                                                         0x2 = RZQ/5 (48 ohm).
+                                                         0x3-0x7 = Reserved. */
 	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
                                                          LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
@@ -9084,7 +9375,9 @@ union cvmx_lmcx_modereg_params1 {
 	struct cvmx_lmcx_modereg_params1_cn61xx cn70xx;
 	struct cvmx_lmcx_modereg_params1_cn61xx cn70xxp1;
 	struct cvmx_lmcx_modereg_params1_s    cn73xx;
+	struct cvmx_lmcx_modereg_params1_s    cn75xx;
 	struct cvmx_lmcx_modereg_params1_s    cn78xx;
+	struct cvmx_lmcx_modereg_params1_s    cn78xxp2;
 	struct cvmx_lmcx_modereg_params1_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_modereg_params1 cvmx_lmcx_modereg_params1_t;
@@ -9163,7 +9456,9 @@ union cvmx_lmcx_modereg_params2 {
 #endif
 	} cn70xxp1;
 	struct cvmx_lmcx_modereg_params2_s    cn73xx;
+	struct cvmx_lmcx_modereg_params2_s    cn75xx;
 	struct cvmx_lmcx_modereg_params2_s    cn78xx;
+	struct cvmx_lmcx_modereg_params2_s    cn78xxp2;
 };
 typedef union cvmx_lmcx_modereg_params2 cvmx_lmcx_modereg_params2_t;
 
@@ -9178,8 +9473,12 @@ union cvmx_lmcx_modereg_params3 {
 	struct cvmx_lmcx_modereg_params3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
-	uint64_t xrank_add_tccd_l             : 3;  /**< Reserved. */
-	uint64_t xrank_add_tccd_s             : 3;  /**< Reserved. */
+	uint64_t xrank_add_tccd_l             : 3;  /**< Added in pass 2.0.
+                                                         Add additional cycles on top of the 4 cycles applied to tCCD_L
+                                                         when crossing logical rank (to the same bank group) of a 3DS DRAM. */
+	uint64_t xrank_add_tccd_s             : 3;  /**< Added in pass 2.0.
+                                                         Add additional cycles on top of the 4 cycles applied to tCCD_S
+                                                         when crossing logical rank (to a different bank group) of a 3DS DRAM. */
 	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
 	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
 	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
@@ -9292,7 +9591,9 @@ union cvmx_lmcx_modereg_params3 {
 	} cn70xx;
 	struct cvmx_lmcx_modereg_params3_cn70xx cn70xxp1;
 	struct cvmx_lmcx_modereg_params3_s    cn73xx;
+	struct cvmx_lmcx_modereg_params3_s    cn75xx;
 	struct cvmx_lmcx_modereg_params3_s    cn78xx;
+	struct cvmx_lmcx_modereg_params3_s    cn78xxp2;
 };
 typedef union cvmx_lmcx_modereg_params3 cvmx_lmcx_modereg_params3_t;
 
@@ -9315,7 +9616,9 @@ union cvmx_lmcx_mpr_data0 {
 	struct cvmx_lmcx_mpr_data0_s          cn70xx;
 	struct cvmx_lmcx_mpr_data0_s          cn70xxp1;
 	struct cvmx_lmcx_mpr_data0_s          cn73xx;
+	struct cvmx_lmcx_mpr_data0_s          cn75xx;
 	struct cvmx_lmcx_mpr_data0_s          cn78xx;
+	struct cvmx_lmcx_mpr_data0_s          cn78xxp2;
 };
 typedef union cvmx_lmcx_mpr_data0 cvmx_lmcx_mpr_data0_t;
 
@@ -9338,7 +9641,9 @@ union cvmx_lmcx_mpr_data1 {
 	struct cvmx_lmcx_mpr_data1_s          cn70xx;
 	struct cvmx_lmcx_mpr_data1_s          cn70xxp1;
 	struct cvmx_lmcx_mpr_data1_s          cn73xx;
+	struct cvmx_lmcx_mpr_data1_s          cn75xx;
 	struct cvmx_lmcx_mpr_data1_s          cn78xx;
+	struct cvmx_lmcx_mpr_data1_s          cn78xxp2;
 };
 typedef union cvmx_lmcx_mpr_data1 cvmx_lmcx_mpr_data1_t;
 
@@ -9363,7 +9668,9 @@ union cvmx_lmcx_mpr_data2 {
 	struct cvmx_lmcx_mpr_data2_s          cn70xx;
 	struct cvmx_lmcx_mpr_data2_s          cn70xxp1;
 	struct cvmx_lmcx_mpr_data2_s          cn73xx;
+	struct cvmx_lmcx_mpr_data2_s          cn75xx;
 	struct cvmx_lmcx_mpr_data2_s          cn78xx;
+	struct cvmx_lmcx_mpr_data2_s          cn78xxp2;
 };
 typedef union cvmx_lmcx_mpr_data2 cvmx_lmcx_mpr_data2_t;
 
@@ -9378,12 +9685,27 @@ union cvmx_lmcx_mr_mpr_ctl {
 	struct cvmx_lmcx_mr_mpr_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_61_63               : 3;
-	uint64_t mr_wr_secure_key_ena         : 1;  /**< Reserved. */
-	uint64_t pba_func_space               : 3;  /**< Reserved. */
+	uint64_t mr_wr_secure_key_ena         : 1;  /**< Added in pass 2.0.
+                                                         When set, this enables the issuing of security key with the
+                                                         unique address field A[17:0] set by LMC()_MR_MPR_CTL[MR_WR_ADDR]
+                                                         during the MRW sequence.
+                                                         Set this to 1 when executing DRAM Post Package Repair manually
+                                                         by using MRW operation. */
+	uint64_t pba_func_space               : 3;  /**< Added in pass 2.0.
+                                                         Set the Function Space Selector during PBA mode of the MRW
+                                                         sequence. */
 	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of the address select for MRS in DDR4 mode. */
-	uint64_t mpr_sample_dq_enable         : 1;  /**< Reserved. */
-	uint64_t pda_early_dqx                : 1;  /**< Reserved. */
-	uint64_t mr_wr_pba_enable             : 1;  /**< Reserved. */
+	uint64_t mpr_sample_dq_enable         : 1;  /**< Added in pass 2.0.
+                                                         Reserved. INTERNAL: Sample the whole r128dat1_2a and r128dat0_2a
+                                                         in one cycle. This has priority over the whole-byte mode. i.e., when
+                                                         this bit is set to 1, the MPR register ignores the value of the
+                                                         MPR_WHOLE_BYTE_ENABLE bit. */
+	uint64_t pda_early_dqx                : 1;  /**< Added in pass 2.0.
+                                                         When set, it enables lmc_dqx early for PDA/PBA operation. */
+	uint64_t mr_wr_pba_enable             : 1;  /**< Added in pass 2.0.
+                                                         Per Buffer Addressability write enable. When set, MRW operations use PBA, enabled by
+                                                         MR_WR_PDA_MASK per buffer.
+                                                         Only available for DDR4 LRDIMM. */
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
                                                          LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
@@ -9474,7 +9796,9 @@ union cvmx_lmcx_mr_mpr_ctl {
 	} cn70xx;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx    cn70xxp1;
 	struct cvmx_lmcx_mr_mpr_ctl_s         cn73xx;
+	struct cvmx_lmcx_mr_mpr_ctl_s         cn75xx;
 	struct cvmx_lmcx_mr_mpr_ctl_s         cn78xx;
+	struct cvmx_lmcx_mr_mpr_ctl_s         cn78xxp2;
 };
 typedef union cvmx_lmcx_mr_mpr_ctl cvmx_lmcx_mr_mpr_ctl_t;
 
@@ -9504,6 +9828,8 @@ union cvmx_lmcx_ns_ctl {
 #endif
 	} s;
 	struct cvmx_lmcx_ns_ctl_s             cn73xx;
+	struct cvmx_lmcx_ns_ctl_s             cn75xx;
+	struct cvmx_lmcx_ns_ctl_s             cn78xxp2;
 };
 typedef union cvmx_lmcx_ns_ctl cvmx_lmcx_ns_ctl_t;
 
@@ -9623,7 +9949,9 @@ union cvmx_lmcx_nxm {
 	} cn70xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn70xxp1;
 	struct cvmx_lmcx_nxm_cn70xx           cn73xx;
+	struct cvmx_lmcx_nxm_cn70xx           cn75xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn78xx;
+	struct cvmx_lmcx_nxm_cn70xx           cn78xxp2;
 	struct cvmx_lmcx_nxm_s                cnf71xx;
 };
 typedef union cvmx_lmcx_nxm cvmx_lmcx_nxm_t;
@@ -9642,7 +9970,8 @@ union cvmx_lmcx_nxm_fadr {
 	struct cvmx_lmcx_nxm_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
-	uint64_t nxm_faddr_ext                : 1;  /**< Reserved. */
+	uint64_t nxm_faddr_ext                : 1;  /**< Added in pass 2.0.
+                                                         Extended bit for the Failing L2C-LMC address (bit 37). */
 	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
                                                          0 = L2C, 1 = HFA */
 	uint64_t nxm_type                     : 1;  /**< Indicates the type of operation that caused NXM error:
@@ -9677,7 +10006,9 @@ union cvmx_lmcx_nxm_fadr {
 	} cn70xx;
 	struct cvmx_lmcx_nxm_fadr_cn70xx      cn70xxp1;
 	struct cvmx_lmcx_nxm_fadr_s           cn73xx;
+	struct cvmx_lmcx_nxm_fadr_s           cn75xx;
 	struct cvmx_lmcx_nxm_fadr_s           cn78xx;
+	struct cvmx_lmcx_nxm_fadr_s           cn78xxp2;
 };
 typedef union cvmx_lmcx_nxm_fadr cvmx_lmcx_nxm_fadr_t;
 
@@ -9708,7 +10039,9 @@ union cvmx_lmcx_ops_cnt {
 	struct cvmx_lmcx_ops_cnt_s            cn70xx;
 	struct cvmx_lmcx_ops_cnt_s            cn70xxp1;
 	struct cvmx_lmcx_ops_cnt_s            cn73xx;
+	struct cvmx_lmcx_ops_cnt_s            cn75xx;
 	struct cvmx_lmcx_ops_cnt_s            cn78xx;
+	struct cvmx_lmcx_ops_cnt_s            cn78xxp2;
 	struct cvmx_lmcx_ops_cnt_s            cnf71xx;
 };
 typedef union cvmx_lmcx_ops_cnt cvmx_lmcx_ops_cnt_t;
@@ -9790,11 +10123,34 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
-	uint64_t data_rate_loopback           : 1;  /**< Reserved. */
-	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. */
-	uint64_t dm_disable                   : 1;  /**< Reserved. */
-	uint64_t c1_sel                       : 2;  /**< Reserved. */
-	uint64_t c0_sel                       : 2;  /**< Reserved. */
+	uint64_t data_rate_loopback           : 1;  /**< Added in pass 2.0.
+                                                         Reserved. INTERNAL: DQ data rate loopback, working in conjunction with LOOPBACK assertion.
+                                                         When asserted, incoming PRBS at even DQ can be set at data rate, and the data is loop
+                                                         backed out through odd DQ at the same rate.
+                                                         When de-asserted, LOOPBACK assertion is working along with LOOPBACK_POS to check on even
+                                                         DQ against each DQS edge seperately. This is done at the clock rate. */
+	uint64_t dq_shallow_loopback          : 1;  /**< Added in pass 2.0.
+                                                         Reserved. INTERNAL: DQ shallow loopback, working in conjunction with LOOPBACK assertion.
+                                                         When asserted, even DQ inputs can be loop-backed out through its adjacent odd DQ outputs
+                                                         without being flop'd by DQS. */
+	uint64_t dm_disable                   : 1;  /**< Added in pass 2.0.
+                                                         Write to 1 to disable the DRAM Data Mask feature by having LMC driving a constant value on
+                                                         the
+                                                         DDRX_DQS<17:9>_P pins of the chip during write operations. LMC drives a constant 0 in DDR3
+                                                         and drives a constant 1 in DDR4.
+                                                         Note that setting this field high is NOT allowed when LMC has the Write DBI feature turned
+                                                         on
+                                                         (MODEREG_PARAMS3[WR_DBI]=1). */
+	uint64_t c1_sel                       : 2;  /**< Added in pass 2.0.
+                                                         0x0 = C1 is not routed to any output pin.
+                                                         0x1 = C1 is routed to CS3.
+                                                         0x2 = C1 is routed to A17 address pin.
+                                                         0x3 = C1 is not routed to any output pin. */
+	uint64_t c0_sel                       : 2;  /**< Added in pass 2.0.
+                                                         0x0 = C0 is not routed to any output pin.
+                                                         0x1 = C0 is routed to CS2.
+                                                         0x2 = C0 is routed to TEN output pin.
+                                                         0x3 = C0 is not routed to any output pin. */
 	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
                                                          clear to value of 0. */
 	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
@@ -9810,26 +10166,29 @@ union cvmx_lmcx_phy_ctl {
                                                          0x3 = Deskew read clock toggles every 16 DCLKs. */
 	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
                                                          DDR PHY. */
-	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
-                                                         0 = 8 bits per byte lane, no DBI.
-                                                         1 = 9 bits per byte lane, including DBI. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Changed in pass 2.0.
+                                                         Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
+                                                         0 = 8 bits per byte lane, no DBI, no DAC debug. O70 has to be set to this value.
+                                                         1 = 10 bits per byte lane, including DBI and DAC. O78, T88 and O73 have to be set to 1. */
 	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
                                                          byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
-	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Changed in pass 2.0.
+                                                         Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
                                                          0x0 = DQ0.
                                                          0x1 = DQ1.
                                                          0x2 = DQ2.
                                                          0x3 = DQ3.
-                                                         0x4 = DBI.
-                                                         0x5 = DQ4.
-                                                         0x6 = DQ5.
-                                                         0x7 = DQ6.
-                                                         0x8 = DQ7. */
+                                                         0x4 = DAC.
+                                                         0x5 = DBI.
+                                                         0x6 = DQ4.
+                                                         0x7 = DQ5.
+                                                         0x8 = DQ6.
+                                                         0x9 = DQ7. */
 	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY. */
 	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
 	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
 	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
-	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMCX_PHY_CTL[PHY_DSK_BYP]
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMC()_PHY_CTL[PHY_DSK_BYP]
                                                          when loopback is enabled. */
 	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
 	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
@@ -10043,7 +10402,9 @@ union cvmx_lmcx_phy_ctl {
 	} cn70xx;
 	struct cvmx_lmcx_phy_ctl_cn70xx       cn70xxp1;
 	struct cvmx_lmcx_phy_ctl_s            cn73xx;
+	struct cvmx_lmcx_phy_ctl_s            cn75xx;
 	struct cvmx_lmcx_phy_ctl_s            cn78xx;
+	struct cvmx_lmcx_phy_ctl_s            cn78xxp2;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cnf71xx;
 };
 typedef union cvmx_lmcx_phy_ctl cvmx_lmcx_phy_ctl_t;
@@ -10314,6 +10675,8 @@ union cvmx_lmcx_ppr_ctl {
 #endif
 	} s;
 	struct cvmx_lmcx_ppr_ctl_s            cn73xx;
+	struct cvmx_lmcx_ppr_ctl_s            cn75xx;
+	struct cvmx_lmcx_ppr_ctl_s            cn78xxp2;
 };
 typedef union cvmx_lmcx_ppr_ctl cvmx_lmcx_ppr_ctl_t;
 
@@ -10467,6 +10830,8 @@ union cvmx_lmcx_ref_status {
 #endif
 	} s;
 	struct cvmx_lmcx_ref_status_s         cn73xx;
+	struct cvmx_lmcx_ref_status_s         cn75xx;
+	struct cvmx_lmcx_ref_status_s         cn78xxp2;
 };
 typedef union cvmx_lmcx_ref_status cvmx_lmcx_ref_status_t;
 
@@ -10507,7 +10872,9 @@ union cvmx_lmcx_reset_ctl {
 	struct cvmx_lmcx_reset_ctl_s          cn70xx;
 	struct cvmx_lmcx_reset_ctl_s          cn70xxp1;
 	struct cvmx_lmcx_reset_ctl_s          cn73xx;
+	struct cvmx_lmcx_reset_ctl_s          cn75xx;
 	struct cvmx_lmcx_reset_ctl_s          cn78xx;
+	struct cvmx_lmcx_reset_ctl_s          cn78xxp2;
 	struct cvmx_lmcx_reset_ctl_s          cnf71xx;
 };
 typedef union cvmx_lmcx_reset_ctl cvmx_lmcx_reset_ctl_t;
@@ -10553,6 +10920,8 @@ union cvmx_lmcx_retry_config {
 #endif
 	} s;
 	struct cvmx_lmcx_retry_config_s       cn73xx;
+	struct cvmx_lmcx_retry_config_s       cn75xx;
+	struct cvmx_lmcx_retry_config_s       cn78xxp2;
 };
 typedef union cvmx_lmcx_retry_config cvmx_lmcx_retry_config_t;
 
@@ -10605,6 +10974,8 @@ union cvmx_lmcx_retry_status {
 #endif
 	} s;
 	struct cvmx_lmcx_retry_status_s       cn73xx;
+	struct cvmx_lmcx_retry_status_s       cn75xx;
+	struct cvmx_lmcx_retry_status_s       cn78xxp2;
 };
 typedef union cvmx_lmcx_retry_status cvmx_lmcx_retry_status_t;
 
@@ -10736,7 +11107,9 @@ union cvmx_lmcx_rlevel_ctl {
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xxp1;
 	struct cvmx_lmcx_rlevel_ctl_s         cn73xx;
+	struct cvmx_lmcx_rlevel_ctl_s         cn75xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn78xx;
+	struct cvmx_lmcx_rlevel_ctl_s         cn78xxp2;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cnf71xx;
 };
 typedef union cvmx_lmcx_rlevel_ctl cvmx_lmcx_rlevel_ctl_t;
@@ -10773,7 +11146,9 @@ union cvmx_lmcx_rlevel_dbg {
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xxp1;
 	struct cvmx_lmcx_rlevel_dbg_s         cn73xx;
+	struct cvmx_lmcx_rlevel_dbg_s         cn75xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn78xx;
+	struct cvmx_lmcx_rlevel_dbg_s         cn78xxp2;
 	struct cvmx_lmcx_rlevel_dbg_s         cnf71xx;
 };
 typedef union cvmx_lmcx_rlevel_dbg cvmx_lmcx_rlevel_dbg_t;
@@ -10850,7 +11225,9 @@ union cvmx_lmcx_rlevel_rankx {
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xxp1;
 	struct cvmx_lmcx_rlevel_rankx_s       cn73xx;
+	struct cvmx_lmcx_rlevel_rankx_s       cn75xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn78xx;
+	struct cvmx_lmcx_rlevel_rankx_s       cn78xxp2;
 	struct cvmx_lmcx_rlevel_rankx_s       cnf71xx;
 };
 typedef union cvmx_lmcx_rlevel_rankx cvmx_lmcx_rlevel_rankx_t;
@@ -11049,7 +11426,9 @@ union cvmx_lmcx_rodt_mask {
 	} cn70xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn70xxp1;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn73xx;
+	struct cvmx_lmcx_rodt_mask_cn70xx     cn75xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn78xx;
+	struct cvmx_lmcx_rodt_mask_cn70xx     cn78xxp2;
 	struct cvmx_lmcx_rodt_mask_s          cnf71xx;
 };
 typedef union cvmx_lmcx_rodt_mask cvmx_lmcx_rodt_mask_t;
@@ -11074,7 +11453,9 @@ union cvmx_lmcx_scramble_cfg0 {
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xxp1;
 	struct cvmx_lmcx_scramble_cfg0_s      cn73xx;
+	struct cvmx_lmcx_scramble_cfg0_s      cn75xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn78xx;
+	struct cvmx_lmcx_scramble_cfg0_s      cn78xxp2;
 	struct cvmx_lmcx_scramble_cfg0_s      cnf71xx;
 };
 typedef union cvmx_lmcx_scramble_cfg0 cvmx_lmcx_scramble_cfg0_t;
@@ -11099,13 +11480,18 @@ union cvmx_lmcx_scramble_cfg1 {
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xxp1;
 	struct cvmx_lmcx_scramble_cfg1_s      cn73xx;
+	struct cvmx_lmcx_scramble_cfg1_s      cn75xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn78xx;
+	struct cvmx_lmcx_scramble_cfg1_s      cn78xxp2;
 	struct cvmx_lmcx_scramble_cfg1_s      cnf71xx;
 };
 typedef union cvmx_lmcx_scramble_cfg1 cvmx_lmcx_scramble_cfg1_t;
 
 /**
  * cvmx_lmc#_scramble_cfg2
+ *
+ * Added in pass 2.0.
+ *
  */
 union cvmx_lmcx_scramble_cfg2 {
 	uint64_t u64;
@@ -11117,6 +11503,8 @@ union cvmx_lmcx_scramble_cfg2 {
 #endif
 	} s;
 	struct cvmx_lmcx_scramble_cfg2_s      cn73xx;
+	struct cvmx_lmcx_scramble_cfg2_s      cn75xx;
+	struct cvmx_lmcx_scramble_cfg2_s      cn78xxp2;
 };
 typedef union cvmx_lmcx_scramble_cfg2 cvmx_lmcx_scramble_cfg2_t;
 
@@ -11144,7 +11532,8 @@ union cvmx_lmcx_scrambled_fadr {
 	struct cvmx_lmcx_scrambled_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved. */
+	uint64_t fcid                         : 3;  /**< Added in pass 2.0.
+                                                         Failing CID number. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_14_37               : 24;
 	uint64_t fcol                         : 14; /**< Failing Column Address[13:0]
@@ -11227,7 +11616,9 @@ union cvmx_lmcx_scrambled_fadr {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_scrambled_fadr_cn73xx cn75xx;
 	struct cvmx_lmcx_scrambled_fadr_cn73xx cn78xx;
+	struct cvmx_lmcx_scrambled_fadr_cn73xx cn78xxp2;
 	struct cvmx_lmcx_scrambled_fadr_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_scrambled_fadr cvmx_lmcx_scrambled_fadr_t;
@@ -11289,7 +11680,9 @@ union cvmx_lmcx_seq_ctl {
 	struct cvmx_lmcx_seq_ctl_s            cn70xx;
 	struct cvmx_lmcx_seq_ctl_s            cn70xxp1;
 	struct cvmx_lmcx_seq_ctl_s            cn73xx;
+	struct cvmx_lmcx_seq_ctl_s            cn75xx;
 	struct cvmx_lmcx_seq_ctl_s            cn78xx;
+	struct cvmx_lmcx_seq_ctl_s            cn78xxp2;
 };
 typedef union cvmx_lmcx_seq_ctl cvmx_lmcx_seq_ctl_t;
 
@@ -11320,8 +11713,10 @@ union cvmx_lmcx_slot_ctl0 {
 	struct cvmx_lmcx_slot_ctl0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t w2r_l_init_ext               : 1;  /**< Reserved. */
-	uint64_t w2r_init_ext                 : 1;  /**< Reserved. */
+	uint64_t w2r_l_init_ext               : 1;  /**< Added in pass 2.0.
+                                                         A 1-bit extenstion to the W2R_L_INIT register. */
+	uint64_t w2r_init_ext                 : 1;  /**< Added in pass 2.0.
+                                                         A 1-bit extension to the W2R_INIT register. */
 	uint64_t w2w_l_init                   : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
                                                          accesses to the same rank and DIMM, and same BG for DDR4. */
 	uint64_t w2r_l_init                   : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
@@ -11417,7 +11812,9 @@ union cvmx_lmcx_slot_ctl0 {
 	} cn70xx;
 	struct cvmx_lmcx_slot_ctl0_cn70xx     cn70xxp1;
 	struct cvmx_lmcx_slot_ctl0_s          cn73xx;
+	struct cvmx_lmcx_slot_ctl0_s          cn75xx;
 	struct cvmx_lmcx_slot_ctl0_s          cn78xx;
+	struct cvmx_lmcx_slot_ctl0_s          cn78xxp2;
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cnf71xx;
 };
 typedef union cvmx_lmcx_slot_ctl0 cvmx_lmcx_slot_ctl0_t;
@@ -11478,7 +11875,9 @@ union cvmx_lmcx_slot_ctl1 {
 	struct cvmx_lmcx_slot_ctl1_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn70xxp1;
 	struct cvmx_lmcx_slot_ctl1_s          cn73xx;
+	struct cvmx_lmcx_slot_ctl1_s          cn75xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn78xx;
+	struct cvmx_lmcx_slot_ctl1_s          cn78xxp2;
 	struct cvmx_lmcx_slot_ctl1_s          cnf71xx;
 };
 typedef union cvmx_lmcx_slot_ctl1 cvmx_lmcx_slot_ctl1_t;
@@ -11538,7 +11937,9 @@ union cvmx_lmcx_slot_ctl2 {
 	struct cvmx_lmcx_slot_ctl2_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn70xxp1;
 	struct cvmx_lmcx_slot_ctl2_s          cn73xx;
+	struct cvmx_lmcx_slot_ctl2_s          cn75xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn78xx;
+	struct cvmx_lmcx_slot_ctl2_s          cn78xxp2;
 	struct cvmx_lmcx_slot_ctl2_s          cnf71xx;
 };
 typedef union cvmx_lmcx_slot_ctl2 cvmx_lmcx_slot_ctl2_t;
@@ -11602,6 +12003,8 @@ union cvmx_lmcx_slot_ctl3 {
 #endif
 	} s;
 	struct cvmx_lmcx_slot_ctl3_s          cn73xx;
+	struct cvmx_lmcx_slot_ctl3_s          cn75xx;
+	struct cvmx_lmcx_slot_ctl3_s          cn78xxp2;
 };
 typedef union cvmx_lmcx_slot_ctl3 cvmx_lmcx_slot_ctl3_t;
 
@@ -11613,7 +12016,12 @@ union cvmx_lmcx_timing_params0 {
 	struct cvmx_lmcx_timing_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t tbcw                         : 6;  /**< Reserved. */
+	uint64_t tbcw                         : 6;  /**< Added in pass 2.0.
+                                                         Indicates tBCW constraints. Set this field as follows:
+                                                         _ RNDUP[TBCW(ns) / TCYC(ns)] - 1
+                                                         where TBCW is from the JEDEC DDR4DB spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate).
+                                                         TYP = 16. */
 	uint64_t reserved_26_47               : 22;
 	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
@@ -11918,7 +12326,9 @@ union cvmx_lmcx_timing_params0 {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_timing_params0_cn73xx cn75xx;
 	struct cvmx_lmcx_timing_params0_cn73xx cn78xx;
+	struct cvmx_lmcx_timing_params0_cn73xx cn78xxp2;
 	struct cvmx_lmcx_timing_params0_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_timing_params0 cvmx_lmcx_timing_params0_t;
@@ -11931,10 +12341,30 @@ union cvmx_lmcx_timing_params1 {
 	struct cvmx_lmcx_timing_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
-	uint64_t txp_ext                      : 1;  /**< Reserved. */
-	uint64_t trcd_ext                     : 1;  /**< Reserved. */
-	uint64_t tpdm_full_cycle_ena          : 1;  /**< Reserved. */
-	uint64_t trfc_dlr                     : 7;  /**< Reserved. */
+	uint64_t txp_ext                      : 1;  /**< Added in pass 2.0.
+                                                         A 1-bit extension to the TXP register. */
+	uint64_t trcd_ext                     : 1;  /**< Added in pass 2.0.
+                                                         A 1-bit extension to the TRCD register. */
+	uint64_t tpdm_full_cycle_ena          : 1;  /**< Added in pass 2.0.
+                                                         When set, this field enables the addition of one-cycle delay to the
+                                                         Write/Read latency calculation. This is to compensate the case when
+                                                         tPDM delay in the RCD of an RDIMM/LRDIMM is greater than one-cycle.
+                                                         Only valid in RDIMM  (LMC()_CTL[RDIMM_ENA]=1) or LRDIMM
+                                                         (LMC()_CONFIG[LRDIMM_ENA=1) mode. */
+	uint64_t trfc_dlr                     : 7;  /**< Added in pass 2.0.
+                                                         Indicates TRFC_DLR constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC_DLR(ns) / (8 * TCYC(ns))]
+                                                         where TRFC_DLR is from the JEDEC 3D Stacked SDRAM spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-120 ns.
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
 	uint64_t reserved_4_48                : 45;
 	uint64_t tmprr                        : 4;  /**< Indicates tMPRR constraints.
                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,
@@ -12412,7 +12842,9 @@ union cvmx_lmcx_timing_params1 {
 	uint64_t reserved_59_63               : 5;
 #endif
 	} cn73xx;
+	struct cvmx_lmcx_timing_params1_cn73xx cn75xx;
 	struct cvmx_lmcx_timing_params1_cn73xx cn78xx;
+	struct cvmx_lmcx_timing_params1_cn73xx cn78xxp2;
 	struct cvmx_lmcx_timing_params1_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_timing_params1 cvmx_lmcx_timing_params1_t;
@@ -12428,7 +12860,10 @@ union cvmx_lmcx_timing_params2 {
 	struct cvmx_lmcx_timing_params2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t trrd_l_ext                   : 1;  /**< Reserved. */
+	uint64_t trrd_l_ext                   : 1;  /**< Added in pass 2.0.
+                                                         MSB of TWTR_L constraints. Set this field
+                                                         when requiring tRRD_L of more than 8 nCK. Otherwise
+                                                         this bit must be 0. */
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
                                                          _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
                                                          For DDR3, typical = max(4 nCK, 7.5ns).
@@ -12501,7 +12936,9 @@ union cvmx_lmcx_timing_params2 {
 	} cn70xx;
 	struct cvmx_lmcx_timing_params2_cn70xx cn70xxp1;
 	struct cvmx_lmcx_timing_params2_s     cn73xx;
+	struct cvmx_lmcx_timing_params2_s     cn75xx;
 	struct cvmx_lmcx_timing_params2_s     cn78xx;
+	struct cvmx_lmcx_timing_params2_s     cn78xxp2;
 };
 typedef union cvmx_lmcx_timing_params2 cvmx_lmcx_timing_params2_t;
 
@@ -12626,7 +13063,9 @@ union cvmx_lmcx_wlevel_ctl {
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xxp1;
 	struct cvmx_lmcx_wlevel_ctl_s         cn73xx;
+	struct cvmx_lmcx_wlevel_ctl_s         cn75xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn78xx;
+	struct cvmx_lmcx_wlevel_ctl_s         cn78xxp2;
 	struct cvmx_lmcx_wlevel_ctl_s         cnf71xx;
 };
 typedef union cvmx_lmcx_wlevel_ctl cvmx_lmcx_wlevel_ctl_t;
@@ -12673,7 +13112,9 @@ union cvmx_lmcx_wlevel_dbg {
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xxp1;
 	struct cvmx_lmcx_wlevel_dbg_s         cn73xx;
+	struct cvmx_lmcx_wlevel_dbg_s         cn75xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn78xx;
+	struct cvmx_lmcx_wlevel_dbg_s         cn78xxp2;
 	struct cvmx_lmcx_wlevel_dbg_s         cnf71xx;
 };
 typedef union cvmx_lmcx_wlevel_dbg cvmx_lmcx_wlevel_dbg_t;
@@ -12768,7 +13209,9 @@ union cvmx_lmcx_wlevel_rankx {
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xxp1;
 	struct cvmx_lmcx_wlevel_rankx_s       cn73xx;
+	struct cvmx_lmcx_wlevel_rankx_s       cn75xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn78xx;
+	struct cvmx_lmcx_wlevel_rankx_s       cn78xxp2;
 	struct cvmx_lmcx_wlevel_rankx_s       cnf71xx;
 };
 typedef union cvmx_lmcx_wlevel_rankx cvmx_lmcx_wlevel_rankx_t;
@@ -12983,7 +13426,9 @@ union cvmx_lmcx_wodt_mask {
 	} cn70xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn70xxp1;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn73xx;
+	struct cvmx_lmcx_wodt_mask_cn70xx     cn75xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn78xx;
+	struct cvmx_lmcx_wodt_mask_cn70xx     cn78xxp2;
 	struct cvmx_lmcx_wodt_mask_s          cnf71xx;
 };
 typedef union cvmx_lmcx_wodt_mask cvmx_lmcx_wodt_mask_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 94ab0fa..80daa45 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -57,7 +57,7 @@
 #define CVMX_MIO_BOOT_COMP CVMX_MIO_BOOT_COMP_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000B8ull);
 }
@@ -80,6 +80,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_ADRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_ADRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000000110ull) + ((offset) & 1) * 8;
@@ -98,6 +99,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_CFGX(%lu) is invalid on this chip\n", offset);
@@ -117,6 +119,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_INTX(%lu) is invalid on this chip\n", offset);
@@ -146,7 +149,8 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INT_ENX(unsigned long offset)
 static inline uint64_t CVMX_MIO_BOOT_DMA_INT_W1SX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_INT_W1SX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 1) * 8;
 }
@@ -164,6 +168,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_TIMX(%lu) is invalid on this chip\n", offset);
@@ -176,7 +181,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 #define CVMX_MIO_BOOT_ECO CVMX_MIO_BOOT_ECO_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_MIO_BOOT_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000001F8ull);
 }
@@ -203,6 +208,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_LOC_CFGX(%lu) is invalid on this chip\n", offset);
@@ -216,7 +222,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 #define CVMX_MIO_BOOT_PIN_DEFS CVMX_MIO_BOOT_PIN_DEFS_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_PIN_DEFS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_PIN_DEFS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000C0ull);
 }
@@ -240,6 +246,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_CFGX(%lu) is invalid on this chip\n", offset);
@@ -265,6 +272,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_TIMX(%lu) is invalid on this chip\n", offset);
@@ -278,7 +286,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 #define CVMX_MIO_EMM_ACCESS_WDOG CVMX_MIO_EMM_ACCESS_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_ACCESS_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020F0ull);
 }
@@ -289,7 +297,7 @@ static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 #define CVMX_MIO_EMM_BUF_DAT CVMX_MIO_EMM_BUF_DAT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E8ull);
 }
@@ -300,7 +308,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 #define CVMX_MIO_EMM_BUF_IDX CVMX_MIO_EMM_BUF_IDX_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_IDX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E0ull);
 }
@@ -311,7 +319,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 #define CVMX_MIO_EMM_CFG CVMX_MIO_EMM_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002000ull);
 }
@@ -322,7 +330,7 @@ static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 #define CVMX_MIO_EMM_CMD CVMX_MIO_EMM_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002058ull);
 }
@@ -333,7 +341,7 @@ static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA CVMX_MIO_EMM_DMA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002050ull);
 }
@@ -344,7 +352,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 #define CVMX_MIO_EMM_DMA_ADR CVMX_MIO_EMM_DMA_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000188ull);
 }
@@ -355,7 +363,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_CFG CVMX_MIO_EMM_DMA_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000180ull);
 }
@@ -366,7 +374,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_ADR CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000170ull);
 }
@@ -377,7 +385,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CFG CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000160ull);
 }
@@ -388,7 +396,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CMD CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000178ull);
 }
@@ -399,7 +407,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT CVMX_MIO_EMM_DMA_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000190ull);
 }
@@ -410,7 +418,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT_W1S CVMX_MIO_EMM_DMA_INT_W1S_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000198ull);
 }
@@ -421,7 +429,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 #define CVMX_MIO_EMM_INT CVMX_MIO_EMM_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002078ull);
 }
@@ -443,7 +451,7 @@ static inline uint64_t CVMX_MIO_EMM_INT_EN_FUNC(void)
 #define CVMX_MIO_EMM_INT_W1S CVMX_MIO_EMM_INT_W1S_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_MIO_EMM_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002080ull);
 }
@@ -457,6 +465,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_MIO_EMM_MODEX(%lu) is invalid on this chip\n", offset);
@@ -469,7 +478,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 #define CVMX_MIO_EMM_RCA CVMX_MIO_EMM_RCA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RCA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020A0ull);
 }
@@ -480,7 +489,7 @@ static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 #define CVMX_MIO_EMM_RSP_HI CVMX_MIO_EMM_RSP_HI_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002070ull);
 }
@@ -491,7 +500,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 #define CVMX_MIO_EMM_RSP_LO CVMX_MIO_EMM_RSP_LO_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002068ull);
 }
@@ -502,7 +511,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 #define CVMX_MIO_EMM_RSP_STS CVMX_MIO_EMM_RSP_STS_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002060ull);
 }
@@ -513,7 +522,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 #define CVMX_MIO_EMM_SAMPLE CVMX_MIO_EMM_SAMPLE_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SAMPLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002090ull);
 }
@@ -524,7 +533,7 @@ static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 #define CVMX_MIO_EMM_STS_MASK CVMX_MIO_EMM_STS_MASK_FUNC()
 static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_STS_MASK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002098ull);
 }
@@ -535,7 +544,7 @@ static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 #define CVMX_MIO_EMM_SWITCH CVMX_MIO_EMM_SWITCH_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SWITCH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002048ull);
 }
@@ -546,7 +555,7 @@ static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 #define CVMX_MIO_EMM_WDOG CVMX_MIO_EMM_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002088ull);
 }
@@ -567,6 +576,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_BNK_DATX(%lu) is invalid on this chip\n", offset);
@@ -583,7 +593,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_DAT4 CVMX_MIO_FUS_DAT4_FUNC()
 static inline uint64_t CVMX_MIO_FUS_DAT4_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_DAT4 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 }
@@ -605,7 +615,7 @@ static inline uint64_t CVMX_MIO_FUS_EMA_FUNC(void)
 #define CVMX_MIO_FUS_INT CVMX_MIO_FUS_INT_FUNC()
 static inline uint64_t CVMX_MIO_FUS_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001548ull);
 }
@@ -631,6 +641,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
 	}
@@ -655,6 +666,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
@@ -664,7 +676,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 #define CVMX_MIO_FUS_PLL CVMX_MIO_FUS_PLL_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001580ull);
 }
@@ -676,7 +688,7 @@ static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 #define CVMX_MIO_FUS_PROG_TIMES CVMX_MIO_FUS_PROG_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PROG_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001518ull);
 }
@@ -688,7 +700,7 @@ static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 #define CVMX_MIO_FUS_READ_TIMES CVMX_MIO_FUS_READ_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_READ_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_READ_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001570ull);
 }
@@ -734,6 +746,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_RPR_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001530ull) + ((offset) & 1) * 8;
@@ -745,7 +758,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_SOFT_REPAIR CVMX_MIO_FUS_SOFT_REPAIR_FUNC()
 static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_SOFT_REPAIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001540ull);
 }
@@ -767,6 +780,7 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 			break;
 	}
@@ -785,6 +799,7 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001428ull);
@@ -872,7 +887,7 @@ static inline uint64_t CVMX_MIO_PLL_SETTING_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_HI_INCR CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F40ull);
 }
@@ -883,7 +898,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_LO_INCR CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F48ull);
 }
@@ -894,7 +909,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_HI CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F38ull);
 }
@@ -905,7 +920,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_LO CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F30ull);
 }
@@ -916,7 +931,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_CFG CVMX_MIO_PTP_CLOCK_CFG_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F00ull);
 }
@@ -927,7 +942,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_COMP CVMX_MIO_PTP_CLOCK_COMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F18ull);
 }
@@ -938,7 +953,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_HI CVMX_MIO_PTP_CLOCK_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F10ull);
 }
@@ -949,7 +964,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_LO CVMX_MIO_PTP_CLOCK_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F08ull);
 }
@@ -960,7 +975,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_INT CVMX_MIO_PTP_DPLL_ERR_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F90ull);
 }
@@ -971,7 +986,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_THRESH CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_THRESH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F88ull);
 }
@@ -982,7 +997,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_INCR CVMX_MIO_PTP_DPLL_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F80ull);
 }
@@ -993,7 +1008,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 #define CVMX_MIO_PTP_EVT_CNT CVMX_MIO_PTP_EVT_CNT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F28ull);
 }
@@ -1004,7 +1019,7 @@ static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 #define CVMX_MIO_PTP_EVT_INT CVMX_MIO_PTP_EVT_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F70ull);
 }
@@ -1026,7 +1041,7 @@ static inline uint64_t CVMX_MIO_PTP_PHY_1PPS_IN_FUNC(void)
 #define CVMX_MIO_PTP_PPS_HI_INCR CVMX_MIO_PTP_PPS_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F60ull);
 }
@@ -1037,7 +1052,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_LO_INCR CVMX_MIO_PTP_PPS_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F68ull);
 }
@@ -1048,7 +1063,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_HI CVMX_MIO_PTP_PPS_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F58ull);
 }
@@ -1059,7 +1074,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_LO CVMX_MIO_PTP_PPS_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F50ull);
 }
@@ -1070,7 +1085,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_TIMESTAMP CVMX_MIO_PTP_TIMESTAMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_TIMESTAMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_TIMESTAMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F20ull);
 }
@@ -1203,6 +1218,7 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_INT(%lu) is invalid on this chip\n", offset);
@@ -1215,7 +1231,8 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_INT_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
 }
@@ -1239,6 +1256,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI(%lu) is invalid on this chip\n", offset);
@@ -1264,6 +1282,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI_EXT(%lu) is invalid on this chip\n", offset);
@@ -1289,6 +1308,7 @@ static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_TWSI_SW(%lu) is invalid on this chip\n", offset);
@@ -1589,6 +1609,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLH(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLH(%lu) is invalid on this chip\n", offset);
@@ -1614,6 +1635,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLL(%lu) is invalid on this chip\n", offset);
@@ -1639,6 +1661,7 @@ static inline uint64_t CVMX_MIO_UARTX_FAR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FAR(%lu) is invalid on this chip\n", offset);
@@ -1664,6 +1687,7 @@ static inline uint64_t CVMX_MIO_UARTX_FCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FCR(%lu) is invalid on this chip\n", offset);
@@ -1689,6 +1713,7 @@ static inline uint64_t CVMX_MIO_UARTX_HTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_HTX(%lu) is invalid on this chip\n", offset);
@@ -1714,6 +1739,7 @@ static inline uint64_t CVMX_MIO_UARTX_IER(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IER(%lu) is invalid on this chip\n", offset);
@@ -1739,6 +1765,7 @@ static inline uint64_t CVMX_MIO_UARTX_IIR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IIR(%lu) is invalid on this chip\n", offset);
@@ -1764,6 +1791,7 @@ static inline uint64_t CVMX_MIO_UARTX_LCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LCR(%lu) is invalid on this chip\n", offset);
@@ -1789,6 +1817,7 @@ static inline uint64_t CVMX_MIO_UARTX_LSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LSR(%lu) is invalid on this chip\n", offset);
@@ -1814,6 +1843,7 @@ static inline uint64_t CVMX_MIO_UARTX_MCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MCR(%lu) is invalid on this chip\n", offset);
@@ -1839,6 +1869,7 @@ static inline uint64_t CVMX_MIO_UARTX_MSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MSR(%lu) is invalid on this chip\n", offset);
@@ -1864,6 +1895,7 @@ static inline uint64_t CVMX_MIO_UARTX_RBR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RBR(%lu) is invalid on this chip\n", offset);
@@ -1889,6 +1921,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFL(%lu) is invalid on this chip\n", offset);
@@ -1914,6 +1947,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFW(%lu) is invalid on this chip\n", offset);
@@ -1939,6 +1973,7 @@ static inline uint64_t CVMX_MIO_UARTX_SBCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SBCR(%lu) is invalid on this chip\n", offset);
@@ -1964,6 +1999,7 @@ static inline uint64_t CVMX_MIO_UARTX_SCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SCR(%lu) is invalid on this chip\n", offset);
@@ -1989,6 +2025,7 @@ static inline uint64_t CVMX_MIO_UARTX_SFE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SFE(%lu) is invalid on this chip\n", offset);
@@ -2014,6 +2051,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRR(%lu) is invalid on this chip\n", offset);
@@ -2039,6 +2077,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRT(%lu) is invalid on this chip\n", offset);
@@ -2064,6 +2103,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRTS(%lu) is invalid on this chip\n", offset);
@@ -2089,6 +2129,7 @@ static inline uint64_t CVMX_MIO_UARTX_STT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_STT(%lu) is invalid on this chip\n", offset);
@@ -2114,6 +2155,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFL(%lu) is invalid on this chip\n", offset);
@@ -2139,6 +2181,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFR(%lu) is invalid on this chip\n", offset);
@@ -2164,6 +2207,7 @@ static inline uint64_t CVMX_MIO_UARTX_THR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_THR(%lu) is invalid on this chip\n", offset);
@@ -2189,6 +2233,7 @@ static inline uint64_t CVMX_MIO_UARTX_USR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_USR(%lu) is invalid on this chip\n", offset);
@@ -2338,41 +2383,8 @@ union cvmx_mio_boot_bist_stat {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_bist_stat_cn70xx cn70xxp1;
-	struct cvmx_mio_boot_bist_stat_cn73xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
-	uint64_t stat                         : 15; /**< BIST status.
-                                                         INTERNAL:
-                                                           <0>  = mio.mio_boot.boot_fifo.mem.
-                                                           <1>  = mio.mio_boot.mio_boot_emm.mem.
-                                                           <2>  = mio.mio_boot.mio_boot_mem2.mem.
-                                                           <3>  = mio.mio_boot.boot_loc.mem.
-                                                           <4>  = mio.mio_boot.dma_fifo.mem.
-                                                           <5>  = mio.mio_nbt.mio_nbt_fifo.mem.
-                                                           <6>  = mio.mio_emm.bufs.mem.mem.
-                                                           <7>  = mio_boot_rom/mio_boot_rom1 (bootroms).
-                                                           <8>  = mio.csr.csr_fifo.mem.
-                                                           <9>  = mio.mii.mix0.mix_agi.ipwreq.ipf_mem.
-                                                                = mix_agi.irf.irf0_dat.
-                                                                = mix_agi.ipwreq.mio_mix_agi_merge.mrg_mem.
-                                                                = mix_ago.oprsp.opf_mem.
-                                                                = mix_ago.orf.ago_orf.
-                                                                = mix_nbr.mrq_mem.
-                                                           <10> = mio.mii.mix1.mix_agi.ipwreq.ipf_mem.
-                                                                = mix_agi.irf.irf0_dat.
-                                                                = mix_agi.ipwreq.mio_mix_agi_merge.mrg_mem.
-                                                                = mix_ago.oprsp.opf_mem.
-                                                                = mix_ago.orf.ago_orf.
-                                                                = mix_nbr.mrq_mem.
-                                                           <11> = mio.mio_nbr.ncbo_crd_fif_mem0.
-                                                           <12> = mio.mio_ndf.mio_ndf_bufs.ndf_buf.
-                                                           <13> = mio.mio_ndf.ndf_ncb_rcv_fif.
-                                                           <14> = mio.mpi.mpi_fifo.mem. */
-#else
-	uint64_t stat                         : 15;
-	uint64_t reserved_15_63               : 49;
-#endif
-	} cn73xx;
+	struct cvmx_mio_boot_bist_stat_cn70xx cn73xx;
+	struct cvmx_mio_boot_bist_stat_cn70xx cn75xx;
 	struct cvmx_mio_boot_bist_stat_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
@@ -2391,6 +2403,7 @@ union cvmx_mio_boot_bist_stat {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} cn78xx;
+	struct cvmx_mio_boot_bist_stat_cn78xx cn78xxp2;
 	struct cvmx_mio_boot_bist_stat_cn61xx cnf71xx;
 };
 typedef union cvmx_mio_boot_bist_stat cvmx_mio_boot_bist_stat_t;
@@ -2456,7 +2469,9 @@ union cvmx_mio_boot_comp {
 	} cn70xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn70xxp1;
 	struct cvmx_mio_boot_comp_cn70xx      cn73xx;
+	struct cvmx_mio_boot_comp_cn70xx      cn75xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn78xx;
+	struct cvmx_mio_boot_comp_cn70xx      cn78xxp2;
 	struct cvmx_mio_boot_comp_cn61xx      cnf71xx;
 };
 typedef union cvmx_mio_boot_comp cvmx_mio_boot_comp_t;
@@ -2518,7 +2533,9 @@ union cvmx_mio_boot_dma_adrx {
 #endif
 	} s;
 	struct cvmx_mio_boot_dma_adrx_s       cn73xx;
+	struct cvmx_mio_boot_dma_adrx_s       cn75xx;
 	struct cvmx_mio_boot_dma_adrx_s       cn78xx;
+	struct cvmx_mio_boot_dma_adrx_s       cn78xxp2;
 };
 typedef union cvmx_mio_boot_dma_adrx cvmx_mio_boot_dma_adrx_t;
 
@@ -2604,7 +2621,9 @@ union cvmx_mio_boot_dma_cfgx {
 	uint64_t en                           : 1;
 #endif
 	} cn73xx;
+	struct cvmx_mio_boot_dma_cfgx_cn73xx  cn75xx;
 	struct cvmx_mio_boot_dma_cfgx_cn73xx  cn78xx;
+	struct cvmx_mio_boot_dma_cfgx_cn73xx  cn78xxp2;
 	struct cvmx_mio_boot_dma_cfgx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_cfgx cvmx_mio_boot_dma_cfgx_t;
@@ -2639,7 +2658,9 @@ union cvmx_mio_boot_dma_intx {
 	struct cvmx_mio_boot_dma_intx_s       cn68xx;
 	struct cvmx_mio_boot_dma_intx_s       cn68xxp1;
 	struct cvmx_mio_boot_dma_intx_s       cn73xx;
+	struct cvmx_mio_boot_dma_intx_s       cn75xx;
 	struct cvmx_mio_boot_dma_intx_s       cn78xx;
+	struct cvmx_mio_boot_dma_intx_s       cn78xxp2;
 	struct cvmx_mio_boot_dma_intx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_intx cvmx_mio_boot_dma_intx_t;
@@ -2697,6 +2718,8 @@ union cvmx_mio_boot_dma_int_w1sx {
 #endif
 	} s;
 	struct cvmx_mio_boot_dma_int_w1sx_s   cn73xx;
+	struct cvmx_mio_boot_dma_int_w1sx_s   cn75xx;
+	struct cvmx_mio_boot_dma_int_w1sx_s   cn78xxp2;
 };
 typedef union cvmx_mio_boot_dma_int_w1sx cvmx_mio_boot_dma_int_w1sx_t;
 
@@ -2754,7 +2777,9 @@ union cvmx_mio_boot_dma_timx {
 	struct cvmx_mio_boot_dma_timx_s       cn68xx;
 	struct cvmx_mio_boot_dma_timx_s       cn68xxp1;
 	struct cvmx_mio_boot_dma_timx_s       cn73xx;
+	struct cvmx_mio_boot_dma_timx_s       cn75xx;
 	struct cvmx_mio_boot_dma_timx_s       cn78xx;
+	struct cvmx_mio_boot_dma_timx_s       cn78xxp2;
 	struct cvmx_mio_boot_dma_timx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_timx cvmx_mio_boot_dma_timx_t;
@@ -2774,6 +2799,8 @@ union cvmx_mio_boot_eco {
 #endif
 	} s;
 	struct cvmx_mio_boot_eco_s            cn73xx;
+	struct cvmx_mio_boot_eco_s            cn75xx;
+	struct cvmx_mio_boot_eco_s            cn78xxp2;
 };
 typedef union cvmx_mio_boot_eco cvmx_mio_boot_eco_t;
 
@@ -2816,7 +2843,9 @@ union cvmx_mio_boot_err {
 	struct cvmx_mio_boot_err_s            cn70xx;
 	struct cvmx_mio_boot_err_s            cn70xxp1;
 	struct cvmx_mio_boot_err_s            cn73xx;
+	struct cvmx_mio_boot_err_s            cn75xx;
 	struct cvmx_mio_boot_err_s            cn78xx;
+	struct cvmx_mio_boot_err_s            cn78xxp2;
 	struct cvmx_mio_boot_err_s            cnf71xx;
 };
 typedef union cvmx_mio_boot_err cvmx_mio_boot_err_t;
@@ -2907,7 +2936,9 @@ union cvmx_mio_boot_loc_adr {
 	struct cvmx_mio_boot_loc_adr_s        cn70xx;
 	struct cvmx_mio_boot_loc_adr_s        cn70xxp1;
 	struct cvmx_mio_boot_loc_adr_s        cn73xx;
+	struct cvmx_mio_boot_loc_adr_s        cn75xx;
 	struct cvmx_mio_boot_loc_adr_s        cn78xx;
+	struct cvmx_mio_boot_loc_adr_s        cn78xxp2;
 	struct cvmx_mio_boot_loc_adr_s        cnf71xx;
 };
 typedef union cvmx_mio_boot_loc_adr cvmx_mio_boot_loc_adr_t;
@@ -2956,7 +2987,9 @@ union cvmx_mio_boot_loc_cfgx {
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xxp1;
 	struct cvmx_mio_boot_loc_cfgx_s       cn73xx;
+	struct cvmx_mio_boot_loc_cfgx_s       cn75xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn78xx;
+	struct cvmx_mio_boot_loc_cfgx_s       cn78xxp2;
 	struct cvmx_mio_boot_loc_cfgx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_loc_cfgx cvmx_mio_boot_loc_cfgx_t;
@@ -2996,7 +3029,9 @@ union cvmx_mio_boot_loc_dat {
 	struct cvmx_mio_boot_loc_dat_s        cn70xx;
 	struct cvmx_mio_boot_loc_dat_s        cn70xxp1;
 	struct cvmx_mio_boot_loc_dat_s        cn73xx;
+	struct cvmx_mio_boot_loc_dat_s        cn75xx;
 	struct cvmx_mio_boot_loc_dat_s        cn78xx;
+	struct cvmx_mio_boot_loc_dat_s        cn78xxp2;
 	struct cvmx_mio_boot_loc_dat_s        cnf71xx;
 };
 typedef union cvmx_mio_boot_loc_dat cvmx_mio_boot_loc_dat_t;
@@ -3195,6 +3230,7 @@ union cvmx_mio_boot_pin_defs {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} cn73xx;
+	struct cvmx_mio_boot_pin_defs_cn73xx  cn75xx;
 	struct cvmx_mio_boot_pin_defs_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
@@ -3248,6 +3284,7 @@ union cvmx_mio_boot_pin_defs {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} cn78xx;
+	struct cvmx_mio_boot_pin_defs_cn78xx  cn78xxp2;
 	struct cvmx_mio_boot_pin_defs_cn61xx  cnf71xx;
 };
 typedef union cvmx_mio_boot_pin_defs cvmx_mio_boot_pin_defs_t;
@@ -3379,7 +3416,9 @@ union cvmx_mio_boot_reg_cfgx {
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xxp1;
 	struct cvmx_mio_boot_reg_cfgx_s       cn73xx;
+	struct cvmx_mio_boot_reg_cfgx_s       cn75xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn78xx;
+	struct cvmx_mio_boot_reg_cfgx_s       cn78xxp2;
 	struct cvmx_mio_boot_reg_cfgx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_reg_cfgx cvmx_mio_boot_reg_cfgx_t;
@@ -3473,7 +3512,9 @@ union cvmx_mio_boot_reg_timx {
 	struct cvmx_mio_boot_reg_timx_s       cn70xx;
 	struct cvmx_mio_boot_reg_timx_s       cn70xxp1;
 	struct cvmx_mio_boot_reg_timx_s       cn73xx;
+	struct cvmx_mio_boot_reg_timx_s       cn75xx;
 	struct cvmx_mio_boot_reg_timx_s       cn78xx;
+	struct cvmx_mio_boot_reg_timx_s       cn78xxp2;
 	struct cvmx_mio_boot_reg_timx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_reg_timx cvmx_mio_boot_reg_timx_t;
@@ -3535,7 +3576,9 @@ union cvmx_mio_boot_thr {
 	struct cvmx_mio_boot_thr_s            cn70xx;
 	struct cvmx_mio_boot_thr_s            cn70xxp1;
 	struct cvmx_mio_boot_thr_s            cn73xx;
+	struct cvmx_mio_boot_thr_s            cn75xx;
 	struct cvmx_mio_boot_thr_s            cn78xx;
+	struct cvmx_mio_boot_thr_s            cn78xxp2;
 	struct cvmx_mio_boot_thr_s            cnf71xx;
 };
 typedef union cvmx_mio_boot_thr cvmx_mio_boot_thr_t;
@@ -3558,7 +3601,9 @@ union cvmx_mio_emm_access_wdog {
 #endif
 	} s;
 	struct cvmx_mio_emm_access_wdog_s     cn73xx;
+	struct cvmx_mio_emm_access_wdog_s     cn75xx;
 	struct cvmx_mio_emm_access_wdog_s     cn78xx;
+	struct cvmx_mio_emm_access_wdog_s     cn78xxp2;
 };
 typedef union cvmx_mio_emm_access_wdog cvmx_mio_emm_access_wdog_t;
 
@@ -3582,7 +3627,9 @@ union cvmx_mio_emm_buf_dat {
 	struct cvmx_mio_emm_buf_dat_s         cn70xx;
 	struct cvmx_mio_emm_buf_dat_s         cn70xxp1;
 	struct cvmx_mio_emm_buf_dat_s         cn73xx;
+	struct cvmx_mio_emm_buf_dat_s         cn75xx;
 	struct cvmx_mio_emm_buf_dat_s         cn78xx;
+	struct cvmx_mio_emm_buf_dat_s         cn78xxp2;
 	struct cvmx_mio_emm_buf_dat_s         cnf71xx;
 };
 typedef union cvmx_mio_emm_buf_dat cvmx_mio_emm_buf_dat_t;
@@ -3616,7 +3663,9 @@ union cvmx_mio_emm_buf_idx {
 	struct cvmx_mio_emm_buf_idx_s         cn70xx;
 	struct cvmx_mio_emm_buf_idx_s         cn70xxp1;
 	struct cvmx_mio_emm_buf_idx_s         cn73xx;
+	struct cvmx_mio_emm_buf_idx_s         cn75xx;
 	struct cvmx_mio_emm_buf_idx_s         cn78xx;
+	struct cvmx_mio_emm_buf_idx_s         cn78xxp2;
 	struct cvmx_mio_emm_buf_idx_s         cnf71xx;
 };
 typedef union cvmx_mio_emm_buf_idx cvmx_mio_emm_buf_idx_t;
@@ -3668,7 +3717,9 @@ union cvmx_mio_emm_cfg {
 	struct cvmx_mio_emm_cfg_s             cn70xx;
 	struct cvmx_mio_emm_cfg_s             cn70xxp1;
 	struct cvmx_mio_emm_cfg_s             cn73xx;
+	struct cvmx_mio_emm_cfg_s             cn75xx;
 	struct cvmx_mio_emm_cfg_s             cn78xx;
+	struct cvmx_mio_emm_cfg_s             cn78xxp2;
 	struct cvmx_mio_emm_cfg_s             cnf71xx;
 };
 typedef union cvmx_mio_emm_cfg cvmx_mio_emm_cfg_t;
@@ -3777,7 +3828,9 @@ union cvmx_mio_emm_cmd {
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xxp1;
 	struct cvmx_mio_emm_cmd_s             cn73xx;
+	struct cvmx_mio_emm_cmd_s             cn75xx;
 	struct cvmx_mio_emm_cmd_s             cn78xx;
+	struct cvmx_mio_emm_cmd_s             cn78xxp2;
 	struct cvmx_mio_emm_cmd_cn61xx        cnf71xx;
 };
 typedef union cvmx_mio_emm_cmd cvmx_mio_emm_cmd_t;
@@ -3878,7 +3931,9 @@ union cvmx_mio_emm_dma {
 	struct cvmx_mio_emm_dma_cn61xx        cn70xx;
 	struct cvmx_mio_emm_dma_cn61xx        cn70xxp1;
 	struct cvmx_mio_emm_dma_s             cn73xx;
+	struct cvmx_mio_emm_dma_s             cn75xx;
 	struct cvmx_mio_emm_dma_s             cn78xx;
+	struct cvmx_mio_emm_dma_s             cn78xxp2;
 	struct cvmx_mio_emm_dma_cn61xx        cnf71xx;
 };
 typedef union cvmx_mio_emm_dma cvmx_mio_emm_dma_t;
@@ -3902,7 +3957,9 @@ union cvmx_mio_emm_dma_adr {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_adr_s         cn73xx;
+	struct cvmx_mio_emm_dma_adr_s         cn75xx;
 	struct cvmx_mio_emm_dma_adr_s         cn78xx;
+	struct cvmx_mio_emm_dma_adr_s         cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_adr cvmx_mio_emm_dma_adr_t;
 
@@ -3942,7 +3999,9 @@ union cvmx_mio_emm_dma_cfg {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_cfg_s         cn73xx;
+	struct cvmx_mio_emm_dma_cfg_s         cn75xx;
 	struct cvmx_mio_emm_dma_cfg_s         cn78xx;
+	struct cvmx_mio_emm_dma_cfg_s         cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_cfg cvmx_mio_emm_dma_cfg_t;
 
@@ -3967,7 +4026,9 @@ union cvmx_mio_emm_dma_fifo_adr {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_fifo_adr_s    cn73xx;
+	struct cvmx_mio_emm_dma_fifo_adr_s    cn75xx;
 	struct cvmx_mio_emm_dma_fifo_adr_s    cn78xx;
+	struct cvmx_mio_emm_dma_fifo_adr_s    cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_fifo_adr cvmx_mio_emm_dma_fifo_adr_t;
 
@@ -4002,7 +4063,9 @@ union cvmx_mio_emm_dma_fifo_cfg {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_fifo_cfg_s    cn73xx;
+	struct cvmx_mio_emm_dma_fifo_cfg_s    cn75xx;
 	struct cvmx_mio_emm_dma_fifo_cfg_s    cn78xx;
+	struct cvmx_mio_emm_dma_fifo_cfg_s    cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_fifo_cfg cvmx_mio_emm_dma_fifo_cfg_t;
 
@@ -4032,7 +4095,8 @@ union cvmx_mio_emm_dma_fifo_cmd {
                                                          DMA FIFO in the case of a write to the eMMC device because the MIO_EMM_INT[DONE]
                                                          interrupt would signify the end of the operation.  It could be cleared on the last
                                                          dma command being submitted to the DMA FIFO and the MIO_EMM_DMA_INT[DONE] would
-                                                         occur when the read from the eMMC device was available in lcal emory. */
+                                                         occur when the read from the eMMC device was available in lcal emory.
+                                                         Added in pass 2.0. */
 	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
 	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
 	uint64_t swap8                        : 1;  /**< DMA engine enable 8-bit swap. */
@@ -4054,6 +4118,7 @@ union cvmx_mio_emm_dma_fifo_cmd {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_fifo_cmd_s    cn73xx;
+	struct cvmx_mio_emm_dma_fifo_cmd_s    cn75xx;
 	struct cvmx_mio_emm_dma_fifo_cmd_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
@@ -4078,6 +4143,7 @@ union cvmx_mio_emm_dma_fifo_cmd {
 	uint64_t reserved_63_63               : 1;
 #endif
 	} cn78xx;
+	struct cvmx_mio_emm_dma_fifo_cmd_s    cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_fifo_cmd cvmx_mio_emm_dma_fifo_cmd_t;
 
@@ -4103,7 +4169,9 @@ union cvmx_mio_emm_dma_int {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_int_s         cn73xx;
+	struct cvmx_mio_emm_dma_int_s         cn75xx;
 	struct cvmx_mio_emm_dma_int_s         cn78xx;
+	struct cvmx_mio_emm_dma_int_s         cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_int cvmx_mio_emm_dma_int_t;
 
@@ -4126,7 +4194,9 @@ union cvmx_mio_emm_dma_int_w1s {
 #endif
 	} s;
 	struct cvmx_mio_emm_dma_int_w1s_s     cn73xx;
+	struct cvmx_mio_emm_dma_int_w1s_s     cn75xx;
 	struct cvmx_mio_emm_dma_int_w1s_s     cn78xx;
+	struct cvmx_mio_emm_dma_int_w1s_s     cn78xxp2;
 };
 typedef union cvmx_mio_emm_dma_int_w1s cvmx_mio_emm_dma_int_w1s_t;
 
@@ -4168,7 +4238,9 @@ union cvmx_mio_emm_int {
 	struct cvmx_mio_emm_int_s             cn70xx;
 	struct cvmx_mio_emm_int_s             cn70xxp1;
 	struct cvmx_mio_emm_int_s             cn73xx;
+	struct cvmx_mio_emm_int_s             cn75xx;
 	struct cvmx_mio_emm_int_s             cn78xx;
+	struct cvmx_mio_emm_int_s             cn78xxp2;
 	struct cvmx_mio_emm_int_s             cnf71xx;
 };
 typedef union cvmx_mio_emm_int cvmx_mio_emm_int_t;
@@ -4243,6 +4315,7 @@ union cvmx_mio_emm_int_w1s {
 #endif
 	} s;
 	struct cvmx_mio_emm_int_w1s_s         cn73xx;
+	struct cvmx_mio_emm_int_w1s_s         cn75xx;
 };
 typedef union cvmx_mio_emm_int_w1s cvmx_mio_emm_int_w1s_t;
 
@@ -4292,7 +4365,9 @@ union cvmx_mio_emm_modex {
 	struct cvmx_mio_emm_modex_s           cn70xx;
 	struct cvmx_mio_emm_modex_s           cn70xxp1;
 	struct cvmx_mio_emm_modex_s           cn73xx;
+	struct cvmx_mio_emm_modex_s           cn75xx;
 	struct cvmx_mio_emm_modex_s           cn78xx;
+	struct cvmx_mio_emm_modex_s           cn78xxp2;
 	struct cvmx_mio_emm_modex_s           cnf71xx;
 };
 typedef union cvmx_mio_emm_modex cvmx_mio_emm_modex_t;
@@ -4317,7 +4392,9 @@ union cvmx_mio_emm_rca {
 	struct cvmx_mio_emm_rca_s             cn70xx;
 	struct cvmx_mio_emm_rca_s             cn70xxp1;
 	struct cvmx_mio_emm_rca_s             cn73xx;
+	struct cvmx_mio_emm_rca_s             cn75xx;
 	struct cvmx_mio_emm_rca_s             cn78xx;
+	struct cvmx_mio_emm_rca_s             cn78xxp2;
 	struct cvmx_mio_emm_rca_s             cnf71xx;
 };
 typedef union cvmx_mio_emm_rca cvmx_mio_emm_rca_t;
@@ -4347,7 +4424,9 @@ union cvmx_mio_emm_rsp_hi {
 	struct cvmx_mio_emm_rsp_hi_s          cn70xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn70xxp1;
 	struct cvmx_mio_emm_rsp_hi_s          cn73xx;
+	struct cvmx_mio_emm_rsp_hi_s          cn75xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn78xx;
+	struct cvmx_mio_emm_rsp_hi_s          cn78xxp2;
 	struct cvmx_mio_emm_rsp_hi_s          cnf71xx;
 };
 typedef union cvmx_mio_emm_rsp_hi cvmx_mio_emm_rsp_hi_t;
@@ -4409,7 +4488,9 @@ union cvmx_mio_emm_rsp_lo {
 	struct cvmx_mio_emm_rsp_lo_s          cn70xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn70xxp1;
 	struct cvmx_mio_emm_rsp_lo_s          cn73xx;
+	struct cvmx_mio_emm_rsp_lo_s          cn75xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn78xx;
+	struct cvmx_mio_emm_rsp_lo_s          cn78xxp2;
 	struct cvmx_mio_emm_rsp_lo_s          cnf71xx;
 };
 typedef union cvmx_mio_emm_rsp_lo cvmx_mio_emm_rsp_lo_t;
@@ -4579,7 +4660,9 @@ union cvmx_mio_emm_rsp_sts {
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xxp1;
 	struct cvmx_mio_emm_rsp_sts_s         cn73xx;
+	struct cvmx_mio_emm_rsp_sts_s         cn75xx;
 	struct cvmx_mio_emm_rsp_sts_s         cn78xx;
+	struct cvmx_mio_emm_rsp_sts_s         cn78xxp2;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cnf71xx;
 };
 typedef union cvmx_mio_emm_rsp_sts cvmx_mio_emm_rsp_sts_t;
@@ -4608,7 +4691,9 @@ union cvmx_mio_emm_sample {
 	struct cvmx_mio_emm_sample_s          cn70xx;
 	struct cvmx_mio_emm_sample_s          cn70xxp1;
 	struct cvmx_mio_emm_sample_s          cn73xx;
+	struct cvmx_mio_emm_sample_s          cn75xx;
 	struct cvmx_mio_emm_sample_s          cn78xx;
+	struct cvmx_mio_emm_sample_s          cn78xxp2;
 	struct cvmx_mio_emm_sample_s          cnf71xx;
 };
 typedef union cvmx_mio_emm_sample cvmx_mio_emm_sample_t;
@@ -4632,7 +4717,9 @@ union cvmx_mio_emm_sts_mask {
 	struct cvmx_mio_emm_sts_mask_s        cn70xx;
 	struct cvmx_mio_emm_sts_mask_s        cn70xxp1;
 	struct cvmx_mio_emm_sts_mask_s        cn73xx;
+	struct cvmx_mio_emm_sts_mask_s        cn75xx;
 	struct cvmx_mio_emm_sts_mask_s        cn78xx;
+	struct cvmx_mio_emm_sts_mask_s        cn78xxp2;
 	struct cvmx_mio_emm_sts_mask_s        cnf71xx;
 };
 typedef union cvmx_mio_emm_sts_mask cvmx_mio_emm_sts_mask_t;
@@ -4703,7 +4790,9 @@ union cvmx_mio_emm_switch {
 	struct cvmx_mio_emm_switch_s          cn70xx;
 	struct cvmx_mio_emm_switch_s          cn70xxp1;
 	struct cvmx_mio_emm_switch_s          cn73xx;
+	struct cvmx_mio_emm_switch_s          cn75xx;
 	struct cvmx_mio_emm_switch_s          cn78xx;
+	struct cvmx_mio_emm_switch_s          cn78xxp2;
 	struct cvmx_mio_emm_switch_s          cnf71xx;
 };
 typedef union cvmx_mio_emm_switch cvmx_mio_emm_switch_t;
@@ -4753,7 +4842,9 @@ union cvmx_mio_emm_wdog {
 	struct cvmx_mio_emm_wdog_s            cn70xx;
 	struct cvmx_mio_emm_wdog_s            cn70xxp1;
 	struct cvmx_mio_emm_wdog_s            cn73xx;
+	struct cvmx_mio_emm_wdog_s            cn75xx;
 	struct cvmx_mio_emm_wdog_s            cn78xx;
+	struct cvmx_mio_emm_wdog_s            cn78xxp2;
 	struct cvmx_mio_emm_wdog_s            cnf71xx;
 };
 typedef union cvmx_mio_emm_wdog cvmx_mio_emm_wdog_t;
@@ -4791,7 +4882,9 @@ union cvmx_mio_fus_bnk_datx {
 	struct cvmx_mio_fus_bnk_datx_s        cn70xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn70xxp1;
 	struct cvmx_mio_fus_bnk_datx_s        cn73xx;
+	struct cvmx_mio_fus_bnk_datx_s        cn75xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn78xx;
+	struct cvmx_mio_fus_bnk_datx_s        cn78xxp2;
 	struct cvmx_mio_fus_bnk_datx_s        cnf71xx;
 };
 typedef union cvmx_mio_fus_bnk_datx cvmx_mio_fus_bnk_datx_t;
@@ -4830,7 +4923,9 @@ union cvmx_mio_fus_dat0 {
 	struct cvmx_mio_fus_dat0_s            cn70xx;
 	struct cvmx_mio_fus_dat0_s            cn70xxp1;
 	struct cvmx_mio_fus_dat0_s            cn73xx;
+	struct cvmx_mio_fus_dat0_s            cn75xx;
 	struct cvmx_mio_fus_dat0_s            cn78xx;
+	struct cvmx_mio_fus_dat0_s            cn78xxp2;
 	struct cvmx_mio_fus_dat0_s            cnf71xx;
 };
 typedef union cvmx_mio_fus_dat0 cvmx_mio_fus_dat0_t;
@@ -4869,7 +4964,9 @@ union cvmx_mio_fus_dat1 {
 	struct cvmx_mio_fus_dat1_s            cn70xx;
 	struct cvmx_mio_fus_dat1_s            cn70xxp1;
 	struct cvmx_mio_fus_dat1_s            cn73xx;
+	struct cvmx_mio_fus_dat1_s            cn75xx;
 	struct cvmx_mio_fus_dat1_s            cn78xx;
+	struct cvmx_mio_fus_dat1_s            cn78xxp2;
 	struct cvmx_mio_fus_dat1_s            cnf71xx;
 };
 typedef union cvmx_mio_fus_dat1 cvmx_mio_fus_dat1_t;
@@ -4903,7 +5000,8 @@ union cvmx_mio_fus_dat2 {
                                                          0x4-0x7 = Reserved. */
 	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
                                                          N/128 power reduction. Small values have less throttling and higher
-                                                         performance. 0x0 disables throttling. */
+                                                         performance. 0x0 disables throttling.
+                                                         Added in pass 2. */
 	uint64_t fus118                       : 1;  /**< Ignore Authentik disable */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit */
@@ -5384,6 +5482,7 @@ union cvmx_mio_fus_dat2 {
 	uint64_t reserved_59_63               : 5;
 #endif
 	} cn73xx;
+	struct cvmx_mio_fus_dat2_cn73xx       cn75xx;
 	struct cvmx_mio_fus_dat2_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
@@ -5435,6 +5534,60 @@ union cvmx_mio_fus_dat2 {
 	uint64_t reserved_59_63               : 5;
 #endif
 	} cn78xx;
+	struct cvmx_mio_fus_dat2_cn78xxp2 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_59_63               : 5;
+	uint64_t run_platform                 : 3;  /**< Fuses to indicate the run platform. Not to be blown in actual hardware.
+                                                         Provides software a means of determining the platform at run time.
+                                                         0x0 = Hardware.
+                                                         0x1 = Emulator.
+                                                         0x2 = RTL simulator.
+                                                         0x3 = ASIM.
+                                                         0x4-0x7 = Reserved. */
+	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
+                                                         N/128 power reduction. Small values have less throttling and higher
+                                                         performance. 0x0 disables throttling.
+                                                         Added in pass 2. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
+                                                         INTERNAL: fuse[99]. */
+	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
+	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
+	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
+	uint64_t fus318                       : 1;  /**< Reserved.
+                                                         INTERNAL: Tied to 0. */
+	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
+	uint64_t reserved_31_29               : 3;
+	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2).
+                                                         INTERNAL: Tied to 1. */
+	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
+	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
+                                                         modes:
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 0 AES/DES/HASH enabled.
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
+	uint64_t reserved_25_24               : 2;
+	uint64_t chip_id                      : 8;  /**< Fuse information - chip ID. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t chip_id                      : 8;
+	uint64_t reserved_25_24               : 2;
+	uint64_t nocrypto                     : 1;
+	uint64_t nomul                        : 1;
+	uint64_t nodfa_cp2                    : 1;
+	uint64_t reserved_31_29               : 3;
+	uint64_t raid_en                      : 1;
+	uint64_t fus318                       : 1;
+	uint64_t dorm_crypto                  : 1;
+	uint64_t power_limit                  : 2;
+	uint64_t rom_info                     : 10;
+	uint64_t fus118                       : 1;
+	uint64_t gbl_pwr_throttle             : 8;
+	uint64_t run_platform                 : 3;
+	uint64_t reserved_59_63               : 5;
+#endif
+	} cn78xxp2;
 	struct cvmx_mio_fus_dat2_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_dat2 cvmx_mio_fus_dat2_t;
@@ -5451,7 +5604,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - DFA information (DTE) */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - DFA information (Cluster mask) */
-	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. Added in pass 2. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown */
@@ -5771,8 +5924,8 @@ union cvmx_mio_fus_dat3 {
                                                          0x2 = 1/2 ways (8-way, 8 MB).
                                                          0x3 = 1/4 ways (4-way, 4MB).
                                                          0x4-0x7 = Reserved. */
-	uint64_t use_int_refclk               : 1;  /**< If set use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
-                                                         to use the external input reference clock. */
+	uint64_t use_int_refclk               : 1;  /**< If set, use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
+                                                         to use the internal input reference clock. */
 	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
 	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
 	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
@@ -5814,6 +5967,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t ema0                         : 6;
 #endif
 	} cn73xx;
+	struct cvmx_mio_fus_dat3_cn73xx       cn75xx;
 	struct cvmx_mio_fus_dat3_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
@@ -5868,6 +6022,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t ema0                         : 6;
 #endif
 	} cn78xx;
+	struct cvmx_mio_fus_dat3_cn73xx       cn78xxp2;
 	struct cvmx_mio_fus_dat3_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_dat3 cvmx_mio_fus_dat3_t;
@@ -5905,7 +6060,9 @@ union cvmx_mio_fus_dat4 {
 	struct cvmx_mio_fus_dat4_s            cn70xx;
 	struct cvmx_mio_fus_dat4_s            cn70xxp1;
 	struct cvmx_mio_fus_dat4_s            cn73xx;
+	struct cvmx_mio_fus_dat4_s            cn75xx;
 	struct cvmx_mio_fus_dat4_s            cn78xx;
+	struct cvmx_mio_fus_dat4_s            cn78xxp2;
 };
 typedef union cvmx_mio_fus_dat4 cvmx_mio_fus_dat4_t;
 
@@ -5974,7 +6131,9 @@ union cvmx_mio_fus_int {
 	struct cvmx_mio_fus_int_s             cn70xx;
 	struct cvmx_mio_fus_int_s             cn70xxp1;
 	struct cvmx_mio_fus_int_s             cn73xx;
+	struct cvmx_mio_fus_int_s             cn75xx;
 	struct cvmx_mio_fus_int_s             cn78xx;
+	struct cvmx_mio_fus_int_s             cn78xxp2;
 };
 typedef union cvmx_mio_fus_int cvmx_mio_fus_int_t;
 
@@ -6005,7 +6164,9 @@ union cvmx_mio_fus_pdf {
 	struct cvmx_mio_fus_pdf_s             cn70xx;
 	struct cvmx_mio_fus_pdf_s             cn70xxp1;
 	struct cvmx_mio_fus_pdf_s             cn73xx;
+	struct cvmx_mio_fus_pdf_s             cn75xx;
 	struct cvmx_mio_fus_pdf_s             cn78xx;
+	struct cvmx_mio_fus_pdf_s             cn78xxp2;
 	struct cvmx_mio_fus_pdf_s             cnf71xx;
 };
 typedef union cvmx_mio_fus_pdf cvmx_mio_fus_pdf_t;
@@ -6167,7 +6328,9 @@ union cvmx_mio_fus_pll {
 	} cn70xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn70xxp1;
 	struct cvmx_mio_fus_pll_cn70xx        cn73xx;
+	struct cvmx_mio_fus_pll_cn70xx        cn75xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn78xx;
+	struct cvmx_mio_fus_pll_cn70xx        cn78xxp2;
 	struct cvmx_mio_fus_pll_cn61xx        cnf71xx;
 };
 typedef union cvmx_mio_fus_pll cvmx_mio_fus_pll_t;
@@ -6256,7 +6419,9 @@ union cvmx_mio_fus_prog {
 	} cn70xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn70xxp1;
 	struct cvmx_mio_fus_prog_cn70xx       cn73xx;
+	struct cvmx_mio_fus_prog_cn70xx       cn75xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn78xx;
+	struct cvmx_mio_fus_prog_cn70xx       cn78xxp2;
 	struct cvmx_mio_fus_prog_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_prog cvmx_mio_fus_prog_t;
@@ -6388,7 +6553,9 @@ union cvmx_mio_fus_prog_times {
 	} cn70xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn70xxp1;
 	struct cvmx_mio_fus_prog_times_cn70xx cn73xx;
+	struct cvmx_mio_fus_prog_times_cn70xx cn75xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn78xx;
+	struct cvmx_mio_fus_prog_times_cn70xx cn78xxp2;
 	struct cvmx_mio_fus_prog_times_cn61xx cnf71xx;
 };
 typedef union cvmx_mio_fus_prog_times cvmx_mio_fus_prog_times_t;
@@ -6399,8 +6566,9 @@ typedef union cvmx_mio_fus_prog_times cvmx_mio_fus_prog_times_t;
  * To read an efuse, software writes MIO_FUS_RCMD[ADDR,PEND] with the byte address of the fuse in
  * question, then software can poll MIO_FUS_RCMD[PEND]. When PEND is clear, then
  * MIO_FUS_RCMD[DAT] is valid. In addition, if the efuse read went to the efuse banks (e.g.
- * (ADDR/16) not [0,1,7]) || EFUSE), software can read MIO_FUS_BNK_DATx which contains all 128
- * fuses in the bank associated in ADDR.
+ * (ADDR/16) not [0,1,7] || EFUSE), software can read MIO_FUS_BNK_DAT() which contains all 128
+ * fuses in the bank associated in ADDR.  Fuses 1023..960 are not accessable if
+ * MIO_FUS_DAT2[DORM_CRYPTO] is enabled.
  */
 union cvmx_mio_fus_rcmd {
 	uint64_t u64;
@@ -6492,7 +6660,9 @@ union cvmx_mio_fus_rcmd {
 	struct cvmx_mio_fus_rcmd_s            cn70xx;
 	struct cvmx_mio_fus_rcmd_s            cn70xxp1;
 	struct cvmx_mio_fus_rcmd_s            cn73xx;
+	struct cvmx_mio_fus_rcmd_s            cn75xx;
 	struct cvmx_mio_fus_rcmd_s            cn78xx;
+	struct cvmx_mio_fus_rcmd_s            cn78xxp2;
 	struct cvmx_mio_fus_rcmd_cn52xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_rcmd cvmx_mio_fus_rcmd_t;
@@ -6605,7 +6775,9 @@ union cvmx_mio_fus_read_times {
 	} cn70xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn70xxp1;
 	struct cvmx_mio_fus_read_times_cn70xx cn73xx;
+	struct cvmx_mio_fus_read_times_cn70xx cn75xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn78xx;
+	struct cvmx_mio_fus_read_times_cn70xx cn78xxp2;
 	struct cvmx_mio_fus_read_times_cn61xx cnf71xx;
 };
 typedef union cvmx_mio_fus_read_times cvmx_mio_fus_read_times_t;
@@ -6708,7 +6880,9 @@ union cvmx_mio_fus_rpr_datx {
 	struct cvmx_mio_fus_rpr_datx_s        cn70xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn70xxp1;
 	struct cvmx_mio_fus_rpr_datx_s        cn73xx;
+	struct cvmx_mio_fus_rpr_datx_s        cn75xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn78xx;
+	struct cvmx_mio_fus_rpr_datx_s        cn78xxp2;
 };
 typedef union cvmx_mio_fus_rpr_datx cvmx_mio_fus_rpr_datx_t;
 
@@ -6742,7 +6916,9 @@ union cvmx_mio_fus_soft_repair {
 	struct cvmx_mio_fus_soft_repair_s     cn70xx;
 	struct cvmx_mio_fus_soft_repair_s     cn70xxp1;
 	struct cvmx_mio_fus_soft_repair_s     cn73xx;
+	struct cvmx_mio_fus_soft_repair_s     cn75xx;
 	struct cvmx_mio_fus_soft_repair_s     cn78xx;
+	struct cvmx_mio_fus_soft_repair_s     cn78xxp2;
 };
 typedef union cvmx_mio_fus_soft_repair cvmx_mio_fus_soft_repair_t;
 
@@ -6878,7 +7054,9 @@ union cvmx_mio_fus_tgg {
 	struct cvmx_mio_fus_tgg_s             cn70xx;
 	struct cvmx_mio_fus_tgg_s             cn70xxp1;
 	struct cvmx_mio_fus_tgg_s             cn73xx;
+	struct cvmx_mio_fus_tgg_s             cn75xx;
 	struct cvmx_mio_fus_tgg_s             cn78xx;
+	struct cvmx_mio_fus_tgg_s             cn78xxp2;
 	struct cvmx_mio_fus_tgg_s             cnf71xx;
 };
 typedef union cvmx_mio_fus_tgg cvmx_mio_fus_tgg_t;
@@ -6969,7 +7147,9 @@ union cvmx_mio_fus_wadr {
 	} cn70xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn70xxp1;
 	struct cvmx_mio_fus_wadr_cn70xx       cn73xx;
+	struct cvmx_mio_fus_wadr_cn70xx       cn75xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn78xx;
+	struct cvmx_mio_fus_wadr_cn70xx       cn78xxp2;
 	struct cvmx_mio_fus_wadr_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_wadr cvmx_mio_fus_wadr_t;
@@ -7193,7 +7373,9 @@ union cvmx_mio_ptp_ckout_hi_incr {
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xxp1;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn73xx;
+	struct cvmx_mio_ptp_ckout_hi_incr_s   cn75xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn78xx;
+	struct cvmx_mio_ptp_ckout_hi_incr_s   cn78xxp2;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cnf71xx;
 };
 typedef union cvmx_mio_ptp_ckout_hi_incr cvmx_mio_ptp_ckout_hi_incr_t;
@@ -7221,7 +7403,9 @@ union cvmx_mio_ptp_ckout_lo_incr {
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xxp1;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn73xx;
+	struct cvmx_mio_ptp_ckout_lo_incr_s   cn75xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn78xx;
+	struct cvmx_mio_ptp_ckout_lo_incr_s   cn78xxp2;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cnf71xx;
 };
 typedef union cvmx_mio_ptp_ckout_lo_incr cvmx_mio_ptp_ckout_lo_incr_t;
@@ -7256,7 +7440,9 @@ union cvmx_mio_ptp_ckout_thresh_hi {
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xxp1;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn73xx;
+	struct cvmx_mio_ptp_ckout_thresh_hi_s cn75xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn78xx;
+	struct cvmx_mio_ptp_ckout_thresh_hi_s cn78xxp2;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cnf71xx;
 };
 typedef union cvmx_mio_ptp_ckout_thresh_hi cvmx_mio_ptp_ckout_thresh_hi_t;
@@ -7284,7 +7470,9 @@ union cvmx_mio_ptp_ckout_thresh_lo {
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xxp1;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn73xx;
+	struct cvmx_mio_ptp_ckout_thresh_lo_s cn75xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn78xx;
+	struct cvmx_mio_ptp_ckout_thresh_lo_s cn78xxp2;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cnf71xx;
 };
 typedef union cvmx_mio_ptp_ckout_thresh_lo cvmx_mio_ptp_ckout_thresh_lo_t;
@@ -7624,7 +7812,9 @@ union cvmx_mio_ptp_clock_cfg {
 	} cn70xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn70xxp1;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn73xx;
+	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn75xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn78xx;
+	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn78xxp2;
 	struct cvmx_mio_ptp_clock_cfg_cn61xx  cnf71xx;
 };
 typedef union cvmx_mio_ptp_clock_cfg cvmx_mio_ptp_clock_cfg_t;
@@ -7657,7 +7847,9 @@ union cvmx_mio_ptp_clock_comp {
 	struct cvmx_mio_ptp_clock_comp_s      cn70xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn70xxp1;
 	struct cvmx_mio_ptp_clock_comp_s      cn73xx;
+	struct cvmx_mio_ptp_clock_comp_s      cn75xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn78xx;
+	struct cvmx_mio_ptp_clock_comp_s      cn78xxp2;
 	struct cvmx_mio_ptp_clock_comp_s      cnf71xx;
 };
 typedef union cvmx_mio_ptp_clock_comp cvmx_mio_ptp_clock_comp_t;
@@ -7687,7 +7879,9 @@ union cvmx_mio_ptp_clock_hi {
 	struct cvmx_mio_ptp_clock_hi_s        cn70xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn70xxp1;
 	struct cvmx_mio_ptp_clock_hi_s        cn73xx;
+	struct cvmx_mio_ptp_clock_hi_s        cn75xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn78xx;
+	struct cvmx_mio_ptp_clock_hi_s        cn78xxp2;
 	struct cvmx_mio_ptp_clock_hi_s        cnf71xx;
 };
 typedef union cvmx_mio_ptp_clock_hi cvmx_mio_ptp_clock_hi_t;
@@ -7718,7 +7912,9 @@ union cvmx_mio_ptp_clock_lo {
 	struct cvmx_mio_ptp_clock_lo_s        cn70xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn70xxp1;
 	struct cvmx_mio_ptp_clock_lo_s        cn73xx;
+	struct cvmx_mio_ptp_clock_lo_s        cn75xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn78xx;
+	struct cvmx_mio_ptp_clock_lo_s        cn78xxp2;
 	struct cvmx_mio_ptp_clock_lo_s        cnf71xx;
 };
 typedef union cvmx_mio_ptp_clock_lo cvmx_mio_ptp_clock_lo_t;
@@ -7736,7 +7932,7 @@ union cvmx_mio_ptp_dpll_err_int {
 	uint64_t n_sclk                       : 32; /**< Latest number of coprocessor clocks in one external reference signal compensation period
                                                          (MIO_PTP_CLOCK_COMP). */
 	uint64_t reserved_2_31                : 30;
-	uint64_t dpll_int_w1s                 : 1;  /**< Reads or sets [DPLL_INT]. */
+	uint64_t dpll_int_w1s                 : 1;  /**< Reads or sets [DPLL_INT]. Added in pass 2. */
 	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
 #else
 	uint64_t dpll_int                     : 1;
@@ -7746,6 +7942,7 @@ union cvmx_mio_ptp_dpll_err_int {
 #endif
 	} s;
 	struct cvmx_mio_ptp_dpll_err_int_s    cn73xx;
+	struct cvmx_mio_ptp_dpll_err_int_s    cn75xx;
 	struct cvmx_mio_ptp_dpll_err_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t n_sclk                       : 32; /**< Latest number of coprocessor clocks in one external reference signal compensation period
@@ -7758,6 +7955,7 @@ union cvmx_mio_ptp_dpll_err_int {
 	uint64_t n_sclk                       : 32;
 #endif
 	} cn78xx;
+	struct cvmx_mio_ptp_dpll_err_int_s    cn78xxp2;
 };
 typedef union cvmx_mio_ptp_dpll_err_int cvmx_mio_ptp_dpll_err_int_t;
 
@@ -7779,7 +7977,9 @@ union cvmx_mio_ptp_dpll_err_thresh {
 #endif
 	} s;
 	struct cvmx_mio_ptp_dpll_err_thresh_s cn73xx;
+	struct cvmx_mio_ptp_dpll_err_thresh_s cn75xx;
 	struct cvmx_mio_ptp_dpll_err_thresh_s cn78xx;
+	struct cvmx_mio_ptp_dpll_err_thresh_s cn78xxp2;
 };
 typedef union cvmx_mio_ptp_dpll_err_thresh cvmx_mio_ptp_dpll_err_thresh_t;
 
@@ -7801,7 +8001,9 @@ union cvmx_mio_ptp_dpll_incr {
 #endif
 	} s;
 	struct cvmx_mio_ptp_dpll_incr_s       cn73xx;
+	struct cvmx_mio_ptp_dpll_incr_s       cn75xx;
 	struct cvmx_mio_ptp_dpll_incr_s       cn78xx;
+	struct cvmx_mio_ptp_dpll_incr_s       cn78xxp2;
 };
 typedef union cvmx_mio_ptp_dpll_incr cvmx_mio_ptp_dpll_incr_t;
 
@@ -7829,7 +8031,9 @@ union cvmx_mio_ptp_evt_cnt {
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xxp1;
 	struct cvmx_mio_ptp_evt_cnt_s         cn73xx;
+	struct cvmx_mio_ptp_evt_cnt_s         cn75xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn78xx;
+	struct cvmx_mio_ptp_evt_cnt_s         cn78xxp2;
 	struct cvmx_mio_ptp_evt_cnt_s         cnf71xx;
 };
 typedef union cvmx_mio_ptp_evt_cnt cvmx_mio_ptp_evt_cnt_t;
@@ -7845,7 +8049,7 @@ union cvmx_mio_ptp_evt_int {
 	struct cvmx_mio_ptp_evt_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t evt_int_w1s                  : 1;  /**< Reads or sets [EVT_INT]. */
+	uint64_t evt_int_w1s                  : 1;  /**< Reads or sets [EVT_INT]. Added in pass 2. */
 	uint64_t evt_int                      : 1;  /**< PTP event observed. Throws MIO_PTP_INTSN_E::MIO_PTP_EVT_INT. */
 #else
 	uint64_t evt_int                      : 1;
@@ -7854,6 +8058,7 @@ union cvmx_mio_ptp_evt_int {
 #endif
 	} s;
 	struct cvmx_mio_ptp_evt_int_s         cn73xx;
+	struct cvmx_mio_ptp_evt_int_s         cn75xx;
 	struct cvmx_mio_ptp_evt_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
@@ -7863,6 +8068,7 @@ union cvmx_mio_ptp_evt_int {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} cn78xx;
+	struct cvmx_mio_ptp_evt_int_s         cn78xxp2;
 };
 typedef union cvmx_mio_ptp_evt_int cvmx_mio_ptp_evt_int_t;
 
@@ -7916,7 +8122,9 @@ union cvmx_mio_ptp_pps_hi_incr {
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xxp1;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn73xx;
+	struct cvmx_mio_ptp_pps_hi_incr_s     cn75xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn78xx;
+	struct cvmx_mio_ptp_pps_hi_incr_s     cn78xxp2;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cnf71xx;
 };
 typedef union cvmx_mio_ptp_pps_hi_incr cvmx_mio_ptp_pps_hi_incr_t;
@@ -7944,7 +8152,9 @@ union cvmx_mio_ptp_pps_lo_incr {
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xxp1;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn73xx;
+	struct cvmx_mio_ptp_pps_lo_incr_s     cn75xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn78xx;
+	struct cvmx_mio_ptp_pps_lo_incr_s     cn78xxp2;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cnf71xx;
 };
 typedef union cvmx_mio_ptp_pps_lo_incr cvmx_mio_ptp_pps_lo_incr_t;
@@ -7979,7 +8189,9 @@ union cvmx_mio_ptp_pps_thresh_hi {
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xxp1;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn73xx;
+	struct cvmx_mio_ptp_pps_thresh_hi_s   cn75xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn78xx;
+	struct cvmx_mio_ptp_pps_thresh_hi_s   cn78xxp2;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cnf71xx;
 };
 typedef union cvmx_mio_ptp_pps_thresh_hi cvmx_mio_ptp_pps_thresh_hi_t;
@@ -8007,7 +8219,9 @@ union cvmx_mio_ptp_pps_thresh_lo {
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xxp1;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn73xx;
+	struct cvmx_mio_ptp_pps_thresh_lo_s   cn75xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn78xx;
+	struct cvmx_mio_ptp_pps_thresh_lo_s   cn78xxp2;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cnf71xx;
 };
 typedef union cvmx_mio_ptp_pps_thresh_lo cvmx_mio_ptp_pps_thresh_lo_t;
@@ -8036,7 +8250,9 @@ union cvmx_mio_ptp_timestamp {
 	struct cvmx_mio_ptp_timestamp_s       cn70xx;
 	struct cvmx_mio_ptp_timestamp_s       cn70xxp1;
 	struct cvmx_mio_ptp_timestamp_s       cn73xx;
+	struct cvmx_mio_ptp_timestamp_s       cn75xx;
 	struct cvmx_mio_ptp_timestamp_s       cn78xx;
+	struct cvmx_mio_ptp_timestamp_s       cn78xxp2;
 	struct cvmx_mio_ptp_timestamp_s       cnf71xx;
 };
 typedef union cvmx_mio_ptp_timestamp cvmx_mio_ptp_timestamp_t;
@@ -9630,7 +9846,9 @@ union cvmx_mio_twsx_int {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} cn73xx;
+	struct cvmx_mio_twsx_int_cn73xx       cn75xx;
 	struct cvmx_mio_twsx_int_cn73xx       cn78xx;
+	struct cvmx_mio_twsx_int_cn73xx       cn78xxp2;
 	struct cvmx_mio_twsx_int_s            cnf71xx;
 };
 typedef union cvmx_mio_twsx_int cvmx_mio_twsx_int_t;
@@ -9654,6 +9872,8 @@ union cvmx_mio_twsx_int_w1s {
 #endif
 	} s;
 	struct cvmx_mio_twsx_int_w1s_s        cn73xx;
+	struct cvmx_mio_twsx_int_w1s_s        cn75xx;
+	struct cvmx_mio_twsx_int_w1s_s        cn78xxp2;
 };
 typedef union cvmx_mio_twsx_int_w1s cvmx_mio_twsx_int_w1s_t;
 
@@ -9792,7 +10012,9 @@ union cvmx_mio_twsx_sw_twsi {
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xxp1;
 	struct cvmx_mio_twsx_sw_twsi_s        cn73xx;
+	struct cvmx_mio_twsx_sw_twsi_s        cn75xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn78xx;
+	struct cvmx_mio_twsx_sw_twsi_s        cn78xxp2;
 	struct cvmx_mio_twsx_sw_twsi_s        cnf71xx;
 };
 typedef union cvmx_mio_twsx_sw_twsi cvmx_mio_twsx_sw_twsi_t;
@@ -9841,7 +10063,9 @@ union cvmx_mio_twsx_sw_twsi_ext {
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xxp1;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn73xx;
+	struct cvmx_mio_twsx_sw_twsi_ext_s    cn75xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn78xx;
+	struct cvmx_mio_twsx_sw_twsi_ext_s    cn78xxp2;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cnf71xx;
 };
 typedef union cvmx_mio_twsx_sw_twsi_ext cvmx_mio_twsx_sw_twsi_ext_t;
@@ -9914,7 +10138,9 @@ union cvmx_mio_twsx_twsi_sw {
 	uint64_t v                            : 2;
 #endif
 	} cn73xx;
+	struct cvmx_mio_twsx_twsi_sw_cn73xx   cn75xx;
 	struct cvmx_mio_twsx_twsi_sw_cn73xx   cn78xx;
+	struct cvmx_mio_twsx_twsi_sw_cn73xx   cn78xxp2;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cnf71xx;
 };
 typedef union cvmx_mio_twsx_twsi_sw cvmx_mio_twsx_twsi_sw_t;
@@ -9963,7 +10189,9 @@ union cvmx_mio_uartx_dlh {
 	struct cvmx_mio_uartx_dlh_s           cn70xx;
 	struct cvmx_mio_uartx_dlh_s           cn70xxp1;
 	struct cvmx_mio_uartx_dlh_s           cn73xx;
+	struct cvmx_mio_uartx_dlh_s           cn75xx;
 	struct cvmx_mio_uartx_dlh_s           cn78xx;
+	struct cvmx_mio_uartx_dlh_s           cn78xxp2;
 	struct cvmx_mio_uartx_dlh_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_dlh cvmx_mio_uartx_dlh_t;
@@ -10013,7 +10241,9 @@ union cvmx_mio_uartx_dll {
 	struct cvmx_mio_uartx_dll_s           cn70xx;
 	struct cvmx_mio_uartx_dll_s           cn70xxp1;
 	struct cvmx_mio_uartx_dll_s           cn73xx;
+	struct cvmx_mio_uartx_dll_s           cn75xx;
 	struct cvmx_mio_uartx_dll_s           cn78xx;
+	struct cvmx_mio_uartx_dll_s           cn78xxp2;
 	struct cvmx_mio_uartx_dll_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_dll cvmx_mio_uartx_dll_t;
@@ -10060,7 +10290,9 @@ union cvmx_mio_uartx_far {
 	struct cvmx_mio_uartx_far_s           cn70xx;
 	struct cvmx_mio_uartx_far_s           cn70xxp1;
 	struct cvmx_mio_uartx_far_s           cn73xx;
+	struct cvmx_mio_uartx_far_s           cn75xx;
 	struct cvmx_mio_uartx_far_s           cn78xx;
+	struct cvmx_mio_uartx_far_s           cn78xxp2;
 	struct cvmx_mio_uartx_far_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_far cvmx_mio_uartx_far_t;
@@ -10114,7 +10346,9 @@ union cvmx_mio_uartx_fcr {
 	struct cvmx_mio_uartx_fcr_s           cn70xx;
 	struct cvmx_mio_uartx_fcr_s           cn70xxp1;
 	struct cvmx_mio_uartx_fcr_s           cn73xx;
+	struct cvmx_mio_uartx_fcr_s           cn75xx;
 	struct cvmx_mio_uartx_fcr_s           cn78xx;
+	struct cvmx_mio_uartx_fcr_s           cn78xxp2;
 	struct cvmx_mio_uartx_fcr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_fcr cvmx_mio_uartx_fcr_t;
@@ -10158,7 +10392,9 @@ union cvmx_mio_uartx_htx {
 	struct cvmx_mio_uartx_htx_s           cn70xx;
 	struct cvmx_mio_uartx_htx_s           cn70xxp1;
 	struct cvmx_mio_uartx_htx_s           cn73xx;
+	struct cvmx_mio_uartx_htx_s           cn75xx;
 	struct cvmx_mio_uartx_htx_s           cn78xx;
+	struct cvmx_mio_uartx_htx_s           cn78xxp2;
 	struct cvmx_mio_uartx_htx_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_htx cvmx_mio_uartx_htx_t;
@@ -10235,7 +10471,9 @@ union cvmx_mio_uartx_ier {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} cn73xx;
+	struct cvmx_mio_uartx_ier_cn73xx      cn75xx;
 	struct cvmx_mio_uartx_ier_cn73xx      cn78xx;
+	struct cvmx_mio_uartx_ier_cn73xx      cn78xxp2;
 	struct cvmx_mio_uartx_ier_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_ier cvmx_mio_uartx_ier_t;
@@ -10282,7 +10520,9 @@ union cvmx_mio_uartx_iir {
 	struct cvmx_mio_uartx_iir_s           cn70xx;
 	struct cvmx_mio_uartx_iir_s           cn70xxp1;
 	struct cvmx_mio_uartx_iir_s           cn73xx;
+	struct cvmx_mio_uartx_iir_s           cn75xx;
 	struct cvmx_mio_uartx_iir_s           cn78xx;
+	struct cvmx_mio_uartx_iir_s           cn78xxp2;
 	struct cvmx_mio_uartx_iir_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_iir cvmx_mio_uartx_iir_t;
@@ -10337,7 +10577,9 @@ union cvmx_mio_uartx_lcr {
 	struct cvmx_mio_uartx_lcr_s           cn70xx;
 	struct cvmx_mio_uartx_lcr_s           cn70xxp1;
 	struct cvmx_mio_uartx_lcr_s           cn73xx;
+	struct cvmx_mio_uartx_lcr_s           cn75xx;
 	struct cvmx_mio_uartx_lcr_s           cn78xx;
+	struct cvmx_mio_uartx_lcr_s           cn78xxp2;
 	struct cvmx_mio_uartx_lcr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_lcr cvmx_mio_uartx_lcr_t;
@@ -10394,7 +10636,9 @@ union cvmx_mio_uartx_lsr {
 	struct cvmx_mio_uartx_lsr_s           cn70xx;
 	struct cvmx_mio_uartx_lsr_s           cn70xxp1;
 	struct cvmx_mio_uartx_lsr_s           cn73xx;
+	struct cvmx_mio_uartx_lsr_s           cn75xx;
 	struct cvmx_mio_uartx_lsr_s           cn78xx;
+	struct cvmx_mio_uartx_lsr_s           cn78xxp2;
 	struct cvmx_mio_uartx_lsr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_lsr cvmx_mio_uartx_lsr_t;
@@ -10448,7 +10692,9 @@ union cvmx_mio_uartx_mcr {
 	struct cvmx_mio_uartx_mcr_s           cn70xx;
 	struct cvmx_mio_uartx_mcr_s           cn70xxp1;
 	struct cvmx_mio_uartx_mcr_s           cn73xx;
+	struct cvmx_mio_uartx_mcr_s           cn75xx;
 	struct cvmx_mio_uartx_mcr_s           cn78xx;
+	struct cvmx_mio_uartx_mcr_s           cn78xxp2;
 	struct cvmx_mio_uartx_mcr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_mcr cvmx_mio_uartx_mcr_t;
@@ -10505,7 +10751,9 @@ union cvmx_mio_uartx_msr {
 	struct cvmx_mio_uartx_msr_s           cn70xx;
 	struct cvmx_mio_uartx_msr_s           cn70xxp1;
 	struct cvmx_mio_uartx_msr_s           cn73xx;
+	struct cvmx_mio_uartx_msr_s           cn75xx;
 	struct cvmx_mio_uartx_msr_s           cn78xx;
+	struct cvmx_mio_uartx_msr_s           cn78xxp2;
 	struct cvmx_mio_uartx_msr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_msr cvmx_mio_uartx_msr_t;
@@ -10549,7 +10797,9 @@ union cvmx_mio_uartx_rbr {
 	struct cvmx_mio_uartx_rbr_s           cn70xx;
 	struct cvmx_mio_uartx_rbr_s           cn70xxp1;
 	struct cvmx_mio_uartx_rbr_s           cn73xx;
+	struct cvmx_mio_uartx_rbr_s           cn75xx;
 	struct cvmx_mio_uartx_rbr_s           cn78xx;
+	struct cvmx_mio_uartx_rbr_s           cn78xxp2;
 	struct cvmx_mio_uartx_rbr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_rbr cvmx_mio_uartx_rbr_t;
@@ -10592,7 +10842,9 @@ union cvmx_mio_uartx_rfl {
 	struct cvmx_mio_uartx_rfl_s           cn70xx;
 	struct cvmx_mio_uartx_rfl_s           cn70xxp1;
 	struct cvmx_mio_uartx_rfl_s           cn73xx;
+	struct cvmx_mio_uartx_rfl_s           cn75xx;
 	struct cvmx_mio_uartx_rfl_s           cn78xx;
+	struct cvmx_mio_uartx_rfl_s           cn78xxp2;
 	struct cvmx_mio_uartx_rfl_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_rfl cvmx_mio_uartx_rfl_t;
@@ -10639,7 +10891,9 @@ union cvmx_mio_uartx_rfw {
 	struct cvmx_mio_uartx_rfw_s           cn70xx;
 	struct cvmx_mio_uartx_rfw_s           cn70xxp1;
 	struct cvmx_mio_uartx_rfw_s           cn73xx;
+	struct cvmx_mio_uartx_rfw_s           cn75xx;
 	struct cvmx_mio_uartx_rfw_s           cn78xx;
+	struct cvmx_mio_uartx_rfw_s           cn78xxp2;
 	struct cvmx_mio_uartx_rfw_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_rfw cvmx_mio_uartx_rfw_t;
@@ -10683,7 +10937,9 @@ union cvmx_mio_uartx_sbcr {
 	struct cvmx_mio_uartx_sbcr_s          cn70xx;
 	struct cvmx_mio_uartx_sbcr_s          cn70xxp1;
 	struct cvmx_mio_uartx_sbcr_s          cn73xx;
+	struct cvmx_mio_uartx_sbcr_s          cn75xx;
 	struct cvmx_mio_uartx_sbcr_s          cn78xx;
+	struct cvmx_mio_uartx_sbcr_s          cn78xxp2;
 	struct cvmx_mio_uartx_sbcr_s          cnf71xx;
 };
 typedef union cvmx_mio_uartx_sbcr cvmx_mio_uartx_sbcr_t;
@@ -10726,7 +10982,9 @@ union cvmx_mio_uartx_scr {
 	struct cvmx_mio_uartx_scr_s           cn70xx;
 	struct cvmx_mio_uartx_scr_s           cn70xxp1;
 	struct cvmx_mio_uartx_scr_s           cn73xx;
+	struct cvmx_mio_uartx_scr_s           cn75xx;
 	struct cvmx_mio_uartx_scr_s           cn78xx;
+	struct cvmx_mio_uartx_scr_s           cn78xxp2;
 	struct cvmx_mio_uartx_scr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_scr cvmx_mio_uartx_scr_t;
@@ -10771,7 +11029,9 @@ union cvmx_mio_uartx_sfe {
 	struct cvmx_mio_uartx_sfe_s           cn70xx;
 	struct cvmx_mio_uartx_sfe_s           cn70xxp1;
 	struct cvmx_mio_uartx_sfe_s           cn73xx;
+	struct cvmx_mio_uartx_sfe_s           cn75xx;
 	struct cvmx_mio_uartx_sfe_s           cn78xx;
+	struct cvmx_mio_uartx_sfe_s           cn78xxp2;
 	struct cvmx_mio_uartx_sfe_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_sfe cvmx_mio_uartx_sfe_t;
@@ -10818,7 +11078,9 @@ union cvmx_mio_uartx_srr {
 	struct cvmx_mio_uartx_srr_s           cn70xx;
 	struct cvmx_mio_uartx_srr_s           cn70xxp1;
 	struct cvmx_mio_uartx_srr_s           cn73xx;
+	struct cvmx_mio_uartx_srr_s           cn75xx;
 	struct cvmx_mio_uartx_srr_s           cn78xx;
+	struct cvmx_mio_uartx_srr_s           cn78xxp2;
 	struct cvmx_mio_uartx_srr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_srr cvmx_mio_uartx_srr_t;
@@ -10863,7 +11125,9 @@ union cvmx_mio_uartx_srt {
 	struct cvmx_mio_uartx_srt_s           cn70xx;
 	struct cvmx_mio_uartx_srt_s           cn70xxp1;
 	struct cvmx_mio_uartx_srt_s           cn73xx;
+	struct cvmx_mio_uartx_srt_s           cn75xx;
 	struct cvmx_mio_uartx_srt_s           cn78xx;
+	struct cvmx_mio_uartx_srt_s           cn78xxp2;
 	struct cvmx_mio_uartx_srt_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_srt cvmx_mio_uartx_srt_t;
@@ -10907,7 +11171,9 @@ union cvmx_mio_uartx_srts {
 	struct cvmx_mio_uartx_srts_s          cn70xx;
 	struct cvmx_mio_uartx_srts_s          cn70xxp1;
 	struct cvmx_mio_uartx_srts_s          cn73xx;
+	struct cvmx_mio_uartx_srts_s          cn75xx;
 	struct cvmx_mio_uartx_srts_s          cn78xx;
+	struct cvmx_mio_uartx_srts_s          cn78xxp2;
 	struct cvmx_mio_uartx_srts_s          cnf71xx;
 };
 typedef union cvmx_mio_uartx_srts cvmx_mio_uartx_srts_t;
@@ -10952,7 +11218,9 @@ union cvmx_mio_uartx_stt {
 	struct cvmx_mio_uartx_stt_s           cn70xx;
 	struct cvmx_mio_uartx_stt_s           cn70xxp1;
 	struct cvmx_mio_uartx_stt_s           cn73xx;
+	struct cvmx_mio_uartx_stt_s           cn75xx;
 	struct cvmx_mio_uartx_stt_s           cn78xx;
+	struct cvmx_mio_uartx_stt_s           cn78xxp2;
 	struct cvmx_mio_uartx_stt_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_stt cvmx_mio_uartx_stt_t;
@@ -10995,7 +11263,9 @@ union cvmx_mio_uartx_tfl {
 	struct cvmx_mio_uartx_tfl_s           cn70xx;
 	struct cvmx_mio_uartx_tfl_s           cn70xxp1;
 	struct cvmx_mio_uartx_tfl_s           cn73xx;
+	struct cvmx_mio_uartx_tfl_s           cn75xx;
 	struct cvmx_mio_uartx_tfl_s           cn78xx;
+	struct cvmx_mio_uartx_tfl_s           cn78xxp2;
 	struct cvmx_mio_uartx_tfl_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_tfl cvmx_mio_uartx_tfl_t;
@@ -11038,7 +11308,9 @@ union cvmx_mio_uartx_tfr {
 	struct cvmx_mio_uartx_tfr_s           cn70xx;
 	struct cvmx_mio_uartx_tfr_s           cn70xxp1;
 	struct cvmx_mio_uartx_tfr_s           cn73xx;
+	struct cvmx_mio_uartx_tfr_s           cn75xx;
 	struct cvmx_mio_uartx_tfr_s           cn78xx;
+	struct cvmx_mio_uartx_tfr_s           cn78xxp2;
 	struct cvmx_mio_uartx_tfr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_tfr cvmx_mio_uartx_tfr_t;
@@ -11082,7 +11354,9 @@ union cvmx_mio_uartx_thr {
 	struct cvmx_mio_uartx_thr_s           cn70xx;
 	struct cvmx_mio_uartx_thr_s           cn70xxp1;
 	struct cvmx_mio_uartx_thr_s           cn73xx;
+	struct cvmx_mio_uartx_thr_s           cn75xx;
 	struct cvmx_mio_uartx_thr_s           cn78xx;
+	struct cvmx_mio_uartx_thr_s           cn78xxp2;
 	struct cvmx_mio_uartx_thr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_thr cvmx_mio_uartx_thr_t;
@@ -11133,7 +11407,9 @@ union cvmx_mio_uartx_usr {
 	struct cvmx_mio_uartx_usr_s           cn70xx;
 	struct cvmx_mio_uartx_usr_s           cn70xxp1;
 	struct cvmx_mio_uartx_usr_s           cn73xx;
+	struct cvmx_mio_uartx_usr_s           cn75xx;
 	struct cvmx_mio_uartx_usr_s           cn78xx;
+	struct cvmx_mio_uartx_usr_s           cn78xxp2;
 	struct cvmx_mio_uartx_usr_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_usr cvmx_mio_uartx_usr_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index 5f8dd33..9aa4fbb 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -63,6 +63,7 @@ static inline uint64_t CVMX_MIXX_BIST(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_BIST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100078ull) + ((offset) & 1) * 2048;
@@ -81,6 +82,7 @@ static inline uint64_t CVMX_MIXX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100020ull) + ((offset) & 1) * 2048;
@@ -115,6 +117,7 @@ static inline uint64_t CVMX_MIXX_IRCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100030ull) + ((offset) & 1) * 2048;
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_MIXX_IRHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100028ull) + ((offset) & 1) * 2048;
@@ -151,6 +155,7 @@ static inline uint64_t CVMX_MIXX_IRING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100010ull) + ((offset) & 1) * 2048;
@@ -169,6 +174,7 @@ static inline uint64_t CVMX_MIXX_IRING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100018ull) + ((offset) & 1) * 2048;
@@ -187,6 +193,7 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ISR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset) & 1) * 2048;
@@ -198,7 +205,8 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 static inline uint64_t CVMX_MIXX_ISR_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ISR_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset) & 1) * 2048;
 }
@@ -216,6 +224,7 @@ static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100040ull) + ((offset) & 1) * 2048;
@@ -234,6 +243,7 @@ static inline uint64_t CVMX_MIXX_ORHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100038ull) + ((offset) & 1) * 2048;
@@ -252,6 +262,7 @@ static inline uint64_t CVMX_MIXX_ORING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100000ull) + ((offset) & 1) * 2048;
@@ -270,6 +281,7 @@ static inline uint64_t CVMX_MIXX_ORING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100008ull) + ((offset) & 1) * 2048;
@@ -288,6 +300,7 @@ static inline uint64_t CVMX_MIXX_REMCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_REMCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100058ull) + ((offset) & 1) * 2048;
@@ -304,6 +317,7 @@ static inline uint64_t CVMX_MIXX_TSCTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100068ull) + ((offset) & 1) * 2048;
@@ -320,6 +334,7 @@ static inline uint64_t CVMX_MIXX_TSTAMP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSTAMP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100060ull) + ((offset) & 1) * 2048;
@@ -388,7 +403,9 @@ union cvmx_mixx_bist {
 	struct cvmx_mixx_bist_s               cn68xx;
 	struct cvmx_mixx_bist_s               cn68xxp1;
 	struct cvmx_mixx_bist_s               cn73xx;
+	struct cvmx_mixx_bist_s               cn75xx;
 	struct cvmx_mixx_bist_s               cn78xx;
+	struct cvmx_mixx_bist_s               cn78xxp2;
 };
 typedef union cvmx_mixx_bist cvmx_mixx_bist_t;
 
@@ -565,7 +582,9 @@ union cvmx_mixx_ctl {
 	struct cvmx_mixx_ctl_s                cn68xx;
 	struct cvmx_mixx_ctl_s                cn68xxp1;
 	struct cvmx_mixx_ctl_s                cn73xx;
+	struct cvmx_mixx_ctl_s                cn75xx;
 	struct cvmx_mixx_ctl_s                cn78xx;
+	struct cvmx_mixx_ctl_s                cn78xxp2;
 };
 typedef union cvmx_mixx_ctl cvmx_mixx_ctl_t;
 
@@ -738,7 +757,9 @@ union cvmx_mixx_ircnt {
 	struct cvmx_mixx_ircnt_s              cn68xx;
 	struct cvmx_mixx_ircnt_s              cn68xxp1;
 	struct cvmx_mixx_ircnt_s              cn73xx;
+	struct cvmx_mixx_ircnt_s              cn75xx;
 	struct cvmx_mixx_ircnt_s              cn78xx;
+	struct cvmx_mixx_ircnt_s              cn78xxp2;
 };
 typedef union cvmx_mixx_ircnt cvmx_mixx_ircnt_t;
 
@@ -782,7 +803,9 @@ union cvmx_mixx_irhwm {
 	struct cvmx_mixx_irhwm_s              cn68xx;
 	struct cvmx_mixx_irhwm_s              cn68xxp1;
 	struct cvmx_mixx_irhwm_s              cn73xx;
+	struct cvmx_mixx_irhwm_s              cn75xx;
 	struct cvmx_mixx_irhwm_s              cn78xx;
+	struct cvmx_mixx_irhwm_s              cn78xxp2;
 };
 typedef union cvmx_mixx_irhwm cvmx_mixx_irhwm_t;
 
@@ -869,7 +892,9 @@ union cvmx_mixx_iring1 {
 	uint64_t isize                        : 20;
 #endif
 	} cn73xx;
+	struct cvmx_mixx_iring1_cn73xx        cn75xx;
 	struct cvmx_mixx_iring1_cn73xx        cn78xx;
+	struct cvmx_mixx_iring1_cn73xx        cn78xxp2;
 };
 typedef union cvmx_mixx_iring1 cvmx_mixx_iring1_t;
 
@@ -918,7 +943,9 @@ union cvmx_mixx_iring2 {
 	struct cvmx_mixx_iring2_s             cn68xx;
 	struct cvmx_mixx_iring2_s             cn68xxp1;
 	struct cvmx_mixx_iring2_s             cn73xx;
+	struct cvmx_mixx_iring2_s             cn75xx;
 	struct cvmx_mixx_iring2_s             cn78xx;
+	struct cvmx_mixx_iring2_s             cn78xxp2;
 };
 typedef union cvmx_mixx_iring2 cvmx_mixx_iring2_t;
 
@@ -1115,7 +1142,9 @@ union cvmx_mixx_isr {
 	struct cvmx_mixx_isr_s                cn68xx;
 	struct cvmx_mixx_isr_s                cn68xxp1;
 	struct cvmx_mixx_isr_s                cn73xx;
+	struct cvmx_mixx_isr_s                cn75xx;
 	struct cvmx_mixx_isr_s                cn78xx;
+	struct cvmx_mixx_isr_s                cn78xxp2;
 };
 typedef union cvmx_mixx_isr cvmx_mixx_isr_t;
 
@@ -1198,6 +1227,8 @@ union cvmx_mixx_isr_w1s {
 #endif
 	} s;
 	struct cvmx_mixx_isr_w1s_s            cn73xx;
+	struct cvmx_mixx_isr_w1s_s            cn75xx;
+	struct cvmx_mixx_isr_w1s_s            cn78xxp2;
 };
 typedef union cvmx_mixx_isr_w1s cvmx_mixx_isr_w1s_t;
 
@@ -1241,7 +1272,9 @@ union cvmx_mixx_orcnt {
 	struct cvmx_mixx_orcnt_s              cn68xx;
 	struct cvmx_mixx_orcnt_s              cn68xxp1;
 	struct cvmx_mixx_orcnt_s              cn73xx;
+	struct cvmx_mixx_orcnt_s              cn75xx;
 	struct cvmx_mixx_orcnt_s              cn78xx;
+	struct cvmx_mixx_orcnt_s              cn78xxp2;
 };
 typedef union cvmx_mixx_orcnt cvmx_mixx_orcnt_t;
 
@@ -1278,7 +1311,9 @@ union cvmx_mixx_orhwm {
 	struct cvmx_mixx_orhwm_s              cn68xx;
 	struct cvmx_mixx_orhwm_s              cn68xxp1;
 	struct cvmx_mixx_orhwm_s              cn73xx;
+	struct cvmx_mixx_orhwm_s              cn75xx;
 	struct cvmx_mixx_orhwm_s              cn78xx;
+	struct cvmx_mixx_orhwm_s              cn78xxp2;
 };
 typedef union cvmx_mixx_orhwm cvmx_mixx_orhwm_t;
 
@@ -1365,7 +1400,9 @@ union cvmx_mixx_oring1 {
 	uint64_t osize                        : 20;
 #endif
 	} cn73xx;
+	struct cvmx_mixx_oring1_cn73xx        cn75xx;
 	struct cvmx_mixx_oring1_cn73xx        cn78xx;
+	struct cvmx_mixx_oring1_cn73xx        cn78xxp2;
 };
 typedef union cvmx_mixx_oring1 cvmx_mixx_oring1_t;
 
@@ -1414,7 +1451,9 @@ union cvmx_mixx_oring2 {
 	struct cvmx_mixx_oring2_s             cn68xx;
 	struct cvmx_mixx_oring2_s             cn68xxp1;
 	struct cvmx_mixx_oring2_s             cn73xx;
+	struct cvmx_mixx_oring2_s             cn75xx;
 	struct cvmx_mixx_oring2_s             cn78xx;
+	struct cvmx_mixx_oring2_s             cn78xxp2;
 };
 typedef union cvmx_mixx_oring2 cvmx_mixx_oring2_t;
 
@@ -1464,7 +1503,9 @@ union cvmx_mixx_remcnt {
 	struct cvmx_mixx_remcnt_s             cn68xx;
 	struct cvmx_mixx_remcnt_s             cn68xxp1;
 	struct cvmx_mixx_remcnt_s             cn73xx;
+	struct cvmx_mixx_remcnt_s             cn75xx;
 	struct cvmx_mixx_remcnt_s             cn78xx;
+	struct cvmx_mixx_remcnt_s             cn78xxp2;
 };
 typedef union cvmx_mixx_remcnt cvmx_mixx_remcnt_t;
 
@@ -1519,7 +1560,9 @@ union cvmx_mixx_tsctl {
 	struct cvmx_mixx_tsctl_s              cn68xx;
 	struct cvmx_mixx_tsctl_s              cn68xxp1;
 	struct cvmx_mixx_tsctl_s              cn73xx;
+	struct cvmx_mixx_tsctl_s              cn75xx;
 	struct cvmx_mixx_tsctl_s              cn78xx;
+	struct cvmx_mixx_tsctl_s              cn78xxp2;
 };
 typedef union cvmx_mixx_tsctl cvmx_mixx_tsctl_t;
 
@@ -1568,7 +1611,9 @@ union cvmx_mixx_tstamp {
 	struct cvmx_mixx_tstamp_s             cn68xx;
 	struct cvmx_mixx_tstamp_s             cn68xxp1;
 	struct cvmx_mixx_tstamp_s             cn73xx;
+	struct cvmx_mixx_tstamp_s             cn75xx;
 	struct cvmx_mixx_tstamp_s             cn78xx;
+	struct cvmx_mixx_tstamp_s             cn78xxp2;
 };
 typedef union cvmx_mixx_tstamp cvmx_mixx_tstamp_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index 79fc801..58cce4f 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_MPI_CFG CVMX_MPI_CFG_FUNC()
 static inline uint64_t CVMX_MPI_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001000ull);
 }
@@ -74,6 +74,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 8))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_MPI_DATX(%lu) is invalid on this chip\n", offset);
@@ -86,7 +87,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 #define CVMX_MPI_STS CVMX_MPI_STS_FUNC()
 static inline uint64_t CVMX_MPI_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001008ull);
 }
@@ -97,7 +98,7 @@ static inline uint64_t CVMX_MPI_STS_FUNC(void)
 #define CVMX_MPI_STS_W1S CVMX_MPI_STS_W1S_FUNC()
 static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_MPI_STS_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001018ull);
 }
@@ -108,7 +109,7 @@ static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
 #define CVMX_MPI_TX CVMX_MPI_TX_FUNC()
 static inline uint64_t CVMX_MPI_TX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_TX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001010ull);
 }
@@ -119,7 +120,7 @@ static inline uint64_t CVMX_MPI_TX_FUNC(void)
 #define CVMX_MPI_WIDE_DAT CVMX_MPI_WIDE_DAT_FUNC()
 static inline uint64_t CVMX_MPI_WIDE_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MPI_WIDE_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001040ull);
 }
@@ -592,7 +593,9 @@ union cvmx_mpi_cfg {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} cn73xx;
+	struct cvmx_mpi_cfg_cn73xx            cn75xx;
 	struct cvmx_mpi_cfg_cn73xx            cn78xx;
+	struct cvmx_mpi_cfg_cn73xx            cn78xxp2;
 	struct cvmx_mpi_cfg_cn61xx            cnf71xx;
 };
 typedef union cvmx_mpi_cfg cvmx_mpi_cfg_t;
@@ -619,7 +622,9 @@ union cvmx_mpi_datx {
 	struct cvmx_mpi_datx_s                cn70xx;
 	struct cvmx_mpi_datx_s                cn70xxp1;
 	struct cvmx_mpi_datx_s                cn73xx;
+	struct cvmx_mpi_datx_s                cn75xx;
 	struct cvmx_mpi_datx_s                cn78xx;
+	struct cvmx_mpi_datx_s                cn78xxp2;
 	struct cvmx_mpi_datx_s                cnf71xx;
 };
 typedef union cvmx_mpi_datx cvmx_mpi_datx_t;
@@ -666,7 +671,9 @@ union cvmx_mpi_sts {
 	struct cvmx_mpi_sts_cn30xx            cn70xx;
 	struct cvmx_mpi_sts_cn30xx            cn70xxp1;
 	struct cvmx_mpi_sts_s                 cn73xx;
+	struct cvmx_mpi_sts_s                 cn75xx;
 	struct cvmx_mpi_sts_s                 cn78xx;
+	struct cvmx_mpi_sts_s                 cn78xxp2;
 	struct cvmx_mpi_sts_cn30xx            cnf71xx;
 };
 typedef union cvmx_mpi_sts cvmx_mpi_sts_t;
@@ -691,6 +698,8 @@ union cvmx_mpi_sts_w1s {
 #endif
 	} s;
 	struct cvmx_mpi_sts_w1s_s             cn73xx;
+	struct cvmx_mpi_sts_w1s_s             cn75xx;
+	struct cvmx_mpi_sts_w1s_s             cn78xxp2;
 };
 typedef union cvmx_mpi_sts_w1s cvmx_mpi_sts_w1s_t;
 
@@ -788,7 +797,9 @@ union cvmx_mpi_tx {
 	} cn70xx;
 	struct cvmx_mpi_tx_cn70xx             cn70xxp1;
 	struct cvmx_mpi_tx_s                  cn73xx;
+	struct cvmx_mpi_tx_s                  cn75xx;
 	struct cvmx_mpi_tx_s                  cn78xx;
+	struct cvmx_mpi_tx_s                  cn78xxp2;
 	struct cvmx_mpi_tx_cn61xx             cnf71xx;
 };
 typedef union cvmx_mpi_tx cvmx_mpi_tx_t;
@@ -811,7 +822,9 @@ union cvmx_mpi_wide_dat {
 	struct cvmx_mpi_wide_dat_s            cn70xx;
 	struct cvmx_mpi_wide_dat_s            cn70xxp1;
 	struct cvmx_mpi_wide_dat_s            cn73xx;
+	struct cvmx_mpi_wide_dat_s            cn75xx;
 	struct cvmx_mpi_wide_dat_s            cn78xx;
+	struct cvmx_mpi_wide_dat_s            cn78xxp2;
 };
 typedef union cvmx_mpi_wide_dat cvmx_mpi_wide_dat_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
index 08dc547..68909e7 100644
--- a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_NDF_BT_PG_INFO CVMX_NDF_BT_PG_INFO_FUNC()
 static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_BT_PG_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 #define CVMX_NDF_CMD CVMX_NDF_CMD_FUNC()
 static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000000ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 #define CVMX_NDF_DMA_ADR CVMX_NDF_DMA_ADR_FUNC()
 static inline uint64_t CVMX_NDF_DMA_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_DMA_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000058ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_NDF_DMA_ADR_FUNC(void)
 #define CVMX_NDF_DMA_CFG CVMX_NDF_DMA_CFG_FUNC()
 static inline uint64_t CVMX_NDF_DMA_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_DMA_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000050ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_NDF_DMA_CFG_FUNC(void)
 #define CVMX_NDF_DRBELL CVMX_NDF_DRBELL_FUNC()
 static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_DRBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000030ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 #define CVMX_NDF_ECC_CNT CVMX_NDF_ECC_CNT_FUNC()
 static inline uint64_t CVMX_NDF_ECC_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_ECC_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000010ull);
 }
@@ -124,6 +124,7 @@ static inline uint64_t CVMX_NDF_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -143,6 +144,7 @@ static inline uint64_t CVMX_NDF_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -169,7 +171,7 @@ static inline uint64_t CVMX_NDF_INT_EN_FUNC(void)
 #define CVMX_NDF_INT_W1S CVMX_NDF_INT_W1S_FUNC()
 static inline uint64_t CVMX_NDF_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000048ull);
 }
@@ -180,7 +182,7 @@ static inline uint64_t CVMX_NDF_INT_W1S_FUNC(void)
 #define CVMX_NDF_MISC CVMX_NDF_MISC_FUNC()
 static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_MISC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000008ull);
 }
@@ -191,7 +193,7 @@ static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 #define CVMX_NDF_ST_REG CVMX_NDF_ST_REG_FUNC()
 static inline uint64_t CVMX_NDF_ST_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_NDF_ST_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000038ull);
 }
@@ -245,6 +247,7 @@ union cvmx_ndf_bt_pg_info {
 	struct cvmx_ndf_bt_pg_info_s          cn70xx;
 	struct cvmx_ndf_bt_pg_info_s          cn70xxp1;
 	struct cvmx_ndf_bt_pg_info_s          cn73xx;
+	struct cvmx_ndf_bt_pg_info_s          cn75xx;
 };
 typedef union cvmx_ndf_bt_pg_info cvmx_ndf_bt_pg_info_t;
 
@@ -278,6 +281,7 @@ union cvmx_ndf_cmd {
 	struct cvmx_ndf_cmd_s                 cn70xx;
 	struct cvmx_ndf_cmd_s                 cn70xxp1;
 	struct cvmx_ndf_cmd_s                 cn73xx;
+	struct cvmx_ndf_cmd_s                 cn75xx;
 };
 typedef union cvmx_ndf_cmd cvmx_ndf_cmd_t;
 
@@ -301,6 +305,7 @@ union cvmx_ndf_dma_adr {
 #endif
 	} s;
 	struct cvmx_ndf_dma_adr_s             cn73xx;
+	struct cvmx_ndf_dma_adr_s             cn75xx;
 };
 typedef union cvmx_ndf_dma_adr cvmx_ndf_dma_adr_t;
 
@@ -341,6 +346,7 @@ union cvmx_ndf_dma_cfg {
 #endif
 	} s;
 	struct cvmx_ndf_dma_cfg_s             cn73xx;
+	struct cvmx_ndf_dma_cfg_s             cn75xx;
 };
 typedef union cvmx_ndf_dma_cfg cvmx_ndf_dma_cfg_t;
 
@@ -392,6 +398,7 @@ union cvmx_ndf_drbell {
 	struct cvmx_ndf_drbell_s              cn70xx;
 	struct cvmx_ndf_drbell_s              cn70xxp1;
 	struct cvmx_ndf_drbell_s              cn73xx;
+	struct cvmx_ndf_drbell_s              cn75xx;
 };
 typedef union cvmx_ndf_drbell cvmx_ndf_drbell_t;
 
@@ -430,6 +437,7 @@ union cvmx_ndf_ecc_cnt {
 	struct cvmx_ndf_ecc_cnt_s             cn70xx;
 	struct cvmx_ndf_ecc_cnt_s             cn70xxp1;
 	struct cvmx_ndf_ecc_cnt_s             cn73xx;
+	struct cvmx_ndf_ecc_cnt_s             cn75xx;
 };
 typedef union cvmx_ndf_ecc_cnt cvmx_ndf_ecc_cnt_t;
 
@@ -496,6 +504,7 @@ union cvmx_ndf_int {
 	struct cvmx_ndf_int_cn52xx            cn70xx;
 	struct cvmx_ndf_int_cn52xx            cn70xxp1;
 	struct cvmx_ndf_int_s                 cn73xx;
+	struct cvmx_ndf_int_s                 cn75xx;
 };
 typedef union cvmx_ndf_int cvmx_ndf_int_t;
 
@@ -571,6 +580,7 @@ union cvmx_ndf_int_w1s {
 #endif
 	} s;
 	struct cvmx_ndf_int_w1s_s             cn73xx;
+	struct cvmx_ndf_int_w1s_s             cn75xx;
 };
 typedef union cvmx_ndf_int_w1s cvmx_ndf_int_w1s_t;
 
@@ -685,6 +695,7 @@ union cvmx_ndf_misc {
 	struct cvmx_ndf_misc_s                cn70xx;
 	struct cvmx_ndf_misc_s                cn70xxp1;
 	struct cvmx_ndf_misc_s                cn73xx;
+	struct cvmx_ndf_misc_s                cn75xx;
 };
 typedef union cvmx_ndf_misc cvmx_ndf_misc_t;
 
@@ -728,6 +739,7 @@ union cvmx_ndf_st_reg {
 	struct cvmx_ndf_st_reg_s              cn70xx;
 	struct cvmx_ndf_st_reg_s              cn70xxp1;
 	struct cvmx_ndf_st_reg_s              cn73xx;
+	struct cvmx_ndf_st_reg_s              cn75xx;
 };
 typedef union cvmx_ndf_st_reg cvmx_ndf_st_reg_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 10dbbac..d397571 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -58,6 +58,7 @@ static inline uint64_t CVMX_OCLAX_BIST_RESULT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((offset) & 7) * 0x1000000ull;
@@ -71,6 +72,7 @@ static inline uint64_t CVMX_OCLAX_CDHX_CTL(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_CDHX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000600ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -84,6 +86,7 @@ static inline uint64_t CVMX_OCLAX_CONST(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_CONST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((offset) & 7) * 0x1000000ull;
@@ -97,6 +100,7 @@ static inline uint64_t CVMX_OCLAX_DATX(unsigned long offset, unsigned long block
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 8191)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8191)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 8191)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8191)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8400000ull) + (((offset) & 8191) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -110,6 +114,7 @@ static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_DAT_POP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((offset) & 7) * 0x1000000ull;
@@ -122,12 +127,13 @@ static inline uint64_t CVMX_OCLAX_ECO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_ECO(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 3) * 0x1000000ull)
+#define CVMX_OCLAX_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long offset)
@@ -135,6 +141,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_DEPTH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((offset) & 7) * 0x1000000ull;
@@ -148,6 +155,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_LIMIT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_LIMIT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((offset) & 7) * 0x1000000ull;
@@ -161,6 +169,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TAIL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TAIL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((offset) & 7) * 0x1000000ull;
@@ -174,6 +183,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TRIG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TRIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((offset) & 7) * 0x1000000ull;
@@ -187,6 +197,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_WRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_WRAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((offset) & 7) * 0x1000000ull;
@@ -200,6 +211,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ANDX_IX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ANDX_IX(%lu,%lu,%lu,%lu) is invalid on this chip\n", a, b, c, d);
 	return CVMX_ADD_IO_SEG(0x00011800A8300000ull) + ((a) << 24) + ((b) << 12) + ((c) << 4) + ((d) << 3);
@@ -213,6 +225,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ORX(unsigned long a, unsigned long b, uns
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ORX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8310000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -226,6 +239,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_STATEX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_STATEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8320000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -239,6 +253,7 @@ static inline uint64_t CVMX_OCLAX_GEN_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_GEN_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((offset) & 7) * 0x1000000ull;
@@ -252,6 +267,7 @@ static inline uint64_t CVMX_OCLAX_MATX_COUNT(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_COUNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8230000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -265,6 +281,7 @@ static inline uint64_t CVMX_OCLAX_MATX_CTL(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8200000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -278,6 +295,7 @@ static inline uint64_t CVMX_OCLAX_MATX_MASKX(unsigned long a, unsigned long b, u
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_MASKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8220000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -291,6 +309,7 @@ static inline uint64_t CVMX_OCLAX_MATX_THRESH(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8240000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -304,6 +323,7 @@ static inline uint64_t CVMX_OCLAX_MATX_VALUEX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_VALUEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8210000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -317,6 +337,7 @@ static inline uint64_t CVMX_OCLAX_RAWX(unsigned long offset, unsigned long block
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_RAWX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000100ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -330,6 +351,7 @@ static inline uint64_t CVMX_OCLAX_SFT_RST(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_SFT_RST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((offset) & 7) * 0x1000000ull;
@@ -343,6 +365,7 @@ static inline uint64_t CVMX_OCLAX_STACK_BASE(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_BASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((offset) & 7) * 0x1000000ull;
@@ -356,6 +379,7 @@ static inline uint64_t CVMX_OCLAX_STACK_CUR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_CUR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((offset) & 7) * 0x1000000ull;
@@ -369,6 +393,7 @@ static inline uint64_t CVMX_OCLAX_STACK_STORE_CNT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_STORE_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((offset) & 7) * 0x1000000ull;
@@ -382,6 +407,7 @@ static inline uint64_t CVMX_OCLAX_STACK_TOP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_TOP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((offset) & 7) * 0x1000000ull;
@@ -395,6 +421,7 @@ static inline uint64_t CVMX_OCLAX_STACK_WRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_WRAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((offset) & 7) * 0x1000000ull;
@@ -408,6 +435,7 @@ static inline uint64_t CVMX_OCLAX_STAGEX(unsigned long offset, unsigned long blo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 71)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 71)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 71)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 71)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_STAGEX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8100000ull) + (((offset) & 127) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -421,6 +449,7 @@ static inline uint64_t CVMX_OCLAX_STATE_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STATE_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((offset) & 7) * 0x1000000ull;
@@ -434,6 +463,7 @@ static inline uint64_t CVMX_OCLAX_STATE_SET(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STATE_SET(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((offset) & 7) * 0x1000000ull;
@@ -447,6 +477,7 @@ static inline uint64_t CVMX_OCLAX_TIME(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_OCLAX_TIME(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((offset) & 7) * 0x1000000ull;
@@ -475,7 +506,9 @@ union cvmx_oclax_bist_result {
 	struct cvmx_oclax_bist_result_s       cn70xx;
 	struct cvmx_oclax_bist_result_s       cn70xxp1;
 	struct cvmx_oclax_bist_result_s       cn73xx;
+	struct cvmx_oclax_bist_result_s       cn75xx;
 	struct cvmx_oclax_bist_result_s       cn78xx;
+	struct cvmx_oclax_bist_result_s       cn78xxp2;
 };
 typedef union cvmx_oclax_bist_result cvmx_oclax_bist_result_t;
 
@@ -514,7 +547,9 @@ union cvmx_oclax_cdhx_ctl {
 	struct cvmx_oclax_cdhx_ctl_s          cn70xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn70xxp1;
 	struct cvmx_oclax_cdhx_ctl_s          cn73xx;
+	struct cvmx_oclax_cdhx_ctl_s          cn75xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn78xx;
+	struct cvmx_oclax_cdhx_ctl_s          cn78xxp2;
 };
 typedef union cvmx_oclax_cdhx_ctl cvmx_oclax_cdhx_ctl_t;
 
@@ -537,7 +572,9 @@ union cvmx_oclax_const {
 	struct cvmx_oclax_const_s             cn70xx;
 	struct cvmx_oclax_const_s             cn70xxp1;
 	struct cvmx_oclax_const_s             cn73xx;
+	struct cvmx_oclax_const_s             cn75xx;
 	struct cvmx_oclax_const_s             cn78xx;
+	struct cvmx_oclax_const_s             cn78xxp2;
 };
 typedef union cvmx_oclax_const cvmx_oclax_const_t;
 
@@ -558,7 +595,9 @@ union cvmx_oclax_datx {
 	struct cvmx_oclax_datx_s              cn70xx;
 	struct cvmx_oclax_datx_s              cn70xxp1;
 	struct cvmx_oclax_datx_s              cn73xx;
+	struct cvmx_oclax_datx_s              cn75xx;
 	struct cvmx_oclax_datx_s              cn78xx;
+	struct cvmx_oclax_datx_s              cn78xxp2;
 };
 typedef union cvmx_oclax_datx cvmx_oclax_datx_t;
 
@@ -589,7 +628,9 @@ union cvmx_oclax_dat_pop {
 	struct cvmx_oclax_dat_pop_s           cn70xx;
 	struct cvmx_oclax_dat_pop_s           cn70xxp1;
 	struct cvmx_oclax_dat_pop_s           cn73xx;
+	struct cvmx_oclax_dat_pop_s           cn75xx;
 	struct cvmx_oclax_dat_pop_s           cn78xx;
+	struct cvmx_oclax_dat_pop_s           cn78xxp2;
 };
 typedef union cvmx_oclax_dat_pop cvmx_oclax_dat_pop_t;
 
@@ -612,6 +653,8 @@ union cvmx_oclax_eco {
 	} s;
 	struct cvmx_oclax_eco_s               cn70xx;
 	struct cvmx_oclax_eco_s               cn73xx;
+	struct cvmx_oclax_eco_s               cn75xx;
+	struct cvmx_oclax_eco_s               cn78xxp2;
 };
 typedef union cvmx_oclax_eco cvmx_oclax_eco_t;
 
@@ -632,7 +675,9 @@ union cvmx_oclax_fifo_depth {
 	struct cvmx_oclax_fifo_depth_s        cn70xx;
 	struct cvmx_oclax_fifo_depth_s        cn70xxp1;
 	struct cvmx_oclax_fifo_depth_s        cn73xx;
+	struct cvmx_oclax_fifo_depth_s        cn75xx;
 	struct cvmx_oclax_fifo_depth_s        cn78xx;
+	struct cvmx_oclax_fifo_depth_s        cn78xxp2;
 };
 typedef union cvmx_oclax_fifo_depth cvmx_oclax_fifo_depth_t;
 
@@ -664,7 +709,9 @@ union cvmx_oclax_fifo_limit {
 	struct cvmx_oclax_fifo_limit_s        cn70xx;
 	struct cvmx_oclax_fifo_limit_s        cn70xxp1;
 	struct cvmx_oclax_fifo_limit_s        cn73xx;
+	struct cvmx_oclax_fifo_limit_s        cn75xx;
 	struct cvmx_oclax_fifo_limit_s        cn78xx;
+	struct cvmx_oclax_fifo_limit_s        cn78xxp2;
 };
 typedef union cvmx_oclax_fifo_limit cvmx_oclax_fifo_limit_t;
 
@@ -685,7 +732,9 @@ union cvmx_oclax_fifo_tail {
 	struct cvmx_oclax_fifo_tail_s         cn70xx;
 	struct cvmx_oclax_fifo_tail_s         cn70xxp1;
 	struct cvmx_oclax_fifo_tail_s         cn73xx;
+	struct cvmx_oclax_fifo_tail_s         cn75xx;
 	struct cvmx_oclax_fifo_tail_s         cn78xx;
+	struct cvmx_oclax_fifo_tail_s         cn78xxp2;
 };
 typedef union cvmx_oclax_fifo_tail cvmx_oclax_fifo_tail_t;
 
@@ -710,7 +759,9 @@ union cvmx_oclax_fifo_trig {
 	struct cvmx_oclax_fifo_trig_s         cn70xx;
 	struct cvmx_oclax_fifo_trig_s         cn70xxp1;
 	struct cvmx_oclax_fifo_trig_s         cn73xx;
+	struct cvmx_oclax_fifo_trig_s         cn75xx;
 	struct cvmx_oclax_fifo_trig_s         cn78xx;
+	struct cvmx_oclax_fifo_trig_s         cn78xxp2;
 };
 typedef union cvmx_oclax_fifo_trig cvmx_oclax_fifo_trig_t;
 
@@ -733,7 +784,9 @@ union cvmx_oclax_fifo_wrap {
 	struct cvmx_oclax_fifo_wrap_s         cn70xx;
 	struct cvmx_oclax_fifo_wrap_s         cn70xxp1;
 	struct cvmx_oclax_fifo_wrap_s         cn73xx;
+	struct cvmx_oclax_fifo_wrap_s         cn75xx;
 	struct cvmx_oclax_fifo_wrap_s         cn78xx;
+	struct cvmx_oclax_fifo_wrap_s         cn78xxp2;
 };
 typedef union cvmx_oclax_fifo_wrap cvmx_oclax_fifo_wrap_t;
 
@@ -749,7 +802,7 @@ union cvmx_oclax_fsmx_andx_ix {
 	struct cvmx_oclax_fsmx_andx_ix_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t trig                         : 1;  /**< Reserved. */
+	uint64_t trig                         : 1;  /**< AND plane control for trigger FSM input. Added in pass 2. */
 	uint64_t mcd                          : 3;  /**< AND plane control for multichip debug (MCD) 0..2 FSM inputs. */
 	uint64_t match                        : 4;  /**< AND plane control for matcher 0..3 FSM inputs. */
 	uint64_t fsm1_state                   : 4;  /**< AND plane control for FSM 1 last state input. */
@@ -766,7 +819,9 @@ union cvmx_oclax_fsmx_andx_ix {
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xxp1;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn73xx;
+	struct cvmx_oclax_fsmx_andx_ix_s      cn75xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn78xx;
+	struct cvmx_oclax_fsmx_andx_ix_s      cn78xxp2;
 };
 typedef union cvmx_oclax_fsmx_andx_ix cvmx_oclax_fsmx_andx_ix_t;
 
@@ -795,7 +850,9 @@ union cvmx_oclax_fsmx_orx {
 #endif
 	} cn70xxp1;
 	struct cvmx_oclax_fsmx_orx_s          cn73xx;
+	struct cvmx_oclax_fsmx_orx_s          cn75xx;
 	struct cvmx_oclax_fsmx_orx_cn70xxp1   cn78xx;
+	struct cvmx_oclax_fsmx_orx_s          cn78xxp2;
 };
 typedef union cvmx_oclax_fsmx_orx cvmx_oclax_fsmx_orx_t;
 
@@ -810,7 +867,9 @@ union cvmx_oclax_fsmx_statex {
 	struct cvmx_oclax_fsmx_statex_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_31_63               : 33;
-	uint64_t sinfo_set                    : 1;  /**< Reserved. */
+	uint64_t sinfo_set                    : 1;  /**< If a control packet is generated in this state (due to capture starting
+                                                         in the next cycle), set OCLA_CAP_CTL_S[SINFO].
+                                                         Added in pass 2. */
 	uint64_t set_int                      : 1;  /**< In this state set interrupt. */
 	uint64_t cap                          : 1;  /**< In this state request capture this cycle. */
 	uint64_t set_mcd                      : 3;  /**< In this state set MCD. */
@@ -840,7 +899,9 @@ union cvmx_oclax_fsmx_statex {
 	struct cvmx_oclax_fsmx_statex_s       cn70xx;
 	struct cvmx_oclax_fsmx_statex_s       cn70xxp1;
 	struct cvmx_oclax_fsmx_statex_s       cn73xx;
+	struct cvmx_oclax_fsmx_statex_s       cn75xx;
 	struct cvmx_oclax_fsmx_statex_s       cn78xx;
+	struct cvmx_oclax_fsmx_statex_s       cn78xxp2;
 };
 typedef union cvmx_oclax_fsmx_statex cvmx_oclax_fsmx_statex_t;
 
@@ -852,7 +913,11 @@ union cvmx_oclax_gen_ctl {
 	struct cvmx_oclax_gen_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t mcdtrig                      : 3;  /**< Reserved. */
+	uint64_t mcdtrig                      : 3;  /**< Enable MCD triggering. For each bit corresponding to the three MCDs:
+                                                         0 = MCD does not cause trigger.
+                                                         1 = When the corresponding MCD is received it will cause
+                                                         triggerring and set OCLA()_STATE_SET[TRIG].
+                                                         Added in pass 2. */
 	uint64_t exten                        : 1;  /**< Enable external triggering.
                                                          0 = External triggering ignored.
                                                          1 = When the external trigger pin selected with GPIO_OCLA_EXTEN_TRIG is high it will cause
@@ -875,7 +940,9 @@ union cvmx_oclax_gen_ctl {
 	struct cvmx_oclax_gen_ctl_s           cn70xx;
 	struct cvmx_oclax_gen_ctl_s           cn70xxp1;
 	struct cvmx_oclax_gen_ctl_s           cn73xx;
+	struct cvmx_oclax_gen_ctl_s           cn75xx;
 	struct cvmx_oclax_gen_ctl_s           cn78xx;
+	struct cvmx_oclax_gen_ctl_s           cn78xxp2;
 };
 typedef union cvmx_oclax_gen_ctl cvmx_oclax_gen_ctl_t;
 
@@ -897,7 +964,9 @@ union cvmx_oclax_matx_count {
 	struct cvmx_oclax_matx_count_s        cn70xx;
 	struct cvmx_oclax_matx_count_s        cn70xxp1;
 	struct cvmx_oclax_matx_count_s        cn73xx;
+	struct cvmx_oclax_matx_count_s        cn75xx;
 	struct cvmx_oclax_matx_count_s        cn78xx;
+	struct cvmx_oclax_matx_count_s        cn78xxp2;
 };
 typedef union cvmx_oclax_matx_count cvmx_oclax_matx_count_t;
 
@@ -925,7 +994,9 @@ union cvmx_oclax_matx_ctl {
 	struct cvmx_oclax_matx_ctl_s          cn70xx;
 	struct cvmx_oclax_matx_ctl_s          cn70xxp1;
 	struct cvmx_oclax_matx_ctl_s          cn73xx;
+	struct cvmx_oclax_matx_ctl_s          cn75xx;
 	struct cvmx_oclax_matx_ctl_s          cn78xx;
+	struct cvmx_oclax_matx_ctl_s          cn78xxp2;
 };
 typedef union cvmx_oclax_matx_ctl cvmx_oclax_matx_ctl_t;
 
@@ -952,7 +1023,9 @@ union cvmx_oclax_matx_maskx {
 	struct cvmx_oclax_matx_maskx_s        cn70xx;
 	struct cvmx_oclax_matx_maskx_s        cn70xxp1;
 	struct cvmx_oclax_matx_maskx_s        cn73xx;
+	struct cvmx_oclax_matx_maskx_s        cn75xx;
 	struct cvmx_oclax_matx_maskx_s        cn78xx;
+	struct cvmx_oclax_matx_maskx_s        cn78xxp2;
 };
 typedef union cvmx_oclax_matx_maskx cvmx_oclax_matx_maskx_t;
 
@@ -974,7 +1047,9 @@ union cvmx_oclax_matx_thresh {
 	struct cvmx_oclax_matx_thresh_s       cn70xx;
 	struct cvmx_oclax_matx_thresh_s       cn70xxp1;
 	struct cvmx_oclax_matx_thresh_s       cn73xx;
+	struct cvmx_oclax_matx_thresh_s       cn75xx;
 	struct cvmx_oclax_matx_thresh_s       cn78xx;
+	struct cvmx_oclax_matx_thresh_s       cn78xxp2;
 };
 typedef union cvmx_oclax_matx_thresh cvmx_oclax_matx_thresh_t;
 
@@ -996,7 +1071,9 @@ union cvmx_oclax_matx_valuex {
 	struct cvmx_oclax_matx_valuex_s       cn70xx;
 	struct cvmx_oclax_matx_valuex_s       cn70xxp1;
 	struct cvmx_oclax_matx_valuex_s       cn73xx;
+	struct cvmx_oclax_matx_valuex_s       cn75xx;
 	struct cvmx_oclax_matx_valuex_s       cn78xx;
+	struct cvmx_oclax_matx_valuex_s       cn78xxp2;
 };
 typedef union cvmx_oclax_matx_valuex cvmx_oclax_matx_valuex_t;
 
@@ -1017,7 +1094,9 @@ union cvmx_oclax_rawx {
 	struct cvmx_oclax_rawx_s              cn70xx;
 	struct cvmx_oclax_rawx_s              cn70xxp1;
 	struct cvmx_oclax_rawx_s              cn73xx;
+	struct cvmx_oclax_rawx_s              cn75xx;
 	struct cvmx_oclax_rawx_s              cn78xx;
+	struct cvmx_oclax_rawx_s              cn78xxp2;
 };
 typedef union cvmx_oclax_rawx cvmx_oclax_rawx_t;
 
@@ -1038,7 +1117,9 @@ union cvmx_oclax_sft_rst {
 	struct cvmx_oclax_sft_rst_s           cn70xx;
 	struct cvmx_oclax_sft_rst_s           cn70xxp1;
 	struct cvmx_oclax_sft_rst_s           cn73xx;
+	struct cvmx_oclax_sft_rst_s           cn75xx;
 	struct cvmx_oclax_sft_rst_s           cn78xx;
+	struct cvmx_oclax_sft_rst_s           cn78xxp2;
 };
 typedef union cvmx_oclax_sft_rst cvmx_oclax_sft_rst_t;
 
@@ -1061,7 +1142,9 @@ union cvmx_oclax_stack_base {
 	struct cvmx_oclax_stack_base_s        cn70xx;
 	struct cvmx_oclax_stack_base_s        cn70xxp1;
 	struct cvmx_oclax_stack_base_s        cn73xx;
+	struct cvmx_oclax_stack_base_s        cn75xx;
 	struct cvmx_oclax_stack_base_s        cn78xx;
+	struct cvmx_oclax_stack_base_s        cn78xxp2;
 };
 typedef union cvmx_oclax_stack_base cvmx_oclax_stack_base_t;
 
@@ -1086,7 +1169,9 @@ union cvmx_oclax_stack_cur {
 	struct cvmx_oclax_stack_cur_s         cn70xx;
 	struct cvmx_oclax_stack_cur_s         cn70xxp1;
 	struct cvmx_oclax_stack_cur_s         cn73xx;
+	struct cvmx_oclax_stack_cur_s         cn75xx;
 	struct cvmx_oclax_stack_cur_s         cn78xx;
+	struct cvmx_oclax_stack_cur_s         cn78xxp2;
 };
 typedef union cvmx_oclax_stack_cur cvmx_oclax_stack_cur_t;
 
@@ -1107,7 +1192,9 @@ union cvmx_oclax_stack_store_cnt {
 	struct cvmx_oclax_stack_store_cnt_s   cn70xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn70xxp1;
 	struct cvmx_oclax_stack_store_cnt_s   cn73xx;
+	struct cvmx_oclax_stack_store_cnt_s   cn75xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn78xx;
+	struct cvmx_oclax_stack_store_cnt_s   cn78xxp2;
 };
 typedef union cvmx_oclax_stack_store_cnt cvmx_oclax_stack_store_cnt_t;
 
@@ -1131,7 +1218,9 @@ union cvmx_oclax_stack_top {
 	struct cvmx_oclax_stack_top_s         cn70xx;
 	struct cvmx_oclax_stack_top_s         cn70xxp1;
 	struct cvmx_oclax_stack_top_s         cn73xx;
+	struct cvmx_oclax_stack_top_s         cn75xx;
 	struct cvmx_oclax_stack_top_s         cn78xx;
+	struct cvmx_oclax_stack_top_s         cn78xxp2;
 };
 typedef union cvmx_oclax_stack_top cvmx_oclax_stack_top_t;
 
@@ -1153,7 +1242,9 @@ union cvmx_oclax_stack_wrap {
 	struct cvmx_oclax_stack_wrap_s        cn70xx;
 	struct cvmx_oclax_stack_wrap_s        cn70xxp1;
 	struct cvmx_oclax_stack_wrap_s        cn73xx;
+	struct cvmx_oclax_stack_wrap_s        cn75xx;
 	struct cvmx_oclax_stack_wrap_s        cn78xx;
+	struct cvmx_oclax_stack_wrap_s        cn78xxp2;
 };
 typedef union cvmx_oclax_stack_wrap cvmx_oclax_stack_wrap_t;
 
@@ -1174,7 +1265,9 @@ union cvmx_oclax_stagex {
 	struct cvmx_oclax_stagex_s            cn70xx;
 	struct cvmx_oclax_stagex_s            cn70xxp1;
 	struct cvmx_oclax_stagex_s            cn73xx;
+	struct cvmx_oclax_stagex_s            cn75xx;
 	struct cvmx_oclax_stagex_s            cn78xx;
+	struct cvmx_oclax_stagex_s            cn78xxp2;
 };
 typedef union cvmx_oclax_stagex cvmx_oclax_stagex_t;
 
@@ -1238,7 +1331,9 @@ union cvmx_oclax_state_int {
 	struct cvmx_oclax_state_int_s         cn70xx;
 	struct cvmx_oclax_state_int_s         cn70xxp1;
 	struct cvmx_oclax_state_int_s         cn73xx;
+	struct cvmx_oclax_state_int_s         cn75xx;
 	struct cvmx_oclax_state_int_s         cn78xx;
+	struct cvmx_oclax_state_int_s         cn78xxp2;
 };
 typedef union cvmx_oclax_state_int cvmx_oclax_state_int_t;
 
@@ -1296,7 +1391,9 @@ union cvmx_oclax_state_set {
 	struct cvmx_oclax_state_set_s         cn70xx;
 	struct cvmx_oclax_state_set_s         cn70xxp1;
 	struct cvmx_oclax_state_set_s         cn73xx;
+	struct cvmx_oclax_state_set_s         cn75xx;
 	struct cvmx_oclax_state_set_s         cn78xx;
+	struct cvmx_oclax_state_set_s         cn78xxp2;
 };
 typedef union cvmx_oclax_state_set cvmx_oclax_state_set_t;
 
@@ -1308,7 +1405,8 @@ union cvmx_oclax_time {
 	struct cvmx_oclax_time_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t cycle                        : 64; /**< Current time as free running counter. Loaded into captured control packets.
-                                                         Unconditionally clocked, independent of OCLA()_SFT_RST. */
+                                                         Unconditionally clocked, independent of OCLA()_SFT_RST.
+                                                         Changed width to 64 bits in pass 2. */
 #else
 	uint64_t cycle                        : 64;
 #endif
@@ -1324,7 +1422,9 @@ union cvmx_oclax_time {
 #endif
 	} cn70xxp1;
 	struct cvmx_oclax_time_s              cn73xx;
+	struct cvmx_oclax_time_s              cn75xx;
 	struct cvmx_oclax_time_cn70xxp1       cn78xx;
+	struct cvmx_oclax_time_s              cn78xxp2;
 };
 typedef union cvmx_oclax_time cvmx_oclax_time_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index b9153e3..dd2a70e 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -882,6 +882,7 @@ union cvmx_ocx_com_bist_status {
 #endif
 	} s;
 	struct cvmx_ocx_com_bist_status_s     cn78xx;
+	struct cvmx_ocx_com_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_ocx_com_bist_status cvmx_ocx_com_bist_status_t;
 
@@ -904,6 +905,7 @@ union cvmx_ocx_com_dual_sort {
 #endif
 	} s;
 	struct cvmx_ocx_com_dual_sort_s       cn78xx;
+	struct cvmx_ocx_com_dual_sort_s       cn78xxp2;
 };
 typedef union cvmx_ocx_com_dual_sort cvmx_ocx_com_dual_sort_t;
 
@@ -952,6 +954,7 @@ union cvmx_ocx_com_int {
 #endif
 	} s;
 	struct cvmx_ocx_com_int_s             cn78xx;
+	struct cvmx_ocx_com_int_s             cn78xxp2;
 };
 typedef union cvmx_ocx_com_int cvmx_ocx_com_int_t;
 
@@ -976,7 +979,9 @@ union cvmx_ocx_com_linkx_ctl {
 	struct cvmx_ocx_com_linkx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t cclk_dis                     : 1;  /**< Reserved. */
+	uint64_t cclk_dis                     : 1;  /**< Reserved.  INTERNAL:  Disable conditional clocking.  Set to force link clocks on
+                                                         unconditionally.
+                                                         Added in pass 2. */
 	uint64_t loopback                     : 1;  /**< Reserved. INTERNAL: Diagnostic data loopback.Set to force outgoing link to inbound port.
                                                          All data and link credits are returned and appear to come from link partner. Typically
                                                          SerDes should be disabled during this operation. */
@@ -1014,6 +1019,7 @@ union cvmx_ocx_com_linkx_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_com_linkx_ctl_s       cn78xx;
+	struct cvmx_ocx_com_linkx_ctl_s       cn78xxp2;
 };
 typedef union cvmx_ocx_com_linkx_ctl cvmx_ocx_com_linkx_ctl_t;
 
@@ -1063,6 +1069,7 @@ union cvmx_ocx_com_linkx_int {
 #endif
 	} s;
 	struct cvmx_ocx_com_linkx_int_s       cn78xx;
+	struct cvmx_ocx_com_linkx_int_s       cn78xxp2;
 };
 typedef union cvmx_ocx_com_linkx_int cvmx_ocx_com_linkx_int_t;
 
@@ -1082,6 +1089,7 @@ union cvmx_ocx_com_link_timer {
 #endif
 	} s;
 	struct cvmx_ocx_com_link_timer_s      cn78xx;
+	struct cvmx_ocx_com_link_timer_s      cn78xxp2;
 };
 typedef union cvmx_ocx_com_link_timer cvmx_ocx_com_link_timer_t;
 
@@ -1116,6 +1124,7 @@ union cvmx_ocx_com_node {
 #endif
 	} s;
 	struct cvmx_ocx_com_node_s            cn78xx;
+	struct cvmx_ocx_com_node_s            cn78xxp2;
 };
 typedef union cvmx_ocx_com_node cvmx_ocx_com_node_t;
 
@@ -1129,12 +1138,39 @@ union cvmx_ocx_dllx_status {
 	uint64_t u64;
 	struct cvmx_ocx_dllx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t max_dll_setting              : 12; /**< Max reported DLL setting. Added in pass 2. */
+	uint64_t min_dll_setting              : 12; /**< Min reported DLL setting. Added in pass 2. */
+	uint64_t pd_pos_rclk_refclk           : 1;  /**< Phase detector output. Added in pass 2. */
+	uint64_t pdl_rclk_refclk              : 1;  /**< Phase detector output. Added in pass 2. */
+	uint64_t pdr_rclk_refclk              : 1;  /**< Phase detector output. Added in pass 2. */
+	uint64_t reserved_32_32               : 1;
+	uint64_t dly_elem_enable              : 16; /**< Delay element enable. Added in pass 2. */
+	uint64_t dll_setting                  : 12; /**< DLL setting. Added in pass 2. */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t dll_lock                     : 1;  /**< DLL lock: 1 = locked, 0 = unlocked. Added in pass 2. */
+#else
+	uint64_t dll_lock                     : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t dll_setting                  : 12;
+	uint64_t dly_elem_enable              : 16;
+	uint64_t reserved_32_32               : 1;
+	uint64_t pdr_rclk_refclk              : 1;
+	uint64_t pdl_rclk_refclk              : 1;
+	uint64_t pd_pos_rclk_refclk           : 1;
+	uint64_t min_dll_setting              : 12;
+	uint64_t max_dll_setting              : 12;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_ocx_dllx_status_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_0_63                : 64;
 #else
 	uint64_t reserved_0_63                : 64;
 #endif
-	} s;
-	struct cvmx_ocx_dllx_status_s         cn78xx;
+	} cn78xx;
+	struct cvmx_ocx_dllx_status_s         cn78xxp2;
 };
 typedef union cvmx_ocx_dllx_status cvmx_ocx_dllx_status_t;
 
@@ -1154,6 +1190,7 @@ union cvmx_ocx_frcx_stat0 {
 #endif
 	} s;
 	struct cvmx_ocx_frcx_stat0_s          cn78xx;
+	struct cvmx_ocx_frcx_stat0_s          cn78xxp2;
 };
 typedef union cvmx_ocx_frcx_stat0 cvmx_ocx_frcx_stat0_t;
 
@@ -1173,6 +1210,7 @@ union cvmx_ocx_frcx_stat1 {
 #endif
 	} s;
 	struct cvmx_ocx_frcx_stat1_s          cn78xx;
+	struct cvmx_ocx_frcx_stat1_s          cn78xxp2;
 };
 typedef union cvmx_ocx_frcx_stat1 cvmx_ocx_frcx_stat1_t;
 
@@ -1191,6 +1229,7 @@ union cvmx_ocx_frcx_stat2 {
 #endif
 	} s;
 	struct cvmx_ocx_frcx_stat2_s          cn78xx;
+	struct cvmx_ocx_frcx_stat2_s          cn78xxp2;
 };
 typedef union cvmx_ocx_frcx_stat2 cvmx_ocx_frcx_stat2_t;
 
@@ -1209,6 +1248,7 @@ union cvmx_ocx_frcx_stat3 {
 #endif
 	} s;
 	struct cvmx_ocx_frcx_stat3_s          cn78xx;
+	struct cvmx_ocx_frcx_stat3_s          cn78xxp2;
 };
 typedef union cvmx_ocx_frcx_stat3 cvmx_ocx_frcx_stat3_t;
 
@@ -1234,6 +1274,7 @@ union cvmx_ocx_lnex_bad_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_bad_cnt_s        cn78xx;
+	struct cvmx_ocx_lnex_bad_cnt_s        cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_bad_cnt cvmx_ocx_lnex_bad_cnt_t;
 
@@ -1261,6 +1302,7 @@ union cvmx_ocx_lnex_cfg {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_cfg_s            cn78xx;
+	struct cvmx_ocx_lnex_cfg_s            cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_cfg cvmx_ocx_lnex_cfg_t;
 
@@ -1299,6 +1341,7 @@ union cvmx_ocx_lnex_int {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_int_s            cn78xx;
+	struct cvmx_ocx_lnex_int_s            cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_int cvmx_ocx_lnex_int_t;
 
@@ -1334,6 +1377,7 @@ union cvmx_ocx_lnex_int_en {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_int_en_s         cn78xx;
+	struct cvmx_ocx_lnex_int_en_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_int_en cvmx_ocx_lnex_int_en_t;
 
@@ -1353,6 +1397,7 @@ union cvmx_ocx_lnex_stat00 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat00_s         cn78xx;
+	struct cvmx_ocx_lnex_stat00_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat00 cvmx_ocx_lnex_stat00_t;
 
@@ -1372,6 +1417,7 @@ union cvmx_ocx_lnex_stat01 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat01_s         cn78xx;
+	struct cvmx_ocx_lnex_stat01_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat01 cvmx_ocx_lnex_stat01_t;
 
@@ -1391,6 +1437,7 @@ union cvmx_ocx_lnex_stat02 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat02_s         cn78xx;
+	struct cvmx_ocx_lnex_stat02_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat02 cvmx_ocx_lnex_stat02_t;
 
@@ -1410,6 +1457,7 @@ union cvmx_ocx_lnex_stat03 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat03_s         cn78xx;
+	struct cvmx_ocx_lnex_stat03_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat03 cvmx_ocx_lnex_stat03_t;
 
@@ -1429,6 +1477,7 @@ union cvmx_ocx_lnex_stat04 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat04_s         cn78xx;
+	struct cvmx_ocx_lnex_stat04_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat04 cvmx_ocx_lnex_stat04_t;
 
@@ -1448,6 +1497,7 @@ union cvmx_ocx_lnex_stat05 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat05_s         cn78xx;
+	struct cvmx_ocx_lnex_stat05_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat05 cvmx_ocx_lnex_stat05_t;
 
@@ -1467,6 +1517,7 @@ union cvmx_ocx_lnex_stat06 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat06_s         cn78xx;
+	struct cvmx_ocx_lnex_stat06_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat06 cvmx_ocx_lnex_stat06_t;
 
@@ -1486,6 +1537,7 @@ union cvmx_ocx_lnex_stat07 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat07_s         cn78xx;
+	struct cvmx_ocx_lnex_stat07_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat07 cvmx_ocx_lnex_stat07_t;
 
@@ -1506,6 +1558,7 @@ union cvmx_ocx_lnex_stat08 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat08_s         cn78xx;
+	struct cvmx_ocx_lnex_stat08_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat08 cvmx_ocx_lnex_stat08_t;
 
@@ -1525,6 +1578,7 @@ union cvmx_ocx_lnex_stat09 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat09_s         cn78xx;
+	struct cvmx_ocx_lnex_stat09_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat09 cvmx_ocx_lnex_stat09_t;
 
@@ -1544,6 +1598,7 @@ union cvmx_ocx_lnex_stat10 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat10_s         cn78xx;
+	struct cvmx_ocx_lnex_stat10_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat10 cvmx_ocx_lnex_stat10_t;
 
@@ -1563,6 +1618,7 @@ union cvmx_ocx_lnex_stat11 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat11_s         cn78xx;
+	struct cvmx_ocx_lnex_stat11_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat11 cvmx_ocx_lnex_stat11_t;
 
@@ -1582,6 +1638,7 @@ union cvmx_ocx_lnex_stat12 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat12_s         cn78xx;
+	struct cvmx_ocx_lnex_stat12_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat12 cvmx_ocx_lnex_stat12_t;
 
@@ -1601,6 +1658,7 @@ union cvmx_ocx_lnex_stat13 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat13_s         cn78xx;
+	struct cvmx_ocx_lnex_stat13_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat13 cvmx_ocx_lnex_stat13_t;
 
@@ -1620,6 +1678,7 @@ union cvmx_ocx_lnex_stat14 {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_stat14_s         cn78xx;
+	struct cvmx_ocx_lnex_stat14_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_stat14 cvmx_ocx_lnex_stat14_t;
 
@@ -1642,6 +1701,7 @@ union cvmx_ocx_lnex_status {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_status_s         cn78xx;
+	struct cvmx_ocx_lnex_status_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_status cvmx_ocx_lnex_status_t;
 
@@ -1678,6 +1738,7 @@ union cvmx_ocx_lnex_sts_msg {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_sts_msg_s        cn78xx;
+	struct cvmx_ocx_lnex_sts_msg_s        cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_sts_msg cvmx_ocx_lnex_sts_msg_t;
 
@@ -1702,6 +1763,7 @@ union cvmx_ocx_lnex_trn_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_trn_ctl_s        cn78xx;
+	struct cvmx_ocx_lnex_trn_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_trn_ctl cvmx_ocx_lnex_trn_ctl_t;
 
@@ -1730,6 +1792,7 @@ union cvmx_ocx_lnex_trn_ld {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_trn_ld_s         cn78xx;
+	struct cvmx_ocx_lnex_trn_ld_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_trn_ld cvmx_ocx_lnex_trn_ld_t;
 
@@ -1756,6 +1819,7 @@ union cvmx_ocx_lnex_trn_lp {
 #endif
 	} s;
 	struct cvmx_ocx_lnex_trn_lp_s         cn78xx;
+	struct cvmx_ocx_lnex_trn_lp_s         cn78xxp2;
 };
 typedef union cvmx_ocx_lnex_trn_lp cvmx_ocx_lnex_trn_lp_t;
 
@@ -1811,6 +1875,7 @@ union cvmx_ocx_lne_dbg {
 #endif
 	} s;
 	struct cvmx_ocx_lne_dbg_s             cn78xx;
+	struct cvmx_ocx_lne_dbg_s             cn78xxp2;
 };
 typedef union cvmx_ocx_lne_dbg cvmx_ocx_lne_dbg_t;
 
@@ -1864,8 +1929,13 @@ union cvmx_ocx_lnkx_cfg {
                                                          A link with QLM_SELECT = 000000 is invalid and will never exchange traffic with the
                                                          link partner. */
 	uint64_t reserved_29_31               : 3;
-	uint64_t data_rate                    : 13; /**< Reserved. */
-	uint64_t low_delay                    : 6;  /**< Reserved. */
+	uint64_t data_rate                    : 13; /**< The number of rclk to transmit 32 words, where each word is 67 bits.  HW will
+                                                         automatically
+                                                         calculate a conservative value for this field.   SW can override the calculation by
+                                                         writing
+                                                         TX_DAT_RATE=roundup((67*RCLK / GBAUD)*32).  Added in pass 2. */
+	uint64_t low_delay                    : 6;  /**< The delay before reacting to a lane low data indication, as a multiple of 64 rclks.
+                                                         Added in pass 2. */
 	uint64_t lane_align_dis               : 1;  /**< Disable the RX lane alignment. */
 	uint64_t lane_rev                     : 1;  /**< RX lane reversal.   When enabled, lane destriping is performed from the most significant
                                                          lane enabled to least significant lane enabled QLM_SELECT must be zero before changing
@@ -1885,6 +1955,7 @@ union cvmx_ocx_lnkx_cfg {
 #endif
 	} s;
 	struct cvmx_ocx_lnkx_cfg_s            cn78xx;
+	struct cvmx_ocx_lnkx_cfg_s            cn78xxp2;
 };
 typedef union cvmx_ocx_lnkx_cfg cvmx_ocx_lnkx_cfg_t;
 
@@ -1933,6 +2004,7 @@ union cvmx_ocx_pp_cmd {
 #endif
 	} s;
 	struct cvmx_ocx_pp_cmd_s              cn78xx;
+	struct cvmx_ocx_pp_cmd_s              cn78xxp2;
 };
 typedef union cvmx_ocx_pp_cmd cvmx_ocx_pp_cmd_t;
 
@@ -1953,6 +2025,7 @@ union cvmx_ocx_pp_rd_data {
 #endif
 	} s;
 	struct cvmx_ocx_pp_rd_data_s          cn78xx;
+	struct cvmx_ocx_pp_rd_data_s          cn78xxp2;
 };
 typedef union cvmx_ocx_pp_rd_data cvmx_ocx_pp_rd_data_t;
 
@@ -1973,6 +2046,7 @@ union cvmx_ocx_pp_wr_data {
 #endif
 	} s;
 	struct cvmx_ocx_pp_wr_data_s          cn78xx;
+	struct cvmx_ocx_pp_wr_data_s          cn78xxp2;
 };
 typedef union cvmx_ocx_pp_wr_data cvmx_ocx_pp_wr_data_t;
 
@@ -1983,13 +2057,17 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t u64;
 	struct cvmx_ocx_qlmx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ser_low                      : 4;  /**< Reserved. */
+	uint64_t ser_low                      : 4;  /**< Reduce latency by limiting the amount of data in flight for each SerDes.  Writing to 0
+                                                         causes
+                                                         hardware to determine a typically optimal value.   Added in pass 2. */
 	uint64_t reserved_42_59               : 18;
-	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. For diagnostic
-                                                         use only.  Removed in pass 2. */
+	uint64_t ser_limit                    : 10; /**< Reserved.  Removed in pass 2. */
 	uint64_t crd_dis                      : 1;  /**< For diagnostic use only. */
 	uint64_t reserved_27_30               : 4;
-	uint64_t trn_rxeq_only                : 1;  /**< Reserved. */
+	uint64_t trn_rxeq_only                : 1;  /**< Shortened training sequence.  Initialized to 1 during cold reset when OCI_SPD<3:0> pins
+                                                         indicate 5 GBAUD <=speed < 8 GBAUD. Otherwise, initialized to 0 during a cold reset. This
+                                                         field is
+                                                         not affected by soft or warm reset.  For diagnostic use only. */
 	uint64_t timer_dis                    : 1;  /**< Disable bad lane timer. A timer counts core clocks (RCLKs) when any enabled lane is not
                                                          ready, i.e. not in the scrambler sync state. If this timer expires before all enabled
                                                          lanes can be made ready, then any lane which is not ready is disabled via
@@ -2047,6 +2125,7 @@ union cvmx_ocx_qlmx_cfg {
 #endif
 	} s;
 	struct cvmx_ocx_qlmx_cfg_s            cn78xx;
+	struct cvmx_ocx_qlmx_cfg_s            cn78xxp2;
 };
 typedef union cvmx_ocx_qlmx_cfg cvmx_ocx_qlmx_cfg_t;
 
@@ -2067,6 +2146,7 @@ union cvmx_ocx_rlkx_align {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_align_s          cn78xx;
+	struct cvmx_ocx_rlkx_align_s          cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_align cvmx_ocx_rlkx_align_t;
 
@@ -2089,6 +2169,7 @@ union cvmx_ocx_rlkx_blk_err {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_blk_err_s        cn78xx;
+	struct cvmx_ocx_rlkx_blk_err_s        cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_blk_err cvmx_ocx_rlkx_blk_err_t;
 
@@ -2115,6 +2196,7 @@ union cvmx_ocx_rlkx_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_ecc_ctl_s        cn78xx;
+	struct cvmx_ocx_rlkx_ecc_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_ecc_ctl cvmx_ocx_rlkx_ecc_ctl_t;
 
@@ -2147,6 +2229,7 @@ union cvmx_ocx_rlkx_enables {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_enables_s        cn78xx;
+	struct cvmx_ocx_rlkx_enables_s        cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_enables cvmx_ocx_rlkx_enables_t;
 
@@ -2166,6 +2249,7 @@ union cvmx_ocx_rlkx_fifox_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_fifox_cnt_s      cn78xx;
+	struct cvmx_ocx_rlkx_fifox_cnt_s      cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_fifox_cnt cvmx_ocx_rlkx_fifox_cnt_t;
 
@@ -2188,6 +2272,7 @@ union cvmx_ocx_rlkx_lnk_data {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_lnk_data_s       cn78xx;
+	struct cvmx_ocx_rlkx_lnk_data_s       cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_lnk_data cvmx_ocx_rlkx_lnk_data_t;
 
@@ -2211,6 +2296,7 @@ union cvmx_ocx_rlkx_mcd_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_rlkx_mcd_ctl_s        cn78xx;
+	struct cvmx_ocx_rlkx_mcd_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ocx_rlkx_mcd_ctl cvmx_ocx_rlkx_mcd_ctl_t;
 
@@ -2233,6 +2319,7 @@ union cvmx_ocx_tlkx_bist_status {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_bist_status_s    cn78xx;
+	struct cvmx_ocx_tlkx_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_bist_status cvmx_ocx_tlkx_bist_status_t;
 
@@ -2263,6 +2350,7 @@ union cvmx_ocx_tlkx_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_ecc_ctl_s        cn78xx;
+	struct cvmx_ocx_tlkx_ecc_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_ecc_ctl cvmx_ocx_tlkx_ecc_ctl_t;
 
@@ -2281,6 +2369,7 @@ union cvmx_ocx_tlkx_fifox_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_fifox_cnt_s      cn78xx;
+	struct cvmx_ocx_tlkx_fifox_cnt_s      cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_fifox_cnt cvmx_ocx_tlkx_fifox_cnt_t;
 
@@ -2300,6 +2389,7 @@ union cvmx_ocx_tlkx_lnk_data {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_lnk_data_s       cn78xx;
+	struct cvmx_ocx_tlkx_lnk_data_s       cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_lnk_data cvmx_ocx_tlkx_lnk_data_t;
 
@@ -2318,6 +2408,7 @@ union cvmx_ocx_tlkx_lnk_vcx_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_lnk_vcx_cnt_s    cn78xx;
+	struct cvmx_ocx_tlkx_lnk_vcx_cnt_s    cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_lnk_vcx_cnt cvmx_ocx_tlkx_lnk_vcx_cnt_t;
 
@@ -2344,6 +2435,7 @@ union cvmx_ocx_tlkx_mcd_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_mcd_ctl_s        cn78xx;
+	struct cvmx_ocx_tlkx_mcd_ctl_s        cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_mcd_ctl cvmx_ocx_tlkx_mcd_ctl_t;
 
@@ -2362,6 +2454,7 @@ union cvmx_ocx_tlkx_rtn_vcx_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_rtn_vcx_cnt_s    cn78xx;
+	struct cvmx_ocx_tlkx_rtn_vcx_cnt_s    cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_rtn_vcx_cnt cvmx_ocx_tlkx_rtn_vcx_cnt_t;
 
@@ -2385,6 +2478,7 @@ union cvmx_ocx_tlkx_stat_ctl {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_ctl_s       cn78xx;
+	struct cvmx_ocx_tlkx_stat_ctl_s       cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_ctl cvmx_ocx_tlkx_stat_ctl_t;
 
@@ -2402,6 +2496,7 @@ union cvmx_ocx_tlkx_stat_data_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_data_cnt_s  cn78xx;
+	struct cvmx_ocx_tlkx_stat_data_cnt_s  cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_data_cnt cvmx_ocx_tlkx_stat_data_cnt_t;
 
@@ -2419,6 +2514,7 @@ union cvmx_ocx_tlkx_stat_err_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_err_cnt_s   cn78xx;
+	struct cvmx_ocx_tlkx_stat_err_cnt_s   cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_err_cnt cvmx_ocx_tlkx_stat_err_cnt_t;
 
@@ -2436,6 +2532,7 @@ union cvmx_ocx_tlkx_stat_idle_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_idle_cnt_s  cn78xx;
+	struct cvmx_ocx_tlkx_stat_idle_cnt_s  cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_idle_cnt cvmx_ocx_tlkx_stat_idle_cnt_t;
 
@@ -2453,6 +2550,7 @@ union cvmx_ocx_tlkx_stat_matx_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_matx_cnt_s  cn78xx;
+	struct cvmx_ocx_tlkx_stat_matx_cnt_s  cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_matx_cnt cvmx_ocx_tlkx_stat_matx_cnt_t;
 
@@ -2480,6 +2578,7 @@ union cvmx_ocx_tlkx_stat_matchx {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_matchx_s    cn78xx;
+	struct cvmx_ocx_tlkx_stat_matchx_s    cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_matchx cvmx_ocx_tlkx_stat_matchx_t;
 
@@ -2497,6 +2596,7 @@ union cvmx_ocx_tlkx_stat_retry_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_retry_cnt_s cn78xx;
+	struct cvmx_ocx_tlkx_stat_retry_cnt_s cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_retry_cnt cvmx_ocx_tlkx_stat_retry_cnt_t;
 
@@ -2514,6 +2614,7 @@ union cvmx_ocx_tlkx_stat_sync_cnt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_sync_cnt_s  cn78xx;
+	struct cvmx_ocx_tlkx_stat_sync_cnt_s  cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_sync_cnt cvmx_ocx_tlkx_stat_sync_cnt_t;
 
@@ -2532,6 +2633,7 @@ union cvmx_ocx_tlkx_stat_vcx_cmd {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_vcx_cmd_s   cn78xx;
+	struct cvmx_ocx_tlkx_stat_vcx_cmd_s   cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_vcx_cmd cvmx_ocx_tlkx_stat_vcx_cmd_t;
 
@@ -2551,6 +2653,7 @@ union cvmx_ocx_tlkx_stat_vcx_con {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_vcx_con_s   cn78xx;
+	struct cvmx_ocx_tlkx_stat_vcx_con_s   cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_vcx_con cvmx_ocx_tlkx_stat_vcx_con_t;
 
@@ -2568,6 +2671,7 @@ union cvmx_ocx_tlkx_stat_vcx_pkt {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_stat_vcx_pkt_s   cn78xx;
+	struct cvmx_ocx_tlkx_stat_vcx_pkt_s   cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_stat_vcx_pkt cvmx_ocx_tlkx_stat_vcx_pkt_t;
 
@@ -2608,6 +2712,7 @@ union cvmx_ocx_tlkx_status {
 #endif
 	} s;
 	struct cvmx_ocx_tlkx_status_s         cn78xx;
+	struct cvmx_ocx_tlkx_status_s         cn78xxp2;
 };
 typedef union cvmx_ocx_tlkx_status cvmx_ocx_tlkx_status_t;
 
@@ -2656,6 +2761,7 @@ union cvmx_ocx_win_cmd {
 #endif
 	} s;
 	struct cvmx_ocx_win_cmd_s             cn78xx;
+	struct cvmx_ocx_win_cmd_s             cn78xxp2;
 };
 typedef union cvmx_ocx_win_cmd cvmx_ocx_win_cmd_t;
 
@@ -2675,6 +2781,7 @@ union cvmx_ocx_win_rd_data {
 #endif
 	} s;
 	struct cvmx_ocx_win_rd_data_s         cn78xx;
+	struct cvmx_ocx_win_rd_data_s         cn78xxp2;
 };
 typedef union cvmx_ocx_win_rd_data cvmx_ocx_win_rd_data_t;
 
@@ -2698,6 +2805,7 @@ union cvmx_ocx_win_timer {
 #endif
 	} s;
 	struct cvmx_ocx_win_timer_s           cn78xx;
+	struct cvmx_ocx_win_timer_s           cn78xxp2;
 };
 typedef union cvmx_ocx_win_timer cvmx_ocx_win_timer_t;
 
@@ -2718,6 +2826,7 @@ union cvmx_ocx_win_wr_data {
 #endif
 	} s;
 	struct cvmx_ocx_win_wr_data_s         cn78xx;
+	struct cvmx_ocx_win_wr_data_s         cn78xxp2;
 };
 typedef union cvmx_ocx_win_wr_data cvmx_ocx_win_wr_data_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index f1e45a1..29e33fa 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -296,6 +296,7 @@ union cvmx_osm_ase_rate_limit_ctrl {
 #endif
 	} s;
 	struct cvmx_osm_ase_rate_limit_ctrl_s cn78xx;
+	struct cvmx_osm_ase_rate_limit_ctrl_s cn78xxp2;
 };
 typedef union cvmx_osm_ase_rate_limit_ctrl cvmx_osm_ase_rate_limit_ctrl_t;
 
@@ -328,6 +329,7 @@ union cvmx_osm_bankx_ctrl {
 	} s;
 	struct cvmx_osm_bankx_ctrl_s          cn73xx;
 	struct cvmx_osm_bankx_ctrl_s          cn78xx;
+	struct cvmx_osm_bankx_ctrl_s          cn78xxp2;
 };
 typedef union cvmx_osm_bankx_ctrl cvmx_osm_bankx_ctrl_t;
 
@@ -377,6 +379,7 @@ union cvmx_osm_ecc_ctrl {
 	} s;
 	struct cvmx_osm_ecc_ctrl_s            cn73xx;
 	struct cvmx_osm_ecc_ctrl_s            cn78xx;
+	struct cvmx_osm_ecc_ctrl_s            cn78xxp2;
 };
 typedef union cvmx_osm_ecc_ctrl cvmx_osm_ecc_ctrl_t;
 
@@ -425,6 +428,7 @@ union cvmx_osm_int_info_addr {
 	} s;
 	struct cvmx_osm_int_info_addr_s       cn73xx;
 	struct cvmx_osm_int_info_addr_s       cn78xx;
+	struct cvmx_osm_int_info_addr_s       cn78xxp2;
 };
 typedef union cvmx_osm_int_info_addr cvmx_osm_int_info_addr_t;
 
@@ -454,6 +458,7 @@ union cvmx_osm_int_info_ecc {
 	} s;
 	struct cvmx_osm_int_info_ecc_s        cn73xx;
 	struct cvmx_osm_int_info_ecc_s        cn78xx;
+	struct cvmx_osm_int_info_ecc_s        cn78xxp2;
 };
 typedef union cvmx_osm_int_info_ecc cvmx_osm_int_info_ecc_t;
 
@@ -542,6 +547,7 @@ union cvmx_osm_int_stat {
 #endif
 	} cn73xx;
 	struct cvmx_osm_int_stat_s            cn78xx;
+	struct cvmx_osm_int_stat_s            cn78xxp2;
 };
 typedef union cvmx_osm_int_stat cvmx_osm_int_stat_t;
 
@@ -577,6 +583,7 @@ union cvmx_osm_memx_bist_status {
 #endif
 	} cn73xx;
 	struct cvmx_osm_memx_bist_status_s    cn78xx;
+	struct cvmx_osm_memx_bist_status_s    cn78xxp2;
 };
 typedef union cvmx_osm_memx_bist_status cvmx_osm_memx_bist_status_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 6d7554a..bfad716 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG000(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000000ull + ((offset) & 3) * 0x100000000ull;
@@ -69,6 +70,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG001(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000004ull + ((offset) & 3) * 0x100000000ull;
@@ -81,6 +83,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG002(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000008ull + ((offset) & 3) * 0x100000000ull;
@@ -93,6 +96,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG003(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000000Cull + ((offset) & 3) * 0x100000000ull;
@@ -105,6 +109,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG004(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000010ull + ((offset) & 3) * 0x100000000ull;
@@ -117,6 +122,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG005(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000014ull + ((offset) & 3) * 0x100000000ull;
@@ -129,6 +135,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG006(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000018ull + ((offset) & 3) * 0x100000000ull;
@@ -141,6 +148,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG007(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000001Cull + ((offset) & 3) * 0x100000000ull;
@@ -153,6 +161,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG008(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000020ull + ((offset) & 3) * 0x100000000ull;
@@ -165,6 +174,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG009(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000024ull + ((offset) & 3) * 0x100000000ull;
@@ -177,6 +187,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG010(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000028ull + ((offset) & 3) * 0x100000000ull;
@@ -189,6 +200,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG011(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000002Cull + ((offset) & 3) * 0x100000000ull;
@@ -201,6 +213,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG012(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000030ull + ((offset) & 3) * 0x100000000ull;
@@ -213,6 +226,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG013(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000034ull + ((offset) & 3) * 0x100000000ull;
@@ -225,6 +239,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG015(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000003Cull + ((offset) & 3) * 0x100000000ull;
@@ -237,6 +252,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG028(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000070ull + ((offset) & 3) * 0x100000000ull;
@@ -249,6 +265,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG029(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000074ull + ((offset) & 3) * 0x100000000ull;
@@ -261,6 +278,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG030(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000078ull + ((offset) & 3) * 0x100000000ull;
@@ -273,6 +291,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG031(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000007Cull + ((offset) & 3) * 0x100000000ull;
@@ -285,6 +304,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG032(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000080ull + ((offset) & 3) * 0x100000000ull;
@@ -297,6 +317,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG037(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000094ull + ((offset) & 3) * 0x100000000ull;
@@ -309,6 +330,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG038(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000098ull + ((offset) & 3) * 0x100000000ull;
@@ -321,6 +343,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG039(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000009Cull + ((offset) & 3) * 0x100000000ull;
@@ -333,6 +356,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG040(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000A0ull + ((offset) & 3) * 0x100000000ull;
@@ -345,6 +369,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG044(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B0ull + ((offset) & 3) * 0x100000000ull;
@@ -357,6 +382,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG045(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B4ull + ((offset) & 3) * 0x100000000ull;
@@ -369,6 +395,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG046(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B8ull + ((offset) & 3) * 0x100000000ull;
@@ -381,6 +408,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG048(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000C0ull + ((offset) & 3) * 0x100000000ull;
@@ -393,6 +421,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG049(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000C4ull + ((offset) & 3) * 0x100000000ull;
@@ -405,6 +434,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG064(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000100ull + ((offset) & 3) * 0x100000000ull;
@@ -417,6 +447,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG082(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000148ull + ((offset) & 3) * 0x100000000ull;
@@ -429,6 +460,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG083(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000014Cull + ((offset) & 3) * 0x100000000ull;
@@ -441,6 +473,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG448(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000700ull + ((offset) & 3) * 0x100000000ull;
@@ -453,6 +486,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG449(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000704ull + ((offset) & 3) * 0x100000000ull;
@@ -465,6 +499,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG450(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000708ull + ((offset) & 3) * 0x100000000ull;
@@ -477,6 +512,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG451(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000070Cull + ((offset) & 3) * 0x100000000ull;
@@ -489,6 +525,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG452(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000710ull + ((offset) & 3) * 0x100000000ull;
@@ -501,6 +538,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG453(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000714ull + ((offset) & 3) * 0x100000000ull;
@@ -513,6 +551,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG454(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000718ull + ((offset) & 3) * 0x100000000ull;
@@ -525,6 +564,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG455(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000071Cull + ((offset) & 3) * 0x100000000ull;
@@ -537,6 +577,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG456(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000720ull + ((offset) & 3) * 0x100000000ull;
@@ -549,6 +590,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG458(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000728ull + ((offset) & 3) * 0x100000000ull;
@@ -561,6 +603,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG459(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000072Cull + ((offset) & 3) * 0x100000000ull;
@@ -573,6 +616,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG460(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000730ull + ((offset) & 3) * 0x100000000ull;
@@ -585,6 +629,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG461(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000734ull + ((offset) & 3) * 0x100000000ull;
@@ -597,6 +642,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG462(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000738ull + ((offset) & 3) * 0x100000000ull;
@@ -609,6 +655,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG463(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000073Cull + ((offset) & 3) * 0x100000000ull;
@@ -621,6 +668,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG464(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000740ull + ((offset) & 3) * 0x100000000ull;
@@ -633,6 +681,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG465(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000744ull + ((offset) & 3) * 0x100000000ull;
@@ -645,6 +694,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG466(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000748ull + ((offset) & 3) * 0x100000000ull;
@@ -657,6 +707,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG467(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000074Cull + ((offset) & 3) * 0x100000000ull;
@@ -669,6 +720,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG468(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000750ull + ((offset) & 3) * 0x100000000ull;
@@ -681,6 +733,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG490(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000007A8ull + ((offset) & 3) * 0x100000000ull;
@@ -693,6 +746,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG491(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000007ACull + ((offset) & 3) * 0x100000000ull;
@@ -705,6 +759,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG492(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000007B0ull + ((offset) & 3) * 0x100000000ull;
@@ -717,6 +772,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG515(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000080Cull + ((offset) & 3) * 0x100000000ull;
@@ -729,6 +785,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG516(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000810ull + ((offset) & 3) * 0x100000000ull;
@@ -741,6 +798,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG517(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000814ull + ((offset) & 3) * 0x100000000ull;
@@ -767,7 +825,9 @@ union cvmx_pcieepvfx_cfg000 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg000_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg000_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg000_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg000_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg000 cvmx_pcieepvfx_cfg000_t;
 
@@ -833,7 +893,9 @@ union cvmx_pcieepvfx_cfg001 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg001_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg001_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg001_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg001_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg001 cvmx_pcieepvfx_cfg001_t;
 
@@ -851,7 +913,8 @@ union cvmx_pcieepvfx_cfg002 {
 	uint32_t sc                           : 8;  /**< Subclass code. */
 	uint32_t pi                           : 8;  /**< Programming interface. */
 	uint32_t rid                          : 8;  /**< Revision ID, writable through PEM()_CFG_WR. However, the application must not change
-                                                         this field. */
+                                                         this field.
+                                                         Changed in pass 2.0. */
 #else
 	uint32_t rid                          : 8;
 	uint32_t pi                           : 8;
@@ -860,7 +923,9 @@ union cvmx_pcieepvfx_cfg002 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg002_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg002_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg002_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg002_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg002 cvmx_pcieepvfx_cfg002_t;
 
@@ -891,7 +956,9 @@ union cvmx_pcieepvfx_cfg003 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg003_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg003_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg003_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg003_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg003 cvmx_pcieepvfx_cfg003_t;
 
@@ -911,7 +978,9 @@ union cvmx_pcieepvfx_cfg004 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg004_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg004_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg004_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg004_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg004 cvmx_pcieepvfx_cfg004_t;
 
@@ -931,7 +1000,9 @@ union cvmx_pcieepvfx_cfg005 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg005_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg005_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg005_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg005_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg005 cvmx_pcieepvfx_cfg005_t;
 
@@ -951,7 +1022,9 @@ union cvmx_pcieepvfx_cfg006 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg006_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg006_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg006_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg006_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg006 cvmx_pcieepvfx_cfg006_t;
 
@@ -971,7 +1044,9 @@ union cvmx_pcieepvfx_cfg007 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg007_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg007_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg007_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg007_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg007 cvmx_pcieepvfx_cfg007_t;
 
@@ -991,7 +1066,9 @@ union cvmx_pcieepvfx_cfg008 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg008_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg008_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg008_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg008_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg008 cvmx_pcieepvfx_cfg008_t;
 
@@ -1011,7 +1088,9 @@ union cvmx_pcieepvfx_cfg009 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg009_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg009_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg009_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg009_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg009 cvmx_pcieepvfx_cfg009_t;
 
@@ -1031,7 +1110,9 @@ union cvmx_pcieepvfx_cfg010 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg010_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg010_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg010_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg010_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg010 cvmx_pcieepvfx_cfg010_t;
 
@@ -1053,7 +1134,9 @@ union cvmx_pcieepvfx_cfg011 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg011_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg011_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg011_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg011_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg011 cvmx_pcieepvfx_cfg011_t;
 
@@ -1077,7 +1160,9 @@ union cvmx_pcieepvfx_cfg012 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg012_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg012_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg012_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg012_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg012 cvmx_pcieepvfx_cfg012_t;
 
@@ -1099,7 +1184,9 @@ union cvmx_pcieepvfx_cfg013 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg013_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg013_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg013_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg013_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg013 cvmx_pcieepvfx_cfg013_t;
 
@@ -1125,7 +1212,9 @@ union cvmx_pcieepvfx_cfg015 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg015_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg015_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg015_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg015_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg015 cvmx_pcieepvfx_cfg015_t;
 
@@ -1157,7 +1246,9 @@ union cvmx_pcieepvfx_cfg028 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg028_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg028_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg028_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg028_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg028 cvmx_pcieepvfx_cfg028_t;
 
@@ -1199,7 +1290,9 @@ union cvmx_pcieepvfx_cfg029 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg029_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg029_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg029_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg029_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg029 cvmx_pcieepvfx_cfg029_t;
 
@@ -1273,7 +1366,9 @@ union cvmx_pcieepvfx_cfg030 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg030_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg030_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg030_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg030_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg030 cvmx_pcieepvfx_cfg030_t;
 
@@ -1329,7 +1424,9 @@ union cvmx_pcieepvfx_cfg031 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg031_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg031_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg031_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg031_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg031 cvmx_pcieepvfx_cfg031_t;
 
@@ -1394,7 +1491,9 @@ union cvmx_pcieepvfx_cfg032 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg032_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg032_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg032_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg032_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg032 cvmx_pcieepvfx_cfg032_t;
 
@@ -1448,7 +1547,9 @@ union cvmx_pcieepvfx_cfg037 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg037_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg037_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg037_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg037_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg037 cvmx_pcieepvfx_cfg037_t;
 
@@ -1489,7 +1590,9 @@ union cvmx_pcieepvfx_cfg038 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg038_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg038_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg038_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg038_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg038 cvmx_pcieepvfx_cfg038_t;
 
@@ -1526,7 +1629,9 @@ union cvmx_pcieepvfx_cfg039 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg039_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg039_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg039_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg039_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg039 cvmx_pcieepvfx_cfg039_t;
 
@@ -1606,7 +1711,9 @@ union cvmx_pcieepvfx_cfg040 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg040_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg040_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg040_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg040_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg040 cvmx_pcieepvfx_cfg040_t;
 
@@ -1639,7 +1746,9 @@ union cvmx_pcieepvfx_cfg044 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg044_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg044_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg044_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg044_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg044 cvmx_pcieepvfx_cfg044_t;
 
@@ -1663,7 +1772,9 @@ union cvmx_pcieepvfx_cfg045 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg045_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg045_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg045_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg045_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg045 cvmx_pcieepvfx_cfg045_t;
 
@@ -1688,7 +1799,9 @@ union cvmx_pcieepvfx_cfg046 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg046_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg046_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg046_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg046_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg046 cvmx_pcieepvfx_cfg046_t;
 
@@ -1731,7 +1844,9 @@ union cvmx_pcieepvfx_cfg048 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg048_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg048_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg048_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg048_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg048 cvmx_pcieepvfx_cfg048_t;
 
@@ -1778,7 +1893,9 @@ union cvmx_pcieepvfx_cfg049 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg049_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg049_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg049_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg049_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg049 cvmx_pcieepvfx_cfg049_t;
 
@@ -1802,7 +1919,9 @@ union cvmx_pcieepvfx_cfg064 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg064_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg064_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg064_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg064_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg064 cvmx_pcieepvfx_cfg064_t;
 
@@ -1826,7 +1945,9 @@ union cvmx_pcieepvfx_cfg082 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg082_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg082_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg082_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg082_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg082 cvmx_pcieepvfx_cfg082_t;
 
@@ -1862,7 +1983,9 @@ union cvmx_pcieepvfx_cfg083 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg083_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg083_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg083_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg083_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg083 cvmx_pcieepvfx_cfg083_t;
 
@@ -1891,7 +2014,9 @@ union cvmx_pcieepvfx_cfg448 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg448_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg448_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg448_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg448_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg448 cvmx_pcieepvfx_cfg448_t;
 
@@ -1918,7 +2043,9 @@ union cvmx_pcieepvfx_cfg449 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg449_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg449_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg449_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg449_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg449 cvmx_pcieepvfx_cfg449_t;
 
@@ -1989,7 +2116,9 @@ union cvmx_pcieepvfx_cfg450 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg450_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg450_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg450_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg450_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg450 cvmx_pcieepvfx_cfg450_t;
 
@@ -2046,7 +2175,9 @@ union cvmx_pcieepvfx_cfg451 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg451_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg451_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg451_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg451_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg451 cvmx_pcieepvfx_cfg451_t;
 
@@ -2111,7 +2242,9 @@ union cvmx_pcieepvfx_cfg452 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg452_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg452_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg452_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg452_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg452 cvmx_pcieepvfx_cfg452_t;
 
@@ -2142,7 +2275,9 @@ union cvmx_pcieepvfx_cfg453 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg453_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg453_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg453_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg453_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg453 cvmx_pcieepvfx_cfg453_t;
 
@@ -2176,7 +2311,9 @@ union cvmx_pcieepvfx_cfg454 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg454_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg454_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg454_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg454_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg454 cvmx_pcieepvfx_cfg454_t;
 
@@ -2232,7 +2369,9 @@ union cvmx_pcieepvfx_cfg455 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg455_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg455_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg455_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg455_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg455 cvmx_pcieepvfx_cfg455_t;
 
@@ -2260,7 +2399,9 @@ union cvmx_pcieepvfx_cfg456 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg456_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg456_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg456_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg456_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg456 cvmx_pcieepvfx_cfg456_t;
 
@@ -2280,7 +2421,9 @@ union cvmx_pcieepvfx_cfg458 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg458_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg458_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg458_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg458_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg458 cvmx_pcieepvfx_cfg458_t;
 
@@ -2300,7 +2443,9 @@ union cvmx_pcieepvfx_cfg459 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg459_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg459_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg459_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg459_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg459 cvmx_pcieepvfx_cfg459_t;
 
@@ -2326,7 +2471,9 @@ union cvmx_pcieepvfx_cfg460 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg460_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg460_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg460_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg460_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg460 cvmx_pcieepvfx_cfg460_t;
 
@@ -2352,7 +2499,9 @@ union cvmx_pcieepvfx_cfg461 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg461_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg461_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg461_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg461_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg461 cvmx_pcieepvfx_cfg461_t;
 
@@ -2378,7 +2527,9 @@ union cvmx_pcieepvfx_cfg462 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg462_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg462_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg462_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg462_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg462 cvmx_pcieepvfx_cfg462_t;
 
@@ -2417,7 +2568,9 @@ union cvmx_pcieepvfx_cfg463 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg463_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg463_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg463_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg463_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg463 cvmx_pcieepvfx_cfg463_t;
 
@@ -2443,7 +2596,9 @@ union cvmx_pcieepvfx_cfg464 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg464_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg464_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg464_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg464_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg464 cvmx_pcieepvfx_cfg464_t;
 
@@ -2469,7 +2624,9 @@ union cvmx_pcieepvfx_cfg465 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg465_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg465_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg465_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg465_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg465 cvmx_pcieepvfx_cfg465_t;
 
@@ -2515,7 +2672,9 @@ union cvmx_pcieepvfx_cfg466 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg466_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg466_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg466_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg466_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg466 cvmx_pcieepvfx_cfg466_t;
 
@@ -2553,7 +2712,9 @@ union cvmx_pcieepvfx_cfg467 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg467_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg467_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg467_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg467_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg467 cvmx_pcieepvfx_cfg467_t;
 
@@ -2592,7 +2753,9 @@ union cvmx_pcieepvfx_cfg468 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg468_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg468_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg468_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg468_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg468 cvmx_pcieepvfx_cfg468_t;
 
@@ -2620,7 +2783,9 @@ union cvmx_pcieepvfx_cfg490 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg490_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg490_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg490_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg490_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg490 cvmx_pcieepvfx_cfg490_t;
 
@@ -2648,7 +2813,9 @@ union cvmx_pcieepvfx_cfg491 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg491_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg491_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg491_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg491_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg491 cvmx_pcieepvfx_cfg491_t;
 
@@ -2676,7 +2843,9 @@ union cvmx_pcieepvfx_cfg492 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg492_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg492_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg492_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg492_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg492 cvmx_pcieepvfx_cfg492_t;
 
@@ -2717,7 +2886,9 @@ union cvmx_pcieepvfx_cfg515 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg515_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg515_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg515_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg515_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg515 cvmx_pcieepvfx_cfg515_t;
 
@@ -2737,7 +2908,9 @@ union cvmx_pcieepvfx_cfg516 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg516_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg516_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg516_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg516_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg516 cvmx_pcieepvfx_cfg516_t;
 
@@ -2757,7 +2930,9 @@ union cvmx_pcieepvfx_cfg517 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg517_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg517_s        cn75xx;
 	struct cvmx_pcieepvfx_cfg517_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg517_s        cn78xxp2;
 };
 typedef union cvmx_pcieepvfx_cfg517 cvmx_pcieepvfx_cfg517_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index e8182c5..066e6a1 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -74,10 +74,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000000ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG000 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000000ull;
@@ -98,7 +102,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
@@ -126,10 +132,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000004ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG001 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000004ull;
@@ -150,7 +160,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
@@ -178,10 +190,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000008ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG002 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000008ull;
@@ -202,7 +218,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
@@ -230,10 +248,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000000Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG003 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000000Cull;
@@ -254,7 +276,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
@@ -282,10 +306,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000010ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG004 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000010ull;
@@ -306,7 +334,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
@@ -334,10 +364,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000010ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG004_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000010ull;
@@ -358,7 +392,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000010ull;
@@ -386,10 +422,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000014ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG005 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000014ull;
@@ -410,7 +450,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
@@ -438,10 +480,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000014ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG005_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000014ull;
@@ -462,7 +508,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000014ull;
@@ -490,10 +538,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000018ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG006 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000018ull;
@@ -514,7 +566,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
@@ -542,10 +596,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000018ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG006_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000018ull;
@@ -566,7 +624,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000018ull;
@@ -594,10 +654,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000001Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG007 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000001Cull;
@@ -618,7 +682,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
@@ -646,10 +712,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003008000001Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG007_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000008000001Cull;
@@ -670,7 +740,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000008000001Cull;
@@ -698,10 +770,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000020ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG008 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000020ull;
@@ -722,7 +798,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
@@ -750,10 +828,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000020ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG008_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000020ull;
@@ -774,7 +856,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000020ull;
@@ -802,10 +886,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000024ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG009 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000024ull;
@@ -826,7 +914,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
@@ -854,10 +944,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000024ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG009_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000024ull;
@@ -878,7 +972,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000024ull;
@@ -906,10 +1002,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000028ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG010 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000028ull;
@@ -930,7 +1030,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
@@ -958,10 +1060,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000002Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG011 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000002Cull;
@@ -982,7 +1088,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
@@ -1010,10 +1118,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000030ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG012 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000030ull;
@@ -1034,7 +1146,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
@@ -1062,10 +1176,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000030ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG012_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000030ull;
@@ -1086,7 +1204,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000030ull;
@@ -1114,10 +1234,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000034ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG013 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000034ull;
@@ -1138,7 +1262,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
@@ -1166,10 +1292,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000003Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG015 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000003Cull;
@@ -1190,7 +1320,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
@@ -1218,10 +1350,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000040ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG016 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000040ull;
@@ -1242,7 +1378,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
@@ -1270,10 +1408,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000044ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG017 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000044ull;
@@ -1294,7 +1436,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
@@ -1322,10 +1466,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000050ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG020 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000050ull;
@@ -1346,7 +1494,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
@@ -1374,10 +1524,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000054ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG021 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000054ull;
@@ -1398,7 +1552,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
@@ -1426,10 +1582,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000058ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG022 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000058ull;
@@ -1450,7 +1610,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
@@ -1478,10 +1640,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000005Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG023 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000005Cull;
@@ -1502,7 +1668,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
@@ -1513,26 +1681,28 @@ static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000060ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000060ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG024(offset) (0x0000030000000060ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG024(offset) (0x0000030000000060ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000064ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000064ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG025(offset) (0x0000030000000064ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG025(offset) (0x0000030000000064ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
@@ -1556,10 +1726,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000070ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG028 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000070ull;
@@ -1580,7 +1754,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
@@ -1608,10 +1784,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000074ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG029 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000074ull;
@@ -1632,7 +1812,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
@@ -1660,10 +1842,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000078ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG030 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000078ull;
@@ -1684,7 +1870,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
@@ -1712,10 +1900,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000007Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG031 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000007Cull;
@@ -1736,7 +1928,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
@@ -1764,10 +1958,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000080ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG032 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000080ull;
@@ -1788,7 +1986,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
@@ -1842,10 +2042,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000094ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG037 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000094ull;
@@ -1866,7 +2070,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
@@ -1894,10 +2100,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000098ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG038 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000098ull;
@@ -1918,7 +2128,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
@@ -1946,10 +2158,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000009Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG039 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000009Cull;
@@ -1970,7 +2186,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
@@ -1998,10 +2216,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x00000300000000A0ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG040 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000000A0ull;
@@ -2022,7 +2244,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
@@ -2058,37 +2282,40 @@ static inline uint64_t CVMX_PCIEEPX_CFG042(unsigned long offset)
 static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000000B0ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000000B0ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG044(offset) (0x00000300000000B0ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG044(offset) (0x00000300000000B0ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000000B4ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000000B4ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG045(offset) (0x00000300000000B4ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG045(offset) (0x00000300000000B4ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000000B8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000000B8ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG046(offset) (0x00000300000000B8ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG046(offset) (0x00000300000000B8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
@@ -2112,10 +2339,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000100ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG064 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000100ull;
@@ -2136,7 +2367,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
@@ -2164,10 +2397,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000104ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG065 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000104ull;
@@ -2188,7 +2425,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
@@ -2216,10 +2455,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000108ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG066 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000108ull;
@@ -2240,7 +2483,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
@@ -2268,10 +2513,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000010Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG067 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000010Cull;
@@ -2292,7 +2541,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
@@ -2320,10 +2571,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000110ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG068 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000110ull;
@@ -2344,7 +2599,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
@@ -2372,10 +2629,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000114ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG069 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000114ull;
@@ -2396,7 +2657,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
@@ -2424,10 +2687,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000118ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG070 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000118ull;
@@ -2448,7 +2715,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
@@ -2476,10 +2745,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000011Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG071 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000011Cull;
@@ -2500,7 +2773,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
@@ -2528,10 +2803,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000120ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG072 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000120ull;
@@ -2552,7 +2831,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
@@ -2580,10 +2861,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000124ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG073 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000124ull;
@@ -2604,7 +2889,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
@@ -2632,10 +2919,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000128ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG074 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000128ull;
@@ -2656,7 +2947,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
@@ -2666,39 +2959,42 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000138ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000138ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG078(offset) (0x0000030000000138ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG078(offset) (0x0000030000000138ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000148ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000148ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG082(offset) (0x0000030000000148ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG082(offset) (0x0000030000000148ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000014Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000014Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG083(offset) (0x000003000000014Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG083(offset) (0x000003000000014Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG084(unsigned long offset)
@@ -2715,313 +3011,339 @@ static inline uint64_t CVMX_PCIEEPX_CFG084(unsigned long offset)
 static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000158ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000158ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG086(offset) (0x0000030000000158ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG086(offset) (0x0000030000000158ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000015Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000015Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG087(offset) (0x000003000000015Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG087(offset) (0x000003000000015Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000160ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000160ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG088(offset) (0x0000030000000160ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG088(offset) (0x0000030000000160ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000164ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000164ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG089(offset) (0x0000030000000164ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG089(offset) (0x0000030000000164ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000168ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000168ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG090(offset) (0x0000030000000168ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG090(offset) (0x0000030000000168ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000016Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000016Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG091(offset) (0x000003000000016Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG091(offset) (0x000003000000016Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000170ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000170ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG092(offset) (0x0000030000000170ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG092(offset) (0x0000030000000170ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000178ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000178ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG094(offset) (0x0000030000000178ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG094(offset) (0x0000030000000178ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000017Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000017Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG095(offset) (0x000003000000017Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG095(offset) (0x000003000000017Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000180ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000180ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG096(offset) (0x0000030000000180ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG096(offset) (0x0000030000000180ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000184ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000184ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG097(offset) (0x0000030000000184ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG097(offset) (0x0000030000000184ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000188ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000188ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG098(offset) (0x0000030000000188ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG098(offset) (0x0000030000000188ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000018Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000018Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG099(offset) (0x000003000000018Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG099(offset) (0x000003000000018Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000190ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000190ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG100(offset) (0x0000030000000190ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG100(offset) (0x0000030000000190ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000194ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000194ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG101(offset) (0x0000030000000194ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG101(offset) (0x0000030000000194ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000198ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000198ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG102(offset) (0x0000030000000198ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG102(offset) (0x0000030000000198ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", offset);
-	return 0x000003000000019Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000003000000019Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG103(offset) (0x000003000000019Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG103(offset) (0x000003000000019Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001A0ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001A0ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG104(offset) (0x00000300000001A0ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG104(offset) (0x00000300000001A0ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001A4ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001A4ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG105(offset) (0x00000300000001A4ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG105(offset) (0x00000300000001A4ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001A8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001A8ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG106(offset) (0x00000300000001A8ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG106(offset) (0x00000300000001A8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001ACull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001ACull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG107(offset) (0x00000300000001ACull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG107(offset) (0x00000300000001ACull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001B0ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001B0ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG108(offset) (0x00000300000001B0ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG108(offset) (0x00000300000001B0ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001B4ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001B4ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG109(offset) (0x00000300000001B4ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG109(offset) (0x00000300000001B4ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001B8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001B8ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG110(offset) (0x00000300000001B8ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG110(offset) (0x00000300000001B8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001BCull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001BCull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG111(offset) (0x00000300000001BCull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG111(offset) (0x00000300000001BCull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000001C0ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000001C0ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG112(offset) (0x00000300000001C0ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG112(offset) (0x00000300000001C0ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
@@ -3045,10 +3367,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000700ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG448 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000700ull;
@@ -3069,7 +3395,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
@@ -3097,10 +3425,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000704ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG449 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000704ull;
@@ -3121,7 +3453,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
@@ -3149,10 +3483,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000708ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG450 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000708ull;
@@ -3173,7 +3511,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
@@ -3201,10 +3541,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000070Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG451 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000070Cull;
@@ -3225,7 +3569,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
@@ -3253,10 +3599,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000710ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG452 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000710ull;
@@ -3277,7 +3627,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
@@ -3305,10 +3657,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000714ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG453 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000714ull;
@@ -3329,7 +3685,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
@@ -3357,10 +3715,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000718ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG454 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000718ull;
@@ -3381,7 +3743,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
@@ -3409,10 +3773,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000071Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG455 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000071Cull;
@@ -3433,7 +3801,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
@@ -3461,10 +3831,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000720ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG456 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000720ull;
@@ -3485,7 +3859,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
@@ -3513,10 +3889,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000728ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG458 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000728ull;
@@ -3537,7 +3917,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
@@ -3565,10 +3947,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000072Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG459 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000072Cull;
@@ -3589,7 +3975,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
@@ -3617,10 +4005,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000730ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG460 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000730ull;
@@ -3641,7 +4033,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
@@ -3669,10 +4063,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000734ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG461 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000734ull;
@@ -3693,7 +4091,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
@@ -3721,10 +4121,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000738ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG462 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000738ull;
@@ -3745,7 +4149,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
@@ -3773,10 +4179,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000073Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG463 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000073Cull;
@@ -3797,7 +4207,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
@@ -3825,10 +4237,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000740ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG464 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000740ull;
@@ -3849,7 +4265,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
@@ -3877,10 +4295,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000744ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG465 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000744ull;
@@ -3901,7 +4323,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
@@ -3929,10 +4353,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000748ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG466 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000748ull;
@@ -3953,7 +4381,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
@@ -3981,10 +4411,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000074Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG467 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000074Cull;
@@ -4005,7 +4439,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
@@ -4033,10 +4469,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000750ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG468 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000750ull;
@@ -4057,7 +4497,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
@@ -4212,10 +4654,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000080Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG515 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000080Cull;
@@ -4233,7 +4679,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
@@ -4261,10 +4709,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000810ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG516 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000810ull;
@@ -4285,7 +4737,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
@@ -4313,10 +4767,14 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000814ull + ((offset) & 7) * 0x100000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG517 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000814ull;
@@ -4337,7 +4795,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
@@ -4347,37 +4807,40 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", offset);
-	return 0x0000030000000890ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000030000000890ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG548(offset) (0x0000030000000890ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG548(offset) (0x0000030000000890ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000008A8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000008A8ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG554(offset) (0x00000300000008A8ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG554(offset) (0x00000300000008A8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", offset);
-	return 0x00000300000008B8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000300000008B8ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG558(offset) (0x00000300000008B8ull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG558(offset) (0x00000300000008B8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 
 /**
@@ -4418,7 +4881,9 @@ union cvmx_pcieepx_cfg000 {
 	struct cvmx_pcieepx_cfg000_s          cn70xx;
 	struct cvmx_pcieepx_cfg000_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg000_s          cn73xx;
+	struct cvmx_pcieepx_cfg000_s          cn75xx;
 	struct cvmx_pcieepx_cfg000_s          cn78xx;
+	struct cvmx_pcieepx_cfg000_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg000_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg000 cvmx_pcieepx_cfg000_t;
@@ -4507,7 +4972,9 @@ union cvmx_pcieepx_cfg001 {
 	struct cvmx_pcieepx_cfg001_s          cn70xx;
 	struct cvmx_pcieepx_cfg001_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg001_s          cn73xx;
+	struct cvmx_pcieepx_cfg001_s          cn75xx;
 	struct cvmx_pcieepx_cfg001_s          cn78xx;
+	struct cvmx_pcieepx_cfg001_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg001_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg001 cvmx_pcieepx_cfg001_t;
@@ -4550,7 +5017,9 @@ union cvmx_pcieepx_cfg002 {
 	struct cvmx_pcieepx_cfg002_s          cn70xx;
 	struct cvmx_pcieepx_cfg002_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg002_s          cn73xx;
+	struct cvmx_pcieepx_cfg002_s          cn75xx;
 	struct cvmx_pcieepx_cfg002_s          cn78xx;
+	struct cvmx_pcieepx_cfg002_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg002_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg002 cvmx_pcieepx_cfg002_t;
@@ -4602,7 +5071,9 @@ union cvmx_pcieepx_cfg003 {
 	struct cvmx_pcieepx_cfg003_s          cn70xx;
 	struct cvmx_pcieepx_cfg003_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg003_s          cn73xx;
+	struct cvmx_pcieepx_cfg003_s          cn75xx;
 	struct cvmx_pcieepx_cfg003_s          cn78xx;
+	struct cvmx_pcieepx_cfg003_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg003_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg003 cvmx_pcieepx_cfg003_t;
@@ -4698,6 +5169,7 @@ union cvmx_pcieepx_cfg004 {
 	uint32_t lbab                         : 8;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg004_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg004_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the BAR 0 base address. */
@@ -4722,6 +5194,7 @@ union cvmx_pcieepx_cfg004 {
 	uint32_t lbab                         : 17;
 #endif
 	} cn78xx;
+	struct cvmx_pcieepx_cfg004_cn78xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg004_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg004 cvmx_pcieepx_cfg004_t;
@@ -4762,7 +5235,9 @@ union cvmx_pcieepx_cfg004_mask {
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg004_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg004_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg004_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg004_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg004_mask cvmx_pcieepx_cfg004_mask_t;
@@ -4795,7 +5270,9 @@ union cvmx_pcieepx_cfg005 {
 	struct cvmx_pcieepx_cfg005_s          cn70xx;
 	struct cvmx_pcieepx_cfg005_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg005_s          cn73xx;
+	struct cvmx_pcieepx_cfg005_s          cn75xx;
 	struct cvmx_pcieepx_cfg005_s          cn78xx;
+	struct cvmx_pcieepx_cfg005_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg005_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg005 cvmx_pcieepx_cfg005_t;
@@ -4828,7 +5305,9 @@ union cvmx_pcieepx_cfg005_mask {
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg005_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg005_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg005_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg005_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg005_mask cvmx_pcieepx_cfg005_mask_t;
@@ -4879,7 +5358,9 @@ union cvmx_pcieepx_cfg006 {
 	struct cvmx_pcieepx_cfg006_s          cn70xx;
 	struct cvmx_pcieepx_cfg006_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg006_s          cn73xx;
+	struct cvmx_pcieepx_cfg006_s          cn75xx;
 	struct cvmx_pcieepx_cfg006_s          cn78xx;
+	struct cvmx_pcieepx_cfg006_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg006_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg006 cvmx_pcieepx_cfg006_t;
@@ -4920,7 +5401,9 @@ union cvmx_pcieepx_cfg006_mask {
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg006_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg006_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg006_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg006_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg006_mask cvmx_pcieepx_cfg006_mask_t;
@@ -4953,7 +5436,9 @@ union cvmx_pcieepx_cfg007 {
 	struct cvmx_pcieepx_cfg007_s          cn70xx;
 	struct cvmx_pcieepx_cfg007_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg007_s          cn73xx;
+	struct cvmx_pcieepx_cfg007_s          cn75xx;
 	struct cvmx_pcieepx_cfg007_s          cn78xx;
+	struct cvmx_pcieepx_cfg007_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg007_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg007 cvmx_pcieepx_cfg007_t;
@@ -4986,7 +5471,9 @@ union cvmx_pcieepx_cfg007_mask {
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg007_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg007_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg007_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg007_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg007_mask cvmx_pcieepx_cfg007_mask_t;
@@ -5059,7 +5546,9 @@ union cvmx_pcieepx_cfg008 {
 	struct cvmx_pcieepx_cfg008_s          cn70xx;
 	struct cvmx_pcieepx_cfg008_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg008_s          cn73xx;
+	struct cvmx_pcieepx_cfg008_s          cn75xx;
 	struct cvmx_pcieepx_cfg008_s          cn78xx;
+	struct cvmx_pcieepx_cfg008_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg008_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg008 cvmx_pcieepx_cfg008_t;
@@ -5100,7 +5589,9 @@ union cvmx_pcieepx_cfg008_mask {
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg008_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg008_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg008_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg008_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg008_mask cvmx_pcieepx_cfg008_mask_t;
@@ -5155,7 +5646,9 @@ union cvmx_pcieepx_cfg009 {
 	} cn70xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn73xx;
+	struct cvmx_pcieepx_cfg009_cn70xx     cn75xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn78xx;
+	struct cvmx_pcieepx_cfg009_cn70xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg009_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg009 cvmx_pcieepx_cfg009_t;
@@ -5188,7 +5681,9 @@ union cvmx_pcieepx_cfg009_mask {
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg009_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg009_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg009_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg009_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg009_mask cvmx_pcieepx_cfg009_mask_t;
@@ -5222,7 +5717,9 @@ union cvmx_pcieepx_cfg010 {
 	struct cvmx_pcieepx_cfg010_s          cn70xx;
 	struct cvmx_pcieepx_cfg010_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg010_s          cn73xx;
+	struct cvmx_pcieepx_cfg010_s          cn75xx;
 	struct cvmx_pcieepx_cfg010_s          cn78xx;
+	struct cvmx_pcieepx_cfg010_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg010_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg010 cvmx_pcieepx_cfg010_t;
@@ -5260,7 +5757,9 @@ union cvmx_pcieepx_cfg011 {
 	struct cvmx_pcieepx_cfg011_s          cn70xx;
 	struct cvmx_pcieepx_cfg011_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg011_s          cn73xx;
+	struct cvmx_pcieepx_cfg011_s          cn75xx;
 	struct cvmx_pcieepx_cfg011_s          cn78xx;
+	struct cvmx_pcieepx_cfg011_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg011_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg011 cvmx_pcieepx_cfg011_t;
@@ -5297,7 +5796,9 @@ union cvmx_pcieepx_cfg012 {
 	struct cvmx_pcieepx_cfg012_s          cn70xx;
 	struct cvmx_pcieepx_cfg012_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg012_s          cn73xx;
+	struct cvmx_pcieepx_cfg012_s          cn75xx;
 	struct cvmx_pcieepx_cfg012_s          cn78xx;
+	struct cvmx_pcieepx_cfg012_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg012_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg012 cvmx_pcieepx_cfg012_t;
@@ -5338,7 +5839,9 @@ union cvmx_pcieepx_cfg012_mask {
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xxp1;
 	struct cvmx_pcieepx_cfg012_mask_s     cn73xx;
+	struct cvmx_pcieepx_cfg012_mask_s     cn75xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn78xx;
+	struct cvmx_pcieepx_cfg012_mask_s     cn78xxp2;
 	struct cvmx_pcieepx_cfg012_mask_s     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg012_mask cvmx_pcieepx_cfg012_mask_t;
@@ -5376,7 +5879,9 @@ union cvmx_pcieepx_cfg013 {
 	struct cvmx_pcieepx_cfg013_s          cn70xx;
 	struct cvmx_pcieepx_cfg013_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg013_s          cn73xx;
+	struct cvmx_pcieepx_cfg013_s          cn75xx;
 	struct cvmx_pcieepx_cfg013_s          cn78xx;
+	struct cvmx_pcieepx_cfg013_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg013_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg013 cvmx_pcieepx_cfg013_t;
@@ -5420,7 +5925,9 @@ union cvmx_pcieepx_cfg015 {
 	struct cvmx_pcieepx_cfg015_s          cn70xx;
 	struct cvmx_pcieepx_cfg015_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg015_s          cn73xx;
+	struct cvmx_pcieepx_cfg015_s          cn75xx;
 	struct cvmx_pcieepx_cfg015_s          cn78xx;
+	struct cvmx_pcieepx_cfg015_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg015_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg015 cvmx_pcieepx_cfg015_t;
@@ -5486,7 +5993,9 @@ union cvmx_pcieepx_cfg016 {
 	struct cvmx_pcieepx_cfg016_s          cn70xx;
 	struct cvmx_pcieepx_cfg016_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg016_s          cn73xx;
+	struct cvmx_pcieepx_cfg016_s          cn75xx;
 	struct cvmx_pcieepx_cfg016_s          cn78xx;
+	struct cvmx_pcieepx_cfg016_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg016_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg016 cvmx_pcieepx_cfg016_t;
@@ -5552,7 +6061,9 @@ union cvmx_pcieepx_cfg017 {
 	struct cvmx_pcieepx_cfg017_s          cn70xx;
 	struct cvmx_pcieepx_cfg017_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg017_s          cn73xx;
+	struct cvmx_pcieepx_cfg017_s          cn75xx;
 	struct cvmx_pcieepx_cfg017_s          cn78xx;
+	struct cvmx_pcieepx_cfg017_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg017_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg017 cvmx_pcieepx_cfg017_t;
@@ -5635,7 +6146,9 @@ union cvmx_pcieepx_cfg020 {
 	struct cvmx_pcieepx_cfg020_s          cn70xx;
 	struct cvmx_pcieepx_cfg020_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg020_s          cn73xx;
+	struct cvmx_pcieepx_cfg020_s          cn75xx;
 	struct cvmx_pcieepx_cfg020_s          cn78xx;
+	struct cvmx_pcieepx_cfg020_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg020_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg020 cvmx_pcieepx_cfg020_t;
@@ -5670,7 +6183,9 @@ union cvmx_pcieepx_cfg021 {
 	struct cvmx_pcieepx_cfg021_s          cn70xx;
 	struct cvmx_pcieepx_cfg021_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg021_s          cn73xx;
+	struct cvmx_pcieepx_cfg021_s          cn75xx;
 	struct cvmx_pcieepx_cfg021_s          cn78xx;
+	struct cvmx_pcieepx_cfg021_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg021_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg021 cvmx_pcieepx_cfg021_t;
@@ -5703,7 +6218,9 @@ union cvmx_pcieepx_cfg022 {
 	struct cvmx_pcieepx_cfg022_s          cn70xx;
 	struct cvmx_pcieepx_cfg022_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg022_s          cn73xx;
+	struct cvmx_pcieepx_cfg022_s          cn75xx;
 	struct cvmx_pcieepx_cfg022_s          cn78xx;
+	struct cvmx_pcieepx_cfg022_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg022_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg022 cvmx_pcieepx_cfg022_t;
@@ -5740,7 +6257,9 @@ union cvmx_pcieepx_cfg023 {
 	struct cvmx_pcieepx_cfg023_s          cn70xx;
 	struct cvmx_pcieepx_cfg023_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg023_s          cn73xx;
+	struct cvmx_pcieepx_cfg023_s          cn75xx;
 	struct cvmx_pcieepx_cfg023_s          cn78xx;
+	struct cvmx_pcieepx_cfg023_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg023_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg023 cvmx_pcieepx_cfg023_t;
@@ -5764,7 +6283,9 @@ union cvmx_pcieepx_cfg024 {
 	struct cvmx_pcieepx_cfg024_s          cn70xx;
 	struct cvmx_pcieepx_cfg024_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg024_s          cn73xx;
+	struct cvmx_pcieepx_cfg024_s          cn75xx;
 	struct cvmx_pcieepx_cfg024_s          cn78xx;
+	struct cvmx_pcieepx_cfg024_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg024 cvmx_pcieepx_cfg024_t;
 
@@ -5786,7 +6307,9 @@ union cvmx_pcieepx_cfg025 {
 	struct cvmx_pcieepx_cfg025_s          cn70xx;
 	struct cvmx_pcieepx_cfg025_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg025_s          cn73xx;
+	struct cvmx_pcieepx_cfg025_s          cn75xx;
 	struct cvmx_pcieepx_cfg025_s          cn78xx;
+	struct cvmx_pcieepx_cfg025_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg025 cvmx_pcieepx_cfg025_t;
 
@@ -5838,7 +6361,9 @@ union cvmx_pcieepx_cfg028 {
 	struct cvmx_pcieepx_cfg028_s          cn70xx;
 	struct cvmx_pcieepx_cfg028_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg028_s          cn73xx;
+	struct cvmx_pcieepx_cfg028_s          cn75xx;
 	struct cvmx_pcieepx_cfg028_s          cn78xx;
+	struct cvmx_pcieepx_cfg028_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg028_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg028 cvmx_pcieepx_cfg028_t;
@@ -5988,7 +6513,9 @@ union cvmx_pcieepx_cfg029 {
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn73xx;
+	struct cvmx_pcieepx_cfg029_cn61xx     cn75xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn78xx;
+	struct cvmx_pcieepx_cfg029_cn61xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg029_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg029 cvmx_pcieepx_cfg029_t;
@@ -6196,7 +6723,9 @@ union cvmx_pcieepx_cfg030 {
 	struct cvmx_pcieepx_cfg030_s          cn70xx;
 	struct cvmx_pcieepx_cfg030_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg030_s          cn73xx;
+	struct cvmx_pcieepx_cfg030_s          cn75xx;
 	struct cvmx_pcieepx_cfg030_s          cn78xx;
+	struct cvmx_pcieepx_cfg030_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg030_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg030 cvmx_pcieepx_cfg030_t;
@@ -6326,7 +6855,9 @@ union cvmx_pcieepx_cfg031 {
 	struct cvmx_pcieepx_cfg031_s          cn70xx;
 	struct cvmx_pcieepx_cfg031_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg031_s          cn73xx;
+	struct cvmx_pcieepx_cfg031_s          cn75xx;
 	struct cvmx_pcieepx_cfg031_s          cn78xx;
+	struct cvmx_pcieepx_cfg031_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg031_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg031 cvmx_pcieepx_cfg031_t;
@@ -6537,7 +7068,9 @@ union cvmx_pcieepx_cfg032 {
 	struct cvmx_pcieepx_cfg032_s          cn70xx;
 	struct cvmx_pcieepx_cfg032_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg032_s          cn73xx;
+	struct cvmx_pcieepx_cfg032_s          cn75xx;
 	struct cvmx_pcieepx_cfg032_s          cn78xx;
+	struct cvmx_pcieepx_cfg032_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg032_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg032 cvmx_pcieepx_cfg032_t;
@@ -6824,7 +7357,9 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg037_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg037_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg037_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -6966,7 +7501,9 @@ union cvmx_pcieepx_cfg038 {
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg038_s          cn73xx;
+	struct cvmx_pcieepx_cfg038_s          cn75xx;
 	struct cvmx_pcieepx_cfg038_s          cn78xx;
+	struct cvmx_pcieepx_cfg038_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_15_31               : 17;
@@ -7060,7 +7597,9 @@ union cvmx_pcieepx_cfg039 {
 	struct cvmx_pcieepx_cfg039_s          cn70xx;
 	struct cvmx_pcieepx_cfg039_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg039_s          cn73xx;
+	struct cvmx_pcieepx_cfg039_s          cn75xx;
 	struct cvmx_pcieepx_cfg039_s          cn78xx;
+	struct cvmx_pcieepx_cfg039_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg039_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg039 cvmx_pcieepx_cfg039_t;
@@ -7281,7 +7820,9 @@ union cvmx_pcieepx_cfg040 {
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg040_s          cn73xx;
+	struct cvmx_pcieepx_cfg040_s          cn75xx;
 	struct cvmx_pcieepx_cfg040_s          cn78xx;
+	struct cvmx_pcieepx_cfg040_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg040_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg040 cvmx_pcieepx_cfg040_t;
@@ -7364,7 +7905,9 @@ union cvmx_pcieepx_cfg044 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg044_s          cn73xx;
+	struct cvmx_pcieepx_cfg044_s          cn75xx;
 	struct cvmx_pcieepx_cfg044_s          cn78xx;
+	struct cvmx_pcieepx_cfg044_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg044 cvmx_pcieepx_cfg044_t;
 
@@ -7391,7 +7934,9 @@ union cvmx_pcieepx_cfg045 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg045_s          cn73xx;
+	struct cvmx_pcieepx_cfg045_s          cn75xx;
 	struct cvmx_pcieepx_cfg045_s          cn78xx;
+	struct cvmx_pcieepx_cfg045_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg045 cvmx_pcieepx_cfg045_t;
 
@@ -7418,7 +7963,9 @@ union cvmx_pcieepx_cfg046 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg046_s          cn73xx;
+	struct cvmx_pcieepx_cfg046_s          cn75xx;
 	struct cvmx_pcieepx_cfg046_s          cn78xx;
+	struct cvmx_pcieepx_cfg046_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg046 cvmx_pcieepx_cfg046_t;
 
@@ -7454,7 +8001,9 @@ union cvmx_pcieepx_cfg064 {
 	struct cvmx_pcieepx_cfg064_s          cn70xx;
 	struct cvmx_pcieepx_cfg064_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg064_s          cn73xx;
+	struct cvmx_pcieepx_cfg064_s          cn75xx;
 	struct cvmx_pcieepx_cfg064_s          cn78xx;
+	struct cvmx_pcieepx_cfg064_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg064_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg064 cvmx_pcieepx_cfg064_t;
@@ -7671,7 +8220,9 @@ union cvmx_pcieepx_cfg065 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg065_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg065_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg065_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg065_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -7926,7 +8477,9 @@ union cvmx_pcieepx_cfg066 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg066_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg066_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg066_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg066_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -8181,7 +8734,9 @@ union cvmx_pcieepx_cfg067 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg067_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg067_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg067_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg067_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -8292,7 +8847,9 @@ union cvmx_pcieepx_cfg068 {
 	struct cvmx_pcieepx_cfg068_s          cn70xx;
 	struct cvmx_pcieepx_cfg068_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg068_s          cn73xx;
+	struct cvmx_pcieepx_cfg068_s          cn75xx;
 	struct cvmx_pcieepx_cfg068_s          cn78xx;
+	struct cvmx_pcieepx_cfg068_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg068_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg068 cvmx_pcieepx_cfg068_t;
@@ -8365,7 +8922,9 @@ union cvmx_pcieepx_cfg069 {
 	struct cvmx_pcieepx_cfg069_s          cn70xx;
 	struct cvmx_pcieepx_cfg069_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg069_s          cn73xx;
+	struct cvmx_pcieepx_cfg069_s          cn75xx;
 	struct cvmx_pcieepx_cfg069_s          cn78xx;
+	struct cvmx_pcieepx_cfg069_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg069_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg069 cvmx_pcieepx_cfg069_t;
@@ -8428,7 +8987,9 @@ union cvmx_pcieepx_cfg070 {
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg070_s          cn73xx;
+	struct cvmx_pcieepx_cfg070_s          cn75xx;
 	struct cvmx_pcieepx_cfg070_s          cn78xx;
+	struct cvmx_pcieepx_cfg070_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg070_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg070 cvmx_pcieepx_cfg070_t;
@@ -8461,7 +9022,9 @@ union cvmx_pcieepx_cfg071 {
 	struct cvmx_pcieepx_cfg071_s          cn70xx;
 	struct cvmx_pcieepx_cfg071_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg071_s          cn73xx;
+	struct cvmx_pcieepx_cfg071_s          cn75xx;
 	struct cvmx_pcieepx_cfg071_s          cn78xx;
+	struct cvmx_pcieepx_cfg071_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg071_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg071 cvmx_pcieepx_cfg071_t;
@@ -8494,7 +9057,9 @@ union cvmx_pcieepx_cfg072 {
 	struct cvmx_pcieepx_cfg072_s          cn70xx;
 	struct cvmx_pcieepx_cfg072_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg072_s          cn73xx;
+	struct cvmx_pcieepx_cfg072_s          cn75xx;
 	struct cvmx_pcieepx_cfg072_s          cn78xx;
+	struct cvmx_pcieepx_cfg072_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg072_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg072 cvmx_pcieepx_cfg072_t;
@@ -8527,7 +9092,9 @@ union cvmx_pcieepx_cfg073 {
 	struct cvmx_pcieepx_cfg073_s          cn70xx;
 	struct cvmx_pcieepx_cfg073_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg073_s          cn73xx;
+	struct cvmx_pcieepx_cfg073_s          cn75xx;
 	struct cvmx_pcieepx_cfg073_s          cn78xx;
+	struct cvmx_pcieepx_cfg073_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg073_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg073 cvmx_pcieepx_cfg073_t;
@@ -8560,7 +9127,9 @@ union cvmx_pcieepx_cfg074 {
 	struct cvmx_pcieepx_cfg074_s          cn70xx;
 	struct cvmx_pcieepx_cfg074_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg074_s          cn73xx;
+	struct cvmx_pcieepx_cfg074_s          cn75xx;
 	struct cvmx_pcieepx_cfg074_s          cn78xx;
+	struct cvmx_pcieepx_cfg074_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg074_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg074 cvmx_pcieepx_cfg074_t;
@@ -8581,7 +9150,9 @@ union cvmx_pcieepx_cfg078 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg078_s          cn73xx;
+	struct cvmx_pcieepx_cfg078_s          cn75xx;
 	struct cvmx_pcieepx_cfg078_s          cn78xx;
+	struct cvmx_pcieepx_cfg078_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg078 cvmx_pcieepx_cfg078_t;
 
@@ -8627,7 +9198,9 @@ union cvmx_pcieepx_cfg082 {
 	uint32_t nco                          : 12;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg082_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg082_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg082_cn73xx     cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg082 cvmx_pcieepx_cfg082_t;
 
@@ -8690,7 +9263,9 @@ union cvmx_pcieepx_cfg083 {
 	uint32_t reserved_23_31               : 9;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg083_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg083_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg083_cn73xx     cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg083 cvmx_pcieepx_cfg083_t;
 
@@ -8744,7 +9319,9 @@ union cvmx_pcieepx_cfg086 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg086_s          cn73xx;
+	struct cvmx_pcieepx_cfg086_s          cn75xx;
 	struct cvmx_pcieepx_cfg086_s          cn78xx;
+	struct cvmx_pcieepx_cfg086_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg086 cvmx_pcieepx_cfg086_t;
 
@@ -8768,7 +9345,9 @@ union cvmx_pcieepx_cfg087 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg087_s          cn73xx;
+	struct cvmx_pcieepx_cfg087_s          cn75xx;
 	struct cvmx_pcieepx_cfg087_s          cn78xx;
+	struct cvmx_pcieepx_cfg087_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg087 cvmx_pcieepx_cfg087_t;
 
@@ -8790,7 +9369,9 @@ union cvmx_pcieepx_cfg088 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg088_s          cn73xx;
+	struct cvmx_pcieepx_cfg088_s          cn75xx;
 	struct cvmx_pcieepx_cfg088_s          cn78xx;
+	struct cvmx_pcieepx_cfg088_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg088 cvmx_pcieepx_cfg088_t;
 
@@ -8826,7 +9407,9 @@ union cvmx_pcieepx_cfg089 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg089_s          cn73xx;
+	struct cvmx_pcieepx_cfg089_s          cn75xx;
 	struct cvmx_pcieepx_cfg089_s          cn78xx;
+	struct cvmx_pcieepx_cfg089_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg089 cvmx_pcieepx_cfg089_t;
 
@@ -8862,7 +9445,9 @@ union cvmx_pcieepx_cfg090 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg090_s          cn73xx;
+	struct cvmx_pcieepx_cfg090_s          cn75xx;
 	struct cvmx_pcieepx_cfg090_s          cn78xx;
+	struct cvmx_pcieepx_cfg090_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg090 cvmx_pcieepx_cfg090_t;
 
@@ -8898,7 +9483,9 @@ union cvmx_pcieepx_cfg091 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg091_s          cn73xx;
+	struct cvmx_pcieepx_cfg091_s          cn75xx;
 	struct cvmx_pcieepx_cfg091_s          cn78xx;
+	struct cvmx_pcieepx_cfg091_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg091 cvmx_pcieepx_cfg091_t;
 
@@ -8934,7 +9521,9 @@ union cvmx_pcieepx_cfg092 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg092_s          cn73xx;
+	struct cvmx_pcieepx_cfg092_s          cn75xx;
 	struct cvmx_pcieepx_cfg092_s          cn78xx;
+	struct cvmx_pcieepx_cfg092_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg092 cvmx_pcieepx_cfg092_t;
 
@@ -8958,7 +9547,9 @@ union cvmx_pcieepx_cfg094 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg094_s          cn73xx;
+	struct cvmx_pcieepx_cfg094_s          cn75xx;
 	struct cvmx_pcieepx_cfg094_s          cn78xx;
+	struct cvmx_pcieepx_cfg094_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg094 cvmx_pcieepx_cfg094_t;
 
@@ -8985,7 +9576,9 @@ union cvmx_pcieepx_cfg095 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg095_s          cn73xx;
+	struct cvmx_pcieepx_cfg095_s          cn75xx;
 	struct cvmx_pcieepx_cfg095_s          cn78xx;
+	struct cvmx_pcieepx_cfg095_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg095 cvmx_pcieepx_cfg095_t;
 
@@ -9022,7 +9615,9 @@ union cvmx_pcieepx_cfg096 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg096_s          cn73xx;
+	struct cvmx_pcieepx_cfg096_s          cn75xx;
 	struct cvmx_pcieepx_cfg096_s          cn78xx;
+	struct cvmx_pcieepx_cfg096_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg096 cvmx_pcieepx_cfg096_t;
 
@@ -9044,7 +9639,9 @@ union cvmx_pcieepx_cfg097 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg097_s          cn73xx;
+	struct cvmx_pcieepx_cfg097_s          cn75xx;
 	struct cvmx_pcieepx_cfg097_s          cn78xx;
+	struct cvmx_pcieepx_cfg097_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg097 cvmx_pcieepx_cfg097_t;
 
@@ -9068,7 +9665,9 @@ union cvmx_pcieepx_cfg098 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg098_s          cn73xx;
+	struct cvmx_pcieepx_cfg098_s          cn75xx;
 	struct cvmx_pcieepx_cfg098_s          cn78xx;
+	struct cvmx_pcieepx_cfg098_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg098 cvmx_pcieepx_cfg098_t;
 
@@ -9090,7 +9689,9 @@ union cvmx_pcieepx_cfg099 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg099_s          cn73xx;
+	struct cvmx_pcieepx_cfg099_s          cn75xx;
 	struct cvmx_pcieepx_cfg099_s          cn78xx;
+	struct cvmx_pcieepx_cfg099_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg099 cvmx_pcieepx_cfg099_t;
 
@@ -9112,7 +9713,9 @@ union cvmx_pcieepx_cfg100 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg100_s          cn73xx;
+	struct cvmx_pcieepx_cfg100_s          cn75xx;
 	struct cvmx_pcieepx_cfg100_s          cn78xx;
+	struct cvmx_pcieepx_cfg100_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg100 cvmx_pcieepx_cfg100_t;
 
@@ -9132,7 +9735,9 @@ union cvmx_pcieepx_cfg101 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg101_s          cn73xx;
+	struct cvmx_pcieepx_cfg101_s          cn75xx;
 	struct cvmx_pcieepx_cfg101_s          cn78xx;
+	struct cvmx_pcieepx_cfg101_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg101 cvmx_pcieepx_cfg101_t;
 
@@ -9152,7 +9757,9 @@ union cvmx_pcieepx_cfg102 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg102_s          cn73xx;
+	struct cvmx_pcieepx_cfg102_s          cn75xx;
 	struct cvmx_pcieepx_cfg102_s          cn78xx;
+	struct cvmx_pcieepx_cfg102_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg102 cvmx_pcieepx_cfg102_t;
 
@@ -9200,6 +9807,7 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t lbab                         : 12;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg103_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg103_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the VF BAR 0 base address. */
@@ -9219,6 +9827,7 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t lbab                         : 17;
 #endif
 	} cn78xx;
+	struct cvmx_pcieepx_cfg103_cn78xx     cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg103 cvmx_pcieepx_cfg103_t;
 
@@ -9238,7 +9847,9 @@ union cvmx_pcieepx_cfg104 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg104_s          cn73xx;
+	struct cvmx_pcieepx_cfg104_s          cn75xx;
 	struct cvmx_pcieepx_cfg104_s          cn78xx;
+	struct cvmx_pcieepx_cfg104_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg104 cvmx_pcieepx_cfg104_t;
 
@@ -9258,7 +9869,9 @@ union cvmx_pcieepx_cfg105 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg105_s          cn73xx;
+	struct cvmx_pcieepx_cfg105_s          cn75xx;
 	struct cvmx_pcieepx_cfg105_s          cn78xx;
+	struct cvmx_pcieepx_cfg105_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg105 cvmx_pcieepx_cfg105_t;
 
@@ -9278,7 +9891,9 @@ union cvmx_pcieepx_cfg106 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg106_s          cn73xx;
+	struct cvmx_pcieepx_cfg106_s          cn75xx;
 	struct cvmx_pcieepx_cfg106_s          cn78xx;
+	struct cvmx_pcieepx_cfg106_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg106 cvmx_pcieepx_cfg106_t;
 
@@ -9298,7 +9913,9 @@ union cvmx_pcieepx_cfg107 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg107_s          cn73xx;
+	struct cvmx_pcieepx_cfg107_s          cn75xx;
 	struct cvmx_pcieepx_cfg107_s          cn78xx;
+	struct cvmx_pcieepx_cfg107_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg107 cvmx_pcieepx_cfg107_t;
 
@@ -9318,7 +9935,9 @@ union cvmx_pcieepx_cfg108 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg108_s          cn73xx;
+	struct cvmx_pcieepx_cfg108_s          cn75xx;
 	struct cvmx_pcieepx_cfg108_s          cn78xx;
+	struct cvmx_pcieepx_cfg108_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg108 cvmx_pcieepx_cfg108_t;
 
@@ -9340,7 +9959,9 @@ union cvmx_pcieepx_cfg109 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg109_s          cn73xx;
+	struct cvmx_pcieepx_cfg109_s          cn75xx;
 	struct cvmx_pcieepx_cfg109_s          cn78xx;
+	struct cvmx_pcieepx_cfg109_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg109 cvmx_pcieepx_cfg109_t;
 
@@ -9364,7 +9985,9 @@ union cvmx_pcieepx_cfg110 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg110_s          cn73xx;
+	struct cvmx_pcieepx_cfg110_s          cn75xx;
 	struct cvmx_pcieepx_cfg110_s          cn78xx;
+	struct cvmx_pcieepx_cfg110_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg110 cvmx_pcieepx_cfg110_t;
 
@@ -9391,7 +10014,9 @@ union cvmx_pcieepx_cfg111 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg111_s          cn73xx;
+	struct cvmx_pcieepx_cfg111_s          cn75xx;
 	struct cvmx_pcieepx_cfg111_s          cn78xx;
+	struct cvmx_pcieepx_cfg111_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg111 cvmx_pcieepx_cfg111_t;
 
@@ -9420,7 +10045,9 @@ union cvmx_pcieepx_cfg112 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg112_s          cn73xx;
+	struct cvmx_pcieepx_cfg112_s          cn75xx;
 	struct cvmx_pcieepx_cfg112_s          cn78xx;
+	struct cvmx_pcieepx_cfg112_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg112 cvmx_pcieepx_cfg112_t;
 
@@ -9468,7 +10095,9 @@ union cvmx_pcieepx_cfg448 {
 	struct cvmx_pcieepx_cfg448_s          cn70xx;
 	struct cvmx_pcieepx_cfg448_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg448_s          cn73xx;
+	struct cvmx_pcieepx_cfg448_s          cn75xx;
 	struct cvmx_pcieepx_cfg448_s          cn78xx;
+	struct cvmx_pcieepx_cfg448_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg448_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg448 cvmx_pcieepx_cfg448_t;
@@ -9512,7 +10141,9 @@ union cvmx_pcieepx_cfg449 {
 	struct cvmx_pcieepx_cfg449_s          cn70xx;
 	struct cvmx_pcieepx_cfg449_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg449_s          cn73xx;
+	struct cvmx_pcieepx_cfg449_s          cn75xx;
 	struct cvmx_pcieepx_cfg449_s          cn78xx;
+	struct cvmx_pcieepx_cfg449_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg449_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg449 cvmx_pcieepx_cfg449_t;
@@ -9685,7 +10316,9 @@ union cvmx_pcieepx_cfg450 {
 	struct cvmx_pcieepx_cfg450_s          cn70xx;
 	struct cvmx_pcieepx_cfg450_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg450_cn52xx     cn73xx;
+	struct cvmx_pcieepx_cfg450_cn52xx     cn75xx;
 	struct cvmx_pcieepx_cfg450_cn52xx     cn78xx;
+	struct cvmx_pcieepx_cfg450_cn52xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg450_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg450 cvmx_pcieepx_cfg450_t;
@@ -9810,7 +10443,9 @@ union cvmx_pcieepx_cfg451 {
 	struct cvmx_pcieepx_cfg451_s          cn70xx;
 	struct cvmx_pcieepx_cfg451_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg451_s          cn73xx;
+	struct cvmx_pcieepx_cfg451_s          cn75xx;
 	struct cvmx_pcieepx_cfg451_s          cn78xx;
+	struct cvmx_pcieepx_cfg451_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg451_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg451 cvmx_pcieepx_cfg451_t;
@@ -10092,7 +10727,9 @@ union cvmx_pcieepx_cfg452 {
 	} cn70xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn73xx;
+	struct cvmx_pcieepx_cfg452_cn70xx     cn75xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn78xx;
+	struct cvmx_pcieepx_cfg452_cn70xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg452_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg452 cvmx_pcieepx_cfg452_t;
@@ -10141,7 +10778,9 @@ union cvmx_pcieepx_cfg453 {
 	struct cvmx_pcieepx_cfg453_s          cn70xx;
 	struct cvmx_pcieepx_cfg453_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg453_s          cn73xx;
+	struct cvmx_pcieepx_cfg453_s          cn75xx;
 	struct cvmx_pcieepx_cfg453_s          cn78xx;
+	struct cvmx_pcieepx_cfg453_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg453_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg453 cvmx_pcieepx_cfg453_t;
@@ -10284,7 +10923,9 @@ union cvmx_pcieepx_cfg454 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} cn73xx;
+	struct cvmx_pcieepx_cfg454_cn73xx     cn75xx;
 	struct cvmx_pcieepx_cfg454_cn73xx     cn78xx;
+	struct cvmx_pcieepx_cfg454_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg454 cvmx_pcieepx_cfg454_t;
@@ -10354,7 +10995,9 @@ union cvmx_pcieepx_cfg455 {
 	struct cvmx_pcieepx_cfg455_s          cn70xx;
 	struct cvmx_pcieepx_cfg455_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg455_s          cn73xx;
+	struct cvmx_pcieepx_cfg455_s          cn75xx;
 	struct cvmx_pcieepx_cfg455_s          cn78xx;
+	struct cvmx_pcieepx_cfg455_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg455_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg455 cvmx_pcieepx_cfg455_t;
@@ -10405,7 +11048,9 @@ union cvmx_pcieepx_cfg456 {
 	struct cvmx_pcieepx_cfg456_s          cn70xx;
 	struct cvmx_pcieepx_cfg456_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg456_s          cn73xx;
+	struct cvmx_pcieepx_cfg456_s          cn75xx;
 	struct cvmx_pcieepx_cfg456_s          cn78xx;
+	struct cvmx_pcieepx_cfg456_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg456_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg456 cvmx_pcieepx_cfg456_t;
@@ -10438,7 +11083,9 @@ union cvmx_pcieepx_cfg458 {
 	struct cvmx_pcieepx_cfg458_s          cn70xx;
 	struct cvmx_pcieepx_cfg458_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg458_s          cn73xx;
+	struct cvmx_pcieepx_cfg458_s          cn75xx;
 	struct cvmx_pcieepx_cfg458_s          cn78xx;
+	struct cvmx_pcieepx_cfg458_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg458_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg458 cvmx_pcieepx_cfg458_t;
@@ -10471,7 +11118,9 @@ union cvmx_pcieepx_cfg459 {
 	struct cvmx_pcieepx_cfg459_s          cn70xx;
 	struct cvmx_pcieepx_cfg459_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg459_s          cn73xx;
+	struct cvmx_pcieepx_cfg459_s          cn75xx;
 	struct cvmx_pcieepx_cfg459_s          cn78xx;
+	struct cvmx_pcieepx_cfg459_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg459_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg459 cvmx_pcieepx_cfg459_t;
@@ -10512,7 +11161,9 @@ union cvmx_pcieepx_cfg460 {
 	struct cvmx_pcieepx_cfg460_s          cn70xx;
 	struct cvmx_pcieepx_cfg460_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg460_s          cn73xx;
+	struct cvmx_pcieepx_cfg460_s          cn75xx;
 	struct cvmx_pcieepx_cfg460_s          cn78xx;
+	struct cvmx_pcieepx_cfg460_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg460_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg460 cvmx_pcieepx_cfg460_t;
@@ -10553,7 +11204,9 @@ union cvmx_pcieepx_cfg461 {
 	struct cvmx_pcieepx_cfg461_s          cn70xx;
 	struct cvmx_pcieepx_cfg461_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg461_s          cn73xx;
+	struct cvmx_pcieepx_cfg461_s          cn75xx;
 	struct cvmx_pcieepx_cfg461_s          cn78xx;
+	struct cvmx_pcieepx_cfg461_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg461_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg461 cvmx_pcieepx_cfg461_t;
@@ -10594,7 +11247,9 @@ union cvmx_pcieepx_cfg462 {
 	struct cvmx_pcieepx_cfg462_s          cn70xx;
 	struct cvmx_pcieepx_cfg462_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg462_s          cn73xx;
+	struct cvmx_pcieepx_cfg462_s          cn75xx;
 	struct cvmx_pcieepx_cfg462_s          cn78xx;
+	struct cvmx_pcieepx_cfg462_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg462_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg462 cvmx_pcieepx_cfg462_t;
@@ -10667,7 +11322,9 @@ union cvmx_pcieepx_cfg463 {
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xxp1;
 	struct cvmx_pcieepx_cfg463_s          cn73xx;
+	struct cvmx_pcieepx_cfg463_s          cn75xx;
 	struct cvmx_pcieepx_cfg463_s          cn78xx;
+	struct cvmx_pcieepx_cfg463_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg463_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg463 cvmx_pcieepx_cfg463_t;
@@ -10706,7 +11363,9 @@ union cvmx_pcieepx_cfg464 {
 	struct cvmx_pcieepx_cfg464_s          cn70xx;
 	struct cvmx_pcieepx_cfg464_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg464_s          cn73xx;
+	struct cvmx_pcieepx_cfg464_s          cn75xx;
 	struct cvmx_pcieepx_cfg464_s          cn78xx;
+	struct cvmx_pcieepx_cfg464_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg464_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg464 cvmx_pcieepx_cfg464_t;
@@ -10745,7 +11404,9 @@ union cvmx_pcieepx_cfg465 {
 	struct cvmx_pcieepx_cfg465_s          cn70xx;
 	struct cvmx_pcieepx_cfg465_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg465_s          cn73xx;
+	struct cvmx_pcieepx_cfg465_s          cn75xx;
 	struct cvmx_pcieepx_cfg465_s          cn78xx;
+	struct cvmx_pcieepx_cfg465_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg465_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg465 cvmx_pcieepx_cfg465_t;
@@ -10820,7 +11481,9 @@ union cvmx_pcieepx_cfg466 {
 	struct cvmx_pcieepx_cfg466_s          cn70xx;
 	struct cvmx_pcieepx_cfg466_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg466_s          cn73xx;
+	struct cvmx_pcieepx_cfg466_s          cn75xx;
 	struct cvmx_pcieepx_cfg466_s          cn78xx;
+	struct cvmx_pcieepx_cfg466_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg466_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg466 cvmx_pcieepx_cfg466_t;
@@ -10877,7 +11540,9 @@ union cvmx_pcieepx_cfg467 {
 	struct cvmx_pcieepx_cfg467_s          cn70xx;
 	struct cvmx_pcieepx_cfg467_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg467_s          cn73xx;
+	struct cvmx_pcieepx_cfg467_s          cn75xx;
 	struct cvmx_pcieepx_cfg467_s          cn78xx;
+	struct cvmx_pcieepx_cfg467_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg467_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg467 cvmx_pcieepx_cfg467_t;
@@ -10934,7 +11599,9 @@ union cvmx_pcieepx_cfg468 {
 	struct cvmx_pcieepx_cfg468_s          cn70xx;
 	struct cvmx_pcieepx_cfg468_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg468_s          cn73xx;
+	struct cvmx_pcieepx_cfg468_s          cn75xx;
 	struct cvmx_pcieepx_cfg468_s          cn78xx;
+	struct cvmx_pcieepx_cfg468_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg468_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg468 cvmx_pcieepx_cfg468_t;
@@ -11130,7 +11797,9 @@ union cvmx_pcieepx_cfg515 {
 	struct cvmx_pcieepx_cfg515_s          cn70xx;
 	struct cvmx_pcieepx_cfg515_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg515_s          cn73xx;
+	struct cvmx_pcieepx_cfg515_s          cn75xx;
 	struct cvmx_pcieepx_cfg515_s          cn78xx;
+	struct cvmx_pcieepx_cfg515_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg515_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg515 cvmx_pcieepx_cfg515_t;
@@ -11163,7 +11832,9 @@ union cvmx_pcieepx_cfg516 {
 	struct cvmx_pcieepx_cfg516_s          cn70xx;
 	struct cvmx_pcieepx_cfg516_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg516_s          cn73xx;
+	struct cvmx_pcieepx_cfg516_s          cn75xx;
 	struct cvmx_pcieepx_cfg516_s          cn78xx;
+	struct cvmx_pcieepx_cfg516_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg516_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg516 cvmx_pcieepx_cfg516_t;
@@ -11196,7 +11867,9 @@ union cvmx_pcieepx_cfg517 {
 	struct cvmx_pcieepx_cfg517_s          cn70xx;
 	struct cvmx_pcieepx_cfg517_s          cn70xxp1;
 	struct cvmx_pcieepx_cfg517_s          cn73xx;
+	struct cvmx_pcieepx_cfg517_s          cn75xx;
 	struct cvmx_pcieepx_cfg517_s          cn78xx;
+	struct cvmx_pcieepx_cfg517_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg517_s          cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg517 cvmx_pcieepx_cfg517_t;
@@ -11240,7 +11913,9 @@ union cvmx_pcieepx_cfg548 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg548_s          cn73xx;
+	struct cvmx_pcieepx_cfg548_s          cn75xx;
 	struct cvmx_pcieepx_cfg548_s          cn78xx;
+	struct cvmx_pcieepx_cfg548_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg548 cvmx_pcieepx_cfg548_t;
 
@@ -11306,7 +11981,9 @@ union cvmx_pcieepx_cfg554 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg554_s          cn73xx;
+	struct cvmx_pcieepx_cfg554_s          cn75xx;
 	struct cvmx_pcieepx_cfg554_s          cn78xx;
+	struct cvmx_pcieepx_cfg554_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg554 cvmx_pcieepx_cfg554_t;
 
@@ -11328,7 +12005,9 @@ union cvmx_pcieepx_cfg558 {
 #endif
 	} s;
 	struct cvmx_pcieepx_cfg558_s          cn73xx;
+	struct cvmx_pcieepx_cfg558_s          cn75xx;
 	struct cvmx_pcieepx_cfg558_s          cn78xx;
+	struct cvmx_pcieepx_cfg558_s          cn78xxp2;
 };
 typedef union cvmx_pcieepx_cfg558 cvmx_pcieepx_cfg558_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 132f020..cfc304d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -72,6 +72,7 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -95,6 +96,7 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
@@ -120,6 +122,7 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -143,6 +146,7 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
@@ -168,6 +172,7 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -191,6 +196,7 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
@@ -216,6 +222,7 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -239,6 +246,7 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
@@ -264,6 +272,7 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -287,6 +296,7 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
@@ -312,6 +322,7 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -335,6 +346,7 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
@@ -360,6 +372,7 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -383,6 +396,7 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
@@ -408,6 +422,7 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -431,6 +446,7 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
@@ -456,6 +472,7 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -479,6 +496,7 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
@@ -504,6 +522,7 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -527,6 +546,7 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
@@ -552,6 +572,7 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -575,6 +596,7 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
@@ -600,6 +622,7 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -623,6 +646,7 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
@@ -648,6 +672,7 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -671,6 +696,7 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
@@ -696,6 +722,7 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -719,6 +746,7 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
@@ -744,6 +772,7 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -767,6 +796,7 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000038ull;
@@ -792,6 +822,7 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -815,6 +846,7 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
@@ -840,6 +872,7 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -863,6 +896,7 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
@@ -888,6 +922,7 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -911,6 +946,7 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
@@ -936,6 +972,7 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -959,6 +996,7 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
@@ -984,6 +1022,7 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1007,6 +1046,7 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
@@ -1032,6 +1072,7 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1055,6 +1096,7 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
@@ -1080,6 +1122,7 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1103,6 +1146,7 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
@@ -1128,6 +1172,7 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1151,6 +1196,7 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
@@ -1176,6 +1222,7 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1199,6 +1246,7 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
@@ -1224,6 +1272,7 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1247,6 +1296,7 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
@@ -1272,6 +1322,7 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1295,6 +1346,7 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
@@ -1320,6 +1372,7 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1343,6 +1396,7 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
@@ -1368,6 +1422,7 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1391,6 +1446,7 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000084ull;
@@ -1416,6 +1472,7 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1439,6 +1496,7 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000088ull;
@@ -1464,6 +1522,7 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1487,6 +1546,7 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000008Cull;
@@ -1512,6 +1572,7 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1535,6 +1596,7 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000090ull;
@@ -1560,6 +1622,7 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1583,6 +1646,7 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
@@ -1608,6 +1672,7 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1631,6 +1696,7 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
@@ -1656,6 +1722,7 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1679,6 +1746,7 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
@@ -1704,6 +1772,7 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1727,6 +1796,7 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
@@ -1752,6 +1822,7 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1775,6 +1846,7 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A4ull;
@@ -1800,6 +1872,7 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1823,6 +1896,7 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A8ull;
@@ -1833,6 +1907,7 @@ static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B0ull + ((offset) & 3) * 0x100000000ull;
@@ -1845,6 +1920,7 @@ static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B4ull + ((offset) & 3) * 0x100000000ull;
@@ -1857,6 +1933,7 @@ static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B8ull + ((offset) & 3) * 0x100000000ull;
@@ -1884,6 +1961,7 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1907,6 +1985,7 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
@@ -1932,6 +2011,7 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1955,6 +2035,7 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
@@ -1980,6 +2061,7 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2003,6 +2085,7 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
@@ -2028,6 +2111,7 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2051,6 +2135,7 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
@@ -2076,6 +2161,7 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2099,6 +2185,7 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
@@ -2124,6 +2211,7 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2147,6 +2235,7 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
@@ -2172,6 +2261,7 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2195,6 +2285,7 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
@@ -2220,6 +2311,7 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2243,6 +2335,7 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
@@ -2268,6 +2361,7 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2291,6 +2385,7 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
@@ -2316,6 +2411,7 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2339,6 +2435,7 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
@@ -2364,6 +2461,7 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2387,6 +2485,7 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
@@ -2412,6 +2511,7 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2435,6 +2535,7 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000012Cull;
@@ -2460,6 +2561,7 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2483,6 +2585,7 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000130ull;
@@ -2508,6 +2611,7 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2531,6 +2635,7 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000134ull;
@@ -2541,6 +2646,7 @@ static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000158ull + ((offset) & 3) * 0x100000000ull;
@@ -2553,6 +2659,7 @@ static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", offset);
 	return 0x000002000000015Cull + ((offset) & 3) * 0x100000000ull;
@@ -2565,6 +2672,7 @@ static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000160ull + ((offset) & 3) * 0x100000000ull;
@@ -2577,6 +2685,7 @@ static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000164ull + ((offset) & 3) * 0x100000000ull;
@@ -2589,6 +2698,7 @@ static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000168ull + ((offset) & 3) * 0x100000000ull;
@@ -2601,6 +2711,7 @@ static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", offset);
 	return 0x000002000000016Cull + ((offset) & 3) * 0x100000000ull;
@@ -2613,6 +2724,7 @@ static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000170ull + ((offset) & 3) * 0x100000000ull;
@@ -2640,6 +2752,7 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2663,6 +2776,7 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
@@ -2688,6 +2802,7 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2711,6 +2826,7 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
@@ -2736,6 +2852,7 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2759,6 +2876,7 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
@@ -2784,6 +2902,7 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2807,6 +2926,7 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
@@ -2832,6 +2952,7 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2855,6 +2976,7 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
@@ -2880,6 +3002,7 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2903,6 +3026,7 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
@@ -2928,6 +3052,7 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2951,6 +3076,7 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
@@ -2976,6 +3102,7 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2999,6 +3126,7 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
@@ -3024,6 +3152,7 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3047,6 +3176,7 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
@@ -3072,6 +3202,7 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3095,6 +3226,7 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
@@ -3120,6 +3252,7 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3143,6 +3276,7 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
@@ -3168,6 +3302,7 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3191,6 +3326,7 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
@@ -3216,6 +3352,7 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3239,6 +3376,7 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
@@ -3264,6 +3402,7 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3287,6 +3426,7 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
@@ -3312,6 +3452,7 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3335,6 +3476,7 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
@@ -3360,6 +3502,7 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3383,6 +3526,7 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
@@ -3408,6 +3552,7 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3431,6 +3576,7 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
@@ -3456,6 +3602,7 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3479,6 +3626,7 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
@@ -3504,6 +3652,7 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3527,6 +3676,7 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
@@ -3552,6 +3702,7 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3575,6 +3726,7 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
@@ -3718,6 +3870,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3739,6 +3892,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
@@ -3764,6 +3918,7 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3787,6 +3942,7 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
@@ -3812,6 +3968,7 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3835,6 +3992,7 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
@@ -3845,6 +4003,7 @@ static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000890ull + ((offset) & 3) * 0x100000000ull;
@@ -3857,6 +4016,7 @@ static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000008A8ull + ((offset) & 3) * 0x100000000ull;
@@ -3869,6 +4029,7 @@ static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000008B8ull + ((offset) & 3) * 0x100000000ull;
@@ -3909,7 +4070,9 @@ union cvmx_pciercx_cfg000 {
 	struct cvmx_pciercx_cfg000_s          cn70xx;
 	struct cvmx_pciercx_cfg000_s          cn70xxp1;
 	struct cvmx_pciercx_cfg000_s          cn73xx;
+	struct cvmx_pciercx_cfg000_s          cn75xx;
 	struct cvmx_pciercx_cfg000_s          cn78xx;
+	struct cvmx_pciercx_cfg000_s          cn78xxp2;
 	struct cvmx_pciercx_cfg000_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg000 cvmx_pciercx_cfg000_t;
@@ -3998,7 +4161,9 @@ union cvmx_pciercx_cfg001 {
 	struct cvmx_pciercx_cfg001_s          cn70xx;
 	struct cvmx_pciercx_cfg001_s          cn70xxp1;
 	struct cvmx_pciercx_cfg001_s          cn73xx;
+	struct cvmx_pciercx_cfg001_s          cn75xx;
 	struct cvmx_pciercx_cfg001_s          cn78xx;
+	struct cvmx_pciercx_cfg001_s          cn78xxp2;
 	struct cvmx_pciercx_cfg001_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg001 cvmx_pciercx_cfg001_t;
@@ -4041,7 +4206,9 @@ union cvmx_pciercx_cfg002 {
 	struct cvmx_pciercx_cfg002_s          cn70xx;
 	struct cvmx_pciercx_cfg002_s          cn70xxp1;
 	struct cvmx_pciercx_cfg002_s          cn73xx;
+	struct cvmx_pciercx_cfg002_s          cn75xx;
 	struct cvmx_pciercx_cfg002_s          cn78xx;
+	struct cvmx_pciercx_cfg002_s          cn78xxp2;
 	struct cvmx_pciercx_cfg002_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg002 cvmx_pciercx_cfg002_t;
@@ -4091,7 +4258,9 @@ union cvmx_pciercx_cfg003 {
 	struct cvmx_pciercx_cfg003_s          cn70xx;
 	struct cvmx_pciercx_cfg003_s          cn70xxp1;
 	struct cvmx_pciercx_cfg003_s          cn73xx;
+	struct cvmx_pciercx_cfg003_s          cn75xx;
 	struct cvmx_pciercx_cfg003_s          cn78xx;
+	struct cvmx_pciercx_cfg003_s          cn78xxp2;
 	struct cvmx_pciercx_cfg003_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg003 cvmx_pciercx_cfg003_t;
@@ -4130,7 +4299,9 @@ union cvmx_pciercx_cfg004 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg004_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg004_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg004_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg004_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg004_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg004_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg004 cvmx_pciercx_cfg004_t;
@@ -4169,7 +4340,9 @@ union cvmx_pciercx_cfg005 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg005_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg005_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg005_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg005_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg005_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg005_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg005 cvmx_pciercx_cfg005_t;
@@ -4209,7 +4382,9 @@ union cvmx_pciercx_cfg006 {
 	struct cvmx_pciercx_cfg006_s          cn70xx;
 	struct cvmx_pciercx_cfg006_s          cn70xxp1;
 	struct cvmx_pciercx_cfg006_s          cn73xx;
+	struct cvmx_pciercx_cfg006_s          cn75xx;
 	struct cvmx_pciercx_cfg006_s          cn78xx;
+	struct cvmx_pciercx_cfg006_s          cn78xxp2;
 	struct cvmx_pciercx_cfg006_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg006 cvmx_pciercx_cfg006_t;
@@ -4284,7 +4459,9 @@ union cvmx_pciercx_cfg007 {
 	struct cvmx_pciercx_cfg007_s          cn70xx;
 	struct cvmx_pciercx_cfg007_s          cn70xxp1;
 	struct cvmx_pciercx_cfg007_s          cn73xx;
+	struct cvmx_pciercx_cfg007_s          cn75xx;
 	struct cvmx_pciercx_cfg007_s          cn78xx;
+	struct cvmx_pciercx_cfg007_s          cn78xxp2;
 	struct cvmx_pciercx_cfg007_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg007 cvmx_pciercx_cfg007_t;
@@ -4335,7 +4512,9 @@ union cvmx_pciercx_cfg008 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg008_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg008_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg008_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg008_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg008_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg008_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg008 cvmx_pciercx_cfg008_t;
@@ -4412,7 +4591,9 @@ union cvmx_pciercx_cfg009 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg009_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg009_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg009_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg009_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg009_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg009_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg009 cvmx_pciercx_cfg009_t;
@@ -4447,7 +4628,9 @@ union cvmx_pciercx_cfg010 {
 	struct cvmx_pciercx_cfg010_s          cn70xx;
 	struct cvmx_pciercx_cfg010_s          cn70xxp1;
 	struct cvmx_pciercx_cfg010_s          cn73xx;
+	struct cvmx_pciercx_cfg010_s          cn75xx;
 	struct cvmx_pciercx_cfg010_s          cn78xx;
+	struct cvmx_pciercx_cfg010_s          cn78xxp2;
 	struct cvmx_pciercx_cfg010_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg010 cvmx_pciercx_cfg010_t;
@@ -4482,7 +4665,9 @@ union cvmx_pciercx_cfg011 {
 	struct cvmx_pciercx_cfg011_s          cn70xx;
 	struct cvmx_pciercx_cfg011_s          cn70xxp1;
 	struct cvmx_pciercx_cfg011_s          cn73xx;
+	struct cvmx_pciercx_cfg011_s          cn75xx;
 	struct cvmx_pciercx_cfg011_s          cn78xx;
+	struct cvmx_pciercx_cfg011_s          cn78xxp2;
 	struct cvmx_pciercx_cfg011_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg011 cvmx_pciercx_cfg011_t;
@@ -4519,7 +4704,9 @@ union cvmx_pciercx_cfg012 {
 	struct cvmx_pciercx_cfg012_s          cn70xx;
 	struct cvmx_pciercx_cfg012_s          cn70xxp1;
 	struct cvmx_pciercx_cfg012_s          cn73xx;
+	struct cvmx_pciercx_cfg012_s          cn75xx;
 	struct cvmx_pciercx_cfg012_s          cn78xx;
+	struct cvmx_pciercx_cfg012_s          cn78xxp2;
 	struct cvmx_pciercx_cfg012_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg012 cvmx_pciercx_cfg012_t;
@@ -4557,7 +4744,9 @@ union cvmx_pciercx_cfg013 {
 	struct cvmx_pciercx_cfg013_s          cn70xx;
 	struct cvmx_pciercx_cfg013_s          cn70xxp1;
 	struct cvmx_pciercx_cfg013_s          cn73xx;
+	struct cvmx_pciercx_cfg013_s          cn75xx;
 	struct cvmx_pciercx_cfg013_s          cn78xx;
+	struct cvmx_pciercx_cfg013_s          cn78xxp2;
 	struct cvmx_pciercx_cfg013_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg013 cvmx_pciercx_cfg013_t;
@@ -4590,7 +4779,9 @@ union cvmx_pciercx_cfg014 {
 	struct cvmx_pciercx_cfg014_s          cn70xx;
 	struct cvmx_pciercx_cfg014_s          cn70xxp1;
 	struct cvmx_pciercx_cfg014_s          cn73xx;
+	struct cvmx_pciercx_cfg014_s          cn75xx;
 	struct cvmx_pciercx_cfg014_s          cn78xx;
+	struct cvmx_pciercx_cfg014_s          cn78xxp2;
 	struct cvmx_pciercx_cfg014_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg014 cvmx_pciercx_cfg014_t;
@@ -4719,7 +4910,9 @@ union cvmx_pciercx_cfg015 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg015_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg015_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg015_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg015_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg015_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg015_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg015 cvmx_pciercx_cfg015_t;
@@ -4787,7 +4980,9 @@ union cvmx_pciercx_cfg016 {
 	struct cvmx_pciercx_cfg016_s          cn70xx;
 	struct cvmx_pciercx_cfg016_s          cn70xxp1;
 	struct cvmx_pciercx_cfg016_s          cn73xx;
+	struct cvmx_pciercx_cfg016_s          cn75xx;
 	struct cvmx_pciercx_cfg016_s          cn78xx;
+	struct cvmx_pciercx_cfg016_s          cn78xxp2;
 	struct cvmx_pciercx_cfg016_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg016 cvmx_pciercx_cfg016_t;
@@ -4853,7 +5048,9 @@ union cvmx_pciercx_cfg017 {
 	struct cvmx_pciercx_cfg017_s          cn70xx;
 	struct cvmx_pciercx_cfg017_s          cn70xxp1;
 	struct cvmx_pciercx_cfg017_s          cn73xx;
+	struct cvmx_pciercx_cfg017_s          cn75xx;
 	struct cvmx_pciercx_cfg017_s          cn78xx;
+	struct cvmx_pciercx_cfg017_s          cn78xxp2;
 	struct cvmx_pciercx_cfg017_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg017 cvmx_pciercx_cfg017_t;
@@ -4969,7 +5166,9 @@ union cvmx_pciercx_cfg020 {
 	uint32_t reserved_25_31               : 7;
 #endif
 	} cn73xx;
+	struct cvmx_pciercx_cfg020_cn73xx     cn75xx;
 	struct cvmx_pciercx_cfg020_cn73xx     cn78xx;
+	struct cvmx_pciercx_cfg020_cn73xx     cn78xxp2;
 	struct cvmx_pciercx_cfg020_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg020 cvmx_pciercx_cfg020_t;
@@ -5004,7 +5203,9 @@ union cvmx_pciercx_cfg021 {
 	struct cvmx_pciercx_cfg021_s          cn70xx;
 	struct cvmx_pciercx_cfg021_s          cn70xxp1;
 	struct cvmx_pciercx_cfg021_s          cn73xx;
+	struct cvmx_pciercx_cfg021_s          cn75xx;
 	struct cvmx_pciercx_cfg021_s          cn78xx;
+	struct cvmx_pciercx_cfg021_s          cn78xxp2;
 	struct cvmx_pciercx_cfg021_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg021 cvmx_pciercx_cfg021_t;
@@ -5037,7 +5238,9 @@ union cvmx_pciercx_cfg022 {
 	struct cvmx_pciercx_cfg022_s          cn70xx;
 	struct cvmx_pciercx_cfg022_s          cn70xxp1;
 	struct cvmx_pciercx_cfg022_s          cn73xx;
+	struct cvmx_pciercx_cfg022_s          cn75xx;
 	struct cvmx_pciercx_cfg022_s          cn78xx;
+	struct cvmx_pciercx_cfg022_s          cn78xxp2;
 	struct cvmx_pciercx_cfg022_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg022 cvmx_pciercx_cfg022_t;
@@ -5074,7 +5277,9 @@ union cvmx_pciercx_cfg023 {
 	struct cvmx_pciercx_cfg023_s          cn70xx;
 	struct cvmx_pciercx_cfg023_s          cn70xxp1;
 	struct cvmx_pciercx_cfg023_s          cn73xx;
+	struct cvmx_pciercx_cfg023_s          cn75xx;
 	struct cvmx_pciercx_cfg023_s          cn78xx;
+	struct cvmx_pciercx_cfg023_s          cn78xxp2;
 	struct cvmx_pciercx_cfg023_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg023 cvmx_pciercx_cfg023_t;
@@ -5127,7 +5332,9 @@ union cvmx_pciercx_cfg028 {
 	struct cvmx_pciercx_cfg028_s          cn70xx;
 	struct cvmx_pciercx_cfg028_s          cn70xxp1;
 	struct cvmx_pciercx_cfg028_s          cn73xx;
+	struct cvmx_pciercx_cfg028_s          cn75xx;
 	struct cvmx_pciercx_cfg028_s          cn78xx;
+	struct cvmx_pciercx_cfg028_s          cn78xxp2;
 	struct cvmx_pciercx_cfg028_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg028 cvmx_pciercx_cfg028_t;
@@ -5193,7 +5400,9 @@ union cvmx_pciercx_cfg029 {
 	struct cvmx_pciercx_cfg029_s          cn70xx;
 	struct cvmx_pciercx_cfg029_s          cn70xxp1;
 	struct cvmx_pciercx_cfg029_s          cn73xx;
+	struct cvmx_pciercx_cfg029_s          cn75xx;
 	struct cvmx_pciercx_cfg029_s          cn78xx;
+	struct cvmx_pciercx_cfg029_s          cn78xxp2;
 	struct cvmx_pciercx_cfg029_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg029 cvmx_pciercx_cfg029_t;
@@ -5311,7 +5520,9 @@ union cvmx_pciercx_cfg030 {
 	struct cvmx_pciercx_cfg030_s          cn70xx;
 	struct cvmx_pciercx_cfg030_s          cn70xxp1;
 	struct cvmx_pciercx_cfg030_s          cn73xx;
+	struct cvmx_pciercx_cfg030_s          cn75xx;
 	struct cvmx_pciercx_cfg030_s          cn78xx;
+	struct cvmx_pciercx_cfg030_s          cn78xxp2;
 	struct cvmx_pciercx_cfg030_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg030 cvmx_pciercx_cfg030_t;
@@ -5443,7 +5654,9 @@ union cvmx_pciercx_cfg031 {
 	struct cvmx_pciercx_cfg031_s          cn70xx;
 	struct cvmx_pciercx_cfg031_s          cn70xxp1;
 	struct cvmx_pciercx_cfg031_s          cn73xx;
+	struct cvmx_pciercx_cfg031_s          cn75xx;
 	struct cvmx_pciercx_cfg031_s          cn78xx;
+	struct cvmx_pciercx_cfg031_s          cn78xxp2;
 	struct cvmx_pciercx_cfg031_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg031 cvmx_pciercx_cfg031_t;
@@ -5547,7 +5760,9 @@ union cvmx_pciercx_cfg032 {
 	struct cvmx_pciercx_cfg032_s          cn70xx;
 	struct cvmx_pciercx_cfg032_s          cn70xxp1;
 	struct cvmx_pciercx_cfg032_s          cn73xx;
+	struct cvmx_pciercx_cfg032_s          cn75xx;
 	struct cvmx_pciercx_cfg032_s          cn78xx;
+	struct cvmx_pciercx_cfg032_s          cn78xxp2;
 	struct cvmx_pciercx_cfg032_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg032 cvmx_pciercx_cfg032_t;
@@ -5612,7 +5827,9 @@ union cvmx_pciercx_cfg033 {
 	struct cvmx_pciercx_cfg033_s          cn70xx;
 	struct cvmx_pciercx_cfg033_s          cn70xxp1;
 	struct cvmx_pciercx_cfg033_s          cn73xx;
+	struct cvmx_pciercx_cfg033_s          cn75xx;
 	struct cvmx_pciercx_cfg033_s          cn78xx;
+	struct cvmx_pciercx_cfg033_s          cn78xxp2;
 	struct cvmx_pciercx_cfg033_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg033 cvmx_pciercx_cfg033_t;
@@ -5687,7 +5904,9 @@ union cvmx_pciercx_cfg034 {
 	struct cvmx_pciercx_cfg034_s          cn70xx;
 	struct cvmx_pciercx_cfg034_s          cn70xxp1;
 	struct cvmx_pciercx_cfg034_s          cn73xx;
+	struct cvmx_pciercx_cfg034_s          cn75xx;
 	struct cvmx_pciercx_cfg034_s          cn78xx;
+	struct cvmx_pciercx_cfg034_s          cn78xxp2;
 	struct cvmx_pciercx_cfg034_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg034 cvmx_pciercx_cfg034_t;
@@ -5736,7 +5955,9 @@ union cvmx_pciercx_cfg035 {
 	struct cvmx_pciercx_cfg035_s          cn70xx;
 	struct cvmx_pciercx_cfg035_s          cn70xxp1;
 	struct cvmx_pciercx_cfg035_s          cn73xx;
+	struct cvmx_pciercx_cfg035_s          cn75xx;
 	struct cvmx_pciercx_cfg035_s          cn78xx;
+	struct cvmx_pciercx_cfg035_s          cn78xxp2;
 	struct cvmx_pciercx_cfg035_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg035 cvmx_pciercx_cfg035_t;
@@ -5775,7 +5996,9 @@ union cvmx_pciercx_cfg036 {
 	struct cvmx_pciercx_cfg036_s          cn70xx;
 	struct cvmx_pciercx_cfg036_s          cn70xxp1;
 	struct cvmx_pciercx_cfg036_s          cn73xx;
+	struct cvmx_pciercx_cfg036_s          cn75xx;
 	struct cvmx_pciercx_cfg036_s          cn78xx;
+	struct cvmx_pciercx_cfg036_s          cn78xxp2;
 	struct cvmx_pciercx_cfg036_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg036 cvmx_pciercx_cfg036_t;
@@ -5970,7 +6193,9 @@ union cvmx_pciercx_cfg037 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} cn73xx;
+	struct cvmx_pciercx_cfg037_cn73xx     cn75xx;
 	struct cvmx_pciercx_cfg037_cn73xx     cn78xx;
+	struct cvmx_pciercx_cfg037_cn73xx     cn78xxp2;
 	struct cvmx_pciercx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -6129,7 +6354,9 @@ union cvmx_pciercx_cfg038 {
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xxp1;
 	struct cvmx_pciercx_cfg038_s          cn73xx;
+	struct cvmx_pciercx_cfg038_s          cn75xx;
 	struct cvmx_pciercx_cfg038_s          cn78xx;
+	struct cvmx_pciercx_cfg038_s          cn78xxp2;
 	struct cvmx_pciercx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_15_31               : 17;
@@ -6231,7 +6458,9 @@ union cvmx_pciercx_cfg039 {
 	struct cvmx_pciercx_cfg039_s          cn70xx;
 	struct cvmx_pciercx_cfg039_s          cn70xxp1;
 	struct cvmx_pciercx_cfg039_s          cn73xx;
+	struct cvmx_pciercx_cfg039_s          cn75xx;
 	struct cvmx_pciercx_cfg039_s          cn78xx;
+	struct cvmx_pciercx_cfg039_s          cn78xxp2;
 	struct cvmx_pciercx_cfg039_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg039 cvmx_pciercx_cfg039_t;
@@ -6460,7 +6689,9 @@ union cvmx_pciercx_cfg040 {
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xxp1;
 	struct cvmx_pciercx_cfg040_s          cn73xx;
+	struct cvmx_pciercx_cfg040_s          cn75xx;
 	struct cvmx_pciercx_cfg040_s          cn78xx;
+	struct cvmx_pciercx_cfg040_s          cn78xxp2;
 	struct cvmx_pciercx_cfg040_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg040 cvmx_pciercx_cfg040_t;
@@ -6493,7 +6724,9 @@ union cvmx_pciercx_cfg041 {
 	struct cvmx_pciercx_cfg041_s          cn70xx;
 	struct cvmx_pciercx_cfg041_s          cn70xxp1;
 	struct cvmx_pciercx_cfg041_s          cn73xx;
+	struct cvmx_pciercx_cfg041_s          cn75xx;
 	struct cvmx_pciercx_cfg041_s          cn78xx;
+	struct cvmx_pciercx_cfg041_s          cn78xxp2;
 	struct cvmx_pciercx_cfg041_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg041 cvmx_pciercx_cfg041_t;
@@ -6526,7 +6759,9 @@ union cvmx_pciercx_cfg042 {
 	struct cvmx_pciercx_cfg042_s          cn70xx;
 	struct cvmx_pciercx_cfg042_s          cn70xxp1;
 	struct cvmx_pciercx_cfg042_s          cn73xx;
+	struct cvmx_pciercx_cfg042_s          cn75xx;
 	struct cvmx_pciercx_cfg042_s          cn78xx;
+	struct cvmx_pciercx_cfg042_s          cn78xxp2;
 	struct cvmx_pciercx_cfg042_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg042 cvmx_pciercx_cfg042_t;
@@ -6561,7 +6796,9 @@ union cvmx_pciercx_cfg044 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg044_s          cn73xx;
+	struct cvmx_pciercx_cfg044_s          cn75xx;
 	struct cvmx_pciercx_cfg044_s          cn78xx;
+	struct cvmx_pciercx_cfg044_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg044 cvmx_pciercx_cfg044_t;
 
@@ -6587,7 +6824,9 @@ union cvmx_pciercx_cfg045 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg045_s          cn73xx;
+	struct cvmx_pciercx_cfg045_s          cn75xx;
 	struct cvmx_pciercx_cfg045_s          cn78xx;
+	struct cvmx_pciercx_cfg045_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg045 cvmx_pciercx_cfg045_t;
 
@@ -6613,7 +6852,9 @@ union cvmx_pciercx_cfg046 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg046_s          cn73xx;
+	struct cvmx_pciercx_cfg046_s          cn75xx;
 	struct cvmx_pciercx_cfg046_s          cn78xx;
+	struct cvmx_pciercx_cfg046_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg046 cvmx_pciercx_cfg046_t;
 
@@ -6649,7 +6890,9 @@ union cvmx_pciercx_cfg064 {
 	struct cvmx_pciercx_cfg064_s          cn70xx;
 	struct cvmx_pciercx_cfg064_s          cn70xxp1;
 	struct cvmx_pciercx_cfg064_s          cn73xx;
+	struct cvmx_pciercx_cfg064_s          cn75xx;
 	struct cvmx_pciercx_cfg064_s          cn78xx;
+	struct cvmx_pciercx_cfg064_s          cn78xxp2;
 	struct cvmx_pciercx_cfg064_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg064 cvmx_pciercx_cfg064_t;
@@ -6826,7 +7069,9 @@ union cvmx_pciercx_cfg065 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg065_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg065_s          cn73xx;
+	struct cvmx_pciercx_cfg065_s          cn75xx;
 	struct cvmx_pciercx_cfg065_s          cn78xx;
+	struct cvmx_pciercx_cfg065_s          cn78xxp2;
 	struct cvmx_pciercx_cfg065_cn70xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg065 cvmx_pciercx_cfg065_t;
@@ -7003,7 +7248,9 @@ union cvmx_pciercx_cfg066 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg066_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg066_s          cn73xx;
+	struct cvmx_pciercx_cfg066_s          cn75xx;
 	struct cvmx_pciercx_cfg066_s          cn78xx;
+	struct cvmx_pciercx_cfg066_s          cn78xxp2;
 	struct cvmx_pciercx_cfg066_cn70xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg066 cvmx_pciercx_cfg066_t;
@@ -7214,7 +7461,9 @@ union cvmx_pciercx_cfg067 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} cn73xx;
+	struct cvmx_pciercx_cfg067_cn73xx     cn75xx;
 	struct cvmx_pciercx_cfg067_cn73xx     cn78xx;
+	struct cvmx_pciercx_cfg067_cn73xx     cn78xxp2;
 	struct cvmx_pciercx_cfg067_cn70xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg067 cvmx_pciercx_cfg067_t;
@@ -7287,7 +7536,9 @@ union cvmx_pciercx_cfg068 {
 	struct cvmx_pciercx_cfg068_s          cn70xx;
 	struct cvmx_pciercx_cfg068_s          cn70xxp1;
 	struct cvmx_pciercx_cfg068_s          cn73xx;
+	struct cvmx_pciercx_cfg068_s          cn75xx;
 	struct cvmx_pciercx_cfg068_s          cn78xx;
+	struct cvmx_pciercx_cfg068_s          cn78xxp2;
 	struct cvmx_pciercx_cfg068_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg068 cvmx_pciercx_cfg068_t;
@@ -7360,7 +7611,9 @@ union cvmx_pciercx_cfg069 {
 	struct cvmx_pciercx_cfg069_s          cn70xx;
 	struct cvmx_pciercx_cfg069_s          cn70xxp1;
 	struct cvmx_pciercx_cfg069_s          cn73xx;
+	struct cvmx_pciercx_cfg069_s          cn75xx;
 	struct cvmx_pciercx_cfg069_s          cn78xx;
+	struct cvmx_pciercx_cfg069_s          cn78xxp2;
 	struct cvmx_pciercx_cfg069_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg069 cvmx_pciercx_cfg069_t;
@@ -7423,7 +7676,9 @@ union cvmx_pciercx_cfg070 {
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xxp1;
 	struct cvmx_pciercx_cfg070_s          cn73xx;
+	struct cvmx_pciercx_cfg070_s          cn75xx;
 	struct cvmx_pciercx_cfg070_s          cn78xx;
+	struct cvmx_pciercx_cfg070_s          cn78xxp2;
 	struct cvmx_pciercx_cfg070_cn52xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg070 cvmx_pciercx_cfg070_t;
@@ -7456,7 +7711,9 @@ union cvmx_pciercx_cfg071 {
 	struct cvmx_pciercx_cfg071_s          cn70xx;
 	struct cvmx_pciercx_cfg071_s          cn70xxp1;
 	struct cvmx_pciercx_cfg071_s          cn73xx;
+	struct cvmx_pciercx_cfg071_s          cn75xx;
 	struct cvmx_pciercx_cfg071_s          cn78xx;
+	struct cvmx_pciercx_cfg071_s          cn78xxp2;
 	struct cvmx_pciercx_cfg071_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg071 cvmx_pciercx_cfg071_t;
@@ -7489,7 +7746,9 @@ union cvmx_pciercx_cfg072 {
 	struct cvmx_pciercx_cfg072_s          cn70xx;
 	struct cvmx_pciercx_cfg072_s          cn70xxp1;
 	struct cvmx_pciercx_cfg072_s          cn73xx;
+	struct cvmx_pciercx_cfg072_s          cn75xx;
 	struct cvmx_pciercx_cfg072_s          cn78xx;
+	struct cvmx_pciercx_cfg072_s          cn78xxp2;
 	struct cvmx_pciercx_cfg072_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg072 cvmx_pciercx_cfg072_t;
@@ -7522,7 +7781,9 @@ union cvmx_pciercx_cfg073 {
 	struct cvmx_pciercx_cfg073_s          cn70xx;
 	struct cvmx_pciercx_cfg073_s          cn70xxp1;
 	struct cvmx_pciercx_cfg073_s          cn73xx;
+	struct cvmx_pciercx_cfg073_s          cn75xx;
 	struct cvmx_pciercx_cfg073_s          cn78xx;
+	struct cvmx_pciercx_cfg073_s          cn78xxp2;
 	struct cvmx_pciercx_cfg073_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg073 cvmx_pciercx_cfg073_t;
@@ -7555,7 +7816,9 @@ union cvmx_pciercx_cfg074 {
 	struct cvmx_pciercx_cfg074_s          cn70xx;
 	struct cvmx_pciercx_cfg074_s          cn70xxp1;
 	struct cvmx_pciercx_cfg074_s          cn73xx;
+	struct cvmx_pciercx_cfg074_s          cn75xx;
 	struct cvmx_pciercx_cfg074_s          cn78xx;
+	struct cvmx_pciercx_cfg074_s          cn78xxp2;
 	struct cvmx_pciercx_cfg074_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg074 cvmx_pciercx_cfg074_t;
@@ -7594,7 +7857,9 @@ union cvmx_pciercx_cfg075 {
 	struct cvmx_pciercx_cfg075_s          cn70xx;
 	struct cvmx_pciercx_cfg075_s          cn70xxp1;
 	struct cvmx_pciercx_cfg075_s          cn73xx;
+	struct cvmx_pciercx_cfg075_s          cn75xx;
 	struct cvmx_pciercx_cfg075_s          cn78xx;
+	struct cvmx_pciercx_cfg075_s          cn78xxp2;
 	struct cvmx_pciercx_cfg075_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg075 cvmx_pciercx_cfg075_t;
@@ -7644,7 +7909,9 @@ union cvmx_pciercx_cfg076 {
 	struct cvmx_pciercx_cfg076_s          cn70xx;
 	struct cvmx_pciercx_cfg076_s          cn70xxp1;
 	struct cvmx_pciercx_cfg076_s          cn73xx;
+	struct cvmx_pciercx_cfg076_s          cn75xx;
 	struct cvmx_pciercx_cfg076_s          cn78xx;
+	struct cvmx_pciercx_cfg076_s          cn78xxp2;
 	struct cvmx_pciercx_cfg076_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg076 cvmx_pciercx_cfg076_t;
@@ -7679,7 +7946,9 @@ union cvmx_pciercx_cfg077 {
 	struct cvmx_pciercx_cfg077_s          cn70xx;
 	struct cvmx_pciercx_cfg077_s          cn70xxp1;
 	struct cvmx_pciercx_cfg077_s          cn73xx;
+	struct cvmx_pciercx_cfg077_s          cn75xx;
 	struct cvmx_pciercx_cfg077_s          cn78xx;
+	struct cvmx_pciercx_cfg077_s          cn78xxp2;
 	struct cvmx_pciercx_cfg077_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg077 cvmx_pciercx_cfg077_t;
@@ -7704,7 +7973,9 @@ union cvmx_pciercx_cfg086 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg086_s          cn73xx;
+	struct cvmx_pciercx_cfg086_s          cn75xx;
 	struct cvmx_pciercx_cfg086_s          cn78xx;
+	struct cvmx_pciercx_cfg086_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg086 cvmx_pciercx_cfg086_t;
 
@@ -7728,7 +7999,9 @@ union cvmx_pciercx_cfg087 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg087_s          cn73xx;
+	struct cvmx_pciercx_cfg087_s          cn75xx;
 	struct cvmx_pciercx_cfg087_s          cn78xx;
+	struct cvmx_pciercx_cfg087_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg087 cvmx_pciercx_cfg087_t;
 
@@ -7750,7 +8023,9 @@ union cvmx_pciercx_cfg088 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg088_s          cn73xx;
+	struct cvmx_pciercx_cfg088_s          cn75xx;
 	struct cvmx_pciercx_cfg088_s          cn78xx;
+	struct cvmx_pciercx_cfg088_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg088 cvmx_pciercx_cfg088_t;
 
@@ -7800,7 +8075,9 @@ union cvmx_pciercx_cfg089 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg089_s          cn73xx;
+	struct cvmx_pciercx_cfg089_s          cn75xx;
 	struct cvmx_pciercx_cfg089_s          cn78xx;
+	struct cvmx_pciercx_cfg089_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg089 cvmx_pciercx_cfg089_t;
 
@@ -7850,7 +8127,9 @@ union cvmx_pciercx_cfg090 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg090_s          cn73xx;
+	struct cvmx_pciercx_cfg090_s          cn75xx;
 	struct cvmx_pciercx_cfg090_s          cn78xx;
+	struct cvmx_pciercx_cfg090_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg090 cvmx_pciercx_cfg090_t;
 
@@ -7900,7 +8179,9 @@ union cvmx_pciercx_cfg091 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg091_s          cn73xx;
+	struct cvmx_pciercx_cfg091_s          cn75xx;
 	struct cvmx_pciercx_cfg091_s          cn78xx;
+	struct cvmx_pciercx_cfg091_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg091 cvmx_pciercx_cfg091_t;
 
@@ -7950,7 +8231,9 @@ union cvmx_pciercx_cfg092 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg092_s          cn73xx;
+	struct cvmx_pciercx_cfg092_s          cn75xx;
 	struct cvmx_pciercx_cfg092_s          cn78xx;
+	struct cvmx_pciercx_cfg092_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg092 cvmx_pciercx_cfg092_t;
 
@@ -7998,7 +8281,9 @@ union cvmx_pciercx_cfg448 {
 	struct cvmx_pciercx_cfg448_s          cn70xx;
 	struct cvmx_pciercx_cfg448_s          cn70xxp1;
 	struct cvmx_pciercx_cfg448_s          cn73xx;
+	struct cvmx_pciercx_cfg448_s          cn75xx;
 	struct cvmx_pciercx_cfg448_s          cn78xx;
+	struct cvmx_pciercx_cfg448_s          cn78xxp2;
 	struct cvmx_pciercx_cfg448_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg448 cvmx_pciercx_cfg448_t;
@@ -8042,7 +8327,9 @@ union cvmx_pciercx_cfg449 {
 	struct cvmx_pciercx_cfg449_s          cn70xx;
 	struct cvmx_pciercx_cfg449_s          cn70xxp1;
 	struct cvmx_pciercx_cfg449_s          cn73xx;
+	struct cvmx_pciercx_cfg449_s          cn75xx;
 	struct cvmx_pciercx_cfg449_s          cn78xx;
+	struct cvmx_pciercx_cfg449_s          cn78xxp2;
 	struct cvmx_pciercx_cfg449_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg449 cvmx_pciercx_cfg449_t;
@@ -8213,7 +8500,9 @@ union cvmx_pciercx_cfg450 {
 	struct cvmx_pciercx_cfg450_s          cn70xx;
 	struct cvmx_pciercx_cfg450_s          cn70xxp1;
 	struct cvmx_pciercx_cfg450_cn52xx     cn73xx;
+	struct cvmx_pciercx_cfg450_cn52xx     cn75xx;
 	struct cvmx_pciercx_cfg450_cn52xx     cn78xx;
+	struct cvmx_pciercx_cfg450_cn52xx     cn78xxp2;
 	struct cvmx_pciercx_cfg450_cn52xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg450 cvmx_pciercx_cfg450_t;
@@ -8338,7 +8627,9 @@ union cvmx_pciercx_cfg451 {
 	struct cvmx_pciercx_cfg451_s          cn70xx;
 	struct cvmx_pciercx_cfg451_s          cn70xxp1;
 	struct cvmx_pciercx_cfg451_s          cn73xx;
+	struct cvmx_pciercx_cfg451_s          cn75xx;
 	struct cvmx_pciercx_cfg451_s          cn78xx;
+	struct cvmx_pciercx_cfg451_s          cn78xxp2;
 	struct cvmx_pciercx_cfg451_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg451 cvmx_pciercx_cfg451_t;
@@ -8612,7 +8903,9 @@ union cvmx_pciercx_cfg452 {
 	} cn70xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn70xxp1;
 	struct cvmx_pciercx_cfg452_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg452_cn70xx     cn75xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn78xx;
+	struct cvmx_pciercx_cfg452_cn70xx     cn78xxp2;
 	struct cvmx_pciercx_cfg452_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg452 cvmx_pciercx_cfg452_t;
@@ -8661,7 +8954,9 @@ union cvmx_pciercx_cfg453 {
 	struct cvmx_pciercx_cfg453_s          cn70xx;
 	struct cvmx_pciercx_cfg453_s          cn70xxp1;
 	struct cvmx_pciercx_cfg453_s          cn73xx;
+	struct cvmx_pciercx_cfg453_s          cn75xx;
 	struct cvmx_pciercx_cfg453_s          cn78xx;
+	struct cvmx_pciercx_cfg453_s          cn78xxp2;
 	struct cvmx_pciercx_cfg453_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg453 cvmx_pciercx_cfg453_t;
@@ -8804,7 +9099,9 @@ union cvmx_pciercx_cfg454 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} cn73xx;
+	struct cvmx_pciercx_cfg454_cn73xx     cn75xx;
 	struct cvmx_pciercx_cfg454_cn73xx     cn78xx;
+	struct cvmx_pciercx_cfg454_cn73xx     cn78xxp2;
 	struct cvmx_pciercx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg454 cvmx_pciercx_cfg454_t;
@@ -8874,7 +9171,9 @@ union cvmx_pciercx_cfg455 {
 	struct cvmx_pciercx_cfg455_s          cn70xx;
 	struct cvmx_pciercx_cfg455_s          cn70xxp1;
 	struct cvmx_pciercx_cfg455_s          cn73xx;
+	struct cvmx_pciercx_cfg455_s          cn75xx;
 	struct cvmx_pciercx_cfg455_s          cn78xx;
+	struct cvmx_pciercx_cfg455_s          cn78xxp2;
 	struct cvmx_pciercx_cfg455_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg455 cvmx_pciercx_cfg455_t;
@@ -8925,7 +9224,9 @@ union cvmx_pciercx_cfg456 {
 	struct cvmx_pciercx_cfg456_s          cn70xx;
 	struct cvmx_pciercx_cfg456_s          cn70xxp1;
 	struct cvmx_pciercx_cfg456_s          cn73xx;
+	struct cvmx_pciercx_cfg456_s          cn75xx;
 	struct cvmx_pciercx_cfg456_s          cn78xx;
+	struct cvmx_pciercx_cfg456_s          cn78xxp2;
 	struct cvmx_pciercx_cfg456_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg456 cvmx_pciercx_cfg456_t;
@@ -8958,7 +9259,9 @@ union cvmx_pciercx_cfg458 {
 	struct cvmx_pciercx_cfg458_s          cn70xx;
 	struct cvmx_pciercx_cfg458_s          cn70xxp1;
 	struct cvmx_pciercx_cfg458_s          cn73xx;
+	struct cvmx_pciercx_cfg458_s          cn75xx;
 	struct cvmx_pciercx_cfg458_s          cn78xx;
+	struct cvmx_pciercx_cfg458_s          cn78xxp2;
 	struct cvmx_pciercx_cfg458_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg458 cvmx_pciercx_cfg458_t;
@@ -8991,7 +9294,9 @@ union cvmx_pciercx_cfg459 {
 	struct cvmx_pciercx_cfg459_s          cn70xx;
 	struct cvmx_pciercx_cfg459_s          cn70xxp1;
 	struct cvmx_pciercx_cfg459_s          cn73xx;
+	struct cvmx_pciercx_cfg459_s          cn75xx;
 	struct cvmx_pciercx_cfg459_s          cn78xx;
+	struct cvmx_pciercx_cfg459_s          cn78xxp2;
 	struct cvmx_pciercx_cfg459_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg459 cvmx_pciercx_cfg459_t;
@@ -9032,7 +9337,9 @@ union cvmx_pciercx_cfg460 {
 	struct cvmx_pciercx_cfg460_s          cn70xx;
 	struct cvmx_pciercx_cfg460_s          cn70xxp1;
 	struct cvmx_pciercx_cfg460_s          cn73xx;
+	struct cvmx_pciercx_cfg460_s          cn75xx;
 	struct cvmx_pciercx_cfg460_s          cn78xx;
+	struct cvmx_pciercx_cfg460_s          cn78xxp2;
 	struct cvmx_pciercx_cfg460_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg460 cvmx_pciercx_cfg460_t;
@@ -9073,7 +9380,9 @@ union cvmx_pciercx_cfg461 {
 	struct cvmx_pciercx_cfg461_s          cn70xx;
 	struct cvmx_pciercx_cfg461_s          cn70xxp1;
 	struct cvmx_pciercx_cfg461_s          cn73xx;
+	struct cvmx_pciercx_cfg461_s          cn75xx;
 	struct cvmx_pciercx_cfg461_s          cn78xx;
+	struct cvmx_pciercx_cfg461_s          cn78xxp2;
 	struct cvmx_pciercx_cfg461_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg461 cvmx_pciercx_cfg461_t;
@@ -9114,7 +9423,9 @@ union cvmx_pciercx_cfg462 {
 	struct cvmx_pciercx_cfg462_s          cn70xx;
 	struct cvmx_pciercx_cfg462_s          cn70xxp1;
 	struct cvmx_pciercx_cfg462_s          cn73xx;
+	struct cvmx_pciercx_cfg462_s          cn75xx;
 	struct cvmx_pciercx_cfg462_s          cn78xx;
+	struct cvmx_pciercx_cfg462_s          cn78xxp2;
 	struct cvmx_pciercx_cfg462_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg462 cvmx_pciercx_cfg462_t;
@@ -9187,7 +9498,9 @@ union cvmx_pciercx_cfg463 {
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xxp1;
 	struct cvmx_pciercx_cfg463_s          cn73xx;
+	struct cvmx_pciercx_cfg463_s          cn75xx;
 	struct cvmx_pciercx_cfg463_s          cn78xx;
+	struct cvmx_pciercx_cfg463_s          cn78xxp2;
 	struct cvmx_pciercx_cfg463_cn52xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg463 cvmx_pciercx_cfg463_t;
@@ -9226,7 +9539,9 @@ union cvmx_pciercx_cfg464 {
 	struct cvmx_pciercx_cfg464_s          cn70xx;
 	struct cvmx_pciercx_cfg464_s          cn70xxp1;
 	struct cvmx_pciercx_cfg464_s          cn73xx;
+	struct cvmx_pciercx_cfg464_s          cn75xx;
 	struct cvmx_pciercx_cfg464_s          cn78xx;
+	struct cvmx_pciercx_cfg464_s          cn78xxp2;
 	struct cvmx_pciercx_cfg464_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg464 cvmx_pciercx_cfg464_t;
@@ -9265,7 +9580,9 @@ union cvmx_pciercx_cfg465 {
 	struct cvmx_pciercx_cfg465_s          cn70xx;
 	struct cvmx_pciercx_cfg465_s          cn70xxp1;
 	struct cvmx_pciercx_cfg465_s          cn73xx;
+	struct cvmx_pciercx_cfg465_s          cn75xx;
 	struct cvmx_pciercx_cfg465_s          cn78xx;
+	struct cvmx_pciercx_cfg465_s          cn78xxp2;
 	struct cvmx_pciercx_cfg465_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg465 cvmx_pciercx_cfg465_t;
@@ -9340,7 +9657,9 @@ union cvmx_pciercx_cfg466 {
 	struct cvmx_pciercx_cfg466_s          cn70xx;
 	struct cvmx_pciercx_cfg466_s          cn70xxp1;
 	struct cvmx_pciercx_cfg466_s          cn73xx;
+	struct cvmx_pciercx_cfg466_s          cn75xx;
 	struct cvmx_pciercx_cfg466_s          cn78xx;
+	struct cvmx_pciercx_cfg466_s          cn78xxp2;
 	struct cvmx_pciercx_cfg466_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg466 cvmx_pciercx_cfg466_t;
@@ -9397,7 +9716,9 @@ union cvmx_pciercx_cfg467 {
 	struct cvmx_pciercx_cfg467_s          cn70xx;
 	struct cvmx_pciercx_cfg467_s          cn70xxp1;
 	struct cvmx_pciercx_cfg467_s          cn73xx;
+	struct cvmx_pciercx_cfg467_s          cn75xx;
 	struct cvmx_pciercx_cfg467_s          cn78xx;
+	struct cvmx_pciercx_cfg467_s          cn78xxp2;
 	struct cvmx_pciercx_cfg467_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg467 cvmx_pciercx_cfg467_t;
@@ -9454,7 +9775,9 @@ union cvmx_pciercx_cfg468 {
 	struct cvmx_pciercx_cfg468_s          cn70xx;
 	struct cvmx_pciercx_cfg468_s          cn70xxp1;
 	struct cvmx_pciercx_cfg468_s          cn73xx;
+	struct cvmx_pciercx_cfg468_s          cn75xx;
 	struct cvmx_pciercx_cfg468_s          cn78xx;
+	struct cvmx_pciercx_cfg468_s          cn78xxp2;
 	struct cvmx_pciercx_cfg468_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg468 cvmx_pciercx_cfg468_t;
@@ -9650,7 +9973,9 @@ union cvmx_pciercx_cfg515 {
 	struct cvmx_pciercx_cfg515_s          cn70xx;
 	struct cvmx_pciercx_cfg515_s          cn70xxp1;
 	struct cvmx_pciercx_cfg515_s          cn73xx;
+	struct cvmx_pciercx_cfg515_s          cn75xx;
 	struct cvmx_pciercx_cfg515_s          cn78xx;
+	struct cvmx_pciercx_cfg515_s          cn78xxp2;
 	struct cvmx_pciercx_cfg515_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg515 cvmx_pciercx_cfg515_t;
@@ -9683,7 +10008,9 @@ union cvmx_pciercx_cfg516 {
 	struct cvmx_pciercx_cfg516_s          cn70xx;
 	struct cvmx_pciercx_cfg516_s          cn70xxp1;
 	struct cvmx_pciercx_cfg516_s          cn73xx;
+	struct cvmx_pciercx_cfg516_s          cn75xx;
 	struct cvmx_pciercx_cfg516_s          cn78xx;
+	struct cvmx_pciercx_cfg516_s          cn78xxp2;
 	struct cvmx_pciercx_cfg516_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg516 cvmx_pciercx_cfg516_t;
@@ -9716,7 +10043,9 @@ union cvmx_pciercx_cfg517 {
 	struct cvmx_pciercx_cfg517_s          cn70xx;
 	struct cvmx_pciercx_cfg517_s          cn70xxp1;
 	struct cvmx_pciercx_cfg517_s          cn73xx;
+	struct cvmx_pciercx_cfg517_s          cn75xx;
 	struct cvmx_pciercx_cfg517_s          cn78xx;
+	struct cvmx_pciercx_cfg517_s          cn78xxp2;
 	struct cvmx_pciercx_cfg517_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg517 cvmx_pciercx_cfg517_t;
@@ -9760,7 +10089,9 @@ union cvmx_pciercx_cfg548 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg548_s          cn73xx;
+	struct cvmx_pciercx_cfg548_s          cn75xx;
 	struct cvmx_pciercx_cfg548_s          cn78xx;
+	struct cvmx_pciercx_cfg548_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg548 cvmx_pciercx_cfg548_t;
 
@@ -9826,7 +10157,9 @@ union cvmx_pciercx_cfg554 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg554_s          cn73xx;
+	struct cvmx_pciercx_cfg554_s          cn75xx;
 	struct cvmx_pciercx_cfg554_s          cn78xx;
+	struct cvmx_pciercx_cfg554_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg554 cvmx_pciercx_cfg554_t;
 
@@ -9848,7 +10181,9 @@ union cvmx_pciercx_cfg558 {
 #endif
 	} s;
 	struct cvmx_pciercx_cfg558_s          cn73xx;
+	struct cvmx_pciercx_cfg558_s          cn75xx;
 	struct cvmx_pciercx_cfg558_s          cn78xx;
+	struct cvmx_pciercx_cfg558_s          cn78xxp2;
 };
 typedef union cvmx_pciercx_cfg558 cvmx_pciercx_cfg558_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 509d5e4..d79fcf0 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -70,6 +70,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if (((offset <= 15)) && ((block_id <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
@@ -91,6 +92,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) + (block_id) * 0x200000ull) * 8;
@@ -113,6 +115,7 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (offset) * 0x1000000ull;
@@ -156,6 +160,7 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -177,6 +182,7 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (offset) * 0x1000000ull;
@@ -200,6 +206,7 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -221,6 +228,7 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
@@ -268,6 +276,7 @@ static inline uint64_t CVMX_PEMX_CFG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 3) * 0x1000000ull;
@@ -285,6 +294,7 @@ static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n", offset);
@@ -303,6 +313,7 @@ static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n", offset);
@@ -317,6 +328,7 @@ static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((offset) & 3) * 0x1000000ull;
@@ -334,6 +346,7 @@ static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n", offset);
@@ -352,6 +365,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n", offset);
@@ -365,6 +379,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 3) * 0x1000000ull;
@@ -390,6 +405,7 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -411,6 +427,7 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (offset) * 0x1000000ull;
@@ -442,6 +459,7 @@ static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n", offset);
@@ -460,6 +478,7 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -475,6 +494,7 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
@@ -490,6 +510,7 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -505,12 +526,61 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_FLR_GLBLCNT_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_FLR_GLBLCNT_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000210ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_FLR_GLBLCNT_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000210ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_FLR_PF0_VF_STOPREQ(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_FLR_PF0_VF_STOPREQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000220ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_FLR_PF0_VF_STOPREQ(offset) (CVMX_ADD_IO_SEG(0x00011800C0000220ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_FLR_PF_STOPREQ(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_FLR_PF_STOPREQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000218ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_FLR_PF_STOPREQ(offset) (CVMX_ADD_IO_SEG(0x00011800C0000218ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_FLR_ZOMBIE_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_FLR_ZOMBIE_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000230ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_FLR_ZOMBIE_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000230ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
@@ -527,6 +597,7 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -547,6 +618,7 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (offset) * 0x1000000ull;
@@ -642,6 +714,7 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
 			break;
@@ -663,6 +736,7 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (offset) * 0x1000000ull;
@@ -674,6 +748,7 @@ static inline uint64_t CVMX_PEMX_ON(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 3) * 0x1000000ull;
@@ -691,6 +766,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n", offset);
@@ -709,6 +785,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n", offset);
@@ -727,6 +804,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n", offset);
@@ -743,6 +821,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000048ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -758,6 +837,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -770,6 +850,7 @@ static inline uint64_t CVMX_PEMX_QLM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 3) * 0x1000000ull;
@@ -783,6 +864,7 @@ static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((offset) & 3) * 0x1000000ull;
@@ -796,6 +878,7 @@ static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((offset) & 3) * 0x1000000ull;
@@ -809,6 +892,7 @@ static inline uint64_t CVMX_PEMX_STRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 3) * 0x1000000ull;
@@ -826,6 +910,7 @@ static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
@@ -881,7 +966,9 @@ union cvmx_pemx_bar1_indexx {
 	struct cvmx_pemx_bar1_indexx_s        cn70xx;
 	struct cvmx_pemx_bar1_indexx_s        cn70xxp1;
 	struct cvmx_pemx_bar1_indexx_s        cn73xx;
+	struct cvmx_pemx_bar1_indexx_s        cn75xx;
 	struct cvmx_pemx_bar1_indexx_s        cn78xx;
+	struct cvmx_pemx_bar1_indexx_s        cn78xxp2;
 	struct cvmx_pemx_bar1_indexx_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_bar1_indexx cvmx_pemx_bar1_indexx_t;
@@ -924,7 +1011,9 @@ union cvmx_pemx_bar2_mask {
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xxp1;
 	struct cvmx_pemx_bar2_mask_s          cn73xx;
+	struct cvmx_pemx_bar2_mask_s          cn75xx;
 	struct cvmx_pemx_bar2_mask_s          cn78xx;
+	struct cvmx_pemx_bar2_mask_s          cn78xxp2;
 	struct cvmx_pemx_bar2_mask_cn61xx     cnf71xx;
 };
 typedef union cvmx_pemx_bar2_mask cvmx_pemx_bar2_mask_t;
@@ -967,7 +1056,9 @@ union cvmx_pemx_bar_ctl {
 	struct cvmx_pemx_bar_ctl_s            cn70xx;
 	struct cvmx_pemx_bar_ctl_s            cn70xxp1;
 	struct cvmx_pemx_bar_ctl_s            cn73xx;
+	struct cvmx_pemx_bar_ctl_s            cn75xx;
 	struct cvmx_pemx_bar_ctl_s            cn78xx;
+	struct cvmx_pemx_bar_ctl_s            cn78xxp2;
 	struct cvmx_pemx_bar_ctl_s            cnf71xx;
 };
 typedef union cvmx_pemx_bar_ctl cvmx_pemx_bar_ctl_t;
@@ -982,14 +1073,13 @@ union cvmx_pemx_bist_status {
 	uint64_t u64;
 	struct cvmx_pemx_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_16_63               : 48;
 	uint64_t retryc                       : 1;  /**< Retry buffer memory C. */
-	uint64_t reserved_24_24               : 1;
+	uint64_t reserved_14_14               : 1;
 	uint64_t rqhdrb0                      : 1;  /**< Rx queue header memory buffer 0. */
 	uint64_t rqhdrb1                      : 1;  /**< Rx queue header memory buffer 1. */
 	uint64_t rqdatab0                     : 1;  /**< Rx queue data buffer 0. */
 	uint64_t rqdatab1                     : 1;  /**< Rx queue data buffer 1. */
-	uint64_t reserved_10_19               : 10;
 	uint64_t tlpn_d0                      : 1;  /**< BIST Status for the tlp_n_fifo_data0. */
 	uint64_t tlpn_d1                      : 1;  /**< BIST Status for the tlp_n_fifo_data1. */
 	uint64_t reserved_0_7                 : 8;
@@ -997,14 +1087,13 @@ union cvmx_pemx_bist_status {
 	uint64_t reserved_0_7                 : 8;
 	uint64_t tlpn_d1                      : 1;
 	uint64_t tlpn_d0                      : 1;
-	uint64_t reserved_10_19               : 10;
 	uint64_t rqdatab1                     : 1;
 	uint64_t rqdatab0                     : 1;
 	uint64_t rqhdrb1                      : 1;
 	uint64_t rqhdrb0                      : 1;
-	uint64_t reserved_24_24               : 1;
+	uint64_t reserved_14_14               : 1;
 	uint64_t retryc                       : 1;
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
 	struct cvmx_pemx_bist_status_cn61xx {
@@ -1057,14 +1146,13 @@ union cvmx_pemx_bist_status {
 	struct cvmx_pemx_bist_status_cn70xx   cn70xxp1;
 	struct cvmx_pemx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_16_63               : 48;
 	uint64_t retryc                       : 1;  /**< Retry buffer memory C. */
 	uint64_t sot                          : 1;  /**< Start of transfer memory. */
 	uint64_t rqhdrb0                      : 1;  /**< Rx queue header memory buffer 0. */
 	uint64_t rqhdrb1                      : 1;  /**< Rx queue header memory buffer 1. */
 	uint64_t rqdatab0                     : 1;  /**< Rx queue data buffer 0. */
 	uint64_t rqdatab1                     : 1;  /**< Rx queue data buffer 1. */
-	uint64_t reserved_10_19               : 10;
 	uint64_t tlpn_d0                      : 1;  /**< BIST Status for the tlp_n_fifo_data0. */
 	uint64_t tlpn_d1                      : 1;  /**< BIST Status for the tlp_n_fifo_data1. */
 	uint64_t tlpn_ctl                     : 1;  /**< BIST Status for the tlp_n_fifo_ctl. */
@@ -1086,17 +1174,18 @@ union cvmx_pemx_bist_status {
 	uint64_t tlpn_ctl                     : 1;
 	uint64_t tlpn_d1                      : 1;
 	uint64_t tlpn_d0                      : 1;
-	uint64_t reserved_10_19               : 10;
 	uint64_t rqdatab1                     : 1;
 	uint64_t rqdatab0                     : 1;
 	uint64_t rqhdrb1                      : 1;
 	uint64_t rqhdrb0                      : 1;
 	uint64_t sot                          : 1;
 	uint64_t retryc                       : 1;
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_bist_status_cn73xx   cn75xx;
 	struct cvmx_pemx_bist_status_cn73xx   cn78xx;
+	struct cvmx_pemx_bist_status_cn73xx   cn78xxp2;
 	struct cvmx_pemx_bist_status_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_bist_status cvmx_pemx_bist_status_t;
@@ -1268,8 +1357,11 @@ union cvmx_pemx_cfg {
                                                          performed to/from the SerDes. When clear, no lane swapping is performed. */
 	uint64_t lanes8                       : 1;  /**< This field enables overwriting the value for the maximum number of lanes. The reset value
                                                          is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
-                                                         PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
-                                                         maximum of 4 lanes. This value is used to set the maximum link width field in the core's
+                                                         PEM is configured for a maximum of 8 lanes when connected to a QLM. When clear, the PEM
+                                                         is configured for a maximum of 4 lanes when connected to a QLM. When the PEM is connected
+                                                         to a DLM, this field is unused, the number of lanes is 2.
+                                                         This value, along with PEM()_QLM[PEMDLMMUX], is used to set the maximum link width field
+                                                         in the core's
                                                          link capabilities register (CFG031) to indicate the maximum number of lanes
                                                          supported. Note that less lanes than the specified maximum can be configured for use via
                                                          the core's link control register (CFG032) negotiated link width field. */
@@ -1294,7 +1386,9 @@ union cvmx_pemx_cfg {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_cfg_cn73xx           cn75xx;
 	struct cvmx_pemx_cfg_cn73xx           cn78xx;
+	struct cvmx_pemx_cfg_cn73xx           cn78xxp2;
 };
 typedef union cvmx_pemx_cfg cvmx_pemx_cfg_t;
 
@@ -1325,7 +1419,9 @@ union cvmx_pemx_cfg_rd {
 	struct cvmx_pemx_cfg_rd_s             cn70xx;
 	struct cvmx_pemx_cfg_rd_s             cn70xxp1;
 	struct cvmx_pemx_cfg_rd_s             cn73xx;
+	struct cvmx_pemx_cfg_rd_s             cn75xx;
 	struct cvmx_pemx_cfg_rd_s             cn78xx;
+	struct cvmx_pemx_cfg_rd_s             cn78xxp2;
 	struct cvmx_pemx_cfg_rd_s             cnf71xx;
 };
 typedef union cvmx_pemx_cfg_rd cvmx_pemx_cfg_rd_t;
@@ -1358,7 +1454,9 @@ union cvmx_pemx_cfg_wr {
 	struct cvmx_pemx_cfg_wr_s             cn70xx;
 	struct cvmx_pemx_cfg_wr_s             cn70xxp1;
 	struct cvmx_pemx_cfg_wr_s             cn73xx;
+	struct cvmx_pemx_cfg_wr_s             cn75xx;
 	struct cvmx_pemx_cfg_wr_s             cn78xx;
+	struct cvmx_pemx_cfg_wr_s             cn78xxp2;
 	struct cvmx_pemx_cfg_wr_s             cnf71xx;
 };
 typedef union cvmx_pemx_cfg_wr cvmx_pemx_cfg_wr_t;
@@ -1385,7 +1483,9 @@ union cvmx_pemx_clk_en {
 	struct cvmx_pemx_clk_en_s             cn70xx;
 	struct cvmx_pemx_clk_en_s             cn70xxp1;
 	struct cvmx_pemx_clk_en_s             cn73xx;
+	struct cvmx_pemx_clk_en_s             cn75xx;
 	struct cvmx_pemx_clk_en_s             cn78xx;
+	struct cvmx_pemx_clk_en_s             cn78xxp2;
 };
 typedef union cvmx_pemx_clk_en cvmx_pemx_clk_en_t;
 
@@ -1423,7 +1523,9 @@ union cvmx_pemx_cpl_lut_valid {
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xx;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xxp1;
 	struct cvmx_pemx_cpl_lut_valid_s      cn73xx;
+	struct cvmx_pemx_cpl_lut_valid_s      cn75xx;
 	struct cvmx_pemx_cpl_lut_valid_s      cn78xx;
+	struct cvmx_pemx_cpl_lut_valid_s      cn78xxp2;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_cpl_lut_valid cvmx_pemx_cpl_lut_valid_t;
@@ -1618,7 +1720,9 @@ union cvmx_pemx_ctl_status {
 	uint64_t reserved_51_63               : 13;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_ctl_status_cn73xx    cn75xx;
 	struct cvmx_pemx_ctl_status_cn73xx    cn78xx;
+	struct cvmx_pemx_ctl_status_cn73xx    cn78xxp2;
 	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
@@ -1646,7 +1750,9 @@ union cvmx_pemx_ctl_status2 {
 #endif
 	} s;
 	struct cvmx_pemx_ctl_status2_s        cn73xx;
+	struct cvmx_pemx_ctl_status2_s        cn75xx;
 	struct cvmx_pemx_ctl_status2_s        cn78xx;
+	struct cvmx_pemx_ctl_status2_s        cn78xxp2;
 };
 typedef union cvmx_pemx_ctl_status2 cvmx_pemx_ctl_status2_t;
 
@@ -2196,7 +2302,9 @@ union cvmx_pemx_dbg_info {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_dbg_info_cn73xx      cn75xx;
 	struct cvmx_pemx_dbg_info_cn73xx      cn78xx;
+	struct cvmx_pemx_dbg_info_cn73xx      cn78xxp2;
 	struct cvmx_pemx_dbg_info_cn61xx      cnf71xx;
 };
 typedef union cvmx_pemx_dbg_info cvmx_pemx_dbg_info_t;
@@ -2466,7 +2574,9 @@ union cvmx_pemx_diag_status {
 	uint64_t reserved_63_9                : 55;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_diag_status_cn73xx   cn75xx;
 	struct cvmx_pemx_diag_status_cn73xx   cn78xx;
+	struct cvmx_pemx_diag_status_cn73xx   cn78xxp2;
 	struct cvmx_pemx_diag_status_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_diag_status cvmx_pemx_diag_status_t;
@@ -2555,7 +2665,9 @@ union cvmx_pemx_ecc_ena {
 	uint64_t reserved_35_63               : 29;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_ecc_ena_cn73xx       cn75xx;
 	struct cvmx_pemx_ecc_ena_cn73xx       cn78xx;
+	struct cvmx_pemx_ecc_ena_cn73xx       cn78xxp2;
 };
 typedef union cvmx_pemx_ecc_ena cvmx_pemx_ecc_ena_t;
 
@@ -2643,11 +2755,138 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn75xx;
 	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn78xx;
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn78xxp2;
 };
 typedef union cvmx_pemx_ecc_synd_ctrl cvmx_pemx_ecc_synd_ctrl_t;
 
 /**
+ * cvmx_pem#_flr_glblcnt_ctl
+ *
+ * Function Level Reset Global Counter Control.
+ *
+ */
+union cvmx_pemx_flr_glblcnt_ctl {
+	uint64_t u64;
+	struct cvmx_pemx_flr_glblcnt_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t chge                         : 1;  /**< When set, the default 25ms expiration of the Function Level Reset
+                                                         Global Counter can be changed. */
+	uint64_t inc                          : 1;  /**< When CHGE is set, this bit determines if the 25ms expiration of the Function
+                                                         Level Reset Global Counter will be increased (set) or decreased (not set). */
+	uint64_t delta                        : 2;  /**< When CHGE is set, this field determines the delta time to increase/decrease
+                                                         the 25ms expiration of the Function Level Reset Global Counter.
+                                                         0x0 = 1ms.
+                                                         0x1 = 2ms.
+                                                         0x2 = 4ms.
+                                                         0x3 = 8ms. */
+#else
+	uint64_t delta                        : 2;
+	uint64_t inc                          : 1;
+	uint64_t chge                         : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_pemx_flr_glblcnt_ctl_s    cn73xx;
+	struct cvmx_pemx_flr_glblcnt_ctl_s    cn75xx;
+};
+typedef union cvmx_pemx_flr_glblcnt_ctl cvmx_pemx_flr_glblcnt_ctl_t;
+
+/**
+ * cvmx_pem#_flr_pf0_vf_stopreq
+ *
+ * PF0 Virtual Function Level Reset Stop Outbound Requests Register.
+ * Hardware automatically sets the STOPREQ bit for the VF when it enters a
+ * Function Level Reset (FLR).  Software is responsible for clearing the STOPREQ
+ * bit but must not do so prior to hardware taking down the FLR, which could be
+ * as long as 100ms.  It may be appropriate for software to wait longer before clearing
+ * STOPREQ, software may need to drain deep DPI queues for example.
+ * Whenever PEM receives a request mastered by Octeon over S2M (i.e. P or NP),
+ * when STOPREQ is set for the function, PEM will discard the outgoing request
+ * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
+ * SWI_RSP_ERROR completion for the request - no timeout is required.
+ * Note that STOPREQ will have no effect on completions returned by Octeon over the S2M.
+ * Note that STOPREQ will have no effect on M2S traffic.
+ */
+union cvmx_pemx_flr_pf0_vf_stopreq {
+	uint64_t u64;
+	struct cvmx_pemx_flr_pf0_vf_stopreq_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t vf_stopreq                   : 64; /**< STOPREQ for the 64 VFs in PF0. */
+#else
+	uint64_t vf_stopreq                   : 64;
+#endif
+	} s;
+	struct cvmx_pemx_flr_pf0_vf_stopreq_s cn73xx;
+	struct cvmx_pemx_flr_pf0_vf_stopreq_s cn75xx;
+};
+typedef union cvmx_pemx_flr_pf0_vf_stopreq cvmx_pemx_flr_pf0_vf_stopreq_t;
+
+/**
+ * cvmx_pem#_flr_pf_stopreq
+ *
+ * PF Function Level Reset Stop Outbound Requests Register.
+ * Hardware automatically sets the STOPREQ bit for the PF when it enters a
+ * Function Level Reset (FLR).  Software is responsible for clearing the STOPREQ
+ * bit but must not do so prior to hardware taking down the FLR, which could be
+ * as long as 100ms.  It may be appropriate for software to wait longer before clearing
+ * STOPREQ, software may need to drain deep DPI queues for example.
+ * Whenever PEM receives a request mastered by Octeon over S2M (i.e. P or NP),
+ * when STOPREQ is set for the function, PEM will discard the outgoing request
+ * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
+ * SWI_RSP_ERROR completion for the request - no timeout is required.
+ * Note that STOPREQ will have no effect on completions returned by Octeon over the S2M.
+ * Note that STOPREQ will have no effect on M2S traffic.
+ */
+union cvmx_pemx_flr_pf_stopreq {
+	uint64_t u64;
+	struct cvmx_pemx_flr_pf_stopreq_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t pf0_stopreq                  : 1;  /**< PF0 STOPREQ bit. */
+#else
+	uint64_t pf0_stopreq                  : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pemx_flr_pf_stopreq_s     cn73xx;
+	struct cvmx_pemx_flr_pf_stopreq_s     cn75xx;
+};
+typedef union cvmx_pemx_flr_pf_stopreq cvmx_pemx_flr_pf_stopreq_t;
+
+/**
+ * cvmx_pem#_flr_zombie_ctl
+ *
+ * Function Level Reset Global Zombie Counter Control Register
+ *
+ */
+union cvmx_pemx_flr_zombie_ctl {
+	uint64_t u64;
+	struct cvmx_pemx_flr_zombie_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t exp                          : 10; /**< The expiration value for the inbound shared global zombie counter.  The global zombie
+                                                         counter
+                                                         continously counts the number of cycles where the PCIe Core was allowed to send
+                                                         either a Posted request or a Completion to the PEM.  When the global zombie counter
+                                                         reaches expiration (EXP), it resets to zero and all the non-zero per PCIe tag zombie
+                                                         counters are decremented.  When a per PCIe tag zombie counter decrements to zero, a
+                                                         SWI_RSP_ERROR is
+                                                         sent to the M2S bus and its associated PCIe tag is returned to the pool.
+                                                         This field allows software programmability control of the zombie counter expiration. */
+#else
+	uint64_t exp                          : 10;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_pemx_flr_zombie_ctl_s     cn73xx;
+	struct cvmx_pemx_flr_zombie_ctl_s     cn75xx;
+};
+typedef union cvmx_pemx_flr_zombie_ctl cvmx_pemx_flr_zombie_ctl_t;
+
+/**
  * cvmx_pem#_inb_read_credits
  *
  * This register contains the number of in-flight read operations from PCIe core to SLI.
@@ -2682,7 +2921,9 @@ union cvmx_pemx_inb_read_credits {
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xxp1;
 	struct cvmx_pemx_inb_read_credits_s   cn73xx;
+	struct cvmx_pemx_inb_read_credits_s   cn75xx;
 	struct cvmx_pemx_inb_read_credits_s   cn78xx;
+	struct cvmx_pemx_inb_read_credits_s   cn78xxp2;
 	struct cvmx_pemx_inb_read_credits_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_inb_read_credits cvmx_pemx_inb_read_credits_t;
@@ -2978,7 +3219,9 @@ union cvmx_pemx_int_sum {
 	uint64_t intd                         : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_int_sum_cn73xx       cn75xx;
 	struct cvmx_pemx_int_sum_cn73xx       cn78xx;
+	struct cvmx_pemx_int_sum_cn73xx       cn78xxp2;
 	struct cvmx_pemx_int_sum_cn61xx       cnf71xx;
 };
 typedef union cvmx_pemx_int_sum cvmx_pemx_int_sum_t;
@@ -3007,7 +3250,9 @@ union cvmx_pemx_on {
 	struct cvmx_pemx_on_s                 cn70xx;
 	struct cvmx_pemx_on_s                 cn70xxp1;
 	struct cvmx_pemx_on_s                 cn73xx;
+	struct cvmx_pemx_on_s                 cn75xx;
 	struct cvmx_pemx_on_s                 cn78xx;
+	struct cvmx_pemx_on_s                 cn78xxp2;
 };
 typedef union cvmx_pemx_on cvmx_pemx_on_t;
 
@@ -3052,6 +3297,7 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t addr                         : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_p2n_bar0_start_cn73xx cn75xx;
 	struct cvmx_pemx_p2n_bar0_start_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t addr                         : 49; /**< The starting address of the 32KB BAR0 address space. */
@@ -3061,6 +3307,7 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t addr                         : 49;
 #endif
 	} cn78xx;
+	struct cvmx_pemx_p2n_bar0_start_cn78xx cn78xxp2;
 	struct cvmx_pemx_p2n_bar0_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar0_start cvmx_pemx_p2n_bar0_start_t;
@@ -3092,7 +3339,9 @@ union cvmx_pemx_p2n_bar1_start {
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xxp1;
 	struct cvmx_pemx_p2n_bar1_start_s     cn73xx;
+	struct cvmx_pemx_p2n_bar1_start_s     cn75xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn78xx;
+	struct cvmx_pemx_p2n_bar1_start_s     cn78xxp2;
 	struct cvmx_pemx_p2n_bar1_start_s     cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar1_start cvmx_pemx_p2n_bar1_start_t;
@@ -3138,7 +3387,9 @@ union cvmx_pemx_p2n_bar2_start {
 	uint64_t addr                         : 19;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_p2n_bar2_start_cn73xx cn75xx;
 	struct cvmx_pemx_p2n_bar2_start_cn73xx cn78xx;
+	struct cvmx_pemx_p2n_bar2_start_cn73xx cn78xxp2;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar2_start cvmx_pemx_p2n_bar2_start_t;
@@ -3168,7 +3419,9 @@ union cvmx_pemx_p2p_barx_end {
 	struct cvmx_pemx_p2p_barx_end_s       cn68xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn68xxp1;
 	struct cvmx_pemx_p2p_barx_end_s       cn73xx;
+	struct cvmx_pemx_p2p_barx_end_s       cn75xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn78xx;
+	struct cvmx_pemx_p2p_barx_end_s       cn78xxp2;
 };
 typedef union cvmx_pemx_p2p_barx_end cvmx_pemx_p2p_barx_end_t;
 
@@ -3212,7 +3465,9 @@ union cvmx_pemx_p2p_barx_start {
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xx;
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xxp1;
 	struct cvmx_pemx_p2p_barx_start_s     cn73xx;
+	struct cvmx_pemx_p2p_barx_start_s     cn75xx;
 	struct cvmx_pemx_p2p_barx_start_s     cn78xx;
+	struct cvmx_pemx_p2p_barx_start_s     cn78xxp2;
 };
 typedef union cvmx_pemx_p2p_barx_start cvmx_pemx_p2p_barx_start_t;
 
@@ -3226,6 +3481,29 @@ union cvmx_pemx_qlm {
 	uint64_t u64;
 	struct cvmx_pemx_qlm_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_pemx_qlm_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t pemdlmsel                    : 1;  /**< When set, PEM2/PEM3 are configured to send/receive traffic to DLM5. When clear, PEM2/PEM3
+                                                         are
+                                                         configured to send/receive traffic to QLM2/QLM3. Note that this bit can only be set for
+                                                         PEM2/PEM3,
+                                                         for all other PEMs it has no function. Note that this bit must only be set when both the
+                                                         associated PHYs and PEM2/PEM3 are in reset. These conditions can be assured by setting the
+                                                         PEM(2,3)_ON[PEMON] bit after setting this bit. */
+#else
+	uint64_t pemdlmsel                    : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_qlm_cn73xx           cn75xx;
+	struct cvmx_pemx_qlm_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t pem3qlm                      : 1;  /**< When set, PEM3 is configured to send/receive traffic to QLM4. When clear, PEM3 is
                                                          configured to send/receive traffic to QLM3. Note that this bit can only be set for PEM3,
@@ -3236,9 +3514,8 @@ union cvmx_pemx_qlm {
 	uint64_t pem3qlm                      : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} s;
-	struct cvmx_pemx_qlm_s                cn73xx;
-	struct cvmx_pemx_qlm_s                cn78xx;
+	} cn78xx;
+	struct cvmx_pemx_qlm_cn78xx           cn78xxp2;
 };
 typedef union cvmx_pemx_qlm cvmx_pemx_qlm_t;
 
@@ -3269,7 +3546,9 @@ union cvmx_pemx_spi_ctl {
 	struct cvmx_pemx_spi_ctl_s            cn70xx;
 	struct cvmx_pemx_spi_ctl_s            cn70xxp1;
 	struct cvmx_pemx_spi_ctl_s            cn73xx;
+	struct cvmx_pemx_spi_ctl_s            cn75xx;
 	struct cvmx_pemx_spi_ctl_s            cn78xx;
+	struct cvmx_pemx_spi_ctl_s            cn78xxp2;
 };
 typedef union cvmx_pemx_spi_ctl cvmx_pemx_spi_ctl_t;
 
@@ -3299,7 +3578,9 @@ union cvmx_pemx_spi_data {
 	struct cvmx_pemx_spi_data_s           cn70xx;
 	struct cvmx_pemx_spi_data_s           cn70xxp1;
 	struct cvmx_pemx_spi_data_s           cn73xx;
+	struct cvmx_pemx_spi_data_s           cn75xx;
 	struct cvmx_pemx_spi_data_s           cn78xx;
+	struct cvmx_pemx_spi_data_s           cn78xxp2;
 };
 typedef union cvmx_pemx_spi_data cvmx_pemx_spi_data_t;
 
@@ -3313,7 +3594,11 @@ union cvmx_pemx_strap {
 	uint64_t u64;
 	struct cvmx_pemx_strap_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_5_63                : 59;
+	uint64_t miopem2dlm5sel               : 1;  /**< The value of the BOOT_AD[13] pin via MIO, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  Only used for PEM2.  When set, PEM2 is configured to
+                                                         DLM5 and PEM()_QLM[PEMDLMSEL] will be set, the Mac will be confifgured for 2 lanes.
+                                                         When clear, PEM2 is configured to QLM2. */
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
                                                          affected by any other reset.  When set, lane swapping is performed to/from the
                                                          SerDes. When clear, no lane swapping is performed. */
@@ -3321,7 +3606,8 @@ union cvmx_pemx_strap {
 #else
 	uint64_t reserved_0_2                 : 3;
 	uint64_t pilaneswap                   : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t miopem2dlm5sel               : 1;
+	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
 	struct cvmx_pemx_strap_cn70xx {
@@ -3338,6 +3624,34 @@ union cvmx_pemx_strap {
 	struct cvmx_pemx_strap_cn70xx         cn70xxp1;
 	struct cvmx_pemx_strap_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t miopem2dlm5sel               : 1;  /**< The value of the BOOT_AD[13] pin via MIO, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  Only used for PEM2.  When set, PEM2 is configured to
+                                                         DLM5 and PEM()_QLM[PEMDLMSEL] will be set, the Mac will be confifgured for 2 lanes.
+                                                         When clear, PEM2 is configured to QLM2. */
+	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  When set, lane swapping is performed to/from the
+                                                         SerDes. When clear, no lane swapping is performed. */
+	uint64_t pilanes8                     : 1;  /**< The value of the pi_select_8lanes pin, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  When set, the PEM is configured for a maximum of
+                                                         8-lanes, When clear, the PEM is configured for a maximum of 4-lanes. */
+	uint64_t pimode                       : 2;  /**< The value of the pi_select_mode[1:0] pins, which are captured on chip cold reset. They are
+                                                         not affected by any other reset.
+                                                         0x0 = EP mode, Gen1 speed.
+                                                         0x1 = EP mode, Gen2 speed.
+                                                         0x2 = EP mode, Gen3 speed.
+                                                         0x3 = RC mode, defaults to Gen3 speed. */
+#else
+	uint64_t pimode                       : 2;
+	uint64_t pilanes8                     : 1;
+	uint64_t pilaneswap                   : 1;
+	uint64_t miopem2dlm5sel               : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_strap_cn73xx         cn75xx;
+	struct cvmx_pemx_strap_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
                                                          affected by any other reset.  When set, lane swapping is performed to/from the
@@ -3357,8 +3671,8 @@ union cvmx_pemx_strap {
 	uint64_t pilaneswap                   : 1;
 	uint64_t reserved_4_63                : 60;
 #endif
-	} cn73xx;
-	struct cvmx_pemx_strap_cn73xx         cn78xx;
+	} cn78xx;
+	struct cvmx_pemx_strap_cn78xx         cn78xxp2;
 };
 typedef union cvmx_pemx_strap cvmx_pemx_strap_t;
 
@@ -3509,7 +3823,9 @@ union cvmx_pemx_tlp_credits {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} cn73xx;
+	struct cvmx_pemx_tlp_credits_cn73xx   cn75xx;
 	struct cvmx_pemx_tlp_credits_cn73xx   cn78xx;
+	struct cvmx_pemx_tlp_credits_cn73xx   cn78xxp2;
 	struct cvmx_pemx_tlp_credits_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_tlp_credits cvmx_pemx_tlp_credits_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index e41c877..88ab30f 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1152,7 +1152,7 @@ static inline uint64_t CVMX_PEXP_NPEI_WINDOW_CTL_FUNC(void)
 #define CVMX_PEXP_SLI_BIST_STATUS CVMX_PEXP_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
 }
@@ -1169,6 +1169,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1181,7 +1182,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_CTL_STATUS CVMX_PEXP_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
 }
@@ -1192,7 +1193,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_PEXP_SLI_DATA_OUT_CNT CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
 }
@@ -1231,6 +1232,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -1249,6 +1251,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -1267,6 +1270,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -1296,6 +1300,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1308,7 +1313,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_INT_SUM CVMX_PEXP_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010330ull);
 }
@@ -1363,7 +1368,7 @@ static inline uint64_t CVMX_PEXP_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 }
@@ -1374,7 +1379,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
 }
@@ -1385,7 +1390,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_PEXP_SLI_MEM_ACCESS_CTL CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
 }
@@ -1402,6 +1407,7 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -1458,7 +1464,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV0 CVMX_PEXP_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
 }
@@ -1469,7 +1475,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV1 CVMX_PEXP_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
 }
@@ -1480,7 +1486,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV2 CVMX_PEXP_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
 }
@@ -1491,7 +1497,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV3 CVMX_PEXP_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
 }
@@ -1502,7 +1508,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RD_MAP CVMX_PEXP_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RD_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
 }
@@ -1601,7 +1607,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_WR_MAP CVMX_PEXP_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_WR_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
 }
@@ -1612,7 +1618,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
 }
@@ -1623,7 +1629,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
 }
@@ -1634,7 +1640,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
 }
@@ -1645,7 +1651,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
 }
@@ -1662,6 +1668,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1680,6 +1687,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
@@ -1698,6 +1706,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -1716,6 +1725,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -1765,6 +1775,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
@@ -1783,6 +1794,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
@@ -1801,6 +1813,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -1819,6 +1832,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -1831,7 +1845,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 #define CVMX_PEXP_SLI_PKT_CNT_INT CVMX_PEXP_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_CNT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
 }
@@ -1919,7 +1933,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_INSTR_ENB CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011000ull);
 }
@@ -1980,6 +1994,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1992,7 +2007,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 #define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
 }
@@ -2025,7 +2040,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 }
@@ -2047,7 +2062,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011240ull);
 }
@@ -2058,7 +2073,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_ENB CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011010ull);
 }
@@ -2124,7 +2139,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_TIME_INT CVMX_PEXP_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_TIME_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
 }
@@ -2163,6 +2178,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -2175,7 +2191,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_PEXP_SLI_SCRATCH_1 CVMX_PEXP_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
 }
@@ -2186,7 +2202,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_PEXP_SLI_SCRATCH_2 CVMX_PEXP_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
 }
@@ -2197,7 +2213,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE1 CVMX_PEXP_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
 }
@@ -2208,7 +2224,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 #define CVMX_PEXP_SLI_STATE2 CVMX_PEXP_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
 }
@@ -2219,7 +2235,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE3 CVMX_PEXP_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
 }
@@ -2241,7 +2257,7 @@ static inline uint64_t CVMX_PEXP_SLI_TX_PIPE_FUNC(void)
 #define CVMX_PEXP_SLI_WINDOW_CTL CVMX_PEXP_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_WINDOW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index dcb418e..7e4e6e6 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKI_ACTIVE0 CVMX_PKI_ACTIVE0_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000220ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 #define CVMX_PKI_ACTIVE1 CVMX_PKI_ACTIVE1_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000230ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 #define CVMX_PKI_ACTIVE2 CVMX_PKI_ACTIVE2_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000240ull);
 }
@@ -90,6 +90,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044900000ull) + ((offset) & 1023) * 8;
@@ -101,7 +102,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 #define CVMX_PKI_BIST_STATUS0 CVMX_PKI_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000080ull);
 }
@@ -112,7 +113,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 #define CVMX_PKI_BIST_STATUS1 CVMX_PKI_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000088ull);
 }
@@ -123,7 +124,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 #define CVMX_PKI_BIST_STATUS2 CVMX_PKI_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000090ull);
 }
@@ -135,6 +136,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_BPIDX_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044B00000ull) + ((offset) & 1023) * 8;
@@ -146,7 +148,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 #define CVMX_PKI_BUF_CTL CVMX_PKI_BUF_CTL_FUNC()
 static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BUF_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000100ull);
 }
@@ -158,6 +160,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4095))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_PKI_CHANX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044A00000ull) + ((offset) & 4095) * 8;
@@ -169,7 +172,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 #define CVMX_PKI_CLKEN CVMX_PKI_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000410ull);
 }
@@ -181,6 +184,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((offset) & 3) * 0x10000ull;
@@ -193,6 +197,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((offset) & 3) * 0x10000ull;
@@ -205,6 +210,7 @@ static inline uint64_t CVMX_PKI_CLX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((offset) & 3) * 0x10000ull;
@@ -217,6 +223,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_ACTIONX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044708000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -229,6 +236,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_MATCHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044704000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -241,6 +249,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_TERMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044700000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -253,6 +262,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300040ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -265,6 +275,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 63)) && ((c <= 15))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_KMEMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044200000ull) + ((a) << 16) + ((b) << 8) + ((c) << 3);
@@ -277,6 +288,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_L2_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300058ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -289,6 +301,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_LG_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300060ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -301,6 +314,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_SKIP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300050ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -313,6 +327,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_STYLE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300048ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -325,6 +340,7 @@ static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2047)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 2047)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2047)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_SMEMX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044400000ull) + (((offset) & 2047) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -337,6 +353,7 @@ static inline uint64_t CVMX_PKI_CLX_START(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_START(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((offset) & 3) * 0x10000ull;
@@ -349,6 +366,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_ALG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044501000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -361,6 +379,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -373,6 +392,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500800ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -384,7 +404,8 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned l
 static inline uint64_t CVMX_PKI_DSTATX_STAT0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_DSTATX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044C00000ull) + ((offset) & 1023) * 64;
 }
@@ -395,7 +416,8 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_PKI_DSTATX_STAT1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_DSTATX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044C00008ull) + ((offset) & 1023) * 64;
 }
@@ -406,7 +428,8 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_PKI_DSTATX_STAT2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_DSTATX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044C00010ull) + ((offset) & 1023) * 64;
 }
@@ -417,7 +440,8 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_PKI_DSTATX_STAT3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_DSTATX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044C00018ull) + ((offset) & 1023) * 64;
 }
@@ -428,7 +452,8 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_PKI_DSTATX_STAT4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_DSTATX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044C00020ull) + ((offset) & 1023) * 64;
 }
@@ -439,7 +464,7 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT4(unsigned long offset)
 #define CVMX_PKI_ECC_CTL0 CVMX_PKI_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000060ull);
 }
@@ -450,7 +475,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 #define CVMX_PKI_ECC_CTL1 CVMX_PKI_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000068ull);
 }
@@ -461,7 +486,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 #define CVMX_PKI_ECC_CTL2 CVMX_PKI_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000070ull);
 }
@@ -472,7 +497,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 #define CVMX_PKI_ECC_INT0 CVMX_PKI_ECC_INT0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000040ull);
 }
@@ -483,7 +508,7 @@ static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 #define CVMX_PKI_ECC_INT1 CVMX_PKI_ECC_INT1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000048ull);
 }
@@ -494,7 +519,7 @@ static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 #define CVMX_PKI_ECC_INT2 CVMX_PKI_ECC_INT2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000050ull);
 }
@@ -506,6 +531,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_FRM_LEN_CHKX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044004000ull) + ((offset) & 1) * 8;
@@ -517,7 +543,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 #define CVMX_PKI_GBL_PEN CVMX_PKI_GBL_PEN_FUNC()
 static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GBL_PEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000200ull);
 }
@@ -528,7 +554,7 @@ static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 #define CVMX_PKI_GEN_INT CVMX_PKI_GEN_INT_FUNC()
 static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GEN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000020ull);
 }
@@ -540,6 +566,7 @@ static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_ICGX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400A000ull) + ((offset) & 3) * 8;
@@ -552,6 +579,7 @@ static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_IMEMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044100000ull) + ((offset) & 2047) * 8;
@@ -564,6 +592,7 @@ static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_LTYPEX_MAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044005000ull) + ((offset) & 31) * 8;
@@ -575,7 +604,7 @@ static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 #define CVMX_PKI_PBE_ECO CVMX_PKI_PBE_ECO_FUNC()
 static inline uint64_t CVMX_PKI_PBE_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_PKI_PBE_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000710ull);
 }
@@ -586,7 +615,7 @@ static inline uint64_t CVMX_PKI_PBE_ECO_FUNC(void)
 #define CVMX_PKI_PCAM_LOOKUP CVMX_PKI_PCAM_LOOKUP_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_LOOKUP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000500ull);
 }
@@ -597,7 +626,7 @@ static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 #define CVMX_PKI_PCAM_RESULT CVMX_PKI_PCAM_RESULT_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000510ull);
 }
@@ -608,7 +637,7 @@ static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 #define CVMX_PKI_PFE_DIAG CVMX_PKI_PFE_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PFE_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000560ull);
 }
@@ -619,7 +648,7 @@ static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 #define CVMX_PKI_PFE_ECO CVMX_PKI_PFE_ECO_FUNC()
 static inline uint64_t CVMX_PKI_PFE_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_PKI_PFE_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000720ull);
 }
@@ -630,7 +659,7 @@ static inline uint64_t CVMX_PKI_PFE_ECO_FUNC(void)
 #define CVMX_PKI_PIX_CLKEN CVMX_PKI_PIX_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000600ull);
 }
@@ -641,7 +670,7 @@ static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 #define CVMX_PKI_PIX_DIAG CVMX_PKI_PIX_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000580ull);
 }
@@ -652,7 +681,7 @@ static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 #define CVMX_PKI_PIX_ECO CVMX_PKI_PIX_ECO_FUNC()
 static inline uint64_t CVMX_PKI_PIX_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_PKI_PIX_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000700ull);
 }
@@ -664,6 +693,7 @@ static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKINDX_ICGSEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044010000ull) + ((offset) & 63) * 8;
@@ -676,6 +706,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00000ull) + ((offset) & 63) * 256;
@@ -688,6 +719,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00008ull) + ((offset) & 63) * 256;
@@ -700,6 +732,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00010ull) + ((offset) & 63) * 256;
@@ -711,7 +744,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 #define CVMX_PKI_PKT_ERR CVMX_PKI_PKT_ERR_FUNC()
 static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PKT_ERR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000030ull);
 }
@@ -719,10 +752,22 @@ static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 #define CVMX_PKI_PKT_ERR (CVMX_ADD_IO_SEG(0x0001180044000030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PTAG_AVAIL CVMX_PKI_PTAG_AVAIL_FUNC()
+static inline uint64_t CVMX_PKI_PTAG_AVAIL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_PKI_PTAG_AVAIL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000130ull);
+}
+#else
+#define CVMX_PKI_PTAG_AVAIL (CVMX_ADD_IO_SEG(0x0001180044000130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_QPG_TBLBX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_QPG_TBLBX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044820000ull) + ((offset) & 2047) * 8;
 }
@@ -734,6 +779,7 @@ static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_QPG_TBLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044800000ull) + ((offset) & 2047) * 8;
@@ -746,6 +792,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_REASM_SOPX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044006000ull) + ((offset) & 1) * 8;
@@ -757,7 +804,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 #define CVMX_PKI_REQ_WGT CVMX_PKI_REQ_WGT_FUNC()
 static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_REQ_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000120ull);
 }
@@ -768,7 +815,7 @@ static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 #define CVMX_PKI_SFT_RST CVMX_PKI_SFT_RST_FUNC()
 static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000010ull);
 }
@@ -780,6 +827,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00000ull) + ((offset) & 63) * 256;
@@ -792,6 +840,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00008ull) + ((offset) & 63) * 256;
@@ -804,6 +853,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00010ull) + ((offset) & 63) * 256;
@@ -816,6 +866,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00018ull) + ((offset) & 63) * 256;
@@ -828,6 +879,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00020ull) + ((offset) & 63) * 256;
@@ -840,6 +892,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00028ull) + ((offset) & 63) * 256;
@@ -852,6 +905,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00030ull) + ((offset) & 63) * 256;
@@ -864,6 +918,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00038ull) + ((offset) & 63) * 256;
@@ -876,6 +931,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00040ull) + ((offset) & 63) * 256;
@@ -888,6 +944,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00088ull) + ((offset) & 63) * 256;
@@ -900,6 +957,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT11(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00090ull) + ((offset) & 63) * 256;
@@ -912,6 +970,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT12(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00098ull) + ((offset) & 63) * 256;
@@ -924,6 +983,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT13(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A0ull) + ((offset) & 63) * 256;
@@ -936,6 +996,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT14(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A8ull) + ((offset) & 63) * 256;
@@ -948,6 +1009,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT15(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B0ull) + ((offset) & 63) * 256;
@@ -960,6 +1022,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT16(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B8ull) + ((offset) & 63) * 256;
@@ -972,6 +1035,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT17(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C0ull) + ((offset) & 63) * 256;
@@ -984,6 +1048,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT18(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C8ull) + ((offset) & 63) * 256;
@@ -996,6 +1061,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00048ull) + ((offset) & 63) * 256;
@@ -1008,6 +1074,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00050ull) + ((offset) & 63) * 256;
@@ -1020,6 +1087,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00058ull) + ((offset) & 63) * 256;
@@ -1032,6 +1100,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00060ull) + ((offset) & 63) * 256;
@@ -1044,6 +1113,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00068ull) + ((offset) & 63) * 256;
@@ -1056,6 +1126,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00070ull) + ((offset) & 63) * 256;
@@ -1068,6 +1139,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00078ull) + ((offset) & 63) * 256;
@@ -1080,6 +1152,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00080ull) + ((offset) & 63) * 256;
@@ -1091,7 +1164,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 #define CVMX_PKI_STAT_CTL CVMX_PKI_STAT_CTL_FUNC()
 static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_STAT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000110ull);
 }
@@ -1103,6 +1176,7 @@ static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_BUF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044024000ull) + ((offset) & 63) * 8;
@@ -1115,6 +1189,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044021000ull) + ((offset) & 63) * 8;
@@ -1127,6 +1202,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044020000ull) + ((offset) & 63) * 8;
@@ -1139,6 +1215,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044022000ull) + ((offset) & 63) * 8;
@@ -1151,6 +1228,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044023000ull) + ((offset) & 63) * 8;
@@ -1163,6 +1241,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044007000ull) + ((offset) & 31) * 8;
@@ -1175,6 +1254,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044008000ull) + ((offset) & 31) * 8;
@@ -1186,7 +1266,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 #define CVMX_PKI_TAG_SECRET CVMX_PKI_TAG_SECRET_FUNC()
 static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_TAG_SECRET not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000430ull);
 }
@@ -1197,7 +1277,7 @@ static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 #define CVMX_PKI_X2P_REQ_OFL CVMX_PKI_X2P_REQ_OFL_FUNC()
 static inline uint64_t CVMX_PKI_X2P_REQ_OFL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_X2P_REQ_OFL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000038ull);
 }
@@ -1220,7 +1300,9 @@ union cvmx_pki_active0 {
 #endif
 	} s;
 	struct cvmx_pki_active0_s             cn73xx;
+	struct cvmx_pki_active0_s             cn75xx;
 	struct cvmx_pki_active0_s             cn78xx;
+	struct cvmx_pki_active0_s             cn78xxp2;
 };
 typedef union cvmx_pki_active0 cvmx_pki_active0_t;
 
@@ -1245,7 +1327,9 @@ union cvmx_pki_active1 {
 #endif
 	} s;
 	struct cvmx_pki_active1_s             cn73xx;
+	struct cvmx_pki_active1_s             cn75xx;
 	struct cvmx_pki_active1_s             cn78xx;
+	struct cvmx_pki_active1_s             cn78xxp2;
 };
 typedef union cvmx_pki_active1 cvmx_pki_active1_t;
 
@@ -1264,7 +1348,9 @@ union cvmx_pki_active2 {
 #endif
 	} s;
 	struct cvmx_pki_active2_s             cn73xx;
+	struct cvmx_pki_active2_s             cn75xx;
 	struct cvmx_pki_active2_s             cn78xx;
+	struct cvmx_pki_active2_s             cn78xxp2;
 };
 typedef union cvmx_pki_active2 cvmx_pki_active2_t;
 
@@ -1306,7 +1392,9 @@ union cvmx_pki_aurax_cfg {
 #endif
 	} s;
 	struct cvmx_pki_aurax_cfg_s           cn73xx;
+	struct cvmx_pki_aurax_cfg_s           cn75xx;
 	struct cvmx_pki_aurax_cfg_s           cn78xx;
+	struct cvmx_pki_aurax_cfg_s           cn78xxp2;
 };
 typedef union cvmx_pki_aurax_cfg cvmx_pki_aurax_cfg_t;
 
@@ -1342,7 +1430,9 @@ union cvmx_pki_bist_status0 {
 #endif
 	} s;
 	struct cvmx_pki_bist_status0_s        cn73xx;
+	struct cvmx_pki_bist_status0_s        cn75xx;
 	struct cvmx_pki_bist_status0_s        cn78xx;
+	struct cvmx_pki_bist_status0_s        cn78xxp2;
 };
 typedef union cvmx_pki_bist_status0 cvmx_pki_bist_status0_t;
 
@@ -1359,6 +1449,11 @@ union cvmx_pki_bist_status1 {
 	uint64_t reserved_26_63               : 38;
 	uint64_t bist                         : 26; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PBE.
+                                                         <25> = DSTATS_MEM0.
+                                                         <24> = DSTATS_MEM1.
+                                                         <23> = DSTATS_MEM2.
+                                                         <22> = DSTATS_MEM3.
+                                                         <21> = DSTATS_MEM4.
                                                          <20> = STATS_MEM0.
                                                          <19> = STATS_MEM1.
                                                          <18> = STATS_MEM2.
@@ -1367,22 +1462,24 @@ union cvmx_pki_bist_status1 {
                                                          <15> = WQEOUT.
                                                          <14> = DOA.
                                                          <13> = BPID.
-                                                         <12 =10> = Reserved.
+                                                         <12:10> = Reserved.
                                                          <9> = PLC.
                                                          <8> = PKTWQ.
-                                                         <7 =6> = Reserved.
+                                                         <7:6> = Reserved.
                                                          <5> = TAG.
                                                          <4> = AURA.
                                                          <3> = CHAN.
                                                          <2> = PBTAG.
                                                          <1> = STYLEWQ.
-                                                         <0> = QPG. */
+                                                         <0> = QPG.
+                                                         Changed in pass 2. */
 #else
 	uint64_t bist                         : 26;
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
 	struct cvmx_pki_bist_status1_s        cn73xx;
+	struct cvmx_pki_bist_status1_s        cn75xx;
 	struct cvmx_pki_bist_status1_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
@@ -1411,6 +1508,7 @@ union cvmx_pki_bist_status1 {
 	uint64_t reserved_21_63               : 43;
 #endif
 	} cn78xx;
+	struct cvmx_pki_bist_status1_s        cn78xxp2;
 };
 typedef union cvmx_pki_bist_status1 cvmx_pki_bist_status1_t;
 
@@ -1446,7 +1544,9 @@ union cvmx_pki_bist_status2 {
 #endif
 	} s;
 	struct cvmx_pki_bist_status2_s        cn73xx;
+	struct cvmx_pki_bist_status2_s        cn75xx;
 	struct cvmx_pki_bist_status2_s        cn78xx;
+	struct cvmx_pki_bist_status2_s        cn78xxp2;
 };
 typedef union cvmx_pki_bist_status2 cvmx_pki_bist_status2_t;
 
@@ -1468,7 +1568,9 @@ union cvmx_pki_bpidx_state {
 #endif
 	} s;
 	struct cvmx_pki_bpidx_state_s         cn73xx;
+	struct cvmx_pki_bpidx_state_s         cn75xx;
 	struct cvmx_pki_bpidx_state_s         cn78xx;
+	struct cvmx_pki_bpidx_state_s         cn78xxp2;
 };
 typedef union cvmx_pki_bpidx_state cvmx_pki_bpidx_state_t;
 
@@ -1513,7 +1615,9 @@ union cvmx_pki_buf_ctl {
 #endif
 	} s;
 	struct cvmx_pki_buf_ctl_s             cn73xx;
+	struct cvmx_pki_buf_ctl_s             cn75xx;
 	struct cvmx_pki_buf_ctl_s             cn78xx;
+	struct cvmx_pki_buf_ctl_s             cn78xxp2;
 };
 typedef union cvmx_pki_buf_ctl cvmx_pki_buf_ctl_t;
 
@@ -1544,7 +1648,9 @@ union cvmx_pki_chanx_cfg {
 #endif
 	} s;
 	struct cvmx_pki_chanx_cfg_s           cn73xx;
+	struct cvmx_pki_chanx_cfg_s           cn75xx;
 	struct cvmx_pki_chanx_cfg_s           cn78xx;
+	struct cvmx_pki_chanx_cfg_s           cn78xxp2;
 };
 typedef union cvmx_pki_chanx_cfg cvmx_pki_chanx_cfg_t;
 
@@ -1586,7 +1692,9 @@ union cvmx_pki_clx_ecc_ctl {
 #endif
 	} s;
 	struct cvmx_pki_clx_ecc_ctl_s         cn73xx;
+	struct cvmx_pki_clx_ecc_ctl_s         cn75xx;
 	struct cvmx_pki_clx_ecc_ctl_s         cn78xx;
+	struct cvmx_pki_clx_ecc_ctl_s         cn78xxp2;
 };
 typedef union cvmx_pki_clx_ecc_ctl cvmx_pki_clx_ecc_ctl_t;
 
@@ -1621,7 +1729,9 @@ union cvmx_pki_clx_ecc_int {
 #endif
 	} s;
 	struct cvmx_pki_clx_ecc_int_s         cn73xx;
+	struct cvmx_pki_clx_ecc_int_s         cn75xx;
 	struct cvmx_pki_clx_ecc_int_s         cn78xx;
+	struct cvmx_pki_clx_ecc_int_s         cn78xxp2;
 };
 typedef union cvmx_pki_clx_ecc_int cvmx_pki_clx_ecc_int_t;
 
@@ -1651,7 +1761,9 @@ union cvmx_pki_clx_int {
 #endif
 	} s;
 	struct cvmx_pki_clx_int_s             cn73xx;
+	struct cvmx_pki_clx_int_s             cn75xx;
 	struct cvmx_pki_clx_int_s             cn78xx;
+	struct cvmx_pki_clx_int_s             cn78xxp2;
 };
 typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
 
@@ -1724,7 +1836,9 @@ union cvmx_pki_clx_pcamx_actionx {
 #endif
 	} s;
 	struct cvmx_pki_clx_pcamx_actionx_s   cn73xx;
+	struct cvmx_pki_clx_pcamx_actionx_s   cn75xx;
 	struct cvmx_pki_clx_pcamx_actionx_s   cn78xx;
+	struct cvmx_pki_clx_pcamx_actionx_s   cn78xxp2;
 };
 typedef union cvmx_pki_clx_pcamx_actionx cvmx_pki_clx_pcamx_actionx_t;
 
@@ -1750,7 +1864,9 @@ union cvmx_pki_clx_pcamx_matchx {
 #endif
 	} s;
 	struct cvmx_pki_clx_pcamx_matchx_s    cn73xx;
+	struct cvmx_pki_clx_pcamx_matchx_s    cn75xx;
 	struct cvmx_pki_clx_pcamx_matchx_s    cn78xx;
+	struct cvmx_pki_clx_pcamx_matchx_s    cn78xxp2;
 };
 typedef union cvmx_pki_clx_pcamx_matchx cvmx_pki_clx_pcamx_matchx_t;
 
@@ -1791,7 +1907,9 @@ union cvmx_pki_clx_pcamx_termx {
 #endif
 	} s;
 	struct cvmx_pki_clx_pcamx_termx_s     cn73xx;
+	struct cvmx_pki_clx_pcamx_termx_s     cn75xx;
 	struct cvmx_pki_clx_pcamx_termx_s     cn78xx;
+	struct cvmx_pki_clx_pcamx_termx_s     cn78xxp2;
 };
 typedef union cvmx_pki_clx_pcamx_termx cvmx_pki_clx_pcamx_termx_t;
 
@@ -1845,7 +1963,9 @@ union cvmx_pki_clx_pkindx_cfg {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn73xx;
+	struct cvmx_pki_clx_pkindx_cfg_s      cn75xx;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn78xx;
+	struct cvmx_pki_clx_pkindx_cfg_s      cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
 
@@ -1887,7 +2007,9 @@ union cvmx_pki_clx_pkindx_kmemx {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_kmemx_s    cn73xx;
+	struct cvmx_pki_clx_pkindx_kmemx_s    cn75xx;
 	struct cvmx_pki_clx_pkindx_kmemx_s    cn78xx;
+	struct cvmx_pki_clx_pkindx_kmemx_s    cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_kmemx cvmx_pki_clx_pkindx_kmemx_t;
 
@@ -1915,7 +2037,9 @@ union cvmx_pki_clx_pkindx_l2_custom {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_l2_custom_s cn73xx;
+	struct cvmx_pki_clx_pkindx_l2_custom_s cn75xx;
 	struct cvmx_pki_clx_pkindx_l2_custom_s cn78xx;
+	struct cvmx_pki_clx_pkindx_l2_custom_s cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_l2_custom cvmx_pki_clx_pkindx_l2_custom_t;
 
@@ -1935,7 +2059,9 @@ union cvmx_pki_clx_pkindx_lg_custom {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_lg_custom_s cn73xx;
+	struct cvmx_pki_clx_pkindx_lg_custom_s cn75xx;
 	struct cvmx_pki_clx_pkindx_lg_custom_s cn78xx;
+	struct cvmx_pki_clx_pkindx_lg_custom_s cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_lg_custom cvmx_pki_clx_pkindx_lg_custom_t;
 
@@ -1962,7 +2088,9 @@ union cvmx_pki_clx_pkindx_skip {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_skip_s     cn73xx;
+	struct cvmx_pki_clx_pkindx_skip_s     cn75xx;
 	struct cvmx_pki_clx_pkindx_skip_s     cn78xx;
+	struct cvmx_pki_clx_pkindx_skip_s     cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_skip cvmx_pki_clx_pkindx_skip_t;
 
@@ -1999,7 +2127,9 @@ union cvmx_pki_clx_pkindx_style {
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_style_s    cn73xx;
+	struct cvmx_pki_clx_pkindx_style_s    cn75xx;
 	struct cvmx_pki_clx_pkindx_style_s    cn78xx;
+	struct cvmx_pki_clx_pkindx_style_s    cn78xxp2;
 };
 typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
 
@@ -2036,7 +2166,9 @@ union cvmx_pki_clx_smemx {
 #endif
 	} s;
 	struct cvmx_pki_clx_smemx_s           cn73xx;
+	struct cvmx_pki_clx_smemx_s           cn75xx;
 	struct cvmx_pki_clx_smemx_s           cn78xx;
+	struct cvmx_pki_clx_smemx_s           cn78xxp2;
 };
 typedef union cvmx_pki_clx_smemx cvmx_pki_clx_smemx_t;
 
@@ -2055,7 +2187,9 @@ union cvmx_pki_clx_start {
 #endif
 	} s;
 	struct cvmx_pki_clx_start_s           cn73xx;
+	struct cvmx_pki_clx_start_s           cn75xx;
 	struct cvmx_pki_clx_start_s           cn78xx;
+	struct cvmx_pki_clx_start_s           cn78xxp2;
 };
 typedef union cvmx_pki_clx_start cvmx_pki_clx_start_t;
 
@@ -2117,7 +2251,9 @@ union cvmx_pki_clx_stylex_alg {
 #endif
 	} s;
 	struct cvmx_pki_clx_stylex_alg_s      cn73xx;
+	struct cvmx_pki_clx_stylex_alg_s      cn75xx;
 	struct cvmx_pki_clx_stylex_alg_s      cn78xx;
+	struct cvmx_pki_clx_stylex_alg_s      cn78xxp2;
 };
 typedef union cvmx_pki_clx_stylex_alg cvmx_pki_clx_stylex_alg_t;
 
@@ -2190,7 +2326,9 @@ union cvmx_pki_clx_stylex_cfg {
 #endif
 	} s;
 	struct cvmx_pki_clx_stylex_cfg_s      cn73xx;
+	struct cvmx_pki_clx_stylex_cfg_s      cn75xx;
 	struct cvmx_pki_clx_stylex_cfg_s      cn78xx;
+	struct cvmx_pki_clx_stylex_cfg_s      cn78xxp2;
 };
 typedef union cvmx_pki_clx_stylex_cfg cvmx_pki_clx_stylex_cfg_t;
 
@@ -2266,7 +2404,9 @@ union cvmx_pki_clx_stylex_cfg2 {
 #endif
 	} s;
 	struct cvmx_pki_clx_stylex_cfg2_s     cn73xx;
+	struct cvmx_pki_clx_stylex_cfg2_s     cn75xx;
 	struct cvmx_pki_clx_stylex_cfg2_s     cn78xx;
+	struct cvmx_pki_clx_stylex_cfg2_s     cn78xxp2;
 };
 typedef union cvmx_pki_clx_stylex_cfg2 cvmx_pki_clx_stylex_cfg2_t;
 
@@ -2287,7 +2427,9 @@ union cvmx_pki_clken {
 #endif
 	} s;
 	struct cvmx_pki_clken_s               cn73xx;
+	struct cvmx_pki_clken_s               cn75xx;
 	struct cvmx_pki_clken_s               cn78xx;
+	struct cvmx_pki_clken_s               cn78xxp2;
 };
 typedef union cvmx_pki_clken cvmx_pki_clken_t;
 
@@ -2310,6 +2452,8 @@ union cvmx_pki_dstatx_stat0 {
 #endif
 	} s;
 	struct cvmx_pki_dstatx_stat0_s        cn73xx;
+	struct cvmx_pki_dstatx_stat0_s        cn75xx;
+	struct cvmx_pki_dstatx_stat0_s        cn78xxp2;
 };
 typedef union cvmx_pki_dstatx_stat0 cvmx_pki_dstatx_stat0_t;
 
@@ -2332,6 +2476,8 @@ union cvmx_pki_dstatx_stat1 {
 #endif
 	} s;
 	struct cvmx_pki_dstatx_stat1_s        cn73xx;
+	struct cvmx_pki_dstatx_stat1_s        cn75xx;
+	struct cvmx_pki_dstatx_stat1_s        cn78xxp2;
 };
 typedef union cvmx_pki_dstatx_stat1 cvmx_pki_dstatx_stat1_t;
 
@@ -2357,6 +2503,8 @@ union cvmx_pki_dstatx_stat2 {
 #endif
 	} s;
 	struct cvmx_pki_dstatx_stat2_s        cn73xx;
+	struct cvmx_pki_dstatx_stat2_s        cn75xx;
+	struct cvmx_pki_dstatx_stat2_s        cn78xxp2;
 };
 typedef union cvmx_pki_dstatx_stat2 cvmx_pki_dstatx_stat2_t;
 
@@ -2379,6 +2527,8 @@ union cvmx_pki_dstatx_stat3 {
 #endif
 	} s;
 	struct cvmx_pki_dstatx_stat3_s        cn73xx;
+	struct cvmx_pki_dstatx_stat3_s        cn75xx;
+	struct cvmx_pki_dstatx_stat3_s        cn78xxp2;
 };
 typedef union cvmx_pki_dstatx_stat3 cvmx_pki_dstatx_stat3_t;
 
@@ -2401,6 +2551,8 @@ union cvmx_pki_dstatx_stat4 {
 #endif
 	} s;
 	struct cvmx_pki_dstatx_stat4_s        cn73xx;
+	struct cvmx_pki_dstatx_stat4_s        cn75xx;
+	struct cvmx_pki_dstatx_stat4_s        cn78xxp2;
 };
 typedef union cvmx_pki_dstatx_stat4 cvmx_pki_dstatx_stat4_t;
 
@@ -2460,7 +2612,9 @@ union cvmx_pki_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_ctl0_s            cn73xx;
+	struct cvmx_pki_ecc_ctl0_s            cn75xx;
 	struct cvmx_pki_ecc_ctl0_s            cn78xx;
+	struct cvmx_pki_ecc_ctl0_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_ctl0 cvmx_pki_ecc_ctl0_t;
 
@@ -2532,7 +2686,9 @@ union cvmx_pki_ecc_ctl1 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_ctl1_s            cn73xx;
+	struct cvmx_pki_ecc_ctl1_s            cn75xx;
 	struct cvmx_pki_ecc_ctl1_s            cn78xx;
+	struct cvmx_pki_ecc_ctl1_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_ctl1 cvmx_pki_ecc_ctl1_t;
 
@@ -2557,7 +2713,9 @@ union cvmx_pki_ecc_ctl2 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_ctl2_s            cn73xx;
+	struct cvmx_pki_ecc_ctl2_s            cn75xx;
 	struct cvmx_pki_ecc_ctl2_s            cn78xx;
+	struct cvmx_pki_ecc_ctl2_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_ctl2 cvmx_pki_ecc_ctl2_t;
 
@@ -2608,7 +2766,9 @@ union cvmx_pki_ecc_int0 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_int0_s            cn73xx;
+	struct cvmx_pki_ecc_int0_s            cn75xx;
 	struct cvmx_pki_ecc_int0_s            cn78xx;
+	struct cvmx_pki_ecc_int0_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_int0 cvmx_pki_ecc_int0_t;
 
@@ -2677,7 +2837,9 @@ union cvmx_pki_ecc_int1 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_int1_s            cn73xx;
+	struct cvmx_pki_ecc_int1_s            cn75xx;
 	struct cvmx_pki_ecc_int1_s            cn78xx;
+	struct cvmx_pki_ecc_int1_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_int1 cvmx_pki_ecc_int1_t;
 
@@ -2700,7 +2862,9 @@ union cvmx_pki_ecc_int2 {
 #endif
 	} s;
 	struct cvmx_pki_ecc_int2_s            cn73xx;
+	struct cvmx_pki_ecc_int2_s            cn75xx;
 	struct cvmx_pki_ecc_int2_s            cn78xx;
+	struct cvmx_pki_ecc_int2_s            cn78xxp2;
 };
 typedef union cvmx_pki_ecc_int2 cvmx_pki_ecc_int2_t;
 
@@ -2721,7 +2885,9 @@ union cvmx_pki_frm_len_chkx {
 #endif
 	} s;
 	struct cvmx_pki_frm_len_chkx_s        cn73xx;
+	struct cvmx_pki_frm_len_chkx_s        cn75xx;
 	struct cvmx_pki_frm_len_chkx_s        cn78xx;
+	struct cvmx_pki_frm_len_chkx_s        cn78xxp2;
 };
 typedef union cvmx_pki_frm_len_chkx cvmx_pki_frm_len_chkx_t;
 
@@ -2789,7 +2955,9 @@ union cvmx_pki_gbl_pen {
 #endif
 	} s;
 	struct cvmx_pki_gbl_pen_s             cn73xx;
+	struct cvmx_pki_gbl_pen_s             cn75xx;
 	struct cvmx_pki_gbl_pen_s             cn78xx;
+	struct cvmx_pki_gbl_pen_s             cn78xxp2;
 };
 typedef union cvmx_pki_gbl_pen cvmx_pki_gbl_pen_t;
 
@@ -2802,9 +2970,11 @@ union cvmx_pki_gen_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t bufs_oflow                   : 1;  /**< Set when PKI receives a packet that exceeds 256 buffers.
-                                                         Throws PKI_INTSN_E::PKI_GEN_BUFS_OFLOW. */
+                                                         Throws PKI_INTSN_E::PKI_GEN_BUFS_OFLOW.
+                                                         Added in pass 2. */
 	uint64_t pkt_size_oflow               : 1;  /**< Set when PKI receives a packet that exceeds 64 KB.
-                                                         Throws PKI_INTSN_E::PKI_GEN_PKT_SIZE_OFLOW. */
+                                                         Throws PKI_INTSN_E::PKI_GEN_PKT_SIZE_OFLOW.
+                                                         Added in pass 2. */
 	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
                                                          Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
 	uint64_t drp_noavail                  : 1;  /**< Set when packet dropped due to no FPA pointers available for the aura the packet
@@ -2841,6 +3011,7 @@ union cvmx_pki_gen_int {
 #endif
 	} s;
 	struct cvmx_pki_gen_int_s             cn73xx;
+	struct cvmx_pki_gen_int_s             cn75xx;
 	struct cvmx_pki_gen_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
@@ -2877,6 +3048,7 @@ union cvmx_pki_gen_int {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} cn78xx;
+	struct cvmx_pki_gen_int_s             cn78xxp2;
 };
 typedef union cvmx_pki_gen_int cvmx_pki_gen_int_t;
 
@@ -2935,7 +3107,9 @@ union cvmx_pki_icgx_cfg {
 #endif
 	} s;
 	struct cvmx_pki_icgx_cfg_s            cn73xx;
+	struct cvmx_pki_icgx_cfg_s            cn75xx;
 	struct cvmx_pki_icgx_cfg_s            cn78xx;
+	struct cvmx_pki_icgx_cfg_s            cn78xxp2;
 };
 typedef union cvmx_pki_icgx_cfg cvmx_pki_icgx_cfg_t;
 
@@ -2953,7 +3127,9 @@ union cvmx_pki_imemx {
 #endif
 	} s;
 	struct cvmx_pki_imemx_s               cn73xx;
+	struct cvmx_pki_imemx_s               cn75xx;
 	struct cvmx_pki_imemx_s               cn78xx;
+	struct cvmx_pki_imemx_s               cn78xxp2;
 };
 typedef union cvmx_pki_imemx cvmx_pki_imemx_t;
 
@@ -2974,7 +3150,9 @@ union cvmx_pki_ltypex_map {
 #endif
 	} s;
 	struct cvmx_pki_ltypex_map_s          cn73xx;
+	struct cvmx_pki_ltypex_map_s          cn75xx;
 	struct cvmx_pki_ltypex_map_s          cn78xx;
+	struct cvmx_pki_ltypex_map_s          cn78xxp2;
 };
 typedef union cvmx_pki_ltypex_map cvmx_pki_ltypex_map_t;
 
@@ -2993,6 +3171,8 @@ union cvmx_pki_pbe_eco {
 #endif
 	} s;
 	struct cvmx_pki_pbe_eco_s             cn73xx;
+	struct cvmx_pki_pbe_eco_s             cn75xx;
+	struct cvmx_pki_pbe_eco_s             cn78xxp2;
 };
 typedef union cvmx_pki_pbe_eco cvmx_pki_pbe_eco_t;
 
@@ -3024,7 +3204,9 @@ union cvmx_pki_pcam_lookup {
 #endif
 	} s;
 	struct cvmx_pki_pcam_lookup_s         cn73xx;
+	struct cvmx_pki_pcam_lookup_s         cn75xx;
 	struct cvmx_pki_pcam_lookup_s         cn78xx;
+	struct cvmx_pki_pcam_lookup_s         cn78xxp2;
 };
 typedef union cvmx_pki_pcam_lookup cvmx_pki_pcam_lookup_t;
 
@@ -3064,7 +3246,9 @@ union cvmx_pki_pcam_result {
 	uint64_t conflict                     : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pki_pcam_result_cn73xx    cn75xx;
 	struct cvmx_pki_pcam_result_cn73xx    cn78xx;
+	struct cvmx_pki_pcam_result_cn73xx    cn78xxp2;
 };
 typedef union cvmx_pki_pcam_result cvmx_pki_pcam_result_t;
 
@@ -3083,7 +3267,9 @@ union cvmx_pki_pfe_diag {
 #endif
 	} s;
 	struct cvmx_pki_pfe_diag_s            cn73xx;
+	struct cvmx_pki_pfe_diag_s            cn75xx;
 	struct cvmx_pki_pfe_diag_s            cn78xx;
+	struct cvmx_pki_pfe_diag_s            cn78xxp2;
 };
 typedef union cvmx_pki_pfe_diag cvmx_pki_pfe_diag_t;
 
@@ -3102,6 +3288,8 @@ union cvmx_pki_pfe_eco {
 #endif
 	} s;
 	struct cvmx_pki_pfe_eco_s             cn73xx;
+	struct cvmx_pki_pfe_eco_s             cn75xx;
+	struct cvmx_pki_pfe_eco_s             cn78xxp2;
 };
 typedef union cvmx_pki_pfe_eco cvmx_pki_pfe_eco_t;
 
@@ -3124,7 +3312,9 @@ union cvmx_pki_pix_clken {
 #endif
 	} s;
 	struct cvmx_pki_pix_clken_s           cn73xx;
+	struct cvmx_pki_pix_clken_s           cn75xx;
 	struct cvmx_pki_pix_clken_s           cn78xx;
+	struct cvmx_pki_pix_clken_s           cn78xxp2;
 };
 typedef union cvmx_pki_pix_clken cvmx_pki_pix_clken_t;
 
@@ -3143,7 +3333,9 @@ union cvmx_pki_pix_diag {
 #endif
 	} s;
 	struct cvmx_pki_pix_diag_s            cn73xx;
+	struct cvmx_pki_pix_diag_s            cn75xx;
 	struct cvmx_pki_pix_diag_s            cn78xx;
+	struct cvmx_pki_pix_diag_s            cn78xxp2;
 };
 typedef union cvmx_pki_pix_diag cvmx_pki_pix_diag_t;
 
@@ -3162,6 +3354,8 @@ union cvmx_pki_pix_eco {
 #endif
 	} s;
 	struct cvmx_pki_pix_eco_s             cn73xx;
+	struct cvmx_pki_pix_eco_s             cn75xx;
+	struct cvmx_pki_pix_eco_s             cn78xxp2;
 };
 typedef union cvmx_pki_pix_eco cvmx_pki_pix_eco_t;
 
@@ -3181,7 +3375,9 @@ union cvmx_pki_pkindx_icgsel {
 #endif
 	} s;
 	struct cvmx_pki_pkindx_icgsel_s       cn73xx;
+	struct cvmx_pki_pkindx_icgsel_s       cn75xx;
 	struct cvmx_pki_pkindx_icgsel_s       cn78xx;
+	struct cvmx_pki_pkindx_icgsel_s       cn78xxp2;
 };
 typedef union cvmx_pki_pkindx_icgsel cvmx_pki_pkindx_icgsel_t;
 
@@ -3203,7 +3399,9 @@ union cvmx_pki_pkndx_inb_stat0 {
 #endif
 	} s;
 	struct cvmx_pki_pkndx_inb_stat0_s     cn73xx;
+	struct cvmx_pki_pkndx_inb_stat0_s     cn75xx;
 	struct cvmx_pki_pkndx_inb_stat0_s     cn78xx;
+	struct cvmx_pki_pkndx_inb_stat0_s     cn78xxp2;
 };
 typedef union cvmx_pki_pkndx_inb_stat0 cvmx_pki_pkndx_inb_stat0_t;
 
@@ -3225,7 +3423,9 @@ union cvmx_pki_pkndx_inb_stat1 {
 #endif
 	} s;
 	struct cvmx_pki_pkndx_inb_stat1_s     cn73xx;
+	struct cvmx_pki_pkndx_inb_stat1_s     cn75xx;
 	struct cvmx_pki_pkndx_inb_stat1_s     cn78xx;
+	struct cvmx_pki_pkndx_inb_stat1_s     cn78xxp2;
 };
 typedef union cvmx_pki_pkndx_inb_stat1 cvmx_pki_pkndx_inb_stat1_t;
 
@@ -3247,7 +3447,9 @@ union cvmx_pki_pkndx_inb_stat2 {
 #endif
 	} s;
 	struct cvmx_pki_pkndx_inb_stat2_s     cn73xx;
+	struct cvmx_pki_pkndx_inb_stat2_s     cn75xx;
 	struct cvmx_pki_pkndx_inb_stat2_s     cn78xx;
+	struct cvmx_pki_pkndx_inb_stat2_s     cn78xxp2;
 };
 typedef union cvmx_pki_pkndx_inb_stat2 cvmx_pki_pkndx_inb_stat2_t;
 
@@ -3267,11 +3469,42 @@ union cvmx_pki_pkt_err {
 #endif
 	} s;
 	struct cvmx_pki_pkt_err_s             cn73xx;
+	struct cvmx_pki_pkt_err_s             cn75xx;
 	struct cvmx_pki_pkt_err_s             cn78xx;
+	struct cvmx_pki_pkt_err_s             cn78xxp2;
 };
 typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
 
 /**
+ * cvmx_pki_ptag_avail
+ *
+ * This register configures tag management. This register may only be written when
+ * PKI_BUF_CTL[PKI_EN] is clear.
+ * INTERNAL: Therefore do not put other fields into this register unless the same constraint
+ * applies.
+ */
+union cvmx_pki_ptag_avail {
+	uint64_t u64;
+	struct cvmx_pki_ptag_avail_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t avail                        : 8;  /**< Number of ptags available for use. Decreasing the number of ptags will reduce
+                                                         the number of packets waiting for parsing, which will lead to sooner
+                                                         backpressure/packet drop, but will decrease the small-packet latency of PKI by
+                                                         reducing buffer-bloat.
+                                                         This may only be written when PKI_BUF_CTL[PKI_EN] is clear. */
+#else
+	uint64_t avail                        : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_pki_ptag_avail_s          cn73xx;
+	struct cvmx_pki_ptag_avail_s          cn75xx;
+	struct cvmx_pki_ptag_avail_s          cn78xxp2;
+};
+typedef union cvmx_pki_ptag_avail cvmx_pki_ptag_avail_t;
+
+/**
  * cvmx_pki_qpg_tbl#
  *
  * The QPG table is used to indirectly calculate the Portadd/Aura/Group from the Diffsrv, HiGig
@@ -3311,7 +3544,9 @@ union cvmx_pki_qpg_tblx {
 #endif
 	} s;
 	struct cvmx_pki_qpg_tblx_s            cn73xx;
+	struct cvmx_pki_qpg_tblx_s            cn75xx;
 	struct cvmx_pki_qpg_tblx_s            cn78xx;
+	struct cvmx_pki_qpg_tblx_s            cn78xxp2;
 };
 typedef union cvmx_pki_qpg_tblx cvmx_pki_qpg_tblx_t;
 
@@ -3336,6 +3571,8 @@ union cvmx_pki_qpg_tblbx {
 #endif
 	} s;
 	struct cvmx_pki_qpg_tblbx_s           cn73xx;
+	struct cvmx_pki_qpg_tblbx_s           cn75xx;
+	struct cvmx_pki_qpg_tblbx_s           cn78xxp2;
 };
 typedef union cvmx_pki_qpg_tblbx cvmx_pki_qpg_tblbx_t;
 
@@ -3356,7 +3593,9 @@ union cvmx_pki_reasm_sopx {
 #endif
 	} s;
 	struct cvmx_pki_reasm_sopx_s          cn73xx;
+	struct cvmx_pki_reasm_sopx_s          cn75xx;
 	struct cvmx_pki_reasm_sopx_s          cn78xx;
+	struct cvmx_pki_reasm_sopx_s          cn78xxp2;
 };
 typedef union cvmx_pki_reasm_sopx cvmx_pki_reasm_sopx_t;
 
@@ -3394,7 +3633,9 @@ union cvmx_pki_req_wgt {
 #endif
 	} s;
 	struct cvmx_pki_req_wgt_s             cn73xx;
+	struct cvmx_pki_req_wgt_s             cn75xx;
 	struct cvmx_pki_req_wgt_s             cn78xx;
+	struct cvmx_pki_req_wgt_s             cn78xxp2;
 };
 typedef union cvmx_pki_req_wgt cvmx_pki_req_wgt_t;
 
@@ -3426,7 +3667,9 @@ union cvmx_pki_sft_rst {
 #endif
 	} s;
 	struct cvmx_pki_sft_rst_s             cn73xx;
+	struct cvmx_pki_sft_rst_s             cn75xx;
 	struct cvmx_pki_sft_rst_s             cn78xx;
+	struct cvmx_pki_sft_rst_s             cn78xxp2;
 };
 typedef union cvmx_pki_sft_rst cvmx_pki_sft_rst_t;
 
@@ -3446,7 +3689,9 @@ union cvmx_pki_statx_hist0 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist0_s         cn73xx;
+	struct cvmx_pki_statx_hist0_s         cn75xx;
 	struct cvmx_pki_statx_hist0_s         cn78xx;
+	struct cvmx_pki_statx_hist0_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist0 cvmx_pki_statx_hist0_t;
 
@@ -3465,7 +3710,9 @@ union cvmx_pki_statx_hist1 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist1_s         cn73xx;
+	struct cvmx_pki_statx_hist1_s         cn75xx;
 	struct cvmx_pki_statx_hist1_s         cn78xx;
+	struct cvmx_pki_statx_hist1_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist1 cvmx_pki_statx_hist1_t;
 
@@ -3484,7 +3731,9 @@ union cvmx_pki_statx_hist2 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist2_s         cn73xx;
+	struct cvmx_pki_statx_hist2_s         cn75xx;
 	struct cvmx_pki_statx_hist2_s         cn78xx;
+	struct cvmx_pki_statx_hist2_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist2 cvmx_pki_statx_hist2_t;
 
@@ -3503,7 +3752,9 @@ union cvmx_pki_statx_hist3 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist3_s         cn73xx;
+	struct cvmx_pki_statx_hist3_s         cn75xx;
 	struct cvmx_pki_statx_hist3_s         cn78xx;
+	struct cvmx_pki_statx_hist3_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist3 cvmx_pki_statx_hist3_t;
 
@@ -3522,7 +3773,9 @@ union cvmx_pki_statx_hist4 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist4_s         cn73xx;
+	struct cvmx_pki_statx_hist4_s         cn75xx;
 	struct cvmx_pki_statx_hist4_s         cn78xx;
+	struct cvmx_pki_statx_hist4_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist4 cvmx_pki_statx_hist4_t;
 
@@ -3541,7 +3794,9 @@ union cvmx_pki_statx_hist5 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist5_s         cn73xx;
+	struct cvmx_pki_statx_hist5_s         cn75xx;
 	struct cvmx_pki_statx_hist5_s         cn78xx;
+	struct cvmx_pki_statx_hist5_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist5 cvmx_pki_statx_hist5_t;
 
@@ -3560,7 +3815,9 @@ union cvmx_pki_statx_hist6 {
 #endif
 	} s;
 	struct cvmx_pki_statx_hist6_s         cn73xx;
+	struct cvmx_pki_statx_hist6_s         cn75xx;
 	struct cvmx_pki_statx_hist6_s         cn78xx;
+	struct cvmx_pki_statx_hist6_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_hist6 cvmx_pki_statx_hist6_t;
 
@@ -3579,7 +3836,9 @@ union cvmx_pki_statx_stat0 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat0_s         cn73xx;
+	struct cvmx_pki_statx_stat0_s         cn75xx;
 	struct cvmx_pki_statx_stat0_s         cn78xx;
+	struct cvmx_pki_statx_stat0_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat0 cvmx_pki_statx_stat0_t;
 
@@ -3598,7 +3857,9 @@ union cvmx_pki_statx_stat1 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat1_s         cn73xx;
+	struct cvmx_pki_statx_stat1_s         cn75xx;
 	struct cvmx_pki_statx_stat1_s         cn78xx;
+	struct cvmx_pki_statx_stat1_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat1 cvmx_pki_statx_stat1_t;
 
@@ -3617,7 +3878,9 @@ union cvmx_pki_statx_stat10 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat10_s        cn73xx;
+	struct cvmx_pki_statx_stat10_s        cn75xx;
 	struct cvmx_pki_statx_stat10_s        cn78xx;
+	struct cvmx_pki_statx_stat10_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat10 cvmx_pki_statx_stat10_t;
 
@@ -3636,7 +3899,9 @@ union cvmx_pki_statx_stat11 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat11_s        cn73xx;
+	struct cvmx_pki_statx_stat11_s        cn75xx;
 	struct cvmx_pki_statx_stat11_s        cn78xx;
+	struct cvmx_pki_statx_stat11_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat11 cvmx_pki_statx_stat11_t;
 
@@ -3656,7 +3921,9 @@ union cvmx_pki_statx_stat12 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat12_s        cn73xx;
+	struct cvmx_pki_statx_stat12_s        cn75xx;
 	struct cvmx_pki_statx_stat12_s        cn78xx;
+	struct cvmx_pki_statx_stat12_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat12 cvmx_pki_statx_stat12_t;
 
@@ -3677,7 +3944,9 @@ union cvmx_pki_statx_stat13 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat13_s        cn73xx;
+	struct cvmx_pki_statx_stat13_s        cn75xx;
 	struct cvmx_pki_statx_stat13_s        cn78xx;
+	struct cvmx_pki_statx_stat13_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat13 cvmx_pki_statx_stat13_t;
 
@@ -3697,7 +3966,9 @@ union cvmx_pki_statx_stat14 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat14_s        cn73xx;
+	struct cvmx_pki_statx_stat14_s        cn75xx;
 	struct cvmx_pki_statx_stat14_s        cn78xx;
+	struct cvmx_pki_statx_stat14_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat14 cvmx_pki_statx_stat14_t;
 
@@ -3717,7 +3988,9 @@ union cvmx_pki_statx_stat15 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat15_s        cn73xx;
+	struct cvmx_pki_statx_stat15_s        cn75xx;
 	struct cvmx_pki_statx_stat15_s        cn78xx;
+	struct cvmx_pki_statx_stat15_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat15 cvmx_pki_statx_stat15_t;
 
@@ -3737,7 +4010,9 @@ union cvmx_pki_statx_stat16 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat16_s        cn73xx;
+	struct cvmx_pki_statx_stat16_s        cn75xx;
 	struct cvmx_pki_statx_stat16_s        cn78xx;
+	struct cvmx_pki_statx_stat16_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat16 cvmx_pki_statx_stat16_t;
 
@@ -3757,7 +4032,9 @@ union cvmx_pki_statx_stat17 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat17_s        cn73xx;
+	struct cvmx_pki_statx_stat17_s        cn75xx;
 	struct cvmx_pki_statx_stat17_s        cn78xx;
+	struct cvmx_pki_statx_stat17_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat17 cvmx_pki_statx_stat17_t;
 
@@ -3777,7 +4054,9 @@ union cvmx_pki_statx_stat18 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat18_s        cn73xx;
+	struct cvmx_pki_statx_stat18_s        cn75xx;
 	struct cvmx_pki_statx_stat18_s        cn78xx;
+	struct cvmx_pki_statx_stat18_s        cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat18 cvmx_pki_statx_stat18_t;
 
@@ -3796,7 +4075,9 @@ union cvmx_pki_statx_stat2 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat2_s         cn73xx;
+	struct cvmx_pki_statx_stat2_s         cn75xx;
 	struct cvmx_pki_statx_stat2_s         cn78xx;
+	struct cvmx_pki_statx_stat2_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat2 cvmx_pki_statx_stat2_t;
 
@@ -3815,7 +4096,9 @@ union cvmx_pki_statx_stat3 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat3_s         cn73xx;
+	struct cvmx_pki_statx_stat3_s         cn75xx;
 	struct cvmx_pki_statx_stat3_s         cn78xx;
+	struct cvmx_pki_statx_stat3_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat3 cvmx_pki_statx_stat3_t;
 
@@ -3834,7 +4117,9 @@ union cvmx_pki_statx_stat4 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat4_s         cn73xx;
+	struct cvmx_pki_statx_stat4_s         cn75xx;
 	struct cvmx_pki_statx_stat4_s         cn78xx;
+	struct cvmx_pki_statx_stat4_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat4 cvmx_pki_statx_stat4_t;
 
@@ -3854,7 +4139,9 @@ union cvmx_pki_statx_stat5 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat5_s         cn73xx;
+	struct cvmx_pki_statx_stat5_s         cn75xx;
 	struct cvmx_pki_statx_stat5_s         cn78xx;
+	struct cvmx_pki_statx_stat5_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat5 cvmx_pki_statx_stat5_t;
 
@@ -3874,7 +4161,9 @@ union cvmx_pki_statx_stat6 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat6_s         cn73xx;
+	struct cvmx_pki_statx_stat6_s         cn75xx;
 	struct cvmx_pki_statx_stat6_s         cn78xx;
+	struct cvmx_pki_statx_stat6_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat6 cvmx_pki_statx_stat6_t;
 
@@ -3893,7 +4182,9 @@ union cvmx_pki_statx_stat7 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat7_s         cn73xx;
+	struct cvmx_pki_statx_stat7_s         cn75xx;
 	struct cvmx_pki_statx_stat7_s         cn78xx;
+	struct cvmx_pki_statx_stat7_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat7 cvmx_pki_statx_stat7_t;
 
@@ -3912,7 +4203,9 @@ union cvmx_pki_statx_stat8 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat8_s         cn73xx;
+	struct cvmx_pki_statx_stat8_s         cn75xx;
 	struct cvmx_pki_statx_stat8_s         cn78xx;
+	struct cvmx_pki_statx_stat8_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat8 cvmx_pki_statx_stat8_t;
 
@@ -3931,7 +4224,9 @@ union cvmx_pki_statx_stat9 {
 #endif
 	} s;
 	struct cvmx_pki_statx_stat9_s         cn73xx;
+	struct cvmx_pki_statx_stat9_s         cn75xx;
 	struct cvmx_pki_statx_stat9_s         cn78xx;
+	struct cvmx_pki_statx_stat9_s         cn78xxp2;
 };
 typedef union cvmx_pki_statx_stat9 cvmx_pki_statx_stat9_t;
 
@@ -3961,7 +4256,9 @@ union cvmx_pki_stat_ctl {
 #endif
 	} s;
 	struct cvmx_pki_stat_ctl_s            cn73xx;
+	struct cvmx_pki_stat_ctl_s            cn75xx;
 	struct cvmx_pki_stat_ctl_s            cn78xx;
+	struct cvmx_pki_stat_ctl_s            cn78xxp2;
 };
 typedef union cvmx_pki_stat_ctl cvmx_pki_stat_ctl_t;
 
@@ -4043,7 +4340,9 @@ union cvmx_pki_stylex_buf {
 #endif
 	} s;
 	struct cvmx_pki_stylex_buf_s          cn73xx;
+	struct cvmx_pki_stylex_buf_s          cn75xx;
 	struct cvmx_pki_stylex_buf_s          cn78xx;
+	struct cvmx_pki_stylex_buf_s          cn78xxp2;
 };
 typedef union cvmx_pki_stylex_buf cvmx_pki_stylex_buf_t;
 
@@ -4064,7 +4363,9 @@ union cvmx_pki_stylex_tag_mask {
 #endif
 	} s;
 	struct cvmx_pki_stylex_tag_mask_s     cn73xx;
+	struct cvmx_pki_stylex_tag_mask_s     cn75xx;
 	struct cvmx_pki_stylex_tag_mask_s     cn78xx;
+	struct cvmx_pki_stylex_tag_mask_s     cn78xxp2;
 };
 typedef union cvmx_pki_stylex_tag_mask cvmx_pki_stylex_tag_mask_t;
 
@@ -4096,7 +4397,9 @@ union cvmx_pki_stylex_tag_sel {
 #endif
 	} s;
 	struct cvmx_pki_stylex_tag_sel_s      cn73xx;
+	struct cvmx_pki_stylex_tag_sel_s      cn75xx;
 	struct cvmx_pki_stylex_tag_sel_s      cn78xx;
+	struct cvmx_pki_stylex_tag_sel_s      cn78xxp2;
 };
 typedef union cvmx_pki_stylex_tag_sel cvmx_pki_stylex_tag_sel_t;
 
@@ -4115,7 +4418,9 @@ union cvmx_pki_stylex_wq2 {
 #endif
 	} s;
 	struct cvmx_pki_stylex_wq2_s          cn73xx;
+	struct cvmx_pki_stylex_wq2_s          cn75xx;
 	struct cvmx_pki_stylex_wq2_s          cn78xx;
+	struct cvmx_pki_stylex_wq2_s          cn78xxp2;
 };
 typedef union cvmx_pki_stylex_wq2 cvmx_pki_stylex_wq2_t;
 
@@ -4134,7 +4439,9 @@ union cvmx_pki_stylex_wq4 {
 #endif
 	} s;
 	struct cvmx_pki_stylex_wq4_s          cn73xx;
+	struct cvmx_pki_stylex_wq4_s          cn75xx;
 	struct cvmx_pki_stylex_wq4_s          cn78xx;
+	struct cvmx_pki_stylex_wq4_s          cn78xxp2;
 };
 typedef union cvmx_pki_stylex_wq4 cvmx_pki_stylex_wq4_t;
 
@@ -4175,7 +4482,9 @@ union cvmx_pki_tag_incx_ctl {
 #endif
 	} s;
 	struct cvmx_pki_tag_incx_ctl_s        cn73xx;
+	struct cvmx_pki_tag_incx_ctl_s        cn75xx;
 	struct cvmx_pki_tag_incx_ctl_s        cn78xx;
+	struct cvmx_pki_tag_incx_ctl_s        cn78xxp2;
 };
 typedef union cvmx_pki_tag_incx_ctl cvmx_pki_tag_incx_ctl_t;
 
@@ -4193,7 +4502,9 @@ union cvmx_pki_tag_incx_mask {
 #endif
 	} s;
 	struct cvmx_pki_tag_incx_mask_s       cn73xx;
+	struct cvmx_pki_tag_incx_mask_s       cn75xx;
 	struct cvmx_pki_tag_incx_mask_s       cn78xx;
+	struct cvmx_pki_tag_incx_mask_s       cn78xxp2;
 };
 typedef union cvmx_pki_tag_incx_mask cvmx_pki_tag_incx_mask_t;
 
@@ -4223,7 +4534,9 @@ union cvmx_pki_tag_secret {
 #endif
 	} s;
 	struct cvmx_pki_tag_secret_s          cn73xx;
+	struct cvmx_pki_tag_secret_s          cn75xx;
 	struct cvmx_pki_tag_secret_s          cn78xx;
+	struct cvmx_pki_tag_secret_s          cn78xxp2;
 };
 typedef union cvmx_pki_tag_secret cvmx_pki_tag_secret_t;
 
@@ -4243,7 +4556,9 @@ union cvmx_pki_x2p_req_ofl {
 #endif
 	} s;
 	struct cvmx_pki_x2p_req_ofl_s         cn73xx;
+	struct cvmx_pki_x2p_req_ofl_s         cn75xx;
 	struct cvmx_pki_x2p_req_ofl_s         cn78xx;
+	struct cvmx_pki_x2p_req_ofl_s         cn78xxp2;
 };
 typedef union cvmx_pki_x2p_req_ofl cvmx_pki_x2p_req_ofl_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index 7a0fdc8..6308681 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -99,13 +99,13 @@ extern "C" {
 
 static inline unsigned cvmx_pki_num_clusters(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX))
 		return 2;
 	return 4;
 }
 static inline unsigned cvmx_pki_num_cl_grp(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX))
 		return 1;
 	return 4;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 31ee975..5b57b81 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKO_CHANNEL_LEVEL CVMX_PKO_CHANNEL_LEVEL_FUNC()
 static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_CHANNEL_LEVEL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 #define CVMX_PKO_DPFI_ENA CVMX_PKO_DPFI_ENA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_ENA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00018ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 #define CVMX_PKO_DPFI_FLUSH CVMX_PKO_DPFI_FLUSH_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FLUSH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00008ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 #define CVMX_PKO_DPFI_FPA_AURA CVMX_PKO_DPFI_FPA_AURA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FPA_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00010ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 #define CVMX_PKO_DPFI_STATUS CVMX_PKO_DPFI_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00000ull);
 }
@@ -112,6 +112,7 @@ static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D8ull) + ((offset) & 1023) * 512;
@@ -124,6 +125,7 @@ static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280018ull) + ((offset) & 1023) * 512;
@@ -136,6 +138,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C8ull) + ((offset) & 1023) * 512;
@@ -148,6 +151,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C0ull) + ((offset) & 1023) * 512;
@@ -160,6 +164,7 @@ static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_FIFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300078ull) + ((offset) & 1023) * 512;
@@ -172,6 +177,7 @@ static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D0ull) + ((offset) & 1023) * 512;
@@ -184,6 +190,7 @@ static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300070ull) + ((offset) & 1023) * 512;
@@ -196,6 +203,7 @@ static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280020ull) + ((offset) & 1023) * 512;
@@ -208,6 +216,7 @@ static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280078ull) + ((offset) & 1023) * 512;
@@ -220,6 +229,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280008ull) + ((offset) & 1023) * 512;
@@ -232,6 +242,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280028ull) + ((offset) & 1023) * 512;
@@ -244,6 +255,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280010ull) + ((offset) & 1023) * 512;
@@ -256,6 +268,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280030ull) + ((offset) & 1023) * 512;
@@ -268,6 +281,7 @@ static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400002800E0ull) + ((offset) & 1023) * 512;
@@ -280,6 +294,7 @@ static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300000ull) + ((offset) & 1023) * 512;
@@ -292,6 +307,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000E8ull) + ((offset) & 1023) * 512;
@@ -304,6 +320,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F0ull) + ((offset) & 1023) * 512;
@@ -316,6 +333,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F8ull) + ((offset) & 1023) * 512;
@@ -328,6 +346,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000050ull) + ((offset) & 1023) * 512;
@@ -340,6 +359,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000040ull) + ((offset) & 1023) * 512;
@@ -352,6 +372,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000048ull) + ((offset) & 1023) * 512;
@@ -363,7 +384,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 #define CVMX_PKO_DQ_CSR_BUS_DEBUG CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400003001F8ull);
 }
@@ -374,7 +395,7 @@ static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_DQ_DEBUG CVMX_PKO_DQ_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300128ull);
 }
@@ -385,7 +406,7 @@ static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 #define CVMX_PKO_DRAIN_IRQ CVMX_PKO_DRAIN_IRQ_FUNC()
 static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DRAIN_IRQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000140ull);
 }
@@ -396,7 +417,7 @@ static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 #define CVMX_PKO_ENABLE CVMX_PKO_ENABLE_FUNC()
 static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00008ull);
 }
@@ -408,6 +429,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PKO_FORMATX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900800ull) + ((offset) & 127) * 8;
@@ -419,7 +441,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 #define CVMX_PKO_L1_SQA_DEBUG CVMX_PKO_L1_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080128ull);
 }
@@ -430,7 +452,7 @@ static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L1_SQB_DEBUG CVMX_PKO_L1_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080130ull);
 }
@@ -442,6 +464,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000018ull) + ((offset) & 31) * 512;
@@ -454,6 +477,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000088ull) + ((offset) & 31) * 512;
@@ -466,6 +490,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000080ull) + ((offset) & 31) * 512;
@@ -478,6 +503,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080058ull) + ((offset) & 31) * 512;
@@ -490,6 +516,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B8ull) + ((offset) & 31) * 512;
@@ -502,6 +529,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B0ull) + ((offset) & 31) * 512;
@@ -514,6 +542,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000038ull) + ((offset) & 31) * 512;
@@ -526,6 +555,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080070ull) + ((offset) & 31) * 512;
@@ -538,6 +568,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080068ull) + ((offset) & 31) * 512;
@@ -550,6 +581,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000098ull) + ((offset) & 31) * 512;
@@ -562,6 +594,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000090ull) + ((offset) & 31) * 512;
@@ -574,6 +607,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000008ull) + ((offset) & 31) * 512;
@@ -586,6 +620,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000010ull) + ((offset) & 31) * 512;
@@ -598,6 +633,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000030ull) + ((offset) & 31) * 512;
@@ -610,6 +646,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000E0ull) + ((offset) & 31) * 512;
@@ -622,6 +659,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080000ull) + ((offset) & 31) * 512;
@@ -634,6 +672,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080060ull) + ((offset) & 31) * 512;
@@ -646,6 +685,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A8ull) + ((offset) & 31) * 512;
@@ -658,6 +698,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A0ull) + ((offset) & 31) * 512;
@@ -669,7 +710,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 #define CVMX_PKO_L1_SQ_CSR_BUS_DEBUG CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000801F8ull);
 }
@@ -680,7 +721,7 @@ static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQA_DEBUG CVMX_PKO_L2_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100128ull);
 }
@@ -691,7 +732,7 @@ static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQB_DEBUG CVMX_PKO_L2_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100130ull);
 }
@@ -703,6 +744,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080018ull) + ((offset) & 511) * 512;
@@ -715,6 +757,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100058ull) + ((offset) & 511) * 512;
@@ -727,6 +770,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100070ull) + ((offset) & 511) * 512;
@@ -739,6 +783,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080020ull) + ((offset) & 511) * 512;
@@ -751,6 +796,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080078ull) + ((offset) & 511) * 512;
@@ -763,6 +809,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100068ull) + ((offset) & 511) * 512;
@@ -775,6 +822,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080008ull) + ((offset) & 511) * 512;
@@ -787,6 +835,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080028ull) + ((offset) & 511) * 512;
@@ -799,6 +848,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080010ull) + ((offset) & 511) * 512;
@@ -811,6 +861,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080030ull) + ((offset) & 511) * 512;
@@ -823,6 +874,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000800E0ull) + ((offset) & 511) * 512;
@@ -835,6 +887,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100000ull) + ((offset) & 511) * 512;
@@ -847,6 +900,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100060ull) + ((offset) & 511) * 512;
@@ -858,7 +912,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L2_SQ_CSR_BUS_DEBUG CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001001F8ull);
 }
@@ -870,6 +924,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_L2_SQX_CHANNEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080038ull) + ((offset) & 511) * 512;
@@ -881,7 +936,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 #define CVMX_PKO_L3_SQA_DEBUG CVMX_PKO_L3_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180128ull);
 }
@@ -892,7 +947,7 @@ static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L3_SQB_DEBUG CVMX_PKO_L3_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180130ull);
 }
@@ -904,6 +959,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100018ull) + ((offset) & 511) * 512;
@@ -916,6 +972,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180058ull) + ((offset) & 511) * 512;
@@ -928,6 +985,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180070ull) + ((offset) & 511) * 512;
@@ -940,6 +998,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100020ull) + ((offset) & 511) * 512;
@@ -952,6 +1011,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100078ull) + ((offset) & 511) * 512;
@@ -964,6 +1024,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180068ull) + ((offset) & 511) * 512;
@@ -976,6 +1037,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100008ull) + ((offset) & 511) * 512;
@@ -988,6 +1050,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100028ull) + ((offset) & 511) * 512;
@@ -1000,6 +1063,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100010ull) + ((offset) & 511) * 512;
@@ -1012,6 +1076,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100030ull) + ((offset) & 511) * 512;
@@ -1024,6 +1089,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400001000E0ull) + ((offset) & 511) * 512;
@@ -1036,6 +1102,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180000ull) + ((offset) & 511) * 512;
@@ -1048,6 +1115,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180060ull) + ((offset) & 511) * 512;
@@ -1059,7 +1127,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L3_SQ_CSR_BUS_DEBUG CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001801F8ull);
 }
@@ -1423,6 +1491,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 383))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 383))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_LUTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000B00000ull) + ((offset) & 1023) * 8;
@@ -1434,7 +1503,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 #define CVMX_PKO_LUT_BIST_STATUS CVMX_PKO_LUT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000B02018ull);
 }
@@ -1445,7 +1514,7 @@ static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_LUT_ECC_CTL0 CVMX_PKO_LUT_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD0ull);
 }
@@ -1456,7 +1525,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS0 CVMX_PKO_LUT_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF0ull);
 }
@@ -1467,7 +1536,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS_CMB0 CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD8ull);
 }
@@ -1478,7 +1547,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS0 CVMX_PKO_LUT_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF8ull);
 }
@@ -1489,7 +1558,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS_CMB0 CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFE8ull);
 }
@@ -1501,6 +1570,7 @@ static inline uint64_t CVMX_PKO_MACX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MACX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900000ull) + ((offset) & 31) * 8;
@@ -1535,6 +1605,7 @@ static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_CRED_CNTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80100ull) + ((offset) & 31) * 8;
@@ -1547,6 +1618,7 @@ static inline uint64_t CVMX_PKO_MCI1_MAX_CREDX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_MAX_CREDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80000ull) + ((offset) & 31) * 8;
@@ -1717,7 +1789,7 @@ static inline uint64_t CVMX_PKO_MEM_THROTTLE_PIPE_FUNC(void)
 #define CVMX_PKO_NCB_BIST_STATUS CVMX_PKO_NCB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFF00ull);
 }
@@ -1728,7 +1800,7 @@ static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_NCB_ECC_CTL0 CVMX_PKO_NCB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD0ull);
 }
@@ -1739,7 +1811,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS0 CVMX_PKO_NCB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF0ull);
 }
@@ -1750,7 +1822,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS_CMB0 CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD8ull);
 }
@@ -1761,7 +1833,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS0 CVMX_PKO_NCB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF8ull);
 }
@@ -1772,7 +1844,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS_CMB0 CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFE8ull);
 }
@@ -1783,7 +1855,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_INT CVMX_PKO_NCB_INT_FUNC()
 static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00010ull);
 }
@@ -1794,7 +1866,7 @@ static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_INFO CVMX_PKO_NCB_TX_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00008ull);
 }
@@ -1805,7 +1877,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_WORD CVMX_PKO_NCB_TX_ERR_WORD_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_WORD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00000ull);
 }
@@ -1816,7 +1888,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 #define CVMX_PKO_PDM_BIST_STATUS CVMX_PKO_PDM_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFF00ull);
 }
@@ -1827,7 +1899,7 @@ static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PDM_CFG CVMX_PKO_PDM_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800000ull);
 }
@@ -1838,7 +1910,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 #define CVMX_PKO_PDM_CFG_DBG CVMX_PKO_PDM_CFG_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800FF8ull);
 }
@@ -1849,7 +1921,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 #define CVMX_PKO_PDM_CP_DBG CVMX_PKO_PDM_CP_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CP_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800190ull);
 }
@@ -1861,6 +1933,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_PDM_DQX_MINPAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008F0000ull) + ((offset) & 1023) * 8;
@@ -1872,7 +1945,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 #define CVMX_PKO_PDM_DRPBUF_DBG CVMX_PKO_PDM_DRPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DRPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000B0ull);
 }
@@ -1883,7 +1956,7 @@ static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_DWPBUF_DBG CVMX_PKO_PDM_DWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A8ull);
 }
@@ -1894,7 +1967,7 @@ static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL0 CVMX_PKO_PDM_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD0ull);
 }
@@ -1905,7 +1978,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL1 CVMX_PKO_PDM_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
 }
@@ -1916,7 +1989,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS0 CVMX_PKO_PDM_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF0ull);
 }
@@ -1927,7 +2000,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE0ull);
 }
@@ -1938,7 +2011,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS0 CVMX_PKO_PDM_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF8ull);
 }
@@ -1949,7 +2022,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS_CMB0 CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE8ull);
 }
@@ -1960,7 +2033,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG0 CVMX_PKO_PDM_FILLB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A0ull);
 }
@@ -1971,7 +2044,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG1 CVMX_PKO_PDM_FILLB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A8ull);
 }
@@ -1982,7 +2055,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG2 CVMX_PKO_PDM_FILLB_DBG2_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B0ull);
 }
@@ -1993,7 +2066,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG0 CVMX_PKO_PDM_FLSHB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B8ull);
 }
@@ -2004,7 +2077,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 CVMX_PKO_PDM_FLSHB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002C0ull);
 }
@@ -2015,7 +2088,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_INTF_DBG_RD CVMX_PKO_PDM_INTF_DBG_RD_FUNC()
 static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_PKO_PDM_INTF_DBG_RD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900F20ull);
 }
@@ -2026,7 +2099,7 @@ static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG CVMX_PKO_PDM_ISRD_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800090ull);
 }
@@ -2037,7 +2110,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG_DQ CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800290ull);
 }
@@ -2048,7 +2121,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG CVMX_PKO_PDM_ISRM_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800098ull);
 }
@@ -2059,7 +2132,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG_DQ CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800298ull);
 }
@@ -2070,7 +2143,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_MEM_ADDR CVMX_PKO_PDM_MEM_ADDR_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800018ull);
 }
@@ -2081,7 +2154,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 #define CVMX_PKO_PDM_MEM_DATA CVMX_PKO_PDM_MEM_DATA_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800010ull);
 }
@@ -2092,7 +2165,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_CTL CVMX_PKO_PDM_MEM_RW_CTL_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800020ull);
 }
@@ -2103,7 +2176,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_STS CVMX_PKO_PDM_MEM_RW_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800028ull);
 }
@@ -2114,7 +2187,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 #define CVMX_PKO_PDM_MWPBUF_DBG CVMX_PKO_PDM_MWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A0ull);
 }
@@ -2125,7 +2198,7 @@ static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_STS CVMX_PKO_PDM_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800008ull);
 }
@@ -2136,7 +2209,7 @@ static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 #define CVMX_PKO_PEB_BIST_STATUS CVMX_PKO_PEB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900D00ull);
 }
@@ -2147,7 +2220,7 @@ static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL0 CVMX_PKO_PEB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD0ull);
 }
@@ -2158,7 +2231,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL1 CVMX_PKO_PEB_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFA8ull);
 }
@@ -2169,7 +2242,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS0 CVMX_PKO_PEB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF0ull);
 }
@@ -2180,7 +2253,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS_CMB0 CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD8ull);
 }
@@ -2191,7 +2264,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS0 CVMX_PKO_PEB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF8ull);
 }
@@ -2202,7 +2275,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFE8ull);
 }
@@ -2213,7 +2286,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECO CVMX_PKO_PEB_ECO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000901000ull);
 }
@@ -2224,7 +2297,7 @@ static inline uint64_t CVMX_PKO_PEB_ECO_FUNC(void)
 #define CVMX_PKO_PEB_ERR_INT CVMX_PKO_PEB_ERR_INT_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C00ull);
 }
@@ -2235,7 +2308,7 @@ static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 #define CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C08ull);
 }
@@ -2246,7 +2319,7 @@ static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_FCS_SOP_ERR_INFO CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_FCS_SOP_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C18ull);
 }
@@ -2257,7 +2330,7 @@ static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_JUMP_DEF_ERR_INFO CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_JUMP_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C10ull);
 }
@@ -2268,7 +2341,7 @@ static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C50ull);
 }
@@ -2279,7 +2352,7 @@ static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MAX_LINK_ERR_INFO CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MAX_LINK_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C48ull);
 }
@@ -2290,7 +2363,7 @@ static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_NCB_CFG CVMX_PKO_PEB_NCB_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_NCB_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900308ull);
 }
@@ -2301,7 +2374,7 @@ static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 #define CVMX_PKO_PEB_PAD_ERR_INFO CVMX_PKO_PEB_PAD_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PAD_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C28ull);
 }
@@ -2312,7 +2385,7 @@ static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_PSE_FIFO_ERR_INFO CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PSE_FIFO_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C20ull);
 }
@@ -2323,7 +2396,7 @@ static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C38ull);
 }
@@ -2334,7 +2407,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C40ull);
 }
@@ -2345,7 +2418,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TRUNC_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C30ull);
 }
@@ -2356,7 +2429,7 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TSO_CFG CVMX_PKO_PEB_TSO_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TSO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900310ull);
 }
@@ -2367,7 +2440,7 @@ static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 #define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000128ull);
 }
@@ -2378,7 +2451,7 @@ static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 #define CVMX_PKO_PQB_DEBUG CVMX_PKO_PQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000130ull);
 }
@@ -2389,7 +2462,7 @@ static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_CSR_BUS_DEBUG CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000001F8ull);
 }
@@ -2400,7 +2473,7 @@ static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_GREEN CVMX_PKO_PQ_DEBUG_GREEN_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_GREEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000058ull);
 }
@@ -2411,7 +2484,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_LINKS CVMX_PKO_PQ_DEBUG_LINKS_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_LINKS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000068ull);
 }
@@ -2422,7 +2495,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_YELLOW CVMX_PKO_PQ_DEBUG_YELLOW_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_YELLOW not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000060ull);
 }
@@ -2433,7 +2506,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 #define CVMX_PKO_PSE_DQ_BIST_STATUS CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300138ull);
 }
@@ -2444,7 +2517,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_CTL0 CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300100ull);
 }
@@ -2455,7 +2528,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS0 CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300118ull);
 }
@@ -2466,7 +2539,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300120ull);
 }
@@ -2477,7 +2550,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS0 CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300108ull);
 }
@@ -2488,7 +2561,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300110ull);
 }
@@ -2499,7 +2572,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_BIST_STATUS CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000138ull);
 }
@@ -2510,7 +2583,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_CTL0 CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000100ull);
 }
@@ -2521,7 +2594,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS0 CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000118ull);
 }
@@ -2532,7 +2605,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000120ull);
 }
@@ -2543,7 +2616,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS0 CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000108ull);
 }
@@ -2554,7 +2627,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000110ull);
 }
@@ -2565,7 +2638,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_BIST_STATUS CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080138ull);
 }
@@ -2576,7 +2649,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_CTL0 CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080100ull);
 }
@@ -2587,7 +2660,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080118ull);
 }
@@ -2598,7 +2671,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080120ull);
 }
@@ -2609,7 +2682,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080108ull);
 }
@@ -2620,7 +2693,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080110ull);
 }
@@ -2631,7 +2704,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_BIST_STATUS CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100138ull);
 }
@@ -2642,7 +2715,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_CTL0 CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100100ull);
 }
@@ -2653,7 +2726,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100118ull);
 }
@@ -2664,7 +2737,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100120ull);
 }
@@ -2675,7 +2748,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100108ull);
 }
@@ -2686,7 +2759,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100110ull);
 }
@@ -2697,7 +2770,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_BIST_STATUS CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180138ull);
 }
@@ -2708,7 +2781,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_CTL0 CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180100ull);
 }
@@ -2719,7 +2792,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180118ull);
 }
@@ -2730,7 +2803,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180120ull);
 }
@@ -2741,7 +2814,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180108ull);
 }
@@ -2752,7 +2825,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180110ull);
 }
@@ -2896,6 +2969,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_PTFX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900100ull) + ((offset) & 31) * 8;
@@ -2907,7 +2981,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 #define CVMX_PKO_PTF_IOBP_CFG CVMX_PKO_PTF_IOBP_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PTF_IOBP_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900300ull);
 }
@@ -2919,6 +2993,7 @@ static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_PKO_PTGFX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900200ull) + ((offset) & 7) * 8;
@@ -3160,7 +3235,7 @@ static inline uint64_t CVMX_PKO_REG_TIMESTAMP_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG CVMX_PKO_SHAPER_CFG_FUNC()
 static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_SHAPER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
 }
@@ -3171,18 +3246,19 @@ static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 static inline uint64_t CVMX_PKO_STATE_UID_IN_USEX_RD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKO_STATE_UID_IN_USEX_RD(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8;
+	return CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 3) * 8;
 }
 #else
-#define CVMX_PKO_STATE_UID_IN_USEX_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8)
+#define CVMX_PKO_STATE_UID_IN_USEX_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 3) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_STATUS CVMX_PKO_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00000ull);
 }
@@ -3193,12 +3269,13 @@ static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 static inline uint64_t CVMX_PKO_TXFX_PKT_CNT_RD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_TXFX_PKT_CNT_RD(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8;
+	return CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 31) * 8;
 }
 #else
-#define CVMX_PKO_TXFX_PKT_CNT_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8)
+#define CVMX_PKO_TXFX_PKT_CNT_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 31) * 8)
 #endif
 
 /**
@@ -3218,7 +3295,9 @@ union cvmx_pko_channel_level {
 #endif
 	} s;
 	struct cvmx_pko_channel_level_s       cn73xx;
+	struct cvmx_pko_channel_level_s       cn75xx;
 	struct cvmx_pko_channel_level_s       cn78xx;
+	struct cvmx_pko_channel_level_s       cn78xxp2;
 };
 typedef union cvmx_pko_channel_level cvmx_pko_channel_level_t;
 
@@ -3239,7 +3318,9 @@ union cvmx_pko_dpfi_ena {
 #endif
 	} s;
 	struct cvmx_pko_dpfi_ena_s            cn73xx;
+	struct cvmx_pko_dpfi_ena_s            cn75xx;
 	struct cvmx_pko_dpfi_ena_s            cn78xx;
+	struct cvmx_pko_dpfi_ena_s            cn78xxp2;
 };
 typedef union cvmx_pko_dpfi_ena cvmx_pko_dpfi_ena_t;
 
@@ -3262,7 +3343,9 @@ union cvmx_pko_dpfi_flush {
 #endif
 	} s;
 	struct cvmx_pko_dpfi_flush_s          cn73xx;
+	struct cvmx_pko_dpfi_flush_s          cn75xx;
 	struct cvmx_pko_dpfi_flush_s          cn78xx;
+	struct cvmx_pko_dpfi_flush_s          cn78xxp2;
 };
 typedef union cvmx_pko_dpfi_flush cvmx_pko_dpfi_flush_t;
 
@@ -3285,7 +3368,9 @@ union cvmx_pko_dpfi_fpa_aura {
 #endif
 	} s;
 	struct cvmx_pko_dpfi_fpa_aura_s       cn73xx;
+	struct cvmx_pko_dpfi_fpa_aura_s       cn75xx;
 	struct cvmx_pko_dpfi_fpa_aura_s       cn78xx;
+	struct cvmx_pko_dpfi_fpa_aura_s       cn78xxp2;
 };
 typedef union cvmx_pko_dpfi_fpa_aura cvmx_pko_dpfi_fpa_aura_t;
 
@@ -3336,7 +3421,9 @@ union cvmx_pko_dpfi_status {
 #endif
 	} s;
 	struct cvmx_pko_dpfi_status_s         cn73xx;
+	struct cvmx_pko_dpfi_status_s         cn75xx;
 	struct cvmx_pko_dpfi_status_s         cn78xx;
+	struct cvmx_pko_dpfi_status_s         cn78xxp2;
 };
 typedef union cvmx_pko_dpfi_status cvmx_pko_dpfi_status_t;
 
@@ -3358,7 +3445,9 @@ union cvmx_pko_dqx_bytes {
 #endif
 	} s;
 	struct cvmx_pko_dqx_bytes_s           cn73xx;
+	struct cvmx_pko_dqx_bytes_s           cn75xx;
 	struct cvmx_pko_dqx_bytes_s           cn78xx;
+	struct cvmx_pko_dqx_bytes_s           cn78xxp2;
 };
 typedef union cvmx_pko_dqx_bytes cvmx_pko_dqx_bytes_t;
 
@@ -3407,7 +3496,9 @@ union cvmx_pko_dqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_dqx_cir_s             cn73xx;
+	struct cvmx_pko_dqx_cir_s             cn75xx;
 	struct cvmx_pko_dqx_cir_s             cn78xx;
+	struct cvmx_pko_dqx_cir_s             cn78xxp2;
 };
 typedef union cvmx_pko_dqx_cir cvmx_pko_dqx_cir_t;
 
@@ -3429,7 +3520,9 @@ union cvmx_pko_dqx_dropped_bytes {
 #endif
 	} s;
 	struct cvmx_pko_dqx_dropped_bytes_s   cn73xx;
+	struct cvmx_pko_dqx_dropped_bytes_s   cn75xx;
 	struct cvmx_pko_dqx_dropped_bytes_s   cn78xx;
+	struct cvmx_pko_dqx_dropped_bytes_s   cn78xxp2;
 };
 typedef union cvmx_pko_dqx_dropped_bytes cvmx_pko_dqx_dropped_bytes_t;
 
@@ -3451,7 +3544,9 @@ union cvmx_pko_dqx_dropped_packets {
 #endif
 	} s;
 	struct cvmx_pko_dqx_dropped_packets_s cn73xx;
+	struct cvmx_pko_dqx_dropped_packets_s cn75xx;
 	struct cvmx_pko_dqx_dropped_packets_s cn78xx;
+	struct cvmx_pko_dqx_dropped_packets_s cn78xxp2;
 };
 typedef union cvmx_pko_dqx_dropped_packets cvmx_pko_dqx_dropped_packets_t;
 
@@ -3474,7 +3569,9 @@ union cvmx_pko_dqx_fifo {
 #endif
 	} s;
 	struct cvmx_pko_dqx_fifo_s            cn73xx;
+	struct cvmx_pko_dqx_fifo_s            cn75xx;
 	struct cvmx_pko_dqx_fifo_s            cn78xx;
+	struct cvmx_pko_dqx_fifo_s            cn78xxp2;
 };
 typedef union cvmx_pko_dqx_fifo cvmx_pko_dqx_fifo_t;
 
@@ -3496,7 +3593,9 @@ union cvmx_pko_dqx_packets {
 #endif
 	} s;
 	struct cvmx_pko_dqx_packets_s         cn73xx;
+	struct cvmx_pko_dqx_packets_s         cn75xx;
 	struct cvmx_pko_dqx_packets_s         cn78xx;
+	struct cvmx_pko_dqx_packets_s         cn78xxp2;
 };
 typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
 
@@ -3504,7 +3603,7 @@ typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
  * cvmx_pko_dq#_pick
  *
  * This CSR contains the meta for the DQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_dqx_pick {
 	uint64_t u64;
@@ -3519,31 +3618,42 @@ union cvmx_pko_dqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -3563,7 +3673,9 @@ union cvmx_pko_dqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_dqx_pick_s            cn73xx;
+	struct cvmx_pko_dqx_pick_s            cn75xx;
 	struct cvmx_pko_dqx_pick_s            cn78xx;
+	struct cvmx_pko_dqx_pick_s            cn78xxp2;
 };
 typedef union cvmx_pko_dqx_pick cvmx_pko_dqx_pick_t;
 
@@ -3612,7 +3724,9 @@ union cvmx_pko_dqx_pir {
 #endif
 	} s;
 	struct cvmx_pko_dqx_pir_s             cn73xx;
+	struct cvmx_pko_dqx_pir_s             cn75xx;
 	struct cvmx_pko_dqx_pir_s             cn78xx;
+	struct cvmx_pko_dqx_pir_s             cn78xxp2;
 };
 typedef union cvmx_pko_dqx_pir cvmx_pko_dqx_pir_t;
 
@@ -3650,7 +3764,9 @@ union cvmx_pko_dqx_pointers {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pko_dqx_pointers_cn73xx   cn75xx;
 	struct cvmx_pko_dqx_pointers_s        cn78xx;
+	struct cvmx_pko_dqx_pointers_s        cn78xxp2;
 };
 typedef union cvmx_pko_dqx_pointers cvmx_pko_dqx_pointers_t;
 
@@ -3672,7 +3788,9 @@ union cvmx_pko_dqx_sched_state {
 #endif
 	} s;
 	struct cvmx_pko_dqx_sched_state_s     cn73xx;
+	struct cvmx_pko_dqx_sched_state_s     cn75xx;
 	struct cvmx_pko_dqx_sched_state_s     cn78xx;
+	struct cvmx_pko_dqx_sched_state_s     cn78xxp2;
 };
 typedef union cvmx_pko_dqx_sched_state cvmx_pko_dqx_sched_state_t;
 
@@ -3695,14 +3813,9 @@ union cvmx_pko_dqx_schedule {
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
                                                          integer). The packet size used in all DWRR (RR_COUNT) calculations is:
-                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
-                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
-                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
-                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor.
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_nm_PICK[LENGTH] + PKO_nm_PICK[ADJUST]))
+                                                            + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR.
                                                          Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
                                                          negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
@@ -3712,7 +3825,9 @@ union cvmx_pko_dqx_schedule {
 #endif
 	} s;
 	struct cvmx_pko_dqx_schedule_s        cn73xx;
+	struct cvmx_pko_dqx_schedule_s        cn75xx;
 	struct cvmx_pko_dqx_schedule_s        cn78xx;
+	struct cvmx_pko_dqx_schedule_s        cn78xxp2;
 };
 typedef union cvmx_pko_dqx_schedule cvmx_pko_dqx_schedule_t;
 
@@ -3726,7 +3841,12 @@ union cvmx_pko_dqx_shape {
 	uint64_t u64;
 	struct cvmx_pko_dqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_25_63               : 39;
+	uint64_t reserved_27_63               : 37;
+	uint64_t schedule_list                : 2;  /**< Shaper scheduling list. Restricts shaper scheduling to specific lists.
+                                                         0x0 = Normal (selected for nearly all scheduling/shaping applications).
+                                                         0x1 = Green-only.
+                                                         0x2 = Yellow-only.
+                                                         0x3 = Red-only. */
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
                                                          and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
@@ -3741,11 +3861,33 @@ union cvmx_pko_dqx_shape {
 	uint64_t yellow_disable               : 1;
 	uint64_t reserved_13_23               : 11;
 	uint64_t length_disable               : 1;
-	uint64_t reserved_25_63               : 39;
+	uint64_t schedule_list                : 2;
+	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
 	struct cvmx_pko_dqx_shape_s           cn73xx;
-	struct cvmx_pko_dqx_shape_s           cn78xx;
+	struct cvmx_pko_dqx_shape_s           cn75xx;
+	struct cvmx_pko_dqx_shape_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
+	uint64_t reserved_13_23               : 11;
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
+	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
+	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
+#else
+	uint64_t adjust                       : 9;
+	uint64_t red_algo                     : 2;
+	uint64_t red_disable                  : 1;
+	uint64_t yellow_disable               : 1;
+	uint64_t reserved_13_23               : 11;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn78xx;
+	struct cvmx_pko_dqx_shape_cn78xx      cn78xxp2;
 };
 typedef union cvmx_pko_dqx_shape cvmx_pko_dqx_shape_t;
 
@@ -3777,7 +3919,9 @@ union cvmx_pko_dqx_shape_state {
 #endif
 	} s;
 	struct cvmx_pko_dqx_shape_state_s     cn73xx;
+	struct cvmx_pko_dqx_shape_state_s     cn75xx;
 	struct cvmx_pko_dqx_shape_state_s     cn78xx;
+	struct cvmx_pko_dqx_shape_state_s     cn78xxp2;
 };
 typedef union cvmx_pko_dqx_shape_state cvmx_pko_dqx_shape_state_t;
 
@@ -3826,7 +3970,9 @@ union cvmx_pko_dqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_dqx_sw_xoff_s         cn73xx;
+	struct cvmx_pko_dqx_sw_xoff_s         cn75xx;
 	struct cvmx_pko_dqx_sw_xoff_s         cn78xx;
+	struct cvmx_pko_dqx_sw_xoff_s         cn78xxp2;
 };
 typedef union cvmx_pko_dqx_sw_xoff cvmx_pko_dqx_sw_xoff_t;
 
@@ -3857,7 +4003,9 @@ union cvmx_pko_dqx_topology {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pko_dqx_topology_cn73xx   cn75xx;
 	struct cvmx_pko_dqx_topology_s        cn78xx;
+	struct cvmx_pko_dqx_topology_s        cn78xxp2;
 };
 typedef union cvmx_pko_dqx_topology cvmx_pko_dqx_topology_t;
 
@@ -3869,14 +4017,18 @@ union cvmx_pko_dqx_wm_buf_cnt {
 	struct cvmx_pko_dqx_wm_buf_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t count                        : 36; /**< Reserved. */
+	uint64_t count                        : 36; /**< Watermark buffer count. The number of buffers allocated (from
+                                                         FPA aura PKO_DPFI_FPA_AURA[NODE,LAURA]) for this DQ.
+                                                         Added in pass 2. */
 #else
 	uint64_t count                        : 36;
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_buf_cnt_s      cn73xx;
+	struct cvmx_pko_dqx_wm_buf_cnt_s      cn75xx;
 	struct cvmx_pko_dqx_wm_buf_cnt_s      cn78xx;
+	struct cvmx_pko_dqx_wm_buf_cnt_s      cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_buf_cnt cvmx_pko_dqx_wm_buf_cnt_t;
 
@@ -3888,11 +4040,16 @@ union cvmx_pko_dqx_wm_buf_ctl {
 	struct cvmx_pko_dqx_wm_buf_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t enable                       : 1;  /**< Reserved. */
+	uint64_t enable                       : 1;  /**< Watermark interrupt enable for [THRESHOLD] comparison to PKO_DQ()_WM_BUF_CNT[COUNT].
+                                                         See the [INTR] description. Added in pass 2. */
 	uint64_t reserved_49_49               : 1;
-	uint64_t intr                         : 1;  /**< Reserved. */
+	uint64_t intr                         : 1;  /**< Watermark Buffer Interrupt. If [INTR] is clear and [ENABLE] is set, PKO
+                                                         sets [INTR] and throws PKO_INTSN_E::PKO_DQ()_WM whenever it
+                                                         modifies PKO_DQ()_WM_BUF_CNT[COUNT] to equal or cross [THRESHOLD].
+                                                         Added in pass 2. */
 	uint64_t reserved_36_47               : 12;
-	uint64_t threshold                    : 36; /**< Reserved. */
+	uint64_t threshold                    : 36; /**< Watermark interrupt Buffer Threshold for PKO_DQ()_WM_BUF_CNT[COUNT].
+                                                         See the [INTR] description. Added in pass 2. */
 #else
 	uint64_t threshold                    : 36;
 	uint64_t reserved_36_47               : 12;
@@ -3903,7 +4060,9 @@ union cvmx_pko_dqx_wm_buf_ctl {
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_buf_ctl_s      cn73xx;
+	struct cvmx_pko_dqx_wm_buf_ctl_s      cn75xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_s      cn78xx;
+	struct cvmx_pko_dqx_wm_buf_ctl_s      cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl cvmx_pko_dqx_wm_buf_ctl_t;
 
@@ -3915,7 +4074,9 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
-	uint64_t intr                         : 1;  /**< Reserved. */
+	uint64_t intr                         : 1;  /**< A copy of PKO_DQ()_WM_BUF_CTL[INTR]. When [INTR] is written with a one,
+                                                         PKO_DQ()_WM_BUF_CTL[INTR] is cleared.
+                                                         Added in pass 2. */
 	uint64_t reserved_0_47                : 48;
 #else
 	uint64_t reserved_0_47                : 48;
@@ -3924,7 +4085,9 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn73xx;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn75xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn78xx;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl_w1c cvmx_pko_dqx_wm_buf_ctl_w1c_t;
 
@@ -3937,8 +4100,8 @@ union cvmx_pko_dqx_wm_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t count                        : 48; /**< Watermark count. The running value of the watermark counter. This value is a count of
-                                                         bytes or packets as specified by PKO_DQ()_WM_CTL[KIND]. [COUNT] covers all descriptors
-                                                         in the DQ between when the PKO SEND LMTDMA/LMTST enqueues the descriptor until
+                                                         bytes or packets as specified by PKO_DQ()_WM_CTL[KIND]. [COUNT] covers all metas
+                                                         for the DQ between when the PKO SEND LMTDMA/LMTST enqueues the descriptor until
                                                          PKO PEB (i.e. the packet engines and FIFO's) first receives the meta descriptor.
                                                          It includes all descriptors whose meta's are held in either L2/DRAM for the DQ
                                                          (i.e. whose metas are held in PKO PDM) or any DQ or SQ (i.e. whose metas are held
@@ -3949,7 +4112,9 @@ union cvmx_pko_dqx_wm_cnt {
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_cnt_s          cn73xx;
+	struct cvmx_pko_dqx_wm_cnt_s          cn75xx;
 	struct cvmx_pko_dqx_wm_cnt_s          cn78xx;
+	struct cvmx_pko_dqx_wm_cnt_s          cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_cnt cvmx_pko_dqx_wm_cnt_t;
 
@@ -3961,18 +4126,18 @@ union cvmx_pko_dqx_wm_ctl {
 	struct cvmx_pko_dqx_wm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_52_63               : 12;
-	uint64_t ncb_query_rsp                : 1;  /**< Reserved. */
-	uint64_t enable                       : 1;  /**< Watermark enable. */
+	uint64_t ncb_query_rsp                : 1;  /**< NCB query response.  Specifies what value is returned in the
+                                                         PKO_QUERY_RTN_S[DEPTH] field.  When set to '0', the value held in
+                                                         PKO_DQ()_WM_CNT[COUNT] is returned.  When set to '1 the value held
+                                                         in PKO_DQ()_WM_BUF_CNT[COUNT] is returned. */
+	uint64_t enable                       : 1;  /**< Reserved. */
 	uint64_t kind                         : 1;  /**< Selects the contents of PKO_DQ()_WM_CNT[COUNT].
-                                                         If [KIND] is clear, PKO_DQ()_WM_CNT[COUNT] is the byte count in the DQ - the
-                                                         sum of the Meta[LENGTH]'s in the DQ, where Meta[LENGTH] is the Meta packet length.
-                                                         If [KIND] is set, PKO_DQ()_WM_CNT[COUNT] is the number of descriptors in the DQ. */
-	uint64_t intr                         : 1;  /**< Watermark Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is
-                                                         generated when the specified threshold is reached or crossed. Subsequent interrupt
-                                                         messages are only generated after this bit has been cleared. */
-	uint64_t threshold                    : 48; /**< Watermark Threshold. This threshold is compared to the watermark count of
-                                                         PKO_DQ()_WM_CNT[COUNT] and an interrupt is generated when the count reaches or
-                                                         crosses the threshold. */
+                                                         If [KIND] is clear, PKO_DQ()_WM_CNT[COUNT] is a byte count for the DQ - the
+                                                         sum of all PKO_META_DESC_S[LENGTH] and PKO_*_PICK[LENGTH] for the DQ.
+                                                         If [KIND] is set, PKO_DQ()_WM_CNT[COUNT] is a number of descriptors for the DQ.
+                                                         See PKO_DQ()_WM_CNT[COUNT]. */
+	uint64_t intr                         : 1;  /**< Reserved. */
+	uint64_t threshold                    : 48; /**< Reserved. */
 #else
 	uint64_t threshold                    : 48;
 	uint64_t intr                         : 1;
@@ -3983,7 +4148,9 @@ union cvmx_pko_dqx_wm_ctl {
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_ctl_s          cn73xx;
+	struct cvmx_pko_dqx_wm_ctl_s          cn75xx;
 	struct cvmx_pko_dqx_wm_ctl_s          cn78xx;
+	struct cvmx_pko_dqx_wm_ctl_s          cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_ctl cvmx_pko_dqx_wm_ctl_t;
 
@@ -3995,9 +4162,7 @@ union cvmx_pko_dqx_wm_ctl_w1c {
 	struct cvmx_pko_dqx_wm_ctl_w1c_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
-	uint64_t intr                         : 1;  /**< Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is generated
-                                                         when the specified threshold is crossed. Subsequent interrupt messages are only generated
-                                                         after this bit has been cleared by writing 1. Throws PKO_INTSN_E::PKO_DQ()_WM. */
+	uint64_t intr                         : 1;  /**< Reserved. */
 	uint64_t reserved_0_47                : 48;
 #else
 	uint64_t reserved_0_47                : 48;
@@ -4006,7 +4171,9 @@ union cvmx_pko_dqx_wm_ctl_w1c {
 #endif
 	} s;
 	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn73xx;
+	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn75xx;
 	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn78xx;
+	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn78xxp2;
 };
 typedef union cvmx_pko_dqx_wm_ctl_w1c cvmx_pko_dqx_wm_ctl_w1c_t;
 
@@ -4023,7 +4190,9 @@ union cvmx_pko_dq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_dq_csr_bus_debug_s    cn73xx;
+	struct cvmx_pko_dq_csr_bus_debug_s    cn75xx;
 	struct cvmx_pko_dq_csr_bus_debug_s    cn78xx;
+	struct cvmx_pko_dq_csr_bus_debug_s    cn78xxp2;
 };
 typedef union cvmx_pko_dq_csr_bus_debug cvmx_pko_dq_csr_bus_debug_t;
 
@@ -4040,7 +4209,9 @@ union cvmx_pko_dq_debug {
 #endif
 	} s;
 	struct cvmx_pko_dq_debug_s            cn73xx;
+	struct cvmx_pko_dq_debug_s            cn75xx;
 	struct cvmx_pko_dq_debug_s            cn78xx;
+	struct cvmx_pko_dq_debug_s            cn78xxp2;
 };
 typedef union cvmx_pko_dq_debug cvmx_pko_dq_debug_t;
 
@@ -4062,7 +4233,9 @@ union cvmx_pko_drain_irq {
 #endif
 	} s;
 	struct cvmx_pko_drain_irq_s           cn73xx;
+	struct cvmx_pko_drain_irq_s           cn75xx;
 	struct cvmx_pko_drain_irq_s           cn78xx;
+	struct cvmx_pko_drain_irq_s           cn78xxp2;
 };
 typedef union cvmx_pko_drain_irq cvmx_pko_drain_irq_t;
 
@@ -4081,7 +4254,9 @@ union cvmx_pko_enable {
 #endif
 	} s;
 	struct cvmx_pko_enable_s              cn73xx;
+	struct cvmx_pko_enable_s              cn75xx;
 	struct cvmx_pko_enable_s              cn78xx;
+	struct cvmx_pko_enable_s              cn78xxp2;
 };
 typedef union cvmx_pko_enable cvmx_pko_enable_t;
 
@@ -4131,7 +4306,9 @@ union cvmx_pko_formatx_ctl {
 #endif
 	} s;
 	struct cvmx_pko_formatx_ctl_s         cn73xx;
+	struct cvmx_pko_formatx_ctl_s         cn75xx;
 	struct cvmx_pko_formatx_ctl_s         cn78xx;
+	struct cvmx_pko_formatx_ctl_s         cn78xxp2;
 };
 typedef union cvmx_pko_formatx_ctl cvmx_pko_formatx_ctl_t;
 
@@ -4177,7 +4354,9 @@ union cvmx_pko_l1_sqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_cir_s          cn73xx;
+	struct cvmx_pko_l1_sqx_cir_s          cn75xx;
 	struct cvmx_pko_l1_sqx_cir_s          cn78xx;
+	struct cvmx_pko_l1_sqx_cir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_cir cvmx_pko_l1_sqx_cir_t;
 
@@ -4199,7 +4378,9 @@ union cvmx_pko_l1_sqx_dropped_bytes {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_dropped_bytes_s cn73xx;
+	struct cvmx_pko_l1_sqx_dropped_bytes_s cn75xx;
 	struct cvmx_pko_l1_sqx_dropped_bytes_s cn78xx;
+	struct cvmx_pko_l1_sqx_dropped_bytes_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_dropped_bytes cvmx_pko_l1_sqx_dropped_bytes_t;
 
@@ -4221,7 +4402,9 @@ union cvmx_pko_l1_sqx_dropped_packets {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_dropped_packets_s cn73xx;
+	struct cvmx_pko_l1_sqx_dropped_packets_s cn75xx;
 	struct cvmx_pko_l1_sqx_dropped_packets_s cn78xx;
+	struct cvmx_pko_l1_sqx_dropped_packets_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_dropped_packets cvmx_pko_l1_sqx_dropped_packets_t;
 
@@ -4255,7 +4438,9 @@ union cvmx_pko_l1_sqx_green {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_green_s        cn73xx;
+	struct cvmx_pko_l1_sqx_green_s        cn75xx;
 	struct cvmx_pko_l1_sqx_green_s        cn78xx;
+	struct cvmx_pko_l1_sqx_green_s        cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_green cvmx_pko_l1_sqx_green_t;
 
@@ -4274,7 +4459,9 @@ union cvmx_pko_l1_sqx_green_bytes {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_green_bytes_s  cn73xx;
+	struct cvmx_pko_l1_sqx_green_bytes_s  cn75xx;
 	struct cvmx_pko_l1_sqx_green_bytes_s  cn78xx;
+	struct cvmx_pko_l1_sqx_green_bytes_s  cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_green_bytes cvmx_pko_l1_sqx_green_bytes_t;
 
@@ -4293,7 +4480,9 @@ union cvmx_pko_l1_sqx_green_packets {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_green_packets_s cn73xx;
+	struct cvmx_pko_l1_sqx_green_packets_s cn75xx;
 	struct cvmx_pko_l1_sqx_green_packets_s cn78xx;
+	struct cvmx_pko_l1_sqx_green_packets_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_green_packets cvmx_pko_l1_sqx_green_packets_t;
 
@@ -4360,7 +4549,9 @@ union cvmx_pko_l1_sqx_link {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l1_sqx_link_cn73xx    cn75xx;
 	struct cvmx_pko_l1_sqx_link_s         cn78xx;
+	struct cvmx_pko_l1_sqx_link_s         cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_link cvmx_pko_l1_sqx_link_t;
 
@@ -4368,7 +4559,7 @@ typedef union cvmx_pko_l1_sqx_link cvmx_pko_l1_sqx_link_t;
  * cvmx_pko_l1_sq#_pick
  *
  * This CSR contains the meta for the L1 SQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_l1_sqx_pick {
 	uint64_t u64;
@@ -4383,31 +4574,42 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4427,7 +4629,9 @@ union cvmx_pko_l1_sqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_pick_s         cn73xx;
+	struct cvmx_pko_l1_sqx_pick_s         cn75xx;
 	struct cvmx_pko_l1_sqx_pick_s         cn78xx;
+	struct cvmx_pko_l1_sqx_pick_s         cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_pick cvmx_pko_l1_sqx_pick_t;
 
@@ -4453,7 +4657,9 @@ union cvmx_pko_l1_sqx_red {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_red_s          cn73xx;
+	struct cvmx_pko_l1_sqx_red_s          cn75xx;
 	struct cvmx_pko_l1_sqx_red_s          cn78xx;
+	struct cvmx_pko_l1_sqx_red_s          cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_red cvmx_pko_l1_sqx_red_t;
 
@@ -4475,7 +4681,9 @@ union cvmx_pko_l1_sqx_red_bytes {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_red_bytes_s    cn73xx;
+	struct cvmx_pko_l1_sqx_red_bytes_s    cn75xx;
 	struct cvmx_pko_l1_sqx_red_bytes_s    cn78xx;
+	struct cvmx_pko_l1_sqx_red_bytes_s    cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_red_bytes cvmx_pko_l1_sqx_red_bytes_t;
 
@@ -4497,7 +4705,9 @@ union cvmx_pko_l1_sqx_red_packets {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_red_packets_s  cn73xx;
+	struct cvmx_pko_l1_sqx_red_packets_s  cn75xx;
 	struct cvmx_pko_l1_sqx_red_packets_s  cn78xx;
+	struct cvmx_pko_l1_sqx_red_packets_s  cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_red_packets cvmx_pko_l1_sqx_red_packets_t;
 
@@ -4509,7 +4719,10 @@ union cvmx_pko_l1_sqx_schedule {
 	struct cvmx_pko_l1_sqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dummy                        : 40; /**< Reserved. */
-	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
+	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
+                                                         integer).
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of the deficit count). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t dummy                        : 40;
@@ -4527,7 +4740,9 @@ union cvmx_pko_l1_sqx_schedule {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l1_sqx_schedule_cn73xx cn75xx;
 	struct cvmx_pko_l1_sqx_schedule_s     cn78xx;
+	struct cvmx_pko_l1_sqx_schedule_cn73xx cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_schedule cvmx_pko_l1_sqx_schedule_t;
 
@@ -4539,11 +4754,17 @@ union cvmx_pko_l1_sqx_shape {
 	struct cvmx_pko_l1_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< N/A */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used.
+                                                         Added in pass 2. */
 	uint64_t reserved_18_23               : 6;
 	uint64_t link                         : 5;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
 	uint64_t reserved_9_12                : 4;
-	uint64_t adjust                       : 9;  /**< N/A */
+	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value
+                                                         allows -255 .. 255 bytes to be added to the packet length for rate
+                                                         limiting and scheduling calculations. [ADJUST] value 0x100 should
+                                                         not be used.
+                                                         Added in pass 2. */
 #else
 	uint64_t adjust                       : 9;
 	uint64_t reserved_9_12                : 4;
@@ -4574,7 +4795,9 @@ union cvmx_pko_l1_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l1_sqx_shape_cn73xx   cn75xx;
 	struct cvmx_pko_l1_sqx_shape_s        cn78xx;
+	struct cvmx_pko_l1_sqx_shape_s        cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_shape cvmx_pko_l1_sqx_shape_t;
 
@@ -4587,6 +4810,25 @@ union cvmx_pko_l1_sqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
+	uint64_t color2                       : 1;  /**< Same value as COLOR. */
+	uint64_t color                        : 1;  /**< Shaper color status. Debug access to the live shaper state.
+                                                         0 = Green - operating in 'committed' range.
+                                                         1 = Red - operating in 'oversubscribed' range or inactive. */
+	uint64_t reserved_26_51               : 26;
+	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
+#else
+	uint64_t cir_accum                    : 26;
+	uint64_t reserved_26_51               : 26;
+	uint64_t color                        : 1;
+	uint64_t color2                       : 1;
+	uint64_t tw_timestamp                 : 6;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_pko_l1_sqx_shape_state_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
 	uint64_t reserved_53_53               : 1;
 	uint64_t color                        : 1;  /**< Shaper color status. Debug access to the live shaper state.
                                                          0 = Green - operating in 'committed' range.
@@ -4601,9 +4843,10 @@ union cvmx_pko_l1_sqx_shape_state {
 	uint64_t tw_timestamp                 : 6;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} s;
-	struct cvmx_pko_l1_sqx_shape_state_s  cn73xx;
+	} cn73xx;
+	struct cvmx_pko_l1_sqx_shape_state_cn73xx cn75xx;
 	struct cvmx_pko_l1_sqx_shape_state_s  cn78xx;
+	struct cvmx_pko_l1_sqx_shape_state_cn73xx cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_shape_state cvmx_pko_l1_sqx_shape_state_t;
 
@@ -4649,7 +4892,9 @@ union cvmx_pko_l1_sqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_sw_xoff_s      cn73xx;
+	struct cvmx_pko_l1_sqx_sw_xoff_s      cn75xx;
 	struct cvmx_pko_l1_sqx_sw_xoff_s      cn78xx;
+	struct cvmx_pko_l1_sqx_sw_xoff_s      cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_sw_xoff cvmx_pko_l1_sqx_sw_xoff_t;
 
@@ -4777,7 +5022,9 @@ union cvmx_pko_l1_sqx_topology {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l1_sqx_topology_cn73xx cn75xx;
 	struct cvmx_pko_l1_sqx_topology_s     cn78xx;
+	struct cvmx_pko_l1_sqx_topology_s     cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_topology cvmx_pko_l1_sqx_topology_t;
 
@@ -4800,7 +5047,9 @@ union cvmx_pko_l1_sqx_yellow {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_yellow_s       cn73xx;
+	struct cvmx_pko_l1_sqx_yellow_s       cn75xx;
 	struct cvmx_pko_l1_sqx_yellow_s       cn78xx;
+	struct cvmx_pko_l1_sqx_yellow_s       cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_yellow cvmx_pko_l1_sqx_yellow_t;
 
@@ -4822,7 +5071,9 @@ union cvmx_pko_l1_sqx_yellow_bytes {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_yellow_bytes_s cn73xx;
+	struct cvmx_pko_l1_sqx_yellow_bytes_s cn75xx;
 	struct cvmx_pko_l1_sqx_yellow_bytes_s cn78xx;
+	struct cvmx_pko_l1_sqx_yellow_bytes_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_yellow_bytes cvmx_pko_l1_sqx_yellow_bytes_t;
 
@@ -4844,7 +5095,9 @@ union cvmx_pko_l1_sqx_yellow_packets {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_yellow_packets_s cn73xx;
+	struct cvmx_pko_l1_sqx_yellow_packets_s cn75xx;
 	struct cvmx_pko_l1_sqx_yellow_packets_s cn78xx;
+	struct cvmx_pko_l1_sqx_yellow_packets_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqx_yellow_packets cvmx_pko_l1_sqx_yellow_packets_t;
 
@@ -4861,7 +5114,9 @@ union cvmx_pko_l1_sq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_l1_sq_csr_bus_debug_s cn73xx;
+	struct cvmx_pko_l1_sq_csr_bus_debug_s cn75xx;
 	struct cvmx_pko_l1_sq_csr_bus_debug_s cn78xx;
+	struct cvmx_pko_l1_sq_csr_bus_debug_s cn78xxp2;
 };
 typedef union cvmx_pko_l1_sq_csr_bus_debug cvmx_pko_l1_sq_csr_bus_debug_t;
 
@@ -4881,7 +5136,9 @@ union cvmx_pko_l1_sqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqa_debug_s        cn73xx;
+	struct cvmx_pko_l1_sqa_debug_s        cn75xx;
 	struct cvmx_pko_l1_sqa_debug_s        cn78xx;
+	struct cvmx_pko_l1_sqa_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqa_debug cvmx_pko_l1_sqa_debug_t;
 
@@ -4901,7 +5158,9 @@ union cvmx_pko_l1_sqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_l1_sqb_debug_s        cn73xx;
+	struct cvmx_pko_l1_sqb_debug_s        cn75xx;
 	struct cvmx_pko_l1_sqb_debug_s        cn78xx;
+	struct cvmx_pko_l1_sqb_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l1_sqb_debug cvmx_pko_l1_sqb_debug_t;
 
@@ -4950,7 +5209,9 @@ union cvmx_pko_l2_sqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_cir_s          cn73xx;
+	struct cvmx_pko_l2_sqx_cir_s          cn75xx;
 	struct cvmx_pko_l2_sqx_cir_s          cn78xx;
+	struct cvmx_pko_l2_sqx_cir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_cir cvmx_pko_l2_sqx_cir_t;
 
@@ -4987,7 +5248,9 @@ union cvmx_pko_l2_sqx_green {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_green_s        cn73xx;
+	struct cvmx_pko_l2_sqx_green_s        cn75xx;
 	struct cvmx_pko_l2_sqx_green_s        cn78xx;
+	struct cvmx_pko_l2_sqx_green_s        cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
 
@@ -4995,7 +5258,7 @@ typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
  * cvmx_pko_l2_sq#_pick
  *
  * This CSR contains the meta for the L2 SQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_l2_sqx_pick {
 	uint64_t u64;
@@ -5010,31 +5273,42 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5054,7 +5328,9 @@ union cvmx_pko_l2_sqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_pick_s         cn73xx;
+	struct cvmx_pko_l2_sqx_pick_s         cn75xx;
 	struct cvmx_pko_l2_sqx_pick_s         cn78xx;
+	struct cvmx_pko_l2_sqx_pick_s         cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_pick cvmx_pko_l2_sqx_pick_t;
 
@@ -5103,7 +5379,9 @@ union cvmx_pko_l2_sqx_pir {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_pir_s          cn73xx;
+	struct cvmx_pko_l2_sqx_pir_s          cn75xx;
 	struct cvmx_pko_l2_sqx_pir_s          cn78xx;
+	struct cvmx_pko_l2_sqx_pir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_pir cvmx_pko_l2_sqx_pir_t;
 
@@ -5138,7 +5416,9 @@ union cvmx_pko_l2_sqx_pointers {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l2_sqx_pointers_cn73xx cn75xx;
 	struct cvmx_pko_l2_sqx_pointers_s     cn78xx;
+	struct cvmx_pko_l2_sqx_pointers_s     cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_pointers cvmx_pko_l2_sqx_pointers_t;
 
@@ -5164,7 +5444,9 @@ union cvmx_pko_l2_sqx_red {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_red_s          cn73xx;
+	struct cvmx_pko_l2_sqx_red_s          cn75xx;
 	struct cvmx_pko_l2_sqx_red_s          cn78xx;
+	struct cvmx_pko_l2_sqx_red_s          cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_red cvmx_pko_l2_sqx_red_t;
 
@@ -5183,7 +5465,9 @@ union cvmx_pko_l2_sqx_sched_state {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_sched_state_s  cn73xx;
+	struct cvmx_pko_l2_sqx_sched_state_s  cn75xx;
 	struct cvmx_pko_l2_sqx_sched_state_s  cn78xx;
+	struct cvmx_pko_l2_sqx_sched_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_sched_state cvmx_pko_l2_sqx_sched_state_t;
 
@@ -5203,14 +5487,9 @@ union cvmx_pko_l2_sqx_schedule {
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
                                                          integer). The packet size used in all DWRR (RR_COUNT) calculations is:
-                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
-                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
-                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
-                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor.
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_nm_PICK[LENGTH] + PKO_nm_PICK[ADJUST]))
+                                                            + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR.
                                                          Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
                                                          negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
@@ -5220,7 +5499,9 @@ union cvmx_pko_l2_sqx_schedule {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_schedule_s     cn73xx;
+	struct cvmx_pko_l2_sqx_schedule_s     cn75xx;
 	struct cvmx_pko_l2_sqx_schedule_s     cn78xx;
+	struct cvmx_pko_l2_sqx_schedule_s     cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_schedule cvmx_pko_l2_sqx_schedule_t;
 
@@ -5231,7 +5512,12 @@ union cvmx_pko_l2_sqx_shape {
 	uint64_t u64;
 	struct cvmx_pko_l2_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_25_63               : 39;
+	uint64_t reserved_27_63               : 37;
+	uint64_t schedule_list                : 2;  /**< Shaper scheduling list. Restricts shaper scheduling to specific lists.
+                                                         0x0 = Normal (selected for nearly all scheduling/shaping applications).
+                                                         0x1 = Green-only.
+                                                         0x2 = Yellow-only.
+                                                         0x3 = Red-only. */
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
                                                          and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
@@ -5274,11 +5560,61 @@ union cvmx_pko_l2_sqx_shape {
 	uint64_t yellow_disable               : 1;
 	uint64_t reserved_13_23               : 11;
 	uint64_t length_disable               : 1;
-	uint64_t reserved_25_63               : 39;
+	uint64_t schedule_list                : 2;
+	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_shape_s        cn73xx;
-	struct cvmx_pko_l2_sqx_shape_s        cn78xx;
+	struct cvmx_pko_l2_sqx_shape_s        cn75xx;
+	struct cvmx_pko_l2_sqx_shape_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
+	uint64_t reserved_13_23               : 11;
+	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when
+                                                         set. Not used by hardware when corresponding PKO_*_CIR[ENABLE] is clear. */
+	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
+                                                         transitions when set. Not used by hardware when [RED_ALGO]/PKO_SEND_EXT_S[RA]=0x2/STALL
+                                                         nor when corresponding PKO_*_PIR[ENABLE] is clear. */
+	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm when not specified by the PKO SEND. Used by hardware
+                                                         only when the shaper is in RED state. (RED state is when
+                                                         PKO_*_SHAPE_STATE[COLOR]=0x2). When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
+                                                         packet, this [RED_ALGO] is not used, and PKO_SEND_EXT_S[RA] instead defines
+                                                         the shaper red state algorithm used for the packet. The
+                                                         encoding for the [RED_ALGO]/PKO_SEND_EXT_S[RA] that is used:
+                                                         0x0 = STALL. See 0x2.
+                                                         0x1 = SEND. Send packets while the shaper is in RED state. When the shaper is
+                                                               in RED state, packets that traverse the shaper will be downgraded to RED_SEND.
+                                                               (if not already RED_SEND or RED_DROP) unless [RED_DISABLE] is set or
+                                                               PKO_SEND_EXT_S[COL] for the packet is CIR_ONLY or NO_COLOR.
+                                                               See also PKO_REDALG_E::SEND.
+                                                         0x2 = STALL. Stall packets while the shaper is in RED state until the shaper is
+                                                               YELLOW or GREEN state. Packets that traverse the shaper are never
+                                                               downgraded to the RED state in this mode.
+                                                               See also PKO_REDALG_E::STALL.
+                                                         0x3 = DISCARD. Continually discard packets while the shaper is in RED state.
+                                                               When the shaper is in RED state, all packets that traverse the shaper
+                                                               will be downgraded to RED_DROP (if not already RED_DROP), unless
+                                                               [RED_DISABLE] is set or PKO_SEND_EXT_S[COL] for the packet is CIR_ONLY
+                                                               or NO_COLOR. RED_DROP packets traverse all subsequent schedulers/shapers
+                                                               (all the way through L1), but do so as quickly as possible without
+                                                               affecting any RR_COUNT, CIR_ACCUM, or PIR_ACCUM state, and are then
+                                                               discarded by PKO. See also PKO_REDALG_E::DISCARD. */
+	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value allows
+                                                         -255 .. 255 bytes to be added to the packet length for shaping and scheduling
+                                                         calculations. [ADJUST] value 0x100 should not be used. */
+#else
+	uint64_t adjust                       : 9;
+	uint64_t red_algo                     : 2;
+	uint64_t red_disable                  : 1;
+	uint64_t yellow_disable               : 1;
+	uint64_t reserved_13_23               : 11;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn78xx;
+	struct cvmx_pko_l2_sqx_shape_cn78xx   cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_shape cvmx_pko_l2_sqx_shape_t;
 
@@ -5307,7 +5643,9 @@ union cvmx_pko_l2_sqx_shape_state {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_shape_state_s  cn73xx;
+	struct cvmx_pko_l2_sqx_shape_state_s  cn75xx;
 	struct cvmx_pko_l2_sqx_shape_state_s  cn78xx;
+	struct cvmx_pko_l2_sqx_shape_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_shape_state cvmx_pko_l2_sqx_shape_state_t;
 
@@ -5356,7 +5694,9 @@ union cvmx_pko_l2_sqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_sw_xoff_s      cn73xx;
+	struct cvmx_pko_l2_sqx_sw_xoff_s      cn75xx;
 	struct cvmx_pko_l2_sqx_sw_xoff_s      cn78xx;
+	struct cvmx_pko_l2_sqx_sw_xoff_s      cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_sw_xoff cvmx_pko_l2_sqx_sw_xoff_t;
 
@@ -5411,7 +5751,9 @@ union cvmx_pko_l2_sqx_topology {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l2_sqx_topology_cn73xx cn75xx;
 	struct cvmx_pko_l2_sqx_topology_s     cn78xx;
+	struct cvmx_pko_l2_sqx_topology_s     cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_topology cvmx_pko_l2_sqx_topology_t;
 
@@ -5437,7 +5779,9 @@ union cvmx_pko_l2_sqx_yellow {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_yellow_s       cn73xx;
+	struct cvmx_pko_l2_sqx_yellow_s       cn75xx;
 	struct cvmx_pko_l2_sqx_yellow_s       cn78xx;
+	struct cvmx_pko_l2_sqx_yellow_s       cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqx_yellow cvmx_pko_l2_sqx_yellow_t;
 
@@ -5454,7 +5798,9 @@ union cvmx_pko_l2_sq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_l2_sq_csr_bus_debug_s cn73xx;
+	struct cvmx_pko_l2_sq_csr_bus_debug_s cn75xx;
 	struct cvmx_pko_l2_sq_csr_bus_debug_s cn78xx;
+	struct cvmx_pko_l2_sq_csr_bus_debug_s cn78xxp2;
 };
 typedef union cvmx_pko_l2_sq_csr_bus_debug cvmx_pko_l2_sq_csr_bus_debug_t;
 
@@ -5474,7 +5820,9 @@ union cvmx_pko_l2_sqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqa_debug_s        cn73xx;
+	struct cvmx_pko_l2_sqa_debug_s        cn75xx;
 	struct cvmx_pko_l2_sqa_debug_s        cn78xx;
+	struct cvmx_pko_l2_sqa_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqa_debug cvmx_pko_l2_sqa_debug_t;
 
@@ -5494,7 +5842,9 @@ union cvmx_pko_l2_sqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_l2_sqb_debug_s        cn73xx;
+	struct cvmx_pko_l2_sqb_debug_s        cn75xx;
 	struct cvmx_pko_l2_sqb_debug_s        cn78xx;
+	struct cvmx_pko_l2_sqb_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l2_sqb_debug cvmx_pko_l2_sqb_debug_t;
 
@@ -5533,7 +5883,9 @@ union cvmx_pko_l3_l2_sqx_channel {
 #endif
 	} s;
 	struct cvmx_pko_l3_l2_sqx_channel_s   cn73xx;
+	struct cvmx_pko_l3_l2_sqx_channel_s   cn75xx;
 	struct cvmx_pko_l3_l2_sqx_channel_s   cn78xx;
+	struct cvmx_pko_l3_l2_sqx_channel_s   cn78xxp2;
 };
 typedef union cvmx_pko_l3_l2_sqx_channel cvmx_pko_l3_l2_sqx_channel_t;
 
@@ -5582,7 +5934,9 @@ union cvmx_pko_l3_sqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_cir_s          cn73xx;
+	struct cvmx_pko_l3_sqx_cir_s          cn75xx;
 	struct cvmx_pko_l3_sqx_cir_s          cn78xx;
+	struct cvmx_pko_l3_sqx_cir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_cir cvmx_pko_l3_sqx_cir_t;
 
@@ -5627,7 +5981,9 @@ union cvmx_pko_l3_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l3_sqx_green_cn73xx   cn75xx;
 	struct cvmx_pko_l3_sqx_green_s        cn78xx;
+	struct cvmx_pko_l3_sqx_green_s        cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
 
@@ -5635,7 +5991,7 @@ typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
  * cvmx_pko_l3_sq#_pick
  *
  * This CSR contains the meta for the L3 SQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_l3_sqx_pick {
 	uint64_t u64;
@@ -5650,31 +6006,42 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5694,7 +6061,9 @@ union cvmx_pko_l3_sqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_pick_s         cn73xx;
+	struct cvmx_pko_l3_sqx_pick_s         cn75xx;
 	struct cvmx_pko_l3_sqx_pick_s         cn78xx;
+	struct cvmx_pko_l3_sqx_pick_s         cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_pick cvmx_pko_l3_sqx_pick_t;
 
@@ -5743,7 +6112,9 @@ union cvmx_pko_l3_sqx_pir {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_pir_s          cn73xx;
+	struct cvmx_pko_l3_sqx_pir_s          cn75xx;
 	struct cvmx_pko_l3_sqx_pir_s          cn78xx;
+	struct cvmx_pko_l3_sqx_pir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_pir cvmx_pko_l3_sqx_pir_t;
 
@@ -5781,7 +6152,9 @@ union cvmx_pko_l3_sqx_pointers {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l3_sqx_pointers_cn73xx cn75xx;
 	struct cvmx_pko_l3_sqx_pointers_s     cn78xx;
+	struct cvmx_pko_l3_sqx_pointers_s     cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_pointers cvmx_pko_l3_sqx_pointers_t;
 
@@ -5817,7 +6190,9 @@ union cvmx_pko_l3_sqx_red {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l3_sqx_red_cn73xx     cn75xx;
 	struct cvmx_pko_l3_sqx_red_s          cn78xx;
+	struct cvmx_pko_l3_sqx_red_s          cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_red cvmx_pko_l3_sqx_red_t;
 
@@ -5839,7 +6214,9 @@ union cvmx_pko_l3_sqx_sched_state {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_sched_state_s  cn73xx;
+	struct cvmx_pko_l3_sqx_sched_state_s  cn75xx;
 	struct cvmx_pko_l3_sqx_sched_state_s  cn78xx;
+	struct cvmx_pko_l3_sqx_sched_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_sched_state cvmx_pko_l3_sqx_sched_state_t;
 
@@ -5862,14 +6239,9 @@ union cvmx_pko_l3_sqx_schedule {
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
                                                          integer). The packet size used in all DWRR (RR_COUNT) calculations is:
-                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
-                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
-                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
-                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor.
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_nm_PICK[LENGTH] + PKO_nm_PICK[ADJUST]))
+                                                            + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR.
                                                          Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
                                                          negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
@@ -5879,7 +6251,9 @@ union cvmx_pko_l3_sqx_schedule {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_schedule_s     cn73xx;
+	struct cvmx_pko_l3_sqx_schedule_s     cn75xx;
 	struct cvmx_pko_l3_sqx_schedule_s     cn78xx;
+	struct cvmx_pko_l3_sqx_schedule_s     cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_schedule cvmx_pko_l3_sqx_schedule_t;
 
@@ -5890,7 +6264,12 @@ union cvmx_pko_l3_sqx_shape {
 	uint64_t u64;
 	struct cvmx_pko_l3_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_25_63               : 39;
+	uint64_t reserved_27_63               : 37;
+	uint64_t schedule_list                : 2;  /**< Shaper scheduling list. Restricts shaper scheduling to specific lists.
+                                                         0x0 = Normal (selected for nearly all scheduling/shaping applications).
+                                                         0x1 = Green-only.
+                                                         0x2 = Yellow-only.
+                                                         0x3 = Red-only. */
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
                                                          and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
@@ -5905,11 +6284,33 @@ union cvmx_pko_l3_sqx_shape {
 	uint64_t yellow_disable               : 1;
 	uint64_t reserved_13_23               : 11;
 	uint64_t length_disable               : 1;
-	uint64_t reserved_25_63               : 39;
+	uint64_t schedule_list                : 2;
+	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_shape_s        cn73xx;
-	struct cvmx_pko_l3_sqx_shape_s        cn78xx;
+	struct cvmx_pko_l3_sqx_shape_s        cn75xx;
+	struct cvmx_pko_l3_sqx_shape_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
+	uint64_t reserved_13_23               : 11;
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
+	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
+	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
+#else
+	uint64_t adjust                       : 9;
+	uint64_t red_algo                     : 2;
+	uint64_t red_disable                  : 1;
+	uint64_t yellow_disable               : 1;
+	uint64_t reserved_13_23               : 11;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn78xx;
+	struct cvmx_pko_l3_sqx_shape_cn78xx   cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_shape cvmx_pko_l3_sqx_shape_t;
 
@@ -5941,7 +6342,9 @@ union cvmx_pko_l3_sqx_shape_state {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_shape_state_s  cn73xx;
+	struct cvmx_pko_l3_sqx_shape_state_s  cn75xx;
 	struct cvmx_pko_l3_sqx_shape_state_s  cn78xx;
+	struct cvmx_pko_l3_sqx_shape_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_shape_state cvmx_pko_l3_sqx_shape_state_t;
 
@@ -5990,7 +6393,9 @@ union cvmx_pko_l3_sqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_sw_xoff_s      cn73xx;
+	struct cvmx_pko_l3_sqx_sw_xoff_s      cn75xx;
 	struct cvmx_pko_l3_sqx_sw_xoff_s      cn78xx;
+	struct cvmx_pko_l3_sqx_sw_xoff_s      cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_sw_xoff cvmx_pko_l3_sqx_sw_xoff_t;
 
@@ -6037,7 +6442,9 @@ union cvmx_pko_l3_sqx_topology {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l3_sqx_topology_cn73xx cn75xx;
 	struct cvmx_pko_l3_sqx_topology_s     cn78xx;
+	struct cvmx_pko_l3_sqx_topology_s     cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_topology cvmx_pko_l3_sqx_topology_t;
 
@@ -6070,7 +6477,9 @@ union cvmx_pko_l3_sqx_yellow {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} cn73xx;
+	struct cvmx_pko_l3_sqx_yellow_cn73xx  cn75xx;
 	struct cvmx_pko_l3_sqx_yellow_s       cn78xx;
+	struct cvmx_pko_l3_sqx_yellow_s       cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqx_yellow cvmx_pko_l3_sqx_yellow_t;
 
@@ -6087,7 +6496,9 @@ union cvmx_pko_l3_sq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_l3_sq_csr_bus_debug_s cn73xx;
+	struct cvmx_pko_l3_sq_csr_bus_debug_s cn75xx;
 	struct cvmx_pko_l3_sq_csr_bus_debug_s cn78xx;
+	struct cvmx_pko_l3_sq_csr_bus_debug_s cn78xxp2;
 };
 typedef union cvmx_pko_l3_sq_csr_bus_debug cvmx_pko_l3_sq_csr_bus_debug_t;
 
@@ -6107,7 +6518,9 @@ union cvmx_pko_l3_sqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqa_debug_s        cn73xx;
+	struct cvmx_pko_l3_sqa_debug_s        cn75xx;
 	struct cvmx_pko_l3_sqa_debug_s        cn78xx;
+	struct cvmx_pko_l3_sqa_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqa_debug cvmx_pko_l3_sqa_debug_t;
 
@@ -6127,7 +6540,9 @@ union cvmx_pko_l3_sqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_l3_sqb_debug_s        cn73xx;
+	struct cvmx_pko_l3_sqb_debug_s        cn75xx;
 	struct cvmx_pko_l3_sqb_debug_s        cn78xx;
+	struct cvmx_pko_l3_sqb_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l3_sqb_debug cvmx_pko_l3_sqb_debug_t;
 
@@ -6176,6 +6591,7 @@ union cvmx_pko_l4_sqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_cir_s          cn78xx;
+	struct cvmx_pko_l4_sqx_cir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_cir cvmx_pko_l4_sqx_cir_t;
 
@@ -6204,6 +6620,7 @@ union cvmx_pko_l4_sqx_green {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_green_s        cn78xx;
+	struct cvmx_pko_l4_sqx_green_s        cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_green cvmx_pko_l4_sqx_green_t;
 
@@ -6211,7 +6628,7 @@ typedef union cvmx_pko_l4_sqx_green cvmx_pko_l4_sqx_green_t;
  * cvmx_pko_l4_sq#_pick
  *
  * This CSR contains the meta for the L4 SQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_l4_sqx_pick {
 	uint64_t u64;
@@ -6226,31 +6643,42 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -6270,6 +6698,7 @@ union cvmx_pko_l4_sqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_pick_s         cn78xx;
+	struct cvmx_pko_l4_sqx_pick_s         cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_pick cvmx_pko_l4_sqx_pick_t;
 
@@ -6318,6 +6747,7 @@ union cvmx_pko_l4_sqx_pir {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_pir_s          cn78xx;
+	struct cvmx_pko_l4_sqx_pir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_pir cvmx_pko_l4_sqx_pir_t;
 
@@ -6340,6 +6770,7 @@ union cvmx_pko_l4_sqx_pointers {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_pointers_s     cn78xx;
+	struct cvmx_pko_l4_sqx_pointers_s     cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_pointers cvmx_pko_l4_sqx_pointers_t;
 
@@ -6363,6 +6794,7 @@ union cvmx_pko_l4_sqx_red {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_red_s          cn78xx;
+	struct cvmx_pko_l4_sqx_red_s          cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_red cvmx_pko_l4_sqx_red_t;
 
@@ -6384,6 +6816,7 @@ union cvmx_pko_l4_sqx_sched_state {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_sched_state_s  cn78xx;
+	struct cvmx_pko_l4_sqx_sched_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_sched_state cvmx_pko_l4_sqx_sched_state_t;
 
@@ -6406,14 +6839,9 @@ union cvmx_pko_l4_sqx_schedule {
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
                                                          integer). The packet size used in all DWRR (RR_COUNT) calculations is:
-                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
-                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
-                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
-                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor.
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_nm_PICK[LENGTH] + PKO_nm_PICK[ADJUST]))
+                                                            + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR.
                                                          Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
                                                          negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
@@ -6423,6 +6851,7 @@ union cvmx_pko_l4_sqx_schedule {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_schedule_s     cn78xx;
+	struct cvmx_pko_l4_sqx_schedule_s     cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_schedule cvmx_pko_l4_sqx_schedule_t;
 
@@ -6455,6 +6884,7 @@ union cvmx_pko_l4_sqx_shape {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_shape_s        cn78xx;
+	struct cvmx_pko_l4_sqx_shape_s        cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_shape cvmx_pko_l4_sqx_shape_t;
 
@@ -6486,6 +6916,7 @@ union cvmx_pko_l4_sqx_shape_state {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_shape_state_s  cn78xx;
+	struct cvmx_pko_l4_sqx_shape_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_shape_state cvmx_pko_l4_sqx_shape_state_t;
 
@@ -6534,6 +6965,7 @@ union cvmx_pko_l4_sqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_sw_xoff_s      cn78xx;
+	struct cvmx_pko_l4_sqx_sw_xoff_s      cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_sw_xoff cvmx_pko_l4_sqx_sw_xoff_t;
 
@@ -6562,6 +6994,7 @@ union cvmx_pko_l4_sqx_topology {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_topology_s     cn78xx;
+	struct cvmx_pko_l4_sqx_topology_s     cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_topology cvmx_pko_l4_sqx_topology_t;
 
@@ -6585,6 +7018,7 @@ union cvmx_pko_l4_sqx_yellow {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_yellow_s       cn78xx;
+	struct cvmx_pko_l4_sqx_yellow_s       cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqx_yellow cvmx_pko_l4_sqx_yellow_t;
 
@@ -6601,6 +7035,7 @@ union cvmx_pko_l4_sq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_l4_sq_csr_bus_debug_s cn78xx;
+	struct cvmx_pko_l4_sq_csr_bus_debug_s cn78xxp2;
 };
 typedef union cvmx_pko_l4_sq_csr_bus_debug cvmx_pko_l4_sq_csr_bus_debug_t;
 
@@ -6620,6 +7055,7 @@ union cvmx_pko_l4_sqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqa_debug_s        cn78xx;
+	struct cvmx_pko_l4_sqa_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqa_debug cvmx_pko_l4_sqa_debug_t;
 
@@ -6639,6 +7075,7 @@ union cvmx_pko_l4_sqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_l4_sqb_debug_s        cn78xx;
+	struct cvmx_pko_l4_sqb_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l4_sqb_debug cvmx_pko_l4_sqb_debug_t;
 
@@ -6687,6 +7124,7 @@ union cvmx_pko_l5_sqx_cir {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_cir_s          cn78xx;
+	struct cvmx_pko_l5_sqx_cir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_cir cvmx_pko_l5_sqx_cir_t;
 
@@ -6715,6 +7153,7 @@ union cvmx_pko_l5_sqx_green {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_green_s        cn78xx;
+	struct cvmx_pko_l5_sqx_green_s        cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_green cvmx_pko_l5_sqx_green_t;
 
@@ -6722,7 +7161,7 @@ typedef union cvmx_pko_l5_sqx_green cvmx_pko_l5_sqx_green_t;
  * cvmx_pko_l5_sq#_pick
  *
  * This CSR contains the meta for the L5 SQ, and is for debug and reconfiguration
- * only and should never be written.
+ * only and should never be written. See also PKO_META_DESC_S.
  */
 union cvmx_pko_l5_sqx_pick {
 	uint64_t u64;
@@ -6737,31 +7176,42 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S.  See also
+                                                         PKO_META_DESC_S[JUMP]. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline.
+                                                         See also PKO_META_DESC_S[FPD]. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero.
+                                                         See also PKO_META_DESC_S[DS]. */
 	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
                                                          and all other fields in this CSR are invalid and shouldn't be used.
                                                          When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
-                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. See also
+                                                         PKO_META_DESC_S[ADJUST]. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[COL<1>]. */
 	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
-                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
                                                          present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
-                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. See also
+                                                         PKO_META_DESC_S[COL<0>]. */
 	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
                                                          (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
-                                                         shapers, but not used by the L1 rate limiters. */
-	uint64_t length                       : 16; /**< The packet length in bytes including pad.
-                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
-                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
-                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
-                                                         DQ the packet used. */
+                                                         shapers, but not used by the L1 rate limiters. See also PKO_META_DESC_S[RA]. */
+	uint64_t length                       : 16; /**< Meta packet length. Generally, the size of the outgoing packet
+                                                         including pad, but excluding FCS and preamble.
+                                                         For metas corresponding to non-PKO_SEND_TSO_S descriptors:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(PKO_SEND_HDR_S[TOTAL], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       PKO_SEND_HDR_S[TOTAL]
+                                                         For metas corresponding to PKO_SEND_TSO_S TSO packet segments:
+                                                          [LENGTH] = PKO_PDM_DQd_MINPAD[MINPAD] ?
+                                                                       MAX(FPS+PKO_SEND_TSO_S[SB], PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                       (FPS+PKO_SEND_TSO_S[SB])
+                                                         d is the DQ that the PKO SEND used. FPS is the number of payload bytes
+                                                         in the TSO segment (see PKO_SEND_TSO_S). See also PKO_META_DESC_S[LENGTH]. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -6781,6 +7231,7 @@ union cvmx_pko_l5_sqx_pick {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_pick_s         cn78xx;
+	struct cvmx_pko_l5_sqx_pick_s         cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_pick cvmx_pko_l5_sqx_pick_t;
 
@@ -6829,6 +7280,7 @@ union cvmx_pko_l5_sqx_pir {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_pir_s          cn78xx;
+	struct cvmx_pko_l5_sqx_pir_s          cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_pir cvmx_pko_l5_sqx_pir_t;
 
@@ -6854,6 +7306,7 @@ union cvmx_pko_l5_sqx_pointers {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_pointers_s     cn78xx;
+	struct cvmx_pko_l5_sqx_pointers_s     cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_pointers cvmx_pko_l5_sqx_pointers_t;
 
@@ -6877,6 +7330,7 @@ union cvmx_pko_l5_sqx_red {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_red_s          cn78xx;
+	struct cvmx_pko_l5_sqx_red_s          cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_red cvmx_pko_l5_sqx_red_t;
 
@@ -6898,6 +7352,7 @@ union cvmx_pko_l5_sqx_sched_state {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_sched_state_s  cn78xx;
+	struct cvmx_pko_l5_sqx_sched_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_sched_state cvmx_pko_l5_sqx_sched_state_t;
 
@@ -6920,14 +7375,9 @@ union cvmx_pko_l5_sqx_schedule {
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
                                                          integer). The packet size used in all DWRR (RR_COUNT) calculations is:
-                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
-                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
-                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
-                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor.
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_nm_PICK[LENGTH] + PKO_nm_PICK[ADJUST]))
+                                                            + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR.
                                                          Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
                                                          negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
@@ -6937,6 +7387,7 @@ union cvmx_pko_l5_sqx_schedule {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_schedule_s     cn78xx;
+	struct cvmx_pko_l5_sqx_schedule_s     cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_schedule cvmx_pko_l5_sqx_schedule_t;
 
@@ -6966,6 +7417,7 @@ union cvmx_pko_l5_sqx_shape {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_shape_s        cn78xx;
+	struct cvmx_pko_l5_sqx_shape_s        cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_shape cvmx_pko_l5_sqx_shape_t;
 
@@ -6997,6 +7449,7 @@ union cvmx_pko_l5_sqx_shape_state {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_shape_state_s  cn78xx;
+	struct cvmx_pko_l5_sqx_shape_state_s  cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_shape_state cvmx_pko_l5_sqx_shape_state_t;
 
@@ -7045,6 +7498,7 @@ union cvmx_pko_l5_sqx_sw_xoff {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_sw_xoff_s      cn78xx;
+	struct cvmx_pko_l5_sqx_sw_xoff_s      cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_sw_xoff cvmx_pko_l5_sqx_sw_xoff_t;
 
@@ -7073,6 +7527,7 @@ union cvmx_pko_l5_sqx_topology {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_topology_s     cn78xx;
+	struct cvmx_pko_l5_sqx_topology_s     cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_topology cvmx_pko_l5_sqx_topology_t;
 
@@ -7096,6 +7551,7 @@ union cvmx_pko_l5_sqx_yellow {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_yellow_s       cn78xx;
+	struct cvmx_pko_l5_sqx_yellow_s       cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqx_yellow cvmx_pko_l5_sqx_yellow_t;
 
@@ -7112,6 +7568,7 @@ union cvmx_pko_l5_sq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_l5_sq_csr_bus_debug_s cn78xx;
+	struct cvmx_pko_l5_sq_csr_bus_debug_s cn78xxp2;
 };
 typedef union cvmx_pko_l5_sq_csr_bus_debug cvmx_pko_l5_sq_csr_bus_debug_t;
 
@@ -7131,6 +7588,7 @@ union cvmx_pko_l5_sqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqa_debug_s        cn78xx;
+	struct cvmx_pko_l5_sqa_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqa_debug cvmx_pko_l5_sqa_debug_t;
 
@@ -7150,6 +7608,7 @@ union cvmx_pko_l5_sqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_l5_sqb_debug_s        cn78xx;
+	struct cvmx_pko_l5_sqb_debug_s        cn78xxp2;
 };
 typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
 
@@ -7214,7 +7673,9 @@ union cvmx_pko_lutx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_pko_lutx_cn73xx           cn75xx;
 	struct cvmx_pko_lutx_s                cn78xx;
+	struct cvmx_pko_lutx_s                cn78xxp2;
 };
 typedef union cvmx_pko_lutx cvmx_pko_lutx_t;
 
@@ -7233,7 +7694,9 @@ union cvmx_pko_lut_bist_status {
 #endif
 	} s;
 	struct cvmx_pko_lut_bist_status_s     cn73xx;
+	struct cvmx_pko_lut_bist_status_s     cn75xx;
 	struct cvmx_pko_lut_bist_status_s     cn78xx;
+	struct cvmx_pko_lut_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_pko_lut_bist_status cvmx_pko_lut_bist_status_t;
 
@@ -7254,7 +7717,9 @@ union cvmx_pko_lut_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_pko_lut_ecc_ctl0_s        cn73xx;
+	struct cvmx_pko_lut_ecc_ctl0_s        cn75xx;
 	struct cvmx_pko_lut_ecc_ctl0_s        cn78xx;
+	struct cvmx_pko_lut_ecc_ctl0_s        cn78xxp2;
 };
 typedef union cvmx_pko_lut_ecc_ctl0 cvmx_pko_lut_ecc_ctl0_t;
 
@@ -7274,7 +7739,9 @@ union cvmx_pko_lut_ecc_dbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn73xx;
+	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn75xx;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn78xx;
+	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts0 cvmx_pko_lut_ecc_dbe_sts0_t;
 
@@ -7297,7 +7764,9 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts_cmb0 cvmx_pko_lut_ecc_dbe_sts_cmb0_t;
 
@@ -7317,7 +7786,9 @@ union cvmx_pko_lut_ecc_sbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn73xx;
+	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn75xx;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn78xx;
+	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts0 cvmx_pko_lut_ecc_sbe_sts0_t;
 
@@ -7340,7 +7811,9 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
 
@@ -7375,7 +7848,9 @@ union cvmx_pko_macx_cfg {
 	struct cvmx_pko_macx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_17_63               : 47;
-	uint64_t min_pad_ena                  : 1;  /**< Minimum padding is enabled for this MAC/FIFO. */
+	uint64_t min_pad_ena                  : 1;  /**< Minimum padding enable. When [MIN_PAD_ENA] is set, PKO pads packets going
+                                                         through the MAC/FIFO (with zeroes) to a minimum of PKO_PDM_CFG[PKO_PAD_MINLEN]
+                                                         bytes. */
 	uint64_t fcs_ena                      : 1;  /**< Enable outside FCS for this MAC/FIFO. */
 	uint64_t fcs_sop_off                  : 8;  /**< FCS start of packet offset. For this MAC, the number of bytes in the front of each packet
                                                          to exclude from FCS. */
@@ -7396,7 +7871,9 @@ union cvmx_pko_macx_cfg {
 #endif
 	} s;
 	struct cvmx_pko_macx_cfg_s            cn73xx;
+	struct cvmx_pko_macx_cfg_s            cn75xx;
 	struct cvmx_pko_macx_cfg_s            cn78xx;
+	struct cvmx_pko_macx_cfg_s            cn78xxp2;
 };
 typedef union cvmx_pko_macx_cfg cvmx_pko_macx_cfg_t;
 
@@ -7408,13 +7885,14 @@ union cvmx_pko_mci0_cred_cntx {
 	struct cvmx_pko_mci0_cred_cntx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t cred_cnt                     : 13; /**< Credit count. */
+	uint64_t cred_cnt                     : 13; /**< Reserved. */
 #else
 	uint64_t cred_cnt                     : 13;
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
 	struct cvmx_pko_mci0_cred_cntx_s      cn78xx;
+	struct cvmx_pko_mci0_cred_cntx_s      cn78xxp2;
 };
 typedef union cvmx_pko_mci0_cred_cntx cvmx_pko_mci0_cred_cntx_t;
 
@@ -7426,15 +7904,14 @@ union cvmx_pko_mci0_max_credx {
 	struct cvmx_pko_mci0_max_credx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t max_cred_lim                 : 12; /**< Max credit limit.  Should be set to (FIFO_CREDIT - MAC_CREDIT) / 16, where FIFO_CREDIT
-                                                         is the size of the TxFIFO for this MAC (2560, 5120 or 10240), and MAC_CREDIT is the size
-                                                         of the MAC FIFO. */
+	uint64_t max_cred_lim                 : 12; /**< Reserved. */
 #else
 	uint64_t max_cred_lim                 : 12;
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
 	struct cvmx_pko_mci0_max_credx_s      cn78xx;
+	struct cvmx_pko_mci0_max_credx_s      cn78xxp2;
 };
 typedef union cvmx_pko_mci0_max_credx cvmx_pko_mci0_max_credx_t;
 
@@ -7453,7 +7930,9 @@ union cvmx_pko_mci1_cred_cntx {
 #endif
 	} s;
 	struct cvmx_pko_mci1_cred_cntx_s      cn73xx;
+	struct cvmx_pko_mci1_cred_cntx_s      cn75xx;
 	struct cvmx_pko_mci1_cred_cntx_s      cn78xx;
+	struct cvmx_pko_mci1_cred_cntx_s      cn78xxp2;
 };
 typedef union cvmx_pko_mci1_cred_cntx cvmx_pko_mci1_cred_cntx_t;
 
@@ -7473,7 +7952,9 @@ union cvmx_pko_mci1_max_credx {
 #endif
 	} s;
 	struct cvmx_pko_mci1_max_credx_s      cn73xx;
+	struct cvmx_pko_mci1_max_credx_s      cn75xx;
 	struct cvmx_pko_mci1_max_credx_s      cn78xx;
+	struct cvmx_pko_mci1_max_credx_s      cn78xxp2;
 };
 typedef union cvmx_pko_mci1_max_credx cvmx_pko_mci1_max_credx_t;
 
@@ -9548,7 +10029,7 @@ union cvmx_pko_ncb_bist_status {
 	uint64_t ncbo_pdm_cmd_dat_ram_bist_status : 1;/**< BIST status for NCBO_PDM_CMD_DAT_RAM. */
 	uint64_t ncbi_l2_pdm_pref_ram_bist_status : 1;/**< BIST status for NCBI_L2_PDM_PREF_RAM. */
 	uint64_t ncbo_pp_fif_ram_bist_status  : 1;  /**< BIST status for NCBO_PP_FIF_RAM. */
-	uint64_t ncbo_skid_fif_ram_bist_status : 1; /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_bist_status : 1; /**< BIST status for NCBO_SKID_FIF_RAM. Added in pass 2. */
 	uint64_t reserved_0_57                : 58;
 #else
 	uint64_t reserved_0_57                : 58;
@@ -9561,7 +10042,9 @@ union cvmx_pko_ncb_bist_status {
 #endif
 	} s;
 	struct cvmx_pko_ncb_bist_status_s     cn73xx;
+	struct cvmx_pko_ncb_bist_status_s     cn75xx;
 	struct cvmx_pko_ncb_bist_status_s     cn78xx;
+	struct cvmx_pko_ncb_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_pko_ncb_bist_status cvmx_pko_ncb_bist_status_t;
 
@@ -9582,8 +10065,8 @@ union cvmx_pko_ncb_ecc_ctl0 {
 	uint64_t ncbi_l2_pdm_pref_ram_cdis    : 1;  /**< NCBI_L2_PDM_PREF_RAM ECC correction disable. */
 	uint64_t ncbo_pp_fif_ram_flip         : 2;  /**< NCBO_PP_FIF_RAM flip syndrome bits on write. */
 	uint64_t ncbo_pp_fif_ram_cdis         : 1;  /**< NCBO_PP_FIF_RAM ECC correction disable. */
-	uint64_t ncbo_skid_fif_ram_flip       : 2;  /**< Reserved. */
-	uint64_t ncbo_skid_fif_ram_cdis       : 1;  /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_flip       : 2;  /**< NCBO_SKID_FIF_RAM flip syndrome bits on write. Added in pass 2. */
+	uint64_t ncbo_skid_fif_ram_cdis       : 1;  /**< NCBO_SKID_FIF_RAM ECC correction disable. Added in pass 2. */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -9602,7 +10085,9 @@ union cvmx_pko_ncb_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_pko_ncb_ecc_ctl0_s        cn73xx;
+	struct cvmx_pko_ncb_ecc_ctl0_s        cn75xx;
 	struct cvmx_pko_ncb_ecc_ctl0_s        cn78xx;
+	struct cvmx_pko_ncb_ecc_ctl0_s        cn78xxp2;
 };
 typedef union cvmx_pko_ncb_ecc_ctl0 cvmx_pko_ncb_ecc_ctl0_t;
 
@@ -9623,7 +10108,10 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Double-bit error for NCBO_SKID_FIF_RAM.
+                                                         Added in pass 2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
 	uint64_t reserved_0_57                : 58;
 #else
 	uint64_t reserved_0_57                : 58;
@@ -9636,7 +10124,9 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn73xx;
+	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn75xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn78xx;
+	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts0 cvmx_pko_ncb_ecc_dbe_sts0_t;
 
@@ -9651,12 +10141,14 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
                                                          software
                                                          must clear bits in PKO_NCB_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
                                                          is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0.
+                                                         Changed in pass 2.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9664,7 +10156,9 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts_cmb0 cvmx_pko_ncb_ecc_dbe_sts_cmb0_t;
 
@@ -9685,7 +10179,10 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM.
+                                                         Added in pass 2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
 	uint64_t reserved_0_57                : 58;
 #else
 	uint64_t reserved_0_57                : 58;
@@ -9698,7 +10195,9 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn73xx;
+	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn75xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn78xx;
+	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts0 cvmx_pko_ncb_ecc_sbe_sts0_t;
 
@@ -9713,12 +10212,14 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
                                                          software
                                                          must clear bits in PKO_NCB_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
                                                          is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0.
+                                                         Changed in pass 2.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9726,7 +10227,9 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts_cmb0 cvmx_pko_ncb_ecc_sbe_sts_cmb0_t;
 
@@ -9760,7 +10263,9 @@ union cvmx_pko_ncb_int {
 #endif
 	} s;
 	struct cvmx_pko_ncb_int_s             cn73xx;
+	struct cvmx_pko_ncb_int_s             cn75xx;
 	struct cvmx_pko_ncb_int_s             cn78xx;
+	struct cvmx_pko_ncb_int_s             cn78xxp2;
 };
 typedef union cvmx_pko_ncb_int cvmx_pko_ncb_int_t;
 
@@ -9791,7 +10296,9 @@ union cvmx_pko_ncb_tx_err_info {
 #endif
 	} s;
 	struct cvmx_pko_ncb_tx_err_info_s     cn73xx;
+	struct cvmx_pko_ncb_tx_err_info_s     cn75xx;
 	struct cvmx_pko_ncb_tx_err_info_s     cn78xx;
+	struct cvmx_pko_ncb_tx_err_info_s     cn78xxp2;
 };
 typedef union cvmx_pko_ncb_tx_err_info cvmx_pko_ncb_tx_err_info_t;
 
@@ -9810,7 +10317,9 @@ union cvmx_pko_ncb_tx_err_word {
 #endif
 	} s;
 	struct cvmx_pko_ncb_tx_err_word_s     cn73xx;
+	struct cvmx_pko_ncb_tx_err_word_s     cn75xx;
 	struct cvmx_pko_ncb_tx_err_word_s     cn78xx;
+	struct cvmx_pko_ncb_tx_err_word_s     cn78xxp2;
 };
 typedef union cvmx_pko_ncb_tx_err_word cvmx_pko_ncb_tx_err_word_t;
 
@@ -9850,9 +10359,9 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t flshb_m_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
 	uint64_t flshb_d_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
 	uint64_t minpad_ram_bist_status       : 1;  /**< BIST status for MINPAD_RAM. */
-	uint64_t mwp_hi_spt_ram_bist_status   : 1;  /**< Reserved. */
-	uint64_t mwp_lo_spt_ram_bist_status   : 1;  /**< Reserved. */
-	uint64_t buf_wm_ram_bist_status       : 1;  /**< Reserved. */
+	uint64_t mwp_hi_spt_ram_bist_status   : 1;  /**< BIST status for MWP_RAM_MEM3. */
+	uint64_t mwp_lo_spt_ram_bist_status   : 1;  /**< BIST status for MWP_RAM_MEM1. */
+	uint64_t buf_wm_ram_bist_status       : 1;  /**< BIST status for BUF_WM_RAM. */
 	uint64_t reserved_0_34                : 35;
 #else
 	uint64_t reserved_0_34                : 35;
@@ -9888,7 +10397,9 @@ union cvmx_pko_pdm_bist_status {
 #endif
 	} s;
 	struct cvmx_pko_pdm_bist_status_s     cn73xx;
+	struct cvmx_pko_pdm_bist_status_s     cn75xx;
 	struct cvmx_pko_pdm_bist_status_s     cn78xx;
+	struct cvmx_pko_pdm_bist_status_s     cn78xxp2;
 };
 typedef union cvmx_pko_pdm_bist_status cvmx_pko_pdm_bist_status_t;
 
@@ -9907,12 +10418,15 @@ union cvmx_pko_pdm_cfg {
                                                          DQ). For diagnostic use only. */
 	uint64_t dis_flsh_cache               : 1;  /**< Set to disable the flush buffer's cache. This makes all fills require full memory latency.
                                                          For diagnostic use only. */
-	uint64_t pko_pad_minlen               : 7;  /**< Minimum frame padding min length. */
+	uint64_t pko_pad_minlen               : 7;  /**< Minimum frame padding min length. Padding is enabled by PKO_MAC*_CFG[MIN_PAD_ENA]. See
+                                                         also PKO_PDM_DQ*_MINPAD[MINPAD]. */
 	uint64_t diag_mode                    : 1;  /**< Set to enable read/write to memories in PDM through CSR interface. For diagnostic use only. */
 	uint64_t alloc_lds                    : 1;  /**< Allocate LDS. This signal prevents the loads to IOBP from being allocated in on-chip cache
-                                                         (LDWB vs. LDD). Two modes as follows: 0 = No allocate (LDWB); 1 = Allocate (LDD). */
+                                                         (LDWB vs. LDD). Two modes as follows: 0 = No allocate (LDWB); 1 = Allocate (LDD).
+                                                         PKO PDM refetches DQ metas and descriptors via IOBP loads. */
 	uint64_t alloc_sts                    : 1;  /**< Allocate STS. This signal prevents the stores to NCB from being allocated in on-chip cache
-                                                         (STF vs. STT). Two modes as follows: 0 = No allocate (STT); 1 = Allocate (STF). */
+                                                         (STF vs. STT). Two modes as follows: 0 = No allocate (STT); 1 = Allocate (STF).
+                                                         PKO PDM stores DQ meta and descriptor overflow data via NCB. */
 #else
 	uint64_t alloc_sts                    : 1;
 	uint64_t alloc_lds                    : 1;
@@ -9925,7 +10439,9 @@ union cvmx_pko_pdm_cfg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_cfg_s             cn73xx;
+	struct cvmx_pko_pdm_cfg_s             cn75xx;
 	struct cvmx_pko_pdm_cfg_s             cn78xx;
+	struct cvmx_pko_pdm_cfg_s             cn78xxp2;
 };
 typedef union cvmx_pko_pdm_cfg cvmx_pko_pdm_cfg_t;
 
@@ -9947,7 +10463,9 @@ union cvmx_pko_pdm_cfg_dbg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_cfg_dbg_s         cn73xx;
+	struct cvmx_pko_pdm_cfg_dbg_s         cn75xx;
 	struct cvmx_pko_pdm_cfg_dbg_s         cn78xx;
+	struct cvmx_pko_pdm_cfg_dbg_s         cn78xxp2;
 };
 typedef union cvmx_pko_pdm_cfg_dbg cvmx_pko_pdm_cfg_dbg_t;
 
@@ -9975,7 +10493,9 @@ union cvmx_pko_pdm_cp_dbg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_cp_dbg_s          cn73xx;
+	struct cvmx_pko_pdm_cp_dbg_s          cn75xx;
 	struct cvmx_pko_pdm_cp_dbg_s          cn78xx;
+	struct cvmx_pko_pdm_cp_dbg_s          cn78xxp2;
 };
 typedef union cvmx_pko_pdm_cp_dbg cvmx_pko_pdm_cp_dbg_t;
 
@@ -9988,17 +10508,25 @@ union cvmx_pko_pdm_dqx_minpad {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t minpad                       : 1;  /**< MINPAD setting per DQ. Each DQ has a separate CSR address; and bit 0 of the data
-                                                         read/write value is the MINPAD bit. When MINPAD is set, the send-packet header has the
-                                                         total field adjusted by MINLEN (PKO_PDM_CFG[PKO_PAD_MINLEN]) as follows:
-                                                         if (MINPAD)
-                                                         if (send_hdr.total < MINLEN) send_hdr.total = MINLEN */
+                                                         read/write value is [MINPAD]. [MINPAD] adjusts the meta length field based on
+                                                         the min packet length as follows:
+                                                             Meta[LENGTH] = [MINPAD] ?
+                                                                               MAX(X, PKO_PDM_CFG[PKO_PAD_MINLEN]) :
+                                                                               X
+                                                         where X is the packet/segment length before pad. PKO_META_DESC_S[LENGTH]
+                                                         and PKO_*_PICK[LENGTH] are Meta[LENGTH].
+                                                         [MINPAD] doesn't affect whether PKO applies pad to the packet or not,
+                                                         PKO_MAC*_CFG[MIN_PAD_ENA] does. When PKO_MAC*_CFG[MIN_PAD_ENA] is set,
+                                                         PKO pads packets through the MAC to PKO_PDM_CFG[PKO_PAD_MINLEN] bytes. */
 #else
 	uint64_t minpad                       : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
 	struct cvmx_pko_pdm_dqx_minpad_s      cn73xx;
+	struct cvmx_pko_pdm_dqx_minpad_s      cn75xx;
 	struct cvmx_pko_pdm_dqx_minpad_s      cn78xx;
+	struct cvmx_pko_pdm_dqx_minpad_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_dqx_minpad cvmx_pko_pdm_dqx_minpad_t;
 
@@ -10039,7 +10567,9 @@ union cvmx_pko_pdm_drpbuf_dbg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_drpbuf_dbg_s      cn73xx;
+	struct cvmx_pko_pdm_drpbuf_dbg_s      cn75xx;
 	struct cvmx_pko_pdm_drpbuf_dbg_s      cn78xx;
+	struct cvmx_pko_pdm_drpbuf_dbg_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_drpbuf_dbg cvmx_pko_pdm_drpbuf_dbg_t;
 
@@ -10051,21 +10581,21 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	struct cvmx_pko_pdm_dwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t cmd_proc                     : 1;  /**< Reserved. */
+	uint64_t cmd_proc                     : 1;  /**< Command process signal. */
 	uint64_t reserved_46_46               : 1;
-	uint64_t mem_data_val                 : 1;  /**< Reserved. */
-	uint64_t insert_np                    : 1;  /**< Reserved. */
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion signal. */
 	uint64_t reserved_43_43               : 1;
 	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
 	uint64_t load_val                     : 1;  /**< Load valid signal. */
 	uint64_t rdy                          : 1;  /**< Ready signal. */
-	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
-	uint64_t mem_rdy                      : 1;  /**< Reserved. */
+	uint64_t cur_state                    : 3;  /**< Reserved. */
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready signal. */
 	uint64_t reserved_33_35               : 3;
-	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
-	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
+	uint64_t track_rd_cnt                 : 6;  /**< Reserved. */
+	uint64_t track_wr_cnt                 : 6;  /**< Reserved. */
 	uint64_t reserved_19_20               : 2;
-	uint64_t insert_dp                    : 2;  /**< Reserved. */
+	uint64_t insert_dp                    : 2;  /**< Descriptor insertion signals. */
 	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
 	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
                                                          0x3 = Low wen.
@@ -10134,7 +10664,9 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pdm_dwpbuf_dbg_cn73xx cn75xx;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xx;
+	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_dwpbuf_dbg cvmx_pko_pdm_dwpbuf_dbg_t;
 
@@ -10175,10 +10707,10 @@ union cvmx_pko_pdm_ecc_ctl0 {
 	uint64_t dwp_hi_ram_cdis              : 1;  /**< DWP_HI_RAM ECC correction disable. */
 	uint64_t dwp_lo_ram_flip              : 2;  /**< DWP_LO_RAM flip syndrome bits on write. */
 	uint64_t dwp_lo_ram_cdis              : 1;  /**< DWP_LO_RAM ECC correction disable. */
-	uint64_t mwp_hi_ram_flip              : 2;  /**< MWP_HI_RAM flip syndrome bits on write. */
-	uint64_t mwp_hi_ram_cdis              : 1;  /**< MWP_HI_RAM ECC correction disable. */
-	uint64_t mwp_lo_ram_flip              : 2;  /**< MWP_LO_RAM flip syndrome bits on write. */
-	uint64_t mwp_lo_ram_cdis              : 1;  /**< MWP_LO_RAM ECC correction disable. */
+	uint64_t mwp_hi_ram_flip              : 2;  /**< Reserved. */
+	uint64_t mwp_hi_ram_cdis              : 1;  /**< Reserved. */
+	uint64_t mwp_lo_ram_flip              : 2;  /**< Reserved. */
+	uint64_t mwp_lo_ram_cdis              : 1;  /**< Reserved. */
 	uint64_t fillb_m_rsp_ram_hi_flip      : 2;  /**< FILLB_M_RSP_RAM_HI flip syndrome bits on write. */
 	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;  /**< FILLB_M_RSP_RAM_HI ECC correction disable. */
 	uint64_t fillb_m_rsp_ram_lo_flip      : 2;  /**< FILLB_M_RSP_RAM_LO flip syndrome bits on write. */
@@ -10319,7 +10851,9 @@ union cvmx_pko_pdm_ecc_ctl0 {
 	uint64_t flshb_cache_lo_ram_flip      : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pdm_ecc_ctl0_cn73xx   cn75xx;
 	struct cvmx_pko_pdm_ecc_ctl0_s        cn78xx;
+	struct cvmx_pko_pdm_ecc_ctl0_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_ctl0 cvmx_pko_pdm_ecc_ctl0_t;
 
@@ -10331,13 +10865,13 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	struct cvmx_pko_pdm_ecc_ctl1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t buf_wm_ram_flip              : 2;  /**< Reserved. */
-	uint64_t buf_wm_ram_cdis              : 1;  /**< Reserved. */
-	uint64_t mwp_mem0_ram_flip            : 2;  /**< Reserved. */
-	uint64_t mwp_mem1_ram_flip            : 2;  /**< Reserved. */
-	uint64_t mwp_mem2_ram_flip            : 2;  /**< Reserved. */
-	uint64_t mwp_mem3_ram_flip            : 2;  /**< Reserved. */
-	uint64_t mwp_ram_cdis                 : 1;  /**< Reserved. */
+	uint64_t buf_wm_ram_flip              : 2;  /**< BUF_WM_RAM flip syndrome bits on write. */
+	uint64_t buf_wm_ram_cdis              : 1;  /**< BUF_WM_RAM ECC correction disable for all four memories */
+	uint64_t mwp_mem0_ram_flip            : 2;  /**< MWP_MEM0_RAM flip syndrome bits on write. */
+	uint64_t mwp_mem1_ram_flip            : 2;  /**< MWP_MEM1_RAM flip syndrome bits on write. */
+	uint64_t mwp_mem2_ram_flip            : 2;  /**< MWP_MEM2_RAM flip syndrome bits on write. */
+	uint64_t mwp_mem3_ram_flip            : 2;  /**< MWP_MEM3_RAM flip syndrome bits on write. */
+	uint64_t mwp_ram_cdis                 : 1;  /**< MWP_RAM ECC correction disable for all four memories */
 	uint64_t minpad_ram_flip              : 2;  /**< MINPAD_RAM flip syndrome bits on write. */
 	uint64_t minpad_ram_cdis              : 1;  /**< MINPAD_RAM ECC correction disable. */
 #else
@@ -10354,7 +10888,9 @@ union cvmx_pko_pdm_ecc_ctl1 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn73xx;
+	struct cvmx_pko_pdm_ecc_ctl1_s        cn75xx;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
+	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_ctl1 cvmx_pko_pdm_ecc_ctl1_t;
 
@@ -10408,9 +10944,11 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
 	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Reserved. */
-	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Reserved. */
-	uint64_t buf_wm_ram_dbe               : 1;  /**< Reserved. */
+	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM3. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem3 */
+	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM1. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem1 */
+	uint64_t buf_wm_ram_dbe               : 1;  /**< Double-bit error for BUF_WM_RAM. */
 	uint64_t reserved_0_38                : 39;
 #else
 	uint64_t reserved_0_38                : 39;
@@ -10442,7 +10980,9 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn73xx;
+	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn75xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn78xx;
+	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts0 cvmx_pko_pdm_ecc_dbe_sts0_t;
 
@@ -10485,7 +11025,9 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts_cmb0 cvmx_pko_pdm_ecc_dbe_sts_cmb0_t;
 
@@ -10539,9 +11081,11 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_LO. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
 	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Reserved. */
-	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Reserved. */
-	uint64_t buf_wm_ram_sbe               : 1;  /**< Reserved. */
+	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM3. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem3 */
+	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM1. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem1 */
+	uint64_t buf_wm_ram_sbe               : 1;  /**< Single-bit error for BUF_WM_RAM. */
 	uint64_t reserved_0_38                : 39;
 #else
 	uint64_t reserved_0_38                : 39;
@@ -10573,7 +11117,9 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn73xx;
+	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn75xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn78xx;
+	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts0 cvmx_pko_pdm_ecc_sbe_sts0_t;
 
@@ -10616,7 +11162,9 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts_cmb0 cvmx_pko_pdm_ecc_sbe_sts_cmb0_t;
 
@@ -10657,7 +11205,9 @@ union cvmx_pko_pdm_fillb_dbg0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_fillb_dbg0_s      cn73xx;
+	struct cvmx_pko_pdm_fillb_dbg0_s      cn75xx;
 	struct cvmx_pko_pdm_fillb_dbg0_s      cn78xx;
+	struct cvmx_pko_pdm_fillb_dbg0_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_fillb_dbg0 cvmx_pko_pdm_fillb_dbg0_t;
 
@@ -10698,7 +11248,9 @@ union cvmx_pko_pdm_fillb_dbg1 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_fillb_dbg1_s      cn73xx;
+	struct cvmx_pko_pdm_fillb_dbg1_s      cn75xx;
 	struct cvmx_pko_pdm_fillb_dbg1_s      cn78xx;
+	struct cvmx_pko_pdm_fillb_dbg1_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_fillb_dbg1 cvmx_pko_pdm_fillb_dbg1_t;
 
@@ -10721,7 +11273,9 @@ union cvmx_pko_pdm_fillb_dbg2 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_fillb_dbg2_s      cn73xx;
+	struct cvmx_pko_pdm_fillb_dbg2_s      cn75xx;
 	struct cvmx_pko_pdm_fillb_dbg2_s      cn78xx;
+	struct cvmx_pko_pdm_fillb_dbg2_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_fillb_dbg2 cvmx_pko_pdm_fillb_dbg2_t;
 
@@ -10754,7 +11308,9 @@ union cvmx_pko_pdm_flshb_dbg0 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_flshb_dbg0_s      cn73xx;
+	struct cvmx_pko_pdm_flshb_dbg0_s      cn75xx;
 	struct cvmx_pko_pdm_flshb_dbg0_s      cn78xx;
+	struct cvmx_pko_pdm_flshb_dbg0_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_flshb_dbg0 cvmx_pko_pdm_flshb_dbg0_t;
 
@@ -10773,7 +11329,9 @@ union cvmx_pko_pdm_flshb_dbg1 {
 #endif
 	} s;
 	struct cvmx_pko_pdm_flshb_dbg1_s      cn73xx;
+	struct cvmx_pko_pdm_flshb_dbg1_s      cn75xx;
 	struct cvmx_pko_pdm_flshb_dbg1_s      cn78xx;
+	struct cvmx_pko_pdm_flshb_dbg1_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_flshb_dbg1 cvmx_pko_pdm_flshb_dbg1_t;
 
@@ -10805,6 +11363,8 @@ union cvmx_pko_pdm_intf_dbg_rd {
 #endif
 	} s;
 	struct cvmx_pko_pdm_intf_dbg_rd_s     cn73xx;
+	struct cvmx_pko_pdm_intf_dbg_rd_s     cn75xx;
+	struct cvmx_pko_pdm_intf_dbg_rd_s     cn78xxp2;
 };
 typedef union cvmx_pko_pdm_intf_dbg_rd cvmx_pko_pdm_intf_dbg_rd_t;
 
@@ -10881,7 +11441,9 @@ union cvmx_pko_pdm_isrd_dbg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_isrd_dbg_s        cn73xx;
+	struct cvmx_pko_pdm_isrd_dbg_s        cn75xx;
 	struct cvmx_pko_pdm_isrd_dbg_s        cn78xx;
+	struct cvmx_pko_pdm_isrd_dbg_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_isrd_dbg cvmx_pko_pdm_isrd_dbg_t;
 
@@ -10912,7 +11474,9 @@ union cvmx_pko_pdm_isrd_dbg_dq {
 #endif
 	} s;
 	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn73xx;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn75xx;
 	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn78xx;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn78xxp2;
 };
 typedef union cvmx_pko_pdm_isrd_dbg_dq cvmx_pko_pdm_isrd_dbg_dq_t;
 
@@ -10979,7 +11543,9 @@ union cvmx_pko_pdm_isrm_dbg {
 #endif
 	} s;
 	struct cvmx_pko_pdm_isrm_dbg_s        cn73xx;
+	struct cvmx_pko_pdm_isrm_dbg_s        cn75xx;
 	struct cvmx_pko_pdm_isrm_dbg_s        cn78xx;
+	struct cvmx_pko_pdm_isrm_dbg_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_isrm_dbg cvmx_pko_pdm_isrm_dbg_t;
 
@@ -11006,7 +11572,9 @@ union cvmx_pko_pdm_isrm_dbg_dq {
 #endif
 	} s;
 	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn73xx;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn75xx;
 	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn78xx;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn78xxp2;
 };
 typedef union cvmx_pko_pdm_isrm_dbg_dq cvmx_pko_pdm_isrm_dbg_dq_t;
 
@@ -11039,7 +11607,9 @@ union cvmx_pko_pdm_mem_addr {
 #endif
 	} s;
 	struct cvmx_pko_pdm_mem_addr_s        cn73xx;
+	struct cvmx_pko_pdm_mem_addr_s        cn75xx;
 	struct cvmx_pko_pdm_mem_addr_s        cn78xx;
+	struct cvmx_pko_pdm_mem_addr_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_mem_addr cvmx_pko_pdm_mem_addr_t;
 
@@ -11058,7 +11628,9 @@ union cvmx_pko_pdm_mem_data {
 #endif
 	} s;
 	struct cvmx_pko_pdm_mem_data_s        cn73xx;
+	struct cvmx_pko_pdm_mem_data_s        cn75xx;
 	struct cvmx_pko_pdm_mem_data_s        cn78xx;
+	struct cvmx_pko_pdm_mem_data_s        cn78xxp2;
 };
 typedef union cvmx_pko_pdm_mem_data cvmx_pko_pdm_mem_data_t;
 
@@ -11079,7 +11651,9 @@ union cvmx_pko_pdm_mem_rw_ctl {
 #endif
 	} s;
 	struct cvmx_pko_pdm_mem_rw_ctl_s      cn73xx;
+	struct cvmx_pko_pdm_mem_rw_ctl_s      cn75xx;
 	struct cvmx_pko_pdm_mem_rw_ctl_s      cn78xx;
+	struct cvmx_pko_pdm_mem_rw_ctl_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_mem_rw_ctl cvmx_pko_pdm_mem_rw_ctl_t;
 
@@ -11098,7 +11672,9 @@ union cvmx_pko_pdm_mem_rw_sts {
 #endif
 	} s;
 	struct cvmx_pko_pdm_mem_rw_sts_s      cn73xx;
+	struct cvmx_pko_pdm_mem_rw_sts_s      cn75xx;
 	struct cvmx_pko_pdm_mem_rw_sts_s      cn78xx;
+	struct cvmx_pko_pdm_mem_rw_sts_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_mem_rw_sts cvmx_pko_pdm_mem_rw_sts_t;
 
@@ -11110,22 +11686,27 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	struct cvmx_pko_pdm_mwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
-	uint64_t str_proc                     : 1;  /**< Reserved. */
-	uint64_t cmd_proc                     : 1;  /**< Reserved. */
-	uint64_t str_val                      : 1;  /**< Reserved. */
-	uint64_t mem_data_val                 : 1;  /**< Reserved. */
-	uint64_t insert_np                    : 1;  /**< Reserved. */
-	uint64_t insert_mp                    : 1;  /**< Reserved. */
+	uint64_t str_proc                     : 1;  /**< Stream process for data streaming. */
+	uint64_t cmd_proc                     : 1;  /**< Command process for memory-type instruction. */
+	uint64_t str_val                      : 1;  /**< streaming valid. */
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion. */
+	uint64_t insert_mp                    : 1;  /**< Meta-packet insertion. */
 	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
 	uint64_t load_val                     : 1;  /**< Load valid signal. */
 	uint64_t rdy                          : 1;  /**< Ready signal. */
 	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
-	uint64_t mem_rdy                      : 1;  /**< Rreserved */
-	uint64_t str_rdy                      : 1;  /**< Reserved. */
-	uint64_t contention_type              : 2;  /**< Reserved. */
-	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
-	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
-	uint64_t mem_wen                      : 4;  /**< Reserved. */
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready. */
+	uint64_t str_rdy                      : 1;  /**< Streaming logic ready. */
+	uint64_t contention_type              : 2;  /**< Contention detected and type mwpbuf__csr_conflict[1:0] bit 0 - a streamFill followed by a
+                                                         flush (same dq, same dst) bit 1 - a flush followed by a stream (same dq, same dst) */
+	uint64_t track_rd_cnt                 : 6;  /**< Reserved. */
+	uint64_t track_wr_cnt                 : 6;  /**< Reserved. */
+	uint64_t mem_wen                      : 4;  /**< Memory write enable signals. The order of the bits is:
+                                                         0x3 = wen mem3.
+                                                         0x2 = wen mem2.
+                                                         0x1 = wen mem1.
+                                                         0x0 = wen mem0. */
 	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
 	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
                                                          0x3 = cen mem3.
@@ -11206,7 +11787,9 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pdm_mwpbuf_dbg_cn73xx cn75xx;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xx;
+	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xxp2;
 };
 typedef union cvmx_pko_pdm_mwpbuf_dbg cvmx_pko_pdm_mwpbuf_dbg_t;
 
@@ -11299,7 +11882,9 @@ union cvmx_pko_pdm_sts {
 #endif
 	} s;
 	struct cvmx_pko_pdm_sts_s             cn73xx;
+	struct cvmx_pko_pdm_sts_s             cn75xx;
 	struct cvmx_pko_pdm_sts_s             cn78xx;
+	struct cvmx_pko_pdm_sts_s             cn78xxp2;
 };
 typedef union cvmx_pko_pdm_sts cvmx_pko_pdm_sts_t;
 
@@ -11423,7 +12008,9 @@ union cvmx_pko_peb_bist_status {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} cn73xx;
+	struct cvmx_pko_peb_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_peb_bist_status_s     cn78xx;
+	struct cvmx_pko_peb_bist_status_cn73xx cn78xxp2;
 };
 typedef union cvmx_pko_peb_bist_status cvmx_pko_peb_bist_status_t;
 
@@ -11606,7 +12193,9 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t iobp1_uid_fifo_ram_flip      : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_peb_ecc_ctl0_cn73xx   cn75xx;
 	struct cvmx_pko_peb_ecc_ctl0_s        cn78xx;
+	struct cvmx_pko_peb_ecc_ctl0_cn73xx   cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_ctl0 cvmx_pko_peb_ecc_ctl0_t;
 
@@ -11637,6 +12226,7 @@ union cvmx_pko_peb_ecc_ctl1 {
 #endif
 	} s;
 	struct cvmx_pko_peb_ecc_ctl1_s        cn73xx;
+	struct cvmx_pko_peb_ecc_ctl1_s        cn75xx;
 	struct cvmx_pko_peb_ecc_ctl1_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ts_addwork_ram_flip          : 2;  /**< TS_ADDWORK_RAM flip syndrome bits on write. */
@@ -11648,6 +12238,7 @@ union cvmx_pko_peb_ecc_ctl1 {
 	uint64_t ts_addwork_ram_flip          : 2;
 #endif
 	} cn78xx;
+	struct cvmx_pko_peb_ecc_ctl1_cn78xx   cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_ctl1 cvmx_pko_peb_ecc_ctl1_t;
 
@@ -11813,6 +12404,7 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
@@ -11886,6 +12478,74 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
 #endif
 	} cn78xx;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xxp2 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t reserved_0_41                : 42;
+#else
+	uint64_t reserved_0_41                : 42;
+	uint64_t ts_addwork_ram_dbe           : 1;
+	uint64_t pkt_mrk_ram_dbe              : 1;
+	uint64_t nxt_link_ptr_ram_dbe         : 1;
+	uint64_t send_mem_ts_fifo_dbe         : 1;
+	uint64_t send_mem_stdn_fifo_dbe       : 1;
+	uint64_t send_mem_fifo_dbe            : 1;
+	uint64_t add_work_fifo_dbe            : 1;
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;
+	uint64_t tx_fifo_crc_ram_dbe          : 1;
+	uint64_t pd_var_bank_ram_dbe          : 1;
+	uint64_t pd_bank0_ram_dbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_dbe             : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_dbe          : 1;
+	uint64_t pdm_resp_buf_ram_dbe         : 1;
+	uint64_t iobp1_fifo_ram_dbe           : 1;
+	uint64_t iobp0_fifo_ram_dbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
+#endif
+	} cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_dbe_sts0 cvmx_pko_peb_ecc_dbe_sts0_t;
 
@@ -11928,7 +12588,9 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_dbe_sts_cmb0 cvmx_pko_peb_ecc_dbe_sts_cmb0_t;
 
@@ -12094,6 +12756,7 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
@@ -12167,6 +12830,74 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
 #endif
 	} cn78xx;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xxp2 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t reserved_0_41                : 42;
+#else
+	uint64_t reserved_0_41                : 42;
+	uint64_t ts_addwork_ram_sbe           : 1;
+	uint64_t pkt_mrk_ram_sbe              : 1;
+	uint64_t nxt_link_ptr_ram_sbe         : 1;
+	uint64_t send_mem_ts_fifo_sbe         : 1;
+	uint64_t send_mem_stdn_fifo_sbe       : 1;
+	uint64_t send_mem_fifo_sbe            : 1;
+	uint64_t add_work_fifo_sbe            : 1;
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;
+	uint64_t tx_fifo_crc_ram_sbe          : 1;
+	uint64_t pd_var_bank_ram_sbe          : 1;
+	uint64_t pd_bank0_ram_sbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_sbe             : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_sbe          : 1;
+	uint64_t pdm_resp_buf_ram_sbe         : 1;
+	uint64_t iobp1_fifo_ram_sbe           : 1;
+	uint64_t iobp0_fifo_ram_sbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
+#endif
+	} cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts0 cvmx_pko_peb_ecc_sbe_sts0_t;
 
@@ -12209,7 +12940,9 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts_cmb0 cvmx_pko_peb_ecc_sbe_sts_cmb0_t;
 
@@ -12228,6 +12961,8 @@ union cvmx_pko_peb_eco {
 #endif
 	} s;
 	struct cvmx_pko_peb_eco_s             cn73xx;
+	struct cvmx_pko_peb_eco_s             cn75xx;
+	struct cvmx_pko_peb_eco_s             cn78xxp2;
 };
 typedef union cvmx_pko_peb_eco cvmx_pko_peb_eco_t;
 
@@ -12273,7 +13008,9 @@ union cvmx_pko_peb_err_int {
 #endif
 	} s;
 	struct cvmx_pko_peb_err_int_s         cn73xx;
+	struct cvmx_pko_peb_err_int_s         cn75xx;
 	struct cvmx_pko_peb_err_int_s         cn78xx;
+	struct cvmx_pko_peb_err_int_s         cn78xxp2;
 };
 typedef union cvmx_pko_peb_err_int cvmx_pko_peb_err_int_t;
 
@@ -12296,7 +13033,9 @@ union cvmx_pko_peb_ext_hdr_def_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn73xx;
+	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn75xx;
 	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn78xx;
+	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_ext_hdr_def_err_info cvmx_pko_peb_ext_hdr_def_err_info_t;
 
@@ -12319,7 +13058,9 @@ union cvmx_pko_peb_fcs_sop_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_fcs_sop_err_info_s cn73xx;
+	struct cvmx_pko_peb_fcs_sop_err_info_s cn75xx;
 	struct cvmx_pko_peb_fcs_sop_err_info_s cn78xx;
+	struct cvmx_pko_peb_fcs_sop_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_fcs_sop_err_info cvmx_pko_peb_fcs_sop_err_info_t;
 
@@ -12342,7 +13083,9 @@ union cvmx_pko_peb_jump_def_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_jump_def_err_info_s cn73xx;
+	struct cvmx_pko_peb_jump_def_err_info_s cn75xx;
 	struct cvmx_pko_peb_jump_def_err_info_s cn78xx;
+	struct cvmx_pko_peb_jump_def_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_jump_def_err_info cvmx_pko_peb_jump_def_err_info_t;
 
@@ -12363,7 +13106,9 @@ union cvmx_pko_peb_macx_cfg_wr_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn73xx;
+	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn75xx;
 	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn78xx;
+	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_macx_cfg_wr_err_info cvmx_pko_peb_macx_cfg_wr_err_info_t;
 
@@ -12386,7 +13131,9 @@ union cvmx_pko_peb_max_link_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_max_link_err_info_s cn73xx;
+	struct cvmx_pko_peb_max_link_err_info_s cn75xx;
 	struct cvmx_pko_peb_max_link_err_info_s cn78xx;
+	struct cvmx_pko_peb_max_link_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_max_link_err_info cvmx_pko_peb_max_link_err_info_t;
 
@@ -12398,14 +13145,16 @@ union cvmx_pko_peb_ncb_cfg {
 	struct cvmx_pko_peb_ncb_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t rstp                         : 1;  /**< Reserved. */
+	uint64_t rstp                         : 1;  /**< Convert STP operations to RSTP. Added in pass 2. */
 #else
 	uint64_t rstp                         : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
 	struct cvmx_pko_peb_ncb_cfg_s         cn73xx;
+	struct cvmx_pko_peb_ncb_cfg_s         cn75xx;
 	struct cvmx_pko_peb_ncb_cfg_s         cn78xx;
+	struct cvmx_pko_peb_ncb_cfg_s         cn78xxp2;
 };
 typedef union cvmx_pko_peb_ncb_cfg cvmx_pko_peb_ncb_cfg_t;
 
@@ -12428,7 +13177,9 @@ union cvmx_pko_peb_pad_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_pad_err_info_s    cn73xx;
+	struct cvmx_pko_peb_pad_err_info_s    cn75xx;
 	struct cvmx_pko_peb_pad_err_info_s    cn78xx;
+	struct cvmx_pko_peb_pad_err_info_s    cn78xxp2;
 };
 typedef union cvmx_pko_peb_pad_err_info cvmx_pko_peb_pad_err_info_t;
 
@@ -12451,7 +13202,9 @@ union cvmx_pko_peb_pse_fifo_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cn73xx;
+	struct cvmx_pko_peb_pse_fifo_err_info_s cn75xx;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xx;
+	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_pse_fifo_err_info cvmx_pko_peb_pse_fifo_err_info_t;
 
@@ -12474,7 +13227,9 @@ union cvmx_pko_peb_subd_addr_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_subd_addr_err_info_s cn73xx;
+	struct cvmx_pko_peb_subd_addr_err_info_s cn75xx;
 	struct cvmx_pko_peb_subd_addr_err_info_s cn78xx;
+	struct cvmx_pko_peb_subd_addr_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_subd_addr_err_info cvmx_pko_peb_subd_addr_err_info_t;
 
@@ -12497,7 +13252,9 @@ union cvmx_pko_peb_subd_size_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_subd_size_err_info_s cn73xx;
+	struct cvmx_pko_peb_subd_size_err_info_s cn75xx;
 	struct cvmx_pko_peb_subd_size_err_info_s cn78xx;
+	struct cvmx_pko_peb_subd_size_err_info_s cn78xxp2;
 };
 typedef union cvmx_pko_peb_subd_size_err_info cvmx_pko_peb_subd_size_err_info_t;
 
@@ -12520,7 +13277,9 @@ union cvmx_pko_peb_trunc_err_info {
 #endif
 	} s;
 	struct cvmx_pko_peb_trunc_err_info_s  cn73xx;
+	struct cvmx_pko_peb_trunc_err_info_s  cn75xx;
 	struct cvmx_pko_peb_trunc_err_info_s  cn78xx;
+	struct cvmx_pko_peb_trunc_err_info_s  cn78xxp2;
 };
 typedef union cvmx_pko_peb_trunc_err_info cvmx_pko_peb_trunc_err_info_t;
 
@@ -12532,11 +13291,20 @@ union cvmx_pko_peb_tso_cfg {
 	struct cvmx_pko_peb_tso_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
-	uint64_t fsf                          : 12; /**< Reserved. */
+	uint64_t fsf                          : 12; /**< Modify the TCP header flags for the first TSO segmented packet by logical AND
+                                                         with this configuration.
+                                                         Added in pass 2.
+                                                         _ FLAGS_new = (FLAGS_original) AND [FSF]. */
 	uint64_t reserved_28_31               : 4;
-	uint64_t msf                          : 12; /**< Reserved. */
+	uint64_t msf                          : 12; /**< Modify the TCP header flags for the middle TSO segmented packets by logical AND
+                                                         with this configuration.
+                                                         Added in pass 2.
+                                                         _ FLAGS_new = (FLAGS_original) AND [MSF]. */
 	uint64_t reserved_12_15               : 4;
-	uint64_t lsf                          : 12; /**< Reserved. */
+	uint64_t lsf                          : 12; /**< Modify the TCP header flags for the last TSO segmented packet by logical AND
+                                                         with this configuration.
+                                                         Added in pass 2.
+                                                         _ FLAGS_new = (FLAGS_original) AND [LSF]. */
 #else
 	uint64_t lsf                          : 12;
 	uint64_t reserved_12_15               : 4;
@@ -12547,7 +13315,9 @@ union cvmx_pko_peb_tso_cfg {
 #endif
 	} s;
 	struct cvmx_pko_peb_tso_cfg_s         cn73xx;
+	struct cvmx_pko_peb_tso_cfg_s         cn75xx;
 	struct cvmx_pko_peb_tso_cfg_s         cn78xx;
+	struct cvmx_pko_peb_tso_cfg_s         cn78xxp2;
 };
 typedef union cvmx_pko_peb_tso_cfg cvmx_pko_peb_tso_cfg_t;
 
@@ -12564,7 +13334,9 @@ union cvmx_pko_pq_csr_bus_debug {
 #endif
 	} s;
 	struct cvmx_pko_pq_csr_bus_debug_s    cn73xx;
+	struct cvmx_pko_pq_csr_bus_debug_s    cn75xx;
 	struct cvmx_pko_pq_csr_bus_debug_s    cn78xx;
+	struct cvmx_pko_pq_csr_bus_debug_s    cn78xxp2;
 };
 typedef union cvmx_pko_pq_csr_bus_debug cvmx_pko_pq_csr_bus_debug_t;
 
@@ -12583,7 +13355,9 @@ union cvmx_pko_pq_debug_green {
 #endif
 	} s;
 	struct cvmx_pko_pq_debug_green_s      cn73xx;
+	struct cvmx_pko_pq_debug_green_s      cn75xx;
 	struct cvmx_pko_pq_debug_green_s      cn78xx;
+	struct cvmx_pko_pq_debug_green_s      cn78xxp2;
 };
 typedef union cvmx_pko_pq_debug_green cvmx_pko_pq_debug_green_t;
 
@@ -12602,7 +13376,9 @@ union cvmx_pko_pq_debug_links {
 #endif
 	} s;
 	struct cvmx_pko_pq_debug_links_s      cn73xx;
+	struct cvmx_pko_pq_debug_links_s      cn75xx;
 	struct cvmx_pko_pq_debug_links_s      cn78xx;
+	struct cvmx_pko_pq_debug_links_s      cn78xxp2;
 };
 typedef union cvmx_pko_pq_debug_links cvmx_pko_pq_debug_links_t;
 
@@ -12623,7 +13399,9 @@ union cvmx_pko_pq_debug_yellow {
 #endif
 	} s;
 	struct cvmx_pko_pq_debug_yellow_s     cn73xx;
+	struct cvmx_pko_pq_debug_yellow_s     cn75xx;
 	struct cvmx_pko_pq_debug_yellow_s     cn78xx;
+	struct cvmx_pko_pq_debug_yellow_s     cn78xxp2;
 };
 typedef union cvmx_pko_pq_debug_yellow cvmx_pko_pq_debug_yellow_t;
 
@@ -12640,7 +13418,9 @@ union cvmx_pko_pqa_debug {
 #endif
 	} s;
 	struct cvmx_pko_pqa_debug_s           cn73xx;
+	struct cvmx_pko_pqa_debug_s           cn75xx;
 	struct cvmx_pko_pqa_debug_s           cn78xx;
+	struct cvmx_pko_pqa_debug_s           cn78xxp2;
 };
 typedef union cvmx_pko_pqa_debug cvmx_pko_pqa_debug_t;
 
@@ -12660,7 +13440,9 @@ union cvmx_pko_pqb_debug {
 #endif
 	} s;
 	struct cvmx_pko_pqb_debug_s           cn73xx;
+	struct cvmx_pko_pqb_debug_s           cn75xx;
 	struct cvmx_pko_pqb_debug_s           cn78xx;
+	struct cvmx_pko_pqb_debug_s           cn78xxp2;
 };
 typedef union cvmx_pko_pqb_debug cvmx_pko_pqb_debug_t;
 
@@ -12710,6 +13492,7 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_dq_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_pse_dq_bist_status_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
@@ -12735,6 +13518,7 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} cn78xx;
+	struct cvmx_pko_pse_dq_bist_status_cn78xx cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_bist_status cvmx_pko_pse_dq_bist_status_t;
 
@@ -12807,7 +13591,9 @@ union cvmx_pko_pse_dq_ecc_ctl0 {
 	uint64_t dq_wt_ram_flip               : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_dq_ecc_ctl0_cn73xx cn75xx;
 	struct cvmx_pko_pse_dq_ecc_ctl0_s     cn78xx;
+	struct cvmx_pko_pse_dq_ecc_ctl0_s     cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_ecc_ctl0 cvmx_pko_pse_dq_ecc_ctl0_t;
 
@@ -12856,7 +13642,9 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	uint64_t dq_wt_ram_dbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts0 cvmx_pko_pse_dq_ecc_dbe_sts0_t;
 
@@ -12888,7 +13676,9 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_t;
 
@@ -12937,7 +13727,9 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	uint64_t dq_wt_ram_sbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts0 cvmx_pko_pse_dq_ecc_sbe_sts0_t;
 
@@ -12969,7 +13761,9 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_t;
 
@@ -12985,9 +13779,9 @@ union cvmx_pko_pse_pq_bist_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t tp_sram                      : 1;  /**< Topology parent - pko_pse_pq_srf32x5e */
-	uint64_t irq_fifo_sram                : 1;  /**< Interrupt message FIFO - pko_pse_pq_srf1024x10e */
+	uint64_t irq_fifo_sram                : 1;  /**< Reserved. */
 	uint64_t wmd_sram                     : 1;  /**< Dynamic watermark state - pko_pse_wmd_srf1024x49e */
-	uint64_t wms_sram                     : 1;  /**< Static watermark configuration - pko_pse_wms_srf1024x50e */
+	uint64_t wms_sram                     : 1;  /**< Reserved. */
 	uint64_t cxd_sram                     : 1;  /**< Dynamic channel state - pko_pse_cxd_srf32x31e */
 	uint64_t dqd_sram                     : 1;  /**< DQ dropped stats - pko_pse_stats_srf1024x88 */
 	uint64_t dqs_sram                     : 1;  /**< DQ sent stats - pko_pse_stats_srf1024x88 */
@@ -13055,7 +13849,9 @@ union cvmx_pko_pse_pq_bist_status {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_pq_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_pse_pq_bist_status_s  cn78xx;
+	struct cvmx_pko_pse_pq_bist_status_s  cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_bist_status cvmx_pko_pse_pq_bist_status_t;
 
@@ -13070,8 +13866,8 @@ union cvmx_pko_pse_pq_ecc_ctl0 {
 	uint64_t pq_cxs_ram_cdis              : 1;  /**< PQ_CXS_RAM ECC correction disable. */
 	uint64_t pq_cxd_ram_flip              : 2;  /**< PQ_CXD_RAM flip syndrome bits on write. */
 	uint64_t pq_cxd_ram_cdis              : 1;  /**< PQ_CXD_RAM ECC correction disable. */
-	uint64_t irq_fifo_sram_flip           : 2;  /**< IRQ_FIFO_SRAM flip syndrome bits on write. */
-	uint64_t irq_fifo_sram_cdis           : 1;  /**< IRQ_FIFO_SRAM ECC correction disable. */
+	uint64_t irq_fifo_sram_flip           : 2;  /**< Reserved. */
+	uint64_t irq_fifo_sram_cdis           : 1;  /**< Reserved. */
 	uint64_t tp_sram_flip                 : 2;  /**< TP_SRAM flip syndrome bits on write. */
 	uint64_t tp_sram_cdis                 : 1;  /**< TP_SRAM ECC correction disable. */
 	uint64_t pq_std_ram_flip              : 2;  /**< PQ_STD_RAM flip syndrome bits on write. */
@@ -13080,8 +13876,8 @@ union cvmx_pko_pse_pq_ecc_ctl0 {
 	uint64_t pq_st_ram_cdis               : 1;  /**< PQ_ST_RAM ECC correction disable. */
 	uint64_t pq_wmd_ram_flip              : 2;  /**< PQ_WMD_RAM flip syndrome bits on write. */
 	uint64_t pq_wmd_ram_cdis              : 1;  /**< PQ_WMD_RAM ECC correction disable. */
-	uint64_t pq_wms_ram_flip              : 2;  /**< PQ_WMS_RAM flip syndrome bits on write. */
-	uint64_t pq_wms_ram_cdis              : 1;  /**< PQ_WMS_RAM ECC correction disable. */
+	uint64_t pq_wms_ram_flip              : 2;  /**< Reserved. */
+	uint64_t pq_wms_ram_cdis              : 1;  /**< Reserved. */
 	uint64_t reserved_0_39                : 40;
 #else
 	uint64_t reserved_0_39                : 40;
@@ -13136,7 +13932,9 @@ union cvmx_pko_pse_pq_ecc_ctl0 {
 	uint64_t pq_cxs_ram_flip              : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_pq_ecc_ctl0_cn73xx cn75xx;
 	struct cvmx_pko_pse_pq_ecc_ctl0_s     cn78xx;
+	struct cvmx_pko_pse_pq_ecc_ctl0_s     cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_ecc_ctl0 cvmx_pko_pse_pq_ecc_ctl0_t;
 
@@ -13151,8 +13949,7 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram */
 	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram */
-	uint64_t irq_fifo_sram_dbe            : 1;  /**< Double-bit error for IRQ_FIFO_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram */
+	uint64_t irq_fifo_sram_dbe            : 1;  /**< Reserved. */
 	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram */
 	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram */
@@ -13160,8 +13957,7 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram */
 	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram */
-	uint64_t pq_wms_ram_dbe               : 1;  /**< Double-bit error for PQ_WMS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+	uint64_t pq_wms_ram_dbe               : 1;  /**< Reserved. */
 	uint64_t reserved_0_55                : 56;
 #else
 	uint64_t reserved_0_55                : 56;
@@ -13201,7 +13997,9 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	uint64_t pq_cxs_ram_dbe               : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts0 cvmx_pko_pse_pq_ecc_dbe_sts0_t;
 
@@ -13232,7 +14030,9 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_t;
 
@@ -13247,8 +14047,7 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram */
 	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram */
-	uint64_t irq_fifo_sram_sbe            : 1;  /**< Single-bit error for IRQ_FIFO_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram */
+	uint64_t irq_fifo_sram_sbe            : 1;  /**< Reserved. */
 	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram */
 	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram */
@@ -13256,8 +14055,7 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram */
 	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram */
-	uint64_t pq_wms_ram_sbe               : 1;  /**< Single-bit error for PQ_WMS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+	uint64_t pq_wms_ram_sbe               : 1;  /**< Reserved. */
 	uint64_t reserved_0_55                : 56;
 #else
 	uint64_t reserved_0_55                : 56;
@@ -13297,7 +14095,9 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	uint64_t pq_cxs_ram_sbe               : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts0 cvmx_pko_pse_pq_ecc_sbe_sts0_t;
 
@@ -13328,7 +14128,9 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_t;
 
@@ -13436,7 +14238,9 @@ union cvmx_pko_pse_sq1_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq1_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq1_bist_status_s cn78xx;
+	struct cvmx_pko_pse_sq1_bist_status_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_bist_status cvmx_pko_pse_sq1_bist_status_t;
 
@@ -13593,7 +14397,9 @@ union cvmx_pko_pse_sq1_ecc_ctl0 {
 	uint64_t cxs_ram_flip                 : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq1_ecc_ctl0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq1_ecc_ctl0_s    cn78xx;
+	struct cvmx_pko_pse_sq1_ecc_ctl0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_ecc_ctl0 cvmx_pko_pse_sq1_ecc_ctl0_t;
 
@@ -13711,7 +14517,9 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	uint64_t cxs_ram_dbe                  : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts0 cvmx_pko_pse_sq1_ecc_dbe_sts0_t;
 
@@ -13752,7 +14560,9 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_t;
 
@@ -13870,7 +14680,9 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	uint64_t cxs_ram_sbe                  : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts0 cvmx_pko_pse_sq1_ecc_sbe_sts0_t;
 
@@ -13911,7 +14723,9 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_t;
 
@@ -13993,7 +14807,9 @@ union cvmx_pko_pse_sq2_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq2_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq2_bist_status_s cn78xx;
+	struct cvmx_pko_pse_sq2_bist_status_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_bist_status cvmx_pko_pse_sq2_bist_status_t;
 
@@ -14112,7 +14928,9 @@ union cvmx_pko_pse_sq2_ecc_ctl0 {
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq2_ecc_ctl0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq2_ecc_ctl0_s    cn78xx;
+	struct cvmx_pko_pse_sq2_ecc_ctl0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_ecc_ctl0 cvmx_pko_pse_sq2_ecc_ctl0_t;
 
@@ -14203,7 +15021,9 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts0 cvmx_pko_pse_sq2_ecc_dbe_sts0_t;
 
@@ -14239,7 +15059,9 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_t;
 
@@ -14330,7 +15152,9 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts0 cvmx_pko_pse_sq2_ecc_sbe_sts0_t;
 
@@ -14366,7 +15190,9 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_t;
 
@@ -14460,7 +15286,9 @@ union cvmx_pko_pse_sq3_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq3_bist_status_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq3_bist_status_s cn78xx;
+	struct cvmx_pko_pse_sq3_bist_status_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_bist_status cvmx_pko_pse_sq3_bist_status_t;
 
@@ -14611,7 +15439,9 @@ union cvmx_pko_pse_sq3_ecc_ctl0 {
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq3_ecc_ctl0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq3_ecc_ctl0_s    cn78xx;
+	struct cvmx_pko_pse_sq3_ecc_ctl0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_ecc_ctl0 cvmx_pko_pse_sq3_ecc_ctl0_t;
 
@@ -14726,7 +15556,9 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts0 cvmx_pko_pse_sq3_ecc_dbe_sts0_t;
 
@@ -14770,7 +15602,9 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_t;
 
@@ -14885,7 +15719,9 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_cn73xx cn75xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts0 cvmx_pko_pse_sq3_ecc_sbe_sts0_t;
 
@@ -14929,7 +15765,9 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn75xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_t;
 
@@ -14991,6 +15829,7 @@ union cvmx_pko_pse_sq4_bist_status {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_bist_status_s cn78xx;
+	struct cvmx_pko_pse_sq4_bist_status_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_bist_status cvmx_pko_pse_sq4_bist_status_t;
 
@@ -15091,6 +15930,7 @@ union cvmx_pko_pse_sq4_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_ecc_ctl0_s    cn78xx;
+	struct cvmx_pko_pse_sq4_ecc_ctl0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_ecc_ctl0 cvmx_pko_pse_sq4_ecc_ctl0_t;
 
@@ -15167,6 +16007,7 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq4_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_ecc_dbe_sts0 cvmx_pko_pse_sq4_ecc_dbe_sts0_t;
 
@@ -15210,6 +16051,7 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0_t;
 
@@ -15286,6 +16128,7 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq4_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_ecc_sbe_sts0 cvmx_pko_pse_sq4_ecc_sbe_sts0_t;
 
@@ -15329,6 +16172,7 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_t;
 
@@ -15390,6 +16234,7 @@ union cvmx_pko_pse_sq5_bist_status {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_bist_status_s cn78xx;
+	struct cvmx_pko_pse_sq5_bist_status_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_bist_status cvmx_pko_pse_sq5_bist_status_t;
 
@@ -15490,6 +16335,7 @@ union cvmx_pko_pse_sq5_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_ecc_ctl0_s    cn78xx;
+	struct cvmx_pko_pse_sq5_ecc_ctl0_s    cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_ecc_ctl0 cvmx_pko_pse_sq5_ecc_ctl0_t;
 
@@ -15566,6 +16412,7 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq5_ecc_dbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_ecc_dbe_sts0 cvmx_pko_pse_sq5_ecc_dbe_sts0_t;
 
@@ -15609,6 +16456,7 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0_t;
 
@@ -15685,6 +16533,7 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts0_s cn78xx;
+	struct cvmx_pko_pse_sq5_ecc_sbe_sts0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_ecc_sbe_sts0 cvmx_pko_pse_sq5_ecc_sbe_sts0_t;
 
@@ -15728,6 +16577,7 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0 {
 #endif
 	} s;
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0_s cn78xx;
+	struct cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0_s cn78xxp2;
 };
 typedef union cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0_t;
 
@@ -15754,7 +16604,9 @@ union cvmx_pko_ptfx_status {
 #endif
 	} s;
 	struct cvmx_pko_ptfx_status_s         cn73xx;
+	struct cvmx_pko_ptfx_status_s         cn75xx;
 	struct cvmx_pko_ptfx_status_s         cn78xx;
+	struct cvmx_pko_ptfx_status_s         cn78xxp2;
 };
 typedef union cvmx_pko_ptfx_status cvmx_pko_ptfx_status_t;
 
@@ -15766,8 +16618,9 @@ union cvmx_pko_ptf_iobp_cfg {
 	struct cvmx_pko_ptf_iobp_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
-	uint64_t iobp1_ds_opt                 : 1;  /**< Reserved. */
-	uint64_t iobp0_l2_allocate            : 1;  /**< Determine L2 allocation (1 = no allocation) when performing IOBP0 requests. */
+	uint64_t iobp1_ds_opt                 : 1;  /**< Optimize IOBP1 requests when data is to be dropped (NULL, RED, SEND_HDR_S[DS]=1). */
+	uint64_t iobp0_l2_allocate            : 1;  /**< Determine L2 allocation (1 = no allocation = LDT, 0 = allocation = LDD) when reading
+                                                         post-PKO_SEND_JUMP descriptors via IOBP0 requests. */
 	uint64_t iobp1_magic_addr             : 35; /**< IOBP1 read address to be used for any dummy reads */
 	uint64_t max_read_size                : 7;  /**< Maximum number of IOBP1 read requests outstanding to be allowed by any given PEB TX FIFO. */
 #else
@@ -15779,7 +16632,9 @@ union cvmx_pko_ptf_iobp_cfg {
 #endif
 	} s;
 	struct cvmx_pko_ptf_iobp_cfg_s        cn73xx;
+	struct cvmx_pko_ptf_iobp_cfg_s        cn75xx;
 	struct cvmx_pko_ptf_iobp_cfg_s        cn78xx;
+	struct cvmx_pko_ptf_iobp_cfg_s        cn78xxp2;
 };
 typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
 
@@ -15914,7 +16769,9 @@ union cvmx_pko_ptgfx_cfg {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} cn73xx;
+	struct cvmx_pko_ptgfx_cfg_cn73xx      cn75xx;
 	struct cvmx_pko_ptgfx_cfg_s           cn78xx;
+	struct cvmx_pko_ptgfx_cfg_s           cn78xxp2;
 };
 typedef union cvmx_pko_ptgfx_cfg cvmx_pko_ptgfx_cfg_t;
 
@@ -17587,9 +18444,10 @@ union cvmx_pko_shaper_cfg {
 	uint64_t color_aware                  : 1;  /**< Color aware. Selects whether or not the PSE shapers take into account
                                                          the color of the incoming packet.  0: color blind, 1: color aware */
 	uint64_t red_send_as_yellow           : 1;  /**< RED_SEND as YELLOW. Configures the way packets colored RED_SEND are
-                                                         handled by the DQ through L2 shapers.  Packets colored RED_DROP do not decrement
-                                                         the PIR in DQ through L2 shapers while packets colored YELLOW do.  (Neither RED_DROP
-                                                         nor YELLOW packets decrement the CIR in DQ through L2 shapers.)  Packets colored
+                                                         handled by the DQ through L2 shapers when operating in COLOR_AWARE mode.
+                                                         Normally packets colored RED_DROP do not decrement the PIR in DQ through
+                                                         L2 shapers while packets colored YELLOW do.  (Neither RED_DROP nor
+                                                         YELLOW packets decrement the CIR in DQ through L2 shapers.)  Packets colored
                                                          RED_SEND are treated as either RED_DROP or YELLOW in the DQ through L2 shapers
                                                          as follows:
                                                          0 = treat RED_SEND as RED_DROP.
@@ -17604,7 +18462,9 @@ union cvmx_pko_shaper_cfg {
 #endif
 	} s;
 	struct cvmx_pko_shaper_cfg_s          cn73xx;
+	struct cvmx_pko_shaper_cfg_s          cn75xx;
 	struct cvmx_pko_shaper_cfg_s          cn78xx;
+	struct cvmx_pko_shaper_cfg_s          cn78xxp2;
 };
 typedef union cvmx_pko_shaper_cfg cvmx_pko_shaper_cfg_t;
 
@@ -17624,6 +18484,8 @@ union cvmx_pko_state_uid_in_usex_rd {
 #endif
 	} s;
 	struct cvmx_pko_state_uid_in_usex_rd_s cn73xx;
+	struct cvmx_pko_state_uid_in_usex_rd_s cn75xx;
+	struct cvmx_pko_state_uid_in_usex_rd_s cn78xxp2;
 };
 typedef union cvmx_pko_state_uid_in_usex_rd cvmx_pko_state_uid_in_usex_rd_t;
 
@@ -17706,12 +18568,17 @@ union cvmx_pko_status {
 	uint64_t pko_rdy                      : 1;
 #endif
 	} cn73xx;
+	struct cvmx_pko_status_cn73xx         cn75xx;
 	struct cvmx_pko_status_cn73xx         cn78xx;
+	struct cvmx_pko_status_cn73xx         cn78xxp2;
 };
 typedef union cvmx_pko_status cvmx_pko_status_t;
 
 /**
  * cvmx_pko_txf#_pkt_cnt_rd
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_pko_txfx_pkt_cnt_rd {
 	uint64_t u64;
@@ -17725,6 +18592,8 @@ union cvmx_pko_txfx_pkt_cnt_rd {
 #endif
 	} s;
 	struct cvmx_pko_txfx_pkt_cnt_rd_s     cn73xx;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s     cn75xx;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s     cn78xxp2;
 };
 typedef union cvmx_pko_txfx_pkt_cnt_rd cvmx_pko_txfx_pkt_cnt_rd_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 33b409d..ccd577e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -107,6 +107,8 @@ enum cvmx_pko_dqop {
  */
 static inline unsigned __cvmx_pko3_num_macs(void)
 {
+        if(OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return 10;	//CSR=14 simulator=10 ?? XXX
         if(OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 14;
         if(OCTEON_IS_MODEL(OCTEON_CN78XX))
@@ -120,9 +122,11 @@ static inline unsigned __cvmx_pko3_num_macs(void)
  */
 static inline int __cvmx_pko3_sq_lvl_max(void)
 {
-        if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return CVMX_PKO_L3_QUEUES;
-        if(OCTEON_IS_MODEL(OCTEON_CN78XX))
+        if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return CVMX_PKO_L3_QUEUES;
+        if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return CVMX_PKO_L5_QUEUES;
 	return -1;
 }
@@ -142,15 +146,18 @@ __cvmx_pko3_sq_lvl_next(enum cvmx_pko3_level_e level)
 		case CVMX_PKO_L2_QUEUES:
 			return CVMX_PKO_L3_QUEUES;
 		case CVMX_PKO_L3_QUEUES:
-			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+			if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+			    OCTEON_IS_MODEL(OCTEON_CN75XX))
 				return CVMX_PKO_DESCR_QUEUES;
 			return CVMX_PKO_L4_QUEUES;
 		case CVMX_PKO_L4_QUEUES:
-			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+			if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+			    OCTEON_IS_MODEL(OCTEON_CN75XX))
 				return CVMX_PKO_LEVEL_INVAL;
 			return CVMX_PKO_L5_QUEUES;
 		case CVMX_PKO_L5_QUEUES:
-			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+			if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+			    OCTEON_IS_MODEL(OCTEON_CN75XX))
 				return CVMX_PKO_LEVEL_INVAL;
 			return CVMX_PKO_DESCR_QUEUES;
 	}
@@ -462,10 +469,15 @@ static inline int __cvmx_pko3_get_mac_num(int xiface, int index)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	cvmx_helper_interface_mode_t mode;
 	int interface_index;
-	int ilk_mac_base = -1, bgx_mac_base = -1;
+	int ilk_mac_base = -1, bgx_mac_base = -1, bgx_ports = 4;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		bgx_mac_base = 2;
+	}
 
-        if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		bgx_mac_base = 2;
+		bgx_ports = 2;
 	}
 
         if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
@@ -491,7 +503,8 @@ static inline int __cvmx_pko3_get_mac_num(int xiface, int index)
 			    ilk_mac_base >= 0)
 				return -1;
 			/* All other modes belong to BGX */
-			return (bgx_mac_base + 4 * xi.interface + index);
+			return (bgx_mac_base +
+				bgx_ports * xi.interface + index);
 	}
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index 79e7cce..2f40219 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -1646,6 +1646,8 @@ static inline unsigned cvmx_sso_num_xgrp(void)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 256;
+	if (OCTEON_IS_MODEL(OCTEON_CN75XX))
+		return 64;
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 64;
 	cvmx_printf("ERROR: %s: Unknown model\n", __func__);
@@ -3249,8 +3251,12 @@ extern int cvmx_pow_get_dump_size(void);
  * @param count  The number of consecutive groups to allocate.
  * @return 0 on success and -1 on failure.
  */
-int cvmx_sso_allocate_group_range(int node, int *base_group, int count);
-int cvmx_sso_allocate_group(int node);
+int cvmx_sso_reserve_group_range(int node, int *base_group, int count);
+#define cvmx_sso_allocate_group_range cvmx_sso_reserve_group_range
+int cvmx_sso_reserve_group(int node);
+#define cvmx_sso_allocate_group cvmx_sso_reserve_group
+int cvmx_sso_release_group_range(int node, int base_group, int count);
+int cvmx_sso_release_group(int node, int group);
 
 #ifdef  __cplusplus
 /* *INDENT-OFF* */
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index 9da28cd..e4e1869 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 110744 $<hr>
+ * <hr>$Revision: 111541 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -201,6 +201,25 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_10G_KR,
 	CVMX_QLM_MODE_40G_KR4,
 	CVMX_QLM_MODE_PCIE_1X8,  /* 1x8 gen3 / gen2 / gen1 */
+	CVMX_QLM_MODE_RGMII_SGMII,
+	CVMX_QLM_MODE_RGMII_XFI,
+	CVMX_QLM_MODE_RGMII_10G_KR,
+	CVMX_QLM_MODE_RGMII_RXAUI,
+	CVMX_QLM_MODE_RGMII_XAUI,
+	CVMX_QLM_MODE_RGMII_XLAUI,
+	CVMX_QLM_MODE_RGMII_40G_KR4,
+	CVMX_QLM_MODE_SGMII_XFI,
+	CVMX_QLM_MODE_SGMII_10G_KR,
+	CVMX_QLM_MODE_SGMII_RXAUI,
+	CVMX_QLM_MODE_XLAUI_RXAUI,
+	CVMX_QLM_MODE_40G_KR4_RXAUI,
+	CVMX_QLM_MODE_RGMII_SGMII_XFI,
+	CVMX_QLM_MODE_RGMII_SGMII_10G_KR,
+	CVMX_QLM_MODE_RGMII_SGMII_RXAUI,
+	CVMX_QLM_MODE_RGMII_XFI_SGMII,
+	CVMX_QLM_MODE_RGMII_10G_KR_SGMII,
+	CVMX_QLM_MODE_RGMII_XFI_RXAUI,
+	CVMX_QLM_MODE_RGMII_10G_KR_RXAUI,
 	CVMX_QLM_MODE_OCI
 };
 
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index f107e20..8b1ece6 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -58,7 +58,7 @@
 #define CVMX_RNM_EER_DBG CVMX_RNM_EER_DBG_FUNC()
 static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000018ull);
 }
@@ -69,7 +69,7 @@ static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 #define CVMX_RNM_EER_KEY CVMX_RNM_EER_KEY_FUNC()
 static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_KEY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000010ull);
 }
@@ -80,7 +80,7 @@ static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 #define CVMX_RNM_SERIAL_NUM CVMX_RNM_SERIAL_NUM_FUNC()
 static inline uint64_t CVMX_RNM_SERIAL_NUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_SERIAL_NUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000020ull);
 }
@@ -91,8 +91,8 @@ static inline uint64_t CVMX_RNM_SERIAL_NUM_FUNC(void)
 /**
  * cvmx_rnm_bist_status
  *
- * This register is the RNM memory BIST status register, indicating status of built-in self-tests.
- *
+ * This register is the RNM memory BIST status register, indicating status of built-in self-
+ * tests. 0 = passed BIST, 1 = failed BIST.
  */
 union cvmx_rnm_bist_status {
 	uint64_t u64;
@@ -127,7 +127,9 @@ union cvmx_rnm_bist_status {
 	struct cvmx_rnm_bist_status_s         cn70xx;
 	struct cvmx_rnm_bist_status_s         cn70xxp1;
 	struct cvmx_rnm_bist_status_s         cn73xx;
+	struct cvmx_rnm_bist_status_s         cn75xx;
 	struct cvmx_rnm_bist_status_s         cn78xx;
+	struct cvmx_rnm_bist_status_s         cn78xxp2;
 	struct cvmx_rnm_bist_status_s         cnf71xx;
 };
 typedef union cvmx_rnm_bist_status cvmx_rnm_bist_status_t;
@@ -243,7 +245,9 @@ union cvmx_rnm_ctl_status {
 	struct cvmx_rnm_ctl_status_s          cn70xx;
 	struct cvmx_rnm_ctl_status_s          cn70xxp1;
 	struct cvmx_rnm_ctl_status_s          cn73xx;
+	struct cvmx_rnm_ctl_status_s          cn75xx;
 	struct cvmx_rnm_ctl_status_s          cn78xx;
+	struct cvmx_rnm_ctl_status_s          cn78xxp2;
 	struct cvmx_rnm_ctl_status_s          cnf71xx;
 };
 typedef union cvmx_rnm_ctl_status cvmx_rnm_ctl_status_t;
@@ -272,7 +276,9 @@ union cvmx_rnm_eer_dbg {
 	struct cvmx_rnm_eer_dbg_s             cn70xx;
 	struct cvmx_rnm_eer_dbg_s             cn70xxp1;
 	struct cvmx_rnm_eer_dbg_s             cn73xx;
+	struct cvmx_rnm_eer_dbg_s             cn75xx;
 	struct cvmx_rnm_eer_dbg_s             cn78xx;
+	struct cvmx_rnm_eer_dbg_s             cn78xxp2;
 	struct cvmx_rnm_eer_dbg_s             cnf71xx;
 };
 typedef union cvmx_rnm_eer_dbg cvmx_rnm_eer_dbg_t;
@@ -303,7 +309,9 @@ union cvmx_rnm_eer_key {
 	struct cvmx_rnm_eer_key_s             cn70xx;
 	struct cvmx_rnm_eer_key_s             cn70xxp1;
 	struct cvmx_rnm_eer_key_s             cn73xx;
+	struct cvmx_rnm_eer_key_s             cn75xx;
 	struct cvmx_rnm_eer_key_s             cn78xx;
+	struct cvmx_rnm_eer_key_s             cn78xxp2;
 	struct cvmx_rnm_eer_key_s             cnf71xx;
 };
 typedef union cvmx_rnm_eer_key cvmx_rnm_eer_key_t;
@@ -336,7 +344,9 @@ union cvmx_rnm_serial_num {
 	struct cvmx_rnm_serial_num_s          cn70xx;
 	struct cvmx_rnm_serial_num_s          cn70xxp1;
 	struct cvmx_rnm_serial_num_s          cn73xx;
+	struct cvmx_rnm_serial_num_s          cn75xx;
 	struct cvmx_rnm_serial_num_s          cn78xx;
+	struct cvmx_rnm_serial_num_s          cn78xxp2;
 	struct cvmx_rnm_serial_num_s          cnf71xx;
 };
 typedef union cvmx_rnm_serial_num cvmx_rnm_serial_num_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index d384a24..f413614 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_RST_BIST_TIMER CVMX_RST_BIST_TIMER_FUNC()
 static inline uint64_t CVMX_RST_BIST_TIMER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_RST_BIST_TIMER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001760ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_RST_BIST_TIMER_FUNC(void)
 #define CVMX_RST_BOOT CVMX_RST_BOOT_FUNC()
 static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_BOOT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001600ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 #define CVMX_RST_CFG CVMX_RST_CFG_FUNC()
 static inline uint64_t CVMX_RST_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001610ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_RST_CFG_FUNC(void)
 #define CVMX_RST_CKILL CVMX_RST_CKILL_FUNC()
 static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CKILL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001638ull);
 }
@@ -100,7 +100,8 @@ static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 static inline uint64_t CVMX_RST_COLD_DATAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_COLD_DATAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800060017C0ull) + ((offset) & 3) * 8;
 }
@@ -113,6 +114,7 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_CTLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180006001640ull) + ((offset) & 3) * 8;
@@ -124,7 +126,7 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 #define CVMX_RST_DELAY CVMX_RST_DELAY_FUNC()
 static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001608ull);
 }
@@ -135,7 +137,7 @@ static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 #define CVMX_RST_ECO CVMX_RST_ECO_FUNC()
 static inline uint64_t CVMX_RST_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800060017B8ull);
 }
@@ -146,7 +148,7 @@ static inline uint64_t CVMX_RST_ECO_FUNC(void)
 #define CVMX_RST_INT CVMX_RST_INT_FUNC()
 static inline uint64_t CVMX_RST_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001628ull);
 }
@@ -157,7 +159,7 @@ static inline uint64_t CVMX_RST_INT_FUNC(void)
 #define CVMX_RST_INT_W1S CVMX_RST_INT_W1S_FUNC()
 static inline uint64_t CVMX_RST_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_RST_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001630ull);
 }
@@ -179,7 +181,7 @@ static inline uint64_t CVMX_RST_OCX_FUNC(void)
 #define CVMX_RST_OUT_CTL CVMX_RST_OUT_CTL_FUNC()
 static inline uint64_t CVMX_RST_OUT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_RST_OUT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001688ull);
 }
@@ -190,7 +192,7 @@ static inline uint64_t CVMX_RST_OUT_CTL_FUNC(void)
 #define CVMX_RST_POWER_DBG CVMX_RST_POWER_DBG_FUNC()
 static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_POWER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001708ull);
 }
@@ -201,7 +203,7 @@ static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 #define CVMX_RST_PP_POWER CVMX_RST_PP_POWER_FUNC()
 static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_PP_POWER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001700ull);
 }
@@ -212,7 +214,7 @@ static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 #define CVMX_RST_REF_CNTR CVMX_RST_REF_CNTR_FUNC()
 static inline uint64_t CVMX_RST_REF_CNTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_RST_REF_CNTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001758ull);
 }
@@ -225,6 +227,7 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_SOFT_PRSTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800060016C0ull) + ((offset) & 3) * 8;
@@ -236,7 +239,7 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 #define CVMX_RST_SOFT_RST CVMX_RST_SOFT_RST_FUNC()
 static inline uint64_t CVMX_RST_SOFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_SOFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001680ull);
 }
@@ -247,7 +250,7 @@ static inline uint64_t CVMX_RST_SOFT_RST_FUNC(void)
 #define CVMX_RST_THERMAL_ALERT CVMX_RST_THERMAL_ALERT_FUNC()
 static inline uint64_t CVMX_RST_THERMAL_ALERT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_RST_THERMAL_ALERT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001690ull);
 }
@@ -257,6 +260,9 @@ static inline uint64_t CVMX_RST_THERMAL_ALERT_FUNC(void)
 
 /**
  * cvmx_rst_bist_timer
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_rst_bist_timer {
 	uint64_t u64;
@@ -272,6 +278,8 @@ union cvmx_rst_bist_timer {
 #endif
 	} s;
 	struct cvmx_rst_bist_timer_s          cn73xx;
+	struct cvmx_rst_bist_timer_s          cn75xx;
+	struct cvmx_rst_bist_timer_s          cn78xxp2;
 };
 typedef union cvmx_rst_bist_timer cvmx_rst_bist_timer_t;
 
@@ -350,7 +358,9 @@ union cvmx_rst_boot {
 	struct cvmx_rst_boot_s                cn70xx;
 	struct cvmx_rst_boot_s                cn70xxp1;
 	struct cvmx_rst_boot_s                cn73xx;
+	struct cvmx_rst_boot_s                cn75xx;
 	struct cvmx_rst_boot_s                cn78xx;
+	struct cvmx_rst_boot_s                cn78xxp2;
 };
 typedef union cvmx_rst_boot cvmx_rst_boot_t;
 
@@ -407,7 +417,9 @@ union cvmx_rst_cfg {
 	uint64_t bist_delay                   : 58;
 #endif
 	} cn73xx;
+	struct cvmx_rst_cfg_cn73xx            cn75xx;
 	struct cvmx_rst_cfg_cn70xx            cn78xx;
+	struct cvmx_rst_cfg_cn70xx            cn78xxp2;
 };
 typedef union cvmx_rst_cfg cvmx_rst_cfg_t;
 
@@ -429,12 +441,17 @@ union cvmx_rst_ckill {
 	struct cvmx_rst_ckill_s               cn70xx;
 	struct cvmx_rst_ckill_s               cn70xxp1;
 	struct cvmx_rst_ckill_s               cn73xx;
+	struct cvmx_rst_ckill_s               cn75xx;
 	struct cvmx_rst_ckill_s               cn78xx;
+	struct cvmx_rst_ckill_s               cn78xxp2;
 };
 typedef union cvmx_rst_ckill cvmx_rst_ckill_t;
 
 /**
  * cvmx_rst_cold_data#
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_rst_cold_datax {
 	uint64_t u64;
@@ -447,6 +464,8 @@ union cvmx_rst_cold_datax {
 #endif
 	} s;
 	struct cvmx_rst_cold_datax_s          cn73xx;
+	struct cvmx_rst_cold_datax_s          cn75xx;
+	struct cvmx_rst_cold_datax_s          cn78xxp2;
 };
 typedef union cvmx_rst_cold_datax cvmx_rst_cold_datax_t;
 
@@ -517,7 +536,9 @@ union cvmx_rst_ctlx {
 	struct cvmx_rst_ctlx_s                cn70xx;
 	struct cvmx_rst_ctlx_s                cn70xxp1;
 	struct cvmx_rst_ctlx_s                cn73xx;
+	struct cvmx_rst_ctlx_s                cn75xx;
 	struct cvmx_rst_ctlx_s                cn78xx;
+	struct cvmx_rst_ctlx_s                cn78xxp2;
 };
 typedef union cvmx_rst_ctlx cvmx_rst_ctlx_t;
 
@@ -546,7 +567,9 @@ union cvmx_rst_delay {
 	struct cvmx_rst_delay_s               cn70xx;
 	struct cvmx_rst_delay_s               cn70xxp1;
 	struct cvmx_rst_delay_s               cn73xx;
+	struct cvmx_rst_delay_s               cn75xx;
 	struct cvmx_rst_delay_s               cn78xx;
+	struct cvmx_rst_delay_s               cn78xxp2;
 };
 typedef union cvmx_rst_delay cvmx_rst_delay_t;
 
@@ -565,7 +588,9 @@ union cvmx_rst_eco {
 #endif
 	} s;
 	struct cvmx_rst_eco_s                 cn73xx;
+	struct cvmx_rst_eco_s                 cn75xx;
 	struct cvmx_rst_eco_s                 cn78xx;
+	struct cvmx_rst_eco_s                 cn78xxp2;
 };
 typedef union cvmx_rst_eco cvmx_rst_eco_t;
 
@@ -606,7 +631,9 @@ union cvmx_rst_int {
 	} cn70xx;
 	struct cvmx_rst_int_cn70xx            cn70xxp1;
 	struct cvmx_rst_int_s                 cn73xx;
+	struct cvmx_rst_int_s                 cn75xx;
 	struct cvmx_rst_int_s                 cn78xx;
+	struct cvmx_rst_int_s                 cn78xxp2;
 };
 typedef union cvmx_rst_int cvmx_rst_int_t;
 
@@ -631,6 +658,8 @@ union cvmx_rst_int_w1s {
 #endif
 	} s;
 	struct cvmx_rst_int_w1s_s             cn73xx;
+	struct cvmx_rst_int_w1s_s             cn75xx;
+	struct cvmx_rst_int_w1s_s             cn78xxp2;
 };
 typedef union cvmx_rst_int_w1s cvmx_rst_int_w1s_t;
 
@@ -645,13 +674,15 @@ union cvmx_rst_ocx {
 	uint64_t rst_link                     : 3;  /**< Controls whether corresponding OCX link going down causes a chip reset. A warm/soft reset
                                                          does not change this field. On cold reset, this field is initialized to 0. See
                                                          OCX_COM_LINK()_CTL for a description of what events can contribute to the link_down
-                                                         condition. */
+                                                         condition.
+                                                         Made readable in pass 2. */
 #else
 	uint64_t rst_link                     : 3;
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
 	struct cvmx_rst_ocx_s                 cn78xx;
+	struct cvmx_rst_ocx_s                 cn78xxp2;
 };
 typedef union cvmx_rst_ocx cvmx_rst_ocx_t;
 
@@ -673,6 +704,7 @@ union cvmx_rst_out_ctl {
 #endif
 	} s;
 	struct cvmx_rst_out_ctl_s             cn73xx;
+	struct cvmx_rst_out_ctl_s             cn75xx;
 };
 typedef union cvmx_rst_out_ctl cvmx_rst_out_ctl_t;
 
@@ -691,7 +723,9 @@ union cvmx_rst_power_dbg {
 #endif
 	} s;
 	struct cvmx_rst_power_dbg_s           cn73xx;
+	struct cvmx_rst_power_dbg_s           cn75xx;
 	struct cvmx_rst_power_dbg_s           cn78xx;
+	struct cvmx_rst_power_dbg_s           cn78xxp2;
 };
 typedef union cvmx_rst_power_dbg cvmx_rst_power_dbg_t;
 
@@ -737,12 +771,17 @@ union cvmx_rst_pp_power {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} cn73xx;
+	struct cvmx_rst_pp_power_cn73xx       cn75xx;
 	struct cvmx_rst_pp_power_s            cn78xx;
+	struct cvmx_rst_pp_power_s            cn78xxp2;
 };
 typedef union cvmx_rst_pp_power cvmx_rst_pp_power_t;
 
 /**
  * cvmx_rst_ref_cntr
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_rst_ref_cntr {
 	uint64_t u64;
@@ -756,6 +795,8 @@ union cvmx_rst_ref_cntr {
 #endif
 	} s;
 	struct cvmx_rst_ref_cntr_s            cn73xx;
+	struct cvmx_rst_ref_cntr_s            cn75xx;
+	struct cvmx_rst_ref_cntr_s            cn78xxp2;
 };
 typedef union cvmx_rst_ref_cntr cvmx_rst_ref_cntr_t;
 
@@ -781,7 +822,9 @@ union cvmx_rst_soft_prstx {
 	struct cvmx_rst_soft_prstx_s          cn70xx;
 	struct cvmx_rst_soft_prstx_s          cn70xxp1;
 	struct cvmx_rst_soft_prstx_s          cn73xx;
+	struct cvmx_rst_soft_prstx_s          cn75xx;
 	struct cvmx_rst_soft_prstx_s          cn78xx;
+	struct cvmx_rst_soft_prstx_s          cn78xxp2;
 };
 typedef union cvmx_rst_soft_prstx cvmx_rst_soft_prstx_t;
 
@@ -803,7 +846,9 @@ union cvmx_rst_soft_rst {
 	struct cvmx_rst_soft_rst_s            cn70xx;
 	struct cvmx_rst_soft_rst_s            cn70xxp1;
 	struct cvmx_rst_soft_rst_s            cn73xx;
+	struct cvmx_rst_soft_rst_s            cn75xx;
 	struct cvmx_rst_soft_rst_s            cn78xx;
+	struct cvmx_rst_soft_rst_s            cn78xxp2;
 };
 typedef union cvmx_rst_soft_rst cvmx_rst_soft_rst_t;
 
@@ -834,6 +879,7 @@ union cvmx_rst_thermal_alert {
 #endif
 	} s;
 	struct cvmx_rst_thermal_alert_s       cn73xx;
+	struct cvmx_rst_thermal_alert_s       cn75xx;
 };
 typedef union cvmx_rst_thermal_alert cvmx_rst_thermal_alert_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index bfaca54..26fbc0b 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_SLI_BIST_STATUS CVMX_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_BIST_STATUS not supported on this chip\n");
 	return 0x0000000000000580ull;
 }
@@ -73,6 +73,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -85,7 +86,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_SLI_CTL_STATUS CVMX_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_CTL_STATUS not supported on this chip\n");
 	return 0x0000000000000570ull;
 }
@@ -96,7 +97,7 @@ static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_SLI_DATA_OUT_CNT CVMX_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return 0x00000000000005F0ull;
 }
@@ -135,6 +136,7 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -153,6 +155,7 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -171,6 +174,7 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -200,6 +204,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -212,7 +217,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_SLI_INT_SUM CVMX_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_INT_SUM not supported on this chip\n");
 	return 0x0000000000000330ull;
 }
@@ -267,7 +272,7 @@ static inline uint64_t CVMX_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT CVMX_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return 0x0000000000003D70ull;
 }
@@ -278,7 +283,7 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return 0x0000000000003E10ull;
 }
@@ -300,6 +305,7 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 			return 0x0000000000003E00ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020050ull;
 			break;
 	}
@@ -320,6 +326,7 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003E00ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020050ull;
 	}
 	return 0x0000000000003E00ull;
@@ -329,7 +336,7 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 #define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return 0x00000000000002F0ull;
 }
@@ -346,6 +353,7 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -363,6 +371,7 @@ static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 			break;
 	}
@@ -377,6 +386,7 @@ static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
@@ -391,6 +401,7 @@ static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 			break;
 	}
@@ -405,6 +416,7 @@ static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
@@ -419,6 +431,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 64))
 				return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + ((offset) & 127) * 16;
 			break;
@@ -433,6 +446,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
@@ -447,6 +461,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 64))
 				return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + ((offset) & 127) * 16;
 			break;
@@ -461,6 +476,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
@@ -497,6 +513,7 @@ static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 			break;
 	}
@@ -511,6 +528,7 @@ static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
@@ -525,6 +543,7 @@ static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000001010ull);
 			break;
 	}
@@ -539,6 +558,7 @@ static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000001010ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
@@ -592,7 +612,7 @@ static inline uint64_t CVMX_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_RCV0 CVMX_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV0 not supported on this chip\n");
 	return 0x0000000000003C10ull;
 }
@@ -603,7 +623,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_SLI_MSI_RCV1 CVMX_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV1 not supported on this chip\n");
 	return 0x0000000000003C20ull;
 }
@@ -614,7 +634,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_SLI_MSI_RCV2 CVMX_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV2 not supported on this chip\n");
 	return 0x0000000000003C30ull;
 }
@@ -625,7 +645,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_SLI_MSI_RCV3 CVMX_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV3 not supported on this chip\n");
 	return 0x0000000000003C40ull;
 }
@@ -636,7 +656,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_SLI_MSI_RD_MAP CVMX_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RD_MAP not supported on this chip\n");
 	return 0x0000000000003CA0ull;
 }
@@ -735,7 +755,7 @@ static inline uint64_t CVMX_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_WR_MAP CVMX_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_WR_MAP not supported on this chip\n");
 	return 0x0000000000003C90ull;
 }
@@ -746,7 +766,7 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV CVMX_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return 0x0000000000003CB0ull;
 }
@@ -757,7 +777,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B1 CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return 0x0000000000000650ull;
 }
@@ -768,7 +788,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B2 CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return 0x0000000000000660ull;
 }
@@ -779,7 +799,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B3 CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return 0x0000000000000670ull;
 }
@@ -796,6 +816,7 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -813,6 +834,7 @@ static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -827,6 +849,7 @@ static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
@@ -842,6 +865,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
@@ -860,6 +884,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -878,6 +903,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -911,6 +937,7 @@ static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -925,6 +952,7 @@ static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
@@ -949,7 +977,8 @@ static inline uint64_t CVMX_SLI_PKTX_IN_BP(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_MBOX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_SLI_PKTX_MBOX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000010210ull) + ((offset) & 127) * 0x20000ull;
 }
@@ -965,6 +994,7 @@ static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -979,6 +1009,7 @@ static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
@@ -994,6 +1025,7 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
@@ -1006,7 +1038,8 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 63))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 63)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 63))))))
 		cvmx_warn("CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000010200ull) + (((offset) & 1) + ((block_id) & 63) * 0x4000ull) * 8;
 }
@@ -1023,6 +1056,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
@@ -1041,6 +1075,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -1059,6 +1094,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -1079,10 +1115,21 @@ static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 #define CVMX_SLI_PKTX_VF_SIG(offset) (CVMX_ADD_IO_SEG(0x00011F0000014C00ull) + ((offset) & 63) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_BIST_STATUS CVMX_SLI_PKT_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_SLI_PKT_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_SLI_PKT_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029220ull);
+}
+#else
+#define CVMX_SLI_PKT_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011F0000029220ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_CNT_INT CVMX_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_CNT_INT not supported on this chip\n");
 	return 0x0000000000001130ull;
 }
@@ -1170,7 +1217,7 @@ static inline uint64_t CVMX_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB CVMX_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return 0x0000000000001000ull;
 }
@@ -1181,7 +1228,7 @@ static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB2 CVMX_SLI_PKT_INSTR_ENB2_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_ENB2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029008ull);
 }
@@ -1219,6 +1266,7 @@ static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 			break;
 	}
@@ -1233,6 +1281,7 @@ static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
@@ -1270,6 +1319,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1282,7 +1332,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 #define CVMX_SLI_PKT_IN_INSTR_COUNTS CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return 0x0000000000001200ull;
 }
@@ -1298,6 +1348,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 			break;
 	}
@@ -1312,6 +1363,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
@@ -1387,7 +1439,8 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_PKT_MACX_PFX_RINFO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000029030ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
 }
@@ -1414,6 +1467,7 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 			break;
 	}
@@ -1428,6 +1482,7 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
@@ -1437,7 +1492,7 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 #define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return 0x0000000000001180ull;
 }
@@ -1459,7 +1514,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN CVMX_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return 0x0000000000001240ull;
 }
@@ -1470,7 +1525,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN2 CVMX_SLI_PKT_OUT_BP_EN2_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029250ull);
 }
@@ -1481,7 +1536,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_FUNC(void)
 #define CVMX_SLI_PKT_OUT_ENB CVMX_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return 0x0000000000001010ull;
 }
@@ -1492,7 +1547,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 #define CVMX_SLI_PKT_OUT_ENB2 CVMX_SLI_PKT_OUT_ENB2_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_ENB2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_ENB2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029018ull);
 }
@@ -1530,6 +1585,7 @@ static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 			break;
 	}
@@ -1544,6 +1600,7 @@ static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
@@ -1586,7 +1643,7 @@ static inline uint64_t CVMX_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT CVMX_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_TIME_INT not supported on this chip\n");
 	return 0x0000000000001140ull;
 }
@@ -1605,17 +1662,6 @@ static inline uint64_t CVMX_SLI_PKT_TIME_INT_ENB_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT_ENB (0x0000000000001160ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_PKT_VF_SIG_INT CVMX_SLI_PKT_VF_SIG_INT_FUNC()
-static inline uint64_t CVMX_SLI_PKT_VF_SIG_INT_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
-		cvmx_warn("CVMX_SLI_PKT_VF_SIG_INT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
-}
-#else
-#define CVMX_SLI_PKT_VF_SIG_INT (CVMX_ADD_IO_SEG(0x00011F0000029170ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 {
 	if (!(
@@ -1635,6 +1681,7 @@ static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 			break;
 	}
@@ -1649,6 +1696,7 @@ static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
@@ -1664,6 +1712,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1676,7 +1725,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_SLI_SCRATCH_1 CVMX_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_1 not supported on this chip\n");
 	return 0x00000000000003C0ull;
 }
@@ -1687,7 +1736,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_SLI_SCRATCH_2 CVMX_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_2 not supported on this chip\n");
 	return 0x00000000000003D0ull;
 }
@@ -1698,7 +1747,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_SLI_STATE1 CVMX_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE1 not supported on this chip\n");
 	return 0x0000000000000620ull;
 }
@@ -1709,7 +1758,7 @@ static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 #define CVMX_SLI_STATE2 CVMX_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE2 not supported on this chip\n");
 	return 0x0000000000000630ull;
 }
@@ -1720,7 +1769,7 @@ static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 #define CVMX_SLI_STATE3 CVMX_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE3 not supported on this chip\n");
 	return 0x0000000000000640ull;
 }
@@ -1742,7 +1791,7 @@ static inline uint64_t CVMX_SLI_TX_PIPE_FUNC(void)
 #define CVMX_SLI_WINDOW_CTL CVMX_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WINDOW_CTL not supported on this chip\n");
 	return 0x00000000000002E0ull;
 }
@@ -1764,6 +1813,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 			return 0x0000000000000010ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020010ull;
 			break;
 	}
@@ -1784,6 +1834,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000010ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020010ull;
 	}
 	return 0x0000000000000010ull;
@@ -1804,6 +1855,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 			return 0x0000000000000040ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020040ull;
 			break;
 	}
@@ -1824,6 +1876,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000040ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020040ull;
 	}
 	return 0x0000000000000040ull;
@@ -1844,6 +1897,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 			return 0x0000000000000000ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020000ull;
 			break;
 	}
@@ -1864,6 +1918,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020000ull;
 	}
 	return 0x0000000000000000ull;
@@ -1884,6 +1939,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 			return 0x0000000000000020ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020020ull;
 			break;
 	}
@@ -1904,6 +1960,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000020ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020020ull;
 	}
 	return 0x0000000000000020ull;
@@ -1924,6 +1981,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 			return 0x0000000000000030ull;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020030ull;
 			break;
 	}
@@ -1944,6 +2002,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000030ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000020030ull;
 	}
 	return 0x0000000000000030ull;
@@ -2180,7 +2239,9 @@ union cvmx_sli_bist_status {
 	} cn70xx;
 	struct cvmx_sli_bist_status_cn70xx    cn70xxp1;
 	struct cvmx_sli_bist_status_s         cn73xx;
+	struct cvmx_sli_bist_status_s         cn75xx;
 	struct cvmx_sli_bist_status_s         cn78xx;
+	struct cvmx_sli_bist_status_s         cn78xxp2;
 	struct cvmx_sli_bist_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_bist_status cvmx_sli_bist_status_t;
@@ -2351,7 +2412,9 @@ union cvmx_sli_ctl_portx {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} cn73xx;
+	struct cvmx_sli_ctl_portx_cn73xx      cn75xx;
 	struct cvmx_sli_ctl_portx_cn73xx      cn78xx;
+	struct cvmx_sli_ctl_portx_cn73xx      cn78xxp2;
 	struct cvmx_sli_ctl_portx_s           cnf71xx;
 };
 typedef union cvmx_sli_ctl_portx cvmx_sli_ctl_portx_t;
@@ -2445,7 +2508,9 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_cn63xx     cn70xx;
 	struct cvmx_sli_ctl_status_cn63xx     cn70xxp1;
 	struct cvmx_sli_ctl_status_s          cn73xx;
+	struct cvmx_sli_ctl_status_s          cn75xx;
 	struct cvmx_sli_ctl_status_s          cn78xx;
+	struct cvmx_sli_ctl_status_s          cn78xxp2;
 	struct cvmx_sli_ctl_status_cn61xx     cnf71xx;
 };
 typedef union cvmx_sli_ctl_status cvmx_sli_ctl_status_t;
@@ -2490,7 +2555,9 @@ union cvmx_sli_data_out_cnt {
 	struct cvmx_sli_data_out_cnt_s        cn70xx;
 	struct cvmx_sli_data_out_cnt_s        cn70xxp1;
 	struct cvmx_sli_data_out_cnt_s        cn73xx;
+	struct cvmx_sli_data_out_cnt_s        cn75xx;
 	struct cvmx_sli_data_out_cnt_s        cn78xx;
+	struct cvmx_sli_data_out_cnt_s        cn78xxp2;
 	struct cvmx_sli_data_out_cnt_s        cnf71xx;
 };
 typedef union cvmx_sli_data_out_cnt cvmx_sli_data_out_cnt_t;
@@ -2602,7 +2669,9 @@ union cvmx_sli_dmax_cnt {
 	struct cvmx_sli_dmax_cnt_s            cn70xx;
 	struct cvmx_sli_dmax_cnt_s            cn70xxp1;
 	struct cvmx_sli_dmax_cnt_s            cn73xx;
+	struct cvmx_sli_dmax_cnt_s            cn75xx;
 	struct cvmx_sli_dmax_cnt_s            cn78xx;
+	struct cvmx_sli_dmax_cnt_s            cn78xxp2;
 	struct cvmx_sli_dmax_cnt_s            cnf71xx;
 };
 typedef union cvmx_sli_dmax_cnt cvmx_sli_dmax_cnt_t;
@@ -2639,7 +2708,9 @@ union cvmx_sli_dmax_int_level {
 	struct cvmx_sli_dmax_int_level_s      cn70xx;
 	struct cvmx_sli_dmax_int_level_s      cn70xxp1;
 	struct cvmx_sli_dmax_int_level_s      cn73xx;
+	struct cvmx_sli_dmax_int_level_s      cn75xx;
 	struct cvmx_sli_dmax_int_level_s      cn78xx;
+	struct cvmx_sli_dmax_int_level_s      cn78xxp2;
 	struct cvmx_sli_dmax_int_level_s      cnf71xx;
 };
 typedef union cvmx_sli_dmax_int_level cvmx_sli_dmax_int_level_t;
@@ -2672,7 +2743,9 @@ union cvmx_sli_dmax_tim {
 	struct cvmx_sli_dmax_tim_s            cn70xx;
 	struct cvmx_sli_dmax_tim_s            cn70xxp1;
 	struct cvmx_sli_dmax_tim_s            cn73xx;
+	struct cvmx_sli_dmax_tim_s            cn75xx;
 	struct cvmx_sli_dmax_tim_s            cn78xx;
+	struct cvmx_sli_dmax_tim_s            cn78xxp2;
 	struct cvmx_sli_dmax_tim_s            cnf71xx;
 };
 typedef union cvmx_sli_dmax_tim cvmx_sli_dmax_tim_t;
@@ -3927,7 +4000,9 @@ union cvmx_sli_int_enb_portx {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_sli_int_enb_portx_cn73xx  cn75xx;
 	struct cvmx_sli_int_enb_portx_cn73xx  cn78xx;
+	struct cvmx_sli_int_enb_portx_cn73xx  cn78xxp2;
 	struct cvmx_sli_int_enb_portx_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
@@ -4834,7 +4909,9 @@ union cvmx_sli_int_sum {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_sli_int_sum_cn73xx        cn75xx;
 	struct cvmx_sli_int_sum_cn73xx        cn78xx;
+	struct cvmx_sli_int_sum_cn73xx        cn78xxp2;
 	struct cvmx_sli_int_sum_cn61xx        cnf71xx;
 };
 typedef union cvmx_sli_int_sum cvmx_sli_int_sum_t;
@@ -5019,7 +5096,9 @@ union cvmx_sli_mac_credit_cnt {
 	struct cvmx_sli_mac_credit_cnt_s      cn70xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn70xxp1;
 	struct cvmx_sli_mac_credit_cnt_s      cn73xx;
+	struct cvmx_sli_mac_credit_cnt_s      cn75xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn78xx;
+	struct cvmx_sli_mac_credit_cnt_s      cn78xxp2;
 	struct cvmx_sli_mac_credit_cnt_s      cnf71xx;
 };
 typedef union cvmx_sli_mac_credit_cnt cvmx_sli_mac_credit_cnt_t;
@@ -5076,7 +5155,9 @@ union cvmx_sli_mac_credit_cnt2 {
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xxp1;
 	struct cvmx_sli_mac_credit_cnt2_s     cn73xx;
+	struct cvmx_sli_mac_credit_cnt2_s     cn75xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn78xx;
+	struct cvmx_sli_mac_credit_cnt2_s     cn78xxp2;
 	struct cvmx_sli_mac_credit_cnt2_s     cnf71xx;
 };
 typedef union cvmx_sli_mac_credit_cnt2 cvmx_sli_mac_credit_cnt2_t;
@@ -5116,7 +5197,9 @@ union cvmx_sli_mac_number {
 	struct cvmx_sli_mac_number_s          cn70xx;
 	struct cvmx_sli_mac_number_s          cn70xxp1;
 	struct cvmx_sli_mac_number_s          cn73xx;
+	struct cvmx_sli_mac_number_s          cn75xx;
 	struct cvmx_sli_mac_number_s          cn78xx;
+	struct cvmx_sli_mac_number_s          cn78xxp2;
 	struct cvmx_sli_mac_number_s          cnf71xx;
 };
 typedef union cvmx_sli_mac_number cvmx_sli_mac_number_t;
@@ -5155,7 +5238,9 @@ union cvmx_sli_mem_access_ctl {
 	struct cvmx_sli_mem_access_ctl_s      cn70xx;
 	struct cvmx_sli_mem_access_ctl_s      cn70xxp1;
 	struct cvmx_sli_mem_access_ctl_s      cn73xx;
+	struct cvmx_sli_mem_access_ctl_s      cn75xx;
 	struct cvmx_sli_mem_access_ctl_s      cn78xx;
+	struct cvmx_sli_mem_access_ctl_s      cn78xxp2;
 	struct cvmx_sli_mem_access_ctl_s      cnf71xx;
 };
 typedef union cvmx_sli_mem_access_ctl cvmx_sli_mem_access_ctl_t;
@@ -5339,7 +5424,9 @@ union cvmx_sli_mem_access_subidx {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_sli_mem_access_subidx_cn73xx cn75xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn78xx;
+	struct cvmx_sli_mem_access_subidx_cn61xx cn78xxp2;
 	struct cvmx_sli_mem_access_subidx_cn61xx cnf71xx;
 };
 typedef union cvmx_sli_mem_access_subidx cvmx_sli_mem_access_subidx_t;
@@ -5396,7 +5483,9 @@ union cvmx_sli_mem_ctl {
 #endif
 	} s;
 	struct cvmx_sli_mem_ctl_s             cn73xx;
+	struct cvmx_sli_mem_ctl_s             cn75xx;
 	struct cvmx_sli_mem_ctl_s             cn78xx;
+	struct cvmx_sli_mem_ctl_s             cn78xxp2;
 };
 typedef union cvmx_sli_mem_ctl cvmx_sli_mem_ctl_t;
 
@@ -5452,7 +5541,9 @@ union cvmx_sli_mem_int_sum {
 #endif
 	} s;
 	struct cvmx_sli_mem_int_sum_s         cn73xx;
+	struct cvmx_sli_mem_int_sum_s         cn75xx;
 	struct cvmx_sli_mem_int_sum_s         cn78xx;
+	struct cvmx_sli_mem_int_sum_s         cn78xxp2;
 };
 typedef union cvmx_sli_mem_int_sum cvmx_sli_mem_int_sum_t;
 
@@ -5588,7 +5679,9 @@ union cvmx_sli_msi_rcv0 {
 	struct cvmx_sli_msi_rcv0_s            cn70xx;
 	struct cvmx_sli_msi_rcv0_s            cn70xxp1;
 	struct cvmx_sli_msi_rcv0_s            cn73xx;
+	struct cvmx_sli_msi_rcv0_s            cn75xx;
 	struct cvmx_sli_msi_rcv0_s            cn78xx;
+	struct cvmx_sli_msi_rcv0_s            cn78xxp2;
 	struct cvmx_sli_msi_rcv0_s            cnf71xx;
 };
 typedef union cvmx_sli_msi_rcv0 cvmx_sli_msi_rcv0_t;
@@ -5617,7 +5710,9 @@ union cvmx_sli_msi_rcv1 {
 	struct cvmx_sli_msi_rcv1_s            cn70xx;
 	struct cvmx_sli_msi_rcv1_s            cn70xxp1;
 	struct cvmx_sli_msi_rcv1_s            cn73xx;
+	struct cvmx_sli_msi_rcv1_s            cn75xx;
 	struct cvmx_sli_msi_rcv1_s            cn78xx;
+	struct cvmx_sli_msi_rcv1_s            cn78xxp2;
 	struct cvmx_sli_msi_rcv1_s            cnf71xx;
 };
 typedef union cvmx_sli_msi_rcv1 cvmx_sli_msi_rcv1_t;
@@ -5646,7 +5741,9 @@ union cvmx_sli_msi_rcv2 {
 	struct cvmx_sli_msi_rcv2_s            cn70xx;
 	struct cvmx_sli_msi_rcv2_s            cn70xxp1;
 	struct cvmx_sli_msi_rcv2_s            cn73xx;
+	struct cvmx_sli_msi_rcv2_s            cn75xx;
 	struct cvmx_sli_msi_rcv2_s            cn78xx;
+	struct cvmx_sli_msi_rcv2_s            cn78xxp2;
 	struct cvmx_sli_msi_rcv2_s            cnf71xx;
 };
 typedef union cvmx_sli_msi_rcv2 cvmx_sli_msi_rcv2_t;
@@ -5675,7 +5772,9 @@ union cvmx_sli_msi_rcv3 {
 	struct cvmx_sli_msi_rcv3_s            cn70xx;
 	struct cvmx_sli_msi_rcv3_s            cn70xxp1;
 	struct cvmx_sli_msi_rcv3_s            cn73xx;
+	struct cvmx_sli_msi_rcv3_s            cn75xx;
 	struct cvmx_sli_msi_rcv3_s            cn78xx;
+	struct cvmx_sli_msi_rcv3_s            cn78xxp2;
 	struct cvmx_sli_msi_rcv3_s            cnf71xx;
 };
 typedef union cvmx_sli_msi_rcv3 cvmx_sli_msi_rcv3_t;
@@ -5710,7 +5809,9 @@ union cvmx_sli_msi_rd_map {
 	struct cvmx_sli_msi_rd_map_s          cn70xx;
 	struct cvmx_sli_msi_rd_map_s          cn70xxp1;
 	struct cvmx_sli_msi_rd_map_s          cn73xx;
+	struct cvmx_sli_msi_rd_map_s          cn75xx;
 	struct cvmx_sli_msi_rd_map_s          cn78xx;
+	struct cvmx_sli_msi_rd_map_s          cn78xxp2;
 	struct cvmx_sli_msi_rd_map_s          cnf71xx;
 };
 typedef union cvmx_sli_msi_rd_map cvmx_sli_msi_rd_map_t;
@@ -5980,7 +6081,9 @@ union cvmx_sli_msi_wr_map {
 	struct cvmx_sli_msi_wr_map_s          cn70xx;
 	struct cvmx_sli_msi_wr_map_s          cn70xxp1;
 	struct cvmx_sli_msi_wr_map_s          cn73xx;
+	struct cvmx_sli_msi_wr_map_s          cn75xx;
 	struct cvmx_sli_msi_wr_map_s          cn78xx;
+	struct cvmx_sli_msi_wr_map_s          cn78xxp2;
 	struct cvmx_sli_msi_wr_map_s          cnf71xx;
 };
 typedef union cvmx_sli_msi_wr_map cvmx_sli_msi_wr_map_t;
@@ -6030,7 +6133,9 @@ union cvmx_sli_msixx_table_addr {
 #endif
 	} s;
 	struct cvmx_sli_msixx_table_addr_s    cn73xx;
+	struct cvmx_sli_msixx_table_addr_s    cn75xx;
 	struct cvmx_sli_msixx_table_addr_s    cn78xx;
+	struct cvmx_sli_msixx_table_addr_s    cn78xxp2;
 };
 typedef union cvmx_sli_msixx_table_addr cvmx_sli_msixx_table_addr_t;
 
@@ -6054,7 +6159,9 @@ union cvmx_sli_msixx_table_data {
 #endif
 	} s;
 	struct cvmx_sli_msixx_table_data_s    cn73xx;
+	struct cvmx_sli_msixx_table_data_s    cn75xx;
 	struct cvmx_sli_msixx_table_data_s    cn78xx;
+	struct cvmx_sli_msixx_table_data_s    cn78xxp2;
 };
 typedef union cvmx_sli_msixx_table_data cvmx_sli_msixx_table_data_t;
 
@@ -6074,6 +6181,7 @@ union cvmx_sli_msix_macx_pf_table_addr {
 #endif
 	} s;
 	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xx;
+	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xxp2;
 };
 typedef union cvmx_sli_msix_macx_pf_table_addr cvmx_sli_msix_macx_pf_table_addr_t;
 
@@ -6097,6 +6205,7 @@ union cvmx_sli_msix_macx_pf_table_data {
 #endif
 	} s;
 	struct cvmx_sli_msix_macx_pf_table_data_s cn78xx;
+	struct cvmx_sli_msix_macx_pf_table_data_s cn78xxp2;
 };
 typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_t;
 
@@ -6150,7 +6259,9 @@ union cvmx_sli_msix_pba0 {
 #endif
 	} s;
 	struct cvmx_sli_msix_pba0_s           cn73xx;
+	struct cvmx_sli_msix_pba0_s           cn75xx;
 	struct cvmx_sli_msix_pba0_s           cn78xx;
+	struct cvmx_sli_msix_pba0_s           cn78xxp2;
 };
 typedef union cvmx_sli_msix_pba0 cvmx_sli_msix_pba0_t;
 
@@ -6180,7 +6291,9 @@ union cvmx_sli_msix_pba1 {
 #endif
 	} s;
 	struct cvmx_sli_msix_pba1_s           cn73xx;
+	struct cvmx_sli_msix_pba1_s           cn75xx;
 	struct cvmx_sli_msix_pba1_s           cn78xx;
+	struct cvmx_sli_msix_pba1_s           cn78xxp2;
 };
 typedef union cvmx_sli_msix_pba1 cvmx_sli_msix_pba1_t;
 
@@ -6214,7 +6327,9 @@ union cvmx_sli_pcie_msi_rcv {
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xxp1;
 	struct cvmx_sli_pcie_msi_rcv_s        cn73xx;
+	struct cvmx_sli_pcie_msi_rcv_s        cn75xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn78xx;
+	struct cvmx_sli_pcie_msi_rcv_s        cn78xxp2;
 	struct cvmx_sli_pcie_msi_rcv_s        cnf71xx;
 };
 typedef union cvmx_sli_pcie_msi_rcv cvmx_sli_pcie_msi_rcv_t;
@@ -6252,7 +6367,9 @@ union cvmx_sli_pcie_msi_rcv_b1 {
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn73xx;
+	struct cvmx_sli_pcie_msi_rcv_b1_s     cn75xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn78xx;
+	struct cvmx_sli_pcie_msi_rcv_b1_s     cn78xxp2;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cnf71xx;
 };
 typedef union cvmx_sli_pcie_msi_rcv_b1 cvmx_sli_pcie_msi_rcv_b1_t;
@@ -6290,7 +6407,9 @@ union cvmx_sli_pcie_msi_rcv_b2 {
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn73xx;
+	struct cvmx_sli_pcie_msi_rcv_b2_s     cn75xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn78xx;
+	struct cvmx_sli_pcie_msi_rcv_b2_s     cn78xxp2;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cnf71xx;
 };
 typedef union cvmx_sli_pcie_msi_rcv_b2 cvmx_sli_pcie_msi_rcv_b2_t;
@@ -6328,7 +6447,9 @@ union cvmx_sli_pcie_msi_rcv_b3 {
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn73xx;
+	struct cvmx_sli_pcie_msi_rcv_b3_s     cn75xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn78xx;
+	struct cvmx_sli_pcie_msi_rcv_b3_s     cn78xxp2;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cnf71xx;
 };
 typedef union cvmx_sli_pcie_msi_rcv_b3 cvmx_sli_pcie_msi_rcv_b3_t;
@@ -6476,6 +6597,7 @@ union cvmx_sli_pktx_cnts {
 	uint64_t po_int                       : 1;
 #endif
 	} cn73xx;
+	struct cvmx_sli_pktx_cnts_cn73xx      cn75xx;
 	struct cvmx_sli_pktx_cnts_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t po_int                       : 1;  /**< Packet output interrupt bit for the ring (i). [PO_INT] reads as one whenever:
@@ -6507,6 +6629,7 @@ union cvmx_sli_pktx_cnts {
 	uint64_t po_int                       : 1;
 #endif
 	} cn78xx;
+	struct cvmx_sli_pktx_cnts_cn78xx      cn78xxp2;
 	struct cvmx_sli_pktx_cnts_cn61xx      cnf71xx;
 };
 typedef union cvmx_sli_pktx_cnts cvmx_sli_pktx_cnts_t;
@@ -6724,6 +6847,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} cn73xx;
+	struct cvmx_sli_pktx_input_control_cn73xx cn75xx;
 	struct cvmx_sli_pktx_input_control_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
@@ -6813,6 +6937,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t reserved_39_63               : 25;
 #endif
 	} cn78xx;
+	struct cvmx_sli_pktx_input_control_cn78xx cn78xxp2;
 };
 typedef union cvmx_sli_pktx_input_control cvmx_sli_pktx_input_control_t;
 
@@ -6842,7 +6967,9 @@ union cvmx_sli_pktx_instr_baddr {
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xxp1;
 	struct cvmx_sli_pktx_instr_baddr_s    cn73xx;
+	struct cvmx_sli_pktx_instr_baddr_s    cn75xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn78xx;
+	struct cvmx_sli_pktx_instr_baddr_s    cn78xxp2;
 	struct cvmx_sli_pktx_instr_baddr_s    cnf71xx;
 };
 typedef union cvmx_sli_pktx_instr_baddr cvmx_sli_pktx_instr_baddr_t;
@@ -6877,7 +7004,9 @@ union cvmx_sli_pktx_instr_baoff_dbell {
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xxp1;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn73xx;
+	struct cvmx_sli_pktx_instr_baoff_dbell_s cn75xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn78xx;
+	struct cvmx_sli_pktx_instr_baoff_dbell_s cn78xxp2;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cnf71xx;
 };
 typedef union cvmx_sli_pktx_instr_baoff_dbell cvmx_sli_pktx_instr_baoff_dbell_t;
@@ -6914,7 +7043,9 @@ union cvmx_sli_pktx_instr_fifo_rsize {
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xxp1;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn73xx;
+	struct cvmx_sli_pktx_instr_fifo_rsize_s cn75xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn78xx;
+	struct cvmx_sli_pktx_instr_fifo_rsize_s cn78xxp2;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cnf71xx;
 };
 typedef union cvmx_sli_pktx_instr_fifo_rsize cvmx_sli_pktx_instr_fifo_rsize_t;
@@ -7167,15 +7298,17 @@ union cvmx_sli_pktx_int_levels {
 #endif
 	} s;
 	struct cvmx_sli_pktx_int_levels_s     cn73xx;
+	struct cvmx_sli_pktx_int_levels_s     cn75xx;
 	struct cvmx_sli_pktx_int_levels_s     cn78xx;
+	struct cvmx_sli_pktx_int_levels_s     cn78xxp2;
 };
 typedef union cvmx_sli_pktx_int_levels cvmx_sli_pktx_int_levels_t;
 
 /**
  * cvmx_sli_pkt#_mbox_int
  *
- * This register contains information to service mbox interrupts from the VF
- *
+ * This register contains information to service mbox interrupts to the VF
+ * when the PF writes the SLI_PKT(0..63)_PF_VF_MBOX_SIG0 register
  */
 union cvmx_sli_pktx_mbox_int {
 	uint64_t u64;
@@ -7194,8 +7327,7 @@ union cvmx_sli_pktx_mbox_int {
                                                          PI_INT or MBOX_INT. */
 	uint64_t reserved_1_59                : 59;
 	uint64_t mbox_en                      : 1;  /**< Enables interrupt to the MSIX vector associated with this VF when the PF writes the
-                                                         corresponding
-                                                         ring in SLI_PKT(0..63)_VF_MBOX_SIG2 */
+                                                         corresponding ring in SLI_PKT(0..63)_VF_MBOX_SIG0 */
 #else
 	uint64_t mbox_en                      : 1;
 	uint64_t reserved_1_59                : 59;
@@ -7206,6 +7338,7 @@ union cvmx_sli_pktx_mbox_int {
 #endif
 	} s;
 	struct cvmx_sli_pktx_mbox_int_s       cn73xx;
+	struct cvmx_sli_pktx_mbox_int_s       cn75xx;
 };
 typedef union cvmx_sli_pktx_mbox_int cvmx_sli_pktx_mbox_int_t;
 
@@ -7238,7 +7371,9 @@ union cvmx_sli_pktx_out_size {
 	struct cvmx_sli_pktx_out_size_s       cn70xx;
 	struct cvmx_sli_pktx_out_size_s       cn70xxp1;
 	struct cvmx_sli_pktx_out_size_s       cn73xx;
+	struct cvmx_sli_pktx_out_size_s       cn75xx;
 	struct cvmx_sli_pktx_out_size_s       cn78xx;
+	struct cvmx_sli_pktx_out_size_s       cn78xxp2;
 	struct cvmx_sli_pktx_out_size_s       cnf71xx;
 };
 typedef union cvmx_sli_pktx_out_size cvmx_sli_pktx_out_size_t;
@@ -7326,7 +7461,9 @@ union cvmx_sli_pktx_output_control {
 #endif
 	} s;
 	struct cvmx_sli_pktx_output_control_s cn73xx;
+	struct cvmx_sli_pktx_output_control_s cn75xx;
 	struct cvmx_sli_pktx_output_control_s cn78xx;
+	struct cvmx_sli_pktx_output_control_s cn78xxp2;
 };
 typedef union cvmx_sli_pktx_output_control cvmx_sli_pktx_output_control_t;
 
@@ -7334,13 +7471,13 @@ typedef union cvmx_sli_pktx_output_control cvmx_sli_pktx_output_control_t;
  * cvmx_sli_pkt#_pf_vf_mbox_sig#
  *
  * This register is used for communication of data from the VF to the PF
- * A PF will write to SLI_PKT()_PF_VF_MBOX_SIG().
- * Each VF may access the same storage using SLIVF_PKT()_VF_PF_MBOX_SIG().
- * Writes from the PF to SLI_PKT(0..127)_PF_VF_MBOX_SIG(0) will cause an
+ * A PF will write to the SLI_PKT(0..127)_PF_VF_MBOX_SIG(0..1) registers.
+ * Each VF may access the same storage using the SLIVF_PKT(0..7)_VF_PF_MBOX_SIG(0..1) registers.
+ * Writes from the PF to the SLI_PKT(0..127)_PF_VF_MBOX_SIG0 register will cause an
  * interrupt to be set in the corresponding SLIVF_PKT(0..7)_MBOX_INT[MBOX_INT],
- * SLIVF_PKT_IN_DONE()_CNTS[MBOX_INT], SLIVF_PKT()_CNTS[MBOX_INT] fields and
- * corresponding bit in SLIVF_PKT_MBOX_INT.  Each PF can only access the
- * rings that its owns as programmed by SLI_PKT_MAC()_RINFO.
+ * SLIVF_PKT_IN_DONE(0..7)_CNTS[MBOX_INT], SLIVF_PKT(0..7)_CNTS[MBOX_INT] fields and
+ * corresponding bit in SLIVF_PKT_MBOX_INT register.  Each PF can only access the
+ * rings that its owns as programmed by the SLI_PKT_MAC(0..3)_RINFO info registers.
  */
 union cvmx_sli_pktx_pf_vf_mbox_sigx {
 	uint64_t u64;
@@ -7353,6 +7490,7 @@ union cvmx_sli_pktx_pf_vf_mbox_sigx {
 #endif
 	} s;
 	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cn73xx;
+	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cn75xx;
 };
 typedef union cvmx_sli_pktx_pf_vf_mbox_sigx cvmx_sli_pktx_pf_vf_mbox_sigx_t;
 
@@ -7382,7 +7520,9 @@ union cvmx_sli_pktx_slist_baddr {
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xxp1;
 	struct cvmx_sli_pktx_slist_baddr_s    cn73xx;
+	struct cvmx_sli_pktx_slist_baddr_s    cn75xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn78xx;
+	struct cvmx_sli_pktx_slist_baddr_s    cn78xxp2;
 	struct cvmx_sli_pktx_slist_baddr_s    cnf71xx;
 };
 typedef union cvmx_sli_pktx_slist_baddr cvmx_sli_pktx_slist_baddr_t;
@@ -7421,7 +7561,9 @@ union cvmx_sli_pktx_slist_baoff_dbell {
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xxp1;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn73xx;
+	struct cvmx_sli_pktx_slist_baoff_dbell_s cn75xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn78xx;
+	struct cvmx_sli_pktx_slist_baoff_dbell_s cn78xxp2;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cnf71xx;
 };
 typedef union cvmx_sli_pktx_slist_baoff_dbell cvmx_sli_pktx_slist_baoff_dbell_t;
@@ -7462,7 +7604,9 @@ union cvmx_sli_pktx_slist_fifo_rsize {
 	} cn70xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn70xxp1;
 	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn73xx;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn75xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn78xx;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn78xxp2;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cnf71xx;
 };
 typedef union cvmx_sli_pktx_slist_fifo_rsize cvmx_sli_pktx_slist_fifo_rsize_t;
@@ -7483,10 +7627,56 @@ union cvmx_sli_pktx_vf_sig {
 #endif
 	} s;
 	struct cvmx_sli_pktx_vf_sig_s         cn78xx;
+	struct cvmx_sli_pktx_vf_sig_s         cn78xxp2;
 };
 typedef union cvmx_sli_pktx_vf_sig cvmx_sli_pktx_vf_sig_t;
 
 /**
+ * cvmx_sli_pkt_bist_status
+ *
+ * This is the built-in self-test (BIST) status register. Each bit is the BIST result of an
+ * individual memory (per bit, 0 = pass and 1 = fail).
+ */
+union cvmx_sli_pkt_bist_status {
+	uint64_t u64;
+	struct cvmx_sli_pkt_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t bist                         : 22; /**< BIST results. Hardware sets a bit in BIST for memory that fails.
+                                                         INTERNAL:
+                                                           poi_fifo_status,
+                                                           psf_fifo_status,
+                                                           pdf_fifo_status,
+                                                           pbn_fifo_status,
+                                                           pfp_fifo_status,
+                                                           pcsr_pout_size_bstatus,
+                                                           gii_imem_bstatus,
+                                                           pcsr_in_done_bstatus,
+                                                           pcsr_instr_mem_bstatus,
+                                                           pcsr_slist_bstatus,
+                                                           pfm_mem_bstatus,
+                                                           pif_fifo_bstatus,
+                                                           msix_mailbox_bstatus,
+                                                           msix_vfdata_bstatus | msix_vfaddr_bstatus,
+                                                           pop_mem0_bstatus,
+                                                           pop_mem1_bstatus,
+                                                           pout_int_bstatus,
+                                                           prd_gdata_fifo_bstatus,
+                                                           prd_glist_rd_fifo_bstatus,
+                                                           prd_pblk_rd_fifo_bstatus,
+                                                           prd_pkt_rd_fifo_bstatus,
+                                                           pwc_ififo_bstatus */
+#else
+	uint64_t bist                         : 22;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} s;
+	struct cvmx_sli_pkt_bist_status_s     cn73xx;
+	struct cvmx_sli_pkt_bist_status_s     cn75xx;
+};
+typedef union cvmx_sli_pkt_bist_status cvmx_sli_pkt_bist_status_t;
+
+/**
  * cvmx_sli_pkt_cnt_int
  *
  * This register specifies which output packet rings are interrupting because of packet counters.
@@ -7538,7 +7728,9 @@ union cvmx_sli_pkt_cnt_int {
 	uint64_t ring                         : 64;
 #endif
 	} cn73xx;
+	struct cvmx_sli_pkt_cnt_int_cn73xx    cn75xx;
 	struct cvmx_sli_pkt_cnt_int_cn73xx    cn78xx;
+	struct cvmx_sli_pkt_cnt_int_cn73xx    cn78xxp2;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_cnt_int cvmx_sli_pkt_cnt_int_t;
@@ -7885,7 +8077,9 @@ union cvmx_sli_pkt_in_donex_cnts {
 	uint64_t po_int                       : 1;
 #endif
 	} cn73xx;
+	struct cvmx_sli_pkt_in_donex_cnts_cn73xx cn75xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn73xx cn78xx;
+	struct cvmx_sli_pkt_in_donex_cnts_cn73xx cn78xxp2;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cnf71xx;
 };
 typedef union cvmx_sli_pkt_in_donex_cnts cvmx_sli_pkt_in_donex_cnts_t;
@@ -7918,7 +8112,9 @@ union cvmx_sli_pkt_in_instr_counts {
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xxp1;
 	struct cvmx_sli_pkt_in_instr_counts_s cn73xx;
+	struct cvmx_sli_pkt_in_instr_counts_s cn75xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn78xx;
+	struct cvmx_sli_pkt_in_instr_counts_s cn78xxp2;
 	struct cvmx_sli_pkt_in_instr_counts_s cnf71xx;
 };
 typedef union cvmx_sli_pkt_in_instr_counts cvmx_sli_pkt_in_instr_counts_t;
@@ -7944,7 +8140,9 @@ union cvmx_sli_pkt_in_int {
 #endif
 	} s;
 	struct cvmx_sli_pkt_in_int_s          cn73xx;
+	struct cvmx_sli_pkt_in_int_s          cn75xx;
 	struct cvmx_sli_pkt_in_int_s          cn78xx;
+	struct cvmx_sli_pkt_in_int_s          cn78xxp2;
 };
 typedef union cvmx_sli_pkt_in_int cvmx_sli_pkt_in_int_t;
 
@@ -8204,7 +8402,9 @@ union cvmx_sli_pkt_instr_enb {
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xxp1;
 	struct cvmx_sli_pkt_instr_enb_s       cn73xx;
+	struct cvmx_sli_pkt_instr_enb_s       cn75xx;
 	struct cvmx_sli_pkt_instr_enb_s       cn78xx;
+	struct cvmx_sli_pkt_instr_enb_s       cn78xxp2;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_pkt_instr_enb cvmx_sli_pkt_instr_enb_t;
@@ -8225,6 +8425,7 @@ union cvmx_sli_pkt_instr_enb2 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_instr_enb2_s      cn73xx;
+	struct cvmx_sli_pkt_instr_enb2_s      cn75xx;
 };
 typedef union cvmx_sli_pkt_instr_enb2 cvmx_sli_pkt_instr_enb2_t;
 
@@ -8322,7 +8523,9 @@ union cvmx_sli_pkt_int {
 #endif
 	} s;
 	struct cvmx_sli_pkt_int_s             cn73xx;
+	struct cvmx_sli_pkt_int_s             cn75xx;
 	struct cvmx_sli_pkt_int_s             cn78xx;
+	struct cvmx_sli_pkt_int_s             cn78xxp2;
 };
 typedef union cvmx_sli_pkt_int cvmx_sli_pkt_int_t;
 
@@ -8418,6 +8621,7 @@ union cvmx_sli_pkt_macx_pfx_rinfo {
 #endif
 	} s;
 	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cn73xx;
+	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cn75xx;
 };
 typedef union cvmx_sli_pkt_macx_pfx_rinfo cvmx_sli_pkt_macx_pfx_rinfo_t;
 
@@ -8447,6 +8651,7 @@ union cvmx_sli_pkt_macx_rinfo {
 #endif
 	} s;
 	struct cvmx_sli_pkt_macx_rinfo_s      cn78xx;
+	struct cvmx_sli_pkt_macx_rinfo_s      cn78xxp2;
 };
 typedef union cvmx_sli_pkt_macx_rinfo cvmx_sli_pkt_macx_rinfo_t;
 
@@ -8466,6 +8671,7 @@ union cvmx_sli_pkt_mac0_sig0 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac0_sig0_s       cn78xx;
+	struct cvmx_sli_pkt_mac0_sig0_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac0_sig0 cvmx_sli_pkt_mac0_sig0_t;
 
@@ -8485,6 +8691,7 @@ union cvmx_sli_pkt_mac0_sig1 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac0_sig1_s       cn78xx;
+	struct cvmx_sli_pkt_mac0_sig1_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac0_sig1 cvmx_sli_pkt_mac0_sig1_t;
 
@@ -8504,6 +8711,7 @@ union cvmx_sli_pkt_mac1_sig0 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac1_sig0_s       cn78xx;
+	struct cvmx_sli_pkt_mac1_sig0_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac1_sig0 cvmx_sli_pkt_mac1_sig0_t;
 
@@ -8523,6 +8731,7 @@ union cvmx_sli_pkt_mac1_sig1 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac1_sig1_s       cn78xx;
+	struct cvmx_sli_pkt_mac1_sig1_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac1_sig1 cvmx_sli_pkt_mac1_sig1_t;
 
@@ -8599,8 +8808,72 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
-	struct cvmx_sli_pkt_mem_ctl_s         cn73xx;
+	struct cvmx_sli_pkt_mem_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_44_63               : 20;
+	uint64_t msid_fs                      : 2;  /**< Used to flip the synd. for pcsr_ncsr_msix_data_flip_synd. */
+	uint64_t msia_fs                      : 2;  /**< Used to flip the synd. for pcsr_ncsr_msix_addr_flip_synd. */
+	uint64_t msi_ecc                      : 1;  /**< When set pcsr_ncsr_msix_ecc_enawill have an ECC not generated and checked. */
+	uint64_t reserved_36_38               : 3;
+	uint64_t pos_fs                       : 2;  /**< Used to flip the synd. for pcsr_pout_size_csr_flip_synd. */
+	uint64_t pos_ecc                      : 1;  /**< When set will have an ECC not generated and checked. */
+	uint64_t pinm_fs                      : 2;  /**< Used to flip the synd. for pcsr_instr_mem_csr_flip_synd. */
+	uint64_t pinm_ecc                     : 1;  /**< When set pcsr_instr_mem_csr_cor_dis will have an ECC not generated and checked. */
+	uint64_t pind_fs                      : 2;  /**< Used to flip the synd. for pcsr_in_done_csr_flip_synd. */
+	uint64_t pind_ecc                     : 1;  /**< When set pcsr_in_done_csr_cor_dis will have an ECC not generated and checked. */
+	uint64_t point_fs                     : 2;  /**< Used to flip the synd. for pout_int_csr_flip_synd. */
+	uint64_t point_ecc                    : 1;  /**< When set pout_int_csr_cor_dis will have an ECC not generated and checked. */
+	uint64_t slist_fs                     : 2;  /**< Used to flip the synd. for pcsr_slist_csr_flip_synd. */
+	uint64_t slist_ecc                    : 1;  /**< When set pcsr_slist_csr_cor_dis will have an ECC not generated and checked. */
+	uint64_t pop1_fs                      : 2;  /**< Used to flip the synd for packet-out-pointer memory1. */
+	uint64_t pop1_ecc                     : 1;  /**< When set Packet Out Pointer memory1 will have an ECC not generated and checked. */
+	uint64_t pop0_fs                      : 2;  /**< Used to flip the synd for packet-out-pointer memory0. */
+	uint64_t pop0_ecc                     : 1;  /**< When set packet-out-pointer memory0 will have an ECC not generated and checked. */
+	uint64_t pfp_fs                       : 2;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
+	uint64_t pfp_ecc                      : 1;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
+	uint64_t pbn_fs                       : 2;  /**< Used to flip the synd for pointer-base-number memory. */
+	uint64_t pbn_ecc                      : 1;  /**< When set pointer-base-number memory will have an ECC not generated and checked. */
+	uint64_t pdf_fs                       : 2;  /**< Used to flip the synd for packet-data-info memory. */
+	uint64_t pdf_ecc                      : 1;  /**< When set packet data memory will have an ECC not generated and checked. */
+	uint64_t psf_fs                       : 2;  /**< Used to flip the synd for PSF memory. */
+	uint64_t psf_ecc                      : 1;  /**< When set PSF memory will have an ECC not generated and checked. */
+	uint64_t poi_fs                       : 2;  /**< Used to flip the synd for packet-out-info memory. */
+	uint64_t poi_ecc                      : 1;  /**< When set packet-out-info memory will have an ECC not generated and checked. */
+#else
+	uint64_t poi_ecc                      : 1;
+	uint64_t poi_fs                       : 2;
+	uint64_t psf_ecc                      : 1;
+	uint64_t psf_fs                       : 2;
+	uint64_t pdf_ecc                      : 1;
+	uint64_t pdf_fs                       : 2;
+	uint64_t pbn_ecc                      : 1;
+	uint64_t pbn_fs                       : 2;
+	uint64_t pfp_ecc                      : 1;
+	uint64_t pfp_fs                       : 2;
+	uint64_t pop0_ecc                     : 1;
+	uint64_t pop0_fs                      : 2;
+	uint64_t pop1_ecc                     : 1;
+	uint64_t pop1_fs                      : 2;
+	uint64_t slist_ecc                    : 1;
+	uint64_t slist_fs                     : 2;
+	uint64_t point_ecc                    : 1;
+	uint64_t point_fs                     : 2;
+	uint64_t pind_ecc                     : 1;
+	uint64_t pind_fs                      : 2;
+	uint64_t pinm_ecc                     : 1;
+	uint64_t pinm_fs                      : 2;
+	uint64_t pos_ecc                      : 1;
+	uint64_t pos_fs                       : 2;
+	uint64_t reserved_36_38               : 3;
+	uint64_t msi_ecc                      : 1;
+	uint64_t msia_fs                      : 2;
+	uint64_t msid_fs                      : 2;
+	uint64_t reserved_44_63               : 20;
+#endif
+	} cn73xx;
+	struct cvmx_sli_pkt_mem_ctl_cn73xx    cn75xx;
 	struct cvmx_sli_pkt_mem_ctl_s         cn78xx;
+	struct cvmx_sli_pkt_mem_ctl_s         cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mem_ctl cvmx_sli_pkt_mem_ctl_t;
 
@@ -8667,7 +8940,9 @@ union cvmx_sli_pkt_out_bp_en {
 	} cn68xx;
 	struct cvmx_sli_pkt_out_bp_en_cn68xx  cn68xxp1;
 	struct cvmx_sli_pkt_out_bp_en_s       cn73xx;
+	struct cvmx_sli_pkt_out_bp_en_s       cn75xx;
 	struct cvmx_sli_pkt_out_bp_en_s       cn78xx;
+	struct cvmx_sli_pkt_out_bp_en_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_out_bp_en cvmx_sli_pkt_out_bp_en_t;
 
@@ -8688,6 +8963,7 @@ union cvmx_sli_pkt_out_bp_en2 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_bp_en2_s      cn73xx;
+	struct cvmx_sli_pkt_out_bp_en2_s      cn75xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en2 cvmx_sli_pkt_out_bp_en2_t;
 
@@ -8729,7 +9005,9 @@ union cvmx_sli_pkt_out_enb {
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xxp1;
 	struct cvmx_sli_pkt_out_enb_s         cn73xx;
+	struct cvmx_sli_pkt_out_enb_s         cn75xx;
 	struct cvmx_sli_pkt_out_enb_s         cn78xx;
+	struct cvmx_sli_pkt_out_enb_s         cn78xxp2;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_out_enb cvmx_sli_pkt_out_enb_t;
@@ -8750,6 +9028,7 @@ union cvmx_sli_pkt_out_enb2 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_enb2_s        cn73xx;
+	struct cvmx_sli_pkt_out_enb2_s        cn75xx;
 };
 typedef union cvmx_sli_pkt_out_enb2 cvmx_sli_pkt_out_enb2_t;
 
@@ -8781,7 +9060,9 @@ union cvmx_sli_pkt_output_wmark {
 	struct cvmx_sli_pkt_output_wmark_s    cn70xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn70xxp1;
 	struct cvmx_sli_pkt_output_wmark_s    cn73xx;
+	struct cvmx_sli_pkt_output_wmark_s    cn75xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn78xx;
+	struct cvmx_sli_pkt_output_wmark_s    cn78xxp2;
 	struct cvmx_sli_pkt_output_wmark_s    cnf71xx;
 };
 typedef union cvmx_sli_pkt_output_wmark cvmx_sli_pkt_output_wmark_t;
@@ -8864,7 +9145,9 @@ union cvmx_sli_pkt_ring_rst {
 #endif
 	} s;
 	struct cvmx_sli_pkt_ring_rst_s        cn73xx;
+	struct cvmx_sli_pkt_ring_rst_s        cn75xx;
 	struct cvmx_sli_pkt_ring_rst_s        cn78xx;
+	struct cvmx_sli_pkt_ring_rst_s        cn78xxp2;
 };
 typedef union cvmx_sli_pkt_ring_rst cvmx_sli_pkt_ring_rst_t;
 
@@ -9026,7 +9309,9 @@ union cvmx_sli_pkt_time_int {
 	uint64_t ring                         : 64;
 #endif
 	} cn73xx;
+	struct cvmx_sli_pkt_time_int_cn73xx   cn75xx;
 	struct cvmx_sli_pkt_time_int_cn73xx   cn78xx;
+	struct cvmx_sli_pkt_time_int_cn73xx   cn78xxp2;
 	struct cvmx_sli_pkt_time_int_cn61xx   cnf71xx;
 };
 typedef union cvmx_sli_pkt_time_int cvmx_sli_pkt_time_int_t;
@@ -9065,25 +9350,6 @@ union cvmx_sli_pkt_time_int_enb {
 typedef union cvmx_sli_pkt_time_int_enb cvmx_sli_pkt_time_int_enb_t;
 
 /**
- * cvmx_sli_pkt_vf_sig_int
- *
- * attributes:
- * vf_reg_type: "bw"
- */
-union cvmx_sli_pkt_vf_sig_int {
-	uint64_t u64;
-	struct cvmx_sli_pkt_vf_sig_int_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< When a PF or VF writes to a SLI_PKT(0..127)_VF_SIG2 register */
-#else
-	uint64_t ring                         : 64;
-#endif
-	} s;
-	struct cvmx_sli_pkt_vf_sig_int_s      cn73xx;
-};
-typedef union cvmx_sli_pkt_vf_sig_int cvmx_sli_pkt_vf_sig_int_t;
-
-/**
  * cvmx_sli_port#_pkind
  *
  * SLI_PORT[0..31]_PKIND = SLI Port Pkind
@@ -9160,7 +9426,9 @@ union cvmx_sli_s2c_end_merge {
 #endif
 	} s;
 	struct cvmx_sli_s2c_end_merge_s       cn73xx;
+	struct cvmx_sli_s2c_end_merge_s       cn75xx;
 	struct cvmx_sli_s2c_end_merge_s       cn78xx;
+	struct cvmx_sli_s2c_end_merge_s       cn78xxp2;
 };
 typedef union cvmx_sli_s2c_end_merge cvmx_sli_s2c_end_merge_t;
 
@@ -9273,7 +9541,9 @@ union cvmx_sli_s2m_portx_ctl {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} cn73xx;
+	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn75xx;
 	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn78xx;
+	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn78xxp2;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_s2m_portx_ctl cvmx_sli_s2m_portx_ctl_t;
@@ -9302,7 +9572,9 @@ union cvmx_sli_scratch_1 {
 	struct cvmx_sli_scratch_1_s           cn70xx;
 	struct cvmx_sli_scratch_1_s           cn70xxp1;
 	struct cvmx_sli_scratch_1_s           cn73xx;
+	struct cvmx_sli_scratch_1_s           cn75xx;
 	struct cvmx_sli_scratch_1_s           cn78xx;
+	struct cvmx_sli_scratch_1_s           cn78xxp2;
 	struct cvmx_sli_scratch_1_s           cnf71xx;
 };
 typedef union cvmx_sli_scratch_1 cvmx_sli_scratch_1_t;
@@ -9331,7 +9603,9 @@ union cvmx_sli_scratch_2 {
 	struct cvmx_sli_scratch_2_s           cn70xx;
 	struct cvmx_sli_scratch_2_s           cn70xxp1;
 	struct cvmx_sli_scratch_2_s           cn73xx;
+	struct cvmx_sli_scratch_2_s           cn75xx;
 	struct cvmx_sli_scratch_2_s           cn78xx;
+	struct cvmx_sli_scratch_2_s           cn78xxp2;
 	struct cvmx_sli_scratch_2_s           cnf71xx;
 };
 typedef union cvmx_sli_scratch_2 cvmx_sli_scratch_2_t;
@@ -9366,7 +9640,9 @@ union cvmx_sli_state1 {
 	struct cvmx_sli_state1_s              cn70xx;
 	struct cvmx_sli_state1_s              cn70xxp1;
 	struct cvmx_sli_state1_s              cn73xx;
+	struct cvmx_sli_state1_s              cn75xx;
 	struct cvmx_sli_state1_s              cn78xx;
+	struct cvmx_sli_state1_s              cn78xxp2;
 	struct cvmx_sli_state1_s              cnf71xx;
 };
 typedef union cvmx_sli_state1 cvmx_sli_state1_t;
@@ -9435,7 +9711,9 @@ union cvmx_sli_state2 {
 	uint64_t reserved_57_63               : 7;
 #endif
 	} cn73xx;
+	struct cvmx_sli_state2_cn73xx         cn75xx;
 	struct cvmx_sli_state2_cn73xx         cn78xx;
+	struct cvmx_sli_state2_cn73xx         cn78xxp2;
 	struct cvmx_sli_state2_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state2 cvmx_sli_state2_t;
@@ -9492,7 +9770,9 @@ union cvmx_sli_state3 {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn73xx;
+	struct cvmx_sli_state3_cn73xx         cn75xx;
 	struct cvmx_sli_state3_cn73xx         cn78xx;
+	struct cvmx_sli_state3_cn73xx         cn78xxp2;
 	struct cvmx_sli_state3_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state3 cvmx_sli_state3_t;
@@ -9588,7 +9868,9 @@ union cvmx_sli_win_rd_addr {
 	struct cvmx_sli_win_rd_addr_s         cn70xx;
 	struct cvmx_sli_win_rd_addr_s         cn70xxp1;
 	struct cvmx_sli_win_rd_addr_s         cn73xx;
+	struct cvmx_sli_win_rd_addr_s         cn75xx;
 	struct cvmx_sli_win_rd_addr_s         cn78xx;
+	struct cvmx_sli_win_rd_addr_s         cn78xxp2;
 	struct cvmx_sli_win_rd_addr_s         cnf71xx;
 };
 typedef union cvmx_sli_win_rd_addr cvmx_sli_win_rd_addr_t;
@@ -9617,7 +9899,9 @@ union cvmx_sli_win_rd_data {
 	struct cvmx_sli_win_rd_data_s         cn70xx;
 	struct cvmx_sli_win_rd_data_s         cn70xxp1;
 	struct cvmx_sli_win_rd_data_s         cn73xx;
+	struct cvmx_sli_win_rd_data_s         cn75xx;
 	struct cvmx_sli_win_rd_data_s         cn78xx;
+	struct cvmx_sli_win_rd_data_s         cn78xxp2;
 	struct cvmx_sli_win_rd_data_s         cnf71xx;
 };
 typedef union cvmx_sli_win_rd_data cvmx_sli_win_rd_data_t;
@@ -9673,7 +9957,9 @@ union cvmx_sli_win_wr_addr {
 	struct cvmx_sli_win_wr_addr_s         cn70xx;
 	struct cvmx_sli_win_wr_addr_s         cn70xxp1;
 	struct cvmx_sli_win_wr_addr_s         cn73xx;
+	struct cvmx_sli_win_wr_addr_s         cn75xx;
 	struct cvmx_sli_win_wr_addr_s         cn78xx;
+	struct cvmx_sli_win_wr_addr_s         cn78xxp2;
 	struct cvmx_sli_win_wr_addr_s         cnf71xx;
 };
 typedef union cvmx_sli_win_wr_addr cvmx_sli_win_wr_addr_t;
@@ -9705,7 +9991,9 @@ union cvmx_sli_win_wr_data {
 	struct cvmx_sli_win_wr_data_s         cn70xx;
 	struct cvmx_sli_win_wr_data_s         cn70xxp1;
 	struct cvmx_sli_win_wr_data_s         cn73xx;
+	struct cvmx_sli_win_wr_data_s         cn75xx;
 	struct cvmx_sli_win_wr_data_s         cn78xx;
+	struct cvmx_sli_win_wr_data_s         cn78xxp2;
 	struct cvmx_sli_win_wr_data_s         cnf71xx;
 };
 typedef union cvmx_sli_win_wr_data cvmx_sli_win_wr_data_t;
@@ -9740,7 +10028,9 @@ union cvmx_sli_win_wr_mask {
 	struct cvmx_sli_win_wr_mask_s         cn70xx;
 	struct cvmx_sli_win_wr_mask_s         cn70xxp1;
 	struct cvmx_sli_win_wr_mask_s         cn73xx;
+	struct cvmx_sli_win_wr_mask_s         cn75xx;
 	struct cvmx_sli_win_wr_mask_s         cn78xx;
+	struct cvmx_sli_win_wr_mask_s         cn78xxp2;
 	struct cvmx_sli_win_wr_mask_s         cnf71xx;
 };
 typedef union cvmx_sli_win_wr_mask cvmx_sli_win_wr_mask_t;
@@ -9789,7 +10079,9 @@ union cvmx_sli_window_ctl {
 	struct cvmx_sli_window_ctl_cn61xx     cn70xx;
 	struct cvmx_sli_window_ctl_cn61xx     cn70xxp1;
 	struct cvmx_sli_window_ctl_s          cn73xx;
+	struct cvmx_sli_window_ctl_s          cn75xx;
 	struct cvmx_sli_window_ctl_s          cn78xx;
+	struct cvmx_sli_window_ctl_s          cn78xxp2;
 	struct cvmx_sli_window_ctl_cn61xx     cnf71xx;
 };
 typedef union cvmx_sli_window_ctl cvmx_sli_window_ctl_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index dfcb582..fa942e2 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -80,6 +80,7 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 1) * 128;
 			break;
@@ -109,6 +110,7 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001818ull) + (offset) * 256;
@@ -142,6 +144,7 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 1) * 128;
 			break;
@@ -171,6 +174,7 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001800ull) + (offset) * 256;
@@ -204,6 +208,7 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 1) * 128;
 			break;
@@ -233,6 +238,7 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001820ull) + (offset) * 256;
@@ -266,6 +272,7 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 1) * 128;
 			break;
@@ -295,6 +302,7 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001810ull) + (offset) * 256;
@@ -328,6 +336,7 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 1) * 128;
 			break;
@@ -357,6 +366,7 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001808ull) + (offset) * 256;
@@ -471,7 +481,9 @@ union cvmx_smix_clk {
 	struct cvmx_smix_clk_s                cn70xx;
 	struct cvmx_smix_clk_s                cn70xxp1;
 	struct cvmx_smix_clk_s                cn73xx;
+	struct cvmx_smix_clk_s                cn75xx;
 	struct cvmx_smix_clk_s                cn78xx;
+	struct cvmx_smix_clk_s                cn78xxp2;
 	struct cvmx_smix_clk_s                cnf71xx;
 };
 typedef union cvmx_smix_clk cvmx_smix_clk_t;
@@ -548,7 +560,9 @@ union cvmx_smix_cmd {
 	struct cvmx_smix_cmd_s                cn70xx;
 	struct cvmx_smix_cmd_s                cn70xxp1;
 	struct cvmx_smix_cmd_s                cn73xx;
+	struct cvmx_smix_cmd_s                cn75xx;
 	struct cvmx_smix_cmd_s                cn78xx;
+	struct cvmx_smix_cmd_s                cn78xxp2;
 	struct cvmx_smix_cmd_s                cnf71xx;
 };
 typedef union cvmx_smix_cmd cvmx_smix_cmd_t;
@@ -592,7 +606,9 @@ union cvmx_smix_en {
 	struct cvmx_smix_en_s                 cn70xx;
 	struct cvmx_smix_en_s                 cn70xxp1;
 	struct cvmx_smix_en_s                 cn73xx;
+	struct cvmx_smix_en_s                 cn75xx;
 	struct cvmx_smix_en_s                 cn78xx;
+	struct cvmx_smix_en_s                 cn78xxp2;
 	struct cvmx_smix_en_s                 cnf71xx;
 };
 typedef union cvmx_smix_en cvmx_smix_en_t;
@@ -638,7 +654,9 @@ union cvmx_smix_rd_dat {
 	struct cvmx_smix_rd_dat_s             cn70xx;
 	struct cvmx_smix_rd_dat_s             cn70xxp1;
 	struct cvmx_smix_rd_dat_s             cn73xx;
+	struct cvmx_smix_rd_dat_s             cn75xx;
 	struct cvmx_smix_rd_dat_s             cn78xx;
+	struct cvmx_smix_rd_dat_s             cn78xxp2;
 	struct cvmx_smix_rd_dat_s             cnf71xx;
 };
 typedef union cvmx_smix_rd_dat cvmx_smix_rd_dat_t;
@@ -684,7 +702,9 @@ union cvmx_smix_wr_dat {
 	struct cvmx_smix_wr_dat_s             cn70xx;
 	struct cvmx_smix_wr_dat_s             cn70xxp1;
 	struct cvmx_smix_wr_dat_s             cn73xx;
+	struct cvmx_smix_wr_dat_s             cn75xx;
 	struct cvmx_smix_wr_dat_s             cn78xx;
+	struct cvmx_smix_wr_dat_s             cn78xxp2;
 	struct cvmx_smix_wr_dat_s             cnf71xx;
 };
 typedef union cvmx_smix_wr_dat cvmx_smix_wr_dat_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index 3438a9a..0e5a7ba 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -55,826 +55,2294 @@
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_ID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_ID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000008ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000008ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_ID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ASMBLY_ID(offset) (0x0000000000000008ull)
+static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_ID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000008ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000008ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000008ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_INFO(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_INFO(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000000Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000000Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000000Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000000Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_INFO (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000000Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ASMBLY_INFO(offset) (0x000000000000000Cull)
+static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_INFO(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000000Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000000Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000000Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000000Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_BAR1_IDXX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 15)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_BAR1_IDXX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return 0x0000000000200010ull + (((offset) & 15) + ((block_id) & 3) * 0x0ull) * 4;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))
+				return 0x0000000000200010ull + (((offset) & 15) + ((block_id) & 3) * 0x0ull) * 4;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return 0x0000000000200010ull + (((offset) & 15) + ((block_id) & 1) * 0x40000000ull) * 4;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return 0x0000010000200010ull + (((offset) & 15) + ((block_id) & 1) * 0x40000000ull) * 4;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_BAR1_IDXX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return 0x0000010000200010ull + (((offset) & 15) + ((block_id) & 1) * 0x40000000ull) * 4;
 }
 #else
-#define CVMX_SRIOMAINTX_BAR1_IDXX(offset, block_id) (0x0000000000200010ull + (((offset) & 15) + ((block_id) & 3) * 0x0ull) * 4)
+static inline uint64_t CVMX_SRIOMAINTX_BAR1_IDXX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200010ull + ((offset) + (block_id) * 0x0ull) * 4;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200010ull + ((offset) + (block_id) * 0x40000000ull) * 4;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200010ull + ((offset) + (block_id) * 0x40000000ull) * 4;
+	}
+	return 0x0000010000200010ull + ((offset) + (block_id) * 0x40000000ull) * 4;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_BELL_STATUS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_BELL_STATUS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200080ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200080ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200080ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200080ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_BELL_STATUS (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200080ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_BELL_STATUS(offset) (0x0000000000200080ull)
+static inline uint64_t CVMX_SRIOMAINTX_BELL_STATUS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200080ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200080ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200080ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200080ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_COMP_TAG(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_COMP_TAG(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000006Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000006Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000006Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000006Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_COMP_TAG (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000006Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_COMP_TAG(offset) (0x000000000000006Cull)
+static inline uint64_t CVMX_SRIOMAINTX_COMP_TAG(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000006Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000006Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000006Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000006Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_CORE_ENABLES(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_CORE_ENABLES(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200070ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200070ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200070ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200070ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_CORE_ENABLES (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200070ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_CORE_ENABLES(offset) (0x0000000000200070ull)
+static inline uint64_t CVMX_SRIOMAINTX_CORE_ENABLES(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200070ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200070ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200070ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200070ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_DEV_ID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DEV_ID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_DEV_ID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_DEV_ID(offset) (0x0000000000000000ull)
+static inline uint64_t CVMX_SRIOMAINTX_DEV_ID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_DEV_REV(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DEV_REV(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000004ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000004ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_DEV_REV (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_DEV_REV(offset) (0x0000000000000004ull)
+static inline uint64_t CVMX_SRIOMAINTX_DEV_REV(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000004ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000004ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000004ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_DST_OPS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DST_OPS(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000001Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000001Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000001Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000001Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_DST_OPS (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000001Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_DST_OPS(offset) (0x000000000000001Cull)
+static inline uint64_t CVMX_SRIOMAINTX_DST_OPS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000001Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000001Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000001Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000001Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_ATTR_CAPT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ATTR_CAPT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002048ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002048ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002048ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002048ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_ATTR_CAPT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002048ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ATTR_CAPT(offset) (0x0000000000002048ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ATTR_CAPT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002048ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002048ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002048ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002048ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_DET(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_DET(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002040ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002040ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002040ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002040ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_DET (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002040ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_DET(offset) (0x0000000000002040ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_DET(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002040ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002040ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002040ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002040ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002068ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002068ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002068ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE(offset) (0x0000000000002068ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002068ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002068ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002068ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002068ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002044ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002044ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002044ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002044ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_EN (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002044ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(offset) (0x0000000000002044ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002044ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002044ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002044ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002044ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000206Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000206Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000206Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000206Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_THR (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000206Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(offset) (0x000000000000206Cull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000206Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000206Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000206Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000206Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_HDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_HDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_HDR (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_HDR(offset) (0x0000000000002000ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_HDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002010ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002010ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(offset) (0x0000000000002010ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002010ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002010ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002010ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002014ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002014ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002014ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002014ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002014ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(offset) (0x0000000000002014ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002014ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002014ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002014ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002014ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000201Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000201Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000201Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000201Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000201Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(offset) (0x000000000000201Cull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000201Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000201Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000201Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000201Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002028ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002028ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002028ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002028ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002028ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID(offset) (0x0000000000002028ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002028ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002028ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002028ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002028ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002018ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002018ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002018ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002018ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002018ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(offset) (0x0000000000002018ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002018ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002018ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002018ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002018ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_DET(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_DET(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002008ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002008ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_DET (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ERR_DET(offset) (0x0000000000002008ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_DET(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002008ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002008ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002008ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_EN(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_EN(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000200Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000200Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000200Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000200Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_EN (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000200Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ERR_EN(offset) (0x000000000000200Cull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_EN(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000200Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000200Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000200Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000200Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002050ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002050ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002050ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002050ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_1 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002050ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(offset) (0x0000000000002050ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002050ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002050ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002050ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002050ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002054ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002054ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002054ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002054ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_2 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002054ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(offset) (0x0000000000002054ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002054ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002054ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002054ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002054ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002058ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000002058ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000002058ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000002058ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_3 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000002058ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(offset) (0x0000000000002058ull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002058ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000002058ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000002058ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000002058ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000204Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000204Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000204Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000204Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000204Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(offset) (0x000000000000204Cull)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000204Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000204Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000204Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000204Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000068ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000068ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_HB_DEV_ID_LOCK (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000068ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(offset) (0x0000000000000068ull)
+static inline uint64_t CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000068ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000068ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000068ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000068ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000102000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000102000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000102000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000102000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000102000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(offset) (0x0000000000102000ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000102000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000102000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000102000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000102000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000102004ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000102004ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000102004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000102004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000102004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(offset) (0x0000000000102004ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000102004ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000102004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000102004ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000102004ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107028ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107028ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107028ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107028ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107028ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(offset) (0x0000000000107028ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107028ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107028ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107028ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107028ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_STAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_STAT(%lu) is invalid on this chip\n", offset);
-	return 0x000000000010702Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000010702Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000010702Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000010702Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_STAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000010702Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PD_PHY_STAT(offset) (0x000000000010702Cull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_STAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000010702Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000010702Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000010702Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000010702Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107020ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107020ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107020ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107020ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107020ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(offset) (0x0000000000107020ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107020ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107020ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107020ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107020ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_STAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_STAT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107024ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107024ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107024ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107024ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_STAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107024ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PI_PHY_STAT(offset) (0x0000000000107024ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_STAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107024ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107024ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107024ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107024ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x000000000010700Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000010700Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000010700Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000010700Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000010700Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_CTRL(offset) (0x000000000010700Cull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000010700Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000010700Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000010700Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000010700Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_DATA(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_DATA(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107014ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107014ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107014ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107014ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_DATA (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107014ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_DATA(offset) (0x0000000000107014ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_DATA(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107014ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107014ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107014ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107014ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_STAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_STAT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107010ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107010ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_STAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_STAT(offset) (0x0000000000107010ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_STAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107010ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107010ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107010ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_CTRL(offset) (0x0000000000107000ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_DATA(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_DATA(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107008ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107008ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_DATA (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_DATA(offset) (0x0000000000107008ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_DATA(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107008ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107008ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107008ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_STAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_STAT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000107004ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000107004ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000107004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000107004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_STAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000107004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_STAT(offset) (0x0000000000107004ull)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_STAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107004ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000107004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000107004ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000107004ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_LANE_X_STATUS_0(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_LANE_X_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return 0x0000000000001010ull + (((offset) & 3) + ((block_id) & 3) * 0x0ull) * 32;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))
+				return 0x0000000000001010ull + (((offset) & 3) + ((block_id) & 3) * 0x0ull) * 32;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id <= 1)))
+				return 0x0000000000001010ull + (((offset) & 3) + ((block_id) & 1) * 0x8000000ull) * 32;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id <= 1)))
+				return 0x0000010000001010ull + (((offset) & 3) + ((block_id) & 1) * 0x8000000ull) * 32;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_LANE_X_STATUS_0 (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return 0x0000010000001010ull + (((offset) & 3) + ((block_id) & 1) * 0x8000000ull) * 32;
 }
 #else
-#define CVMX_SRIOMAINTX_LANE_X_STATUS_0(offset, block_id) (0x0000000000001010ull + (((offset) & 3) + ((block_id) & 3) * 0x0ull) * 32)
+static inline uint64_t CVMX_SRIOMAINTX_LANE_X_STATUS_0(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000001010ull + ((offset) + (block_id) * 0x0ull) * 32;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000001010ull + ((offset) + (block_id) * 0x8000000ull) * 32;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000001010ull + ((offset) + (block_id) * 0x8000000ull) * 32;
+	}
+	return 0x0000010000001010ull + ((offset) + (block_id) * 0x8000000ull) * 32;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_LCS_BA0(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA0(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000058ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000058ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000058ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000058ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_LCS_BA0 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000058ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_LCS_BA0(offset) (0x0000000000000058ull)
+static inline uint64_t CVMX_SRIOMAINTX_LCS_BA0(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000058ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000058ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000058ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000058ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_LCS_BA1(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA1(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000005Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000005Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000005Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000005Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_LCS_BA1 (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000005Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_LCS_BA1(offset) (0x000000000000005Cull)
+static inline uint64_t CVMX_SRIOMAINTX_LCS_BA1(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000005Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000005Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000005Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000005Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START0(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START0(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START0 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR0_START0(offset) (0x0000000000200000ull)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START0(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START1(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START1(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200004ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200004ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200004ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START1 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR0_START1(offset) (0x0000000000200004ull)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START1(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200004ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200004ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200004ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START0(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START0(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200008ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200008ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200008ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START0 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR1_START0(offset) (0x0000000000200008ull)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START0(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200008ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200008ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200008ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START1(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START1(%lu) is invalid on this chip\n", offset);
-	return 0x000000000020000Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000020000Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000020000Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000020000Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START1 (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000020000Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR1_START1(offset) (0x000000000020000Cull)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START1(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000020000Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000020000Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000020000Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000020000Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR2_START(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR2_START(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200050ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200050ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200050ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200050ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR2_START (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200050ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR2_START(offset) (0x0000000000200050ull)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR2_START(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200050ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200050ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200050ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200050ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_MAC_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_MAC_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200068ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200068ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200068ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_MAC_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200068ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_MAC_CTRL(offset) (0x0000000000200068ull)
+static inline uint64_t CVMX_SRIOMAINTX_MAC_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200068ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200068ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200068ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200068ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PE_FEAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PE_FEAT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000010ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000010ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000010ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PE_FEAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PE_FEAT(offset) (0x0000000000000010ull)
+static inline uint64_t CVMX_SRIOMAINTX_PE_FEAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000010ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000010ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000010ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PE_LLC(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PE_LLC(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000004Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000004Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000004Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000004Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PE_LLC (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000004Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PE_LLC(offset) (0x000000000000004Cull)
+static inline uint64_t CVMX_SRIOMAINTX_PE_LLC(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000004Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000004Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000004Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000004Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000015Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000015Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000015Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000015Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000015Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_CTL(offset) (0x000000000000015Cull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000015Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000015Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000015Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000015Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL2(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL2(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000154ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000154ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000154ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000154ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL2 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000154ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_CTL2(offset) (0x0000000000000154ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL2(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000154ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000154ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000154ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000154ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_ERR_STAT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_ERR_STAT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000158ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000158ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000158ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000158ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_ERR_STAT (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000158ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_ERR_STAT(offset) (0x0000000000000158ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_ERR_STAT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000158ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000158ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000158ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000158ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_REQ(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_REQ(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000140ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000140ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000140ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000140ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_REQ (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000140ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LINK_REQ(offset) (0x0000000000000140ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_REQ(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000140ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000140ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000140ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000140ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_RESP(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_RESP(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000144ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000144ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000144ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000144ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_RESP (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000144ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LINK_RESP(offset) (0x0000000000000144ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_RESP(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000144ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000144ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000144ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000144ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000148ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000148ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000148ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000148ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000148ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(offset) (0x0000000000000148ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000148ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000148ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000148ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000148ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_GEN_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_GEN_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000013Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000013Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000013Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000013Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_GEN_CTL (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000013Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_GEN_CTL(offset) (0x000000000000013Cull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_GEN_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000013Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000013Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000013Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000013Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_LT_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_LT_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000120ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000120ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000120ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000120ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_LT_CTL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000120ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_LT_CTL(offset) (0x0000000000000120ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_LT_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000120ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000120ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000120ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000120ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_MBH0(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_MBH0(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000100ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000100ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000100ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000100ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_MBH0 (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000100ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_MBH0(offset) (0x0000000000000100ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_MBH0(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000100ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000100ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000100ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000100ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_RT_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_RT_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000124ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000124ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000124ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000124ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_RT_CTL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000124ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_RT_CTL(offset) (0x0000000000000124ull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_RT_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000124ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000124ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000124ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000124ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PORT_TTL_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_TTL_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x000000000000012Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000000012Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000000012Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000000012Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PORT_TTL_CTL (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000000012Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_TTL_CTL(offset) (0x000000000000012Cull)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_TTL_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000012Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000000012Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000000012Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000000012Cull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_PRI_DEV_ID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PRI_DEV_ID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000060ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000060ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000060ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000060ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_PRI_DEV_ID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000060ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PRI_DEV_ID(offset) (0x0000000000000060ull)
+static inline uint64_t CVMX_SRIOMAINTX_PRI_DEV_ID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000060ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000060ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000060ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000060ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_CTRL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200064ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200064ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200064ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200064ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200064ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SEC_DEV_CTRL(offset) (0x0000000000200064ull)
+static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200064ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200064ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200064ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200064ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_ID(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_ID(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000200060ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000200060ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000200060ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000200060ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_ID (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000200060ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SEC_DEV_ID(offset) (0x0000000000200060ull)
+static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_ID(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200060ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000200060ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000200060ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000200060ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_SERIAL_LANE_HDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SERIAL_LANE_HDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000001000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000001000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000001000ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_SERIAL_LANE_HDR (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000001000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SERIAL_LANE_HDR(offset) (0x0000000000001000ull)
+static inline uint64_t CVMX_SRIOMAINTX_SERIAL_LANE_HDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000001000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000001000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000001000ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000001000ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_SRC_OPS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SRC_OPS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000018ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x0000000000000018ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000000000000018ull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000010000000018ull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_SRC_OPS (offset = %lu) not supported on this chip\n", offset);
+	return 0x0000010000000018ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SRC_OPS(offset) (0x0000000000000018ull)
+static inline uint64_t CVMX_SRIOMAINTX_SRC_OPS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000018ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000018ull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x0000010000000018ull + (offset) * 0x100000000ull;
+	}
+	return 0x0000010000000018ull + (offset) * 0x100000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_TX_DROP(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_TX_DROP(%lu) is invalid on this chip\n", offset);
-	return 0x000000000020006Cull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return 0x000000000020006Cull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000000000020006Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000001000020006Cull + ((offset) & 1) * 0x100000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOMAINTX_TX_DROP (offset = %lu) not supported on this chip\n", offset);
+	return 0x000001000020006Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_TX_DROP(offset) (0x000000000020006Cull)
+static inline uint64_t CVMX_SRIOMAINTX_TX_DROP(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return 0x000000000020006Cull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return 0x000000000020006Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return 0x000001000020006Cull + (offset) * 0x100000000ull;
+	}
+	return 0x000001000020006Cull + (offset) * 0x100000000ull;
+}
 #endif
 
 /**
  * cvmx_sriomaint#_asmbly_id
  *
- * SRIOMAINT_ASMBLY_ID = SRIO Assembly ID
- *
- * The Assembly ID register shows the Assembly ID and Vendor
+ * This register shows the assembly id and vendor specified in SRIO()_ASMBLY_ID.
  *
- * Notes:
- * The Assembly ID register shows the Assembly ID and Vendor specified in $SRIO_ASMBLY_ID.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ASMBLY_ID     hclk    hrst_n
  */
 union cvmx_sriomaintx_asmbly_id {
 	uint32_t u32;
 	struct cvmx_sriomaintx_asmbly_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t assy_id                      : 16; /**< Assembly Identifer */
-	uint32_t assy_ven                     : 16; /**< Assembly Vendor Identifer */
+	uint32_t assy_id                      : 16; /**< Assembly identifer. */
+	uint32_t assy_ven                     : 16; /**< Assembly vendor identifer. */
 #else
 	uint32_t assy_ven                     : 16;
 	uint32_t assy_id                      : 16;
@@ -883,29 +2351,22 @@ union cvmx_sriomaintx_asmbly_id {
 	struct cvmx_sriomaintx_asmbly_id_s    cn63xx;
 	struct cvmx_sriomaintx_asmbly_id_s    cn63xxp1;
 	struct cvmx_sriomaintx_asmbly_id_s    cn66xx;
+	struct cvmx_sriomaintx_asmbly_id_s    cn75xx;
 };
 typedef union cvmx_sriomaintx_asmbly_id cvmx_sriomaintx_asmbly_id_t;
 
 /**
  * cvmx_sriomaint#_asmbly_info
  *
- * SRIOMAINT_ASMBLY_INFO = SRIO Assembly Information
- *
- * The Assembly Info register shows the Assembly Revision specified in $SRIO_ASMBLY_INFO
- *
- * Notes:
- * The Assembly Info register shows the Assembly Revision specified in $SRIO_ASMBLY_INFO and Extended
- *  Feature Pointer.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ASMBLY_INFO   hclk    hrst_n
+ * This register shows the assembly revision specified in SRIO()_ASMBLY_INFO and
+ * extended feature pointer.
  */
 union cvmx_sriomaintx_asmbly_info {
 	uint32_t u32;
 	struct cvmx_sriomaintx_asmbly_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t assy_rev                     : 16; /**< Assembly Revision */
-	uint32_t ext_fptr                     : 16; /**< Pointer to the first entry in the extended feature
-                                                         list. */
+	uint32_t assy_rev                     : 16; /**< Assembly revision. */
+	uint32_t ext_fptr                     : 16; /**< Pointer to the first entry in the extended feature list. */
 #else
 	uint32_t ext_fptr                     : 16;
 	uint32_t assy_rev                     : 16;
@@ -914,32 +2375,47 @@ union cvmx_sriomaintx_asmbly_info {
 	struct cvmx_sriomaintx_asmbly_info_s  cn63xx;
 	struct cvmx_sriomaintx_asmbly_info_s  cn63xxp1;
 	struct cvmx_sriomaintx_asmbly_info_s  cn66xx;
+	struct cvmx_sriomaintx_asmbly_info_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_asmbly_info cvmx_sriomaintx_asmbly_info_t;
 
 /**
  * cvmx_sriomaint#_bar1_idx#
  *
- * SRIOMAINT_BAR1_IDXX = SRIO BAR1 IndexX Register
- *
  * Contains address index and control bits for access to memory ranges of BAR1.
- *
- * Notes:
- * This register specifies the Octeon address, endian swap and cache status associated with each of
- *  the 16 BAR1 entries.  The local address bits used are based on the BARSIZE field located in the
- *  SRIOMAINT(0,2..3)_M2S_BAR1_START0 register.  This register is only writeable over SRIO if the
- *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR1 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_BAR1_IDX[0:15]        hclk    hrst_n
+ * This register specifies the Octeon address, endian swap and cache status associated with each
+ * of the 16 BAR1 entries.  The local address bits used are based on the BARSIZE field located in
+ * SRIOMAINT()_M2S_BAR1_START0.  This register is only writeable over SRIO if
+ * SRIO()_ACC_CTRL[DENY_BAR1] is zero.
  */
 union cvmx_sriomaintx_bar1_idxx {
 	uint32_t u32;
 	struct cvmx_sriomaintx_bar1_idxx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_6_31                : 26;
+	uint32_t es                           : 2;  /**< Endian swap mode.
+                                                         0x0 = No swap.
+                                                         0x1 = 64-bit swap bytes [ABCD_EFGH] -> [HGFE_DCBA].
+                                                         0x2 = 32-bit swap words [ABCD_EFGH] -> [DCBA_HGFE].
+                                                         0x3 = 32-bit word exch  [ABCD_EFGH] -> [EFGH_ABCD]. */
+	uint32_t nca                          : 1;  /**< Non-cacheable access mode.  When set, transfers
+                                                         through this window are not cacheable. */
+	uint32_t reserved_1_2                 : 2;
+	uint32_t enable                       : 1;  /**< When set the selected index address is valid. */
+#else
+	uint32_t enable                       : 1;
+	uint32_t reserved_1_2                 : 2;
+	uint32_t nca                          : 1;
+	uint32_t es                           : 2;
+	uint32_t reserved_6_31                : 26;
+#endif
+	} s;
+	struct cvmx_sriomaintx_bar1_idxx_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_30_31               : 2;
 	uint32_t la                           : 22; /**< L2/DRAM Address bits [37:16]
                                                          Not all LA[21:0] bits are used by SRIO hardware,
-                                                         depending on SRIOMAINT(0,2..3)_M2S_BAR1_START1[BARSIZE].
+                                                         depending on SRIOMAINT(0..1)_M2S_BAR1_START1[BARSIZE].
 
                                                                                  Become
                                                                                  L2/DRAM
@@ -978,32 +2454,66 @@ union cvmx_sriomaintx_bar1_idxx {
 	uint32_t la                           : 22;
 	uint32_t reserved_30_31               : 2;
 #endif
-	} s;
-	struct cvmx_sriomaintx_bar1_idxx_s    cn63xx;
-	struct cvmx_sriomaintx_bar1_idxx_s    cn63xxp1;
-	struct cvmx_sriomaintx_bar1_idxx_s    cn66xx;
+	} cn63xx;
+	struct cvmx_sriomaintx_bar1_idxx_cn63xx cn63xxp1;
+	struct cvmx_sriomaintx_bar1_idxx_cn63xx cn66xx;
+	struct cvmx_sriomaintx_bar1_idxx_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t la                           : 26; /**< L2/DRAM Address bits [41:16].
+                                                         Not all LA[25:0] bits are used by SRIO hardware,
+                                                         depending on SRIOMAINT()_M2S_BAR1_START1[BARSIZE].
+                                                         <pre>
+                                                         Become
+                                                         L2/DRAM
+                                                         Address  Entry
+                                                         BARSIZE  LA Bits Used   Bits     Size
+                                                         0        LA[25:0]    [41:16]     64KB
+                                                         1        LA[25:1]    [41:17]    128KB
+                                                         2        LA[25:2]    [41:18]    256KB
+                                                         3        LA[25:3]    [41:19]    512KB
+                                                         4        LA[25:4]    [41:20]      1MB
+                                                         5        LA[25:5]    [41:21]      2MB
+                                                         6        LA[25:6]    [41:22]      4MB
+                                                         7        LA[25:7]    [41:23]      8MB
+                                                         8        LA[25:8]    [41:24]     16MB
+                                                         9        LA[25:9]    [41:25]     32MB
+                                                         10       LA[25:10]   [41:26]     64MB
+                                                         11       LA[25:11]   [41:27]    128MB
+                                                         12       LA[25:12]   [41:28]    256MB
+                                                         13       LA[25:13]   [41:29]    512MB
+                                                         </pre> */
+	uint32_t es                           : 2;  /**< Endian swap mode.
+                                                         0x0 = No swap.
+                                                         0x1 = 64-bit swap bytes [ABCD_EFGH] -> [HGFE_DCBA].
+                                                         0x2 = 32-bit swap words [ABCD_EFGH] -> [DCBA_HGFE].
+                                                         0x3 = 32-bit word exch  [ABCD_EFGH] -> [EFGH_ABCD]. */
+	uint32_t nca                          : 1;  /**< Non-cacheable access mode.  When set, transfers
+                                                         through this window are not cacheable. */
+	uint32_t reserved_1_2                 : 2;
+	uint32_t enable                       : 1;  /**< When set the selected index address is valid. */
+#else
+	uint32_t enable                       : 1;
+	uint32_t reserved_1_2                 : 2;
+	uint32_t nca                          : 1;
+	uint32_t es                           : 2;
+	uint32_t la                           : 26;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriomaintx_bar1_idxx cvmx_sriomaintx_bar1_idxx_t;
 
 /**
  * cvmx_sriomaint#_bell_status
  *
- * SRIOMAINT_BELL_STATUS = SRIO Incoming Doorbell Status
- *
- * The SRIO Incoming (RX) Doorbell Status
- *
- * Notes:
- * This register displays the status of the doorbells received.  If FULL is set the SRIO device will
- *  retry incoming transactions.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_BELL_STATUS   hclk    hrst_n
+ * This register displays the status of the doorbells received. If FULL is set the SRIO
+ * device will retry incoming transactions.
  */
 union cvmx_sriomaintx_bell_status {
 	uint32_t u32;
 	struct cvmx_sriomaintx_bell_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_1_31                : 31;
-	uint32_t full                         : 1;  /**< Not able to receive Doorbell Transactions */
+	uint32_t full                         : 1;  /**< Not able to receive doorbell transactions. */
 #else
 	uint32_t full                         : 1;
 	uint32_t reserved_1_31                : 31;
@@ -1012,27 +2522,21 @@ union cvmx_sriomaintx_bell_status {
 	struct cvmx_sriomaintx_bell_status_s  cn63xx;
 	struct cvmx_sriomaintx_bell_status_s  cn63xxp1;
 	struct cvmx_sriomaintx_bell_status_s  cn66xx;
+	struct cvmx_sriomaintx_bell_status_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_bell_status cvmx_sriomaintx_bell_status_t;
 
 /**
  * cvmx_sriomaint#_comp_tag
  *
- * SRIOMAINT_COMP_TAG = SRIO Component Tag
- *
- * Component Tag
- *
- * Notes:
  * This register contains a component tag value for the processing element and the value can be
- *  assigned by software when the device is initialized.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_COMP_TAG      hclk    hrst_n
+ * assigned by software when the device is initialized.
  */
 union cvmx_sriomaintx_comp_tag {
 	uint32_t u32;
 	struct cvmx_sriomaintx_comp_tag_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t comp_tag                     : 32; /**< Component Tag for Firmware Use */
+	uint32_t comp_tag                     : 32; /**< Component tag for firmware use. */
 #else
 	uint32_t comp_tag                     : 32;
 #endif
@@ -1040,60 +2544,55 @@ union cvmx_sriomaintx_comp_tag {
 	struct cvmx_sriomaintx_comp_tag_s     cn63xx;
 	struct cvmx_sriomaintx_comp_tag_s     cn63xxp1;
 	struct cvmx_sriomaintx_comp_tag_s     cn66xx;
+	struct cvmx_sriomaintx_comp_tag_s     cn75xx;
 };
 typedef union cvmx_sriomaintx_comp_tag cvmx_sriomaintx_comp_tag_t;
 
 /**
  * cvmx_sriomaint#_core_enables
  *
- * SRIOMAINT_CORE_ENABLES = SRIO Core Control
- *
- * Core Control
- *
- * Notes:
- * This register displays the reset state of the Octeon Core Logic while the SRIO Link is running.
- *  The bit should be set after the software has initialized the chip to allow memory operations.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_CORE_ENABLES  hclk    hrst_n, srst_n
+ * This register displays the reset state of the Octeon Core Logic while the SRIO Link is
+ * running.
+ * The bit should be set after the software has initialized the chip to allow memory operations.
  */
 union cvmx_sriomaintx_core_enables {
 	uint32_t u32;
 	struct cvmx_sriomaintx_core_enables_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_5_31                : 27;
-	uint32_t halt                         : 1;  /**< OCTEON currently in Reset
-                                                         0 = All OCTEON resources are available.
-                                                         1 = The OCTEON is in reset. When this bit is set,
-                                                             SRIO maintenance registers can be accessed,
-                                                             but BAR0, BAR1, and BAR2 cannot be. */
-	uint32_t imsg1                        : 1;  /**< Allow Incoming Message Unit 1 Operations
-                                                         Note: This bit is cleared when the C63XX is reset
-                                                          0 = SRIO Incoming Messages to Unit 1 ignored and
-                                                              return error response
-                                                          1 = SRIO Incoming Messages to Unit 1 */
-	uint32_t imsg0                        : 1;  /**< Allow Incoming Message Unit 0 Operations
-                                                         Note: This bit is cleared when the C63XX is reset
-                                                          0 = SRIO Incoming Messages to Unit 0 ignored and
-                                                              return error response
-                                                          1 = SRIO Incoming Messages to Unit 0 */
-	uint32_t doorbell                     : 1;  /**< Allow Inbound Doorbell Operations
-                                                         Note: This bit is cleared when the C63XX is reset
-                                                          0 = SRIO Doorbell OPs ignored and return error
-                                                              response
-                                                          1 = SRIO Doorbell OPs Allowed */
-	uint32_t memory                       : 1;  /**< Allow Inbound/Outbound Memory Operations
-                                                         Note: This bit is cleared when the C63XX is reset
-                                                          0 = SRIO Incoming Nwrites and Swrites are
-                                                              dropped.  Incoming Nreads, Atomics and
-                                                              NwriteRs return responses with ERROR status.
-                                                              SRIO Incoming Maintenance BAR Memory Accesses
-                                                              are processed normally.
-                                                              Outgoing Store Operations are Dropped
-                                                              Outgoing Load Operations are not issued and
-                                                              return all 1's with an ERROR status.
-                                                              In Flight Operations started while the bit is
-                                                              set in both directions will complete normally.
-                                                          1 = SRIO Memory Read/Write OPs Allowed */
+	uint32_t halt                         : 1;  /**< CNXXXX currently in reset.
+                                                         0 = All CNXXXX resources are available.
+                                                         1 = The CNXXXX is in reset. When this bit is set,
+                                                         SRIO maintenance registers can be accessed,
+                                                         but BAR0, BAR1, and BAR2 cannot be. */
+	uint32_t imsg1                        : 1;  /**< Allow incoming message unit 1 operations.
+                                                         Note: This bit is cleared when the CNXXXX is reset.
+                                                         0 = SRIO incoming messages to unit 1 ignored and
+                                                         return error response.
+                                                         1 = SRIO incoming messages to unit 1 allowed. */
+	uint32_t imsg0                        : 1;  /**< Allow incoming message unit 0 operations
+                                                         Note: This bit is cleared when the CNXXX is reset.
+                                                         0 = SRIO incoming messages to unit 0 ignored and
+                                                         return error response.
+                                                         1 = SRIO incoming messages to unit 0 allowed. */
+	uint32_t doorbell                     : 1;  /**< Allow inbound doorbell operations
+                                                         Note: This bit is cleared when the CNXXXX is reset.
+                                                         0 = SRIO doorbell OPs ignored and return error
+                                                         response.
+                                                         1 = SRIO doorbell OPs allowed. */
+	uint32_t memory                       : 1;  /**< Allow inbound/outbound memory operations.
+                                                         Note: This bit is cleared when the CNXXXX is reset.
+                                                         0 = SRIO Incoming nwrites and swrites are
+                                                         dropped.  Incoming nreads, atomics and
+                                                         nwriters return responses with ERROR status.
+                                                         SRIO incoming maintenance BAR memory accesses
+                                                         are processed normally.
+                                                         Outgoing store operations are dropped.
+                                                         Outgoing load operations are not issued and
+                                                         return all 1's with an ERROR status.
+                                                         In flight operations started while the bit is
+                                                         set in both directions will complete normally.
+                                                         1 = SRIO Memory Read/Write OPs Allowed */
 #else
 	uint32_t memory                       : 1;
 	uint32_t doorbell                     : 1;
@@ -1106,27 +2605,22 @@ union cvmx_sriomaintx_core_enables {
 	struct cvmx_sriomaintx_core_enables_s cn63xx;
 	struct cvmx_sriomaintx_core_enables_s cn63xxp1;
 	struct cvmx_sriomaintx_core_enables_s cn66xx;
+	struct cvmx_sriomaintx_core_enables_s cn75xx;
 };
 typedef union cvmx_sriomaintx_core_enables cvmx_sriomaintx_core_enables_t;
 
 /**
  * cvmx_sriomaint#_dev_id
  *
- * SRIOMAINT_DEV_ID = SRIO Device ID
- *
- * The DeviceVendor Identity field identifies the vendor that manufactured the device
+ * This register identifies the vendor that manufactured the device.
  *
- * Notes:
- * This register identifies Cavium Networks and the Product ID.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_DEV_ID        hclk    hrst_n
  */
 union cvmx_sriomaintx_dev_id {
 	uint32_t u32;
 	struct cvmx_sriomaintx_dev_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t device                       : 16; /**< Product Identity */
-	uint32_t vendor                       : 16; /**< Cavium Vendor Identity */
+	uint32_t device                       : 16; /**< Product identity. */
+	uint32_t vendor                       : 16; /**< Cavium vendor identity. */
 #else
 	uint32_t vendor                       : 16;
 	uint32_t device                       : 16;
@@ -1135,27 +2629,22 @@ union cvmx_sriomaintx_dev_id {
 	struct cvmx_sriomaintx_dev_id_s       cn63xx;
 	struct cvmx_sriomaintx_dev_id_s       cn63xxp1;
 	struct cvmx_sriomaintx_dev_id_s       cn66xx;
+	struct cvmx_sriomaintx_dev_id_s       cn75xx;
 };
 typedef union cvmx_sriomaintx_dev_id cvmx_sriomaintx_dev_id_t;
 
 /**
  * cvmx_sriomaint#_dev_rev
  *
- * SRIOMAINT_DEV_REV = SRIO Device Revision
- *
- * The Device Revision register identifies the chip pass and revision
+ * The device revision register identifies the chip pass and revision.
  *
- * Notes:
- * This register identifies the chip pass and revision derived from the fuses.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_DEV_REV       hclk    hrst_n
  */
 union cvmx_sriomaintx_dev_rev {
 	uint32_t u32;
 	struct cvmx_sriomaintx_dev_rev_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_8_31                : 24;
-	uint32_t revision                     : 8;  /**< Chip Pass/Revision */
+	uint32_t revision                     : 8;  /**< Chip pass/revision. */
 #else
 	uint32_t revision                     : 8;
 	uint32_t reserved_8_31                : 24;
@@ -1164,75 +2653,69 @@ union cvmx_sriomaintx_dev_rev {
 	struct cvmx_sriomaintx_dev_rev_s      cn63xx;
 	struct cvmx_sriomaintx_dev_rev_s      cn63xxp1;
 	struct cvmx_sriomaintx_dev_rev_s      cn66xx;
+	struct cvmx_sriomaintx_dev_rev_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_dev_rev cvmx_sriomaintx_dev_rev_t;
 
 /**
  * cvmx_sriomaint#_dst_ops
  *
- * SRIOMAINT_DST_OPS = SRIO Source Operations
- *
- * The logical operations supported from external devices.
- *
- * Notes:
- * The logical operations supported from external devices.   The Destination OPs register shows the
- *  operations specified in the SRIO(0,2..3)_IP_FEATURE.OPS register.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_DST_OPS       hclk    hrst_n
+ * The logical operations supported from external devices.   This register shows
+ * the operations specified in SRIO()_IP_FEATURE[OPS].
  */
 union cvmx_sriomaintx_dst_ops {
 	uint32_t u32;
 	struct cvmx_sriomaintx_dst_ops_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t gsm_read                     : 1;  /**< PE does not support Read Home operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<31>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<31>. */
 	uint32_t i_read                       : 1;  /**< PE does not support Instruction Read.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<30>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<30>. */
 	uint32_t rd_own                       : 1;  /**< PE does not support Read for Ownership.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<29>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<29>. */
 	uint32_t d_invald                     : 1;  /**< PE does not support Data Cache Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<28>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<28>. */
 	uint32_t castout                      : 1;  /**< PE does not support Castout Operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<27>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<27>. */
 	uint32_t d_flush                      : 1;  /**< PE does not support Data Cache Flush.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<26>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<26>. */
 	uint32_t io_read                      : 1;  /**< PE does not support IO Read.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<25>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<25>. */
 	uint32_t i_invald                     : 1;  /**< PE does not support Instruction Cache Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<24>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<24>. */
 	uint32_t tlb_inv                      : 1;  /**< PE does not support TLB Entry Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<23>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<23>. */
 	uint32_t tlb_invs                     : 1;  /**< PE does not support TLB Entry Invalidate Sync.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<22>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<22>. */
 	uint32_t reserved_16_21               : 6;
 	uint32_t read                         : 1;  /**< PE can support Nread operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<15>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS<15>] */
 	uint32_t write                        : 1;  /**< PE can support Nwrite operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<14>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<14>. */
 	uint32_t swrite                       : 1;  /**< PE can support Swrite operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<13>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<13>. */
 	uint32_t write_r                      : 1;  /**< PE can support Write with Response operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<12>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<12>. */
 	uint32_t msg                          : 1;  /**< PE can support Data Message operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<11>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<11>. */
 	uint32_t doorbell                     : 1;  /**< PE can support Doorbell operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<10>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<10>. */
 	uint32_t compswap                     : 1;  /**< PE does not support Atomic Compare and Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<9>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<9>. */
 	uint32_t testswap                     : 1;  /**< PE does not support Atomic Test and Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<8>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<8>. */
 	uint32_t atom_inc                     : 1;  /**< PE can support Atomic increment operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<7>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<7>. */
 	uint32_t atom_dec                     : 1;  /**< PE can support Atomic decrement operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<6>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<6>. */
 	uint32_t atom_set                     : 1;  /**< PE can support Atomic set operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<5>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<5>. */
 	uint32_t atom_clr                     : 1;  /**< PE can support Atomic clear operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<4>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<4>. */
 	uint32_t atom_swp                     : 1;  /**< PE does not support Atomic Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<3>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<3>. */
 	uint32_t port_wr                      : 1;  /**< PE can Port Write operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<2>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<2>. */
 	uint32_t reserved_0_1                 : 2;
 #else
 	uint32_t reserved_0_1                 : 2;
@@ -1266,86 +2749,86 @@ union cvmx_sriomaintx_dst_ops {
 	struct cvmx_sriomaintx_dst_ops_s      cn63xx;
 	struct cvmx_sriomaintx_dst_ops_s      cn63xxp1;
 	struct cvmx_sriomaintx_dst_ops_s      cn66xx;
+	struct cvmx_sriomaintx_dst_ops_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_dst_ops cvmx_sriomaintx_dst_ops_t;
 
 /**
  * cvmx_sriomaint#_erb_attr_capt
  *
- * SRIOMAINT_ERB_ATTR_CAPT = SRIO Attributes Capture
+ * This register contains the information captured during the error.
+ * The HW will not update this register (i.e. this register is locked) while
+ * VALID is set in this CSR.
+ * The HW sets SRIO_INT_REG[PHY_ERB] every time it sets VALID in this CSR.
+ * To handle the interrupt, the following procedure may be best:
  *
- * Attributes Capture
+ * (1) clear SRIO_INT_REG[PHY_ERB],
  *
- * Notes:
- * This register contains the information captured during the error.
- *  The HW will not update this register (i.e. this register is locked) while
- *  VALID is set in this CSR.
- *  The HW sets SRIO_INT_REG[PHY_ERB] every time it sets VALID in this CSR.
- *  To handle the interrupt, the following procedure may be best:
- *       (1) clear SRIO_INT_REG[PHY_ERB],
- *       (2) read this CSR, corresponding SRIOMAINT*_ERB_ERR_DET, SRIOMAINT*_ERB_PACK_SYM_CAPT,
- *           SRIOMAINT*_ERB_PACK_CAPT_1, SRIOMAINT*_ERB_PACK_CAPT_2, and SRIOMAINT*_ERB_PACK_CAPT_3
- *       (3) Write VALID in this CSR to 0.
+ * (2) read this CSR, corresponding SRIOMAINT()_ERB_ERR_DET, SRIOMAINT()_ERB_PACK_SYM_CAPT,
+ * SRIOMAINT()_ERB_PACK_CAPT_1, SRIOMAINT()_ERB_PACK_CAPT_2, and SRIOMAINT()_ERB_PACK_CAPT_3
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ATTR_CAPT hclk    hrst_n
+ * (3) Write VALID in this CSR to 0.
  */
 union cvmx_sriomaintx_erb_attr_capt {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_attr_capt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t inf_type                     : 3;  /**< Type of Information Logged.
-                                                         000 - Packet
-                                                         010 - Short Control Symbol
-                                                               (use only first capture register)
-                                                         100 - Implementation Specific Error Reporting
-                                                         All Others Reserved */
+	uint32_t inf_type                     : 3;  /**< Type of information logged.
+                                                         0x0 = Packet.
+                                                         0x2 = Short control symbol
+                                                         (use only first capture register).
+                                                         0x4 = Implementation specific error reporting.
+                                                         else = Reserved */
 	uint32_t err_type                     : 5;  /**< The encoded value of the 31 minus the bit in
-                                                         SRIOMAINT(0,2..3)_ERB_ERR_DET that describes the error
-                                                         captured in SRIOMAINT(0,2..3)_ERB_*CAPT Registers.
-                                                         (For example a value of 5 indicates 31-5 = bit 26) */
-	uint32_t err_info                     : 20; /**< Error Info.
+                                                         SRIOMAINT()_ERB_ERR_DET that describes the error
+                                                         captured in SRIOMAINT()_ERB_()CAPT Registers.
+                                                         (For example a value of 5 indicates 31-5 = bit 26). */
+	uint32_t err_info                     : 20; /**< Error info.
+                                                         <pre>
                                                          ERR_TYPE Bits   Description
-                                                            0     23     TX Protocol Error
+                                                         -------- ------ -----------
+                                                         0        23     TX Protocol Error
                                                                   22     RX Protocol Error
                                                                   21     TX Link Response Timeout
                                                                   20     TX ACKID Timeout
                                                                   - 19:16  Reserved
                                                                   - 15:12  TX Protocol ID
-                                                                         1 = Rcvd Unexpected Link Response
-                                                                         2 = Rcvd Link Response before Req
-                                                                         3 = Rcvd NACK servicing NACK
-                                                                         4 = Rcvd NACK
-                                                                         5 = Rcvd RETRY servicing RETRY
-                                                                         6 = Rcvd RETRY servicing NACK
-                                                                         7 = Rcvd ACK servicing RETRY
-                                                                         8 = Rcvd ACK servicing NACK
-                                                                         9 = Unexp ACKID on ACK or RETRY
-                                                                        10 = Unexp ACK or RETRY
-                                                                  - 11:8   Reserved
-                                                                  - 7:4   RX Protocol ID
-                                                                         1 = Rcvd EOP w/o Prev SOP
-                                                                         2 = Rcvd STOMP w/o Prev SOP
-                                                                         3 = Unexp RESTART
-                                                                         4 = Redundant Status from LinkReq
-                                                          9-16    23:20  RX K Bits
-                                                                  - 19:0   Reserved
-                                                           26     23:20  RX K Bits
-                                                                  - 19:0   Reserved
-                                                           27     23:12  Type
-                                                                           0x000 TX
-                                                                           0x010 RX
-                                                                  - 11:8   RX or TX Protocol ID (see above)
-                                                                  - 7:4   Reserved
-                                                           30     23:20  RX K Bits
-                                                                  - 19:0   Reserved
-                                                           31     23:16  ACKID Timeout 0x2
-                                                                  - 15:14  Reserved
-                                                                  - 13:8   AckID
-                                                                  - 7:4   Reserved
-                                                           All others ERR_TYPEs are reserved. */
+                                                                           1 = Rcvd Unexpected Link Response
+                                                                           2 = Rcvd Link Response before Req
+                                                                           3 = Rcvd NACK servicing NACK
+                                                                           4 = Rcvd NACK
+                                                                           5 = Rcvd RETRY servicing RETRY
+                                                                           6 = Rcvd RETRY servicing NACK
+                                                                           7 = Rcvd ACK servicing RETRY
+                                                                           8 = Rcvd ACK servicing NACK
+                                                                           9 = Unexp ACKID on ACK or RETRY
+                                                                           10 = Unexp ACK or RETRY
+                                                                 - 11:8   Reserved
+                                                                - 7:4   RX Protocol ID
+                                                                           1 = Rcvd EOP w/o Prev SOP
+                                                                           2 = Rcvd STOMP w/o Prev SOP
+                                                                           3 = Unexp RESTART
+                                                                           4 = Redundant Status from LinkReq
+                                                         9-16   23:20  RX K Bits
+                                                                - 19:0   Reserved
+                                                         26     23:20  RX K Bits
+                                                                - 19:0   Reserved
+                                                         27     23:12  Type
+                                                                        0x000 TX
+                                                                        0x010 RX
+                                                                - 11:8   RX or TX Protocol ID (see above)
+                                                                - 7:4   Reserved
+                                                         30     23:20  RX K Bits
+                                                                - 19:0   Reserved
+                                                         31     23:16  ACKID Timeout 0x2
+                                                                - 15:14  Reserved
+                                                                - 13:8   AckID
+                                                                - 7:4   Reserved
+                                                         </pre>
+                                                         All others ERR_TYPEs are reserved. */
 	uint32_t reserved_1_3                 : 3;
 	uint32_t valid                        : 1;  /**< This bit is set by hardware to indicate that the
-                                                         Packet/control symbol capture registers contain
+                                                         packet/control symbol capture registers contain
                                                          valid information. For control symbols, only
                                                          capture register 0 will contain meaningful
                                                          information.  This bit must be cleared by software
@@ -1385,67 +2868,60 @@ union cvmx_sriomaintx_erb_attr_capt {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_erb_attr_capt_s cn66xx;
+	struct cvmx_sriomaintx_erb_attr_capt_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_attr_capt cvmx_sriomaintx_erb_attr_capt_t;
 
 /**
  * cvmx_sriomaint#_erb_err_det
  *
- * SRIOMAINT_ERB_ERR_DET = SRIO Error Detect
- *
- * Error Detect
- *
- * Notes:
- * The Error Detect Register indicates physical layer transmission errors detected by the hardware.
- *  The HW will not update this register (i.e. this register is locked) while
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_DET   hclk    hrst_n
+ * The Error Detect Register indicates physical layer transmission errors detected by the
+ * hardware. The HW will not update this register (i.e. this register is locked) while
+ * SRIOMAINT()_ERB_ATTR_CAPT[VALID] is set.
  */
 union cvmx_sriomaintx_erb_err_det {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_err_det_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t imp_err                      : 1;  /**< Implementation Specific Error. */
+	uint32_t imp_err                      : 1;  /**< Implementation specific error. */
 	uint32_t reserved_23_30               : 8;
-	uint32_t ctl_crc                      : 1;  /**< Received a control symbol with a bad CRC value
-                                                         Complete Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+	uint32_t ctl_crc                      : 1;  /**< Received a control symbol with a bad CRC value.
+                                                         Complete symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t uns_id                       : 1;  /**< Received an acknowledge control symbol with an
-                                                         unexpected ackID (packet-accepted or packet_retry)
-                                                         Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         unexpected ackID (packet-accepted or packet_retry).
+                                                         Partial symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t nack                         : 1;  /**< Received packet-not-accepted acknowledge control
                                                          symbols.
-                                                         Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
-	uint32_t out_ack                      : 1;  /**< Received packet with unexpected ackID value
-                                                         Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
-	uint32_t pkt_crc                      : 1;  /**< Received a packet with a bad CRC value
-                                                         Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Partial symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
+	uint32_t out_ack                      : 1;  /**< Received packet with unexpected ackID value.
+                                                         Header in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
+	uint32_t pkt_crc                      : 1;  /**< Received a packet with a bad CRC value.
+                                                         Header in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t size                         : 1;  /**< Received packet which exceeds the maximum allowed
                                                          size of 276 bytes.
-                                                         Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Header in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t inv_char                     : 1;  /**< Received illegal, 8B/10B error  or undefined
                                                          codegroup within a packet.
-                                                         Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Header in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t inv_data                     : 1;  /**< Received data codegroup or 8B/10B error within an
                                                          IDLE sequence.
-                                                         Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Header in SRIOMAINT()_ERB_PACK_SYM_CAPT */
 	uint32_t reserved_6_14                : 9;
 	uint32_t bad_ack                      : 1;  /**< Link_response received with an ackID that is not
                                                          outstanding.
-                                                         Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Partial symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t proterr                      : 1;  /**< An unexpected packet or control symbol was
                                                          received.
-                                                         Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Partial Symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT */
 	uint32_t f_toggle                     : 1;  /**< Reserved. */
-	uint32_t del_err                      : 1;  /**< Received illegal or undefined codegroup.
-                                                         (either INV_DATA or INV_CHAR)
-                                                         Complete Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
-	uint32_t uns_ack                      : 1;  /**< An unexpected acknowledge control symbol was
-                                                         received.
-                                                         Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+	uint32_t del_err                      : 1;  /**< Received illegal or undefined codegroup
+                                                         (either INV_DATA or INV_CHAR).
+                                                         Complete symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
+	uint32_t uns_ack                      : 1;  /**< An unexpected acknowledge control symbol was received.
+                                                         Partial symbol in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 	uint32_t lnk_tout                     : 1;  /**< An acknowledge or link-response control symbol is
                                                          not received within the specified timeout interval
-                                                         Partial Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
+                                                         Partial header in SRIOMAINT()_ERB_PACK_SYM_CAPT. */
 #else
 	uint32_t lnk_tout                     : 1;
 	uint32_t uns_ack                      : 1;
@@ -1520,50 +2996,42 @@ union cvmx_sriomaintx_erb_err_det {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_erb_err_det_s  cn66xx;
+	struct cvmx_sriomaintx_erb_err_det_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_err_det cvmx_sriomaintx_erb_err_det_t;
 
 /**
  * cvmx_sriomaint#_erb_err_rate
  *
- * SRIOMAINT_ERB_ERR_RATE = SRIO Error Rate
- *
- * Error Rate
- *
- * Notes:
- * The Error Rate register is used with the Error Rate Threshold register to monitor and control the
- *  reporting of transmission errors.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE  hclk    hrst_n
+ * This register is used with the Error Rate Threshold register to monitor and control
+ * the reporting of transmission errors.
  */
 union cvmx_sriomaintx_erb_err_rate {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_err_rate_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t err_bias                     : 8;  /**< These bits provide the error rate bias value.
-                                                         0x00 - do not decrement the error rate counter
-                                                         0x01 - decrement every 1ms (+/-34%)
-                                                         0x02 - decrement every 10ms (+/-34%)
-                                                         0x04 - decrement every 100ms (+/-34%)
-                                                         0x08 - decrement every 1s (+/-34%)
-                                                         0x10 - decrement every 10s (+/-34%)
-                                                         0x20 - decrement every 100s (+/-34%)
-                                                         0x40 - decrement every 1000s (+/-34%)
-                                                         0x80 - decrement every 10000s (+/-34%)
-                                                         All other values are reserved */
+                                                         0x00 = do not decrement the error rate counter.
+                                                         0x01 = decrement every 1ms (+/-34%).
+                                                         0x02 = decrement every 10ms (+/-34%).
+                                                         0x04 = decrement every 100ms (+/-34%).
+                                                         0x08 = decrement every 1s (+/-34%).
+                                                         0x10 = decrement every 10s (+/-34%).
+                                                         0x20 = decrement every 100s (+/-34%).
+                                                         0x40 = decrement every 1000s (+/-34%).
+                                                         0x80 = decrement every 10000s (+/-34%).
+                                                         _ All other values are reserved */
 	uint32_t reserved_18_23               : 6;
 	uint32_t rate_lim                     : 2;  /**< These bits limit the incrementing of the error
                                                          rate counter above the failed threshold trigger.
-                                                           00 - only count 2 errors above
-                                                           01 - only count 4 errors above
-                                                           10 - only count 16 error above
-                                                           11 - do not limit incrementing the error rate ct */
-	uint32_t pk_rate                      : 8;  /**< Peak Value attainted by the error rate counter */
-	uint32_t rate_cnt                     : 8;  /**< These bits maintain a count of the number of
-                                                         transmission errors that have been detected by the
-                                                         port, decremented by the Error Rate Bias
-                                                         mechanism, to create an indication of the link
-                                                         error rate. */
+                                                         0x0 = only count 2 errors above.
+                                                         0x1 = only count 4 errors above.
+                                                         0x2 = only count 16 error above.
+                                                         0x3 = do not limit incrementing the error rate count. */
+	uint32_t pk_rate                      : 8;  /**< Peak value attainted by the error rate counter */
+	uint32_t rate_cnt                     : 8;  /**< These bits maintain a count of the number of transmission errors that have been
+                                                         detected by the port, decremented by the error rate bias mechanism, to create an
+                                                         indication of the link error rate. */
 #else
 	uint32_t rate_cnt                     : 8;
 	uint32_t pk_rate                      : 8;
@@ -1575,44 +3043,39 @@ union cvmx_sriomaintx_erb_err_rate {
 	struct cvmx_sriomaintx_erb_err_rate_s cn63xx;
 	struct cvmx_sriomaintx_erb_err_rate_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_err_rate_s cn66xx;
+	struct cvmx_sriomaintx_erb_err_rate_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_err_rate cvmx_sriomaintx_erb_err_rate_t;
 
 /**
  * cvmx_sriomaint#_erb_err_rate_en
  *
- * SRIOMAINT_ERB_ERR_RATE_EN = SRIO Error Rate Enable
- *
- * Error Rate Enable
- *
- * Notes:
- * This register contains the bits that control when an error condition is allowed to increment the
- *  error rate counter in the Error Rate Threshold Register and lock the Error Capture registers.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE_EN       hclk    hrst_n
+ * This register contains the bits that control when an error condition is allowed to increment
+ * the error rate counter in the error rate threshold register and lock the error capture
+ * registers.
  */
 union cvmx_sriomaintx_erb_err_rate_en {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_err_rate_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t imp_err                      : 1;  /**< Enable Implementation Specific Error. */
+	uint32_t imp_err                      : 1;  /**< Enable implementation specific error. */
 	uint32_t reserved_23_30               : 8;
 	uint32_t ctl_crc                      : 1;  /**< Enable error rate counting of control symbols with
-                                                         bad CRC values */
+                                                         bad CRC values. */
 	uint32_t uns_id                       : 1;  /**< Enable error rate counting of acknowledge control
                                                          symbol with unexpected ackIDs
-                                                         (packet-accepted or packet_retry) */
+                                                         (packet-accepted or packet_retry). */
 	uint32_t nack                         : 1;  /**< Enable error rate counting of packet-not-accepted
                                                          acknowledge control symbols. */
 	uint32_t out_ack                      : 1;  /**< Enable error rate counting of received packet with
-                                                         unexpected ackID value */
+                                                         unexpected ackID value. */
 	uint32_t pkt_crc                      : 1;  /**< Enable error rate counting of received a packet
-                                                         with a bad CRC value */
+                                                         with a bad CRC value. */
 	uint32_t size                         : 1;  /**< Enable error rate counting of received packet
                                                          which exceeds the maximum size of 276 bytes. */
 	uint32_t inv_char                     : 1;  /**< Enable error rate counting of received illegal
-                                                         illegal, 8B/10B error or undefined codegroup
-                                                         within a packet. */
+                                                         8B/10B error or undefined codegroup within a
+                                                         packet. */
 	uint32_t inv_data                     : 1;  /**< Enable error rate counting of received data
                                                          codegroup or 8B/10B error within IDLE sequence. */
 	uint32_t reserved_6_14                : 9;
@@ -1627,7 +3090,7 @@ union cvmx_sriomaintx_erb_err_rate_en {
                                                          acknowledge control symbols received. */
 	uint32_t lnk_tout                     : 1;  /**< Enable error rate counting of acknowledge or
                                                          link-response control symbols not received within
-                                                         the specified timeout interval */
+                                                         the specified timeout interval. */
 #else
 	uint32_t lnk_tout                     : 1;
 	uint32_t uns_ack                      : 1;
@@ -1696,21 +3159,15 @@ union cvmx_sriomaintx_erb_err_rate_en {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_erb_err_rate_en_s cn66xx;
+	struct cvmx_sriomaintx_erb_err_rate_en_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_err_rate_en cvmx_sriomaintx_erb_err_rate_en_t;
 
 /**
  * cvmx_sriomaint#_erb_err_rate_thr
  *
- * SRIOMAINT_ERB_ERR_RATE_THR = SRIO Error Rate Threshold
- *
- * Error Rate Threshold
- *
- * Notes:
- * The Error Rate Threshold register is used to control the reporting of errors to the link status.
- *  Typically the Degraded Threshold is less than the Fail Threshold.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR      hclk    hrst_n
+ * This register is used to control the reporting of errors to the link
+ * status. Typically the degraded threshold is less than the fail threshold.
  */
 union cvmx_sriomaintx_erb_err_rate_thr {
 	uint32_t u32;
@@ -1719,21 +3176,19 @@ union cvmx_sriomaintx_erb_err_rate_thr {
 	uint32_t fail_th                      : 8;  /**< These bits provide the threshold value for
                                                          reporting an error condition due to a possibly
                                                          broken link.
-                                                           0x00 - Disable the Error Rate Failed Threshold
-                                                                  Trigger
-                                                           0x01 - Set the error reporting threshold to 1
-                                                           0x02 - Set the error reporting threshold to 2
-                                                           - ...
-                                                           0xFF - Set the error reporting threshold to 255 */
+                                                         0x00 = Disable the error rate failed threshold trigger.
+                                                         0x01 = Set the error reporting threshold to 1.
+                                                         0x02 = Set the error reporting threshold to 2.
+                                                         - ...
+                                                         0xFF = Set the error reporting threshold to 255. */
 	uint32_t dgrad_th                     : 8;  /**< These bits provide the threshold value for
                                                          reporting an error condition due to a possibly
                                                          degrading link.
-                                                           0x00 - Disable the Degrade Rate Failed Threshold
-                                                                  Trigger
-                                                           0x01 - Set the error reporting threshold to 1
-                                                           0x02 - Set the error reporting threshold to 2
-                                                           - ...
-                                                           0xFF - Set the error reporting threshold to 255 */
+                                                         0x00 = Disable the degrade rate failed threshold trigger.
+                                                         0x01 - Set the error reporting threshold to 1.
+                                                         0x02 - Set the error reporting threshold to 2.
+                                                         - ...
+                                                         0xFF - Set the error reporting threshold to 255. */
 	uint32_t reserved_0_15                : 16;
 #else
 	uint32_t reserved_0_15                : 16;
@@ -1744,22 +3199,16 @@ union cvmx_sriomaintx_erb_err_rate_thr {
 	struct cvmx_sriomaintx_erb_err_rate_thr_s cn63xx;
 	struct cvmx_sriomaintx_erb_err_rate_thr_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_err_rate_thr_s cn66xx;
+	struct cvmx_sriomaintx_erb_err_rate_thr_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_err_rate_thr cvmx_sriomaintx_erb_err_rate_thr_t;
 
 /**
  * cvmx_sriomaint#_erb_hdr
  *
- * SRIOMAINT_ERB_HDR = SRIO Error Reporting Block Header
- *
- * Error Reporting Block Header
- *
- * Notes:
- * The error management extensions block header register contains the EF_PTR to the next EF_BLK and
- *  the EF_ID that identifies this as the error management extensions block header. In this
- *  implementation this is the last block and therefore the EF_PTR is a NULL pointer.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_HDR       hclk    hrst_n
+ * The error management extensions block header register contains the EF_PTR to the next EF_BLK
+ * and the EF_ID that identifies this as the error management extensions block header. In this
+ * implementation this is the last block and therefore the EF_PTR is a NULL pointer.
  */
 union cvmx_sriomaintx_erb_hdr {
 	uint32_t u32;
@@ -1767,7 +3216,7 @@ union cvmx_sriomaintx_erb_hdr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ef_ptr                       : 16; /**< Pointer to the next block in the extended features
                                                          data structure. */
-	uint32_t ef_id                        : 16; /**< Single Port ID */
+	uint32_t ef_id                        : 16; /**< Single port ID. */
 #else
 	uint32_t ef_id                        : 16;
 	uint32_t ef_ptr                       : 16;
@@ -1776,23 +3225,17 @@ union cvmx_sriomaintx_erb_hdr {
 	struct cvmx_sriomaintx_erb_hdr_s      cn63xx;
 	struct cvmx_sriomaintx_erb_hdr_s      cn63xxp1;
 	struct cvmx_sriomaintx_erb_hdr_s      cn66xx;
+	struct cvmx_sriomaintx_erb_hdr_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_hdr cvmx_sriomaintx_erb_hdr_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_addr_capt_h
  *
- * SRIOMAINT_ERB_LT_ADDR_CAPT_H = SRIO Logical/Transport Layer High Address Capture
- *
- * Logical/Transport Layer High Address Capture
- *
- * Notes:
- * This register contains error information. It is locked when a Logical/Transport error is detected
- *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero. This register should be
- *  written only when error detection is disabled.  This register is only required for end point
- *  transactions of 50 or 66 bits.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ADDR_CAPT_H    hclk    hrst_n
+ * This register contains error information. It is locked when a Logical/Transport error is
+ * detected and unlocked when the SRIOMAINT()_ERB_LT_ERR_DET is written to zero. This
+ * register should be written only when error detection is disabled.  This register is only
+ * required for end point transactions of 50 or 66 bits.
  */
 union cvmx_sriomaintx_erb_lt_addr_capt_h {
 	uint32_t u32;
@@ -1808,22 +3251,16 @@ union cvmx_sriomaintx_erb_lt_addr_capt_h {
 	struct cvmx_sriomaintx_erb_lt_addr_capt_h_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_addr_capt_h_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_addr_capt_h_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_addr_capt_h_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_addr_capt_h cvmx_sriomaintx_erb_lt_addr_capt_h_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_addr_capt_l
  *
- * SRIOMAINT_ERB_LT_ADDR_CAPT_L = SRIO Logical/Transport Layer Low Address Capture
- *
- * Logical/Transport Layer Low Address Capture
- *
- * Notes:
- * This register contains error information. It is locked when a Logical/Transport error is detected
- *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be
- *  written only when error detection is disabled.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ADDR_CAPT_L    hclk    hrst_n
+ * This register contains error information. It is locked when a Logical/Transport error is
+ * detected and unlocked when the SRIOMAINT()_ERB_LT_ERR_DET is written to zero.
+ * This register should be written only when error detection is disabled.
  */
 union cvmx_sriomaintx_erb_lt_addr_capt_l {
 	uint32_t u32;
@@ -1831,7 +3268,7 @@ union cvmx_sriomaintx_erb_lt_addr_capt_l {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t addr                         : 29; /**< Least significant 29 bits of the address
                                                          associated with the error.  Bits 31:24 specify the
-                                                         request HOP count for Maintenance Operations.
+                                                         request HOP count for maintenance operations.
                                                          Information supplied for requests and responses if
                                                          available. */
 	uint32_t reserved_2_2                 : 1;
@@ -1847,52 +3284,42 @@ union cvmx_sriomaintx_erb_lt_addr_capt_l {
 	struct cvmx_sriomaintx_erb_lt_addr_capt_l_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_addr_capt_l_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_addr_capt_l_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_addr_capt_l_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_addr_capt_l cvmx_sriomaintx_erb_lt_addr_capt_l_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_ctrl_capt
  *
- * SRIOMAINT_ERB_LT_CTRL_CAPT = SRIO Logical/Transport Layer Control Capture
- *
- * Logical/Transport Layer Control Capture
- *
- * Notes:
- * This register contains error information. It is locked when a Logical/Transport error is detected
- *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be
- *  written only when error detection is disabled.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_CTRL_CAPT      hclk    hrst_n
+ * This register contains error information. It is locked when a Logical/Transport error is
+ * detected and unlocked when the SRIOMAINT()_ERB_LT_ERR_DET is written to zero.
+ * This register should be written only when error detection is disabled.
  */
 union cvmx_sriomaintx_erb_lt_ctrl_capt {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_lt_ctrl_capt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t ftype                        : 4;  /**< Format Type associated with the error */
-	uint32_t ttype                        : 4;  /**< Transaction Type associated with the error
-                                                         (For Messages)
-                                                         Message Length */
-	uint32_t extra                        : 8;  /**< Additional Information
-                                                         (For Messages)
-                                                         - 23:22 Letter
-                                                         - 21:20 Mbox
-                                                         - 19:16 Msgseg/xmbox
+	uint32_t ftype                        : 4;  /**< Format type associated with the error. */
+	uint32_t ttype                        : 4;  /**< Transaction type associated with the error
+                                                         (for messages). */
+	uint32_t extra                        : 8;  /**< Additional information (for messages):
+                                                         <23:22> = Letter.
+                                                         <21:20> = Mbox.
+                                                         <19:16> = Msgseg/xmbox.
                                                          Information for the last message request sent
-                                                         for the mailbox that had an error
-                                                         (For Responses)
-                                                         - 23:20 Response Request FTYPE
-                                                         - 19:16 Response Request TTYPE
-                                                         (For all other types)
-                                                         Reserved. */
+                                                         for the mailbox that had an error (for responses):
+                                                         <23:20> = Response request FTYPE.
+                                                         <19:16> = Response request TTYPE.
+                                                         For all other types:
+                                                         _ Reserved. */
 	uint32_t status                       : 4;  /**< Response Status.
-                                                         (For all other Requests)
+                                                         (For all other requests)
                                                          Reserved. */
 	uint32_t size                         : 4;  /**< Size associated with the transaction. */
 	uint32_t tt                           : 1;  /**< Transfer Type 0=ID8, 1=ID16. */
 	uint32_t wdptr                        : 1;  /**< Word Pointer associated with the error. */
 	uint32_t reserved_5_5                 : 1;
-	uint32_t capt_idx                     : 5;  /**< Capture Index. 31 - Bit set in
-                                                         SRIOMAINT(0,2..3)_ERB_LT_ERR_DET. */
+	uint32_t capt_idx                     : 5;  /**< Capture Index. 31 - Bit set in SRIOMAINT()_ERB_LT_ERR_DET. */
 #else
 	uint32_t capt_idx                     : 5;
 	uint32_t reserved_5_5                 : 1;
@@ -1908,34 +3335,26 @@ union cvmx_sriomaintx_erb_lt_ctrl_capt {
 	struct cvmx_sriomaintx_erb_lt_ctrl_capt_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_ctrl_capt_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_ctrl_capt_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_ctrl_capt_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_ctrl_capt cvmx_sriomaintx_erb_lt_ctrl_capt_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_dev_id
  *
- * SRIOMAINT_ERB_LT_DEV_ID = SRIO Port-write Target deviceID
- *
- * Port-write Target deviceID
- *
- * Notes:
- * This SRIO interface does not support generating Port-Writes based on ERB Errors.  This register is
- *  currently unused and should be treated as reserved.
- *
- * Clk_Rst:        SRIOMAINT_ERB_LT_DEV_ID hclk    hrst_n
+ * This SRIO interface does not support generating port-writes based on ERB errors.  This
+ * register is currently unused and should be treated as reserved.
  */
 union cvmx_sriomaintx_erb_lt_dev_id {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_lt_dev_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t id16                         : 8;  /**< This is the most significant byte of the
-                                                         port-write destination deviceID (large transport
-                                                         systems only)
-                                                         destination ID used for Port Write errors */
-	uint32_t id8                          : 8;  /**< This is the port-write destination deviceID */
-	uint32_t tt                           : 1;  /**< Transport Type used for Port Write
-                                                         0 = Small Transport, ID8 Only
-                                                         1 = Large Transport, ID16 and ID8 */
+	uint32_t id16                         : 8;  /**< This is the most significant byte of the port-write destination deviceID (large
+                                                         transport systems only) destination ID used for port write errors. */
+	uint32_t id8                          : 8;  /**< This is the port-write destination deviceID. */
+	uint32_t tt                           : 1;  /**< Transport type used for port write.
+                                                         0 = Small transport, ID8 only.
+                                                         1 = Large transport, ID16 and ID8. */
 	uint32_t reserved_0_14                : 15;
 #else
 	uint32_t reserved_0_14                : 15;
@@ -1947,37 +3366,31 @@ union cvmx_sriomaintx_erb_lt_dev_id {
 	struct cvmx_sriomaintx_erb_lt_dev_id_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_dev_id_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_dev_id_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_dev_id_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_dev_id cvmx_sriomaintx_erb_lt_dev_id_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_dev_id_capt
  *
- * SRIOMAINT_ERB_LT_DEV_ID_CAPT = SRIO Logical/Transport Layer Device ID Capture
- *
- * Logical/Transport Layer Device ID Capture
- *
- * Notes:
- * This register contains error information. It is locked when a Logical/Transport error is detected
- *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be
- *  written only when error detection is disabled.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_DEV_ID_CAPT    hclk    hrst_n
+ * This register contains error information. It is locked when a Logical/Transport error is
+ * detected and unlocked when the SRIOMAINT()_ERB_LT_ERR_DET is written to zero.  This
+ * register should be written only when error detection is disabled.
  */
 union cvmx_sriomaintx_erb_lt_dev_id_capt {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_lt_dev_id_capt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t dst_id16                     : 8;  /**< Most significant byte of the large transport
-                                                         destination ID associated with the error */
+                                                         destination ID associated with the error. */
 	uint32_t dst_id8                      : 8;  /**< Least significant byte of the large transport
                                                          destination ID or the 8-bit small transport
-                                                         destination ID associated with the error */
+                                                         destination ID associated with the error. */
 	uint32_t src_id16                     : 8;  /**< Most significant byte of the large transport
-                                                         source ID associated with the error */
+                                                         source ID associated with the error. */
 	uint32_t src_id8                      : 8;  /**< Least significant byte of the large transport
                                                          source ID or the 8-bit small transport source ID
-                                                         associated with the error */
+                                                         associated with the error. */
 #else
 	uint32_t src_id8                      : 8;
 	uint32_t src_id16                     : 8;
@@ -1988,36 +3401,34 @@ union cvmx_sriomaintx_erb_lt_dev_id_capt {
 	struct cvmx_sriomaintx_erb_lt_dev_id_capt_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_dev_id_capt_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_dev_id_capt_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_dev_id_capt_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_dev_id_capt cvmx_sriomaintx_erb_lt_dev_id_capt_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_err_det
  *
- * SRIOMAINT_ERB_LT_ERR_DET = SRIO Logical/Transport Layer Error Detect
+ * This register indicates the error that was detected by the Logical or Transport logic layer.
+ * Once a bit is set in this CSR, HW will lock the register until SW writes a zero to clear all
+ * the fields.  The HW sets SRIO_INT_REG[LOG_ERB] every time it sets one of the bits.
+ * To handle the interrupt, the following procedure may be best:
  *
- * SRIO Logical/Transport Layer Error Detect
+ * (1) read this CSR, corresponding SRIOMAINT()_ERB_LT_ADDR_CAPT_H,
+ * SRIOMAINT()_ERB_LT_ADDR_CAPT_L,
+ * SRIOMAINT()_ERB_LT_DEV_ID_CAPT, and SRIOMAINT()_ERB_LT_CTRL_CAPT
  *
- * Notes:
- * This register indicates the error that was detected by the Logical or Transport logic layer.
- *  Once a bit is set in this CSR, HW will lock the register until SW writes a zero to clear all the
- *  fields.  The HW sets SRIO_INT_REG[LOG_ERB] every time it sets one of the bits.
- *  To handle the interrupt, the following procedure may be best:
- *       (1) clear SRIO_INT_REG[LOG_ERB],
- *       (2) read this CSR, corresponding SRIOMAINT*_ERB_LT_ADDR_CAPT_H, SRIOMAINT*_ERB_LT_ADDR_CAPT_L,
- *           SRIOMAINT*_ERB_LT_DEV_ID_CAPT, and SRIOMAINT*_ERB_LT_CTRL_CAPT
- *       (3) Write this CSR to 0.
+ * (2) Write this CSR to 0.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ERR_DET        hclk    hrst_n
+ * (3) clear SRIO_INT_REG[LOG_ERB],
  */
 union cvmx_sriomaintx_erb_lt_err_det {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_lt_err_det_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t io_err                       : 1;  /**< Received a response of ERROR for an IO Logical
-                                                         Layer Request.  This includes all Maintenance and
-                                                         Memory Responses not destined for the RX Soft
-                                                         Packet FIFO. When SRIO receives an ERROR response
+	uint32_t io_err                       : 1;  /**< Received a response of ERROR for an IO logical
+                                                         layer request.  This includes all maintenance and
+                                                         memory responses not destined for the RX soft
+                                                         packet FIFO. When SRIO receives an ERROR response
                                                          for a read, the issuing core or DPI DMA engine
                                                          receives result bytes with all bits set. In the
                                                          case of writes with response, this bit is the only
@@ -2026,7 +3437,7 @@ union cvmx_sriomaintx_erb_lt_err_det {
                                                          message segment. This bit is the only direct
                                                          indication of a MSG_ERR. When a MSG_ERR occurs,
                                                          SRIO drops the message segment and will not set
-                                                         SRIO*_INT_REG[OMSG*] after the message
+                                                         SRIO()_INT_REG[OMSG*] after the message
                                                          "transfer". NOTE: SRIO can continue to send or
                                                          retry other segments from the same message after
                                                          a MSG_ERR. */
@@ -2060,21 +3471,21 @@ union cvmx_sriomaintx_erb_lt_err_det {
                                                          outstanding message segment whose status was not
                                                          DONE, RETRY, or ERROR. */
 	uint32_t ill_tgt                      : 1;  /**< Received a packet that contained a destination ID
-                                                         other than SRIOMAINT*_PRI_DEV_ID or
-                                                         SRIOMAINT*_SEC_DEV_ID. When an ILL_TGT error
+                                                         other than SRIOMAINT()_PRI_DEV_ID or
+                                                         SRIOMAINT()_SEC_DEV_ID. When an ILL_TGT error
                                                          occurs, SRIO drops the packet. ILL_TGT errors are
                                                          highest priority, so may mask other problems.
                                                          Packets with ILL_TGT errors cannot enter the RX
                                                          soft packet fifo. */
 	uint32_t msg_tout                     : 1;  /**< An expected incoming message request has not been
                                                          received within the time-out interval specified in
-                                                         SRIOMAINT(0,2..3)_PORT_RT_CTL. When a MSG_TOUT occurs,
+                                                         SRIOMAINT()_PORT_RT_CTL. When a MSG_TOUT occurs,
                                                          SRIO (internally) terminates the inflight message
                                                          with an error. */
 	uint32_t pkt_tout                     : 1;  /**< A required response has not been received to an
                                                          outgoing memory, maintenance or message request
                                                          before the time-out interval specified in
-                                                         SRIOMAINT(0,2..3)_PORT_RT_CTL.  When an IO or maintenance
+                                                         SRIOMAINT()_PORT_RT_CTL.  When an IO or maintenance
                                                          read request operation has a PKT_TOUT, the issuing
                                                          core load or DPI DMA engine receive all ones for
                                                          the result. When an IO NWRITE_R has a PKT_TOUT,
@@ -2085,23 +3496,23 @@ union cvmx_sriomaintx_erb_lt_err_det {
                                                          NOTE: SRIO may continue to send or retry other
                                                          segments from the same message. When one or more of
                                                          the segments in an outgoing message have a
-                                                         PKT_TOUT, SRIO will not set SRIO*_INT_REG[OMSG*]
+                                                         PKT_TOUT, SRIO will not set SRIO()_INT_REG[OMSG*]
                                                          after the message "transfer". */
 	uint32_t uns_resp                     : 1;  /**< An unsolicited/unexpected memory, maintenance or
                                                          message response packet was received that was not
-                                                         destined for the RX Soft Packet FIFO.  When this
+                                                         destined for the RX soft packet FIFO.  When this
                                                          condition is detected, the packet is dropped. */
 	uint32_t uns_tran                     : 1;  /**< A transaction is received that is not supported.
                                                          SRIO HW will never set this bit - SRIO routes all
                                                          unsupported transactions to the RX soft packet
                                                          FIFO. */
 	uint32_t reserved_1_21                : 21;
-	uint32_t resp_sz                      : 1;  /**< Received an incoming Memory or Maintenance
-                                                         Read response packet with a DONE status and less
+	uint32_t resp_sz                      : 1;  /**< Received an incoming memory or maintenance
+                                                         read response packet with a DONE status and less
                                                          data then expected.  This condition causes the
                                                          Read to be completed and an error response to be
                                                          returned with all the data bits set to the issuing
-                                                         Core or DMA Engine. */
+                                                         core or DMA engine. */
 #else
 	uint32_t resp_sz                      : 1;
 	uint32_t reserved_1_21                : 21;
@@ -2120,69 +3531,50 @@ union cvmx_sriomaintx_erb_lt_err_det {
 	struct cvmx_sriomaintx_erb_lt_err_det_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_err_det_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_err_det_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_err_det_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_err_det cvmx_sriomaintx_erb_lt_err_det_t;
 
 /**
  * cvmx_sriomaint#_erb_lt_err_en
  *
- * SRIOMAINT_ERB_LT_ERR_EN = SRIO Logical/Transport Layer Error Enable
- *
- * SRIO Logical/Transport Layer Error Enable
- *
- * Notes:
- * This register contains the bits that control if an error condition locks the Logical/Transport
- *  Layer Error Detect and Capture registers and is reported to the system host.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ERR_EN hclk    hrst_n
+ * This register contains the bits that control if an error condition locks the
+ * logical/transport layer error detect and capture registers and is reported to the
+ * system host.
  */
 union cvmx_sriomaintx_erb_lt_err_en {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_lt_err_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t io_err                       : 1;  /**< Enable reporting of an IO error response. Save and
-                                                         lock original request transaction information in
-                                                         all Logical/Transport Layer Capture CSRs. */
-	uint32_t msg_err                      : 1;  /**< Enable reporting of a Message error response. Save
-                                                         and lock original request transaction information
-                                                         in all Logical/Transport Layer Capture CSRs. */
-	uint32_t gsm_err                      : 1;  /**< Enable reporting of a GSM error response. Save and
-                                                         lock original request transaction capture
-                                                         information in all Logical/Transport Layer Capture
+	uint32_t io_err                       : 1;  /**< Enable reporting of an IO error response. Save and lock original request
+                                                         transaction information in all logical/transport layer capture CSRs. */
+	uint32_t msg_err                      : 1;  /**< Enable reporting of a Message error response. Save and lock original request
+                                                         transaction information in all logical/transport layer capture CSRs. */
+	uint32_t gsm_err                      : 1;  /**< Enable reporting of a GSM error response. Save and lock original request
+                                                         transaction capture information in all logical/transport layer capture CSRs. */
+	uint32_t msg_fmt                      : 1;  /**< Enable reporting of a message format error. Save and lock transaction capture
+                                                         information in logical/transport layer device ID and control capture CSRs. */
+	uint32_t ill_tran                     : 1;  /**< Enable reporting of an illegal transaction decode error Save and lock
+                                                         transaction capture information in logical/transport layer device ID and control
+                                                         capture CSRs. */
+	uint32_t ill_tgt                      : 1;  /**< Enable reporting of an illegal transaction target error. Save and lock
+                                                         transaction capture information in logical/transport layer device ID and control
+                                                         capture CSRs. */
+	uint32_t msg_tout                     : 1;  /**< Enable reporting of a message request time-out error. Save and lock transaction
+                                                         capture information in logical/transport layer device ID and control capture
+                                                         CSRs for the last message request segment packet received. */
+	uint32_t pkt_tout                     : 1;  /**< Enable reporting of a packet response time-out error. Save and lock original
+                                                         request address in logical/transport layer address capture CSRs. Save and lock
+                                                         original request destination ID in logical/transport layer device ID capture
+                                                         CSR. */
+	uint32_t uns_resp                     : 1;  /**< Enable reporting of an unsolicited response error. Save and lock transaction
+                                                         capture information in logical/transport layer device ID and control capture
+                                                         CSRs. */
+	uint32_t uns_tran                     : 1;  /**< Enable reporting of an unsupported transaction error. Save and lock transaction
+                                                         capture information in logical/transport layer device ID and control capture
                                                          CSRs. */
-	uint32_t msg_fmt                      : 1;  /**< Enable reporting of a message format error. Save
-                                                         and lock transaction capture information in
-                                                         Logical/Transport Layer Device ID and Control
-                                                         Capture CSRs. */
-	uint32_t ill_tran                     : 1;  /**< Enable reporting of an illegal transaction decode
-                                                         error Save and lock transaction capture
-                                                         information in Logical/Transport Layer Device ID
-                                                         and Control Capture CSRs. */
-	uint32_t ill_tgt                      : 1;  /**< Enable reporting of an illegal transaction target
-                                                         error. Save and lock transaction capture
-                                                         information in Logical/Transport Layer Device ID
-                                                         and Control Capture CSRs. */
-	uint32_t msg_tout                     : 1;  /**< Enable reporting of a Message Request time-out
-                                                         error. Save and lock transaction capture
-                                                         information in Logical/Transport Layer Device ID
-                                                         and Control Capture CSRs for the last Message
-                                                         request segment packet received. */
-	uint32_t pkt_tout                     : 1;  /**< Enable reporting of a packet response time-out
-                                                         error.  Save and lock original request address in
-                                                         Logical/Transport Layer Address Capture CSRs.
-                                                         Save and lock original request Destination ID in
-                                                         Logical/Transport Layer Device ID Capture CSR. */
-	uint32_t uns_resp                     : 1;  /**< Enable reporting of an unsolicited response error.
-                                                         Save and lock transaction capture information in
-                                                         Logical/Transport Layer Device ID and Control
-                                                         Capture CSRs. */
-	uint32_t uns_tran                     : 1;  /**< Enable reporting of an unsupported transaction
-                                                         error.  Save and lock transaction capture
-                                                         information in Logical/Transport Layer Device ID
-                                                         and Control Capture CSRs. */
 	uint32_t reserved_1_21                : 21;
-	uint32_t resp_sz                      : 1;  /**< Enable reporting of an incoming response with
-                                                         unexpected data size */
+	uint32_t resp_sz                      : 1;  /**< Enable reporting of an incoming response with unexpected data size. */
 #else
 	uint32_t resp_sz                      : 1;
 	uint32_t reserved_1_21                : 21;
@@ -2201,23 +3593,17 @@ union cvmx_sriomaintx_erb_lt_err_en {
 	struct cvmx_sriomaintx_erb_lt_err_en_s cn63xx;
 	struct cvmx_sriomaintx_erb_lt_err_en_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_lt_err_en_s cn66xx;
+	struct cvmx_sriomaintx_erb_lt_err_en_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_lt_err_en cvmx_sriomaintx_erb_lt_err_en_t;
 
 /**
  * cvmx_sriomaint#_erb_pack_capt_1
  *
- * SRIOMAINT_ERB_PACK_CAPT_1 = SRIO Packet Capture 1
- *
- * Packet Capture 1
- *
- * Notes:
- * Error capture register 1 contains either long symbol capture information or bytes 4 through 7 of
- *  the packet header.
- *  The HW will not update this register (i.e. this register is locked) while
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_1       hclk    hrst_n
+ * This register contains either long symbol capture information or bytes 4
+ * through 7 of the packet header. The HW will not update this register (i.e. this
+ * register is locked) while SRIOMAINT()_ERB_ATTR_CAPT[VALID] is set. This register
+ * should only be read while this bit is set.
  */
 union cvmx_sriomaintx_erb_pack_capt_1 {
 	uint32_t u32;
@@ -2231,22 +3617,17 @@ union cvmx_sriomaintx_erb_pack_capt_1 {
 	struct cvmx_sriomaintx_erb_pack_capt_1_s cn63xx;
 	struct cvmx_sriomaintx_erb_pack_capt_1_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_pack_capt_1_s cn66xx;
+	struct cvmx_sriomaintx_erb_pack_capt_1_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_pack_capt_1 cvmx_sriomaintx_erb_pack_capt_1_t;
 
 /**
  * cvmx_sriomaint#_erb_pack_capt_2
  *
- * SRIOMAINT_ERB_PACK_CAPT_2 = SRIO Packet Capture 2
- *
- * Packet Capture 2
- *
- * Notes:
- * Error capture register 2 contains bytes 8 through 11 of the packet header.
- *  The HW will not update this register (i.e. this register is locked) while
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_2       hclk    hrst_n
+ * This register contains bytes 8 through 11 of the packet header. The HW
+ * will not update this register (i.e. this register is locked) while
+ * SRIOMAINT()_ERB_ATTR_CAPT[VALID] is set. This register should only be read while
+ * this bit is set.
  */
 union cvmx_sriomaintx_erb_pack_capt_2 {
 	uint32_t u32;
@@ -2260,22 +3641,17 @@ union cvmx_sriomaintx_erb_pack_capt_2 {
 	struct cvmx_sriomaintx_erb_pack_capt_2_s cn63xx;
 	struct cvmx_sriomaintx_erb_pack_capt_2_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_pack_capt_2_s cn66xx;
+	struct cvmx_sriomaintx_erb_pack_capt_2_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_pack_capt_2 cvmx_sriomaintx_erb_pack_capt_2_t;
 
 /**
  * cvmx_sriomaint#_erb_pack_capt_3
  *
- * SRIOMAINT_ERB_PACK_CAPT_3 = SRIO Packet Capture 3
- *
- * Packet Capture 3
- *
- * Notes:
- * Error capture register 3 contains bytes 12 through 15 of the packet header.
- *  The HW will not update this register (i.e. this register is locked) while
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_3       hclk    hrst_n
+ * This register contains bytes 12 through 15 of the packet header.
+ * The HW will not update this register (i.e. this register is locked) while
+ * SRIOMAINT()_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is
+ * set.
  */
 union cvmx_sriomaintx_erb_pack_capt_3 {
 	uint32_t u32;
@@ -2289,38 +3665,33 @@ union cvmx_sriomaintx_erb_pack_capt_3 {
 	struct cvmx_sriomaintx_erb_pack_capt_3_s cn63xx;
 	struct cvmx_sriomaintx_erb_pack_capt_3_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_pack_capt_3_s cn66xx;
+	struct cvmx_sriomaintx_erb_pack_capt_3_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_pack_capt_3 cvmx_sriomaintx_erb_pack_capt_3_t;
 
 /**
  * cvmx_sriomaint#_erb_pack_sym_capt
  *
- * SRIOMAINT_ERB_PACK_SYM_CAPT = SRIO Packet/Control Symbol Capture
- *
- * Packet/Control Symbol Capture
- *
- * Notes:
- * This register contains either captured control symbol information or the first 4 bytes of captured
- *  packet information.  The Errors that generate Partial Control Symbols can be found in
- *  SRIOMAINT*_ERB_ERR_DET.  The HW will not update this register (i.e. this register is locked) while
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT     hclk    hrst_n
+ * This register contains either captured control symbol information or the first 4 bytes of
+ * captured packet information.  The Errors that generate Partial Control Symbols can be found in
+ * SRIOMAINT()_ERB_ERR_DET.  The HW will not update this register (i.e. this register is locked)
+ * while SRIOMAINT()_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this
+ * bit is set.
  */
 union cvmx_sriomaintx_erb_pack_sym_capt {
 	uint32_t u32;
 	struct cvmx_sriomaintx_erb_pack_sym_capt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t capture                      : 32; /**< Control Character and Control Symbol or Bytes 0 to
-                                                         3 of Packet Header
-                                                         The Control Symbol consists of
-                                                           - 31:24 - SC Character (0 in Partial Symbol)
-                                                           - 23:21 - Stype 0
-                                                           - 20:16 - Parameter 0
-                                                           - 15:11 - Parameter 1
-                                                           - 10: 8 - Stype 1 (0 in Partial Symbol)
-                                                           - 7: 5 - Command (0 in Partial Symbol)
-                                                           - 4: 0 - CRC5    (0 in Partial Symbol) */
+	uint32_t capture                      : 32; /**< Control character and control symbol or bytes 0 to
+                                                         3 of packet header.
+                                                         The control symbol consists of:
+                                                         <31:24> = SC Character (0 in partial symbol).
+                                                         <23:21> = Stype 0.
+                                                         <20:16> = Parameter 0.
+                                                         <15:11> = Parameter 1.
+                                                         <10:8> = Stype 1 (0 in partial symbol).
+                                                         <7:5> = Command (0 in partial symbol).
+                                                         <4:0> = CRC5    (0 in partial symbol). */
 #else
 	uint32_t capture                      : 32;
 #endif
@@ -2328,31 +3699,26 @@ union cvmx_sriomaintx_erb_pack_sym_capt {
 	struct cvmx_sriomaintx_erb_pack_sym_capt_s cn63xx;
 	struct cvmx_sriomaintx_erb_pack_sym_capt_s cn63xxp1;
 	struct cvmx_sriomaintx_erb_pack_sym_capt_s cn66xx;
+	struct cvmx_sriomaintx_erb_pack_sym_capt_s cn75xx;
 };
 typedef union cvmx_sriomaintx_erb_pack_sym_capt cvmx_sriomaintx_erb_pack_sym_capt_t;
 
 /**
  * cvmx_sriomaint#_hb_dev_id_lock
  *
- * SRIOMAINT_HB_DEV_ID_LOCK = SRIO Host Device ID Lock
- *
- * The Host Base Device ID
- *
- * Notes:
- * This register contains the Device ID of the Host responsible for initializing this SRIO device.
- *  The register contains a special write once function that captures the first HOSTID written to it
- *  after reset.  The function allows several potential hosts to write to this register and then read
- *  it to see if they have responsibility for initialization.  The register can be unlocked by
- *  rewriting the current host value.  This will reset the lock and restore the value to 0xFFFF.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_HB_DEV_ID_LOCK        hclk    hrst_n
+ * This register contains the device ID of the host responsible for initializing this SRIO
+ * device. The register contains a special write once function that captures the first HOSTID
+ * written to it after reset.  The function allows several potential hosts to write to this
+ * register and then read it to see if they have responsibility for initialization.  The register
+ * can be unlocked by rewriting the current host value.  This will reset the lock and restore the
+ * value to 0xFFFF.
  */
 union cvmx_sriomaintx_hb_dev_id_lock {
 	uint32_t u32;
 	struct cvmx_sriomaintx_hb_dev_id_lock_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
-	uint32_t hostid                       : 16; /**< Primary 16-bit Device ID */
+	uint32_t hostid                       : 16; /**< Primary 16-bit device ID. */
 #else
 	uint32_t hostid                       : 16;
 	uint32_t reserved_16_31               : 16;
@@ -2361,35 +3727,28 @@ union cvmx_sriomaintx_hb_dev_id_lock {
 	struct cvmx_sriomaintx_hb_dev_id_lock_s cn63xx;
 	struct cvmx_sriomaintx_hb_dev_id_lock_s cn63xxp1;
 	struct cvmx_sriomaintx_hb_dev_id_lock_s cn66xx;
+	struct cvmx_sriomaintx_hb_dev_id_lock_s cn75xx;
 };
 typedef union cvmx_sriomaintx_hb_dev_id_lock cvmx_sriomaintx_hb_dev_id_lock_t;
 
 /**
  * cvmx_sriomaint#_ir_buffer_config
  *
- * SRIOMAINT_IR_BUFFER_CONFIG = SRIO Buffer Configuration
- *
- * Buffer Configuration
+ * This register controls the operation of the SRIO core buffer mux logic.
  *
- * Notes:
- * This register controls the operation of the SRIO Core buffer mux logic.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG      hclk    hrst_n
  */
 union cvmx_sriomaintx_ir_buffer_config {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_buffer_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t tx_wm0                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
-	uint32_t tx_wm1                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
-	uint32_t tx_wm2                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
+	uint32_t tx_wm0                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
+	uint32_t tx_wm1                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
+	uint32_t tx_wm2                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
 	uint32_t reserved_3_19                : 17;
-	uint32_t tx_flow                      : 1;  /**< Controls whether Transmitter Flow Control is
-                                                         permitted on this device.
-                                                           0 - Disabled
-                                                           1 - Permitted
-                                                         The reset value of this field is
-                                                         SRIO*_IP_FEATURE[TX_FLOW]. */
+	uint32_t tx_flow                      : 1;  /**< Controls whether transmitter flow control is permitted on this device.
+                                                         0 = Disabled.
+                                                         1 = Permitted.
+                                                         The reset value of this field is SRIO()_IP_FEATURE[TX_FLOW]. */
 	uint32_t tx_sync                      : 1;  /**< Reserved. */
 	uint32_t rx_sync                      : 1;  /**< Reserved. */
 #else
@@ -2405,23 +3764,38 @@ union cvmx_sriomaintx_ir_buffer_config {
 	struct cvmx_sriomaintx_ir_buffer_config_s cn63xx;
 	struct cvmx_sriomaintx_ir_buffer_config_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_buffer_config_s cn66xx;
+	struct cvmx_sriomaintx_ir_buffer_config_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t tx_wm0                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
+	uint32_t tx_wm1                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
+	uint32_t tx_wm2                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
+	uint32_t reserved_19_3                : 17;
+	uint32_t tx_flow                      : 1;  /**< Controls whether transmitter flow control is permitted on this device.
+                                                         0 = Disabled.
+                                                         1 = Permitted.
+                                                         The reset value of this field is SRIO()_IP_FEATURE[TX_FLOW]. */
+	uint32_t tx_sync                      : 1;  /**< Reserved. */
+	uint32_t rx_sync                      : 1;  /**< Reserved. */
+#else
+	uint32_t rx_sync                      : 1;
+	uint32_t tx_sync                      : 1;
+	uint32_t tx_flow                      : 1;
+	uint32_t reserved_19_3                : 17;
+	uint32_t tx_wm2                       : 4;
+	uint32_t tx_wm1                       : 4;
+	uint32_t tx_wm0                       : 4;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_buffer_config cvmx_sriomaintx_ir_buffer_config_t;
 
 /**
  * cvmx_sriomaint#_ir_buffer_config2
  *
- * SRIOMAINT_IR_BUFFER_CONFIG2 = SRIO Buffer Configuration 2
- *
- * Buffer Configuration 2
- *
- * Notes:
- * This register controls the RX and TX Buffer availablility by priority.  The typical values are
- *  optimized for normal operation.  Care must be taken when changing these values to avoid values
- *  which can result in deadlocks.  Disabling a priority is not recommended and can result in system
- *  level failures.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2     hclk    hrst_n
+ * This register controls the RX and TX Buffer availablility by priority.  The typical values
+ * are optimized for normal operation.  Care must be taken when changing these values to avoid
+ * values which can result in deadlocks.  Disabling a priority is not recommended and can result
+ * in system level failures.
  */
 union cvmx_sriomaintx_ir_buffer_config2 {
 	uint32_t u32;
@@ -2464,26 +3838,21 @@ union cvmx_sriomaintx_ir_buffer_config2 {
 	} s;
 	struct cvmx_sriomaintx_ir_buffer_config2_s cn63xx;
 	struct cvmx_sriomaintx_ir_buffer_config2_s cn66xx;
+	struct cvmx_sriomaintx_ir_buffer_config2_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_buffer_config2 cvmx_sriomaintx_ir_buffer_config2_t;
 
 /**
  * cvmx_sriomaint#_ir_pd_phy_ctrl
  *
- * SRIOMAINT_IR_PD_PHY_CTRL = SRIO Platform Dependent PHY Control
- *
- * Platform Dependent PHY Control
- *
- * Notes:
  * This register can be used for testing.  The register is otherwise unused by the hardware.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PD_PHY_CTRL        hclk    hrst_n
  */
 union cvmx_sriomaintx_ir_pd_phy_ctrl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_pd_phy_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t pd_ctrl                      : 32; /**< Unused Register available for testing */
+	uint32_t pd_ctrl                      : 32; /**< Unused register available for testing. */
 #else
 	uint32_t pd_ctrl                      : 32;
 #endif
@@ -2491,63 +3860,57 @@ union cvmx_sriomaintx_ir_pd_phy_ctrl {
 	struct cvmx_sriomaintx_ir_pd_phy_ctrl_s cn63xx;
 	struct cvmx_sriomaintx_ir_pd_phy_ctrl_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_pd_phy_ctrl_s cn66xx;
+	struct cvmx_sriomaintx_ir_pd_phy_ctrl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_pd_phy_ctrl cvmx_sriomaintx_ir_pd_phy_ctrl_t;
 
 /**
  * cvmx_sriomaint#_ir_pd_phy_stat
  *
- * SRIOMAINT_IR_PD_PHY_STAT = SRIO Platform Dependent PHY Status
- *
- * Platform Dependent PHY Status
- *
- * Notes:
- * This register is used to monitor PHY status on each lane.  They are documented here to assist in
- *  debugging only.  The lane numbers take into account the lane swap pin.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PD_PHY_STAT        hclk    hrst_n
+ * This register is used to monitor PHY status on each lane.  They are documented here to assist
+ * in debugging only.  The lane numbers take into account the lane swap pin.
  */
 union cvmx_sriomaintx_ir_pd_phy_stat {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_pd_phy_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
-	uint32_t ln3_rx                       : 3;  /**< Phy Lane 3 RX Status
-                                                         0XX = Normal Operation
-                                                         100 = 8B/10B Error
-                                                         101 = Elastic Buffer Overflow (Data Lost)
-                                                         110 = Elastic Buffer Underflow (Data Corrupted)
-                                                         111 = Disparity Error */
-	uint32_t ln3_dis                      : 1;  /**< Lane 3 Phy Clock Disabled
-                                                         0 = Phy Clock Valid
-                                                         1 = Phy Clock InValid */
-	uint32_t ln2_rx                       : 3;  /**< Phy Lane 2 RX Status
-                                                         0XX = Normal Operation
-                                                         100 = 8B/10B Error
-                                                         101 = Elastic Buffer Overflow (Data Lost)
-                                                         110 = Elastic Buffer Underflow (Data Corrupted)
-                                                         111 = Disparity Error */
-	uint32_t ln2_dis                      : 1;  /**< Lane 2 Phy Clock Disabled
-                                                         0 = Phy Clock Valid
-                                                         1 = Phy Clock InValid */
-	uint32_t ln1_rx                       : 3;  /**< Phy Lane 1 RX Status
-                                                         0XX = Normal Operation
-                                                         100 = 8B/10B Error
-                                                         101 = Elastic Buffer Overflow (Data Lost)
-                                                         110 = Elastic Buffer Underflow (Data Corrupted)
-                                                         111 = Disparity Error */
-	uint32_t ln1_dis                      : 1;  /**< Lane 1 Phy Clock Disabled
-                                                         0 = Phy Clock Valid
-                                                         1 = Phy Clock InValid */
-	uint32_t ln0_rx                       : 3;  /**< Phy Lane 0 RX Status
-                                                         0XX = Normal Operation
-                                                         100 = 8B/10B Error
-                                                         101 = Elastic Buffer Overflow (Data Lost)
-                                                         110 = Elastic Buffer Underflow (Data Corrupted)
-                                                         111 = Disparity Error */
-	uint32_t ln0_dis                      : 1;  /**< Lane 0 Phy Clock Disabled
-                                                         0 = Phy Clock Valid
-                                                         1 = Phy Clock InValid */
+	uint32_t ln3_rx                       : 3;  /**< Phy lane 3 RX status.
+                                                         0XX = Normal operation.
+                                                         100 = 8B/10B error.
+                                                         101 = Elastic buffer overflow (data lost).
+                                                         110 = Elastic buffer underflow (data corrupted).
+                                                         111 = Disparity error. */
+	uint32_t ln3_dis                      : 1;  /**< Lane 3 phy clock disabled.
+                                                         0 = Phy clock valid.
+                                                         1 = Phy clock invalid. */
+	uint32_t ln2_rx                       : 3;  /**< Phy lane 2 RX status.
+                                                         0XX = Normal operation
+                                                         100 = 8B/10B error.
+                                                         101 = Elastic buffer overflow (data lost).
+                                                         110 = Elastic buffer underflow (data corrupted).
+                                                         111 = Disparity error. */
+	uint32_t ln2_dis                      : 1;  /**< Lane 2 phy clock disabled.
+                                                         0 = Phy clock valid.
+                                                         1 = Phy clock invalid. */
+	uint32_t ln1_rx                       : 3;  /**< Phy lane 1 RX status.
+                                                         0XX = Normal operation.
+                                                         100 = 8B/10B error.
+                                                         101 = Elastic buffer overflow (data lost).
+                                                         110 = Elastic buffer underflow (data corrupted).
+                                                         111 = Disparity error. */
+	uint32_t ln1_dis                      : 1;  /**< Lane 1 phy clock disabled.
+                                                         0 = Phy clock valid.
+                                                         1 = Phy clock invalid. */
+	uint32_t ln0_rx                       : 3;  /**< Phy Lane 0 RX status.
+                                                         0XX = Normal operation.
+                                                         100 = 8B/10B error.
+                                                         101 = Elastic buffer overflow (data lost).
+                                                         110 = Elastic buffer underflow (data corrupted).
+                                                         111 = Disparity error. */
+	uint32_t ln0_dis                      : 1;  /**< Lane 0 phy clock disabled.
+                                                         0 = Phy clock valid.
+                                                         1 = Phy clock invalid. */
 #else
 	uint32_t ln0_dis                      : 1;
 	uint32_t ln0_rx                       : 3;
@@ -2563,36 +3926,30 @@ union cvmx_sriomaintx_ir_pd_phy_stat {
 	struct cvmx_sriomaintx_ir_pd_phy_stat_s cn63xx;
 	struct cvmx_sriomaintx_ir_pd_phy_stat_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_pd_phy_stat_s cn66xx;
+	struct cvmx_sriomaintx_ir_pd_phy_stat_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_pd_phy_stat cvmx_sriomaintx_ir_pd_phy_stat_t;
 
 /**
  * cvmx_sriomaint#_ir_pi_phy_ctrl
  *
- * SRIOMAINT_IR_PI_PHY_CTRL = SRIO Platform Independent PHY Control
- *
- * Platform Independent PHY Control
- *
- * Notes:
- * This register is used to control platform independent operating modes of the transceivers. These
- *  control bits are uniform across all platforms.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PI_PHY_CTRL        hclk    hrst_n
+ * This register is used to control platform independent operating modes of the transceivers.
+ * These control bits are uniform across all platforms.
  */
 union cvmx_sriomaintx_ir_pi_phy_ctrl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_pi_phy_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t tx_reset                     : 1;  /**< Outgoing PHY Logic Reset.  0=Reset, 1=Normal Op */
-	uint32_t rx_reset                     : 1;  /**< Incoming PHY Logic Reset.  0=Reset, 1=Normal Op */
+	uint32_t tx_reset                     : 1;  /**< Outgoing PHY Logic Reset.  0=Reset, 1=Normal operation. */
+	uint32_t rx_reset                     : 1;  /**< Incoming PHY Logic Reset.  0=Reset, 1=Normal operation. */
 	uint32_t reserved_29_29               : 1;
 	uint32_t loopback                     : 2;  /**< These bits control the state of the loopback
                                                          control vector on the transceiver interface.  The
                                                          loopback modes are enumerated as follows:
-                                                           00 - No Loopback
-                                                           01 - Near End PCS Loopback
-                                                           10 - Far End PCS Loopback
-                                                           11 - Both Near and Far End PCS Loopback */
+                                                         0x0 - No loopback.
+                                                         0x1 = Near end PCS loopback.
+                                                         0x2 = Far end PCS loopback.
+                                                         0x3 = Both near and far end PCS loopback. */
 	uint32_t reserved_0_26                : 27;
 #else
 	uint32_t reserved_0_26                : 27;
@@ -2605,41 +3962,35 @@ union cvmx_sriomaintx_ir_pi_phy_ctrl {
 	struct cvmx_sriomaintx_ir_pi_phy_ctrl_s cn63xx;
 	struct cvmx_sriomaintx_ir_pi_phy_ctrl_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_pi_phy_ctrl_s cn66xx;
+	struct cvmx_sriomaintx_ir_pi_phy_ctrl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_pi_phy_ctrl cvmx_sriomaintx_ir_pi_phy_ctrl_t;
 
 /**
  * cvmx_sriomaint#_ir_pi_phy_stat
  *
- * SRIOMAINT_IR_PI_PHY_STAT = SRIO Platform Independent PHY Status
- *
- * Platform Independent PHY Status
- *
- * Notes:
- * This register displays the status of the link initialization state machine.  Changes to this state
- *  cause the SRIO(0,2..3)_INT_REG.LINK_UP or SRIO(0,2..3)_INT_REG.LINK_DOWN interrupts.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PI_PHY_STAT        hclk    hrst_n
+ * This register displays the status of the link initialization state machine.  Changes to this
+ * state cause the SRIO()_INT_REG[LINK_UP] or SRIO()_INT_REG[LINK_DOWN] interrupts.
  */
 union cvmx_sriomaintx_ir_pi_phy_stat {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_pi_phy_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_12_31               : 20;
-	uint32_t tx_rdy                       : 1;  /**< Minimum number of Status Transmitted */
-	uint32_t rx_rdy                       : 1;  /**< Minimum number of Good Status Received */
+	uint32_t tx_rdy                       : 1;  /**< Minimum number of status transmitted. */
+	uint32_t rx_rdy                       : 1;  /**< Minimum number of good status received. */
 	uint32_t init_sm                      : 10; /**< Initialization State Machine
-                                                         001 - Silent
-                                                         002 - Seek
-                                                         004 - Discovery
-                                                         008 - 1x_Mode_Lane0
-                                                         010 - 1x_Mode_Lane1
-                                                         020 - 1x_Mode_Lane2
-                                                         040 - 1x_Recovery
-                                                         080 - 2x_Mode
-                                                         100 - 2x_Recovery
-                                                         200 - 4x_Mode
-                                                         All others are reserved */
+                                                         0x001 = Silent.
+                                                         0x002 = Seek.
+                                                         0x004 = Discovery.
+                                                         0x008 = 1x_Mode_Lane0.
+                                                         0x010 = 1x_Mode_Lane1.
+                                                         0x020 = 1x_Mode_Lane2.
+                                                         0x040 = 1x_Recovery.
+                                                         0x080 = 2x_Mode.
+                                                         0x100 = 2x_Recovery.
+                                                         0x200 = 4x_Mode.
+                                                         _ All others are reserved */
 #else
 	uint32_t init_sm                      : 10;
 	uint32_t rx_rdy                       : 1;
@@ -2669,21 +4020,15 @@ union cvmx_sriomaintx_ir_pi_phy_stat {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_ir_pi_phy_stat_s cn66xx;
+	struct cvmx_sriomaintx_ir_pi_phy_stat_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_pi_phy_stat cvmx_sriomaintx_ir_pi_phy_stat_t;
 
 /**
  * cvmx_sriomaint#_ir_sp_rx_ctrl
  *
- * SRIOMAINT_IR_SP_RX_CTRL = SRIO Soft Packet FIFO Receive Control
- *
- * Soft Packet FIFO Receive Control
- *
- * Notes:
- * This register is used to configure events generated by the reception of packets using the soft
- * packet FIFO.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_CTRL hclk    hrst_n
+ * This register is used to configure events generated by the reception of packets using the
+ * soft packet FIFO.
  */
 union cvmx_sriomaintx_ir_sp_rx_ctrl {
 	uint32_t u32;
@@ -2693,7 +4038,7 @@ union cvmx_sriomaintx_ir_sp_rx_ctrl {
 	uint32_t overwrt                      : 1;  /**< When clear, SRIO drops received packets that should
                                                          enter the soft packet FIFO when the FIFO is full.
                                                          In this case, SRIO also increments
-                                                         SRIOMAINT(0,2..3)_IR_SP_RX_STAT.DROP_CNT. When set, SRIO
+                                                         SRIOMAINT()_IR_SP_RX_STAT[DROP_CNT]. When set, SRIO
                                                          stalls received packets that should enter the soft
                                                          packet FIFO when the FIFO is full. SRIO may stop
                                                          receiving any packets in this stall case if
@@ -2707,34 +4052,28 @@ union cvmx_sriomaintx_ir_sp_rx_ctrl {
 	struct cvmx_sriomaintx_ir_sp_rx_ctrl_s cn63xx;
 	struct cvmx_sriomaintx_ir_sp_rx_ctrl_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_rx_ctrl_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_rx_ctrl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_rx_ctrl cvmx_sriomaintx_ir_sp_rx_ctrl_t;
 
 /**
  * cvmx_sriomaint#_ir_sp_rx_data
  *
- * SRIOMAINT_IR_SP_RX_DATA = SRIO Soft Packet FIFO Receive Data
- *
- * Soft Packet FIFO Receive Data
- *
- * Notes:
- * This register is used to read data from the soft packet FIFO.  The Soft Packet FIFO contains the
- *  majority of the packet data received from the SRIO link.  The packet does not include the Control
- *  Symbols or the initial byte containing AckId, 2 Reserved Bits and the CRF.  In the case of packets
- *  with less than 80 bytes (including AckId byte) both the trailing CRC and Pad (if present) are
- *  included in the FIFO and Octet Count.  In the case of a packet with exactly 80 bytes (including
- *  the AckId byte) the CRC is removed and the Pad is maintained so the Octet Count will read 81 bytes
- *  instead of the expected 83.  In cases over 80 bytes the CRC at 80 bytes is removed but the
- *  trailing CRC and Pad (if necessary) are present.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_DATA hclk    hrst_n
+ * This register is used to read data from the soft packet FIFO.  The Soft Packet FIFO contains
+ * the majority of the packet data received from the SRIO link.  The packet does not include the
+ * Control Symbols or the initial byte containing AckId, 2 Reserved Bits and the CRF.  In the
+ * case of packets with less than 80 bytes (including AckId byte) both the trailing CRC and Pad
+ * (if present) are included in the FIFO and Octet Count.  In the case of a packet with exactly
+ * 80 bytes (including the AckId byte) the CRC is removed and the Pad is maintained so the Octet
+ * Count will read 81 bytes instead of the expected 83.  In cases over 80 bytes the CRC at 80
+ * bytes
+ * is removed but the trailing CRC and Pad (if necessary) are present.
  */
 union cvmx_sriomaintx_ir_sp_rx_data {
 	uint32_t u32;
 	struct cvmx_sriomaintx_ir_sp_rx_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t pkt_data                     : 32; /**< This register is used to read packet data from the
-                                                         RX FIFO. */
+	uint32_t pkt_data                     : 32; /**< This register is used to read packet data from the RX FIFO. */
 #else
 	uint32_t pkt_data                     : 32;
 #endif
@@ -2742,27 +4081,25 @@ union cvmx_sriomaintx_ir_sp_rx_data {
 	struct cvmx_sriomaintx_ir_sp_rx_data_s cn63xx;
 	struct cvmx_sriomaintx_ir_sp_rx_data_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_rx_data_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_rx_data_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_rx_data cvmx_sriomaintx_ir_sp_rx_data_t;
 
 /**
  * cvmx_sriomaint#_ir_sp_rx_stat
  *
- * SRIOMAINT_IR_SP_RX_STAT = SRIO Soft Packet FIFO Receive Status
+ * This register is used to monitor the reception of packets using the soft packet FIFO.
+ * The HW sets SRIO_INT_REG[SOFT_RX] every time a packet arrives in the soft packet FIFO. To read
+ * out (one or more) packets, the following procedure may be best:
  *
- * Soft Packet FIFO Receive Status
+ * (1) clear SRIO_INT_REG[SOFT_RX],
  *
- * Notes:
- * This register is used to monitor the reception of packets using the soft packet FIFO.
- *  The HW sets SRIO_INT_REG[SOFT_RX] every time a packet arrives in the soft packet FIFO. To read
- *  out (one or more) packets, the following procedure may be best:
- *       (1) clear SRIO_INT_REG[SOFT_RX],
- *       (2) read this CSR to determine how many packets there are,
- *       (3) read the packets out (via SRIOMAINT*_IR_SP_RX_DATA).
- *  This procedure could lead to situations where SOFT_RX will be set even though there are currently
- *  no packets - the SW interrupt handler would need to properly handle this case
+ * (2) read this CSR to determine how many packets there are,
+ *
+ * (3) read the packets out (via SRIOMAINT()_IR_SP_RX_DATA).
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_STAT hclk    hrst_n
+ * This procedure could lead to situations where SOFT_RX will be set even though there are
+ * currently no packets the SW interrupt handler would need to properly handle this case
  */
 union cvmx_sriomaintx_ir_sp_rx_stat {
 	uint32_t u32;
@@ -2779,10 +4116,10 @@ union cvmx_sriomaintx_ir_sp_rx_stat {
 	uint32_t fifo_st                      : 4;  /**< These bits display the state of the state machine
                                                          that controls loading of packet data into the RX
                                                          FIFO. The enumeration of states are as follows:
-                                                           0000 - Idle
-                                                           0001 - Armed
-                                                           0010 - Active
-                                                           All other states are reserved. */
+                                                         0x0 = Idle.
+                                                         0x1 = Armed.
+                                                         0x2 = Active.
+                                                         _ All other states are reserved. */
 #else
 	uint32_t fifo_st                      : 4;
 	uint32_t full                         : 1;
@@ -2818,21 +4155,15 @@ union cvmx_sriomaintx_ir_sp_rx_stat {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_rx_stat_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_rx_stat_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_rx_stat cvmx_sriomaintx_ir_sp_rx_stat_t;
 
 /**
  * cvmx_sriomaint#_ir_sp_tx_ctrl
  *
- * SRIOMAINT_IR_SP_TX_CTRL = SRIO Soft Packet FIFO Transmit Control
- *
- * Soft Packet FIFO Transmit Control
- *
- * Notes:
- * This register is used to configure and control the transmission of packets using the soft packet
- *  FIFO.
- *
- * Clk_Rst:        SRIOMAINT_IR_SP_TX_CTRL hclk    hrst_n
+ * This register is used to configure and control the transmission of packets using the soft
+ * packet FIFO.
  */
 union cvmx_sriomaintx_ir_sp_tx_ctrl {
 	uint32_t u32;
@@ -2841,8 +4172,8 @@ union cvmx_sriomaintx_ir_sp_tx_ctrl {
 	uint32_t octets                       : 16; /**< Writing a non-zero value (N) to this field arms
                                                          the packet FIFO for packet transmission. The FIFO
                                                          control logic will transmit the next N bytes
-                                                         written 4-bytes at a time to the
-                                                         SRIOMAINT(0,2..3)_IR_SP_TX_DATA Register and create a
+                                                         written 4-bytes at a time to
+                                                         SRIOMAINT()_IR_SP_TX_DATA and create a
                                                          single RapidIO packet. */
 	uint32_t reserved_0_15                : 16;
 #else
@@ -2853,25 +4184,19 @@ union cvmx_sriomaintx_ir_sp_tx_ctrl {
 	struct cvmx_sriomaintx_ir_sp_tx_ctrl_s cn63xx;
 	struct cvmx_sriomaintx_ir_sp_tx_ctrl_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_tx_ctrl_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_tx_ctrl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_tx_ctrl cvmx_sriomaintx_ir_sp_tx_ctrl_t;
-
-/**
- * cvmx_sriomaint#_ir_sp_tx_data
- *
- * SRIOMAINT_IR_SP_TX_DATA = SRIO Soft Packet FIFO Transmit Data
- *
- * Soft Packet FIFO Transmit Data
- *
- * Notes:
- * This register is used to write data to the soft packet FIFO.  The format of the packet follows the
- * Internal Packet Format (add link here).  Care must be taken on creating TIDs for the packets which
- * generate a response.  Bits [7:6] of the 8 bit TID must be set for all Soft Packet FIFO generated
- * packets.  TID values of 0x00 - 0xBF are reserved for hardware generated Tags.  The remainer of the
- * TID[5:0] must be unique for each packet in flight and cannot be reused until a response is received
- * in the SRIOMAINT(0,2..3)_IR_SP_RX_DATA register.
+
+/**
+ * cvmx_sriomaint#_ir_sp_tx_data
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_TX_DATA hclk    hrst_n
+ * This register is used to write data to the soft packet FIFO.  The format of the packet
+ * follows the internal packet format (add link here).  Care must be taken on creating TIDs
+ * for the packets which generate a response.  Bits [7:6] of the 8 bit TID must be set for
+ * all Soft Packet FIFO generated packets.  TID values of 0x00 0xBF are reserved for hardware
+ * generated Tags.  The remainer of the TID[5:0] must be unique for each packet in flight and
+ * cannot be reused until a response is received in the SRIOMAINT()_IR_SP_RX_DATA register.
  */
 union cvmx_sriomaintx_ir_sp_tx_data {
 	uint32_t u32;
@@ -2886,20 +4211,15 @@ union cvmx_sriomaintx_ir_sp_tx_data {
 	struct cvmx_sriomaintx_ir_sp_tx_data_s cn63xx;
 	struct cvmx_sriomaintx_ir_sp_tx_data_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_tx_data_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_tx_data_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_tx_data cvmx_sriomaintx_ir_sp_tx_data_t;
 
 /**
  * cvmx_sriomaint#_ir_sp_tx_stat
  *
- * SRIOMAINT_IR_SP_TX_STAT = SRIO Soft Packet FIFO Transmit Status
- *
- * Soft Packet FIFO Transmit Status
- *
- * Notes:
  * This register is used to monitor the transmission of packets using the soft packet FIFO.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_TX_STAT hclk    hrst_n
  */
 union cvmx_sriomaintx_ir_sp_tx_stat {
 	uint32_t u32;
@@ -2911,16 +4231,16 @@ union cvmx_sriomaintx_ir_sp_tx_stat {
                                                          stored in the Tx FIFO.  The field always reads
                                                          zero in the current hardware. */
 	uint32_t reserved_5_11                : 7;
-	uint32_t full                         : 1;  /**< This bit is set when the value of Buffers Filled
+	uint32_t full                         : 1;  /**< This bit is set when the value of buffers filled
                                                          equals the number of available transmission
                                                          buffers. */
 	uint32_t fifo_st                      : 4;  /**< These bits display the state of the state machine
                                                          that controls loading of packet data into the TX
                                                          FIFO. The enumeration of states are as follows:
-                                                           0000 - Idle
-                                                           0001 - Armed
-                                                           0010 - Active
-                                                           All other states are reserved. */
+                                                         0x0 = Idle.
+                                                         0x1 = Armed.
+                                                         0x2 = Active.
+                                                         _ All other states are reserved. */
 #else
 	uint32_t fifo_st                      : 4;
 	uint32_t full                         : 1;
@@ -2932,20 +4252,15 @@ union cvmx_sriomaintx_ir_sp_tx_stat {
 	struct cvmx_sriomaintx_ir_sp_tx_stat_s cn63xx;
 	struct cvmx_sriomaintx_ir_sp_tx_stat_s cn63xxp1;
 	struct cvmx_sriomaintx_ir_sp_tx_stat_s cn66xx;
+	struct cvmx_sriomaintx_ir_sp_tx_stat_s cn75xx;
 };
 typedef union cvmx_sriomaintx_ir_sp_tx_stat cvmx_sriomaintx_ir_sp_tx_stat_t;
 
 /**
  * cvmx_sriomaint#_lane_#_status_0
  *
- * SRIOMAINT_LANE_X_STATUS_0 = SRIO Lane X Status 0
- *
- * SRIO Lane Status 0
- *
- * Notes:
  * This register contains status information about the local lane transceiver.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_LANE_[0:3]_STATUS_0   hclk    hrst_n
  */
 union cvmx_sriomaintx_lane_x_status_0 {
 	uint32_t u32;
@@ -2954,41 +4269,41 @@ union cvmx_sriomaintx_lane_x_status_0 {
 	uint32_t port                         : 8;  /**< The number of the port within the device to which
                                                          the lane is assigned. */
 	uint32_t lane                         : 4;  /**< Lane Number within the port. */
-	uint32_t tx_type                      : 1;  /**< Transmitter Type
-                                                         0 = Short Run
-                                                         1 = Long Run */
-	uint32_t tx_mode                      : 1;  /**< Transmitter Operating Mode
-                                                         0 = Short Run
-                                                         1 = Long Run */
-	uint32_t rx_type                      : 2;  /**< Receiver Type
-                                                         0 = Short Run
-                                                         1 = Medium Run
-                                                         2 = Long Run
-                                                         3 = Reserved */
-	uint32_t rx_inv                       : 1;  /**< Receiver Input Inverted
-                                                         0 = No Inversion
-                                                         1 = Input Inverted */
-	uint32_t rx_adapt                     : 1;  /**< Receiver Trained
+	uint32_t tx_type                      : 1;  /**< Transmitter type:
+                                                         0 = Short run.
+                                                         1 = Long run. */
+	uint32_t tx_mode                      : 1;  /**< Transmitter operating mode:
+                                                         0 = Short run.
+                                                         1 = Long run. */
+	uint32_t rx_type                      : 2;  /**< Receiver type:
+                                                         0x0 = Short run.
+                                                         0x1 = Medium run.
+                                                         0x2 = Long run.
+                                                         0x3 = Reserved. */
+	uint32_t rx_inv                       : 1;  /**< Receiver input inverted:
+                                                         0 = No inversion.
+                                                         1 = Input inverted. */
+	uint32_t rx_adapt                     : 1;  /**< Receiver trained:
                                                          0 = One or more adaptive equalizers are
-                                                             controlled by the lane receiver and at least
-                                                             one is not trained.
+                                                         controlled by the lane receiver and at least
+                                                         one is not trained.
                                                          1 = The lane receiver controls no adaptive
-                                                             equalizers or all the equalizers are trained. */
-	uint32_t rx_sync                      : 1;  /**< Receiver Lane Sync'd */
-	uint32_t rx_train                     : 1;  /**< Receiver Lane Trained */
-	uint32_t dec_err                      : 4;  /**< 8Bit/10Bit Decoding Errors
-                                                         0    = No Errors since last read
-                                                         1-14 = Number of Errors since last read
-                                                         15   = Fifteen or more Errors since last read */
-	uint32_t xsync                        : 1;  /**< Receiver Lane Sync Change
-                                                         0 = Lane Sync has not changed since last read
-                                                         1 = Lane Sync has changed since last read */
-	uint32_t xtrain                       : 1;  /**< Receiver Training Change
-                                                         0 = Training has not changed since last read
-                                                         1 = Training has changed since last read */
+                                                         equalizers or all the equalizers are trained. */
+	uint32_t rx_sync                      : 1;  /**< Receiver lane synced. */
+	uint32_t rx_train                     : 1;  /**< Receiver lane trained. */
+	uint32_t dec_err                      : 4;  /**< 8Bit/10Bit decoding errors.
+                                                         0    = No Errors since last read.
+                                                         1-14 = Number of Errors since last read.
+                                                         15   = Fifteen or more Errors since last read. */
+	uint32_t xsync                        : 1;  /**< Receiver lane sync change.
+                                                         0 = Lane Sync has not changed since last read.
+                                                         1 = Lane Sync has changed since last read. */
+	uint32_t xtrain                       : 1;  /**< Receiver training change.
+                                                         0 = Training has not changed since last read.
+                                                         1 = Training has changed since last read. */
 	uint32_t reserved_4_5                 : 2;
-	uint32_t status1                      : 1;  /**< Status 1 CSR Implemented */
-	uint32_t statusn                      : 3;  /**< Status 2-7 Not Implemented */
+	uint32_t status1                      : 1;  /**< Status 1 CSR implemented. */
+	uint32_t statusn                      : 3;  /**< Status 2-7 not implemented. */
 #else
 	uint32_t statusn                      : 3;
 	uint32_t status1                      : 1;
@@ -3010,33 +4325,29 @@ union cvmx_sriomaintx_lane_x_status_0 {
 	struct cvmx_sriomaintx_lane_x_status_0_s cn63xx;
 	struct cvmx_sriomaintx_lane_x_status_0_s cn63xxp1;
 	struct cvmx_sriomaintx_lane_x_status_0_s cn66xx;
+	struct cvmx_sriomaintx_lane_x_status_0_s cn75xx;
 };
 typedef union cvmx_sriomaintx_lane_x_status_0 cvmx_sriomaintx_lane_x_status_0_t;
 
 /**
  * cvmx_sriomaint#_lcs_ba0
  *
- * SRIOMAINT_LCS_BA0 = SRIO Local Configuration Space MSB Base Address
- *
  * MSBs of SRIO Address Space mapped to Maintenance BAR.
- *
- * Notes:
- * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window has
- *  the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows.  Note:  Address bits
- *  not supplied in the transfer are considered zero.  For example, SRIO Address 65:35 must be set to
- *  zero to match in a 34-bit access.  SRIO Address 65:50 must be set to zero to match in a 50-bit
- *  access.  This coding allows the Maintenance Bar window to appear in specific address spaces. The
- *  remaining bits are located in SRIOMAINT(0,2..3)_LCS_BA1. This SRIO maintenance BAR is effectively
- *  disabled when LCSBA[30] is set with 34 or 50-bit addressing.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_LCS_BA0       hclk    hrst_n
+ * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window
+ * has the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows.
+ * Note:  Address bits not supplied in the transfer are considered zero.  For example, SRIO
+ * Address 65:35 must be set to zero to match in a 34-bit access.  SRIO Address 65:50 must be
+ * set to zero to match in a 50-bit access.  This coding allows the Maintenance Bar window to
+ * appear in specific address spaces. The remaining bits are located in SRIOMAINT()_LCS_BA1.
+ * This SRIO maintenance BAR is effectively disabled when LCSBA[30] is set with 34 or 50-bit
+ * addressing.
  */
 union cvmx_sriomaintx_lcs_ba0 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_lcs_ba0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t lcsba                        : 31; /**< SRIO Address 65:35 */
+	uint32_t lcsba                        : 31; /**< SRIO address 65:35. */
 #else
 	uint32_t lcsba                        : 31;
 	uint32_t reserved_31_31               : 1;
@@ -3045,33 +4356,29 @@ union cvmx_sriomaintx_lcs_ba0 {
 	struct cvmx_sriomaintx_lcs_ba0_s      cn63xx;
 	struct cvmx_sriomaintx_lcs_ba0_s      cn63xxp1;
 	struct cvmx_sriomaintx_lcs_ba0_s      cn66xx;
+	struct cvmx_sriomaintx_lcs_ba0_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_lcs_ba0 cvmx_sriomaintx_lcs_ba0_t;
 
 /**
  * cvmx_sriomaint#_lcs_ba1
  *
- * SRIOMAINT_LCS_BA1 = SRIO Local Configuration Space LSB Base Address
- *
  * LSBs of SRIO Address Space mapped to Maintenance BAR.
- *
- * Notes:
- * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window has
- *  the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows. Address bits not
- *  supplied in the transfer are considered zero.  For example, SRIO Address 65:35 must be set to zero
- *  to match in a 34-bit access and SRIO Address 65:50 must be set to zero to match in a 50-bit access.
- *  This coding allows the Maintenance Bar window to appear in specific address spaces. Accesses
- *  through this BAR are limited to single word (32-bit) aligned transfers of one to four bytes.
- *  Accesses which violate this rule will return an error response if possible and be otherwise
- *  ignored.  The remaining bits are located in SRIOMAINT(0,2..3)_LCS_BA0.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_LCS_BA1       hclk    hrst_n
+ * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window
+ * has the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows. Address
+ * bits not supplied in the transfer are considered zero.  For example, SRIO Address 65:35 must
+ * be set to zero to match in a 34-bit access and SRIO Address 65:50 must be set to zero to match
+ * in a 50-bit access. This coding allows the Maintenance Bar window to appear in specific
+ * address
+ * spaces. Accesses through this BAR are limited to single word (32-bit) aligned transfers of one
+ * to four bytes. Accesses which violate this rule will return an error response if possible and
+ * be otherwise ignored.  The remaining bits are located in SRIOMAINT()_LCS_BA0.
  */
 union cvmx_sriomaintx_lcs_ba1 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_lcs_ba1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t lcsba                        : 11; /**< SRIO Address 34:24 */
+	uint32_t lcsba                        : 11; /**< SRIO address 34:24. */
 	uint32_t reserved_0_20                : 21;
 #else
 	uint32_t reserved_0_20                : 21;
@@ -3081,29 +4388,32 @@ union cvmx_sriomaintx_lcs_ba1 {
 	struct cvmx_sriomaintx_lcs_ba1_s      cn63xx;
 	struct cvmx_sriomaintx_lcs_ba1_s      cn63xxp1;
 	struct cvmx_sriomaintx_lcs_ba1_s      cn66xx;
+	struct cvmx_sriomaintx_lcs_ba1_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t lcsba                        : 11; /**< SRIO address 34:24. */
+	uint32_t reserved_20_0                : 21;
+#else
+	uint32_t reserved_20_0                : 21;
+	uint32_t lcsba                        : 11;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriomaintx_lcs_ba1 cvmx_sriomaintx_lcs_ba1_t;
 
 /**
  * cvmx_sriomaint#_m2s_bar0_start0
  *
- * SRIOMAINT_M2S_BAR0_START0 = SRIO Device Access BAR0 MSB Start
- *
  * The starting SRIO address to forwarded to the NPEI Configuration Space.
- *
- * Notes:
  * This register specifies the 50-bit and 66-bit SRIO Address mapped to the BAR0 Space.  See
- *  SRIOMAINT(0,2..3)_M2S_BAR0_START1 for more details. This register is only writeable over SRIO if the
- *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR0 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR0_START0       hclk    hrst_n
+ * SRIOMAINT()_M2S_BAR0_START1 for more details. This register is only writeable over SRIO if
+ * the SRIO()_ACC_CTRL[DENY_BAR0] bit is zero.
  */
 union cvmx_sriomaintx_m2s_bar0_start0 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar0_start0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t addr64                       : 16; /**< SRIO Address 63:48 */
-	uint32_t addr48                       : 16; /**< SRIO Address 47:32 */
+	uint32_t addr64                       : 16; /**< SRIO address 63:48. */
+	uint32_t addr48                       : 16; /**< SRIO address 47:32. */
 #else
 	uint32_t addr48                       : 16;
 	uint32_t addr64                       : 16;
@@ -3112,40 +4422,37 @@ union cvmx_sriomaintx_m2s_bar0_start0 {
 	struct cvmx_sriomaintx_m2s_bar0_start0_s cn63xx;
 	struct cvmx_sriomaintx_m2s_bar0_start0_s cn63xxp1;
 	struct cvmx_sriomaintx_m2s_bar0_start0_s cn66xx;
+	struct cvmx_sriomaintx_m2s_bar0_start0_s cn75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar0_start0 cvmx_sriomaintx_m2s_bar0_start0_t;
 
 /**
  * cvmx_sriomaint#_m2s_bar0_start1
  *
- * SRIOMAINT_M2S_BAR0_START1 = SRIO Device Access BAR0 LSB Start
- *
  * The starting SRIO address to forwarded to the NPEI Configuration Space.
- *
- * Notes:
- * This register specifies the SRIO Address mapped to the BAR0 RSL Space.  If the transaction has not
- *  already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0] registers, if
- *  ENABLE is set and the address bits match then the SRIO Memory transactions will map to Octeon SLI
- *  Registers.  34-bit address transactions require a match in SRIO Address 33:14 and require all the
- *  other bits in ADDR48, ADDR64 and ADDR66 fields to be zero.  50-bit address transactions a match of
- *  SRIO Address 49:14 and require all the other bits of ADDR64 and ADDR66 to be zero.  66-bit address
- *  transactions require matches of all valid address field bits.  Reads and  Writes through Bar0
- *  have a size limit of 8 bytes and cannot cross a 64-bit boundry.  All accesses with sizes greater
- *  than this limit will be ignored and return an error on any SRIO responses.  Note: ADDR48 and
- *  ADDR64 fields are located in SRIOMAINT(0,2..3)_M2S_BAR0_START0.  The ADDR32/66 fields of this register
- *  are writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_ADR0 bit is zero.  The ENABLE field is
- *  writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_BAR0 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR0_START1       hclk    hrst_n
+ * This register specifies the SRIO Address mapped to the BAR0 RSL Space.  If the transaction
+ * has not already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0]
+ * registers, if ENABLE is set and the address bits match then the SRIO Memory transactions
+ * will map to Octeon SLI Registers.  34-bit address transactions require a match in SRIO
+ * Address 33:14 and require all the other bits in ADDR48, ADDR64 and ADDR66 fields to be zero.
+ * 50-bit address transactions a match of SRIO Address 49:14 and require all the other bits of
+ * ADDR64 and ADDR66 to be zero.  66-bit address transactions require matches of all valid
+ * address
+ * field bits.  Reads and  Writes through Bar0 have a size limit of 8 bytes and cannot cross
+ * a 64-bit boundry.  All accesses with sizes greater than this limit will be ignored and return
+ * an error on any SRIO responses.  Note: ADDR48 and ADDR64 fields are located in
+ * SRIOMAINT()_M2S_BAR0_START0.  The ADDR32/66 fields of this register
+ * are writeable over SRIO if the SRIO()_ACC_CTRL[DENY_ADR0] bit is zero.  The ENABLE field is
+ * writeable over SRIO if the SRIO()_ACC_CTRL[DENY_BAR0] bit is zero.
  */
 union cvmx_sriomaintx_m2s_bar0_start1 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar0_start1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t addr32                       : 18; /**< SRIO Address 31:14 */
+	uint32_t addr32                       : 18; /**< SRIO address 31:14. */
 	uint32_t reserved_3_13                : 11;
-	uint32_t addr66                       : 2;  /**< SRIO Address 65:64 */
-	uint32_t enable                       : 1;  /**< Enable BAR0 Access */
+	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
+	uint32_t enable                       : 1;  /**< Enable BAR0 access. */
 #else
 	uint32_t enable                       : 1;
 	uint32_t addr66                       : 2;
@@ -3156,33 +4463,28 @@ union cvmx_sriomaintx_m2s_bar0_start1 {
 	struct cvmx_sriomaintx_m2s_bar0_start1_s cn63xx;
 	struct cvmx_sriomaintx_m2s_bar0_start1_s cn63xxp1;
 	struct cvmx_sriomaintx_m2s_bar0_start1_s cn66xx;
+	struct cvmx_sriomaintx_m2s_bar0_start1_s cn75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar0_start1 cvmx_sriomaintx_m2s_bar0_start1_t;
 
 /**
  * cvmx_sriomaint#_m2s_bar1_start0
  *
- * SRIOMAINT_M2S_BAR1_START0 = SRIO Device Access BAR1 MSB Start
- *
  * The starting SRIO address to forwarded to the BAR1 Memory Space.
- *
- * Notes:
  * This register specifies the 50-bit and 66-bit SRIO Address mapped to the BAR1 Space.  See
- *  SRIOMAINT(0,2..3)_M2S_BAR1_START1 for more details.  This register is only writeable over SRIO if the
- *  SRIO(0,2..3)_ACC_CTRL.DENY_ADR1 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR1_START0       hclk    hrst_n
+ * SRIOMAINT()_M2S_BAR1_START1 for more details.  This register is only writeable over SRIO
+ * if the SRIO()_ACC_CTRL[DENY_ADR1] bit is zero.
  */
 union cvmx_sriomaintx_m2s_bar1_start0 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar1_start0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t addr64                       : 16; /**< SRIO Address 63:48 */
-	uint32_t addr48                       : 16; /**< SRIO Address 47:32
+	uint32_t addr64                       : 16; /**< SRIO address 63:48. */
+	uint32_t addr48                       : 16; /**< SRIO address 47:32.
                                                          The SRIO hardware does not use the low order
                                                          one or two bits of this field when BARSIZE is 12
                                                          or 13, respectively.
-                                                         (BARSIZE is SRIOMAINT(0,2..3)_M2S_BAR1_START1[BARSIZE].) */
+                                                         (BARSIZE is SRIOMAINT()_M2S_BAR1_START1[BARSIZE].) */
 #else
 	uint32_t addr48                       : 16;
 	uint32_t addr64                       : 16;
@@ -3191,38 +4493,41 @@ union cvmx_sriomaintx_m2s_bar1_start0 {
 	struct cvmx_sriomaintx_m2s_bar1_start0_s cn63xx;
 	struct cvmx_sriomaintx_m2s_bar1_start0_s cn63xxp1;
 	struct cvmx_sriomaintx_m2s_bar1_start0_s cn66xx;
+	struct cvmx_sriomaintx_m2s_bar1_start0_s cn75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar1_start0 cvmx_sriomaintx_m2s_bar1_start0_t;
 
 /**
  * cvmx_sriomaint#_m2s_bar1_start1
  *
- * SRIOMAINT_M2S_BAR1_START1 = SRIO Device to BAR1 Start
- *
  * The starting SRIO address to forwarded to the BAR1 Memory Space.
- *
- * Notes:
- * This register specifies the SRIO Address mapped to the BAR1 Space.  If the transaction has not
- *  already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0] registers and the
- *  address bits do not match enabled BAR0 addresses and if ENABLE is set and the addresses match the
- *  BAR1 addresses then SRIO Memory transactions will map to Octeon Memory Space specified by
- *  SRIOMAINT(0,2..3)_BAR1_IDX[31:0] registers.  The BARSIZE field determines the size of BAR1, the entry
- *  select bits, and the size of each entry. A 34-bit address matches BAR1 when it matches
- *  SRIO_Address[33:20+BARSIZE] while all the other bits in ADDR48, ADDR64 and ADDR66 are zero.
- *  A 50-bit address matches BAR1 when it matches SRIO_Address[49:20+BARSIZE] while all the
- *  other bits of ADDR64 and ADDR66 are zero.  A 66-bit address matches BAR1 when all of
- *  SRIO_Address[65:20+BARSIZE] match all corresponding address CSR field bits.  Note: ADDR48 and
- *  ADDR64 fields are located in SRIOMAINT(0,2..3)_M2S_BAR1_START0. The ADDR32/66 fields of this register
- *  are writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_ADR1 bit is zero.  The remaining fields are
- *  writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_BAR1 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR1_START1       hclk    hrst_n
+ * This register specifies the SRIO Address mapped to the BAR1 Space.  If the
+ * transaction has not already been mapped to SRIO Maintenance Space through the
+ * SRIOMAINT_LCS_BA[1:0] registers and the address bits do not match enabled BAR0
+ * addresses and if ENABLE is set and the addresses match the BAR1 addresses then
+ * SRIO Memory transactions will map to Octeon Memory Space specified by
+ * SRIOMAINT()_BAR1_IDX[31:0] registers.  The BARSIZE field determines the size of
+ * BAR1, the entry select bits, and the size of each entry.
+ *
+ * * A 34-bit address matches BAR1 when it matches SRIO_Address[33:20+BARSIZE] while
+ * all the other bits in ADDR48, ADDR64 and ADDR66 are zero.
+ *
+ * * A 50-bit address matches BAR1 when it matches SRIO_Address[49:20+BARSIZE] while
+ * all the other bits of ADDR64 and ADDR66 are zero.
+ *
+ * * A 66-bit address matches BAR1 when all of SRIO_Address[65:20+BARSIZE] match all
+ * corresponding address CSR field bits.
+ *
+ * Note: ADDR48 and
+ * ADDR64 fields are located in SRIOMAINT()_M2S_BAR1_START0. The ADDR32/66 fields of
+ * this register are writeable over SRIO if SRIO()_ACC_CTRL[DENY_ADR1] is zero.
+ * The remaining fields are writeable over SRIO if SRIO()_ACC_CTRL[DENY_BAR1] is zero.
  */
 union cvmx_sriomaintx_m2s_bar1_start1 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar1_start1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t addr32                       : 12; /**< SRIO Address 31:20
+	uint32_t addr32                       : 12; /**< SRIO address 31:20.
                                                          This field is not used by the SRIO hardware for
                                                          BARSIZE values 12 or 13.
                                                          With BARSIZE < 12, the upper 12-BARSIZE
@@ -3230,32 +4535,30 @@ union cvmx_sriomaintx_m2s_bar1_start1 {
                                                          bits of this field are unused by the SRIO hardware. */
 	uint32_t reserved_7_19                : 13;
 	uint32_t barsize                      : 4;  /**< Bar Size.
-                                                                              SRIO_Address*
-                                                                         ---------------------
-                                                                        /                     \
+                                                         <pre>
+                                                                           SRIO_Address*
+                                                                            ---------------------
+                                                                           /                     \
                                                          BARSIZE         BAR     Entry   Entry    Entry
                                                          Value   BAR    compare  Select  Offset   Size
-                                                                 Size    bits    bits    bits
-                                                          0       1MB    65:20   19:16   15:0     64KB
-                                                          1       2MB    65:21   20:17   16:0    128KB
-                                                          2       4MB    65:22   21:18   17:0    256KB
-                                                          3       8MB    65:23   22:19   18:0    512KB
-                                                          4      16MB    65:24   23:20   19:0      1MB
-                                                          5      32MB    65:25   24:21   20:0      2MB
-                                                          6      64MB    65:26   25:22   21:0      4MB
-                                                          7     128MB    65:27   26:23   22:0      8MB
-                                                          8     256MB    65:28   27:24   23:0     16MB
-                                                          9     512MB    65:29   28:25   24:0     32MB
-                                                         10    1024MB    65:30   29:26   25:0     64MB
-                                                         11    2048MB    65:31   30:27   26:0    128MB
-                                                         12    4096MB    65:32   31:28   27:0    256MB
-                                                         13    8192MB    65:33   32:29   28:0    512MB
-
-                                                         *The SRIO Transaction Address
-                                                         The entry select bits is the X that  select an
-                                                         SRIOMAINT(0,2..3)_BAR1_IDXX entry. */
-	uint32_t addr66                       : 2;  /**< SRIO Address 65:64 */
-	uint32_t enable                       : 1;  /**< Enable BAR1 Access */
+                                                         Size    bits    bits    bits
+                                                         0       1MB    65:20   19:16   15:0     64KB
+                                                         1       2MB    65:21   20:17   16:0    128KB
+                                                         2       4MB    65:22   21:18   17:0    256KB
+                                                         3       8MB    65:23   22:19   18:0    512KB
+                                                         4      16MB    65:24   23:20   19:0      1MB
+                                                         5      32MB    65:25   24:21   20:0      2MB
+                                                         6      64MB    65:26   25:22   21:0      4MB
+                                                         7     128MB    65:27   26:23   22:0      8MB
+                                                         8     256MB    65:28   27:24   23:0     16MB
+                                                         9     512MB    65:29   28:25   24:0     32MB
+                                                         10    1024MB   65:30   29:26   25:0     64MB
+                                                         11    2048MB   65:31   30:27   26:0    128MB
+                                                         12    4096MB   65:32   31:28   27:0    256MB
+                                                         13    8192MB   65:33   32:29   28:0    512MB
+                                                         </pre> */
+	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
+	uint32_t enable                       : 1;  /**< Enable BAR1 access. */
 #else
 	uint32_t enable                       : 1;
 	uint32_t addr66                       : 2;
@@ -3313,33 +4616,55 @@ union cvmx_sriomaintx_m2s_bar1_start1 {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriomaintx_m2s_bar1_start1_s cn66xx;
+	struct cvmx_sriomaintx_m2s_bar1_start1_s cn75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar1_start1 cvmx_sriomaintx_m2s_bar1_start1_t;
 
 /**
  * cvmx_sriomaint#_m2s_bar2_start
  *
- * SRIOMAINT_M2S_BAR2_START = SRIO Device to BAR2 Start
- *
  * The starting SRIO address to forwarded to the BAR2 Memory Space.
- *
- * Notes:
- * This register specifies the SRIO Address mapped to the BAR2 Space.  If ENABLE is set and the
- *  address bits do not match and other enabled BAR address and match the BAR2 addresses then the SRIO
- *  Memory transactions will map to Octeon BAR2 Memory Space.  34-bit address transactions require
- *  ADDR66, ADDR64 and ADDR48 fields set to zero and supplies zeros for unused addresses 40:34.
- *  50-bit address transactions a match of SRIO Address 49:41 and require all the other bits of ADDR64
- *  and ADDR66 to be zero.  66-bit address transactions require matches of all valid address field
- *  bits.  The ADDR32/48/64/66 fields of this register are writeable over SRIO if the
- *  SRIO(0,2..3)_ACC_CTRL.DENY_ADR2 bit is zero.  The remaining fields are writeable over SRIO if the
- *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR2 bit is zero.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR2_START        hclk    hrst_n
+ * This register specifies the SRIO Address mapped to the BAR2 Space.  If ENABLE is set
+ * and the address bits do not match the other enabled BAR address and match the BAR2
+ * addresses then the SRIO Memory transactions will map to Octeon BAR2 Memory Space.
+ * 34-bit address transactions require ADDR66, ADDR64 and ADDR48 fields set to zero
+ * and supply zeros for unused local addresses 41:34.  50-bit address transactions a
+ * match of SRIO Address 49:42 and require all the other bits of ADDR64 and ADDR66 to
+ * be zero.  66-bit address transactions require matches of all valid address field
+ * bits.  The ADDR32/48/64/66 fields of this register are writeable over SRIO if
+ * SRIO()_ACC_CTRL[DENY_ADR2] is zero.  The remaining fields are writeable over SRIO
+ * if SRIO()_ACC_CTRL[DENY_BAR2] is zero.
  */
 union cvmx_sriomaintx_m2s_bar2_start {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar2_start_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t addr64                       : 16; /**< SRIO address 63:48. */
+	uint32_t reserved_6_15                : 10;
+	uint32_t esx                          : 2;  /**< Endian swap mode used for SRIO 34-bit access.
+                                                         For 50/66-bit assesses Endian Swap is determine
+                                                         by ESX XOR'd with SRIO address 43:42.
+                                                         0x0 = No swap.
+                                                         0x1 = 64-bit swap bytes [ABCD_EFGH] -> [HGFE_DCBA].
+                                                         0x2 = 32-bit swap words [ABCD_EFGH] -> [DCBA_HGFE].
+                                                         0x3 = 32-bit word exch  [ABCD_EFGH] -> [EFGH_ABCD]. */
+	uint32_t cax                          : 1;  /**< Cacheable Access Mode.  When set transfer is
+                                                         cached.  This bit is used for SRIO 34-bit access.
+                                                         For 50/66-bit accessas NCA is determine by CAX
+                                                         XOR'd with SRIO address 44. */
+	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
+	uint32_t enable                       : 1;  /**< Enable BAR2 access. */
+#else
+	uint32_t enable                       : 1;
+	uint32_t addr66                       : 2;
+	uint32_t cax                          : 1;
+	uint32_t esx                          : 2;
+	uint32_t reserved_6_15                : 10;
+	uint32_t addr64                       : 16;
+#endif
+	} s;
+	struct cvmx_sriomaintx_m2s_bar2_start_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t addr64                       : 16; /**< SRIO Address 63:48 */
 	uint32_t addr48                       : 7;  /**< SRIO Address 47:41 */
 	uint32_t reserved_6_8                 : 3;
@@ -3365,49 +4690,68 @@ union cvmx_sriomaintx_m2s_bar2_start {
 	uint32_t addr48                       : 7;
 	uint32_t addr64                       : 16;
 #endif
-	} s;
-	struct cvmx_sriomaintx_m2s_bar2_start_s cn63xx;
-	struct cvmx_sriomaintx_m2s_bar2_start_s cn63xxp1;
-	struct cvmx_sriomaintx_m2s_bar2_start_s cn66xx;
+	} cn63xx;
+	struct cvmx_sriomaintx_m2s_bar2_start_cn63xx cn63xxp1;
+	struct cvmx_sriomaintx_m2s_bar2_start_cn63xx cn66xx;
+	struct cvmx_sriomaintx_m2s_bar2_start_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t addr64                       : 16; /**< SRIO address 63:48. */
+	uint32_t addr48                       : 3;  /**< SRIO address 47:45. */
+	uint32_t reserved_6_12                : 7;
+	uint32_t esx                          : 2;  /**< Endian swap mode used for SRIO 34-bit access.
+                                                         For 50/66-bit assesses Endian Swap is determine
+                                                         by ESX XOR'd with SRIO address 43:42.
+                                                         0x0 = No swap.
+                                                         0x1 = 64-bit swap bytes [ABCD_EFGH] -> [HGFE_DCBA].
+                                                         0x2 = 32-bit swap words [ABCD_EFGH] -> [DCBA_HGFE].
+                                                         0x3 = 32-bit word exch  [ABCD_EFGH] -> [EFGH_ABCD]. */
+	uint32_t cax                          : 1;  /**< Cacheable Access Mode.  When set transfer is
+                                                         cached.  This bit is used for SRIO 34-bit access.
+                                                         For 50/66-bit accessas NCA is determine by CAX
+                                                         XOR'd with SRIO address 44. */
+	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
+	uint32_t enable                       : 1;  /**< Enable BAR2 access. */
+#else
+	uint32_t enable                       : 1;
+	uint32_t addr66                       : 2;
+	uint32_t cax                          : 1;
+	uint32_t esx                          : 2;
+	uint32_t reserved_6_12                : 7;
+	uint32_t addr48                       : 3;
+	uint32_t addr64                       : 16;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar2_start cvmx_sriomaintx_m2s_bar2_start_t;
 
 /**
  * cvmx_sriomaint#_mac_ctrl
  *
- * SRIOMAINT_MAC_CTRL = SRIO MAC Control
- *
- * Control for MAC Features
- *
- * Notes:
  * This register enables MAC optimizations that may not be supported by all SRIO devices.  The
- *  default values should be supported.  This register can be changed at any time while the MAC is
- *  out of reset.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_MAC_CTRL      hclk    hrst_n
+ * default values should be supported.  This register can be changed at any time while the MAC is
+ * out of reset.
  */
 union cvmx_sriomaintx_mac_ctrl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_mac_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_21_31               : 11;
-	uint32_t sec_spf                      : 1;  /**< Send all Incoming Packets matching Secondary ID to
-                                                         RX Soft Packet FIFO.  This bit is ignored if
+	uint32_t sec_spf                      : 1;  /**< Send all incoming packets matching secondary ID to
+                                                         RX soft packet FIFO.  This bit is ignored if
                                                          RX_SPF is set. */
-	uint32_t ack_zero                     : 1;  /**< Generate ACKs for all incoming Zero Byte packets.
+	uint32_t ack_zero                     : 1;  /**< Generate ACKs for all incoming zero byte packets.
                                                          Default behavior is to issue a NACK.  Regardless
-                                                         of this setting the SRIO(0,2..3)_INT_REG.ZERO_PKT
-                                                         interrupt is generated.
-                                                         SRIO(0,2..3)_INT_REG. */
-	uint32_t rx_spf                       : 1;  /**< Route all received packets to RX Soft Packet FIFO.
-                                                         No logical layer ERB Errors will be reported.
-                                                         Used for Diagnostics Only. */
-	uint32_t eop_mrg                      : 1;  /**< Transmitted Packets can eliminate EOP Symbol on
+                                                         of this setting the SRIO()_INT_REG[ZERO_PKT]
+                                                         interrupt is generated in SRIO()_INT_REG. */
+	uint32_t rx_spf                       : 1;  /**< Route all received packets to RX soft packet FIFO.
+                                                         No logical layer ERB errors will be reported.
+                                                         For diagnostic use only. */
+	uint32_t eop_mrg                      : 1;  /**< Transmitted packets can eliminate EOP symbol on
                                                          back to back packets. */
-	uint32_t type_mrg                     : 1;  /**< Allow STYPE Merging on Transmit. */
-	uint32_t lnk_rtry                     : 16; /**< Number of times MAC will reissue Link Request
-                                                         after timeout.  If retry count is exceeded Fatal
-                                                         Port Error will occur (see SRIO(0,2..3)_INT_REG.F_ERROR) */
+	uint32_t type_mrg                     : 1;  /**< Allow STYPE merging on transmit. */
+	uint32_t lnk_rtry                     : 16; /**< Number of times MAC will reissue link request
+                                                         after timeout.  If retry count is exceeded a fatal
+                                                         port error will occur (see SRIO()_INT_REG[F_ERROR]). */
 #else
 	uint32_t lnk_rtry                     : 16;
 	uint32_t type_mrg                     : 1;
@@ -3445,27 +4789,21 @@ union cvmx_sriomaintx_mac_ctrl {
 #endif
 	} cn63xx;
 	struct cvmx_sriomaintx_mac_ctrl_s     cn66xx;
+	struct cvmx_sriomaintx_mac_ctrl_s     cn75xx;
 };
 typedef union cvmx_sriomaintx_mac_ctrl cvmx_sriomaintx_mac_ctrl_t;
 
 /**
  * cvmx_sriomaint#_pe_feat
  *
- * SRIOMAINT_PE_FEAT = SRIO Processing Element Features
- *
- * The Supported Processing Element Features.
+ * This register describes the major functionality provided by the SRIO device.
  *
- * Notes:
- * The Processing Element Feature register describes the major functionality provided by the SRIO
- *  device.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PE_FEAT       hclk    hrst_n
  */
 union cvmx_sriomaintx_pe_feat {
 	uint32_t u32;
 	struct cvmx_sriomaintx_pe_feat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t bridge                       : 1;  /**< Bridge Functions not supported. */
+	uint32_t bridge                       : 1;  /**< Bridge functions not supported. */
 	uint32_t memory                       : 1;  /**< PE contains addressable memory. */
 	uint32_t proc                         : 1;  /**< PE contains a local processor. */
 	uint32_t switchf                      : 1;  /**< Switch Functions not supported. */
@@ -3474,9 +4812,9 @@ union cvmx_sriomaintx_pe_feat {
 	uint32_t suppress                     : 1;  /**< Error Recovery Suppression not supported. */
 	uint32_t crf                          : 1;  /**< Critical Request Flow not supported. */
 	uint32_t lg_tran                      : 1;  /**< Large Transport (16-bit Device IDs) supported. */
-	uint32_t ex_feat                      : 1;  /**< Extended Feature Pointer is valid. */
+	uint32_t ex_feat                      : 1;  /**< Extended feature pointer is valid. */
 	uint32_t ex_addr                      : 3;  /**< PE supports 66, 50 and 34-bit addresses.
-                                                         [2:1] are a RO copy of SRIO*_IP_FEATURE[A66,A50]. */
+                                                         [2:1] are a RO copy of SRIO()_IP_FEATURE[A66,A50]. */
 #else
 	uint32_t ex_addr                      : 3;
 	uint32_t ex_feat                      : 1;
@@ -3494,20 +4832,15 @@ union cvmx_sriomaintx_pe_feat {
 	struct cvmx_sriomaintx_pe_feat_s      cn63xx;
 	struct cvmx_sriomaintx_pe_feat_s      cn63xxp1;
 	struct cvmx_sriomaintx_pe_feat_s      cn66xx;
+	struct cvmx_sriomaintx_pe_feat_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_pe_feat cvmx_sriomaintx_pe_feat_t;
 
 /**
  * cvmx_sriomaint#_pe_llc
  *
- * SRIOMAINT_PE_LLC = SRIO Processing Element Logical Layer Control
- *
- * Addresses supported by the SRIO Device.
- *
- * Notes:
- * The Processing Element Logical Layer is used for general configuration for the logical interface.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PE_LLC        hclk    hrst_n
+ * The register is used for general configuration for the logical
+ * interface.
  */
 union cvmx_sriomaintx_pe_llc {
 	uint32_t u32;
@@ -3517,10 +4850,10 @@ union cvmx_sriomaintx_pe_llc {
 	uint32_t ex_addr                      : 3;  /**< Controls the number of address bits generated by
                                                          PE as a source and processed by the PE as a
                                                          target of an operation.
-                                                          001 = 34-bit Addresses
-                                                          010 = 50-bit Addresses
-                                                          100 = 66-bit Addresses
-                                                          All other encodings are reserved. */
+                                                         0x1 = 34-bit Addresses
+                                                         0x2 = 50-bit Addresses
+                                                         0x4 = 66-bit Addresses
+                                                         All other encodings are reserved. */
 #else
 	uint32_t ex_addr                      : 3;
 	uint32_t reserved_3_31                : 29;
@@ -3529,32 +4862,105 @@ union cvmx_sriomaintx_pe_llc {
 	struct cvmx_sriomaintx_pe_llc_s       cn63xx;
 	struct cvmx_sriomaintx_pe_llc_s       cn63xxp1;
 	struct cvmx_sriomaintx_pe_llc_s       cn66xx;
+	struct cvmx_sriomaintx_pe_llc_s       cn75xx;
 };
 typedef union cvmx_sriomaintx_pe_llc cvmx_sriomaintx_pe_llc_t;
 
 /**
  * cvmx_sriomaint#_port_0_ctl
  *
- * SRIOMAINT_PORT_0_CTL = SRIO Port 0 Control
- *
- * Port 0 Control
- *
- * Notes:
  * This register contains assorted control bits.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_CTL    hclk    hrst_n
  */
 union cvmx_sriomaintx_port_0_ctl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_0_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t pt_width                     : 2;  /**< Hardware port width:
+                                                         0x0 = One Lane supported.
+                                                         0x1 = One/Four Lanes supported.
+                                                         0x2 = One/Two Lanes supported.
+                                                         0x3 = One/Two/Four Lanes supported.
+                                                         This value is a copy of SRIO()_IP_FEATURE[PT_WIDTH]
+                                                         limited by the number of lanes the MAC has. */
+	uint32_t it_width                     : 3;  /**< Initialized port width:
+                                                         0x0 = Single-lane, lane 0.
+                                                         0x1 = Single-lane, lane 1 or 2.
+                                                         0x2 = Four-lane.
+                                                         0x3 = Two-lane.
+                                                         0x7 = Link uninitialized.
+                                                         Others = Reserved. */
+	uint32_t ov_width                     : 3;  /**< Override Port Width.  Writing this register causes
+                                                         the port to reinitialize.
+                                                         0x0 = No override all lanes possible.
+                                                         0x1 = Reserved
+                                                         0x2 = Force single-lane, lane 0.
+                                                         If Ln 0 is unavailable try lane 2 then lane 1.
+                                                         0x3 = Force single-lane, lane 2
+                                                         If Ln 2 is unavailable try lane 1 then lane 0.
+                                                         0x4 = Reserved
+                                                         0x5 = Enable two-lane, disable four-lane.
+                                                         0x6 = Enable four-lane, disable two-lane.
+                                                         0x7 = All lanes sizes enabled. */
+	uint32_t reserved_23_23               : 1;
+	uint32_t o_enable                     : 1;  /**< Port output enable. When cleared, port will generate control symbols and respond
+                                                         to maintenance transactions only. When set, all transactions are allowed. */
+	uint32_t i_enable                     : 1;  /**< Port input enable. When cleared, port will generate control symbols and respond
+                                                         to maintenance packets only. All other packets will not be accepted. */
+	uint32_t dis_err                      : 1;  /**< Disable error checking.  For diagnostic use only. */
+	uint32_t mcast                        : 1;  /**< Reserved. */
+	uint32_t reserved_18_18               : 1;
+	uint32_t enumb                        : 1;  /**< Enumeration boundry. SW can use this bit to determine port enumeration. */
+	uint32_t reserved_16_16               : 1;
+	uint32_t ex_width                     : 2;  /**< Extended port width not supported. */
+	uint32_t ex_stat                      : 2;  /**< Extended port width status. 0x0 = not supported. */
+	uint32_t suppress                     : 8;  /**< Retransmit suppression mask.  CRF not Supported. */
+	uint32_t stp_port                     : 1;  /**< Stop on failed port. This bit is used with the DROP_PKT bit to force certain
+                                                         behavior when the error rate failed threshold has been met or exceeded. */
+	uint32_t drop_pkt                     : 1;  /**< Drop on failed port. This bit is used with the STP_PORT bit to force certain
+                                                         behavior when the error rate failed threshold has been met or exceeded. */
+	uint32_t prt_lock                     : 1;  /**< When this bit is cleared, the packets that may be
+                                                         received and issued are controlled by the state of
+                                                         the O_ENABLE and I_ENABLE bits.  When this bit is
+                                                         set, this port is stopped and is not enabled to
+                                                         receive any packets; the input port can still
+                                                         follow the training procedure and can still send
+                                                         respond to link-requests; all received packets
+                                                         return packet-not-accepted control symbols to
+                                                         force an error condition to be signaled by the
+                                                         sending device.  The O_ENABLE bit should also be
+                                                         cleared to disable packet output. */
+	uint32_t pt_type                      : 1;  /**< Port type.  1 = Serial port. */
+#else
+	uint32_t pt_type                      : 1;
+	uint32_t prt_lock                     : 1;
+	uint32_t drop_pkt                     : 1;
+	uint32_t stp_port                     : 1;
+	uint32_t suppress                     : 8;
+	uint32_t ex_stat                      : 2;
+	uint32_t ex_width                     : 2;
+	uint32_t reserved_16_16               : 1;
+	uint32_t enumb                        : 1;
+	uint32_t reserved_18_18               : 1;
+	uint32_t mcast                        : 1;
+	uint32_t dis_err                      : 1;
+	uint32_t i_enable                     : 1;
+	uint32_t o_enable                     : 1;
+	uint32_t reserved_23_23               : 1;
+	uint32_t ov_width                     : 3;
+	uint32_t it_width                     : 3;
+	uint32_t pt_width                     : 2;
+#endif
+	} s;
+	struct cvmx_sriomaintx_port_0_ctl_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t pt_width                     : 2;  /**< Hardware Port Width.
                                                          00 = One Lane supported.
                                                          01 = One/Four Lanes supported.
                                                          10 = One/Two Lanes supported.
                                                          11 = One/Two/Four Lanes supported.
-                                                         This value is a copy of SRIO*_IP_FEATURE[PT_WIDTH]
-                                                         limited by the number of lanes the MAC has. */
+                                                         Pass 1 initialized to 0x2 but x1/x4 supported
+                                                         This is a RO copy of SRIO*_IP_FEATURE[PT_WIDTH]. */
 	uint32_t it_width                     : 3;  /**< Initialized Port Width
                                                          000 = Single-lane, Lane 0
                                                          001 = Single-lane, Lane 1 or 2
@@ -3567,16 +4973,17 @@ union cvmx_sriomaintx_port_0_ctl {
                                                          000 = No Override all lanes possible
                                                          001 = Reserved
                                                          010 = Force Single-lane, Lane 0
-                                                               If Ln 0 is unavailable try Ln 2 then Ln 1
                                                          011 = Force Single-lane, Lane 2
-                                                               If Ln 2 is unavailable try Ln 1 then Ln 0
+                                                               (Lane 1 if only lanes 0,1 are connected)
                                                          100 = Reserved
-                                                         101 = Enable Two-lane, Disable Four-Lane
-                                                         110 = Enable Four-lane, Disable Two-Lane
+                                                         101 = Force Two-lane, Disable Four-Lane
+                                                         110 = Force Four-lane, Disable Two-Lane
                                                          111 = All lanes sizes enabled */
 	uint32_t disable                      : 1;  /**< Port Disable.  Setting this bit should disable
-                                                         SERDES drivers and receivers.  On this chip it
-                                                         disables SERDES receivers only. */
+                                                         both SERDES drivers and receivers.
+                                                         On Passes 1.x, 2.0 and 2.1 this bit disables only
+                                                         the receiver side.  On Pass 2.2, this bit is
+                                                         ignored by the hardware. */
 	uint32_t o_enable                     : 1;  /**< Port Output Enable.  When cleared, port will
                                                          generate control symbols and respond to
                                                          maintenance transactions only.  When set, all
@@ -3634,72 +5041,141 @@ union cvmx_sriomaintx_port_0_ctl {
 	uint32_t it_width                     : 3;
 	uint32_t pt_width                     : 2;
 #endif
-	} s;
-	struct cvmx_sriomaintx_port_0_ctl_s   cn63xx;
-	struct cvmx_sriomaintx_port_0_ctl_s   cn63xxp1;
-	struct cvmx_sriomaintx_port_0_ctl_s   cn66xx;
+	} cn63xx;
+	struct cvmx_sriomaintx_port_0_ctl_cn63xx cn63xxp1;
+	struct cvmx_sriomaintx_port_0_ctl_cn63xx cn66xx;
+	struct cvmx_sriomaintx_port_0_ctl_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t pt_width                     : 2;  /**< Hardware port width:
+                                                         0x0 = One Lane supported.
+                                                         0x1 = One/Four Lanes supported.
+                                                         0x2 = One/Two Lanes supported.
+                                                         0x3 = One/Two/Four Lanes supported.
+                                                         This value is a copy of SRIO()_IP_FEATURE[PT_WIDTH]
+                                                         limited by the number of lanes the MAC has. */
+	uint32_t it_width                     : 3;  /**< Initialized port width:
+                                                         0x0 = Single-lane, lane 0.
+                                                         0x1 = Single-lane, lane 1 or 2.
+                                                         0x2 = Four-lane.
+                                                         0x3 = Two-lane.
+                                                         0x7 = Link uninitialized.
+                                                         Others = Reserved. */
+	uint32_t ov_width                     : 3;  /**< Override Port Width.  Writing this register causes
+                                                         the port to reinitialize.
+                                                         0x0 = No override all lanes possible.
+                                                         0x1 = Reserved
+                                                         0x2 = Force single-lane, lane 0.
+                                                         If Ln 0 is unavailable try lane 2 then lane 1.
+                                                         0x3 = Force single-lane, lane 2
+                                                         If Ln 2 is unavailable try lane 1 then lane 0.
+                                                         0x4 = Reserved
+                                                         0x5 = Enable two-lane, disable four-lane.
+                                                         0x6 = Enable four-lane, disable two-lane.
+                                                         0x7 = All lanes sizes enabled. */
+	uint32_t port_disable                 : 1;  /**< Port disable. Setting this bit should disable SERDES drivers and receivers. On
+                                                         this chip it disables SERDES receivers only. */
+	uint32_t o_enable                     : 1;  /**< Port output enable. When cleared, port will generate control symbols and respond
+                                                         to maintenance transactions only. When set, all transactions are allowed. */
+	uint32_t i_enable                     : 1;  /**< Port input enable. When cleared, port will generate control symbols and respond
+                                                         to maintenance packets only. All other packets will not be accepted. */
+	uint32_t dis_err                      : 1;  /**< Disable error checking.  For diagnostic use only. */
+	uint32_t mcast                        : 1;  /**< Reserved. */
+	uint32_t reserved_18_18               : 1;
+	uint32_t enumb                        : 1;  /**< Enumeration boundry. SW can use this bit to determine port enumeration. */
+	uint32_t reserved_16_16               : 1;
+	uint32_t ex_width                     : 2;  /**< Extended port width not supported. */
+	uint32_t ex_stat                      : 2;  /**< Extended port width status. 0x0 = not supported. */
+	uint32_t suppress                     : 8;  /**< Retransmit suppression mask.  CRF not Supported. */
+	uint32_t stp_port                     : 1;  /**< Stop on failed port. This bit is used with the DROP_PKT bit to force certain
+                                                         behavior when the error rate failed threshold has been met or exceeded. */
+	uint32_t drop_pkt                     : 1;  /**< Drop on failed port. This bit is used with the STP_PORT bit to force certain
+                                                         behavior when the error rate failed threshold has been met or exceeded. */
+	uint32_t prt_lock                     : 1;  /**< When this bit is cleared, the packets that may be
+                                                         received and issued are controlled by the state of
+                                                         the O_ENABLE and I_ENABLE bits.  When this bit is
+                                                         set, this port is stopped and is not enabled to
+                                                         receive any packets; the input port can still
+                                                         follow the training procedure and can still send
+                                                         respond to link-requests; all received packets
+                                                         return packet-not-accepted control symbols to
+                                                         force an error condition to be signaled by the
+                                                         sending device.  The O_ENABLE bit should also be
+                                                         cleared to disable packet output. */
+	uint32_t pt_type                      : 1;  /**< Port type.  1 = Serial port. */
+#else
+	uint32_t pt_type                      : 1;
+	uint32_t prt_lock                     : 1;
+	uint32_t drop_pkt                     : 1;
+	uint32_t stp_port                     : 1;
+	uint32_t suppress                     : 8;
+	uint32_t ex_stat                      : 2;
+	uint32_t ex_width                     : 2;
+	uint32_t reserved_16_16               : 1;
+	uint32_t enumb                        : 1;
+	uint32_t reserved_18_18               : 1;
+	uint32_t mcast                        : 1;
+	uint32_t dis_err                      : 1;
+	uint32_t i_enable                     : 1;
+	uint32_t o_enable                     : 1;
+	uint32_t port_disable                 : 1;
+	uint32_t ov_width                     : 3;
+	uint32_t it_width                     : 3;
+	uint32_t pt_width                     : 2;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_ctl cvmx_sriomaintx_port_0_ctl_t;
 
 /**
  * cvmx_sriomaint#_port_0_ctl2
  *
- * SRIOMAINT_PORT_0_CTL2 = SRIO Port 0 Control 2
- *
- * Port 0 Control 2
+ * These registers are accessed when a local processor or an external
+ * device wishes to examine the port baudrate information.  The Automatic
+ * Baud Rate Feature is not available on this device. The SUP_* and ENB_*
+ * fields are set directly by the SRIO()_STATUS_REG[SPD] bits as a
+ * reference but otherwise have no effect.
  *
- * Notes:
- * These registers are accessed when a local processor or an external device wishes to examine the
- *  port baudrate information.  The Automatic Baud Rate Feature is not available on this device.  The
- *  SUP_* and ENB_* fields are set directly by the QLM_SPD bits as a reference but otherwise have
- *  no effect.  WARNING:  Writes to this register will reinitialize the SRIO link.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_CTL2   hclk    hrst_n
+ * WARNING!!  Writes to this register will reinitialize the SRIO link.
  */
 union cvmx_sriomaintx_port_0_ctl2 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_0_ctl2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t sel_baud                     : 4;  /**< Link Baud Rate Selected.
-                                                           0000 - No rate selected
-                                                           0001 - 1.25 GBaud
-                                                           0010 - 2.5 GBaud
-                                                           0011 - 3.125 GBaud
-                                                           0100 - 5.0 GBaud
-                                                           0101 - 6.25 GBaud (reserved)
-                                                           0110 - 0b1111 - Reserved
-                                                         Indicates the speed of the interface SERDES lanes
-                                                         (selected by the QLM*_SPD straps). */
-	uint32_t baud_sup                     : 1;  /**< Automatic Baud Rate Discovery not supported. */
-	uint32_t baud_enb                     : 1;  /**< Auto Baud Rate Discovery Enable. */
+	uint32_t sel_baud                     : 4;  /**< Indicates the speed of the interface SERDES lanes.
+                                                         Link Baud Rate Selected:
+                                                         0x0 = No rate selected.
+                                                         0x1 = 1.25 GBaud.
+                                                         0x2 = 2.5 GBaud.
+                                                         0x3 = 3.125 GBaud.
+                                                         0x4 = 5.0 GBaud.
+                                                         0x5 = 6.25 GBaud (reserved).
+                                                         0x6-0xF = Reserved. */
+	uint32_t baud_sup                     : 1;  /**< Automatic baud rate discovery not supported. */
+	uint32_t baud_enb                     : 1;  /**< Auto baud rate discovery enable. */
 	uint32_t sup_125g                     : 1;  /**< 1.25GB Rate Operation supported.
                                                          Set when the interface SERDES lanes are operating
-                                                         at 1.25 Gbaud (as selected by QLM*_SPD straps). */
+                                                         at 1.25 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t enb_125g                     : 1;  /**< 1.25GB Rate Operation enable.
-                                                         Reset to 1 when the interface SERDES lanes are
-                                                         operating at 1.25 Gbaud (as selected by QLM*_SPD
-                                                         straps). Reset to 0 otherwise. */
+                                                         Set when the interface SERDES lanes are operating
+                                                         at 1.25 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t sup_250g                     : 1;  /**< 2.50GB Rate Operation supported.
                                                          Set when the interface SERDES lanes are operating
-                                                         at 2.5 Gbaud (as selected by QLM*_SPD straps). */
+                                                         at 2.5 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t enb_250g                     : 1;  /**< 2.50GB Rate Operation enable.
-                                                         Reset to 1 when the interface SERDES lanes are
-                                                         operating at 2.5 Gbaud (as selected by QLM*_SPD
-                                                         straps). Reset to 0 otherwise. */
+                                                         Set when the interface SERDES lanes are operating
+                                                         at 2.5 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t sup_312g                     : 1;  /**< 3.125GB Rate Operation supported.
                                                          Set when the interface SERDES lanes are operating
-                                                         at 3.125 Gbaud (as selected by QLM*_SPD straps). */
+                                                         at 3.125 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t enb_312g                     : 1;  /**< 3.125GB Rate Operation enable.
-                                                         Reset to 1 when the interface SERDES lanes are
-                                                         operating at 3.125 Gbaud (as selected by QLM*_SPD
-                                                         straps). Reset to 0 otherwise. */
+                                                         Set when the interface SERDES lanes are operating
+                                                         at 3.125 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t sub_500g                     : 1;  /**< 5.0GB Rate Operation supported.
                                                          Set when the interface SERDES lanes are operating
-                                                         at 5.0 Gbaud (as selected by QLM*_SPD straps). */
+                                                         at 5.0 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t enb_500g                     : 1;  /**< 5.0GB Rate Operation enable.
-                                                         Reset to 1 when the interface SERDES lanes are
-                                                         operating at 5.0 Gbaud (as selected by QLM*_SPD
-                                                         straps). Reset to 0 otherwise. */
+                                                         Set when the interface SERDES lanes are operating
+                                                         at 5.0 Gbaud (as selected by SRIO()_STATUS_REG[SPD]). */
 	uint32_t sup_625g                     : 1;  /**< 6.25GB Rate Operation (not supported). */
 	uint32_t enb_625g                     : 1;  /**< 6.25GB Rate Operation enable. */
 	uint32_t reserved_2_15                : 14;
@@ -3731,67 +5207,60 @@ union cvmx_sriomaintx_port_0_ctl2 {
 	struct cvmx_sriomaintx_port_0_ctl2_s  cn63xx;
 	struct cvmx_sriomaintx_port_0_ctl2_s  cn63xxp1;
 	struct cvmx_sriomaintx_port_0_ctl2_s  cn66xx;
+	struct cvmx_sriomaintx_port_0_ctl2_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_ctl2 cvmx_sriomaintx_port_0_ctl2_t;
 
 /**
  * cvmx_sriomaint#_port_0_err_stat
  *
- * SRIOMAINT_PORT_0_ERR_STAT = SRIO Port 0 Error and Status
- *
- * Port 0 Error and Status
- *
- * Notes:
  * This register displays port error and status information.  Several port error conditions are
- *  captured here and must be cleared by writing 1's to the individual bits.
- *  Bits are R/W on 65/66xx pass 1 and R/W1C on pass 1.2
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_ERR_STAT       hclk    hrst_n
+ * captured here and must be cleared by writing 1's to the individual bits.
  */
 union cvmx_sriomaintx_port_0_err_stat {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_0_err_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_27_31               : 5;
-	uint32_t pkt_drop                     : 1;  /**< Output Packet Dropped. */
-	uint32_t o_fail                       : 1;  /**< Output Port has encountered a failure condition,
+	uint32_t pkt_drop                     : 1;  /**< Output packet dropped. */
+	uint32_t o_fail                       : 1;  /**< Output port has encountered a failure condition,
                                                          meaning the port's failed error threshold has
-                                                         reached SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR.ER_FAIL value. */
-	uint32_t o_dgrad                      : 1;  /**< Output Port has encountered a degraded condition,
+                                                         reached SRIOMAINT()_ERB_ERR_RATE_THR[ER_FAIL] value. */
+	uint32_t o_dgrad                      : 1;  /**< Output port has encountered a degraded condition,
                                                          meaning the port's degraded threshold has
-                                                         reached SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR.ER_DGRAD
+                                                         reached SRIOMAINT()_ERB_ERR_RATE_THR[ER_DGRAD]
                                                          value. */
 	uint32_t reserved_21_23               : 3;
-	uint32_t o_retry                      : 1;  /**< Output Retry Encountered.  This bit is set when
+	uint32_t o_retry                      : 1;  /**< Output retry encountered.  This bit is set when
                                                          bit 18 is set. */
-	uint32_t o_rtried                     : 1;  /**< Output Port has received a packet-retry condition
+	uint32_t o_rtried                     : 1;  /**< Output port has received a packet-retry condition
                                                          and cannot make forward progress.  This bit is set
                                                          when  bit 18 is set and is cleared when a packet-
                                                          accepted or a packet-not-accepted control symbol
                                                          is received. */
-	uint32_t o_sm_ret                     : 1;  /**< Output Port State Machine has received a
+	uint32_t o_sm_ret                     : 1;  /**< Output port state machine has received a
                                                          packet-retry control symbol and is retrying the
                                                          packet. */
-	uint32_t o_error                      : 1;  /**< Output Error Encountered and possibly recovered
+	uint32_t o_error                      : 1;  /**< Output error encountered and possibly recovered
                                                          from.  This sticky bit is set with bit 16. */
-	uint32_t o_sm_err                     : 1;  /**< Output Port State Machine has encountered an
+	uint32_t o_sm_err                     : 1;  /**< Output port state machine has encountered an
                                                          error. */
 	uint32_t reserved_11_15               : 5;
-	uint32_t i_sm_ret                     : 1;  /**< Input Port State Machine has received a
+	uint32_t i_sm_ret                     : 1;  /**< Input port state machine has received a
                                                          packet-retry control symbol and is retrying the
                                                          packet. */
-	uint32_t i_error                      : 1;  /**< Input Error Encountered and possibly recovered
+	uint32_t i_error                      : 1;  /**< Input error encountered and possibly recovered
                                                          from.  This sticky bit is set with bit 8. */
-	uint32_t i_sm_err                     : 1;  /**< Input Port State Machine has encountered an
+	uint32_t i_sm_err                     : 1;  /**< Input port state machine has encountered an
                                                          error. */
 	uint32_t reserved_5_7                 : 3;
 	uint32_t pt_write                     : 1;  /**< Port has encountered a condition which required it
-                                                         initiate a Maintenance Port-Write Operation.
+                                                         initiate a maintenance port-write operation.
                                                          Never set by hardware. */
 	uint32_t reserved_3_3                 : 1;
-	uint32_t pt_error                     : 1;  /**< Input or Output Port has encountered an
+	uint32_t pt_error                     : 1;  /**< Input or output port has encountered an
                                                          unrecoverable error condition. */
-	uint32_t pt_ok                        : 1;  /**< Input or Output Port are intitialized and the port
+	uint32_t pt_ok                        : 1;  /**< Input or output port are intitialized and the port
                                                          is exchanging error free control symbols with
                                                          attached device. */
 	uint32_t pt_uinit                     : 1;  /**< Port is uninitialized.  This bit and bit 1 are
@@ -3822,31 +5291,25 @@ union cvmx_sriomaintx_port_0_err_stat {
 	struct cvmx_sriomaintx_port_0_err_stat_s cn63xx;
 	struct cvmx_sriomaintx_port_0_err_stat_s cn63xxp1;
 	struct cvmx_sriomaintx_port_0_err_stat_s cn66xx;
+	struct cvmx_sriomaintx_port_0_err_stat_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_err_stat cvmx_sriomaintx_port_0_err_stat_t;
 
 /**
  * cvmx_sriomaint#_port_0_link_req
  *
- * SRIOMAINT_PORT_0_LINK_REQ = SRIO Port 0 Link Request
- *
- * Port 0 Manual Link Request
- *
- * Notes:
- * Writing this register generates the link request symbol or eight device reset symbols.   The
- *  progress of the request can be determined by reading SRIOMAINT(0,2..3)_PORT_0_LINK_RESP.  Only a single
- *  request should be generated at a time.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LINK_REQ       hclk    hrst_n
+ * Writing this register generates the link request symbol or eight device reset
+ * symbols. The progress of the request can be determined by reading
+ * SRIOMAINT()_PORT_0_LINK_RESP. Only a single request should be generated at a time.
  */
 union cvmx_sriomaintx_port_0_link_req {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_0_link_req_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_3_31                : 29;
-	uint32_t cmd                          : 3;  /**< Link Request Command.
-                                                         011 - Reset Device
-                                                         100 - Link Request
+	uint32_t cmd                          : 3;  /**< Link request command.
+                                                         0x3 = Reset device.
+                                                         0x4 = Link request.
                                                          All other values reserved. */
 #else
 	uint32_t cmd                          : 3;
@@ -3855,34 +5318,29 @@ union cvmx_sriomaintx_port_0_link_req {
 	} s;
 	struct cvmx_sriomaintx_port_0_link_req_s cn63xx;
 	struct cvmx_sriomaintx_port_0_link_req_s cn66xx;
+	struct cvmx_sriomaintx_port_0_link_req_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_link_req cvmx_sriomaintx_port_0_link_req_t;
 
 /**
  * cvmx_sriomaint#_port_0_link_resp
  *
- * SRIOMAINT_PORT_0_LINK_RESP = SRIO Port 0 Link Response
- *
- * Port 0 Manual Link Response
- *
- * Notes:
- * This register only returns responses generated by writes to SRIOMAINT(0,2..3)_PORT_0_LINK_REQ.
+ * This register only returns responses generated by writes to SRIOMAINT()_PORT_0_LINK_REQ.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LINK_RESP      hclk    hrst_n
  */
 union cvmx_sriomaintx_port_0_link_resp {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_0_link_resp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t valid                        : 1;  /**< Link Response Valid.
+	uint32_t valid                        : 1;  /**< Link response valid.
+                                                         0 = No response received.
                                                          1 = Link Response Received or Reset Device
-                                                             Symbols Transmitted.  Value cleared on read.
-                                                         0 = No response received. */
+                                                         Symbols Transmitted.  Value cleared on read. */
 	uint32_t reserved_11_30               : 20;
 	uint32_t ackid                        : 6;  /**< AckID received from link response.
                                                          Reset Device symbol response is always zero.
                                                          Bit 10 is used for IDLE2 and always reads zero. */
-	uint32_t status                       : 5;  /**< Link Response Status.
+	uint32_t status                       : 5;  /**< Link response status.
                                                          Status supplied by link response.
                                                          Reset Device symbol response is always zero. */
 #else
@@ -3894,23 +5352,18 @@ union cvmx_sriomaintx_port_0_link_resp {
 	} s;
 	struct cvmx_sriomaintx_port_0_link_resp_s cn63xx;
 	struct cvmx_sriomaintx_port_0_link_resp_s cn66xx;
+	struct cvmx_sriomaintx_port_0_link_resp_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_link_resp cvmx_sriomaintx_port_0_link_resp_t;
 
 /**
  * cvmx_sriomaint#_port_0_local_ackid
  *
- * SRIOMAINT_PORT_0_LOCAL_ACKID = SRIO Port 0 Local AckID
- *
- * Port 0 Local AckID Control
- *
- * Notes:
- * This register is typically only written when recovering from a failed link.  It may be read at any
- *  time the MAC is out of reset.  Writes to the O_ACKID field will be used for both the O_ACKID and
- *  E_ACKID.  Care must be taken to ensure that no packets are pending at the time of a write.  The
- *  number of pending packets can be read in the TX_INUSE field of SRIO(0,2..3)_MAC_BUFFERS.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LOCAL_ACKID    hclk    hrst_n
+ * This register is typically only written when recovering from a failed link. It may
+ * be read at any time the MAC is out of reset. Writes to the O_ACKID field will be
+ * used for both the O_ACKID and E_ACKID. Care must be taken to ensure that no packets
+ * are pending at the time of a write. The number of pending packets can be read in the
+ * TX_INUSE field of SRIO()_MAC_BUFFERS.
  */
 union cvmx_sriomaintx_port_0_local_ackid {
 	uint32_t u32;
@@ -3936,28 +5389,23 @@ union cvmx_sriomaintx_port_0_local_ackid {
 	} s;
 	struct cvmx_sriomaintx_port_0_local_ackid_s cn63xx;
 	struct cvmx_sriomaintx_port_0_local_ackid_s cn66xx;
+	struct cvmx_sriomaintx_port_0_local_ackid_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_0_local_ackid cvmx_sriomaintx_port_0_local_ackid_t;
 
 /**
  * cvmx_sriomaint#_port_gen_ctl
  *
- * SRIOMAINT_PORT_GEN_CTL = SRIO Port General Control
- *
  * Port General Control
  *
- * Notes:
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_GEN_CTL  hclk    hrst_n
- *
  */
 union cvmx_sriomaintx_port_gen_ctl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_gen_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t host                         : 1;  /**< Host Device.
-                                                         The HOST reset value is based on corresponding
-                                                         MIO_RST_CTL*[PRTMODE].  HOST resets to 1 when
-                                                         this field selects RC (i.e. host) mode, else 0. */
+                                                         The HOST value is based on corresponding
+                                                         SRIO()_STATUS_REG[HOST] bit but may be overwritten by software. */
 	uint32_t menable                      : 1;  /**< Master Enable.  Must be set for device to issue
                                                          read, write, doorbell, message requests. */
 	uint32_t discover                     : 1;  /**< Discovered. The device has been discovered by the
@@ -3973,33 +5421,28 @@ union cvmx_sriomaintx_port_gen_ctl {
 	struct cvmx_sriomaintx_port_gen_ctl_s cn63xx;
 	struct cvmx_sriomaintx_port_gen_ctl_s cn63xxp1;
 	struct cvmx_sriomaintx_port_gen_ctl_s cn66xx;
+	struct cvmx_sriomaintx_port_gen_ctl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_gen_ctl cvmx_sriomaintx_port_gen_ctl_t;
 
 /**
  * cvmx_sriomaint#_port_lt_ctl
  *
- * SRIOMAINT_PORT_LT_CTL = SRIO Link Layer Timeout Control
- *
- * Link Layer Timeout Control
- *
- * Notes:
- * This register controls the timeout for link layer transactions.  It is used as the timeout between
- *  sending a packet (of any type) or link request to receiving the corresponding link acknowledge or
- *  link-response.  Each count represents 200ns.  The minimum timeout period is the TIMEOUT x 200nS
- *  and the maximum is twice that number.  A value less than 32 may not guarantee that all timeout
- *  errors will be reported correctly.  When the timeout period expires the packet or link request is
- *  dropped and the error is logged in the LNK_TOUT field of the SRIOMAINT(0,2..3)_ERB_ERR_DET register.  A
- *  value of 0 in this register will allow the packet or link request to be issued but it will timeout
- *  immediately.  This value is not recommended for normal operation.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_LT_CTL   hclk    hrst_n
+ * This register controls the timeout for link layer transactions.  It is used as the timeout
+ * between sending a packet (of any type) or link request to receiving the corresponding link
+ * acknowledge or link-response.  Each count represents 200ns.  The minimum timeout period is
+ * the TIMEOUT x200nS and the maximum is twice that number.  A value less than 32 may not
+ * guarantee that all timeout errors will be reported correctly.  When the timeout period expires
+ * the packet or link request is dropped and the error is logged in the LNK_TOUT field of the
+ * SRIOMAINT()_ERB_ERR_DET register. A value of 0 in this register will allow the packet or
+ * link request to be issued but it will timeout immediately.  This value is not recommended for
+ * normal operation.
  */
 union cvmx_sriomaintx_port_lt_ctl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_lt_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t timeout                      : 24; /**< Timeout Value */
+	uint32_t timeout                      : 24; /**< Timeout value. */
 	uint32_t reserved_0_7                 : 8;
 #else
 	uint32_t reserved_0_7                 : 8;
@@ -4009,6 +5452,7 @@ union cvmx_sriomaintx_port_lt_ctl {
 	struct cvmx_sriomaintx_port_lt_ctl_s  cn63xx;
 	struct cvmx_sriomaintx_port_lt_ctl_s  cn63xxp1;
 	struct cvmx_sriomaintx_port_lt_ctl_s  cn66xx;
+	struct cvmx_sriomaintx_port_lt_ctl_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_port_lt_ctl cvmx_sriomaintx_port_lt_ctl_t;
 
@@ -4027,8 +5471,8 @@ union cvmx_sriomaintx_port_mbh0 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_mbh0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t ef_ptr                       : 16; /**< Pointer to Error Management Block. */
-	uint32_t ef_id                        : 16; /**< Extended Feature ID (Generic Endpoint Device) */
+	uint32_t ef_ptr                       : 16; /**< Pointer to error management block. */
+	uint32_t ef_id                        : 16; /**< Extended feature ID (generic endpoint device). */
 #else
 	uint32_t ef_id                        : 16;
 	uint32_t ef_ptr                       : 16;
@@ -4037,37 +5481,33 @@ union cvmx_sriomaintx_port_mbh0 {
 	struct cvmx_sriomaintx_port_mbh0_s    cn63xx;
 	struct cvmx_sriomaintx_port_mbh0_s    cn63xxp1;
 	struct cvmx_sriomaintx_port_mbh0_s    cn66xx;
+	struct cvmx_sriomaintx_port_mbh0_s    cn75xx;
 };
 typedef union cvmx_sriomaintx_port_mbh0 cvmx_sriomaintx_port_mbh0_t;
 
 /**
  * cvmx_sriomaint#_port_rt_ctl
  *
- * SRIOMAINT_PORT_RT_CTL = SRIO Logical Layer Timeout Control
- *
- * Logical Layer Timeout Control
- *
- * Notes:
- * This register controls the timeout for logical layer transactions.  It is used under two
- *  conditions.  First, it is used as the timeout period between sending a packet requiring a packet
- *  response being sent to receiving the corresponding response.  This is used for all outgoing packet
- *  types including memory, maintenance, doorbells and message operations.  When the timeout period
- *  expires the packet is disgarded and the error is logged in the PKT_TOUT field of the
- *  SRIOMAINT(0,2..3)_ERB_LT_ERR_DET register.  The second use of this register is as a timeout period
- *  between incoming message segments of the same message.  If a message segment is received then the
- *  MSG_TOUT field of the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET register is set if the next segment has not been
- *  received before the time expires.  In both cases, each count represents 200ns.  The minimum
- *  timeout period is the TIMEOUT x 200nS and the maximum is twice that number.  A value less than 32
- *  may not guarantee that all timeout errors will be reported correctly.  A value of 0 disables the
- *  logical layer timeouts and is not recommended for normal operation.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_RT_CTL   hclk    hrst_n
+ * This register controls the timeout for logical layer transactions. It is used under
+ * two conditions. First, it is used as the timeout period between sending a packet
+ * requiring a packet response being sent to receiving the corresponding response. This
+ * is used for all outgoing packet types including memory, maintenance, doorbells and
+ * message operations. When the timeout period expires the packet is disgarded and the
+ * error is logged in the PKT_TOUT field of the SRIOMAINT()_ERB_LT_ERR_DET
+ * register. The second use of this register is as a timeout period between incoming
+ * message segments of the same message. If a message segment is received then the
+ * MSG_TOUT field of the SRIOMAINT()_ERB_LT_ERR_DET register is set if the next segment
+ * has not been received before the time expires. In both cases, each count represents
+ * 200ns. The minimum timeout period is the TIMEOUT x 200nS and the maximum is twice
+ * that number. A value less than 32 may not guarantee that all timeout errors will be
+ * reported correctly. A value of 0 disables the logical layer timeouts and is not
+ * recommended for normal operation.
  */
 union cvmx_sriomaintx_port_rt_ctl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_rt_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t timeout                      : 24; /**< Timeout Value */
+	uint32_t timeout                      : 24; /**< Timeout value. */
 	uint32_t reserved_0_7                 : 8;
 #else
 	uint32_t reserved_0_7                 : 8;
@@ -4077,39 +5517,35 @@ union cvmx_sriomaintx_port_rt_ctl {
 	struct cvmx_sriomaintx_port_rt_ctl_s  cn63xx;
 	struct cvmx_sriomaintx_port_rt_ctl_s  cn63xxp1;
 	struct cvmx_sriomaintx_port_rt_ctl_s  cn66xx;
+	struct cvmx_sriomaintx_port_rt_ctl_s  cn75xx;
 };
 typedef union cvmx_sriomaintx_port_rt_ctl cvmx_sriomaintx_port_rt_ctl_t;
 
 /**
  * cvmx_sriomaint#_port_ttl_ctl
  *
- * SRIOMAINT_PORT_TTL_CTL = SRIO Packet Time to Live Control
- *
- * Packet Time to Live
- *
- * Notes:
- * This register controls the timeout for outgoing packets.  It is used to make sure packets are
- *  being transmitted and acknowledged within a reasonable period of time.   The timeout value
- *  corresponds to TIMEOUT x 200ns and a value of 0 disables the timer.  The actualy value of the
- *  should be greater than the physical layer timout specified in SRIOMAINT(0,2..3)_PORT_LT_CTL and is
- *  typically a less SRIOMAINT(0,2..3)_PORT_LT_CTL timeout than the response timeout specified in
- *  SRIOMAINT(0,2..3)_PORT_RT_CTL.  A second application of this timer is to remove all the packets waiting
- *  to be transmitted including those already in flight.  This may necessary in the case of a link
- *  going down (see SRIO(0,2..3)_INT_REG.LINK_DWN).  This can accomplished by setting the TIMEOUT to small
- *  value all so that all TX packets can be dropped.  In either case, when the timeout expires the TTL
- *  interrupt is asserted, any packets currently being transmitted are dropped, the
- *  SRIOMAINT(0,2..3)_TX_DROP.DROP bit is set (causing any scheduled packets to be dropped), the
- *  SRIOMAINT(0,2..3)_TX_DROP.DROP_CNT is incremented for each packet and the SRIO output state is set to
- *  IDLE (all errors are cleared).  Software must clear the SRIOMAINT(0,2..3)_TX_DROP.DROP bit to resume
- *  transmitting packets.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_RT_CTL   hclk    hrst_n
+ * This register controls the timeout for outgoing packets. It is used to make sure
+ * packets are being transmitted and acknowledged within a reasonable period of
+ * time. The timeout value corresponds to TIMEOUT x 200ns and a value of 0 disables the
+ * timer. The actualy value of the should be greater than the physical layer timout
+ * specified in SRIOMAINT()_PORT_LT_CTL and is typically a less SRIOMAINT()_PORT_LT_CTL
+ * timeout than the response timeout specified in SRIOMAINT()_PORT_RT_CTL. A second
+ * application of this timer is to remove all the packets waiting to be transmitted
+ * including those already in flight. This may necessary in the case of a link going
+ * down (see SRIO()_INT_REG[LINK_DWN]). This can accomplished by setting the TIMEOUT to
+ * small value all so that all TX packets can be dropped. In either case, when the
+ * timeout expires the TTL interrupt is asserted, any packets currently being
+ * transmitted are dropped, the SRIOMAINT()_TX_DROP[DROP] bit is set (causing any
+ * scheduled packets to be dropped), the SRIOMAINT()_TX_DROP[DROP_CNT] is incremented
+ * for each packet and the SRIO output state is set to IDLE (all errors are
+ * cleared). Software must clear the SRIOMAINT()_TX_DROP[DROP] bit to resume
+ * transmitting packets.
  */
 union cvmx_sriomaintx_port_ttl_ctl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_port_ttl_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t timeout                      : 24; /**< Timeout Value */
+	uint32_t timeout                      : 24; /**< Timeout value. */
 	uint32_t reserved_0_7                 : 8;
 #else
 	uint32_t reserved_0_7                 : 8;
@@ -4118,29 +5554,24 @@ union cvmx_sriomaintx_port_ttl_ctl {
 	} s;
 	struct cvmx_sriomaintx_port_ttl_ctl_s cn63xx;
 	struct cvmx_sriomaintx_port_ttl_ctl_s cn66xx;
+	struct cvmx_sriomaintx_port_ttl_ctl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_port_ttl_ctl cvmx_sriomaintx_port_ttl_ctl_t;
 
 /**
  * cvmx_sriomaint#_pri_dev_id
  *
- * SRIOMAINT_PRI_DEV_ID = SRIO Primary Device ID
- *
- * Primary 8 and 16 bit Device IDs
- *
- * Notes:
- * This register defines the primary 8 and 16 bit device IDs used for large and small transport.  An
- *  optional secondary set of device IDs are located in SRIOMAINT(0,2..3)_SEC_DEV_ID.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_PRI_DEV_ID    hclk    hrst_n
+ * Primary 8 and 16 bit Device IDs.
+ * This register defines the primary 8 and 16 bit device IDs used for large and small transport.
+ * An optional secondary set of device IDs are located in SRIOMAINT()_SEC_DEV_ID.
  */
 union cvmx_sriomaintx_pri_dev_id {
 	uint32_t u32;
 	struct cvmx_sriomaintx_pri_dev_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
-	uint32_t id8                          : 8;  /**< Primary 8-bit Device ID */
-	uint32_t id16                         : 16; /**< Primary 16-bit Device ID */
+	uint32_t id8                          : 8;  /**< Primary 8-bit device ID. */
+	uint32_t id16                         : 16; /**< Primary 16-bit device ID. */
 #else
 	uint32_t id16                         : 16;
 	uint32_t id8                          : 8;
@@ -4150,30 +5581,25 @@ union cvmx_sriomaintx_pri_dev_id {
 	struct cvmx_sriomaintx_pri_dev_id_s   cn63xx;
 	struct cvmx_sriomaintx_pri_dev_id_s   cn63xxp1;
 	struct cvmx_sriomaintx_pri_dev_id_s   cn66xx;
+	struct cvmx_sriomaintx_pri_dev_id_s   cn75xx;
 };
 typedef union cvmx_sriomaintx_pri_dev_id cvmx_sriomaintx_pri_dev_id_t;
 
 /**
  * cvmx_sriomaint#_sec_dev_ctrl
  *
- * SRIOMAINT_SEC_DEV_CTRL = SRIO Secondary Device ID Control
- *
- * Control for Secondary Device IDs
- *
- * Notes:
- * This register enables the secondary 8 and 16 bit device IDs used for large and small transport.
- *  The corresponding secondary ID must be written before the ID is enabled.  The secondary IDs should
- *  not be enabled if the values of the primary and secondary IDs are identical.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_SEC_DEV_CTRL  hclk    hrst_n
+ * This register enables the secondary 8 and 16 bit device IDs used for large and small
+ * transport.
+ * The corresponding secondary ID must be written before the ID is enabled.  The secondary IDs
+ * should not be enabled if the values of the primary and secondary IDs are identical.
  */
 union cvmx_sriomaintx_sec_dev_ctrl {
 	uint32_t u32;
 	struct cvmx_sriomaintx_sec_dev_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_2_31                : 30;
-	uint32_t enable8                      : 1;  /**< Enable matches to secondary 8-bit Device ID */
-	uint32_t enable16                     : 1;  /**< Enable matches to secondary 16-bit Device ID */
+	uint32_t enable8                      : 1;  /**< Enable matches to secondary 8-bit device ID. */
+	uint32_t enable16                     : 1;  /**< Enable matches to secondary 16-bit device ID. */
 #else
 	uint32_t enable16                     : 1;
 	uint32_t enable8                      : 1;
@@ -4183,32 +5609,28 @@ union cvmx_sriomaintx_sec_dev_ctrl {
 	struct cvmx_sriomaintx_sec_dev_ctrl_s cn63xx;
 	struct cvmx_sriomaintx_sec_dev_ctrl_s cn63xxp1;
 	struct cvmx_sriomaintx_sec_dev_ctrl_s cn66xx;
+	struct cvmx_sriomaintx_sec_dev_ctrl_s cn75xx;
 };
 typedef union cvmx_sriomaintx_sec_dev_ctrl cvmx_sriomaintx_sec_dev_ctrl_t;
 
 /**
  * cvmx_sriomaint#_sec_dev_id
  *
- * SRIOMAINT_SEC_DEV_ID = SRIO Secondary Device ID
- *
- * Secondary 8 and 16 bit Device IDs
- *
- * Notes:
- * This register defines the secondary 8 and 16 bit device IDs used for large and small transport.
- *  The corresponding secondary ID must be written before the ID is enabled in the
- *  SRIOMAINT(0,2..3)_SEC_DEV_CTRL register.  The primary set of device IDs are located in
- *  SRIOMAINT(0,2..3)_PRI_DEV_ID register.  The secondary IDs should not be written to the same values as the
- *  corresponding primary IDs.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_SEC_DEV_ID    hclk    hrst_n
+ * Secondary 8 and 16 bit device IDs.
+ * This register defines the secondary 8 and 16 bit device IDs used for large and small
+ * transport.
+ * The corresponding secondary ID must be written before the ID is enabled in the
+ * SRIOMAINT()_SEC_DEV_CTRL register.  The primary set of device IDs are located in
+ * SRIOMAINT()_PRI_DEV_ID register.  The secondary IDs should not be written to the same
+ * values as the corresponding primary IDs.
  */
 union cvmx_sriomaintx_sec_dev_id {
 	uint32_t u32;
 	struct cvmx_sriomaintx_sec_dev_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
-	uint32_t id8                          : 8;  /**< Secondary 8-bit Device ID */
-	uint32_t id16                         : 16; /**< Secondary 16-bit Device ID */
+	uint32_t id8                          : 8;  /**< Secondary 8-bit device ID. */
+	uint32_t id16                         : 16; /**< Secondary 16-bit device ID. */
 #else
 	uint32_t id16                         : 16;
 	uint32_t id8                          : 8;
@@ -4218,21 +5640,15 @@ union cvmx_sriomaintx_sec_dev_id {
 	struct cvmx_sriomaintx_sec_dev_id_s   cn63xx;
 	struct cvmx_sriomaintx_sec_dev_id_s   cn63xxp1;
 	struct cvmx_sriomaintx_sec_dev_id_s   cn66xx;
+	struct cvmx_sriomaintx_sec_dev_id_s   cn75xx;
 };
 typedef union cvmx_sriomaintx_sec_dev_id cvmx_sriomaintx_sec_dev_id_t;
 
 /**
  * cvmx_sriomaint#_serial_lane_hdr
  *
- * SRIOMAINT_SERIAL_LANE_HDR = SRIO Serial Lane Header
- *
- * SRIO Serial Lane Header
- *
- * Notes:
- * The error management extensions block header register contains the EF_PTR to the next EF_BLK and
- *  the EF_ID that identifies this as the Serial Lane Status Block.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_SERIAL_LANE_HDR       hclk    hrst_n
+ * The error management extensions block header register contains the EF_PTR to the next EF_BLK
+ * and the EF_ID that identifies this as the Serial Lane Status Block.
  */
 union cvmx_sriomaintx_serial_lane_hdr {
 	uint32_t u32;
@@ -4240,7 +5656,7 @@ union cvmx_sriomaintx_serial_lane_hdr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ef_ptr                       : 16; /**< Pointer to the next block in the extended features
                                                          data structure. */
-	uint32_t ef_id                        : 16;
+	uint32_t ef_id                        : 16; /**< ID. */
 #else
 	uint32_t ef_id                        : 16;
 	uint32_t ef_ptr                       : 16;
@@ -4249,75 +5665,69 @@ union cvmx_sriomaintx_serial_lane_hdr {
 	struct cvmx_sriomaintx_serial_lane_hdr_s cn63xx;
 	struct cvmx_sriomaintx_serial_lane_hdr_s cn63xxp1;
 	struct cvmx_sriomaintx_serial_lane_hdr_s cn66xx;
+	struct cvmx_sriomaintx_serial_lane_hdr_s cn75xx;
 };
 typedef union cvmx_sriomaintx_serial_lane_hdr cvmx_sriomaintx_serial_lane_hdr_t;
 
 /**
  * cvmx_sriomaint#_src_ops
  *
- * SRIOMAINT_SRC_OPS = SRIO Source Operations
- *
- * The logical operations initiated by the Octeon.
- *
- * Notes:
- * The logical operations initiated by the Cores.   The Source OPs register shows the operations
- *  specified in the SRIO(0,2..3)_IP_FEATURE.OPS register.
+ * This register shows the operations specified in the SRIO()_IP_FEATURE registers.
  *
- * Clk_Rst:        SRIOMAINT(0,2..3)_SRC_OPS       hclk    hrst_n
  */
 union cvmx_sriomaintx_src_ops {
 	uint32_t u32;
 	struct cvmx_sriomaintx_src_ops_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t gsm_read                     : 1;  /**< PE does not support Read Home operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<31>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<31>. */
 	uint32_t i_read                       : 1;  /**< PE does not support Instruction Read.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<30>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<30>. */
 	uint32_t rd_own                       : 1;  /**< PE does not support Read for Ownership.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<29>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<29>. */
 	uint32_t d_invald                     : 1;  /**< PE does not support Data Cache Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<28>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<28>. */
 	uint32_t castout                      : 1;  /**< PE does not support Castout Operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<27>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<27>. */
 	uint32_t d_flush                      : 1;  /**< PE does not support Data Cache Flush.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<26>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<26>. */
 	uint32_t io_read                      : 1;  /**< PE does not support IO Read.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<25>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<25>. */
 	uint32_t i_invald                     : 1;  /**< PE does not support Instruction Cache Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<24>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<24>. */
 	uint32_t tlb_inv                      : 1;  /**< PE does not support TLB Entry Invalidate.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<23>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<23>. */
 	uint32_t tlb_invs                     : 1;  /**< PE does not support TLB Entry Invalidate Sync.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<22>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<22>. */
 	uint32_t reserved_16_21               : 6;
 	uint32_t read                         : 1;  /**< PE can support Nread operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<15>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<15>. */
 	uint32_t write                        : 1;  /**< PE can support Nwrite operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<14>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<14>. */
 	uint32_t swrite                       : 1;  /**< PE can support Swrite operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<13>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<13>. */
 	uint32_t write_r                      : 1;  /**< PE can support Write with Response operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<12>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<12>. */
 	uint32_t msg                          : 1;  /**< PE can support Data Message operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<11>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<11>. */
 	uint32_t doorbell                     : 1;  /**< PE can support Doorbell operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<10>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<10>. */
 	uint32_t compswap                     : 1;  /**< PE does not support Atomic Compare and Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<9>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<9>. */
 	uint32_t testswap                     : 1;  /**< PE does not support Atomic Test and Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<8>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<8>. */
 	uint32_t atom_inc                     : 1;  /**< PE can support Atomic increment operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<7>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<7>. */
 	uint32_t atom_dec                     : 1;  /**< PE can support Atomic decrement operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<6>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<6>. */
 	uint32_t atom_set                     : 1;  /**< PE can support Atomic set operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<5>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<5>. */
 	uint32_t atom_clr                     : 1;  /**< PE can support Atomic clear operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<4>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<4>. */
 	uint32_t atom_swp                     : 1;  /**< PE does not support Atomic Swap.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<3>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<3>. */
 	uint32_t port_wr                      : 1;  /**< PE can Port Write operations.
-                                                         This is a RO copy of SRIO*_IP_FEATURE[OPS<2>] */
+                                                         This is a RO copy of SRIO()_IP_FEATURE[OPS]<2>. */
 	uint32_t reserved_0_1                 : 2;
 #else
 	uint32_t reserved_0_1                 : 2;
@@ -4351,23 +5761,17 @@ union cvmx_sriomaintx_src_ops {
 	struct cvmx_sriomaintx_src_ops_s      cn63xx;
 	struct cvmx_sriomaintx_src_ops_s      cn63xxp1;
 	struct cvmx_sriomaintx_src_ops_s      cn66xx;
+	struct cvmx_sriomaintx_src_ops_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_src_ops cvmx_sriomaintx_src_ops_t;
 
 /**
  * cvmx_sriomaint#_tx_drop
  *
- * SRIOMAINT_TX_DROP = SRIO MAC Outgoing Packet Drop
- *
- * Outging SRIO Packet Drop Control/Status
- *
- * Notes:
  * This register controls and provides status for dropping outgoing SRIO packets.  The DROP bit
- *  should only be cleared when no packets are currently being dropped.  This can be guaranteed by
- *  clearing the SRIOMAINT(0,2..3)_PORT_0_CTL.O_ENABLE bit before changing the DROP bit and restoring the
- *  O_ENABLE afterwards.
- *
- * Clk_Rst:        SRIOMAINT(0,2..3)_MAC_CTRL      hclk    hrst_n
+ * should only be cleared when no packets are currently being dropped.  This can be guaranteed by
+ * clearing SRIOMAINT()_PORT_0_CTL[O_ENABLE] before changing the DROP bit and
+ * restoring the O_ENABLE afterwards.
  */
 union cvmx_sriomaintx_tx_drop {
 	uint32_t u32;
@@ -4376,16 +5780,16 @@ union cvmx_sriomaintx_tx_drop {
 	uint32_t reserved_17_31               : 15;
 	uint32_t drop                         : 1;  /**< All outgoing packets are dropped.  Any packets
                                                          requiring a response will return 1's after the
-                                                         SRIOMAINT(0,2..3)_PORT_RT_CTL Timeout expires.  This bit
+                                                         SRIOMAINT()_PORT_RT_CTL timeout expires.  This bit
                                                          is set automatically when the TTL Timeout occurs
                                                          or can be set by software and must always be
                                                          cleared by software. */
 	uint32_t drop_cnt                     : 16; /**< Number of packets dropped by transmit logic.
                                                          Packets are dropped whenever a packet is ready to
                                                          be transmitted and a TTL Timeouts occur, the  DROP
-                                                         bit is set or the SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR
+                                                         bit is set or the SRIOMAINT()_ERB_ERR_RATE_THR
                                                          FAIL_TH has been reached and the DROP_PKT bit is
-                                                         set in SRIOMAINT(0,2..3)_PORT_0_CTL.  This counter wraps
+                                                         set in SRIOMAINT()_PORT_0_CTL.  This counter wraps
                                                          on overflow and is cleared only on reset. */
 #else
 	uint32_t drop_cnt                     : 16;
@@ -4395,6 +5799,7 @@ union cvmx_sriomaintx_tx_drop {
 	} s;
 	struct cvmx_sriomaintx_tx_drop_s      cn63xx;
 	struct cvmx_sriomaintx_tx_drop_s      cn66xx;
+	struct cvmx_sriomaintx_tx_drop_s      cn75xx;
 };
 typedef union cvmx_sriomaintx_tx_drop cvmx_sriomaintx_tx_drop_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index b172d96..cea7064 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -57,7 +57,8 @@ static inline uint64_t CVMX_SRIOX_ACC_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_ACC_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000148ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -69,7 +70,8 @@ static inline uint64_t CVMX_SRIOX_ASMBLY_ID(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_ASMBLY_ID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000200ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -81,7 +83,8 @@ static inline uint64_t CVMX_SRIOX_ASMBLY_INFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_ASMBLY_INFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -89,11 +92,23 @@ static inline uint64_t CVMX_SRIOX_ASMBLY_INFO(unsigned long offset)
 #define CVMX_SRIOX_ASMBLY_INFO(offset) (CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_BELL_LOOKUPX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_SRIOX_BELL_LOOKUPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8;
+}
+#else
+#define CVMX_SRIOX_BELL_LOOKUPX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000500ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_BELL_RESP_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_BELL_RESP_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -101,11 +116,23 @@ static inline uint64_t CVMX_SRIOX_BELL_RESP_CTRL(unsigned long offset)
 #define CVMX_SRIOX_BELL_RESP_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_BELL_SELECT(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_BELL_SELECT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000320ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_BELL_SELECT(offset) (CVMX_ADD_IO_SEG(0x00011800C8000320ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -113,28 +140,127 @@ static inline uint64_t CVMX_SRIOX_BIST_STATUS(unsigned long offset)
 #define CVMX_SRIOX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_IMSG_CTRL(unsigned long offset)
+static inline uint64_t CVMX_SRIOX_ECC_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_CTRL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_ECC_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000238ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_ECC_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000238ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_ECC_STATUS(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_ECC_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000230ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_ECC_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000230ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_ECO(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_ECO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80005F8ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800C80005F8ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_IMSG_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C8000608ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOX_IMSG_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000608ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IMSG_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 3) * 0x1000000ull)
+static inline uint64_t CVMX_SRIOX_IMSG_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000608ull) + (offset) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800C8000608ull) + (offset) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IMSG_INST_HDRX(unsigned long offset, unsigned long block_id)
 {
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C8000510ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800C8000510ull) + (((offset) & 1) + ((block_id) & 1) * 0x200000ull) * 8;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 255)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800C8000800ull) + (((offset) & 255) + ((block_id) & 1) * 0x200000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOX_IMSG_INST_HDRX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800C8000800ull) + (((offset) & 255) + ((block_id) & 1) * 0x200000ull) * 8;
+}
+#else
+static inline uint64_t CVMX_SRIOX_IMSG_INST_HDRX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000510ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000510ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000800ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800C8000800ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_IMSG_PKINDX(unsigned long offset, unsigned long block_id)
+{
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_INST_HDRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000510ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_SRIOX_IMSG_PKINDX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800C8000620ull) + (((offset) & 1) + ((block_id) & 1) * 0x200000ull) * 8;
 }
 #else
-#define CVMX_SRIOX_IMSG_INST_HDRX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000510ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8)
+#define CVMX_SRIOX_IMSG_PKINDX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000620ull) + (((offset) & 1) + ((block_id) & 1) * 0x200000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_IMSG_PRT1_HDR(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_IMSG_PRT1_HDR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000638ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_IMSG_PRT1_HDR(offset) (CVMX_ADD_IO_SEG(0x00011800C8000638ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IMSG_QOS_GRPX(unsigned long offset, unsigned long block_id)
@@ -153,7 +279,8 @@ static inline uint64_t CVMX_SRIOX_IMSG_STATUSX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 23)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 23)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 23)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 23)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_IMSG_STATUSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000700ull) + (((offset) & 31) + ((block_id) & 3) * 0x200000ull) * 8;
 }
@@ -163,14 +290,36 @@ static inline uint64_t CVMX_SRIOX_IMSG_STATUSX(unsigned long offset, unsigned lo
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 3) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0) || ((offset >= 2) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C8000600ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000600ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IMSG_VPORT_THR(offset) (CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 3) * 0x1000000ull)
+static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C8000600ull) + (offset) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800C8000600ull) + (offset) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR2(unsigned long offset)
@@ -224,7 +373,8 @@ static inline uint64_t CVMX_SRIOX_INT_INFO0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_INT_INFO0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000120ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -236,7 +386,8 @@ static inline uint64_t CVMX_SRIOX_INT_INFO1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_INT_INFO1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000128ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -248,7 +399,8 @@ static inline uint64_t CVMX_SRIOX_INT_INFO2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_INT_INFO2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000130ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -260,7 +412,8 @@ static inline uint64_t CVMX_SRIOX_INT_INFO3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_INT_INFO3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000138ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -272,7 +425,8 @@ static inline uint64_t CVMX_SRIOX_INT_REG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_INT_REG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -280,11 +434,23 @@ static inline uint64_t CVMX_SRIOX_INT_REG(unsigned long offset)
 #define CVMX_SRIOX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_INT_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_INT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_INT_W1S(offset) (CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IP_FEATURE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_IP_FEATURE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C80003F8ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -296,7 +462,8 @@ static inline uint64_t CVMX_SRIOX_MAC_BUFFERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_MAC_BUFFERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000390ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -308,7 +475,8 @@ static inline uint64_t CVMX_SRIOX_MAINT_OP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_MAINT_OP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000158ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -320,7 +488,8 @@ static inline uint64_t CVMX_SRIOX_MAINT_RD_DATA(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_MAINT_RD_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000160ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -332,7 +501,8 @@ static inline uint64_t CVMX_SRIOX_MCE_TX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_MCE_TX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000240ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -344,7 +514,8 @@ static inline uint64_t CVMX_SRIOX_MEM_OP_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_MEM_OP_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000168ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -356,7 +527,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_CTRLX(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_CTRLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000488ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -368,7 +540,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_DONE_COUNTSX(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_DONE_COUNTSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C80004B0ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -380,7 +553,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_FMP_MRX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_FMP_MRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000498ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -392,7 +566,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_NMP_MRX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_NMP_MRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C80004A0ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -404,7 +579,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_PORTX(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_PORTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000480ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -416,7 +592,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_SILO_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_OMSG_SILO_THR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C80004F8ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -428,7 +605,8 @@ static inline uint64_t CVMX_SRIOX_OMSG_SP_MRX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_OMSG_SP_MRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000490ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64;
 }
@@ -440,7 +618,8 @@ static inline uint64_t CVMX_SRIOX_PRIOX_IN_USE(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_PRIOX_IN_USE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C80003C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
 }
@@ -452,7 +631,8 @@ static inline uint64_t CVMX_SRIOX_RX_BELL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_RX_BELL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -460,11 +640,23 @@ static inline uint64_t CVMX_SRIOX_RX_BELL(unsigned long offset)
 #define CVMX_SRIOX_RX_BELL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SRIOX_RX_BELL_CTRL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRIOX_RX_BELL_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000318ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_SRIOX_RX_BELL_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000318ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_RX_BELL_SEQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_RX_BELL_SEQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000300ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -476,7 +668,8 @@ static inline uint64_t CVMX_SRIOX_RX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_RX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000380ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -488,7 +681,8 @@ static inline uint64_t CVMX_SRIOX_S2M_TYPEX(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 15)) && ((block_id == 0) || (block_id == 2) || (block_id == 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 15)) && ((block_id == 0) || (block_id == 2) || (block_id == 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_SRIOX_S2M_TYPEX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C8000180ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 }
@@ -500,7 +694,8 @@ static inline uint64_t CVMX_SRIOX_SEQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_SEQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000278ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -512,7 +707,8 @@ static inline uint64_t CVMX_SRIOX_STATUS_REG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_STATUS_REG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000100ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -524,7 +720,8 @@ static inline uint64_t CVMX_SRIOX_TAG_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TAG_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000178ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -536,7 +733,8 @@ static inline uint64_t CVMX_SRIOX_TLP_CREDITS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000150ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -548,7 +746,8 @@ static inline uint64_t CVMX_SRIOX_TX_BELL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TX_BELL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000280ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -560,7 +759,8 @@ static inline uint64_t CVMX_SRIOX_TX_BELL_INFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TX_BELL_INFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000288ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -572,7 +772,8 @@ static inline uint64_t CVMX_SRIOX_TX_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TX_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000170ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -596,7 +797,8 @@ static inline uint64_t CVMX_SRIOX_TX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_TX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000388ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -608,7 +810,8 @@ static inline uint64_t CVMX_SRIOX_WR_DONE_COUNTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SRIOX_WR_DONE_COUNTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C8000340ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -619,39 +822,33 @@ static inline uint64_t CVMX_SRIOX_WR_DONE_COUNTS(unsigned long offset)
 /**
  * cvmx_srio#_acc_ctrl
  *
- * SRIO_ACC_CTRL = SRIO Access Control
+ * This register controls write access to the BAR registers via SRIO Maintenance Operations.
+ * At powerup the BAR registers can be accessed via RSL and Maintenance Operations.  If the
+ * DENY_BAR* bits or DENY_ADR* bits are set then Maintenance Writes to the corresponding BAR
+ * fields are ignored.  This register does not effect read operations.  Reset values for
+ * DENY_BAR[2:0] are typically clear but they are set if the chip is operating in Authentik
+ * Mode.
  *
- * General access control of the incoming BAR registers.
- *
- * Notes:
- * This register controls write access to the BAR registers via SRIO Maintenance Operations.  At
- *  powerup the BAR registers can be accessed via RSL and Maintenance Operations.  If the DENY_BAR*
- *  bits or DENY_ADR* bits are set then Maintenance Writes to the corresponding BAR fields are
- *  ignored.  Setting both the DENY_BAR and DENY_ADR for a corresponding BAR is compatable with the
- *  operation of the DENY_BAR bit found in 63xx Pass 2 and earlier.  This register does not effect
- *  read operations.  Reset values for DENY_BAR[2:0] are typically clear but they are set if
- *  the chip is operating in Authentik Mode.
- *
- * Clk_Rst:        SRIO(0,2..3)_ACC_CTRL   hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_acc_ctrl {
 	uint64_t u64;
 	struct cvmx_sriox_acc_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t deny_adr2                    : 1;  /**< Deny SRIO Write Access to SRIO Address Fields in
-                                                         SRIOMAINT(0,2..3)_BAR2* Registers */
-	uint64_t deny_adr1                    : 1;  /**< Deny SRIO Write Access to SRIO Address Fields in
-                                                         SRIOMAINT(0,2..3)_BAR1* Registers */
-	uint64_t deny_adr0                    : 1;  /**< Deny SRIO Write Access to SRIO Address Fields in
-                                                         SRIOMAINT(0,2..3)_BAR0* Registers */
+	uint64_t deny_adr2                    : 1;  /**< Deny SRIO write access to SRIO address fields in
+                                                         SRIOMAINT()_BAR2* registers. */
+	uint64_t deny_adr1                    : 1;  /**< Deny SRIO write access to SRIO address fields in
+                                                         SRIOMAINT()_BAR1* registers. */
+	uint64_t deny_adr0                    : 1;  /**< Deny SRIO write access to SRIO address fields in
+                                                         SRIOMAINT()_BAR0* registers. */
 	uint64_t reserved_3_3                 : 1;
-	uint64_t deny_bar2                    : 1;  /**< Deny SRIO Write Access to non-SRIO Address Fields
-                                                         in the SRIOMAINT_BAR2 Registers */
-	uint64_t deny_bar1                    : 1;  /**< Deny SRIO Write Access to non-SRIO Address Fields
-                                                         in the SRIOMAINT_BAR1 Registers */
-	uint64_t deny_bar0                    : 1;  /**< Deny SRIO Write Access to non-SRIO Address Fields
-                                                         in the SRIOMAINT_BAR0 Registers */
+	uint64_t deny_bar2                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
+                                                         in the SRIOMAINT_BAR2 registers. */
+	uint64_t deny_bar1                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
+                                                         in the SRIOMAINT_BAR1 registers. */
+	uint64_t deny_bar0                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
+                                                         in the SRIOMAINT_BAR0 registers. */
 #else
 	uint64_t deny_bar0                    : 1;
 	uint64_t deny_bar1                    : 1;
@@ -678,30 +875,28 @@ union cvmx_sriox_acc_ctrl {
 	} cn63xx;
 	struct cvmx_sriox_acc_ctrl_cn63xx     cn63xxp1;
 	struct cvmx_sriox_acc_ctrl_s          cn66xx;
+	struct cvmx_sriox_acc_ctrl_s          cn75xx;
 };
 typedef union cvmx_sriox_acc_ctrl cvmx_sriox_acc_ctrl_t;
 
 /**
  * cvmx_srio#_asmbly_id
  *
- * SRIO_ASMBLY_ID = SRIO Assembly ID
+ * This register specifies the assembly ID and vendor visible in the
+ * SRIOMAINT()_ASMBLY_ID register.  The assembly vendor ID is typically
+ * supplied by the RapidIO Trade Association.  This register is only
+ * reset during COLD boot and may only be modified while SRIO()_STATUS_REG[ACCESS]
+ * is zero.
  *
- * The Assembly ID register controls the Assembly ID and Vendor
- *
- * Notes:
- * This register specifies the Assembly ID and Vendor visible in SRIOMAINT(0,2..3)_ASMBLY_ID register.  The
- *  Assembly Vendor ID is typically supplied by the RapidIO Trade Association.  This register is only
- *  reset during COLD boot and may only be modified while SRIO(0,2..3)_STATUS_REG.ACCESS is zero.
- *
- * Clk_Rst:        SRIO(0,2..3)_ASMBLY_ID  sclk    srst_cold_n
+ * This register is reset by the coprocessor-clock cold reset.
  */
 union cvmx_sriox_asmbly_id {
 	uint64_t u64;
 	struct cvmx_sriox_asmbly_id_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t assy_id                      : 16; /**< Assembly Identifer */
-	uint64_t assy_ven                     : 16; /**< Assembly Vendor Identifer */
+	uint64_t assy_id                      : 16; /**< Assembly identifer. */
+	uint64_t assy_ven                     : 16; /**< Assembly vendor identifer. */
 #else
 	uint64_t assy_ven                     : 16;
 	uint64_t assy_id                      : 16;
@@ -711,29 +906,26 @@ union cvmx_sriox_asmbly_id {
 	struct cvmx_sriox_asmbly_id_s         cn63xx;
 	struct cvmx_sriox_asmbly_id_s         cn63xxp1;
 	struct cvmx_sriox_asmbly_id_s         cn66xx;
+	struct cvmx_sriox_asmbly_id_s         cn75xx;
 };
 typedef union cvmx_sriox_asmbly_id cvmx_sriox_asmbly_id_t;
 
 /**
  * cvmx_srio#_asmbly_info
  *
- * SRIO_ASMBLY_INFO = SRIO Assembly Information
+ * The Assembly Info register controls the assembly revision visible in the
+ * ASSY_REV field of the SRIOMAINT()_ASMBLY_INFO register.  This register is
+ * only reset during COLD boot and may only be modified while SRIO()_STATUS_REG[ACCESS]
+ * is zero.
  *
- * The Assembly Info register controls the Assembly Revision
- *
- * Notes:
- * The Assembly Info register controls the Assembly Revision visible in the ASSY_REV field of the
- *  SRIOMAINT(0,2..3)_ASMBLY_INFO register.  This register is only reset during COLD boot and may only be
- *  modified while SRIO(0,2..3)_STATUS_REG.ACCESS is zero.
- *
- * Clk_Rst:        SRIO(0,2..3)_ASMBLY_INFO        sclk    srst_cold_n
+ * This register is reset by the coprocessor-clock cold reset.
  */
 union cvmx_sriox_asmbly_info {
 	uint64_t u64;
 	struct cvmx_sriox_asmbly_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t assy_rev                     : 16; /**< Assembly Revision */
+	uint64_t assy_rev                     : 16; /**< Assembly revision. */
 	uint64_t reserved_0_15                : 16;
 #else
 	uint64_t reserved_0_15                : 16;
@@ -744,20 +936,74 @@ union cvmx_sriox_asmbly_info {
 	struct cvmx_sriox_asmbly_info_s       cn63xx;
 	struct cvmx_sriox_asmbly_info_s       cn63xxp1;
 	struct cvmx_sriox_asmbly_info_s       cn66xx;
+	struct cvmx_sriox_asmbly_info_s       cn75xx;
 };
 typedef union cvmx_sriox_asmbly_info cvmx_sriox_asmbly_info_t;
 
 /**
+ * cvmx_srio#_bell_lookup#
+ *
+ * The QOS/GRP table contains 16 entries with 16 QOS/GRP pairs
+ * per entry 256 pairs total.  HW selects the FIFO by using the
+ * fields determined by the SRIO_BELL_SELECT register to parse
+ * the doorbell packet.  The actual FIFO number selected is limited
+ * by the SRIO()_RX_BELL_CTRL[NUM_FIFO].
+ * For example, if NUM_FIFO has a value of 011 (4 FIFOs) then only
+ * the two LSBs of the FIFO number stored in the SRIO_BELL_LOOKUP are
+ * used.
+ *
+ * This register is reset by the h-clock reset.
+ */
+union cvmx_sriox_bell_lookupx {
+	uint64_t u64;
+	struct cvmx_sriox_bell_lookupx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t entry15                      : 4;  /**< FIFO number addressed by IDX=15. */
+	uint64_t entry14                      : 4;  /**< FIFO number addressed by IDX=14. */
+	uint64_t entry13                      : 4;  /**< FIFO number addressed by IDX=13. */
+	uint64_t entry12                      : 4;  /**< FIFO number addressed by IDX=12. */
+	uint64_t entry11                      : 4;  /**< FIFO number addressed by IDX=11. */
+	uint64_t entry10                      : 4;  /**< FIFO number addressed by IDX=10. */
+	uint64_t entry9                       : 4;  /**< FIFO number addressed by IDX=9. */
+	uint64_t entry8                       : 4;  /**< FIFO number addressed by IDX=8. */
+	uint64_t entry7                       : 4;  /**< FIFO number addressed by IDX=7. */
+	uint64_t entry6                       : 4;  /**< FIFO number addressed by IDX=6. */
+	uint64_t entry5                       : 4;  /**< FIFO number addressed by IDX=5. */
+	uint64_t entry4                       : 4;  /**< FIFO number addressed by IDX=4. */
+	uint64_t entry3                       : 4;  /**< FIFO number addressed by IDX=3. */
+	uint64_t entry2                       : 4;  /**< FIFO number addressed by IDX=2. */
+	uint64_t entry1                       : 4;  /**< FIFO number addressed by IDX=1. */
+	uint64_t entry0                       : 4;  /**< FIFO number addressed by IDX=0. */
+#else
+	uint64_t entry0                       : 4;
+	uint64_t entry1                       : 4;
+	uint64_t entry2                       : 4;
+	uint64_t entry3                       : 4;
+	uint64_t entry4                       : 4;
+	uint64_t entry5                       : 4;
+	uint64_t entry6                       : 4;
+	uint64_t entry7                       : 4;
+	uint64_t entry8                       : 4;
+	uint64_t entry9                       : 4;
+	uint64_t entry10                      : 4;
+	uint64_t entry11                      : 4;
+	uint64_t entry12                      : 4;
+	uint64_t entry13                      : 4;
+	uint64_t entry14                      : 4;
+	uint64_t entry15                      : 4;
+#endif
+	} s;
+	struct cvmx_sriox_bell_lookupx_s      cn75xx;
+};
+typedef union cvmx_sriox_bell_lookupx cvmx_sriox_bell_lookupx_t;
+
+/**
  * cvmx_srio#_bell_resp_ctrl
  *
- * SRIO_BELL_RESP_CTRL = SRIO Doorbell Response Control
- *
- * The SRIO Doorbell Response Control Register
+ * This register is used to override the response priority of the outgoing
+ * doorbell responses.
  *
- * Notes:
- * This register is used to override the response priority of the outgoing doorbell responses.
- *
- * Clk_Rst:        SRIO(0,2..3)_BELL_RESP_CTRL     hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_bell_resp_ctrl {
 	uint64_t u64;
@@ -765,13 +1011,13 @@ union cvmx_sriox_bell_resp_ctrl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t rp1_sid                      : 1;  /**< Sets response priority for incomimg doorbells
-                                                         of priority 1 on the secondary ID (0=2, 1=3) */
+                                                         of priority 1 on the secondary ID (0=2, 1=3). */
 	uint64_t rp0_sid                      : 2;  /**< Sets response priority for incomimg doorbells
-                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3). */
 	uint64_t rp1_pid                      : 1;  /**< Sets response priority for incomimg doorbells
-                                                         of priority 1 on the primary ID (0=2, 1=3) */
+                                                         of priority 1 on the primary ID (0=2, 1=3). */
 	uint64_t rp0_pid                      : 2;  /**< Sets response priority for incomimg doorbells
-                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3). */
 #else
 	uint64_t rp0_pid                      : 2;
 	uint64_t rp1_pid                      : 1;
@@ -783,20 +1029,75 @@ union cvmx_sriox_bell_resp_ctrl {
 	struct cvmx_sriox_bell_resp_ctrl_s    cn63xx;
 	struct cvmx_sriox_bell_resp_ctrl_s    cn63xxp1;
 	struct cvmx_sriox_bell_resp_ctrl_s    cn66xx;
+	struct cvmx_sriox_bell_resp_ctrl_s    cn75xx;
 };
 typedef union cvmx_sriox_bell_resp_ctrl cvmx_sriox_bell_resp_ctrl_t;
 
 /**
- * cvmx_srio#_bist_status
+ * cvmx_srio#_bell_select
  *
- * SRIO_BIST_STATUS = SRIO Bist Status
+ * This register is used select which bits in the doorbell packet
+ * are used to provide the 4 bit address and 4 bit index into the
+ * lookup table specified in SRIO()_BELL_LOOKUP[0:15].  Each address
+ * and index has a 6-bit selector to pick a bit out of the incoming
+ * doorbell using the following:
  *
- * Results from BIST runs of SRIO's memories.
+ *   35-34  Doorbell Priority [1:0]
+ *   33       Secondary ID (1=Packet Matched Enabled Secondary ID8 or ID16)
+ *   32       ID8/ID16 bit (1=Packet used 16-bit Device IDs)
+ *   31-16  Source ID [15:0]
+ *   15-0   Doorbell Payload [15:0]
  *
- * Notes:
- * BIST Results.
+ * This register is reset by the h-clock reset.
+ */
+union cvmx_sriox_bell_select {
+	uint64_t u64;
+	struct cvmx_sriox_bell_select_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t addr3                        : 6;  /**< Selector for address 3. */
+	uint64_t reserved_54_55               : 2;
+	uint64_t addr2                        : 6;  /**< Selector for address 2. */
+	uint64_t reserved_46_47               : 2;
+	uint64_t addr1                        : 6;  /**< Selector for address 1. */
+	uint64_t reserved_38_39               : 2;
+	uint64_t addr0                        : 6;  /**< Selector for address 0. */
+	uint64_t reserved_30_31               : 2;
+	uint64_t idx3                         : 6;  /**< Selector for index 3. */
+	uint64_t reserved_22_23               : 2;
+	uint64_t idx2                         : 6;  /**< Selector for index 2. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t idx1                         : 6;  /**< Selector for index 1. */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t idx0                         : 6;  /**< Selector for index 0. */
+#else
+	uint64_t idx0                         : 6;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t idx1                         : 6;
+	uint64_t reserved_14_15               : 2;
+	uint64_t idx2                         : 6;
+	uint64_t reserved_22_23               : 2;
+	uint64_t idx3                         : 6;
+	uint64_t reserved_30_31               : 2;
+	uint64_t addr0                        : 6;
+	uint64_t reserved_38_39               : 2;
+	uint64_t addr1                        : 6;
+	uint64_t reserved_46_47               : 2;
+	uint64_t addr2                        : 6;
+	uint64_t reserved_54_55               : 2;
+	uint64_t addr3                        : 6;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} s;
+	struct cvmx_sriox_bell_select_s       cn75xx;
+};
+typedef union cvmx_sriox_bell_select cvmx_sriox_bell_select_t;
+
+/**
+ * cvmx_srio#_bist_status
+ *
+ * Results from BIST runs of SRIO's memories.
  *
- * Clk_Rst:        SRIO(0,2..3)_BIST_STATUS        hclk    hrst_n
  */
 union cvmx_sriox_bist_status {
 	uint64_t u64;
@@ -810,17 +1111,40 @@ union cvmx_sriox_bist_status {
 	uint64_t otag                         : 2;  /**< Outgoing Tag Data. */
 	uint64_t itag                         : 1;  /**< Incoming TAG Data. */
 	uint64_t ofree                        : 1;  /**< Outgoing Free Pointer RAM (OFIFO) */
+	uint64_t reserved_0_33                : 34;
+#else
+	uint64_t reserved_0_33                : 34;
+	uint64_t ofree                        : 1;
+	uint64_t itag                         : 1;
+	uint64_t otag                         : 2;
+	uint64_t bell                         : 2;
+	uint64_t cram                         : 2;
+	uint64_t mram                         : 2;
+	uint64_t lram                         : 1;
+	uint64_t reserved_45_63               : 19;
+#endif
+	} s;
+	struct cvmx_sriox_bist_status_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_44_63               : 20;
+	uint64_t mram                         : 2;  /**< Incoming Message SLI FIFO. */
+	uint64_t cram                         : 2;  /**< Incoming Rd/Wr/Response Command FIFO. */
+	uint64_t bell                         : 2;  /**< Incoming Doorbell FIFO. */
+	uint64_t otag                         : 2;  /**< Outgoing Tag Data. */
+	uint64_t itag                         : 1;  /**< Incoming TAG Data. */
+	uint64_t ofree                        : 1;  /**< Outgoing Free Pointer RAM (OFIFO) */
 	uint64_t rtn                          : 2;  /**< Outgoing Response Return FIFO. */
 	uint64_t obulk                        : 4;  /**< Outgoing Bulk Data RAMs (OFIFO) */
 	uint64_t optrs                        : 4;  /**< Outgoing Priority Pointer RAMs (OFIFO) */
-	uint64_t oarb2                        : 2;  /**< Additional Outgoing Priority RAMs. */
-	uint64_t rxbuf2                       : 2;  /**< Additional Incoming SRIO MAC Buffers. */
+	uint64_t oarb2                        : 2;  /**< Additional Outgoing Priority RAMs (Pass 2). */
+	uint64_t rxbuf2                       : 2;  /**< Additional Incoming SRIO MAC Buffers (Pass 2). */
 	uint64_t oarb                         : 2;  /**< Outgoing Priority RAMs (OARB) */
 	uint64_t ispf                         : 1;  /**< Incoming Soft Packet FIFO */
 	uint64_t ospf                         : 1;  /**< Outgoing Soft Packet FIFO */
 	uint64_t txbuf                        : 2;  /**< Outgoing SRIO MAC Buffer. */
 	uint64_t rxbuf                        : 2;  /**< Incoming SRIO MAC Buffer. */
-	uint64_t imsg                         : 5;  /**< Incoming Message RAMs. */
+	uint64_t imsg                         : 5;  /**< Incoming Message RAMs.
+                                                         IMSG<0> (i.e. <7>) unused in Pass 2 */
 	uint64_t omsg                         : 7;  /**< Outgoing Message RAMs. */
 #else
 	uint64_t omsg                         : 7;
@@ -841,11 +1165,10 @@ union cvmx_sriox_bist_status {
 	uint64_t bell                         : 2;
 	uint64_t cram                         : 2;
 	uint64_t mram                         : 2;
-	uint64_t lram                         : 1;
-	uint64_t reserved_45_63               : 19;
+	uint64_t reserved_44_63               : 20;
 #endif
-	} s;
-	struct cvmx_sriox_bist_status_cn63xx {
+	} cn63xx;
+	struct cvmx_sriox_bist_status_cn63xxp1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
 	uint64_t mram                         : 2;  /**< Incoming Message SLI FIFO. */
@@ -857,15 +1180,13 @@ union cvmx_sriox_bist_status {
 	uint64_t rtn                          : 2;  /**< Outgoing Response Return FIFO. */
 	uint64_t obulk                        : 4;  /**< Outgoing Bulk Data RAMs (OFIFO) */
 	uint64_t optrs                        : 4;  /**< Outgoing Priority Pointer RAMs (OFIFO) */
-	uint64_t oarb2                        : 2;  /**< Additional Outgoing Priority RAMs (Pass 2). */
-	uint64_t rxbuf2                       : 2;  /**< Additional Incoming SRIO MAC Buffers (Pass 2). */
+	uint64_t reserved_20_23               : 4;
 	uint64_t oarb                         : 2;  /**< Outgoing Priority RAMs (OARB) */
 	uint64_t ispf                         : 1;  /**< Incoming Soft Packet FIFO */
 	uint64_t ospf                         : 1;  /**< Outgoing Soft Packet FIFO */
 	uint64_t txbuf                        : 2;  /**< Outgoing SRIO MAC Buffer. */
 	uint64_t rxbuf                        : 2;  /**< Incoming SRIO MAC Buffer. */
-	uint64_t imsg                         : 5;  /**< Incoming Message RAMs.
-                                                         IMSG<0> (i.e. <7>) unused in Pass 2 */
+	uint64_t imsg                         : 5;  /**< Incoming Message RAMs. */
 	uint64_t omsg                         : 7;  /**< Outgoing Message RAMs. */
 #else
 	uint64_t omsg                         : 7;
@@ -875,8 +1196,7 @@ union cvmx_sriox_bist_status {
 	uint64_t ospf                         : 1;
 	uint64_t ispf                         : 1;
 	uint64_t oarb                         : 2;
-	uint64_t rxbuf2                       : 2;
-	uint64_t oarb2                        : 2;
+	uint64_t reserved_20_23               : 4;
 	uint64_t optrs                        : 4;
 	uint64_t obulk                        : 4;
 	uint64_t rtn                          : 2;
@@ -888,10 +1208,11 @@ union cvmx_sriox_bist_status {
 	uint64_t mram                         : 2;
 	uint64_t reserved_44_63               : 20;
 #endif
-	} cn63xx;
-	struct cvmx_sriox_bist_status_cn63xxp1 {
+	} cn63xxp1;
+	struct cvmx_sriox_bist_status_cn66xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_44_63               : 20;
+	uint64_t reserved_45_63               : 19;
+	uint64_t lram                         : 1;  /**< Incoming Doorbell Lookup RAM. */
 	uint64_t mram                         : 2;  /**< Incoming Message SLI FIFO. */
 	uint64_t cram                         : 2;  /**< Incoming Rd/Wr/Response Command FIFO. */
 	uint64_t bell                         : 2;  /**< Incoming Doorbell FIFO. */
@@ -901,7 +1222,8 @@ union cvmx_sriox_bist_status {
 	uint64_t rtn                          : 2;  /**< Outgoing Response Return FIFO. */
 	uint64_t obulk                        : 4;  /**< Outgoing Bulk Data RAMs (OFIFO) */
 	uint64_t optrs                        : 4;  /**< Outgoing Priority Pointer RAMs (OFIFO) */
-	uint64_t reserved_20_23               : 4;
+	uint64_t oarb2                        : 2;  /**< Additional Outgoing Priority RAMs. */
+	uint64_t rxbuf2                       : 2;  /**< Additional Incoming SRIO MAC Buffers. */
 	uint64_t oarb                         : 2;  /**< Outgoing Priority RAMs (OARB) */
 	uint64_t ispf                         : 1;  /**< Incoming Soft Packet FIFO */
 	uint64_t ospf                         : 1;  /**< Outgoing Soft Packet FIFO */
@@ -917,7 +1239,8 @@ union cvmx_sriox_bist_status {
 	uint64_t ospf                         : 1;
 	uint64_t ispf                         : 1;
 	uint64_t oarb                         : 2;
-	uint64_t reserved_20_23               : 4;
+	uint64_t rxbuf2                       : 2;
+	uint64_t oarb2                        : 2;
 	uint64_t optrs                        : 4;
 	uint64_t obulk                        : 4;
 	uint64_t rtn                          : 2;
@@ -927,24 +1250,202 @@ union cvmx_sriox_bist_status {
 	uint64_t bell                         : 2;
 	uint64_t cram                         : 2;
 	uint64_t mram                         : 2;
-	uint64_t reserved_44_63               : 20;
+	uint64_t lram                         : 1;
+	uint64_t reserved_45_63               : 19;
 #endif
-	} cn63xxp1;
-	struct cvmx_sriox_bist_status_s       cn66xx;
+	} cn66xx;
+	struct cvmx_sriox_bist_status_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_34_63               : 30;
+	uint64_t status                       : 34; /**< Bist status set bit indicates failure.
+                                                         INTERNAL:
+                                                         33 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
+                                                         32 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
+                                                         31 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
+                                                         30 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
+                                                         29 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
+                                                         28 = fc.core.roc.srio.sli.idec.lram.
+                                                         27 = fc.core.roc.srio.sli.ififo.mram0.
+                                                         26 = fc.core.roc.srio.sli.ififo.mram.
+                                                         25 = fc.core.roc.srio.sli.ififo.cram.
+                                                         24 = fc.core.roc.srio.sli.ififo.bell.dbell_mem.
+                                                         23 = fc.core.roc.srio.sli.tag.otag.
+                                                         22 = fc.core.roc.srio.sli.tag.itag.
+                                                         21 = fc.core.roc.srio.sli.ofifo.hs_pfifo.sram.
+                                                         20 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
+                                                         19 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
+                                                         18 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
+                                                         17 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
+                                                         16 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
+                                                         15 = fc.core.roc.srio.sli.ofifo.sh_pfifo3.sram.
+                                                         14 = fc.core.roc.srio.sli.ofifo.sh_pfifo2.sram.
+                                                         13 = fc.core.roc.srio.sli.ofifo.sh_pfifo1.sram.
+                                                         12 = fc.core.roc.srio.sli.ofifo.sh_pfifo0.sram.
+                                                         11 = fc.core.roc.srio.sli.oarb.cmd_fifo.m1.
+                                                         10 = fc.core.roc.srio.sli.oarb.cmd_fifo.m0.
+                                                         9 = fc.core.roc.srio.omsg.sil.mem.
+                                                         8 = fc.core.roc.srio.omsg.fif1.mem2.
+                                                         7 = fc.core.roc.srio.omsg.fif1.mem0_l.
+                                                         6 = fc.core.roc.srio.omsg.fif1.mem0_h.
+                                                         5 = fc.core.roc.srio.omsg.fif0.mem2.
+                                                         4 = fc.core.roc.srio.omsg.fif0.mem0_l.
+                                                         3 = fc.core.roc.srio.omsg.fif0.mem0_h.
+                                                         2 = fc.core.roc.srio.imsg.pre.dat_mem.
+                                                         1 = fc.core.roc.srio.imsg.pre.hdr_mem.
+                                                         0 = fc.core.roc.srio.imsg.pre.csr_mem. */
+#else
+	uint64_t status                       : 34;
+	uint64_t reserved_34_63               : 30;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_bist_status cvmx_sriox_bist_status_t;
 
 /**
- * cvmx_srio#_imsg_ctrl
+ * cvmx_srio#_ecc_ctrl
  *
- * SRIO_IMSG_CTRL = SRIO Incoming Message Control
+ * ECC Diagnostic Control Register
  *
- * The SRIO Incoming Message Control Register
+ */
+union cvmx_sriox_ecc_ctrl {
+	uint64_t u64;
+	struct cvmx_sriox_ecc_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ecc_dis                      : 1;  /**< Disable ECC Checking on all SRIO internal memories.
+                                                         Typically set to zero. */
+	uint64_t reserved_44_62               : 19;
+	uint64_t flip                         : 44; /**< Error Insertion Bits for ECC syndromes.  Two per RAM.  Typically set to zero.
+                                                          INTERNAL:
+                                                          - 43:42 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
+                                                          - 41:40 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
+                                                          - 39:38 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
+                                                          - 37:36 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
+                                                          - 35:34 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
+                                                          - 33:32 = fc.core.roc.srio.sli.tag.otag.
+                                                          - 31:30 = fc.core.roc.srio.sli.tag.itag.
+                                                          - 29:28 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
+                                                          - 27:26 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
+                                                          - 25:24 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
+                                                          - 23:22 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
+                                                          - 21:20 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
+                                                          - 19:18 = fc.core.roc.srio.sli.oarb.cmd_fifo.m1.
+                                                          - 17:16 = fc.core.roc.srio.sli.oarb.cmd_fifo.m0.
+                                                          - 15:14 = fc.core.roc.srio.omsg.sil.mem.
+                                                          - 13:12 = fc.core.roc.srio.omsg.fif1.mem2.
+                                                          - 11:10 = fc.core.roc.srio.omsg.fif1.mem0_l.
+                                                         - 9:8   = fc.core.roc.srio.omsg.fif1.mem0_h.
+                                                         - 7:6   = fc.core.roc.srio.omsg.fif0.mem2.
+                                                         - 5:4   = fc.core.roc.srio.omsg.fif0.mem0_l.
+                                                         - 3:2   = fc.core.roc.srio.omsg.fif0.mem0_h.
+                                                         - 1:0   = fc.core.roc.srio.imsg.pre.csr_mem. */
+#else
+	uint64_t flip                         : 44;
+	uint64_t reserved_44_62               : 19;
+	uint64_t ecc_dis                      : 1;
+#endif
+	} s;
+	struct cvmx_sriox_ecc_ctrl_s          cn75xx;
+};
+typedef union cvmx_sriox_ecc_ctrl cvmx_sriox_ecc_ctrl_t;
+
+/**
+ * cvmx_srio#_ecc_status
  *
- * Notes:
- * RSP_THR should not typically be modified from reset value.
+ * List of detected ECC failures.
+ *
+ */
+union cvmx_sriox_ecc_status {
+	uint64_t u64;
+	struct cvmx_sriox_ecc_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_54_63               : 10;
+	uint64_t dbe                          : 22; /**< Double Bit Error detected.  Set bit indicates failure.
+                                                         INTERNAL:
+                                                         53 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
+                                                         52 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
+                                                         51 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
+                                                         50 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
+                                                         49 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
+                                                         48 = fc.core.roc.srio.sli.tag.otag.
+                                                         47 = fc.core.roc.srio.sli.tag.itag.
+                                                         46 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
+                                                         45 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
+                                                         44 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
+                                                         43 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
+                                                         42 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
+                                                         41 = fc.core.roc.srio.sli.oarb.cmd_fifo.m1.
+                                                         40 = fc.core.roc.srio.sli.oarb.cmd_fifo.m0.
+                                                         39 = fc.core.roc.srio.omsg.sil.mem.
+                                                         38 = fc.core.roc.srio.omsg.fif1.mem2.
+                                                         37 = fc.core.roc.srio.omsg.fif1.mem0_l.
+                                                         36 = fc.core.roc.srio.omsg.fif1.mem0_h.
+                                                         35 = fc.core.roc.srio.omsg.fif0.mem2.
+                                                         34 = fc.core.roc.srio.omsg.fif0.mem0_l.
+                                                         33 = fc.core.roc.srio.omsg.fif0.mem0_h.
+                                                         32 = fc.core.roc.srio.imsg.pre.csr_mem. */
+	uint64_t reserved_22_31               : 10;
+	uint64_t sbe                          : 22; /**< Single Bit Error detected.  Set bit indicates failure.
+                                                         INTERNAL:
+                                                         21 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
+                                                         20 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
+                                                         19 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
+                                                         18 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
+                                                         17 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
+                                                         16 = fc.core.roc.srio.sli.tag.otag.
+                                                         15 = fc.core.roc.srio.sli.tag.itag.
+                                                         14 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
+                                                         13 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
+                                                         12 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
+                                                         11 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
+                                                         10 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
+                                                         9 = fc.core.roc.srio.sli.oarb.cmd_fifo.m1.
+                                                         8 = fc.core.roc.srio.sli.oarb.cmd_fifo.m0.
+                                                         7 = fc.core.roc.srio.omsg.sil.mem.
+                                                         6 = fc.core.roc.srio.omsg.fif1.mem2.
+                                                         5 = fc.core.roc.srio.omsg.fif1.mem0_l.
+                                                         4 = fc.core.roc.srio.omsg.fif1.mem0_h.
+                                                         3 = fc.core.roc.srio.omsg.fif0.mem2.
+                                                         2 = fc.core.roc.srio.omsg.fif0.mem0_l.
+                                                         1 = fc.core.roc.srio.omsg.fif0.mem0_h.
+                                                         0 = fc.core.roc.srio.imsg.pre.csr_mem. */
+#else
+	uint64_t sbe                          : 22;
+	uint64_t reserved_22_31               : 10;
+	uint64_t dbe                          : 22;
+	uint64_t reserved_54_63               : 10;
+#endif
+	} s;
+	struct cvmx_sriox_ecc_status_s        cn75xx;
+};
+typedef union cvmx_sriox_ecc_status cvmx_sriox_ecc_status_t;
+
+/**
+ * cvmx_srio#_eco
+ *
+ * Reserved.
+ *
+ * This register is reset by the h-clock reset.
+ */
+union cvmx_sriox_eco {
+	uint64_t u64;
+	struct cvmx_sriox_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< ECO flops. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_sriox_eco_s               cn75xx;
+};
+typedef union cvmx_sriox_eco cvmx_sriox_eco_t;
+
+/**
+ * cvmx_srio#_imsg_ctrl
+ *
+ * This register is reset by the h-clock reset.
  *
- * Clk_Rst:        SRIO(0,2..3)_IMSG_CTRL  hclk    hrst_n
  */
 union cvmx_sriox_imsg_ctrl {
 	uint64_t u64;
@@ -952,33 +1453,54 @@ union cvmx_sriox_imsg_ctrl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t to_mode                      : 1;  /**< MP message timeout mode:
-                                                         - 0: The timeout counter gets reset whenever the
-                                                             next sequential segment is received, regardless
-                                                             of whether it is accepted
-                                                         - 1: The timeout counter gets reset only when the
-                                                             next sequential segment is received and
-                                                             accepted */
+                                                         0 = The timeout counter gets reset whenever the
+                                                         next sequential segment is received, regardless
+                                                         of whether it is accepted.
+                                                         1 = The timeout counter gets reset only when the
+                                                         next sequential segment is received and
+                                                         accepted. */
 	uint64_t reserved_30_30               : 1;
-	uint64_t rsp_thr                      : 6;  /**< Reserved */
+	uint64_t rsp_thr                      : 6;  /**< Reserved. */
 	uint64_t reserved_22_23               : 2;
 	uint64_t rp1_sid                      : 1;  /**< Sets msg response priority for incomimg messages
-                                                         of priority 1 on the secondary ID (0=2, 1=3) */
+                                                         of priority 1 on the secondary ID (0=2, 1=3). */
 	uint64_t rp0_sid                      : 2;  /**< Sets msg response priority for incomimg messages
-                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3). */
 	uint64_t rp1_pid                      : 1;  /**< Sets msg response priority for incomimg messages
-                                                         of priority 1 on the primary ID (0=2, 1=3) */
+                                                         of priority 1 on the primary ID (0=2, 1=3). */
 	uint64_t rp0_pid                      : 2;  /**< Sets msg response priority for incomimg messages
-                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3). */
 	uint64_t reserved_15_15               : 1;
-	uint64_t prt_sel                      : 3;  /**< Port/Controller selection method:
-                                                         - 0: Table lookup based on mailbox
-                                                         - 1: Table lookup based on priority
-                                                         - 2: Table lookup based on letter
-                                                         - 3: Size-based (SP to port 0, MP to port 1)
-                                                         - 4: ID-based (pri ID to port 0, sec ID to port 1) */
-	uint64_t lttr                         : 4;  /**< Port/Controller selection letter table */
-	uint64_t prio                         : 4;  /**< Port/Controller selection priority table */
-	uint64_t mbox                         : 4;  /**< Port/Controller selection mailbox table */
+	uint64_t prt_sel                      : 3;  /**< Port/controller selection method:
+                                                         0x0 = Table lookup based on mailbox (See MBOX).
+                                                         0x1 = Table lookup based on priority (See PRIO).
+                                                         0x2 = Table lookup based on letter (See LTTR).
+                                                         0x3 = Size-based (SP to port 0, MP to port 1).
+                                                         0x4 = ID-based (pri ID to port 0, sec ID to port 1). */
+	uint64_t lttr                         : 4;  /**< Port/controller selection letter table.
+                                                         Type 11 Traffic Supports 4 Letters (A-D).
+                                                         0000 = All Letters to port 0.
+                                                         0001 = Letter A to port 1, others to port 0.
+                                                         - ....
+                                                         0101 = Letter A,C to port 1, others to port 0.
+                                                         - ....
+                                                         1111 = All Letters to port 1. */
+	uint64_t prio                         : 4;  /**< Port/controller selection priority table.
+                                                         SRIO Supports 4 Priorities (0-3).
+                                                         0000 = All Priorities to port 0.
+                                                         0001 = Priority 0 to port 1, others to port 0.
+                                                         - ....
+                                                         1001 = Priority 0,3 to port 1, others to port 0.
+                                                         - ....
+                                                         1111 = All Priorities to port 1. */
+	uint64_t mbox                         : 4;  /**< Port/controller selection mailbox table.
+                                                         TYpe 11 Traffic Supports 4 Mailboxes (0-3).
+                                                         0000 = All Mailboxes to port 0.
+                                                         0001 = Mailbox 0 to port 1, others to port 0.
+                                                         - ....
+                                                         0110 = Mailboxes 1,2 to port 1, others to port 0.
+                                                         - ....
+                                                         1111 = All Mailboxes to port 1. */
 #else
 	uint64_t mbox                         : 4;
 	uint64_t prio                         : 4;
@@ -999,28 +1521,35 @@ union cvmx_sriox_imsg_ctrl {
 	struct cvmx_sriox_imsg_ctrl_s         cn63xx;
 	struct cvmx_sriox_imsg_ctrl_s         cn63xxp1;
 	struct cvmx_sriox_imsg_ctrl_s         cn66xx;
+	struct cvmx_sriox_imsg_ctrl_s         cn75xx;
 };
 typedef union cvmx_sriox_imsg_ctrl cvmx_sriox_imsg_ctrl_t;
 
 /**
  * cvmx_srio#_imsg_inst_hdr#
  *
- * SRIO_IMSG_INST_HDRX = SRIO Incoming Message Packet Instruction Header
+ * SRIO HW generates the SRIO_WORD1 fields from this table.
+ * SRIO_WORD1 is the 2nd of two header words that SRIO inserts in
+ * front of all received messages. SRIO_WORD1 is commonly used
+ * as a PKI_INST_HDR. The actual header word used is indexed by
+ * the concatenation of SRIO_WORD0_E[TT,LETTER,PRIO,DIS,MBOX].
+ * If port 1 has been selected by SRIO(0..1)_IMSG_CTRL[PRT_SEL]
+ * then the SRIO(0..1)_IMSG_PRT1_XHDR is XOR'ed with the resulting
+ * header.
  *
- * The SRIO Port/Controller X Incoming Message Packet Instruction Header Register
- *
- * Notes:
- * SRIO HW generates most of the SRIO_WORD1 fields from these values. SRIO_WORD1 is the 2nd of two
- *  header words that SRIO inserts in front of all received messages. SRIO_WORD1 may commonly be used
- *  as a PIP/IPD PKT_INST_HDR. This CSR matches the PIP/IPD PKT_INST_HDR format except for the QOS
- *  and GRP fields. SRIO*_IMSG_QOS_GRP*[QOS*,GRP*] supply the QOS and GRP fields.
- *
- * Clk_Rst:        SRIO(0,2..3)_IMSG_INST_HDR[0:1] hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_imsg_inst_hdrx {
 	uint64_t u64;
 	struct cvmx_sriox_imsg_inst_hdrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_sriox_imsg_inst_hdrx_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t r                            : 1;  /**< Port/Controller X R */
 	uint64_t reserved_58_62               : 5;
 	uint64_t pm                           : 2;  /**< Port/Controller X PM */
@@ -1051,14 +1580,64 @@ union cvmx_sriox_imsg_inst_hdrx {
 	uint64_t reserved_58_62               : 5;
 	uint64_t r                            : 1;
 #endif
-	} s;
-	struct cvmx_sriox_imsg_inst_hdrx_s    cn63xx;
-	struct cvmx_sriox_imsg_inst_hdrx_s    cn63xxp1;
-	struct cvmx_sriox_imsg_inst_hdrx_s    cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_imsg_inst_hdrx_cn63xx cn63xxp1;
+	struct cvmx_sriox_imsg_inst_hdrx_cn63xx cn66xx;
+	struct cvmx_sriox_imsg_inst_hdrx_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t hdr                          : 64; /**< PKI Instruction Header word */
+#else
+	uint64_t hdr                          : 64;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_imsg_inst_hdrx cvmx_sriox_imsg_inst_hdrx_t;
 
 /**
+ * cvmx_srio#_imsg_pkind#
+ *
+ * This register is reset by the h-clock reset.
+ *
+ */
+union cvmx_sriox_imsg_pkindx {
+	uint64_t u64;
+	struct cvmx_sriox_imsg_pkindx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t pknd                         : 7;  /**< PKI port kind for this controller. */
+#else
+	uint64_t pknd                         : 7;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_sriox_imsg_pkindx_s       cn75xx;
+};
+typedef union cvmx_sriox_imsg_pkindx cvmx_sriox_imsg_pkindx_t;
+
+/**
+ * cvmx_srio#_imsg_prt1_hdr
+ *
+ * This register allows extra control in generating SRIO_WORD1 header
+ * information for message port 1.
+ *
+ * This register is reset by the h-clock reset.
+ */
+union cvmx_sriox_imsg_prt1_hdr {
+	uint64_t u64;
+	struct cvmx_sriox_imsg_prt1_hdr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t xhdr                         : 64; /**< The field provided is XOR'd with the value provided by SRIO(0..1)_IMSG_INST_HDR.
+                                                         The field is typically zero and is probably used only for cases when message port
+                                                         is selected based on size (see SRIO(0..1)_IMSG_CTRL[PRT_SEL] = 3). */
+#else
+	uint64_t xhdr                         : 64;
+#endif
+	} s;
+	struct cvmx_sriox_imsg_prt1_hdr_s     cn75xx;
+};
+typedef union cvmx_sriox_imsg_prt1_hdr cvmx_sriox_imsg_prt1_hdr_t;
+
+/**
  * cvmx_srio#_imsg_qos_grp#
  *
  * SRIO_IMSG_QOS_GRPX = SRIO Incoming Message QOS/GRP Table
@@ -1139,42 +1718,37 @@ typedef union cvmx_sriox_imsg_qos_grpx cvmx_sriox_imsg_qos_grpx_t;
 /**
  * cvmx_srio#_imsg_status#
  *
- * SRIO_IMSG_STATUSX = SRIO Incoming Message Status Table
- *
- * The SRIO Incoming Message Status Table Entry X
- *
- * Notes:
- * Clk_Rst:        SRIO(0,2..3)_IMSG_STATUS[0:1]   hclk    hrst_n
+ * This register is reset by the h-clock reset.
  *
  */
 union cvmx_sriox_imsg_statusx {
 	uint64_t u64;
 	struct cvmx_sriox_imsg_statusx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t val1                         : 1;  /**< Entry X:1 Valid */
-	uint64_t err1                         : 1;  /**< Entry X:1 Error */
-	uint64_t toe1                         : 1;  /**< Entry X:1 Timeout Error */
-	uint64_t toc1                         : 1;  /**< Entry X:1 Timeout Count */
-	uint64_t prt1                         : 1;  /**< Entry X:1 Port */
+	uint64_t val1                         : 1;  /**< Entry 1 valid. */
+	uint64_t err1                         : 1;  /**< Entry 1 error. */
+	uint64_t toe1                         : 1;  /**< Entry 1 timeout error. */
+	uint64_t toc1                         : 1;  /**< Entry 1 timeout count. */
+	uint64_t prt1                         : 1;  /**< Entry 1 port. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t tt1                          : 1;  /**< Entry X:1 TT ID */
-	uint64_t dis1                         : 1;  /**< Entry X:1 Dest ID */
-	uint64_t seg1                         : 4;  /**< Entry X:1 Next Segment */
-	uint64_t mbox1                        : 2;  /**< Entry X:1 Mailbox */
-	uint64_t lttr1                        : 2;  /**< Entry X:1 Letter */
-	uint64_t sid1                         : 16; /**< Entry X:1 Source ID */
-	uint64_t val0                         : 1;  /**< Entry X:0 Valid */
-	uint64_t err0                         : 1;  /**< Entry X:0 Error */
-	uint64_t toe0                         : 1;  /**< Entry X:0 Timeout Error */
-	uint64_t toc0                         : 1;  /**< Entry X:0 Timeout Count */
-	uint64_t prt0                         : 1;  /**< Entry X:0 Port */
+	uint64_t tt1                          : 1;  /**< Entry 1 TT ID. */
+	uint64_t dis1                         : 1;  /**< Entry 1 Dest ID. */
+	uint64_t seg1                         : 4;  /**< Entry 1 next segment. */
+	uint64_t mbox1                        : 2;  /**< Entry 1 mailbox. */
+	uint64_t lttr1                        : 2;  /**< Entry 1 letter. */
+	uint64_t sid1                         : 16; /**< Entry 1 source ID. */
+	uint64_t val0                         : 1;  /**< Entry 0 valid. */
+	uint64_t err0                         : 1;  /**< Entry 0 error. */
+	uint64_t toe0                         : 1;  /**< Entry 0 timeout error. */
+	uint64_t toc0                         : 1;  /**< Entry 0 timeout count. */
+	uint64_t prt0                         : 1;  /**< Entry 0 port. */
 	uint64_t reserved_26_26               : 1;
-	uint64_t tt0                          : 1;  /**< Entry X:0 TT ID */
-	uint64_t dis0                         : 1;  /**< Entry X:0 Dest ID */
-	uint64_t seg0                         : 4;  /**< Entry X:0 Next Segment */
-	uint64_t mbox0                        : 2;  /**< Entry X:0 Mailbox */
-	uint64_t lttr0                        : 2;  /**< Entry X:0 Letter */
-	uint64_t sid0                         : 16; /**< Entry X:0 Source ID */
+	uint64_t tt0                          : 1;  /**< Entry 0 TT ID. */
+	uint64_t dis0                         : 1;  /**< Entry 0 dest ID. */
+	uint64_t seg0                         : 4;  /**< Entry 0 next segment. */
+	uint64_t mbox0                        : 2;  /**< Entry 0 mailbox. */
+	uint64_t lttr0                        : 2;  /**< Entry 0 letter. */
+	uint64_t sid0                         : 16; /**< Entry 0 source ID. */
 #else
 	uint64_t sid0                         : 16;
 	uint64_t lttr0                        : 2;
@@ -1205,38 +1779,89 @@ union cvmx_sriox_imsg_statusx {
 	struct cvmx_sriox_imsg_statusx_s      cn63xx;
 	struct cvmx_sriox_imsg_statusx_s      cn63xxp1;
 	struct cvmx_sriox_imsg_statusx_s      cn66xx;
+	struct cvmx_sriox_imsg_statusx_s      cn75xx;
 };
 typedef union cvmx_sriox_imsg_statusx cvmx_sriox_imsg_statusx_t;
 
 /**
  * cvmx_srio#_imsg_vport_thr
  *
- * SRIO_IMSG_VPORT_THR = SRIO Incoming Message Virtual Port Threshold
- *
- * The SRIO Incoming Message Virtual Port Threshold Register
- *
- * Notes:
- * SRIO0_IMSG_VPORT_THR.MAX_TOT must be >= SRIO0_IMSG_VPORT_THR.BUF_THR
- * + SRIO2_IMSG_VPORT_THR.BUF_THR + SRIO3_IMSG_VPORT_THR.BUF_THR.  This register can be accessed
- * regardless of the value in SRIO(0,2..3)_STATUS_REG.ACCESS and is not effected by MAC reset.  The maximum
- * number of VPORTs allocated to a MAC is limited to 46 if QLM0 is configured to x2 or x4 mode and 44
- * if configured in x1 mode.
+ * SRIO0_IMSG_VPORT_THR[MAX_TOT] must be >= SRIO0_IMSG_VPORT_THR[BUF_THR]
+ * This register can be accessed regardless of the value in
+ * SRIO()_STATUS_REG[ACCESS] and is not effected by MAC reset.  The
+ * maximum number of VPORTs allocated to a MAC is limited to 48.
  *
- * Clk_Rst:        SRIO(0,2..3)_IMSG_VPORT_THR     sclk    srst_n
+ * This register is reset by the coprocessor-clock reset.
  */
 union cvmx_sriox_imsg_vport_thr {
 	uint64_t u64;
 	struct cvmx_sriox_imsg_vport_thr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t base                         : 6;  /**< Vport starting offset.  The Vports used between SRIO0 and SRIO1 must not overlap
+                                                         with each other or other devices.  The first 8 vports are initially for BGX, Loopback,
+                                                         etc.
+                                                         Default is 8 (to 51) for SRIO0 and 52 (to 95) for SRIO1. */
+	uint64_t reserved_54_55               : 2;
+	uint64_t max_tot                      : 6;  /**< Sets max number of vports available to this SRIO MAC.  Maximum value supported by
+                                                         hardware is 48.  The total number of vports available to SRIO MACs by the 75xx is 94
+                                                         but depends on configuration.  Default is 44 vports each. */
+	uint64_t reserved_46_47               : 2;
+	uint64_t max_s1                       : 6;  /**< Reserved. */
+	uint64_t reserved_38_39               : 2;
+	uint64_t max_s0                       : 6;  /**< Reserved. */
+	uint64_t sp_vport                     : 1;  /**< Single-segment vport pre-allocation.
+                                                         When set, single-segment messages use pre-allocated
+                                                         vport slots and a single port is removed from the
+                                                         MAX_TOT.  This port does not count towards the MAX_S0
+                                                         and MAX_S1 thresholds.
+                                                         When clear, single-segment messages must allocate
+                                                         vport slots just like multi-segment messages do. */
+	uint64_t reserved_20_30               : 11;
+	uint64_t buf_thr                      : 4;  /**< Sets number of vports to be buffered by this
+                                                         interface. BUF_THR must not be zero when receiving
+                                                         messages. The max and recommended BUF_THR value is 8.
+                                                         Lack of a buffered vport can force a retry for a received
+                                                         first segment, so, particularly if SP_VPORT=0
+                                                         (which is not recommended) or the segment size is
+                                                         small, larger BUF_THR values may improve
+                                                         performance. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t max_p1                       : 6;  /**< Maximum number of open vports in port 1. */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t max_p0                       : 6;  /**< Maximum number of open vports in port 0. */
+#else
+	uint64_t max_p0                       : 6;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t max_p1                       : 6;
+	uint64_t reserved_14_15               : 2;
+	uint64_t buf_thr                      : 4;
+	uint64_t reserved_20_30               : 11;
+	uint64_t sp_vport                     : 1;
+	uint64_t max_s0                       : 6;
+	uint64_t reserved_38_39               : 2;
+	uint64_t max_s1                       : 6;
+	uint64_t reserved_46_47               : 2;
+	uint64_t max_tot                      : 6;
+	uint64_t reserved_54_55               : 2;
+	uint64_t base                         : 6;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} s;
+	struct cvmx_sriox_imsg_vport_thr_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t max_tot                      : 6;  /**< Sets max number of vports available to the chip
-                                                         This field is only used in SRIO0. */
+	uint64_t max_tot                      : 6;  /**< Sets max number of vports available to SRIO0+SRIO1
+                                                         This field is only used in SRIO0.
+                                                         SRIO1 never uses SRIO1_IMSG_VPORT_THR[MAX_TOT]. */
 	uint64_t reserved_46_47               : 2;
-	uint64_t max_s1                       : 6;  /**< Reserved
-                                                         This field is only used in SRIO0. */
+	uint64_t max_s1                       : 6;  /**< Sets max number of vports available to SRIO1
+                                                         This field is only used in SRIO0.
+                                                         SRIO1 never uses SRIO1_IMSG_VPORT_THR[MAX_S1]. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t max_s0                       : 6;  /**< Sets max number of vports available to SRIO0
-                                                         This field is only used in SRIO0. */
+                                                         This field is only used in SRIO0.
+                                                         SRIO1 never uses SRIO1_IMSG_VPORT_THR[MAX_S0]. */
 	uint64_t sp_vport                     : 1;  /**< Single-segment vport pre-allocation.
                                                          When set, single-segment messages use pre-allocated
                                                          vport slots (that do not count toward thresholds).
@@ -1256,9 +1881,17 @@ union cvmx_sriox_imsg_vport_thr {
                                                          small, larger BUF_THR values may improve
                                                          performance. */
 	uint64_t reserved_14_15               : 2;
-	uint64_t max_p1                       : 6;  /**< Sets max number of open vports in port 1 */
+	uint64_t max_p1                       : 6;  /**< Sets max number of open vports in port 1
+                                                         A setting of 0x3F disables vport limit
+                                                         checking for this message port.  This port should
+                                                         be disabled if timeouts or other message format
+                                                         errors are detected. */
 	uint64_t reserved_6_7                 : 2;
-	uint64_t max_p0                       : 6;  /**< Sets max number of open vports in port 0 */
+	uint64_t max_p0                       : 6;  /**< Sets max number of open vports in port 0
+                                                         A setting of 0x3F disables vport limit
+                                                         checking for this message port.  This port should
+                                                         be disabled if timeouts or other message format
+                                                         errors are detected. */
 #else
 	uint64_t max_p0                       : 6;
 	uint64_t reserved_6_7                 : 2;
@@ -1274,10 +1907,10 @@ union cvmx_sriox_imsg_vport_thr {
 	uint64_t max_tot                      : 6;
 	uint64_t reserved_54_63               : 10;
 #endif
-	} s;
-	struct cvmx_sriox_imsg_vport_thr_s    cn63xx;
-	struct cvmx_sriox_imsg_vport_thr_s    cn63xxp1;
-	struct cvmx_sriox_imsg_vport_thr_s    cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_imsg_vport_thr_cn63xx cn63xxp1;
+	struct cvmx_sriox_imsg_vport_thr_cn63xx cn66xx;
+	struct cvmx_sriox_imsg_vport_thr_s    cn75xx;
 };
 typedef union cvmx_sriox_imsg_vport_thr cvmx_sriox_imsg_vport_thr_t;
 
@@ -1521,28 +2154,58 @@ typedef union cvmx_sriox_int_enable cvmx_sriox_int_enable_t;
 /**
  * cvmx_srio#_int_info0
  *
- * SRIO_INT_INFO0 = SRIO Interrupt Information
+ * This register contains the first header word of the illegal s2m transaction
+ * associated with the SLI_ERR interrupt.  The remaining information is located
+ * in SRIO()_INT_INFO1.   This register is only updated when the SLI_ERR is initially
+ * detected.  Once the interrupt is cleared then additional information can be captured.
+ * Common errors include:
  *
- * The SRIO Interrupt Information
+ *   1.  Load/Stores with Length over 32.
  *
- * Notes:
- * This register contains the first header word of the illegal s2m transaction associated with the
- *  SLI_ERR interrupt.  The remaining information is located in SRIO(0,2..3)_INT_INFO1.   This register is
- *  only updated when the SLI_ERR is initially detected.  Once the interrupt is cleared then
- *  additional information can be captured.
- *  Common Errors Include:
- *   1.  Load/Stores with Length over 32
- *   2.  Load/Stores that translate to Maintenance Ops with a length over 8
- *   3.  Load Ops that translate to Atomic Ops with other than 1, 2 and 4 byte accesses
- *   4.  Load/Store Ops with a Length 0
- *   5.  Unexpected Responses
- *
- * Clk_Rst:        SRIO(0,2..3)_INT_REG    hclk    hrst_n
+ *   2.  Load/Stores that translate to Maintenance Ops with a length over 8.
+ *
+ *   3.  Load Ops that translate to Atomic Ops with other than 1, 2 and 4 byte accesses.
+ *
+ *   4.  Load/Store Ops with a Length 0.
+ *
+ *   5.  Unexpected Responses.
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_int_info0 {
 	uint64_t u64;
 	struct cvmx_sriox_int_info0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cmd                          : 4;  /**< Command.
+                                                         0x0 = Load, outgoing read request.
+                                                         0x4 = Store, outgoing write request.
+                                                         0x8 = Response, outgoing read response.
+                                                         _ All others are reserved and generate errors. */
+	uint64_t reserved_56_59               : 4;
+	uint64_t tag                          : 8;  /**< Internal Transaction Number */
+	uint64_t reserved_42_47               : 6;
+	uint64_t length                       : 10; /**< Data length in 64-bit words (load/store only). */
+	uint64_t status                       : 3;  /**< Response status.
+                                                         0x0 = Success.
+                                                         0x1 = Error.
+                                                         _ All others reserved. */
+	uint64_t reserved_16_28               : 13;
+	uint64_t be0                          : 8;  /**< First 64-bit word byte enables (load/store only). */
+	uint64_t be1                          : 8;  /**< Last 64-bit word byte enables (load/store only). */
+#else
+	uint64_t be1                          : 8;
+	uint64_t be0                          : 8;
+	uint64_t reserved_16_28               : 13;
+	uint64_t status                       : 3;
+	uint64_t length                       : 10;
+	uint64_t reserved_42_47               : 6;
+	uint64_t tag                          : 8;
+	uint64_t reserved_56_59               : 4;
+	uint64_t cmd                          : 4;
+#endif
+	} s;
+	struct cvmx_sriox_int_info0_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t cmd                          : 4;  /**< Command
                                                          0 = Load, Outgoing Read Request
                                                          4 = Store, Outgoing Write Request
@@ -1572,34 +2235,60 @@ union cvmx_sriox_int_info0 {
 	uint64_t type                         : 4;
 	uint64_t cmd                          : 4;
 #endif
-	} s;
-	struct cvmx_sriox_int_info0_s         cn63xx;
-	struct cvmx_sriox_int_info0_s         cn63xxp1;
-	struct cvmx_sriox_int_info0_s         cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_int_info0_cn63xx    cn63xxp1;
+	struct cvmx_sriox_int_info0_cn63xx    cn66xx;
+	struct cvmx_sriox_int_info0_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cmd                          : 4;  /**< Command.
+                                                         0x0 = Load, outgoing read request.
+                                                         0x4 = Store, outgoing write request.
+                                                         0x8 = Response, outgoing read response.
+                                                         _ All others are reserved and generate errors. */
+	uint64_t typ                          : 4;  /**< Command type.
+                                                         Load/store SRIO_S2M_TYPE used.
+                                                         Response (Reserved). */
+	uint64_t tag                          : 8;  /**< Internal Transaction Number */
+	uint64_t reserved_47_42               : 6;
+	uint64_t length                       : 10; /**< Data length in 64-bit words (load/store only). */
+	uint64_t status                       : 3;  /**< Response status.
+                                                         0x0 = Success.
+                                                         0x1 = Error.
+                                                         _ All others reserved. */
+	uint64_t reserved_28_16               : 13;
+	uint64_t be0                          : 8;  /**< First 64-bit word byte enables (load/store only). */
+	uint64_t be1                          : 8;  /**< Last 64-bit word byte enables (load/store only). */
+#else
+	uint64_t be1                          : 8;
+	uint64_t be0                          : 8;
+	uint64_t reserved_28_16               : 13;
+	uint64_t status                       : 3;
+	uint64_t length                       : 10;
+	uint64_t reserved_47_42               : 6;
+	uint64_t tag                          : 8;
+	uint64_t typ                          : 4;
+	uint64_t cmd                          : 4;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_int_info0 cvmx_sriox_int_info0_t;
 
 /**
  * cvmx_srio#_int_info1
  *
- * SRIO_INT_INFO1 = SRIO Interrupt Information
- *
- * The SRIO Interrupt Information
+ * This register contains the second header word of the illegal s2m transaction
+ * associated with the SLI_ERR interrupt.  The remaining information is located
+ * in SRIO()_INT_INFO0.   This register is only updated when the SLI_ERR is initially
+ * detected.  Once the interrupt is cleared then additional information can be captured.
  *
- * Notes:
- * This register contains the second header word of the illegal s2m transaction associated with the
- *  SLI_ERR interrupt.  The remaining information is located in SRIO(0,2..3)_INT_INFO0.   This register is
- *  only updated when the SLI_ERR is initially detected.  Once the interrupt is cleared then
- *  additional information can be captured.
- *
- * Clk_Rst:        SRIO(0,2..3)_INT_REG    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_int_info1 {
 	uint64_t u64;
 	struct cvmx_sriox_int_info1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t info1                        : 64; /**< Address (Load/Store) or First 64-bit Word of
-                                                         Response Data Associated with Interrupt */
+	uint64_t info1                        : 64; /**< Address (load/store) or first 64-bit word of
+                                                         response data associated with interrupt. */
 #else
 	uint64_t info1                        : 64;
 #endif
@@ -1607,49 +2296,46 @@ union cvmx_sriox_int_info1 {
 	struct cvmx_sriox_int_info1_s         cn63xx;
 	struct cvmx_sriox_int_info1_s         cn63xxp1;
 	struct cvmx_sriox_int_info1_s         cn66xx;
+	struct cvmx_sriox_int_info1_s         cn75xx;
 };
 typedef union cvmx_sriox_int_info1 cvmx_sriox_int_info1_t;
 
 /**
  * cvmx_srio#_int_info2
  *
- * SRIO_INT_INFO2 = SRIO Interrupt Information
- *
- * The SRIO Interrupt Information
- *
- * Notes:
- * This register contains the invalid outbound message descriptor associated with the OMSG_ERR
- *  interrupt.  This register is only updated when the OMSG_ERR is initially detected.  Once the
- *  interrupt is cleared then additional information can be captured.
+ * This register contains the invalid outbound message descriptor associated
+ * with the OMSG_ERR interrupt.  This register is only updated when the OMSG_ERR
+ * is initially detected.  Once the interrupt is cleared then additional
+ * information can be captured.
  *
- * Clk_Rst:        SRIO(0,2..3)_INT_REG    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_int_info2 {
 	uint64_t u64;
 	struct cvmx_sriox_int_info2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t prio                         : 2;  /**< PRIO field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t tt                           : 1;  /**< TT field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t sis                          : 1;  /**< SIS field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t ssize                        : 4;  /**< SSIZE field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t did                          : 16; /**< DID field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t xmbox                        : 4;  /**< XMBOX field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t mbox                         : 2;  /**< MBOX field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t letter                       : 2;  /**< LETTER field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t rsrvd                        : 30; /**< RSRVD field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t lns                          : 1;  /**< LNS field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 	uint64_t intr                         : 1;  /**< INT field of outbound message descriptor
-                                                         associated with the OMSG_ERR interrupt */
+                                                         associated with the OMSG_ERR interrupt. */
 #else
 	uint64_t intr                         : 1;
 	uint64_t lns                          : 1;
@@ -1667,27 +2353,55 @@ union cvmx_sriox_int_info2 {
 	struct cvmx_sriox_int_info2_s         cn63xx;
 	struct cvmx_sriox_int_info2_s         cn63xxp1;
 	struct cvmx_sriox_int_info2_s         cn66xx;
+	struct cvmx_sriox_int_info2_s         cn75xx;
 };
 typedef union cvmx_sriox_int_info2 cvmx_sriox_int_info2_t;
 
 /**
  * cvmx_srio#_int_info3
  *
- * SRIO_INT_INFO3 = SRIO Interrupt Information
- *
- * The SRIO Interrupt Information
- *
- * Notes:
- * This register contains the retry response associated with the RTRY_ERR interrupt.  This register
- *  is only updated when the RTRY_ERR is initially detected.  Once the interrupt is cleared then
- *  additional information can be captured.
+ * This register contains the retry response associated with the RTRY_ERR interrupt.
+ * The register is only updated when the RTRY_ERR is initially detected.  Once the
+ * interrupt is cleared then additional information can be captured.
  *
- * Clk_Rst:        SRIO(0,2..3)_INT_REG    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_int_info3 {
 	uint64_t u64;
 	struct cvmx_sriox_int_info3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t prio                         : 2;  /**< Priority of received retry response message. */
+	uint64_t tt                           : 2;  /**< TT of received retry response message. */
+	uint64_t reserved_56_59               : 4;
+	uint64_t other                        : 48; /**< Other fields of received retry response message
+                                                         If [TT]==0 (8-bit ID's):
+                                                         _ <47:40> => destination ID.
+                                                         _ <39:32> => source ID.
+                                                         _ <31:28> => transaction (should be 1 - msg).
+                                                         _ <27:24> => status (should be 3 - retry).
+                                                         _ <23:22> => letter.
+                                                         _ <21:20> => mbox.
+                                                         _ <19:16> => msgseg.
+                                                         _ <15:0>  => unused.
+                                                         If [TT]==1 (16-bit ID's):
+                                                         _ <47:32> => destination ID.
+                                                         _ <31:16> => source ID.
+                                                         _ <15:12> => transaction (should be 1 - msg).
+                                                         _ <11:8>  => status (should be 3 - retry).
+                                                         _ <7:6>   => letter.
+                                                         _ <5:4>   => mbox.
+                                                         _ <3:0>   => msgseg. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t other                        : 48;
+	uint64_t reserved_56_59               : 4;
+	uint64_t tt                           : 2;
+	uint64_t prio                         : 2;
+#endif
+	} s;
+	struct cvmx_sriox_int_info3_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t prio                         : 2;  /**< Priority of received retry response message */
 	uint64_t tt                           : 2;  /**< TT of received retry response message */
 	uint64_t type                         : 4;  /**< Type of received retry response message
@@ -1718,87 +2432,222 @@ union cvmx_sriox_int_info3 {
 	uint64_t tt                           : 2;
 	uint64_t prio                         : 2;
 #endif
-	} s;
-	struct cvmx_sriox_int_info3_s         cn63xx;
-	struct cvmx_sriox_int_info3_s         cn63xxp1;
-	struct cvmx_sriox_int_info3_s         cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_int_info3_cn63xx    cn63xxp1;
+	struct cvmx_sriox_int_info3_cn63xx    cn66xx;
+	struct cvmx_sriox_int_info3_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t prio                         : 2;  /**< Priority of received retry response message. */
+	uint64_t tt                           : 2;  /**< TT of received retry response message. */
+	uint64_t typ                          : 4;  /**< Type of received retry response message (should be 13). */
+	uint64_t other                        : 48; /**< Other fields of received retry response message
+                                                         If [TT]==0 (8-bit ID's):
+                                                         _ <47:40> => destination ID.
+                                                         _ <39:32> => source ID.
+                                                         _ <31:28> => transaction (should be 1 - msg).
+                                                         _ <27:24> => status (should be 3 - retry).
+                                                         _ <23:22> => letter.
+                                                         _ <21:20> => mbox.
+                                                         _ <19:16> => msgseg.
+                                                         _ <15:0>  => unused.
+                                                         If [TT]==1 (16-bit ID's):
+                                                         _ <47:32> => destination ID.
+                                                         _ <31:16> => source ID.
+                                                         _ <15:12> => transaction (should be 1 - msg).
+                                                         _ <11:8>  => status (should be 3 - retry).
+                                                         _ <7:6>   => letter.
+                                                         _ <5:4>   => mbox.
+                                                         _ <3:0>   => msgseg. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t other                        : 48;
+	uint64_t typ                          : 4;
+	uint64_t tt                           : 2;
+	uint64_t prio                         : 2;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_int_info3 cvmx_sriox_int_info3_t;
 
 /**
  * cvmx_srio#_int_reg
  *
- * SRIO_INT_REG = SRIO Interrupt Register
- *
- * Displays and clears which enabled interrupts have occured
- *
- * Notes:
  * This register provides interrupt status.  Like most SRIO CSRs, this register can only
- *  be read/written when the corresponding SRIO is both present and not in reset. (SRIO*_INT2_REG
- *  can be accessed when SRIO is in reset.) Any set bits written to this register clear the
- *  corresponding interrupt.  The RXBELL interrupt is cleared by reading all the entries in the
- *  incoming Doorbell FIFO.  The LOG_ERB interrupt must be cleared before writing zeroes
- *  to clear the bits in the SRIOMAINT*_ERB_LT_ERR_DET register.  Otherwise a new interrupt may be
- *  lost. The PHY_ERB interrupt must be cleared before writing a zero to
- *  SRIOMAINT*_ERB_ATTR_CAPT[VALID]. Otherwise, a new interrupt may be lost.  OMSG_ERR is set when an
- *  invalid outbound message descriptor is received.  The descriptor is deemed to be invalid if the
- *  SSIZE field is set to a reserved value, the SSIZE field combined with the packet length would
- *  result in more than 16 message segments, or the packet only contains a descriptor (no data).
- *
- * Clk_Rst:        SRIO(0,2..3)_INT_REG    hclk    hrst_n
+ * be read/written when the corresponding SRIO is both present and not in reset. (SRIO()_INT2_REG
+ * can be accessed when SRIO is in reset.) Any set bits written to this register clear the
+ * corresponding interrupt.  The RXBELL interrupt is cleared by reading all the entries in the
+ * incoming Doorbell FIFO.  OMSG_ERR is set when
+ * an invalid outbound message descriptor is received.  The descriptor is deemed to be invalid if
+ * the SSIZE field is set to a reserved value, the SSIZE field combined with the packet length
+ * would result in more than 16 message segments, or the packet only contains a descriptor (no
+ * data).
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_int_reg {
 	uint64_t u64;
 	struct cvmx_sriox_int_reg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
+	uint64_t reserved_48_63               : 16;
+	uint64_t door_bell                    : 16; /**< One or more incoming doorbells received for SRIO doorbell 0-15.
+                                                         These interrupts are valid when SRIO()_RX_BELL_CTRL[NUM_FIFO] = 1-5; */
 	uint64_t int2_sum                     : 1;  /**< Interrupt Set and Enabled in SRIO(0,2..3)_INT2_REG */
+	uint64_t reserved_29_30               : 2;
+	uint64_t dbe                          : 1;  /**< Double bit internal memory error detected.
+                                                         See SRIO()_ECC_STATUS[DBE]. */
+	uint64_t sbe                          : 1;  /**< Single bit internal memory error detected.
+                                                         See SRIO()_ECC_STATUS[SBE]. */
+	uint64_t zero_pkt                     : 1;  /**< Received incoming SRIO zero byte packet. */
+	uint64_t ttl_tout                     : 1;  /**< Outgoing packet time to live timeout.
+                                                         See SRIOMAINT()_PORT_TTL_CTL.
+                                                         See SRIOMAINT()_TX_DROP. */
+	uint64_t fail                         : 1;  /**< ERB error rate reached fail count.
+                                                         See SRIOMAINT()_ERB_ERR_RATE. */
+	uint64_t degrad                       : 1;  /**< ERB error rate reached degrade count.
+                                                         See SRIOMAINT()_ERB_ERR_RATE. */
+	uint64_t mac_buf                      : 1;  /**< SRIO MAC buffer CRC error.  See SRIO()_MAC_BUFFERS. */
+	uint64_t f_error                      : 1;  /**< SRIO fatal port error (MAC reset required). */
+	uint64_t rtry_err                     : 1;  /**< Outbound message retry threshold exceeded.
+                                                         See SRIO()_INT_INFO3.
+                                                         When one or more of the segments in an outgoing
+                                                         message have a RTRY_ERR, SRIO will not set
+                                                         OMSG* after the message "transfer". */
+	uint64_t pko_err                      : 1;  /**< Outbound message received PKO Error  FIXME, going to change to   PKO Reset Error - Message
+                                                         Received from PKO while
+                                                         MAC in reset. This
+                                                         This register provides interrupt status. Unlike SRIO()_INT_REG,
+                                                         SRIO()_INT2_REG can be accessed whenever the SRIO is present,
+                                                         regardless of whether the corresponding SRIO is in reset or not.
+                                                         INT_SUM shows the status of the interrupts in SRIO()_INT_REG.
+                                                         Any set bits written to this register clear the corresponding interrupt.
+                                                         The register can be accessed/modified regardless of the value of
+                                                         SRIO()_STATUS_REG[ACCESS] and probably should be the first register read
+                                                         when an SRIO interrupt occurs.  FIXME */
+	uint64_t omsg_err                     : 1;  /**< Outbound message invalid descriptor error.
+                                                         See SRIO()_INT_INFO2. */
+	uint64_t omsg1                        : 1;  /**< Controller 1 outbound message complete.
+                                                         See SRIO()_OMSG_DONE_COUNTS1. */
+	uint64_t omsg0                        : 1;  /**< Controller 0 outbound message complete.
+                                                         See SRIO()_OMSG_DONE_COUNTS0. */
+	uint64_t link_up                      : 1;  /**< Serial link going from inactive to active. */
+	uint64_t link_dwn                     : 1;  /**< Serial link going from active to inactive. */
+	uint64_t phy_erb                      : 1;  /**< Physical layer error detected in erb.
+                                                         This is a summary interrupt of all SRIOMAINT physical layer interrupts,
+                                                         and this is level interrupt that only can be cleared from SRIOMAINT csrs.
+                                                         See SRIOMAINT()_ERB_ATTR_CAPT. */
+	uint64_t log_erb                      : 1;  /**< Logical/transport layer error detected in ERB.
+                                                         This is a summary interrupt of all SRIOMAINT logical layer interrupts,
+                                                         and this is level interrupt that only can be cleared from SRIOMAINT csrs.
+                                                         See SRIOMAINT()_ERB_LT_ERR_DET. */
+	uint64_t soft_rx                      : 1;  /**< Incoming packet received by soft packet FIFO. */
+	uint64_t soft_tx                      : 1;  /**< Outgoing packet sent by soft packet FIFO. */
+	uint64_t mce_rx                       : 1;  /**< Incoming multicast event symbol. */
+	uint64_t mce_tx                       : 1;  /**< Outgoing multicast event transmit complete. */
+	uint64_t wr_done                      : 1;  /**< Outgoing last nwrite_r DONE response received.
+                                                         See SRIO()_WR_DONE_COUNTS. */
+	uint64_t sli_err                      : 1;  /**< Unsupported S2M transaction received.
+                                                         See SRIO()_INT_INFO0, SRIO()_INT_INFO1. */
+	uint64_t deny_wr                      : 1;  /**< Incoming maint_wr access to denied bar registers. */
+	uint64_t bar_err                      : 1;  /**< Incoming access crossing/missing BAR address. */
+	uint64_t maint_op                     : 1;  /**< Internal maintenance operation complete.
+                                                         See SRIO()_MAINT_OP and SRIO()_MAINT_RD_DATA. */
+	uint64_t rxbell                       : 1;  /**< One or more incoming doorbells received.
+                                                         This interrupt is only valid in back-compatible mode,
+                                                         when SRIO()_RX_BELL_CTRL[NUM_FIFO] = 0;
+                                                         Read SRIO()_RX_BELL to empty FIFO. */
+	uint64_t bell_err                     : 1;  /**< Outgoing doorbell timeout, retry or error.
+                                                         See SRIO()_TX_BELL_INFO. */
+	uint64_t txbell                       : 1;  /**< Outgoing doorbell complete.
+                                                         TXBELL will not be asserted if a timeout, retry or
+                                                         error occurs. */
+#else
+	uint64_t txbell                       : 1;
+	uint64_t bell_err                     : 1;
+	uint64_t rxbell                       : 1;
+	uint64_t maint_op                     : 1;
+	uint64_t bar_err                      : 1;
+	uint64_t deny_wr                      : 1;
+	uint64_t sli_err                      : 1;
+	uint64_t wr_done                      : 1;
+	uint64_t mce_tx                       : 1;
+	uint64_t mce_rx                       : 1;
+	uint64_t soft_tx                      : 1;
+	uint64_t soft_rx                      : 1;
+	uint64_t log_erb                      : 1;
+	uint64_t phy_erb                      : 1;
+	uint64_t link_dwn                     : 1;
+	uint64_t link_up                      : 1;
+	uint64_t omsg0                        : 1;
+	uint64_t omsg1                        : 1;
+	uint64_t omsg_err                     : 1;
+	uint64_t pko_err                      : 1;
+	uint64_t rtry_err                     : 1;
+	uint64_t f_error                      : 1;
+	uint64_t mac_buf                      : 1;
+	uint64_t degrad                       : 1;
+	uint64_t fail                         : 1;
+	uint64_t ttl_tout                     : 1;
+	uint64_t zero_pkt                     : 1;
+	uint64_t sbe                          : 1;
+	uint64_t dbe                          : 1;
+	uint64_t reserved_29_30               : 2;
+	uint64_t int2_sum                     : 1;
+	uint64_t door_bell                    : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_sriox_int_reg_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t int2_sum                     : 1;  /**< Interrupt Set and Enabled in SRIO(0..1)_INT2_REG
+                                                         (Pass 2) */
 	uint64_t reserved_27_30               : 4;
-	uint64_t zero_pkt                     : 1;  /**< Received Incoming SRIO Zero byte packet */
-	uint64_t ttl_tout                     : 1;  /**< Outgoing Packet Time to Live Timeout
-                                                         See SRIOMAINT(0,2..3)_PORT_TTL_CTL
-                                                         See SRIOMAINT(0,2..3)_TX_DROP */
-	uint64_t fail                         : 1;  /**< ERB Error Rate reached Fail Count
-                                                         See SRIOMAINT(0,2..3)_ERB_ERR_RATE */
-	uint64_t degrad                       : 1;  /**< ERB Error Rate reached Degrade Count
-                                                         See SRIOMAINT(0,2..3)_ERB_ERR_RATE */
-	uint64_t mac_buf                      : 1;  /**< SRIO MAC Buffer CRC Error
-                                                         See SRIO(0,2..3)_MAC_BUFFERS */
+	uint64_t zero_pkt                     : 1;  /**< Received Incoming SRIO Zero byte packet (Pass 2) */
+	uint64_t ttl_tout                     : 1;  /**< Outgoing Packet Time to Live Timeout (Pass 2)
+                                                         See SRIOMAINT(0..1)_PORT_TTL_CTL
+                                                         See SRIOMAINT(0..1)_TX_DROP */
+	uint64_t fail                         : 1;  /**< ERB Error Rate reached Fail Count (Pass 2)
+                                                         See SRIOMAINT(0..1)_ERB_ERR_RATE */
+	uint64_t degrad                       : 1;  /**< ERB Error Rate reached Degrade Count (Pass 2)
+                                                         See SRIOMAINT(0..1)_ERB_ERR_RATE */
+	uint64_t mac_buf                      : 1;  /**< SRIO MAC Buffer CRC Error (Pass 2)
+                                                         See SRIO(0..1)_MAC_BUFFERS */
 	uint64_t f_error                      : 1;  /**< SRIO Fatal Port Error (MAC reset required) */
 	uint64_t rtry_err                     : 1;  /**< Outbound Message Retry Threshold Exceeded
-                                                         See SRIO(0,2..3)_INT_INFO3
+                                                         See SRIO(0..1)_INT_INFO3
                                                          When one or more of the segments in an outgoing
                                                          message have a RTRY_ERR, SRIO will not set
                                                          OMSG* after the message "transfer". */
 	uint64_t pko_err                      : 1;  /**< Outbound Message Received PKO Error */
 	uint64_t omsg_err                     : 1;  /**< Outbound Message Invalid Descriptor Error
-                                                         See SRIO(0,2..3)_INT_INFO2 */
+                                                         See SRIO(0..1)_INT_INFO2 */
 	uint64_t omsg1                        : 1;  /**< Controller 1 Outbound Message Complete
-                                                         See SRIO(0,2..3)_OMSG_DONE_COUNTS1 */
+                                                         See SRIO(0..1)_OMSG_DONE_COUNTS1 */
 	uint64_t omsg0                        : 1;  /**< Controller 0 Outbound Message Complete
-                                                         See SRIO(0,2..3)_OMSG_DONE_COUNTS0 */
+                                                         See SRIO(0..1)_OMSG_DONE_COUNTS0 */
 	uint64_t link_up                      : 1;  /**< Serial Link going from Inactive to Active */
 	uint64_t link_dwn                     : 1;  /**< Serial Link going from Active to Inactive */
 	uint64_t phy_erb                      : 1;  /**< Physical Layer Error detected in ERB
                                                          See SRIOMAINT*_ERB_ATTR_CAPT */
 	uint64_t log_erb                      : 1;  /**< Logical/Transport Layer Error detected in ERB
-                                                         See SRIOMAINT(0,2..3)_ERB_LT_ERR_DET */
+                                                         See SRIOMAINT(0..1)_ERB_LT_ERR_DET */
 	uint64_t soft_rx                      : 1;  /**< Incoming Packet received by Soft Packet FIFO */
 	uint64_t soft_tx                      : 1;  /**< Outgoing Packet sent by Soft Packet FIFO */
 	uint64_t mce_rx                       : 1;  /**< Incoming Multicast Event Symbol */
 	uint64_t mce_tx                       : 1;  /**< Outgoing Multicast Event Transmit Complete */
 	uint64_t wr_done                      : 1;  /**< Outgoing Last Nwrite_R DONE Response Received.
-                                                         See SRIO(0,2..3)_WR_DONE_COUNTS */
+                                                         See SRIO(0..1)_WR_DONE_COUNTS */
 	uint64_t sli_err                      : 1;  /**< Unsupported S2M Transaction Received.
-                                                         See SRIO(0,2..3)_INT_INFO[1:0] */
+                                                         See SRIO(0..1)_INT_INFO[1:0] */
 	uint64_t deny_wr                      : 1;  /**< Incoming Maint_Wr Access to Denied Bar Registers. */
 	uint64_t bar_err                      : 1;  /**< Incoming Access Crossing/Missing BAR Address */
 	uint64_t maint_op                     : 1;  /**< Internal Maintenance Operation Complete.
-                                                         See SRIO(0,2..3)_MAINT_OP and SRIO(0,2..3)_MAINT_RD_DATA */
+                                                         See SRIO(0..1)_MAINT_OP and SRIO(0..1)_MAINT_RD_DATA */
 	uint64_t rxbell                       : 1;  /**< One or more Incoming Doorbells Received.
-                                                         Read SRIO(0,2..3)_RX_BELL to empty FIFO */
+                                                         Read SRIO(0..1)_RX_BELL to empty FIFO */
 	uint64_t bell_err                     : 1;  /**< Outgoing Doorbell Timeout, Retry or Error.
-                                                         See SRIO(0,2..3)_TX_BELL_INFO */
+                                                         See SRIO(0..1)_TX_BELL_INFO */
 	uint64_t txbell                       : 1;  /**< Outgoing Doorbell Complete.
                                                          TXBELL will not be asserted if a Timeout, Retry or
                                                          Error occurs. */
@@ -1834,8 +2683,7 @@ union cvmx_sriox_int_reg {
 	uint64_t int2_sum                     : 1;
 	uint64_t reserved_32_63               : 32;
 #endif
-	} s;
-	struct cvmx_sriox_int_reg_s           cn63xx;
+	} cn63xx;
 	struct cvmx_sriox_int_reg_cn63xxp1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
@@ -1900,53 +2748,232 @@ union cvmx_sriox_int_reg {
 	uint64_t reserved_22_63               : 42;
 #endif
 	} cn63xxp1;
-	struct cvmx_sriox_int_reg_s           cn66xx;
+	struct cvmx_sriox_int_reg_cn63xx      cn66xx;
+	struct cvmx_sriox_int_reg_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t door_bell                    : 16; /**< One or more incoming doorbells received for SRIO doorbell 0-15.
+                                                         These interrupts are valid when SRIO()_RX_BELL_CTRL[NUM_FIFO] = 1-5; */
+	uint64_t reserved_29_31               : 3;
+	uint64_t dbe                          : 1;  /**< Double bit internal memory error detected.
+                                                         See SRIO()_ECC_STATUS[DBE]. */
+	uint64_t sbe                          : 1;  /**< Single bit internal memory error detected.
+                                                         See SRIO()_ECC_STATUS[SBE]. */
+	uint64_t zero_pkt                     : 1;  /**< Received incoming SRIO zero byte packet. */
+	uint64_t ttl_tout                     : 1;  /**< Outgoing packet time to live timeout.
+                                                         See SRIOMAINT()_PORT_TTL_CTL.
+                                                         See SRIOMAINT()_TX_DROP. */
+	uint64_t fail                         : 1;  /**< ERB error rate reached fail count.
+                                                         See SRIOMAINT()_ERB_ERR_RATE. */
+	uint64_t degrad                       : 1;  /**< ERB error rate reached degrade count.
+                                                         See SRIOMAINT()_ERB_ERR_RATE. */
+	uint64_t mac_buf                      : 1;  /**< SRIO MAC buffer CRC error.  See SRIO()_MAC_BUFFERS. */
+	uint64_t f_error                      : 1;  /**< SRIO fatal port error (MAC reset required). */
+	uint64_t rtry_err                     : 1;  /**< Outbound message retry threshold exceeded.
+                                                         See SRIO()_INT_INFO3.
+                                                         When one or more of the segments in an outgoing
+                                                         message have a RTRY_ERR, SRIO will not set
+                                                         OMSG* after the message "transfer". */
+	uint64_t pko_err                      : 1;  /**< Outbound message received PKO Error  FIXME, going to change to   PKO Reset Error - Message
+                                                         Received from PKO while
+                                                         MAC in reset. This
+                                                         This register provides interrupt status. Unlike SRIO()_INT_REG,
+                                                         SRIO()_INT2_REG can be accessed whenever the SRIO is present,
+                                                         regardless of whether the corresponding SRIO is in reset or not.
+                                                         INT_SUM shows the status of the interrupts in SRIO()_INT_REG.
+                                                         Any set bits written to this register clear the corresponding interrupt.
+                                                         The register can be accessed/modified regardless of the value of
+                                                         SRIO()_STATUS_REG[ACCESS] and probably should be the first register read
+                                                         when an SRIO interrupt occurs.  FIXME */
+	uint64_t omsg_err                     : 1;  /**< Outbound message invalid descriptor error.
+                                                         See SRIO()_INT_INFO2. */
+	uint64_t omsg1                        : 1;  /**< Controller 1 outbound message complete.
+                                                         See SRIO()_OMSG_DONE_COUNTS1. */
+	uint64_t omsg0                        : 1;  /**< Controller 0 outbound message complete.
+                                                         See SRIO()_OMSG_DONE_COUNTS0. */
+	uint64_t link_up                      : 1;  /**< Serial link going from inactive to active. */
+	uint64_t link_dwn                     : 1;  /**< Serial link going from active to inactive. */
+	uint64_t phy_erb                      : 1;  /**< Physical layer error detected in erb.
+                                                         This is a summary interrupt of all SRIOMAINT physical layer interrupts,
+                                                         and this is level interrupt that only can be cleared from SRIOMAINT csrs.
+                                                         See SRIOMAINT()_ERB_ATTR_CAPT. */
+	uint64_t log_erb                      : 1;  /**< Logical/transport layer error detected in ERB.
+                                                         This is a summary interrupt of all SRIOMAINT logical layer interrupts,
+                                                         and this is level interrupt that only can be cleared from SRIOMAINT csrs.
+                                                         See SRIOMAINT()_ERB_LT_ERR_DET. */
+	uint64_t soft_rx                      : 1;  /**< Incoming packet received by soft packet FIFO. */
+	uint64_t soft_tx                      : 1;  /**< Outgoing packet sent by soft packet FIFO. */
+	uint64_t mce_rx                       : 1;  /**< Incoming multicast event symbol. */
+	uint64_t mce_tx                       : 1;  /**< Outgoing multicast event transmit complete. */
+	uint64_t wr_done                      : 1;  /**< Outgoing last nwrite_r DONE response received.
+                                                         See SRIO()_WR_DONE_COUNTS. */
+	uint64_t sli_err                      : 1;  /**< Unsupported S2M transaction received.
+                                                         See SRIO()_INT_INFO0, SRIO()_INT_INFO1. */
+	uint64_t deny_wr                      : 1;  /**< Incoming maint_wr access to denied bar registers. */
+	uint64_t bar_err                      : 1;  /**< Incoming access crossing/missing BAR address. */
+	uint64_t maint_op                     : 1;  /**< Internal maintenance operation complete.
+                                                         See SRIO()_MAINT_OP and SRIO()_MAINT_RD_DATA. */
+	uint64_t rxbell                       : 1;  /**< One or more incoming doorbells received.
+                                                         This interrupt is only valid in back-compatible mode,
+                                                         when SRIO()_RX_BELL_CTRL[NUM_FIFO] = 0;
+                                                         Read SRIO()_RX_BELL to empty FIFO. */
+	uint64_t bell_err                     : 1;  /**< Outgoing doorbell timeout, retry or error.
+                                                         See SRIO()_TX_BELL_INFO. */
+	uint64_t txbell                       : 1;  /**< Outgoing doorbell complete.
+                                                         TXBELL will not be asserted if a timeout, retry or
+                                                         error occurs. */
+#else
+	uint64_t txbell                       : 1;
+	uint64_t bell_err                     : 1;
+	uint64_t rxbell                       : 1;
+	uint64_t maint_op                     : 1;
+	uint64_t bar_err                      : 1;
+	uint64_t deny_wr                      : 1;
+	uint64_t sli_err                      : 1;
+	uint64_t wr_done                      : 1;
+	uint64_t mce_tx                       : 1;
+	uint64_t mce_rx                       : 1;
+	uint64_t soft_tx                      : 1;
+	uint64_t soft_rx                      : 1;
+	uint64_t log_erb                      : 1;
+	uint64_t phy_erb                      : 1;
+	uint64_t link_dwn                     : 1;
+	uint64_t link_up                      : 1;
+	uint64_t omsg0                        : 1;
+	uint64_t omsg1                        : 1;
+	uint64_t omsg_err                     : 1;
+	uint64_t pko_err                      : 1;
+	uint64_t rtry_err                     : 1;
+	uint64_t f_error                      : 1;
+	uint64_t mac_buf                      : 1;
+	uint64_t degrad                       : 1;
+	uint64_t fail                         : 1;
+	uint64_t ttl_tout                     : 1;
+	uint64_t zero_pkt                     : 1;
+	uint64_t sbe                          : 1;
+	uint64_t dbe                          : 1;
+	uint64_t reserved_29_31               : 3;
+	uint64_t door_bell                    : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_int_reg cvmx_sriox_int_reg_t;
 
 /**
+ * cvmx_srio#_int_w1s
+ */
+union cvmx_sriox_int_w1s {
+	uint64_t u64;
+	struct cvmx_sriox_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t door_bell                    : 16; /**< Reads SRIO()_INT_REG[DOOR_BELL]. */
+	uint64_t reserved_29_31               : 3;
+	uint64_t dbe                          : 1;  /**< Reads SRIO()_INT_REG[DBE]. */
+	uint64_t sbe                          : 1;  /**< Reads SRIO()_INT_REG[SBE]. */
+	uint64_t zero_pkt                     : 1;  /**< Reads or sets  SRIO()_INT_REG[ZERO_PKT]. */
+	uint64_t ttl_tout                     : 1;  /**< Reads or sets  SRIO()_INT_REG[TTL_TOUT]. */
+	uint64_t fail                         : 1;  /**< Reads or sets  SRIO()_INT_REG[FAIL]. */
+	uint64_t degrade                      : 1;  /**< Reads or sets  SRIO()_INT_REG[DEGRADE]. */
+	uint64_t mac_buf                      : 1;  /**< Reads or sets  SRIO()_INT_REG[MAC_BUF]. */
+	uint64_t f_error                      : 1;  /**< Reads or sets  SRIO()_INT_REG[F_ERROR]. */
+	uint64_t rtry_err                     : 1;  /**< Reads or sets  SRIO()_INT_REG[RTRY_ERR]. */
+	uint64_t pko_err                      : 1;  /**< Reads or sets  SRIO()_INT_REG[PKO_ERR]. */
+	uint64_t omsg_err                     : 1;  /**< Reads or sets  SRIO()_INT_REG[OMSG_ERR]. */
+	uint64_t omsg1                        : 1;  /**< Reads or sets  SRIO()_INT_REG[OMSG1]. */
+	uint64_t omsg0                        : 1;  /**< Reads or sets  SRIO()_INT_REG[OMSG0]. */
+	uint64_t link_up                      : 1;  /**< Reads or sets  SRIO()_INT_REG[LINK_UP]. */
+	uint64_t link_dwn                     : 1;  /**< Reads or sets  SRIO()_INT_REG[LINK_DWN]. */
+	uint64_t phy_erb                      : 1;  /**< Reads SRIO()_INT_REG[PHY_ERB]. */
+	uint64_t log_erb                      : 1;  /**< Reads SRIO()_INT_REG[LOG_ERB]. */
+	uint64_t soft_rx                      : 1;  /**< Reads or sets  SRIO()_INT_REG[SOFT_RX]. */
+	uint64_t soft_tx                      : 1;  /**< Reads or sets  SRIO()_INT_REG[SOFT_TX]. */
+	uint64_t mce_rx                       : 1;  /**< Reads or sets  SRIO()_INT_REG[MCE_RX]. */
+	uint64_t mce_tx                       : 1;  /**< Reads or sets  SRIO()_INT_REG[MCE_TX]. */
+	uint64_t wr_done                      : 1;  /**< Reads or sets  SRIO()_INT_REG[WR_DONE]. */
+	uint64_t sli_err                      : 1;  /**< Reads or sets  SRIO()_INT_REG[SLI_ERR]. */
+	uint64_t deny_wr                      : 1;  /**< Reads or sets  SRIO()_INT_REG[BAR_ERR]. */
+	uint64_t bar_err                      : 1;  /**< Reads or sets  SRIO()_INT_REG[BAR_ERR]. */
+	uint64_t maint_op                     : 1;  /**< Reads or sets  SRIO()_INT_REG[MAINT_OP]. */
+	uint64_t rxbell                       : 1;  /**< Reads SRIO()_INT_REG[RX_BELL]. */
+	uint64_t bell_err                     : 1;  /**< Reads or sets  SRIO()_INT_REG[BELL_ERR]. */
+	uint64_t txbell                       : 1;  /**< Reads or sets  SRIO()_INT_REG[TXBELL]. */
+#else
+	uint64_t txbell                       : 1;
+	uint64_t bell_err                     : 1;
+	uint64_t rxbell                       : 1;
+	uint64_t maint_op                     : 1;
+	uint64_t bar_err                      : 1;
+	uint64_t deny_wr                      : 1;
+	uint64_t sli_err                      : 1;
+	uint64_t wr_done                      : 1;
+	uint64_t mce_tx                       : 1;
+	uint64_t mce_rx                       : 1;
+	uint64_t soft_tx                      : 1;
+	uint64_t soft_rx                      : 1;
+	uint64_t log_erb                      : 1;
+	uint64_t phy_erb                      : 1;
+	uint64_t link_dwn                     : 1;
+	uint64_t link_up                      : 1;
+	uint64_t omsg0                        : 1;
+	uint64_t omsg1                        : 1;
+	uint64_t omsg_err                     : 1;
+	uint64_t pko_err                      : 1;
+	uint64_t rtry_err                     : 1;
+	uint64_t f_error                      : 1;
+	uint64_t mac_buf                      : 1;
+	uint64_t degrade                      : 1;
+	uint64_t fail                         : 1;
+	uint64_t ttl_tout                     : 1;
+	uint64_t zero_pkt                     : 1;
+	uint64_t sbe                          : 1;
+	uint64_t dbe                          : 1;
+	uint64_t reserved_29_31               : 3;
+	uint64_t door_bell                    : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_sriox_int_w1s_s           cn75xx;
+};
+typedef union cvmx_sriox_int_w1s cvmx_sriox_int_w1s_t;
+
+/**
  * cvmx_srio#_ip_feature
  *
- * SRIO_IP_FEATURE = SRIO IP Feature Select
- *
- * Debug Register used to enable IP Core Features
- *
- * Notes:
- * This register is used to override powerup values used by the SRIOMAINT Registers and QLM
- *  configuration.  The register is only reset during COLD boot.  It should only be modified only
- *  while SRIO(0,2..3)_STATUS_REG.ACCESS is zero.
+ * This register is used to override powerup values used by the
+ * SRIOMAINT Registers and QLM configuration.  The register is
+ * only reset during COLD boot.  It should only be modified only
+ * while SRIO()_STATUS_REG[ACCESS] is zero.
  *
- * Clk_Rst:        SRIO(0,2..3)_IP_FEATURE sclk    srst_cold_n
+ * This register is reset by the coprocessor-clock cold reset.
  */
 union cvmx_sriox_ip_feature {
 	uint64_t u64;
 	struct cvmx_sriox_ip_feature_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ops                          : 32; /**< Reset Value for the OPs fields in both the
-                                                         SRIOMAINT(0,2..3)_SRC_OPS and SRIOMAINT(0,2..3)_DST_OPS
-                                                         registers. */
+	uint64_t ops                          : 32; /**< Reset value for the OPs fields in both SRIOMAINT()_SRC_OPS and
+                                                         SRIOMAINT()_DST_OPS. */
 	uint64_t reserved_15_31               : 17;
-	uint64_t no_vmin                      : 1;  /**< Lane Sync Valid Minimum Count Disable. (Pass 3)
+	uint64_t no_vmin                      : 1;  /**< Lane sync valid minimum count disable.
                                                          0 = Wait for 2^12 valid codewords and at least
-                                                             127 comma characters before starting
-                                                             alignment.
+                                                         127 comma characters before starting
+                                                         alignment.
                                                          1 = Wait only for 127 comma characters before
-                                                             starting alignment. (SRIO V1.3 Compatable) */
+                                                         starting alignment. (SRIO V1.3 Compatable). */
 	uint64_t a66                          : 1;  /**< 66-bit Address Support.  Value for bit 2 of the
-                                                         EX_ADDR field in the SRIOMAINT(0,2..3)_PE_FEAT register. */
+                                                         EX_ADDR field in the SRIOMAINT()_PE_FEAT register. */
 	uint64_t a50                          : 1;  /**< 50-bit Address Support.  Value for bit 1 of the
-                                                         EX_ADDR field in the SRIOMAINT(0,2..3)_PE_FEAT register. */
+                                                         EX_ADDR field in the SRIOMAINT()_PE_FEAT register. */
 	uint64_t reserved_11_11               : 1;
-	uint64_t tx_flow                      : 1;  /**< Reset Value for the TX_FLOW field in the
-                                                         SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG register. */
-	uint64_t pt_width                     : 2;  /**< Value for the PT_WIDTH field in the
-                                                         SRIOMAINT(0,2..3)_PORT_0_CTL register. */
-	uint64_t tx_pol                       : 4;  /**< TX Serdes Polarity Lanes 3-0
-                                                         0 = Normal Operation
-                                                         1 = Invert, Swap +/- Tx SERDES Pins */
-	uint64_t rx_pol                       : 4;  /**< RX Serdes Polarity Lanes 3-0
-                                                         0 = Normal Operation
-                                                         1 = Invert, Swap +/- Rx SERDES Pins */
+	uint64_t tx_flow                      : 1;  /**< Reset value for SRIOMAINT()_IR_BUFFER_CONFIG[TX_FLOW]. */
+	uint64_t pt_width                     : 2;  /**< Reset value for SRIOMAINT()_PORT_0_CTL[PT_WIDTH]. */
+	uint64_t tx_pol                       : 4;  /**< TX Serdes polarity lanes 3-0.
+                                                         0 = Normal operation.
+                                                         1 = Invert, Swap +/- Tx SERDES pins. */
+	uint64_t rx_pol                       : 4;  /**< RX Serdes polarity lanes 3-0.
+                                                         0 = Normal operation.
+                                                         1 = Invert, Swap +/- Rx SERDES pins. */
 #else
 	uint64_t rx_pol                       : 4;
 	uint64_t tx_pol                       : 4;
@@ -1999,22 +3026,19 @@ union cvmx_sriox_ip_feature {
 	} cn63xx;
 	struct cvmx_sriox_ip_feature_cn63xx   cn63xxp1;
 	struct cvmx_sriox_ip_feature_s        cn66xx;
+	struct cvmx_sriox_ip_feature_s        cn75xx;
 };
 typedef union cvmx_sriox_ip_feature cvmx_sriox_ip_feature_t;
 
 /**
  * cvmx_srio#_mac_buffers
  *
- * SRIO_MAC_BUFFERS = SRIO MAC Buffer Control
- *
- * Reports errors and controls buffer usage on the main MAC buffers
- *
- * Notes:
- * Register displays errors status for each of the eight RX and TX buffers and controls use of the
- *  buffer in future operations.  It also displays the number of RX and TX buffers currently used by
- *  the MAC.
+ * Register displays errors status for each of the eight
+ * RX and TX buffers and controls use of the buffer in
+ * future operations.  It also displays the number of RX
+ * and TX buffers currently used by the MAC.
  *
- * Clk_Rst:        SRIO(0,2..3)_MAC_BUFFERS        hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_mac_buffers {
 	uint64_t u64;
@@ -2030,9 +3054,9 @@ union cvmx_sriox_mac_buffers {
 	uint64_t tx_inuse                     : 4;  /**< Number of TX buffers containing packets waiting
                                                          to be transmitted or to be acknowledged. */
 	uint64_t tx_stat                      : 8;  /**< Errors detected in main SRIO Transmit Buffers.
-                                                         CRC error detected in buffer sets bit of buffer \#
+                                                         CRC error detected in buffer sets the corresponding bit
                                                          until the corresponding TX_ENB is disabled.  Each
-                                                         bit set causes the SRIO(0,2..3)_INT_REG.MAC_BUF
+                                                         bit set causes the SRIO()_INT_REG[MAC_BUF]
                                                          interrupt. */
 	uint64_t reserved_24_31               : 8;
 	uint64_t rx_enb                       : 8;  /**< RX Buffer Enable.  Each bit enables a specific RX
@@ -2044,9 +3068,9 @@ union cvmx_sriox_mac_buffers {
 	uint64_t rx_inuse                     : 4;  /**< Number of RX buffers containing valid packets
                                                          waiting to be processed by the logical layer. */
 	uint64_t rx_stat                      : 8;  /**< Errors detected in main SRIO Receive Buffers.  CRC
-                                                         error detected in buffer sets bit of buffer \#
+                                                         error detected in buffer sets the corresponding bit
                                                          until the corresponding RX_ENB is disabled.  Each
-                                                         bit set causes the SRIO(0,2..3)_INT_REG.MAC_BUF
+                                                         bit set causes the SRIO()_INT_REG[MAC_BUF]
                                                          interrupt. */
 #else
 	uint64_t rx_stat                      : 8;
@@ -2063,36 +3087,35 @@ union cvmx_sriox_mac_buffers {
 	} s;
 	struct cvmx_sriox_mac_buffers_s       cn63xx;
 	struct cvmx_sriox_mac_buffers_s       cn66xx;
+	struct cvmx_sriox_mac_buffers_s       cn75xx;
 };
 typedef union cvmx_sriox_mac_buffers cvmx_sriox_mac_buffers_t;
 
 /**
  * cvmx_srio#_maint_op
  *
- * SRIO_MAINT_OP = SRIO Maintenance Operation
- *
- * Allows access to maintenance registers.
- *
- * Notes:
- * This register allows write access to the local SRIOMAINT registers.  A write to this register
- *  posts a read or write operation selected by the OP bit to the local SRIOMAINT register selected by
- *  ADDR.  This write also sets the PENDING bit.  The PENDING bit is cleared by hardware when the
- *  operation is complete.  The MAINT_OP Interrupt is also set as the PENDING bit is cleared.  While
- *  this bit is set, additional writes to this register stall the RSL.  The FAIL bit is set with the
- *  clearing of the PENDING bit when an illegal address is selected. WR_DATA is used only during write
- *  operations.  Only 32-bit Maintenance Operations are supported.
- *
- * Clk_Rst:        SRIO(0,2..3)_MAINT_OP   hclk    hrst_n
+ * This register allows write access to the local SRIOMAINT registers.
+ * A write to this register posts a read or write operation selected
+ * by the OP bit to the local SRIOMAINT register selected by ADDR.
+ * This write also sets the PENDING bit.  The PENDING bit is cleared by
+ * hardware when the operation is complete.  The MAINT_OP Interrupt is
+ * also set as the PENDING bit is cleared.  While this bit is set,
+ * additional writes to this register stall the RSL.  The FAIL bit is
+ * set with the clearing of the PENDING bit when an illegal address is
+ * selected. WR_DATA is used only during write operations.  Only
+ * 32-bit maintenance operations are supported.
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_maint_op {
 	uint64_t u64;
 	struct cvmx_sriox_maint_op_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t wr_data                      : 32; /**< Write Data[31:0]. */
+	uint64_t wr_data                      : 32; /**< Write data <31:0>. */
 	uint64_t reserved_27_31               : 5;
-	uint64_t fail                         : 1;  /**< Maintenance Operation Address Error */
-	uint64_t pending                      : 1;  /**< Maintenance Operation Pending */
-	uint64_t op                           : 1;  /**< Operation. 0=Read, 1=Write */
+	uint64_t fail                         : 1;  /**< Maintenance operation address error. */
+	uint64_t pending                      : 1;  /**< Maintenance operation pending. */
+	uint64_t op                           : 1;  /**< Operation. 0=Read, 1=Write. */
 	uint64_t addr                         : 24; /**< Address. Addr[1:0] are ignored. */
 #else
 	uint64_t addr                         : 24;
@@ -2106,31 +3129,27 @@ union cvmx_sriox_maint_op {
 	struct cvmx_sriox_maint_op_s          cn63xx;
 	struct cvmx_sriox_maint_op_s          cn63xxp1;
 	struct cvmx_sriox_maint_op_s          cn66xx;
+	struct cvmx_sriox_maint_op_s          cn75xx;
 };
 typedef union cvmx_sriox_maint_op cvmx_sriox_maint_op_t;
 
 /**
  * cvmx_srio#_maint_rd_data
  *
- * SRIO_MAINT_RD_DATA = SRIO Maintenance Read Data
+ * This register allows read access of the local SRIOMAINT registers.  A write to the
+ * SRIO()_MAINT_OP register with the OP bit set to zero initiates a read request and
+ * clears the VALID bit.  The resulting read is returned here and the VALID bit is set.
+ * Access to the register will not stall the RSL but the VALID bit should be read.
  *
- * Allows read access of maintenance registers.
- *
- * Notes:
- * This register allows read access of the local SRIOMAINT registers.  A write to the SRIO(0,2..3)_MAINT_OP
- *  register with the OP bit set to zero initiates a read request and clears the VALID bit.  The
- *  resulting read is returned here and the VALID bit is set.  Access to the register will not stall
- *  the RSL but the VALID bit should be read.
- *
- * Clk_Rst:        SRIO(0,2..3)_MAINT_RD_DATA      hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_maint_rd_data {
 	uint64_t u64;
 	struct cvmx_sriox_maint_rd_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
-	uint64_t valid                        : 1;  /**< Read Data Valid. */
-	uint64_t rd_data                      : 32; /**< Read Data[31:0]. */
+	uint64_t valid                        : 1;  /**< Read data valid. */
+	uint64_t rd_data                      : 32; /**< Read data[31:0]. */
 #else
 	uint64_t rd_data                      : 32;
 	uint64_t valid                        : 1;
@@ -2140,30 +3159,26 @@ union cvmx_sriox_maint_rd_data {
 	struct cvmx_sriox_maint_rd_data_s     cn63xx;
 	struct cvmx_sriox_maint_rd_data_s     cn63xxp1;
 	struct cvmx_sriox_maint_rd_data_s     cn66xx;
+	struct cvmx_sriox_maint_rd_data_s     cn75xx;
 };
 typedef union cvmx_sriox_maint_rd_data cvmx_sriox_maint_rd_data_t;
 
 /**
  * cvmx_srio#_mce_tx_ctl
  *
- * SRIO_MCE_TX_CTL = SRIO Multicast Event Transmit Control
- *
- * Multicast Event TX Control
+ * Writes to this register cause the SRIO device to generate a Multicast Event.
+ * Setting the MCE bit requests the logic to generate the Multicast Event Symbol.
+ * Reading the bit shows the status of the transmit event.  The hardware will
+ * clear the bit when the event has been transmitted and set the MCE_TX Interrupt.
  *
- * Notes:
- * Writes to this register cause the SRIO device to generate a Multicast Event.  Setting the MCE bit
- *  requests the logic to generate the Multicast Event Symbol.  Reading the MCS bit shows the status
- *  of the transmit event.  The hardware will clear the bit when the event has been transmitted and
- *  set the MCS_TX Interrupt.
- *
- * Clk_Rst:        SRIO(0,2..3)_MCE_TX_CTL hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_mce_tx_ctl {
 	uint64_t u64;
 	struct cvmx_sriox_mce_tx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t mce                          : 1;  /**< Multicast Event Transmit. */
+	uint64_t mce                          : 1;  /**< Multicast event transmit. */
 #else
 	uint64_t mce                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2172,45 +3187,41 @@ union cvmx_sriox_mce_tx_ctl {
 	struct cvmx_sriox_mce_tx_ctl_s        cn63xx;
 	struct cvmx_sriox_mce_tx_ctl_s        cn63xxp1;
 	struct cvmx_sriox_mce_tx_ctl_s        cn66xx;
+	struct cvmx_sriox_mce_tx_ctl_s        cn75xx;
 };
 typedef union cvmx_sriox_mce_tx_ctl cvmx_sriox_mce_tx_ctl_t;
 
 /**
  * cvmx_srio#_mem_op_ctrl
  *
- * SRIO_MEM_OP_CTRL = SRIO Memory Operation Control
- *
- * The SRIO Memory Operation Control
- *
- * Notes:
- * This register is used to control memory operations.  Bits are provided to override the priority of
- *  the outgoing responses to memory operations.  The memory operations with responses include NREAD,
- *  NWRITE_R, ATOMIC_INC, ATOMIC_DEC, ATOMIC_SET and ATOMIC_CLR.
+ * This register is used to control memory operations.  Bits are provided to override
+ * the priority of the outgoing responses to memory operations.  The memory operations
+ * with responses include NREAD, NWRITE_R, ATOMIC_INC, ATOMIC_DEC, ATOMIC_SET and ATOMIC_CLR.
  *
- * Clk_Rst:        SRIO(0,2..3)_MEM_OP_CTRL        hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_mem_op_ctrl {
 	uint64_t u64;
 	struct cvmx_sriox_mem_op_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t rr_ro                        : 1;  /**< Read Response Relaxed Ordering.  Controls ordering
-                                                         rules for incoming memory operations
-                                                          0 = Normal Ordering
-                                                          1 = Relaxed Ordering */
-	uint64_t w_ro                         : 1;  /**< Write Relaxed Ordering.  Controls ordering rules
-                                                         for incoming memory operations
-                                                          0 = Normal Ordering
-                                                          1 = Relaxed Ordering */
+	uint64_t rr_ro                        : 1;  /**< Read response relaxed ordering.  Controls ordering
+                                                         rules for incoming memory operations.
+                                                         0 = Normal ordering.
+                                                         1 = Relaxed ordering. */
+	uint64_t w_ro                         : 1;  /**< Write relaxed ordering.  Controls ordering rules
+                                                         for incoming memory operations.
+                                                         0 = Normal ordering.
+                                                         1 = Relaxed ordering. */
 	uint64_t reserved_6_7                 : 2;
 	uint64_t rp1_sid                      : 1;  /**< Sets response priority for incomimg memory ops
-                                                         of priority 1 on the secondary ID (0=2, 1=3) */
+                                                         of priority 1 on the secondary ID (0=2, 1=3). */
 	uint64_t rp0_sid                      : 2;  /**< Sets response priority for incomimg memory ops
-                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the secondary ID (0,1=1 2=2, 3=3). */
 	uint64_t rp1_pid                      : 1;  /**< Sets response priority for incomimg memory ops
-                                                         of priority 1 on the primary ID (0=2, 1=3) */
+                                                         of priority 1 on the primary ID (0=2, 1=3). */
 	uint64_t rp0_pid                      : 2;  /**< Sets response priority for incomimg memory ops
-                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3) */
+                                                         of priority 0 on the primary ID (0,1=1 2=2, 3=3). */
 #else
 	uint64_t rp0_pid                      : 2;
 	uint64_t rp1_pid                      : 1;
@@ -2225,45 +3236,42 @@ union cvmx_sriox_mem_op_ctrl {
 	struct cvmx_sriox_mem_op_ctrl_s       cn63xx;
 	struct cvmx_sriox_mem_op_ctrl_s       cn63xxp1;
 	struct cvmx_sriox_mem_op_ctrl_s       cn66xx;
+	struct cvmx_sriox_mem_op_ctrl_s       cn75xx;
 };
 typedef union cvmx_sriox_mem_op_ctrl cvmx_sriox_mem_op_ctrl_t;
 
 /**
  * cvmx_srio#_omsg_ctrl#
  *
- * SRIO_OMSG_CTRLX = SRIO Outbound Message Control
- *
- * The SRIO Controller X Outbound Message Control Register
- *
- * Notes:
  * 1) If IDM_TT, IDM_SIS, and IDM_DID are all clear, then the "ID match" will always be false.
+ *
  * 2) LTTR_SP and LTTR_MP must be non-zero at all times, otherwise the message output queue can
- *        get blocked
- * 3) TESTMODE has no function on controller 1
- * 4) When IDM_TT=0, it is possible for an ID match to match an 8-bit DID with a 16-bit DID - SRIO
- *        zero-extends all 8-bit DID's, and the DID comparisons are always 16-bits.
+ * get blocked.
+ *
+ * 3) TESTMODE has no function on controller 1.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_CTRL[0:1]     hclk    hrst_n
+ * 4) When IDM_TT=0, it is possible for an ID match to match an 8-bit DID with a 16-bit DID SRIO
+ * zero-extends all 8-bit DID's, and the DID comparisons are always 16-bits.
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_ctrlx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_ctrlx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t testmode                     : 1;  /**< Controller X test mode (keep as RSVD in HRM) */
+	uint64_t testmode                     : 1;  /**< Reserved. INTERNAL: Controller test mode (keep as RSVD in HRM). */
 	uint64_t reserved_37_62               : 26;
-	uint64_t silo_max                     : 5;  /**< Sets max number outgoing segments for controller X
+	uint64_t silo_max                     : 5;  /**< Sets max number outgoing segments for this controller.
                                                          Valid range is 0x01 .. 0x10  Note that lower
                                                          values will reduce bandwidth. */
-	uint64_t rtry_thr                     : 16; /**< Controller X Retry threshold */
-	uint64_t rtry_en                      : 1;  /**< Controller X Retry threshold enable */
+	uint64_t rtry_thr                     : 16; /**< Controller retry threshold. */
+	uint64_t rtry_en                      : 1;  /**< Controller retry threshold enable. */
 	uint64_t reserved_11_14               : 4;
-	uint64_t idm_tt                       : 1;  /**< Controller X ID match includes TT ID */
-	uint64_t idm_sis                      : 1;  /**< Controller X ID match includes SIS */
-	uint64_t idm_did                      : 1;  /**< Controller X ID match includes DID */
-	uint64_t lttr_sp                      : 4;  /**< Controller X SP allowable letters in dynamic
-                                                         letter select mode (LNS) */
-	uint64_t lttr_mp                      : 4;  /**< Controller X MP allowable letters in dynamic
-                                                         letter select mode (LNS) */
+	uint64_t idm_tt                       : 1;  /**< Controller ID match includes TT ID. */
+	uint64_t idm_sis                      : 1;  /**< Controller ID match includes SIS. */
+	uint64_t idm_did                      : 1;  /**< Controller ID match includes DID. */
+	uint64_t lttr_sp                      : 4;  /**< Controller SP allowable letters in dynamic letter select mode (LNS). */
+	uint64_t lttr_mp                      : 4;  /**< Controller MP allowable letters in dynamic letter select mode (LNS). */
 #else
 	uint64_t lttr_mp                      : 4;
 	uint64_t lttr_sp                      : 4;
@@ -2307,35 +3315,31 @@ union cvmx_sriox_omsg_ctrlx {
 #endif
 	} cn63xxp1;
 	struct cvmx_sriox_omsg_ctrlx_s        cn66xx;
+	struct cvmx_sriox_omsg_ctrlx_s        cn75xx;
 };
 typedef union cvmx_sriox_omsg_ctrlx cvmx_sriox_omsg_ctrlx_t;
 
 /**
  * cvmx_srio#_omsg_done_counts#
  *
- * SRIO_OMSG_DONE_COUNTSX = SRIO Outbound Message Complete Counts
- *
- * The SRIO Controller X Outbound Message Complete Counts Register
- *
- * Notes:
- * This register shows the number of successful and unsuccessful Outgoing Messages issued through
- *  this controller.  The only messages considered are the ones with the INT field set in the PKO
- *  message header.  This register is typically not written while Outbound SRIO Memory traffic is
- *  enabled.  The sum of the GOOD and BAD counts should equal the number of messages sent unless
- *  the MAC has been reset.
+ * This register shows the number of successful and unsuccessful Outgoing Messages issued
+ * through this controller.  The only messages considered are the ones with the INT field
+ * set in the PKO message header.  This register is typically not written while Outbound
+ * SRIO Memory traffic is enabled.  The sum of the GOOD and BAD counts should equal the
+ * number of messages sent unless the MAC has been reset.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_DONE_COUNTS[0:1]      hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_done_countsx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_done_countsx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t bad                          : 16; /**< Number of Outbound Messages requesting an INT that
+	uint64_t bad                          : 16; /**< Number of outbound messages requesting an INT that
                                                          did not increment GOOD. (One or more segment of the
                                                          message either timed out, reached the retry limit,
                                                          or received an ERROR response.) */
-	uint64_t good                         : 16; /**< Number of Outbound Messages requesting an INT that
+	uint64_t good                         : 16; /**< Number of outbound messages requesting an INT that
                                                          received a DONE response for every segment. */
 #else
 	uint64_t good                         : 16;
@@ -2345,127 +3349,127 @@ union cvmx_sriox_omsg_done_countsx {
 	} s;
 	struct cvmx_sriox_omsg_done_countsx_s cn63xx;
 	struct cvmx_sriox_omsg_done_countsx_s cn66xx;
+	struct cvmx_sriox_omsg_done_countsx_s cn75xx;
 };
 typedef union cvmx_sriox_omsg_done_countsx cvmx_sriox_omsg_done_countsx_t;
 
 /**
  * cvmx_srio#_omsg_fmp_mr#
  *
- * SRIO_OMSG_FMP_MRX = SRIO Outbound Message FIRSTMP Message Restriction
+ * This CSR controls when FMP candidate message segments (from the two different controllers)
+ * can enter the message segment silo to be sent out. A segment remains in the silo until after
+ * is has been transmitted and either acknowledged or errored out.
+ * Candidates and silo entries are one of 4 types:
  *
- * The SRIO Controller X Outbound Message FIRSTMP Message Restriction Register
+ * _ SP  a single-segment message.
  *
- * Notes:
- * This CSR controls when FMP candidate message segments (from the two different controllers) can enter
- * the message segment silo to be sent out. A segment remains in the silo until after is has
- * been transmitted and either acknowledged or errored out.
+ * _ FMP the first segment of a multi-segment message.
  *
- * Candidates and silo entries are one of 4 types:
- *  SP  - a single-segment message
- *  FMP - the first segment of a multi-segment message
- *  NMP - the other segments in a multi-segment message
- *  PSD - the silo psuedo-entry that is valid only while a controller is in the middle of pushing
- *        a multi-segment message into the silo and can match against segments generated by
- *        the other controller
+ * _ NMP the other segments in a multi-segment message.
  *
- * When a candidate "matches" against a silo entry or pseudo entry, it cannot enter the silo.
- * By default (i.e. zeroes in this CSR), the FMP candidate matches against all entries in the
- * silo. When fields in this CSR are set, FMP candidate segments will match fewer silo entries and
- * can enter the silo more freely, probably providing better performance.
+ * _ PSD the silo psuedo-entry that is valid only while a controller is in the middle of pushing
+ *   a multi-segment message into the silo and can match against segments generated by
+ *   the other controller
+ *
+ * When a candidate "matches" against a silo entry or pseudo entry, it cannot enter the
+ * silo.  By default (i.e. zeroes in this CSR), the FMP candidate matches against all
+ * entries in the silo. When fields in this CSR are set, FMP candidate segments will
+ * match fewer silo entries and can enter the silo more freely, probably providing
+ * better performance.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_FMP_MR[0:1]   hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_fmp_mrx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_fmp_mrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t ctlr_sp                      : 1;  /**< Controller X FIRSTMP enable controller SP
+	uint64_t ctlr_sp                      : 1;  /**< Controller FIRSTMP enable controller SP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed SP segments that were created
                                                          by the same controller. When clear, this FMP-SP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t ctlr_fmp                     : 1;  /**< Controller X FIRSTMP enable controller FIRSTMP
+	uint64_t ctlr_fmp                     : 1;  /**< Controller FIRSTMP enable controller FIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed FMP segments that were created
                                                          by the same controller. When clear, this FMP-FMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t ctlr_nmp                     : 1;  /**< Controller X FIRSTMP enable controller NFIRSTMP
+	uint64_t ctlr_nmp                     : 1;  /**< Controller FIRSTMP enable controller NFIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed NMP segments that were created
                                                          by the same controller. When clear, this FMP-NMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t id_sp                        : 1;  /**< Controller X FIRSTMP enable ID SP
+	uint64_t id_sp                        : 1;  /**< Controller FIRSTMP enable ID SP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed SP segments that "ID match" the
                                                          candidate. When clear, this FMP-SP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t id_fmp                       : 1;  /**< Controller X FIRSTMP enable ID FIRSTMP
+	uint64_t id_fmp                       : 1;  /**< Controller FIRSTMP enable ID FIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed FMP segments that "ID match" the
                                                          candidate. When clear, this FMP-FMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t id_nmp                       : 1;  /**< Controller X FIRSTMP enable ID NFIRSTMP
+	uint64_t id_nmp                       : 1;  /**< Controller FIRSTMP enable ID NFIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed NMP segments that "ID match" the
                                                          candidate. When clear, this FMP-NMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t id_psd                       : 1;  /**< Controller X FIRSTMP enable ID PSEUDO
+	uint64_t id_psd                       : 1;  /**< Controller FIRSTMP enable ID PSEUDO.
                                                          When set, the FMP candidate message segment can
                                                          only match the silo pseudo (for the other
                                                          controller) when it is an "ID match". When clear,
                                                          this FMP-PSD match can occur with any ID values.
                                                          Not used by the hardware when ALL_PSD is set. */
-	uint64_t mbox_sp                      : 1;  /**< Controller X FIRSTMP enable MBOX SP
+	uint64_t mbox_sp                      : 1;  /**< Controller FIRSTMP enable MBOX SP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed SP segments with the same 2-bit
                                                          mbox value as the candidate. When clear, this
                                                          FMP-SP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t mbox_fmp                     : 1;  /**< Controller X FIRSTMP enable MBOX FIRSTMP
+	uint64_t mbox_fmp                     : 1;  /**< Controller FIRSTMP enable MBOX FIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed FMP segments with the same 2-bit
                                                          mbox value as the candidate. When clear, this
                                                          FMP-FMP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t mbox_nmp                     : 1;  /**< Controller X FIRSTMP enable MBOX NFIRSTMP
+	uint64_t mbox_nmp                     : 1;  /**< Controller FIRSTMP enable MBOX NFIRSTMP.
                                                          When set, the FMP candidate message segment can
                                                          only match siloed NMP segments with the same 2-bit
                                                          mbox value as the candidate. When clear, this
                                                          FMP-NMP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t mbox_psd                     : 1;  /**< Controller X FIRSTMP enable MBOX PSEUDO
+	uint64_t mbox_psd                     : 1;  /**< Controller FIRSTMP enable MBOX PSEUDO.
                                                          When set, the FMP candidate message segment can
                                                          only match the silo pseudo (for the other
                                                          controller) if the pseudo has the same 2-bit mbox
                                                          value as the candidate. When clear, this FMP-PSD
                                                          match can occur with any mbox values.
                                                          Not used by the hardware when ALL_PSD is set. */
-	uint64_t all_sp                       : 1;  /**< Controller X FIRSTMP enable all SP
+	uint64_t all_sp                       : 1;  /**< Controller FIRSTMP enable all SP.
                                                          When set, no FMP candidate message segments ever
                                                          match siloed SP segments and ID_SP
                                                          and MBOX_SP are not used. When clear, FMP-SP
                                                          matches can occur. */
-	uint64_t all_fmp                      : 1;  /**< Controller X FIRSTMP enable all FIRSTMP
+	uint64_t all_fmp                      : 1;  /**< Controller FIRSTMP enable all FIRSTMP.
                                                          When set, no FMP candidate message segments ever
                                                          match siloed FMP segments and ID_FMP and MBOX_FMP
                                                          are not used. When clear, FMP-FMP matches can
                                                          occur. */
-	uint64_t all_nmp                      : 1;  /**< Controller X FIRSTMP enable all NFIRSTMP
+	uint64_t all_nmp                      : 1;  /**< Controller FIRSTMP enable all NFIRSTMP.
                                                          When set, no FMP candidate message segments ever
                                                          match siloed NMP segments and ID_NMP and MBOX_NMP
                                                          are not used. When clear, FMP-NMP matches can
                                                          occur. */
-	uint64_t all_psd                      : 1;  /**< Controller X FIRSTMP enable all PSEUDO
+	uint64_t all_psd                      : 1;  /**< Controller FIRSTMP enable all PSEUDO.
                                                          When set, no FMP candidate message segments ever
                                                          match the silo pseudo (for the other controller)
                                                          and ID_PSD and MBOX_PSD are not used. When clear,
@@ -2492,111 +3496,111 @@ union cvmx_sriox_omsg_fmp_mrx {
 	struct cvmx_sriox_omsg_fmp_mrx_s      cn63xx;
 	struct cvmx_sriox_omsg_fmp_mrx_s      cn63xxp1;
 	struct cvmx_sriox_omsg_fmp_mrx_s      cn66xx;
+	struct cvmx_sriox_omsg_fmp_mrx_s      cn75xx;
 };
 typedef union cvmx_sriox_omsg_fmp_mrx cvmx_sriox_omsg_fmp_mrx_t;
 
 /**
  * cvmx_srio#_omsg_nmp_mr#
  *
- * SRIO_OMSG_NMP_MRX = SRIO Outbound Message NFIRSTMP Message Restriction
+ * This CSR controls when NMP candidate message segments (from the two different controllers)
+ * can enter the message segment silo to be sent out. A segment remains in the silo until after
+ * it has been transmitted and either acknowledged or errored out.
+ * Candidates and silo entries are one of 4 types:
  *
- * The SRIO Controller X Outbound Message NFIRSTMP Message Restriction Register
+ * _ SP  a single-segment message.
  *
- * Notes:
- * This CSR controls when NMP candidate message segments (from the two different controllers) can enter
- * the message segment silo to be sent out. A segment remains in the silo until after is has
- * been transmitted and either acknowledged or errored out.
+ * _ FMP the first segment of a multi-segment message.
  *
- * Candidates and silo entries are one of 4 types:
- *  SP  - a single-segment message
- *  FMP - the first segment of a multi-segment message
- *  NMP - the other segments in a multi-segment message
- *  PSD - the silo psuedo-entry that is valid only while a controller is in the middle of pushing
- *        a multi-segment message into the silo and can match against segments generated by
- *        the other controller
+ * _ NMP the other segments in a multi-segment message.
  *
- * When a candidate "matches" against a silo entry or pseudo entry, it cannot enter the silo.
- * By default (i.e. zeroes in this CSR), the NMP candidate matches against all entries in the
- * silo. When fields in this CSR are set, NMP candidate segments will match fewer silo entries and
- * can enter the silo more freely, probably providing better performance.
+ * _ PSD the silo psuedo-entry that is valid only while a controller is in the middle of pushing
+ *   a multi-segment message into the silo and can match against segments generated by
+ *   the other controller
+ *
+ * When a candidate "matches" against a silo entry or pseudo entry, it cannot enter the
+ * silo.  By default (i.e. zeroes in this CSR), the NMP candidate matches against all
+ * entries in the silo. When fields in this CSR are set, NMP candidate segments will
+ * match fewer silo entries and can enter the silo more freely, probably providing
+ * better performance.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_NMP_MR[0:1]   hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_nmp_mrx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_nmp_mrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t ctlr_sp                      : 1;  /**< Controller X NFIRSTMP enable controller SP
+	uint64_t ctlr_sp                      : 1;  /**< Controller NFIRSTMP enable controller SP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed SP segments that were created
                                                          by the same controller. When clear, this NMP-SP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t ctlr_fmp                     : 1;  /**< Controller X NFIRSTMP enable controller FIRSTMP
+	uint64_t ctlr_fmp                     : 1;  /**< Controller NFIRSTMP enable controller FIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed FMP segments that were created
                                                          by the same controller. When clear, this NMP-FMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t ctlr_nmp                     : 1;  /**< Controller X NFIRSTMP enable controller NFIRSTMP
+	uint64_t ctlr_nmp                     : 1;  /**< Controller NFIRSTMP enable controller NFIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed NMP segments that were created
                                                          by the same controller. When clear, this NMP-NMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t id_sp                        : 1;  /**< Controller X NFIRSTMP enable ID SP
+	uint64_t id_sp                        : 1;  /**< Controller NFIRSTMP enable ID SP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed SP segments that "ID match" the
                                                          candidate. When clear, this NMP-SP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t id_fmp                       : 1;  /**< Controller X NFIRSTMP enable ID FIRSTMP
+	uint64_t id_fmp                       : 1;  /**< Controller NFIRSTMP enable ID FIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed FMP segments that "ID match" the
                                                          candidate. When clear, this NMP-FMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t id_nmp                       : 1;  /**< Controller X NFIRSTMP enable ID NFIRSTMP
+	uint64_t id_nmp                       : 1;  /**< Controller NFIRSTMP enable ID NFIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed NMP segments that "ID match" the
                                                          candidate. When clear, this NMP-NMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_NMP is set. */
 	uint64_t reserved_8_8                 : 1;
-	uint64_t mbox_sp                      : 1;  /**< Controller X NFIRSTMP enable MBOX SP
+	uint64_t mbox_sp                      : 1;  /**< Controller NFIRSTMP enable MBOX SP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed SP segments with the same 2-bit
                                                          mbox  value as the candidate. When clear, this
                                                          NMP-SP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t mbox_fmp                     : 1;  /**< Controller X NFIRSTMP enable MBOX FIRSTMP
+	uint64_t mbox_fmp                     : 1;  /**< Controller NFIRSTMP enable MBOX FIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed FMP segments with the same 2-bit
                                                          mbox value as the candidate. When clear, this
                                                          NMP-FMP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t mbox_nmp                     : 1;  /**< Controller X NFIRSTMP enable MBOX NFIRSTMP
+	uint64_t mbox_nmp                     : 1;  /**< Controller NFIRSTMP enable MBOX NFIRSTMP.
                                                          When set, the NMP candidate message segment can
                                                          only match siloed NMP segments with the same 2-bit
                                                          mbox value as the candidate. When clear, this
                                                          NMP-NMP match can occur with any mbox values.
                                                          Not used by the hardware when ALL_NMP is set. */
 	uint64_t reserved_4_4                 : 1;
-	uint64_t all_sp                       : 1;  /**< Controller X NFIRSTMP enable all SP
+	uint64_t all_sp                       : 1;  /**< Controller NFIRSTMP enable all SP.
                                                          When set, no NMP candidate message segments ever
                                                          match siloed SP segments and ID_SP
                                                          and MBOX_SP are not used. When clear, NMP-SP
                                                          matches can occur. */
-	uint64_t all_fmp                      : 1;  /**< Controller X NFIRSTMP enable all FIRSTMP
+	uint64_t all_fmp                      : 1;  /**< Controller NFIRSTMP enable all FIRSTMP.
                                                          When set, no NMP candidate message segments ever
                                                          match siloed FMP segments and ID_FMP and MBOX_FMP
                                                          are not used. When clear, NMP-FMP matches can
                                                          occur. */
-	uint64_t all_nmp                      : 1;  /**< Controller X NFIRSTMP enable all NFIRSTMP
+	uint64_t all_nmp                      : 1;  /**< Controller NFIRSTMP enable all NFIRSTMP.
                                                          When set, no NMP candidate message segments ever
                                                          match siloed NMP segments and ID_NMP and MBOX_NMP
                                                          are not used. When clear, NMP-NMP matches can
@@ -2624,40 +3628,23 @@ union cvmx_sriox_omsg_nmp_mrx {
 	struct cvmx_sriox_omsg_nmp_mrx_s      cn63xx;
 	struct cvmx_sriox_omsg_nmp_mrx_s      cn63xxp1;
 	struct cvmx_sriox_omsg_nmp_mrx_s      cn66xx;
+	struct cvmx_sriox_omsg_nmp_mrx_s      cn75xx;
 };
 typedef union cvmx_sriox_omsg_nmp_mrx cvmx_sriox_omsg_nmp_mrx_t;
 
 /**
  * cvmx_srio#_omsg_port#
  *
- * SRIO_OMSG_PORTX = SRIO Outbound Message Port
+ * Enable Outgoing message ports.
  *
- * The SRIO Controller X Outbound Message Port Register
- *
- * Notes:
- * PORT maps the PKO port to SRIO interface \# / controller X as follows:
- *
- *   000 == PKO port 40
- *   001 == PKO port 41
- *   010 == PKO port 42
- *   011 == PKO port 43
- *   100 == PKO port 44
- *   101 == PKO port 45
- *   110 == PKO port 46
- *   111 == PKO port 47
- *
- *  No two PORT fields among the enabled controllers (ENABLE == 1) may be set to the same value.
- *  The register is only reset during COLD boot.  The register can be accessed/modified regardless of
- *  the value in SRIO(0,2..3)_STATUS_REG.ACCESS.
- *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_PORT[0:1]     sclk    srst_n
+ * This register is reset by the coprocessor-clock reset.
  */
 union cvmx_sriox_omsg_portx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_portx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t enable                       : 1;  /**< Controller X enable */
+	uint64_t enable                       : 1;  /**< Controller enable. */
 	uint64_t reserved_3_30                : 28;
 	uint64_t port                         : 3;  /**< Controller X PKO port */
 #else
@@ -2682,20 +3669,26 @@ union cvmx_sriox_omsg_portx {
 	} cn63xx;
 	struct cvmx_sriox_omsg_portx_cn63xx   cn63xxp1;
 	struct cvmx_sriox_omsg_portx_s        cn66xx;
+	struct cvmx_sriox_omsg_portx_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t enable                       : 1;  /**< Controller enable. */
+	uint64_t reserved_0_30                : 31;
+#else
+	uint64_t reserved_0_30                : 31;
+	uint64_t enable                       : 1;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_omsg_portx cvmx_sriox_omsg_portx_t;
 
 /**
  * cvmx_srio#_omsg_silo_thr
  *
- * SRIO_OMSG_SILO_THR = SRIO Outgoing Message SILO Thresholds
- *
- * The SRIO Outgoing Message SILO Thresholds
- *
- * Notes:
- * Limits the number of Outgoing Message Segments in flight at a time.
+ * This register limits the number of outgoing message segments in flight at a time.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_SILO_THR      hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_silo_thr {
 	uint64_t u64;
@@ -2712,134 +3705,133 @@ union cvmx_sriox_omsg_silo_thr {
 	} s;
 	struct cvmx_sriox_omsg_silo_thr_s     cn63xx;
 	struct cvmx_sriox_omsg_silo_thr_s     cn66xx;
+	struct cvmx_sriox_omsg_silo_thr_s     cn75xx;
 };
 typedef union cvmx_sriox_omsg_silo_thr cvmx_sriox_omsg_silo_thr_t;
 
 /**
  * cvmx_srio#_omsg_sp_mr#
  *
- * SRIO_OMSG_SP_MRX = SRIO Outbound Message SP Message Restriction
+ * This CSR controls when SP candidate message segments (from the two different controllers)
+ * can enter the message segment silo to be sent out. A segment remains in the silo until
+ * after is has been transmitted and either acknowledged or errored out.
+ * Candidates and silo entries are one of 4 types:
  *
- * The SRIO Controller X Outbound Message SP Message Restriction Register
+ * _ SP  a single-segment message
  *
- * Notes:
- * This CSR controls when SP candidate message segments (from the two different controllers) can enter
- * the message segment silo to be sent out. A segment remains in the silo until after is has
- * been transmitted and either acknowledged or errored out.
+ * _ FMP the first segment of a multi-segment message
  *
- * Candidates and silo entries are one of 4 types:
- *  SP  - a single-segment message
- *  FMP - the first segment of a multi-segment message
- *  NMP - the other segments in a multi-segment message
- *  PSD - the silo psuedo-entry that is valid only while a controller is in the middle of pushing
- *        a multi-segment message into the silo and can match against segments generated by
- *        the other controller
+ * _ NMP the other segments in a multi-segment message
+ *
+ * _ PSD the silo psuedo-entry that is valid only while a controller is in the middle of pushing
+ *   a multi-segment message into the silo and can match against segments generated by
+ *   the other controller
  *
  * When a candidate "matches" against a silo entry or pseudo entry, it cannot enter the silo.
  * By default (i.e. zeroes in this CSR), the SP candidate matches against all entries in the
  * silo. When fields in this CSR are set, SP candidate segments will match fewer silo entries and
  * can enter the silo more freely, probably providing better performance.
  *
- * Clk_Rst:        SRIO(0,2..3)_OMSG_SP_MR[0:1]    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_omsg_sp_mrx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_sp_mrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t xmbox_sp                     : 1;  /**< Controller X SP enable XMBOX SP
+	uint64_t xmbox_sp                     : 1;  /**< Controller SP enable XMBOX SP.
                                                          When set, the SP candidate message can only
                                                          match siloed SP segments with the same 4-bit xmbox
                                                          value as the candidate. When clear, this SP-SP
                                                          match can occur with any xmbox values.
                                                          When XMBOX_SP is set, MBOX_SP will commonly be set.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t ctlr_sp                      : 1;  /**< Controller X SP enable controller SP
+	uint64_t ctlr_sp                      : 1;  /**< Controller SP enable controller SP.
                                                          When set, the SP candidate message can
                                                          only match siloed SP segments that were created
                                                          by the same controller. When clear, this SP-SP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t ctlr_fmp                     : 1;  /**< Controller X SP enable controller FIRSTMP
+	uint64_t ctlr_fmp                     : 1;  /**< Controller SP enable controller FIRSTMP.
                                                          When set, the SP candidate message can
                                                          only match siloed FMP segments that were created
                                                          by the same controller. When clear, this SP-FMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t ctlr_nmp                     : 1;  /**< Controller X SP enable controller NFIRSTMP
+	uint64_t ctlr_nmp                     : 1;  /**< Controller SP enable controller NFIRSTMP.
                                                          When set, the SP candidate message can
                                                          only match siloed NMP segments that were created
                                                          by the same controller. When clear, this SP-NMP
                                                          match can also occur when the segments were
                                                          created by the other controller.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t id_sp                        : 1;  /**< Controller X SP enable ID SP
+	uint64_t id_sp                        : 1;  /**< Controller SP enable ID SP.
                                                          When set, the SP candidate message can
                                                          only match siloed SP segments that "ID match" the
                                                          candidate. When clear, this SP-SP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t id_fmp                       : 1;  /**< Controller X SP enable ID FIRSTMP
+	uint64_t id_fmp                       : 1;  /**< Controller SP enable ID FIRSTMP.
                                                          When set, the SP candidate message can
                                                          only match siloed FMP segments that "ID match" the
                                                          candidate. When clear, this SP-FMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t id_nmp                       : 1;  /**< Controller X SP enable ID NFIRSTMP
+	uint64_t id_nmp                       : 1;  /**< Controller SP enable ID NFIRSTMP.
                                                          When set, the SP candidate message can
                                                          only match siloed NMP segments that "ID match" the
                                                          candidate. When clear, this SP-NMP match can occur
                                                          with any ID values.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t id_psd                       : 1;  /**< Controller X SP enable ID PSEUDO
+	uint64_t id_psd                       : 1;  /**< Controller SP enable ID PSEUDO.
                                                          When set, the SP candidate message can
                                                          only match the silo pseudo (for the other
                                                          controller) when it is an "ID match". When clear,
                                                          this SP-PSD match can occur with any ID values.
                                                          Not used by the hardware when ALL_PSD is set. */
-	uint64_t mbox_sp                      : 1;  /**< Controller X SP enable MBOX SP
+	uint64_t mbox_sp                      : 1;  /**< Controller SP enable MBOX SP.
                                                          When set, the SP candidate message can only
                                                          match siloed SP segments with the same 2-bit mbox
                                                          value as the candidate. When clear, this SP-SP
                                                          match can occur with any mbox values.
                                                          Not used by the hardware when ALL_SP is set. */
-	uint64_t mbox_fmp                     : 1;  /**< Controller X SP enable MBOX FIRSTMP
+	uint64_t mbox_fmp                     : 1;  /**< Controller SP enable MBOX FIRSTMP.
                                                          When set, the SP candidate message can only
                                                          match siloed FMP segments with the same 2-bit mbox
                                                          value as the candidate. When clear, this SP-FMP
                                                          match can occur with any mbox values.
                                                          Not used by the hardware when ALL_FMP is set. */
-	uint64_t mbox_nmp                     : 1;  /**< Controller X SP enable MBOX NFIRSTMP
+	uint64_t mbox_nmp                     : 1;  /**< Controller SP enable MBOX NFIRSTMP.
                                                          When set, the SP candidate message can only
                                                          match siloed NMP segments with the same 2-bit mbox
                                                          value as the candidate. When clear, this SP-NMP
                                                          match can occur with any mbox values.
                                                          Not used by the hardware when ALL_NMP is set. */
-	uint64_t mbox_psd                     : 1;  /**< Controller X SP enable MBOX PSEUDO
+	uint64_t mbox_psd                     : 1;  /**< Controller SP enable MBOX PSEUDO.
                                                          When set, the SP candidate message can only
                                                          match the silo pseudo (for the other controller)
                                                          if the pseudo has the same 2-bit mbox value as the
                                                          candidate. When clear, this SP-PSD match can occur
                                                          with any mbox values.
                                                          Not used by the hardware when ALL_PSD is set. */
-	uint64_t all_sp                       : 1;  /**< Controller X SP enable all SP
+	uint64_t all_sp                       : 1;  /**< Controller SP enable all SP.
                                                          When set, no SP candidate messages ever
                                                          match siloed SP segments, and XMBOX_SP, ID_SP,
                                                          and MBOX_SP are not used. When clear, SP-SP
                                                          matches can occur. */
-	uint64_t all_fmp                      : 1;  /**< Controller X SP enable all FIRSTMP
+	uint64_t all_fmp                      : 1;  /**< Controller SP enable all FIRSTMP.
                                                          When set, no SP candidate messages ever
                                                          match siloed FMP segments and ID_FMP and MBOX_FMP
                                                          are not used. When clear, SP-FMP matches can
                                                          occur. */
-	uint64_t all_nmp                      : 1;  /**< Controller X SP enable all NFIRSTMP
+	uint64_t all_nmp                      : 1;  /**< Controller SP enable all NFIRSTMP.
                                                          When set, no SP candidate messages ever
                                                          match siloed NMP segments and ID_NMP and MBOX_NMP
                                                          are not used. When clear, SP-NMP matches can
                                                          occur. */
-	uint64_t all_psd                      : 1;  /**< Controller X SP enable all PSEUDO
+	uint64_t all_psd                      : 1;  /**< Controller SP enable all PSEUDO.
                                                          When set, no SP candidate messages ever
                                                          match the silo pseudo (for the other controller)
                                                          and ID_PSD and MBOX_PSD are not used. When clear,
@@ -2867,36 +3859,34 @@ union cvmx_sriox_omsg_sp_mrx {
 	struct cvmx_sriox_omsg_sp_mrx_s       cn63xx;
 	struct cvmx_sriox_omsg_sp_mrx_s       cn63xxp1;
 	struct cvmx_sriox_omsg_sp_mrx_s       cn66xx;
+	struct cvmx_sriox_omsg_sp_mrx_s       cn75xx;
 };
 typedef union cvmx_sriox_omsg_sp_mrx cvmx_sriox_omsg_sp_mrx_t;
 
 /**
  * cvmx_srio#_prio#_in_use
  *
- * SRIO_PRIO[0:3]_IN_USE = S2M PRIORITY FIFO IN USE COUNTS
- *
- * SRIO S2M Priority X FIFO Inuse counts
- *
- * Notes:
- * These registers provide status information on the number of read/write requests pending in the S2M
- *  Priority FIFOs.  The information can be used to help determine when an S2M_TYPE register can be
- *  reallocated.  For example, if an S2M_TYPE is used N times in a DMA write operation and the DMA has
- *  completed.  The register corresponding to the RD/WR_PRIOR of the S2M_TYPE can be read to determine
- *  the START_CNT and then can be polled to see if the END_CNT equals the START_CNT or at least
- *  START_CNT+N.   These registers can be accessed regardless of the value of SRIO(0,2..3)_STATUS_REG.ACCESS
- *  but are reset by either the MAC or Core being reset.
- *
- * Clk_Rst:        SRIO(0,2..3)_PRIO[0:3]_IN_USE   sclk    srst_n, hrst_n
+ * These registers provide status information on the number of
+ * read/write requests pending in the S2M Priority FIFOs.
+ * The information can be used to help determine when an S2M_TYPE
+ * register can be reallocated.  For example, if an S2M_TYPE
+ * is used N times in a DMA write operation and the DMA has
+ * completed.  The register corresponding to the RD/WR_PRIOR
+ * of the S2M_TYPE can be read to determine the START_CNT and
+ * then can be polled to see if the END_CNT equals the START_CNT
+ * or at least START_CNT+N.   These registers can be accessed
+ * regardless of the value of SRIO()_STATUS_REG[ACCESS]
+ * but are reset by either the MAC or Core being reset.
+ *
+ * This register is reset by the coprocessor-clock or h-clock reset.
  */
 union cvmx_sriox_priox_in_use {
 	uint64_t u64;
 	struct cvmx_sriox_priox_in_use_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t end_cnt                      : 16; /**< Count of Packets with S2M_TYPES completed for this
-                                                         Priority X FIFO */
-	uint64_t start_cnt                    : 16; /**< Count of Packets with S2M_TYPES started for this
-                                                         Priority X FIFO */
+	uint64_t end_cnt                      : 16; /**< Count of packets with S2M_TYPES completed for this priority FIFO. */
+	uint64_t start_cnt                    : 16; /**< Count of packets with S2M_TYPES started for this priority FIFO. */
 #else
 	uint64_t start_cnt                    : 16;
 	uint64_t end_cnt                      : 16;
@@ -2905,31 +3895,50 @@ union cvmx_sriox_priox_in_use {
 	} s;
 	struct cvmx_sriox_priox_in_use_s      cn63xx;
 	struct cvmx_sriox_priox_in_use_s      cn66xx;
+	struct cvmx_sriox_priox_in_use_s      cn75xx;
 };
 typedef union cvmx_sriox_priox_in_use cvmx_sriox_priox_in_use_t;
 
 /**
  * cvmx_srio#_rx_bell
  *
- * SRIO_RX_BELL = SRIO Receive Doorbell
- *
- * The SRIO Incoming (RX) Doorbell
+ * This register contains the SRIO Information, Device ID, Transaction Type
+ * and Priority of the incoming Doorbell Transaction as well as the number
+ * of transactions waiting to be read.  Reading this register causes a
+ * Doorbell to be removed from the RX Bell FIFO and the COUNT to be decremented.
+ * If the COUNT is zero then the FIFO is empty and the other fields should be
+ * considered invalid.  When the FIFO is full an ERROR is automatically issued.
+ * The RXBELL Interrupt can be used to detect posts to this FIFO.
  *
- * Notes:
- * This register contains the SRIO Information, Device ID, Transaction Type and Priority of the
- *  incoming Doorbell Transaction as well as the number of transactions waiting to be read.  Reading
- *  this register causes a Doorbell to be removed from the RX Bell FIFO and the COUNT to be
- *  decremented.  If the COUNT is zero then the FIFO is empty and the other fields should be
- *  considered invalid.  When the FIFO is full an ERROR is automatically issued.  The RXBELL Interrupt
- *  can be used to detect posts to this FIFO.
- *
- * Clk_Rst:        SRIO(0,2..3)_RX_BELL    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_rx_bell {
 	uint64_t u64;
 	struct cvmx_sriox_rx_bell_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field from received doorbell. */
+	uint64_t src_id                       : 16; /**< Doorbell Source Device ID[15:0]. */
+	uint64_t count                        : 8;  /**< RX bell FIFO count.
+                                                         Count must be > 0x0 for entry to be valid. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t dest_id                      : 1;  /**< Destination device ID. 0=Primary, 1=Secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t id16                         : 1;
+	uint64_t dest_id                      : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t count                        : 8;
+	uint64_t src_id                       : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_sriox_rx_bell_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
 	uint64_t data                         : 16; /**< Information field from received doorbell */
 	uint64_t src_id                       : 16; /**< Doorbell Source Device ID[15:0] */
 	uint64_t count                        : 8;  /**< RX Bell FIFO Count
@@ -2950,36 +3959,90 @@ union cvmx_sriox_rx_bell {
 	uint64_t data                         : 16;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} s;
-	struct cvmx_sriox_rx_bell_s           cn63xx;
-	struct cvmx_sriox_rx_bell_s           cn63xxp1;
-	struct cvmx_sriox_rx_bell_s           cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_rx_bell_cn63xx      cn63xxp1;
+	struct cvmx_sriox_rx_bell_cn63xx      cn66xx;
+	struct cvmx_sriox_rx_bell_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field from received doorbell. */
+	uint64_t src_id                       : 16; /**< Doorbell Source Device ID[15:0]. */
+	uint64_t count                        : 8;  /**< RX bell FIFO count.
+                                                         Count must be > 0x0 for entry to be valid. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t dest_id                      : 1;  /**< Destination device ID. 0=Primary, 1=Secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t prior                        : 2;  /**< Doorbell priority. */
+#else
+	uint64_t prior                        : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t id16                         : 1;
+	uint64_t dest_id                      : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t count                        : 8;
+	uint64_t src_id                       : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_rx_bell cvmx_sriox_rx_bell_t;
 
 /**
- * cvmx_srio#_rx_bell_seq
+ * cvmx_srio#_rx_bell_ctrl
  *
- * SRIO_RX_BELL_SEQ = SRIO Receive Doorbell Sequence Count
+ * This register is used to control the number and size of RX Doorbell FIFOs.
+ * The NUM_FIFO field should only be changed when SRIOMAINT()_CORE_ENABLES[DOORBELL]
+ * is disabled and the FIFOs are empty or doorbells may be lost.
  *
- * The SRIO Incoming (RX) Doorbell Sequence Count
+ * This register is reset by the h-clock reset.
+ */
+union cvmx_sriox_rx_bell_ctrl {
+	uint64_t u64;
+	struct cvmx_sriox_rx_bell_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t num_fifo                     : 3;  /**< Number, size and access of RX Doorbell FIFOs.
+                                                         0x0 = Single 128 Entry FIFO accessed by
+                                                               SRIO()_RX_BELL and SRIO()_RX_BELL_SEQ
+                                                         For all other values Doorbell FIFOs can be
+                                                         accessed by reading DPI_SRIO_RX_BELL and
+                                                         DPI_SRIO_RX_BELL_SEQ and status can be found in
+                                                         CIU_SRIO_BELL_STATUS.
+                                                         0x1 = Single 128 entry FIFO.
+                                                         0x2 = Two 64 entry FIFOs.
+                                                         0x3 = Four 32 entry FIFOs.
+                                                         0x4 = Eight 16 entry FIFOs.
+                                                         0x5 = Sixteen 8 entry FIFOs.
+                                                         _ All values others reserved. */
+#else
+	uint64_t num_fifo                     : 3;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_sriox_rx_bell_ctrl_s      cn75xx;
+};
+typedef union cvmx_sriox_rx_bell_ctrl cvmx_sriox_rx_bell_ctrl_t;
+
+/**
+ * cvmx_srio#_rx_bell_seq
  *
- * Notes:
- * This register contains the value of the sequence counter when the doorbell was received and a
- *  shadow copy of the Bell FIFO Count that can be read without emptying the FIFO.  This register must
- *  be read prior to SRIO(0,2..3)_RX_BELL to guarantee that the information corresponds to the correct
- *  doorbell.
+ * This register contains the value of the sequence counter when the doorbell
+ * was received and a shadow copy of the Bell FIFO Count that can be read without
+ * emptying the FIFO.  This register must be read prior to SRIO()_RX_BELL to
+ * guarantee that the information corresponds to the correct doorbell.
  *
- * Clk_Rst:        SRIO(0,2..3)_RX_BELL_SEQ        hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_rx_bell_seq {
 	uint64_t u64;
 	struct cvmx_sriox_rx_bell_seq_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
-	uint64_t count                        : 8;  /**< RX Bell FIFO Count
-                                                         Note:  Count must be > 0 for entry to be valid. */
-	uint64_t seq                          : 32; /**< 32-bit Sequence \# associated with Doorbell Message */
+	uint64_t count                        : 8;  /**< RX bell fifo count.
+                                                         Count must be > 0x0 for entry to be valid. */
+	uint64_t seq                          : 32; /**< 32-bit sequence number associated with doorbell message. */
 #else
 	uint64_t seq                          : 32;
 	uint64_t count                        : 8;
@@ -2989,28 +4052,49 @@ union cvmx_sriox_rx_bell_seq {
 	struct cvmx_sriox_rx_bell_seq_s       cn63xx;
 	struct cvmx_sriox_rx_bell_seq_s       cn63xxp1;
 	struct cvmx_sriox_rx_bell_seq_s       cn66xx;
+	struct cvmx_sriox_rx_bell_seq_s       cn75xx;
 };
 typedef union cvmx_sriox_rx_bell_seq cvmx_sriox_rx_bell_seq_t;
 
 /**
  * cvmx_srio#_rx_status
  *
- * SRIO_RX_STATUS = SRIO Inbound Credits/Response Status
- *
- * Specifies the current number of credits/responses by SRIO for Inbound Traffic
- *
- * Notes:
- * Debug Register specifying the number of credits/responses currently in use for Inbound Traffic.
- *  The maximum value for COMP, N_POST and POST is set in SRIO(0,2..3)_TLP_CREDITS.  When all inbound traffic
- *  has stopped the values should eventually return to the maximum values.  The RTN_PR[3:1] entry
- *  counts should eventually return to the reset values.
+ * Debug Register specifying the number of credits/responses
+ * currently in use for inbound traffic.  The maximum value
+ * for COMP, N_POST and POST is set in SRIO()_TLP_CREDITS.
+ * When all inbound traffic has stopped the values should
+ * eventually return to the maximum values.  The RTN_PR[3:1] entry
+ * counts should eventually return to the reset values.
  *
- * Clk_Rst:        SRIO(0,2..3)_RX_STATUS  hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_rx_status {
 	uint64_t u64;
 	struct cvmx_sriox_rx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t rtn_pr3                      : 8;  /**< Number of pending priority 3 response entries. */
+	uint64_t rtn_pr2                      : 8;  /**< Number of pending priority 2 response entries. */
+	uint64_t rtn_pr1                      : 8;  /**< Number of pending priority 1 response entries. */
+	uint64_t reserved_29_39               : 11;
+	uint64_t mbox                         : 5;  /**< Credits for mailbox data used in X2P. */
+	uint64_t comp                         : 8;  /**< Credits for read completions used in M2S. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t n_post                       : 5;  /**< Credits for read requests used in M2S. */
+	uint64_t post                         : 8;  /**< Credits for write request postings used in M2S. */
+#else
+	uint64_t post                         : 8;
+	uint64_t n_post                       : 5;
+	uint64_t reserved_13_15               : 3;
+	uint64_t comp                         : 8;
+	uint64_t mbox                         : 5;
+	uint64_t reserved_29_39               : 11;
+	uint64_t rtn_pr1                      : 8;
+	uint64_t rtn_pr2                      : 8;
+	uint64_t rtn_pr3                      : 8;
+#endif
+	} s;
+	struct cvmx_sriox_rx_status_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t rtn_pr3                      : 8;  /**< Number of pending Priority 3 Response Entries. */
 	uint64_t rtn_pr2                      : 8;  /**< Number of pending Priority 2 Response Entries. */
 	uint64_t rtn_pr1                      : 8;  /**< Number of pending Priority 1 Response Entries. */
@@ -3031,40 +4115,35 @@ union cvmx_sriox_rx_status {
 	uint64_t rtn_pr2                      : 8;
 	uint64_t rtn_pr3                      : 8;
 #endif
-	} s;
-	struct cvmx_sriox_rx_status_s         cn63xx;
-	struct cvmx_sriox_rx_status_s         cn63xxp1;
-	struct cvmx_sriox_rx_status_s         cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_rx_status_cn63xx    cn63xxp1;
+	struct cvmx_sriox_rx_status_cn63xx    cn66xx;
+	struct cvmx_sriox_rx_status_s         cn75xx;
 };
 typedef union cvmx_sriox_rx_status cvmx_sriox_rx_status_t;
 
 /**
  * cvmx_srio#_s2m_type#
  *
- * SRIO_S2M_TYPE[0:15] = SLI to SRIO MAC Operation Type
- *
- * SRIO Operation Type selected by PP or DMA Accesses
- *
- * Notes:
- * This CSR table specifies how to convert a SLI/DPI MAC read or write into sRIO operations.
- *  Each SLI/DPI read or write access supplies a 64-bit address (MACADD[63:0]), 2-bit ADDRTYPE, and
- *  2-bit endian-swap. This SRIO*_S2M_TYPE* CSR description specifies a table with 16 CSRs. SRIO
- *  selects one of the table entries with TYPEIDX[3:0], which it creates from the SLI/DPI MAC memory
- *  space read or write as follows:
- *    TYPEIDX[1:0] = ADDRTYPE[1:0] (ADDRTYPE[1] is no-snoop to the PCIe MAC,
- *                                  ADDRTYPE[0] is relaxed-ordering to the PCIe MAC)
- *    TYPEIDX[2] = MACADD[50]
- *    TYPEIDX[3] = MACADD[59]
- *
- * Clk_Rst:        SRIO(0,2..3)_S2M_TYPE[0:15]     hclk    hrst_n
+ * This CSR table specifies how to convert a SLI/DPI MAC read or write
+ * into sRIO operations.  Each SLI/DPI read or write access supplies a
+ * 64-bit address (MACADD[63:0]), 2-bit ADDRTYPE and 2-bit endian-swap.
+ * This SRIO()_S2M_TYPE* CSR description specifies a table with 16 CSRs.
+ * SRIO selects one of the table entries with TYPEIDX[3:0], which it
+ * creates from the SLI/DPI MAC memory space read or write as follows:
+ *   TYPEIDX[1:0] = ADDRTYPE[1:0] (ADDRTYPE[1] is no-snoop to the PCIe MAC,
+ *   ADDRTYPE[0] is relaxed-ordering to the PCIe MAC)
+ *   TYPEIDX[2] = MACADD[50]
+ *   TYPEIDX[3] = MACADD[59]
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_s2m_typex {
 	uint64_t u64;
 	struct cvmx_sriox_s2m_typex_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_19_63               : 45;
-	uint64_t wr_op                        : 3;  /**< sRIO operation for SLI/DPI writes
-
+	uint64_t wr_op                        : 3;  /**< sRIO operation for SLI/DPI writes.
                                                          SLI/DPI hardware break MAC memory space writes
                                                          that they generate into pieces of maximum size
                                                          256B. For NWRITE/NWRITE_R/SWRITE WR_OP variants
@@ -3080,149 +4159,131 @@ union cvmx_sriox_s2m_typex {
                                                          so that all MAC memory space writes with
                                                          MAINTENANCE write and port-write WR_OP's can be
                                                          serviced in a single sRIO operation.
-
                                                          SRIO always sends the write data (64-bit) words
                                                          out in order.
-
-                                                          WR_OP = 0 = Normal Write (NWRITE)
-                                                                 SRIO breaks a MAC memory space write into
-                                                                 the minimum number of required sRIO NWRITE
-                                                                 operations. This will be 1-5 total NWRITEs,
-                                                                 depending on endian-swap, alignment, and
-                                                                 length.
-
-                                                          WR_OP = 1 = Normal Write w/Response (NWRITE_R)
-                                                                 SRIO breaks a MAC memory space write into
-                                                                 the minimum number of required sRIO
-                                                                 NWRITE_R operations. This will be 1-5 total
-                                                                 NWRITE_R's, depending on endian-swap,
-                                                                 alignment, and length.
-
-                                                                 SRIO sets SRIO*_INT_REG[WR_DONE] after it
-                                                                 receives the DONE response for the last
-                                                                 NWRITE_R sent.
-
-                                                          WR_OP = 2 = NWRITE, Streaming write (SWRITE),
-                                                                      NWRITE
-                                                                 SRIO attempts to turn the MAC memory space
-                                                                 write into an SWRITE operation. There will
-                                                                 be 1-5 total sRIO operations (0-2 NWRITE's
-                                                                 followed by 0-1 SWRITE's followed by 0-2
-                                                                 NWRITE's) generated to complete the MAC
-                                                                 memory space write, depending on
-                                                                 endian-swap, alignment, and length.
-
-                                                                 If the starting address is not 64-bit
-                                                                 aligned, SRIO first creates 1-4 NWRITE's to
-                                                                 either align it or complete the write. Then
-                                                                 SRIO creates a SWRITE including all aligned
-                                                                 64-bit words. (SRIO won't create an SWRITE
-                                                                 when there are none.) If store data
-                                                                 remains, SRIO finally creates another 1 or
-                                                                 2 NWRITE's.
-
-                                                          WR_OP = 3 = NWRITE, SWRITE, NWRITE_R
-                                                                 SRIO attempts to turn the MAC memory space
-                                                                 write into an SWRITE operation followed by
-                                                                 a NWRITE_R operation. The last operation
-                                                                 is always NWRITE_R. There will be 1-5
-                                                                 total sRIO operations (0-2 NWRITE's,
-                                                                 followed by 0-1 SWRITE, followed by 1-4
-                                                                 NWRITE_R's) generated to service the MAC
-                                                                 memory space write, depending on
-                                                                 endian-swap, alignment, and length.
-
-                                                                 If the write is contained in one aligned
-                                                                 64-bit word, SRIO will completely service
-                                                                 the MAC memory space write with 1-4
-                                                                 NWRITE_R's.
-
-                                                                 Otherwise, if the write spans multiple
-                                                                 words, SRIO services the write as follows.
-                                                                 First, if the start of the write is not
-                                                                 word-aligned, SRIO creates 1 or 2 NWRITE's
-                                                                 to align it. Then SRIO creates an SWRITE
-                                                                 that includes all aligned 64-bit words,
-                                                                 leaving data for the final NWRITE_R(s).
-                                                                 (SRIO won't create the SWRITE when there is
-                                                                 no data for it.) Then SRIO finally creates
-                                                                 1 or 2 NWRITE_R's.
-
-                                                                 In any case, SRIO sets
-                                                                 SRIO*_INT_REG[WR_DONE] after it receives
-                                                                 the DONE response for the last NWRITE_R
-                                                                 sent.
-
-                                                          WR_OP = 4 = NWRITE, NWRITE_R
-                                                                 SRIO attempts to turn the MAC memory space
-                                                                 write into an NWRITE operation followed by
-                                                                 a NWRITE_R operation. The last operation
-                                                                 is always NWRITE_R. There will be 1-5
-                                                                 total sRIO operations (0-3 NWRITE's
-                                                                 followed by 1-4 NWRITE_R's) generated to
-                                                                 service the MAC memory space write,
-                                                                 depending on endian-swap, alignment, and
-                                                                 length.
-
-                                                                 If the write is contained in one aligned
-                                                                 64-bit word, SRIO will completely service
-                                                                 the MAC memory space write with 1-4
-                                                                 NWRITE_R's.
-
-                                                                 Otherwise, if the write spans multiple
-                                                                 words, SRIO services the write as follows.
-                                                                 First, if the start of the write is not
-                                                                 word-aligned, SRIO creates 1 or 2 NWRITE's
-                                                                 to align it. Then SRIO creates an NWRITE
-                                                                 that includes all aligned 64-bit words,
-                                                                 leaving data for the final NWRITE_R(s).
-                                                                 (SRIO won't create this NWRITE when there
-                                                                 is no data for it.) Then SRIO finally
-                                                                 creates 1 or 2 NWRITE_R's.
-
-                                                                 In any case, SRIO sets
-                                                                 SRIO*_INT_REG[WR_DONE] after it receives
-                                                                 the DONE response for the last NWRITE_R
-                                                                 sent.
-
-                                                          WR_OP = 5 = Reserved
-
-                                                          WR_OP = 6 = Maintenance Write
-                                                               - SRIO will create one sRIO MAINTENANCE write
-                                                                 operation to service the MAC memory space
-                                                                 write
-                                                               - IAOW_SEL must be zero. (see description
-                                                                 below.)
-                                                               - MDS must be zero. (MDS is MACADD[63:62] -
-                                                                 see IAOW_SEL description below.)
-                                                               - Hop Cnt is MACADD[31:24]/SRIOAddress[31:24]
-                                                               - MACADD[23:0]/SRIOAddress[23:0] selects
-                                                                 maintenance register (i.e. config_offset)
-                                                               - sRIODestID[15:0] is MACADD[49:34].
-                                                                 (MACADD[49:42] unused when ID16=0)
-                                                               - Write size/alignment must obey sRIO rules
-                                                                 (4, 8, 16, 24, 32, 40, 48, 56 and 64 byte
-                                                                 lengths allowed)
-
-                                                          WR_OP = 7 = Maintenance Port Write
-                                                               - SRIO will create one sRIO MAINTENANCE port
-                                                                 write operation to service the MAC memory
-                                                                 space write
-                                                               - IAOW_SEL must be zero. (see description
-                                                                 below.)
-                                                               - MDS must be zero. (MDS is MACADD[63:62] -
-                                                                 see IAOW_SEL description below.)
-                                                               - Hop Cnt is MACADD[31:24]/sRIOAddress[31:24]
-                                                               - MACADD[23:0]/sRIOAddress[23:0] MBZ
-                                                                 (config_offset field reserved by sRIO)
-                                                               - sRIODestID[15:0] is MACADD[49:34].
-                                                                 (MACADD[49:42] unused when ID16=0)
-                                                               - Write size/alignment must obey sRIO rules
-                                                                 (4, 8, 16, 24, 32, 40, 48, 56 and 64 byte
-                                                                 lengths allowed) */
+                                                         WR_OP = 0 = Normal Write (NWRITE)
+                                                         SRIO breaks a MAC memory space write into
+                                                         the minimum number of required sRIO NWRITE
+                                                         operations. This will be 1-5 total NWRITEs,
+                                                         depending on endian-swap, alignment, and
+                                                         length.
+                                                         WR_OP = 1 = Normal Write w/Response (NWRITE_R)
+                                                         SRIO breaks a MAC memory space write into
+                                                         the minimum number of required sRIO
+                                                         NWRITE_R operations. This will be 1-5 total
+                                                         NWRITE_R's, depending on endian-swap,
+                                                         alignment, and length.
+                                                         SRIO sets SRIO()_INT_REG[WR_DONE] after it
+                                                         receives the DONE response for the last
+                                                         NWRITE_R sent.
+                                                         WR_OP = 2 = NWRITE, Streaming write (SWRITE),
+                                                         NWRITE
+                                                         SRIO attempts to turn the MAC memory space
+                                                         write into an SWRITE operation. There will
+                                                         be 1-5 total sRIO operations (0-2 NWRITE's
+                                                         followed by 0-1 SWRITE's followed by 0-2
+                                                         NWRITE's) generated to complete the MAC
+                                                         memory space write, depending on
+                                                         endian-swap, alignment, and length.
+                                                         If the starting address is not 64-bit
+                                                         aligned, SRIO first creates 1-4 NWRITE's to
+                                                         either align it or complete the write. Then
+                                                         SRIO creates a SWRITE including all aligned
+                                                         64-bit words. (SRIO won't create an SWRITE
+                                                         when there are none.) If store data
+                                                         remains, SRIO finally creates another 1 or
+                                                         2 NWRITE's.
+                                                         WR_OP = 3 = NWRITE, SWRITE, NWRITE_R
+                                                         SRIO attempts to turn the MAC memory space
+                                                         write into an SWRITE operation followed by
+                                                         a NWRITE_R operation. The last operation
+                                                         is always NWRITE_R. There will be 1-5
+                                                         total sRIO operations (0-2 NWRITE's,
+                                                         followed by 0-1 SWRITE, followed by 1-4
+                                                         NWRITE_R's) generated to service the MAC
+                                                         memory space write, depending on
+                                                         endian-swap, alignment, and length.
+                                                         If the write is contained in one aligned
+                                                         64-bit word, SRIO will completely service
+                                                         the MAC memory space write with 1-4
+                                                         NWRITE_R's.
+                                                         Otherwise, if the write spans multiple
+                                                         words, SRIO services the write as follows.
+                                                         First, if the start of the write is not
+                                                         word-aligned, SRIO creates 1 or 2 NWRITE's
+                                                         to align it. Then SRIO creates an SWRITE
+                                                         that includes all aligned 64-bit words,
+                                                         leaving data for the final NWRITE_R(s).
+                                                         (SRIO won't create the SWRITE when there is
+                                                         no data for it.) Then SRIO finally creates
+                                                         1 or 2 NWRITE_R's.
+                                                         In any case, SRIO sets
+                                                         SRIO()_INT_REG[WR_DONE] after it receives
+                                                         the DONE response for the last NWRITE_R
+                                                         sent.
+                                                         WR_OP = 4 = NWRITE, NWRITE_R
+                                                         SRIO attempts to turn the MAC memory space
+                                                         write into an NWRITE operation followed by
+                                                         a NWRITE_R operation. The last operation
+                                                         is always NWRITE_R. There will be 1-5
+                                                         total sRIO operations (0-3 NWRITE's
+                                                         followed by 1-4 NWRITE_R's) generated to
+                                                         service the MAC memory space write,
+                                                         depending on endian-swap, alignment, and
+                                                         length.
+                                                         If the write is contained in one aligned
+                                                         64-bit word, SRIO will completely service
+                                                         the MAC memory space write with 1-4
+                                                         NWRITE_R's.
+                                                         Otherwise, if the write spans multiple
+                                                         words, SRIO services the write as follows.
+                                                         First, if the start of the write is not
+                                                         word-aligned, SRIO creates 1 or 2 NWRITE's
+                                                         to align it. Then SRIO creates an NWRITE
+                                                         that includes all aligned 64-bit words,
+                                                         leaving data for the final NWRITE_R(s).
+                                                         (SRIO won't create this NWRITE when there
+                                                         is no data for it.) Then SRIO finally
+                                                         creates 1 or 2 NWRITE_R's.
+                                                         In any case, SRIO sets
+                                                         SRIO()_INT_REG[WR_DONE] after it receives
+                                                         the DONE response for the last NWRITE_R
+                                                         sent.
+                                                         WR_OP = 5 = Reserved
+                                                         WR_OP = 6 = Maintenance Write
+                                                         - SRIO will create one sRIO MAINTENANCE write
+                                                         operation to service the MAC memory space
+                                                         write
+                                                         - IAOW_SEL must be zero. (see description
+                                                         below.)
+                                                         - MDS must be zero. (MDS is MACADD[63:62] -
+                                                         see IAOW_SEL description below.)
+                                                         - Hop Cnt is MACADD[31:24]/SRIOAddress[31:24]
+                                                         - MACADD[23:0]/SRIOAddress[23:0] selects
+                                                         maintenance register (i.e. config_offset)
+                                                         - sRIODestID[15:0] is MACADD[49:34].
+                                                         (MACADD[49:42] unused when ID16=0)
+                                                         - Write size/alignment must obey sRIO rules
+                                                         (4, 8, 16, 24, 32, 40, 48, 56 and 64 byte
+                                                         lengths allowed)
+                                                         WR_OP = 7 = Maintenance Port Write
+                                                         - SRIO will create one sRIO MAINTENANCE port
+                                                         write operation to service the MAC memory
+                                                         space write
+                                                         - IAOW_SEL must be zero. (see description
+                                                         below.)
+                                                         - MDS must be zero. (MDS is MACADD[63:62] -
+                                                         see IAOW_SEL description below.)
+                                                         - Hop Cnt is MACADD[31:24]/sRIOAddress[31:24]
+                                                         - MACADD[23:0]/sRIOAddress[23:0] MBZ
+                                                         (config_offset field reserved by sRIO)
+                                                         - sRIODestID[15:0] is MACADD[49:34].
+                                                         (MACADD[49:42] unused when ID16=0)
+                                                         - Write size/alignment must obey sRIO rules
+                                                         (4, 8, 16, 24, 32, 40, 48, 56 and 64 byte
+                                                         lengths allowed) */
 	uint64_t reserved_15_15               : 1;
 	uint64_t rd_op                        : 3;  /**< sRIO operation for SLI/DPI reads
-
                                                          SLI/DPI hardware and sRIO configuration
                                                          restrictions guarantee that SRIO can service any
                                                          MAC memory space read that it receives from SLI/DPI
@@ -3237,80 +4298,69 @@ union cvmx_sriox_s2m_typex {
                                                          that the cores issue such that all MAC memory space
                                                          reads with ATOMIC and MAINTENANCE RD_OP's can be
                                                          serviced in a single sRIO operation.
-
-                                                          RD_OP = 0 = Normal Read (NREAD)
-                                                               - SRIO will create one sRIO NREAD
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (up to 256 byte lengths). (This requirement
-                                                                 is guaranteed by SLI/DPI usage restrictions
-                                                                 and configuration.)
-
-                                                          RD_OP = 1 = Reserved
-
-                                                          RD_OP = 2 = Atomic Set
-                                                               - SRIO will create one sRIO ATOMIC set
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (1, 2, and 4 byte lengths allowed)
-
-                                                          RD_OP = 3 = Atomic Clear
-                                                               - SRIO will create one sRIO ATOMIC clr
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (1, 2, and 4 byte lengths allowed)
-
-                                                          RD_OP = 4 = Atomic Increment
-                                                               - SRIO will create one sRIO ATOMIC inc
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (1, 2, and 4 byte lengths allowed)
-
-                                                          RD_OP = 5 = Atomic Decrement
-                                                               - SRIO will create one sRIO ATOMIC dec
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (1, 2, and 4 byte lengths allowed)
-
-                                                          RD_OP = 6 = Maintenance Read
-                                                               - SRIO will create one sRIO MAINTENANCE read
-                                                                 operation to service the MAC memory
-                                                                 space read
-                                                               - IAOW_SEL must be zero. (see description
-                                                                 below.)
-                                                               - MDS must be zero. (MDS is MACADD[63:62] -
-                                                                 see IAOW_SEL description below.)
-                                                               - Hop Cnt is MACADD[31:24]/sRIOAddress[31:24]
-                                                               - MACADD[23:0]/sRIOAddress[23:0] selects
-                                                                 maintenance register (i.e. config_offset)
-                                                               - sRIODestID[15:0] is MACADD[49:34].
-                                                                 (MACADD[49:42] unused when ID16=0)
-                                                               - Read size/alignment must obey sRIO rules
-                                                                 (4, 8, 16, 32 and 64 byte lengths allowed)
-
-                                                          RD_OP = 7 = Reserved */
-	uint64_t wr_prior                     : 2;  /**< Transaction Priority 0-3 used for writes */
-	uint64_t rd_prior                     : 2;  /**< Transaction Priority 0-3 used for reads/ATOMICs */
+                                                         RD_OP = 0 = Normal Read (NREAD)
+                                                         - SRIO will create one sRIO NREAD
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (up to 256 byte lengths). (This requirement
+                                                         is guaranteed by SLI/DPI usage restrictions
+                                                         and configuration.)
+                                                         RD_OP = 1 = Reserved
+                                                         RD_OP = 2 = Atomic Set
+                                                         - SRIO will create one sRIO ATOMIC set
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (1, 2, and 4 byte lengths allowed)
+                                                         RD_OP = 3 = Atomic Clear
+                                                         - SRIO will create one sRIO ATOMIC clr
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (1, 2, and 4 byte lengths allowed)
+                                                         RD_OP = 4 = Atomic Increment
+                                                         - SRIO will create one sRIO ATOMIC inc
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (1, 2, and 4 byte lengths allowed)
+                                                         RD_OP = 5 = Atomic Decrement
+                                                         - SRIO will create one sRIO ATOMIC dec
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (1, 2, and 4 byte lengths allowed)
+                                                         RD_OP = 6 = Maintenance Read
+                                                         - SRIO will create one sRIO MAINTENANCE read
+                                                         operation to service the MAC memory
+                                                         space read
+                                                         - IAOW_SEL must be zero. (see description
+                                                         below.)
+                                                         - MDS must be zero. (MDS is MACADD[63:62] -
+                                                         see IAOW_SEL description below.)
+                                                         - Hop Cnt is MACADD[31:24]/sRIOAddress[31:24]
+                                                         - MACADD[23:0]/sRIOAddress[23:0] selects
+                                                         maintenance register (i.e. config_offset)
+                                                         - sRIODestID[15:0] is MACADD[49:34].
+                                                         (MACADD[49:42] unused when ID16=0)
+                                                         - Read size/alignment must obey sRIO rules
+                                                         (4, 8, 16, 32 and 64 byte lengths allowed)
+                                                         RD_OP = 7 = Reserved */
+	uint64_t wr_prior                     : 2;  /**< Transaction priority 0-3 used for writes. */
+	uint64_t rd_prior                     : 2;  /**< Transaction priority 0-3 used for reads/ATOMICs */
 	uint64_t reserved_6_7                 : 2;
-	uint64_t src_id                       : 1;  /**< Source ID
-
-                                                         0 = Use Primary ID as Source ID
-                                                             (SRIOMAINT*_PRI_DEV_ID[ID16 or ID8], depending
-                                                             on SRIO TT ID (i.e. ID16 below))
-
-                                                         1 = Use Secondary ID as Source ID
-                                                             (SRIOMAINT*_SEC_DEV_ID[ID16 or ID8], depending
-                                                             on SRIO TT ID (i.e. ID16 below)) */
-	uint64_t id16                         : 1;  /**< SRIO TT ID 0=8bit, 1=16-bit
+	uint64_t src_id                       : 1;  /**< Source ID.
+                                                         0 = Use primary ID as source ID
+                                                         (SRIOMAINT()_PRI_DEV_ID[ID16 or ID8], depending
+                                                         on SRIO TT ID (i.e. ID16 below)).
+                                                         1 = Use secondary ID as source ID
+                                                         (SRIOMAINT()_SEC_DEV_ID[ID16 or ID8], depending
+                                                         on SRIO TT ID (i.e. ID16 below)). */
+	uint64_t id16                         : 1;  /**< SRIO TT ID 0=8bit, 1=16-bit.
                                                          IAOW_SEL must not be 2 when ID16=1. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t iaow_sel                     : 2;  /**< Internal Address Offset Width Select
-
+	uint64_t iaow_sel                     : 2;  /**< Internal address offset width select.
                                                          IAOW_SEL determines how to convert the
                                                          MACADD[63:62,58:51,49:0] recieved from SLI/DPI with
                                                          read/write into an sRIO address (sRIOAddress[...])
@@ -3318,109 +4368,96 @@ union cvmx_sriox_s2m_typex {
                                                          address width mode (SRIOMAINT_PE_LLC[EX_ADDR]) and
                                                          ID16, determine the  width of the sRIO address and
                                                          ID in the outgoing request(s), respectively.
-
                                                          MACADD[61:60] is always unused.
-
                                                          MACADD[59] is always TYPEIDX[3]
                                                          MACADD[50] is always TYPEIDX[2]
-                                                          (TYPEIDX[3:0] selects one of these
-                                                          SRIO*_S2M_TYPE* table entries.)
-
+                                                         (TYPEIDX[3:0] selects one of these
+                                                         SRIO()_S2M_TYPE* table entries.)
                                                          MACADD[17:0] always becomes sRIOAddress[17:0].
-
-                                                          IAOW_SEL = 0 = 34-bit Address Offset
-
-                                                              Must be used when sRIO link is in 34-bit
-                                                               address width mode.
-                                                              When sRIO is in 50-bit address width mode,
-                                                               sRIOAddress[49:34]=0 in the outgoing request.
-                                                              When sRIO is in 66-bit address width mode,
-                                                               sRIOAddress[65:34]=0 in the outgoing request.
-
-                                                              Usage of the SLI/DPI MAC address when
-                                                              IAOW_SEL = 0:
-                                                               MACADD[63:62] = Multi-Device Swap (MDS)
-                                                                 MDS value affects MACADD[49:18] usage
-                                                               MACADD[58:51] => unused
-                                                               MACADD[49:18] usage depends on MDS value
-                                                                MDS = 0
-                                                                  MACADD[49:34] => sRIODestID[15:0]
-                                                                    (MACADD[49:42] unused when ID16=0)
-                                                                  MACADD[33:18] => sRIOAddress[33:18]
-                                                                MDS = 1
-                                                                  MACADD[49:42] => sRIODestID[15:8]
-                                                                    (MACADD[49:42] unused when ID16 = 0)
-                                                                  MACADD[41:34] => sRIOAddress[33:26]
-                                                                  MACADD[33:26] => sRIODestID[7:0]
-                                                                  MACADD[25:18] => sRIOAddress[25:18]
-                                                                MDS = 2
-                                                                  ID16 must be one.
-                                                                  MACADD[49:34] => sRIOAddress[33:18]
-                                                                  MACADD[33:18] => sRIODestID[15:0]
-                                                                MDS = 3 = Reserved
-
-                                                          IAOW_SEL = 1 = 42-bit Address Offset
-
-                                                              Must not be used when sRIO link is in 34-bit
-                                                               address width mode.
-                                                              When sRIO is in 50-bit address width mode,
-                                                               sRIOAddress[49:42]=0 in the outgoing request.
-                                                              When sRIO is in 66-bit address width mode,
-                                                               sRIOAddress[65:42]=0 in the outgoing request.
-
-                                                              Usage of the SLI/DPI MAC address when
-                                                              IAOW_SEL = 1:
-                                                               MACADD[63:62] => Multi-Device Swap (MDS)
-                                                                 MDS value affects MACADD[58:51,49:42,33:18]
-                                                                   use
-                                                               MACADD[41:34] => sRIOAddress[41:34]
-                                                               MACADD[58:51,49:42,33:18] usage depends on
-                                                               MDS value:
-                                                                MDS = 0
-                                                                  MACADD[58:51] => sRIODestID[15:8]
-                                                                  MACADD[49:42] => sRIODestID[7:0]
-                                                                    (MACADD[58:51] unused when ID16=0)
-                                                                  MACADD[33:18] => sRIOAddress[33:18]
-                                                                MDS = 1
-                                                                  MACADD[58:51] => sRIODestID[15:8]
-                                                                    (MACADD[58:51] unused when ID16 = 0)
-                                                                  MACADD[49:42] => sRIOAddress[33:26]
-                                                                  MACADD[33:26] => sRIODestID[7:0]
-                                                                  MACADD[25:18] => sRIOAddress[25:18]
-                                                                MDS = 2
-                                                                  ID16 must be one.
-                                                                  MACADD[58:51] => sRIOAddress[33:26]
-                                                                  MACADD[49:42] => sRIOAddress[25:18]
-                                                                  MACADD[33:18] => sRIODestID[15:0]
-                                                                MDS = 3 = Reserved
-
-                                                          IAOW_SEL = 2 = 50-bit Address Offset
-
-                                                              Must not be used when sRIO link is in 34-bit
-                                                               address width mode.
-                                                              Must not be used when ID16=1.
-                                                              When sRIO is in 66-bit address width mode,
-                                                               sRIOAddress[65:50]=0 in the outgoing request.
-
-                                                              Usage of the SLI/DPI MAC address when
-                                                              IAOW_SEL = 2:
-                                                               MACADD[63:62] => Multi-Device Swap (MDS)
-                                                                 MDS value affects MACADD[58:51,33:26] use
-                                                                 MDS value 3 is reserved
-                                                               MACADD[49:34] => sRIOAddress[49:34]
-                                                               MACADD[25:18] => sRIOAddress[25:18]
-                                                               MACADD[58:51,33:26] usage depends on
-                                                               MDS value:
-                                                                MDS = 0
-                                                                  MACADD[58:51] => sRIODestID[7:0]
-                                                                  MACADD[33:26] => sRIOAddress[33:26]
-                                                                MDS = 1
-                                                                  MACADD[58:51] => sRIOAddress[33:26]
-                                                                  MACADD[33:26] => sRIODestID[7:0]
-                                                                MDS = 2 = Reserved
-                                                                MDS = 3 = Reserved
-
-                                                          IAOW_SEL = 3 = Reserved */
+                                                         IAOW_SEL = 0 = 34-bit Address Offset
+                                                         Must be used when sRIO link is in 34-bit
+                                                         address width mode.
+                                                         When sRIO is in 50-bit address width mode,
+                                                         sRIOAddress[49:34]=0 in the outgoing request.
+                                                         When sRIO is in 66-bit address width mode,
+                                                         sRIOAddress[65:34]=0 in the outgoing request.
+                                                         Usage of the SLI/DPI MAC address when
+                                                         IAOW_SEL = 0:
+                                                         MACADD[63:62] = Multi-Device Swap (MDS)
+                                                         MDS value affects MACADD[49:18] usage
+                                                         MACADD[58:51] => unused
+                                                         MACADD[49:18] usage depends on MDS value
+                                                         MDS = 0
+                                                         MACADD[49:34] => sRIODestID[15:0]
+                                                         (MACADD[49:42] unused when ID16=0)
+                                                         MACADD[33:18] => sRIOAddress[33:18]
+                                                         MDS = 1
+                                                         MACADD[49:42] => sRIODestID[15:8]
+                                                         (MACADD[49:42] unused when ID16 = 0)
+                                                         MACADD[41:34] => sRIOAddress[33:26]
+                                                         MACADD[33:26] => sRIODestID[7:0]
+                                                         MACADD[25:18] => sRIOAddress[25:18]
+                                                         MDS = 2
+                                                         ID16 must be one.
+                                                         MACADD[49:34] => sRIOAddress[33:18]
+                                                         MACADD[33:18] => sRIODestID[15:0]
+                                                         MDS = 3 = Reserved
+                                                         IAOW_SEL = 1 = 42-bit Address Offset
+                                                         Must not be used when sRIO link is in 34-bit
+                                                         address width mode.
+                                                         When sRIO is in 50-bit address width mode,
+                                                         sRIOAddress[49:42]=0 in the outgoing request.
+                                                         When sRIO is in 66-bit address width mode,
+                                                         sRIOAddress[65:42]=0 in the outgoing request.
+                                                         Usage of the SLI/DPI MAC address when
+                                                         IAOW_SEL = 1:
+                                                         MACADD[63:62] => Multi-Device Swap (MDS)
+                                                         MDS value affects MACADD[58:51,49:42,33:18]
+                                                         use
+                                                         MACADD[41:34] => sRIOAddress[41:34]
+                                                         MACADD[58:51,49:42,33:18] usage depends on
+                                                         MDS value:
+                                                         MDS = 0
+                                                         MACADD[58:51] => sRIODestID[15:8]
+                                                         MACADD[49:42] => sRIODestID[7:0]
+                                                         (MACADD[58:51] unused when ID16=0)
+                                                         MACADD[33:18] => sRIOAddress[33:18]
+                                                         MDS = 1
+                                                         MACADD[58:51] => sRIODestID[15:8]
+                                                         (MACADD[58:51] unused when ID16 = 0)
+                                                         MACADD[49:42] => sRIOAddress[33:26]
+                                                         MACADD[33:26] => sRIODestID[7:0]
+                                                         MACADD[25:18] => sRIOAddress[25:18]
+                                                         MDS = 2
+                                                         ID16 must be one.
+                                                         MACADD[58:51] => sRIOAddress[33:26]
+                                                         MACADD[49:42] => sRIOAddress[25:18]
+                                                         MACADD[33:18] => sRIODestID[15:0]
+                                                         MDS = 3 = Reserved
+                                                         IAOW_SEL = 2 = 50-bit Address Offset
+                                                         Must not be used when sRIO link is in 34-bit
+                                                         address width mode.
+                                                         Must not be used when ID16=1.
+                                                         When sRIO is in 66-bit address width mode,
+                                                         sRIOAddress[65:50]=0 in the outgoing request.
+                                                         Usage of the SLI/DPI MAC address when
+                                                         IAOW_SEL = 2:
+                                                         MACADD[63:62] => Multi-Device Swap (MDS)
+                                                         MDS value affects MACADD[58:51,33:26] use
+                                                         MDS value 3 is reserved
+                                                         MACADD[49:34] => sRIOAddress[49:34]
+                                                         MACADD[25:18] => sRIOAddress[25:18]
+                                                         MACADD[58:51,33:26] usage depends on
+                                                         MDS value:
+                                                         MDS = 0
+                                                         MACADD[58:51] => sRIODestID[7:0]
+                                                         MACADD[33:26] => sRIOAddress[33:26]
+                                                         MDS = 1
+                                                         MACADD[58:51] => sRIOAddress[33:26]
+                                                         MACADD[33:26] => sRIODestID[7:0]
+                                                         MDS = 2 = Reserved
+                                                         MDS = 3 = Reserved
+                                                         IAOW_SEL = 3 = Reserved */
 #else
 	uint64_t iaow_sel                     : 2;
 	uint64_t reserved_2_3                 : 2;
@@ -3438,28 +4475,24 @@ union cvmx_sriox_s2m_typex {
 	struct cvmx_sriox_s2m_typex_s         cn63xx;
 	struct cvmx_sriox_s2m_typex_s         cn63xxp1;
 	struct cvmx_sriox_s2m_typex_s         cn66xx;
+	struct cvmx_sriox_s2m_typex_s         cn75xx;
 };
 typedef union cvmx_sriox_s2m_typex cvmx_sriox_s2m_typex_t;
 
 /**
  * cvmx_srio#_seq
  *
- * SRIO_SEQ = SRIO Sequence Count
- *
- * The SRIO Sequence Count
- *
- * Notes:
- * This register contains the current value of the sequence counter.  This counter increments every
- *  time a doorbell or the first segment of a message is accepted.
+ * This register contains the current value of the sequence counter.  This counter increments
+ * every time a doorbell or the first segment of a message is accepted.
  *
- * Clk_Rst:        SRIO(0,2..3)_SEQ        hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_seq {
 	uint64_t u64;
 	struct cvmx_sriox_seq_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t seq                          : 32; /**< 32-bit Sequence \# */
+	uint64_t seq                          : 32; /**< 32-bit sequence number. */
 #else
 	uint64_t seq                          : 32;
 	uint64_t reserved_32_63               : 32;
@@ -3468,31 +4501,84 @@ union cvmx_sriox_seq {
 	struct cvmx_sriox_seq_s               cn63xx;
 	struct cvmx_sriox_seq_s               cn63xxp1;
 	struct cvmx_sriox_seq_s               cn66xx;
+	struct cvmx_sriox_seq_s               cn75xx;
 };
 typedef union cvmx_sriox_seq cvmx_sriox_seq_t;
 
 /**
  * cvmx_srio#_status_reg
  *
- * 13e20 reserved
+ * The SRIO field displays if the port has been configured for SRIO operation.  This register
+ * can be read regardless of whether the SRIO is selected or being reset.  Although some other
+ * registers can be accessed while the ACCESS bit is zero (see individual registers for details),
+ * the majority of SRIO registers and all the SRIOMAINT registers can be used only when the
+ * ACCESS bit is asserted.
  *
- *
- *                  SRIO_STATUS_REG = SRIO Status Register
- *
- * General status of the SRIO.
- *
- * Notes:
- * The SRIO field displays if the port has been configured for SRIO operation.  This register can be
- *  read regardless of whether the SRIO is selected or being reset.  Although some other registers can
- *  be accessed while the ACCESS bit is zero (see individual registers for details), the majority of
- *  SRIO registers and all the SRIOMAINT registers can be used only when the ACCESS bit is asserted.
- *
- * Clk_Rst:        SRIO(0,2..3)_STATUS_REG sclk    srst_n
+ * This register is reset by the coprocessor-clock reset.
  */
 union cvmx_sriox_status_reg {
 	uint64_t u64;
 	struct cvmx_sriox_status_reg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t host                         : 1;  /**< SRIO Host Setting.  This field is initialized on a cold reset based on the
+                                                         value of the corresponding SRIOx_SPD pins. If the pins are set to 15 then
+                                                         the port is disabled and set to host otherwise it is initialized as an end
+                                                         point.  The values in this field are used to determine the setting in the
+                                                         SRIOMAINT()_PORT_GEN_CTL[HOST] field.  The value is not modified during
+                                                         a warm or soft reset and should be set before SRIO bit is enabled.
+                                                          0 = SRIO port is endpoint (EP).
+                                                          1 = SRIO port is host. */
+	uint64_t spd                          : 4;  /**< SRIO Speed Setting.  This field is initialized on a cold reset based on the
+                                                         value of the corresponding SRIOx_SPD pins. The values in this field are
+                                                         used to determine the setting in the SRIOMAINT()_PORT_0_CTL2 register and to
+                                                         the QLM PLL setting.  The value is not modified during a warm or soft reset
+                                                         and should be set before SRIO bit is enabled.
+                                                         <pre>
+                                                          0x0 =     5G  100 MHz reference.
+                                                          0x1 =   2.5G  100 MHz reference.
+                                                          0x2 =   2.5G  100 MHz reference.
+                                                          0x3 =  1.25G  100 MHz reference.
+                                                          0x4 =  1.25G  156.25 MHz reference.
+                                                          0x5 =  6.25G  125 MHz reference. Reserved.
+                                                          0x6 =     5G  125 MHz reference.
+                                                          0x7 =   2.5G  156.25 MHz reference.
+                                                          0x8 = 3.125G  125 MHz reference.
+                                                          0x9 =   2.5G  125 MHz reference.
+                                                          0xA =  1.25G  125 MHz reference.
+                                                          0xB =     5G  156.25 MHz reference.
+                                                          0xC =  6.25G  156.25 MHz reference. Reserved.
+                                                          0xD =  3.75G  156.25 MHz reference. Reserved.
+                                                          0xE = 3.125G  156.25 MHz reference.
+                                                          0xF =         Interface disabled.
+                                                         </pre> */
+	uint64_t run_type                     : 2;  /**< SRIO Run Type.  This field is initialized on a cold reset based on the
+                                                         value of the corresponding SRIOx_CFG pin.  The values in this field are
+                                                         used to determine tx/rx type settings in the SRIOMAINT()_LANE_()_STATUS_0
+                                                         registers.  The value is not modified during a warm or soft reset and should
+                                                         be set before SRIO bit is enabled.
+                                                         0x0 = Short run  (SRIO()_CFG is 0).
+                                                         0x1 = Medium run.
+                                                         0x2 = Long run   (SRIO()_CFG is 1). */
+	uint64_t access                       : 1;  /**< SRIO register access.
+                                                         0 - Access disabled.
+                                                         1 - Access enabled. */
+	uint64_t srio                         : 1;  /**< SRIO port enabled.  This bit is initialized on a cold reset based on the
+                                                         value of the SRIO()_SPD pins.  If the SPD is all 1's the interface is disabled.
+                                                         The value is not modified during a warm or soft reset.
+                                                         0 = All SRIO functions disabled.
+                                                         1 = All SRIO operations permitted. */
+#else
+	uint64_t srio                         : 1;
+	uint64_t access                       : 1;
+	uint64_t run_type                     : 2;
+	uint64_t spd                          : 4;
+	uint64_t host                         : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_sriox_status_reg_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t access                       : 1;  /**< SRIO and SRIOMAINT Register Access.
                                                          0 - Register Access Disabled.
@@ -3505,25 +4591,20 @@ union cvmx_sriox_status_reg {
 	uint64_t access                       : 1;
 	uint64_t reserved_2_63                : 62;
 #endif
-	} s;
-	struct cvmx_sriox_status_reg_s        cn63xx;
-	struct cvmx_sriox_status_reg_s        cn63xxp1;
-	struct cvmx_sriox_status_reg_s        cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_status_reg_cn63xx   cn63xxp1;
+	struct cvmx_sriox_status_reg_cn63xx   cn66xx;
+	struct cvmx_sriox_status_reg_s        cn75xx;
 };
 typedef union cvmx_sriox_status_reg cvmx_sriox_status_reg_t;
 
 /**
  * cvmx_srio#_tag_ctrl
  *
- * SRIO_TAG_CTRL = SRIO TAG Control
- *
- * The SRIO TAG Control
- *
- * Notes:
- * This register is used to show the state of the internal transaction tags and provides a manual
- *  reset of the outgoing tags.
+ * This register is used to show the state of the internal transaction
+ * tags and provides a manual reset of the outgoing tags.
  *
- * Clk_Rst:        SRIO(0,2..3)_TAG_CTRL   hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tag_ctrl {
 	uint64_t u64;
@@ -3536,18 +4617,18 @@ union cvmx_sriox_tag_ctrl {
                                                          performed when the SRIO MAC is reset but it may be
                                                          necessary after a chip reset while the MAC is in
                                                          operation.  This bit must be set then cleared to
-                                                         return to normal operation.  Typically, Outgoing
+                                                         return to normal operation.  Typically, outgoing
                                                          SRIO packets must be halted 6 seconds prior to
                                                          this bit is set to avoid generating duplicate tags
                                                          and unexpected response errors. */
 	uint64_t reserved_13_15               : 3;
-	uint64_t otag                         : 5;  /**< Number of Available Outbound Tags.  Tags are
+	uint64_t otag                         : 5;  /**< Number of available outbound tags.  Tags are
                                                          required for all outgoing memory and maintenance
-                                                         operations that require a response. (Max 16) */
+                                                         operations that require a response. (Max 16). */
 	uint64_t reserved_5_7                 : 3;
-	uint64_t itag                         : 5;  /**< Number of Available Inbound Tags.  Tags are
+	uint64_t itag                         : 5;  /**< Number of available inbound tags.  Tags are
                                                          required for all incoming memory operations that
-                                                         require a response. (Max 16) */
+                                                         require a response. (Max 16). */
 #else
 	uint64_t itag                         : 5;
 	uint64_t reserved_5_7                 : 3;
@@ -3560,37 +4641,45 @@ union cvmx_sriox_tag_ctrl {
 	struct cvmx_sriox_tag_ctrl_s          cn63xx;
 	struct cvmx_sriox_tag_ctrl_s          cn63xxp1;
 	struct cvmx_sriox_tag_ctrl_s          cn66xx;
+	struct cvmx_sriox_tag_ctrl_s          cn75xx;
 };
 typedef union cvmx_sriox_tag_ctrl cvmx_sriox_tag_ctrl_t;
 
 /**
  * cvmx_srio#_tlp_credits
  *
- * SRIO_TLP_CREDITS = SRIO TLP Credits
+ * This register is for diagnostic use only.
  *
- * Specifies the number of credits the SRIO can use for incoming Commands and Messages.
- *
- * Notes:
- * Specifies the number of maximum credits the SRIO can use for incoming Commands and Messages.
- *  Reset values for COMP, N_POST and POST credits are based on the number of lanes allocated by the
- *  QLM Configuration to the SRIO MAC and whether QLM1 is used by PCIe.  If SRIO MACs are unused then
- *  credits may be allocated to other MACs under some circumstances.  The following table shows the
- *  reset values for COMP/N_POST/POST:
- *                     QLM0_CFG    QLM1_CFG    SRIO0       SRIO2      SRIO3
- *                    ======================================================
- *                        PEM        Any       0/0/0       0/0/0      0/0/0
- *                      SRIO x4      Any     128/16/128    0/0/0      0/0/0
- *                      SRIO x2      PEM      64/8/64     64/8/64     0/0/0
- *                      SRIO x2    non-PEM   128/16/128  128/16/128   0/0/0
- *                      SRIO x1      PEM      42/5/42     42/5/42    42/5/42
- *                      SRIO x1    non-PEM    64/8/64     64/8/64    64/8/64
- *
- * Clk_Rst:        SRIO(0,2..3)_TLP_CREDITS        hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tlp_credits {
 	uint64_t u64;
 	struct cvmx_sriox_tlp_credits_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t mbox                         : 5;  /**< Credits for mailbox data used in X2P.
+                                                         Legal values are 0x1 to 0x10. */
+	uint64_t comp                         : 8;  /**< Credits for read completions used in M2S.
+                                                         Default is 64 (0x40) credits per SRIO MAC.  Can be increased to 128 (0x80)
+                                                         if only one SRIO MAC is used.  Legal values are 0x22 to 0x80. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t n_post                       : 5;  /**< Credits for read requests used in M2S.
+                                                         Default is 8 credits per SRIO MAC.  Can be increased to 16 (0x10)
+                                                         if only one SRIO MAC is used.  Legal values are 0x4 to 0x10. */
+	uint64_t post                         : 8;  /**< Credits for write request postings used in M2S.
+                                                         Default is 64 (0x40) credits per SRIO MAC.  Can be increased to 128 (0x80)
+                                                         if only one SRIO MAC is used.  Legal values are 0x22 to 0x80. */
+#else
+	uint64_t post                         : 8;
+	uint64_t n_post                       : 5;
+	uint64_t reserved_13_15               : 3;
+	uint64_t comp                         : 8;
+	uint64_t mbox                         : 5;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_sriox_tlp_credits_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
 	uint64_t mbox                         : 4;  /**< Credits for Mailbox Data used in M2S.
                                                          Legal values are 0x2 to 0x8. */
@@ -3609,28 +4698,25 @@ union cvmx_sriox_tlp_credits {
 	uint64_t mbox                         : 4;
 	uint64_t reserved_28_63               : 36;
 #endif
-	} s;
-	struct cvmx_sriox_tlp_credits_s       cn63xx;
-	struct cvmx_sriox_tlp_credits_s       cn63xxp1;
-	struct cvmx_sriox_tlp_credits_s       cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_tlp_credits_cn63xx  cn63xxp1;
+	struct cvmx_sriox_tlp_credits_cn63xx  cn66xx;
+	struct cvmx_sriox_tlp_credits_s       cn75xx;
 };
 typedef union cvmx_sriox_tlp_credits cvmx_sriox_tlp_credits_t;
 
 /**
  * cvmx_srio#_tx_bell
  *
- * SRIO_TX_BELL = SRIO Transmit Doorbell
- *
- * The SRIO Outgoing (TX) Doorbell
- *
- * Notes:
- * This register specifies SRIO Information, Device ID, Transaction Type and Priority of the outgoing
- *  Doorbell Transaction.  Writes to this register causes the Doorbell to be issued using these bits.
- *  The write also causes the PENDING bit to be set. The hardware automatically clears bit when the
- *  Doorbell operation has been acknowledged.  A write to this register while the PENDING bit is set
- *  should be avoided as it will stall the RSL until the first Doorbell has completed.
+ * This register specifies SRIO information, device ID, transaction type and
+ * priority of the outgoing doorbell transaction.  Writes to this register
+ * cause the doorbell to be issued using these bits.  The write also causes the
+ * PENDING bit to be set. The hardware automatically clears bit when the
+ * Doorbell operation has been acknowledged.  A write to this register while
+ * the PENDING bit is set should be avoided as it will stall the RSL until
+ * the first Doorbell has completed.
  *
- * Clk_Rst:        SRIO(0,2..3)_TX_BELL    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tx_bell {
 	uint64_t u64;
@@ -3638,6 +4724,29 @@ union cvmx_sriox_tx_bell {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t data                         : 16; /**< Information field for next doorbell operation */
+	uint64_t dest_id                      : 16; /**< Doorbell destination device ID[15:0]. */
+	uint64_t reserved_9_15                : 7;
+	uint64_t pending                      : 1;  /**< Doorbell transmit in progress. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t src_id                       : 1;  /**< Source device ID 0=primary, 1=secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t id16                         : 1;
+	uint64_t src_id                       : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t pending                      : 1;
+	uint64_t reserved_9_15                : 7;
+	uint64_t dest_id                      : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_sriox_tx_bell_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field for next doorbell operation */
 	uint64_t dest_id                      : 16; /**< Doorbell Destination Device ID[15:0] */
 	uint64_t reserved_9_15                : 7;
 	uint64_t pending                      : 1;  /**< Doorbell Transmit in Progress */
@@ -3658,33 +4767,77 @@ union cvmx_sriox_tx_bell {
 	uint64_t data                         : 16;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} s;
-	struct cvmx_sriox_tx_bell_s           cn63xx;
-	struct cvmx_sriox_tx_bell_s           cn63xxp1;
-	struct cvmx_sriox_tx_bell_s           cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_tx_bell_cn63xx      cn63xxp1;
+	struct cvmx_sriox_tx_bell_cn63xx      cn66xx;
+	struct cvmx_sriox_tx_bell_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field for next doorbell operation */
+	uint64_t dest_id                      : 16; /**< Doorbell destination device ID[15:0]. */
+	uint64_t reserved_9_15                : 7;
+	uint64_t pending                      : 1;  /**< Doorbell transmit in progress. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t src_id                       : 1;  /**< Source device ID 0=primary, 1=secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t prior                        : 2;  /**< Doorbell priority. */
+#else
+	uint64_t prior                        : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t id16                         : 1;
+	uint64_t src_id                       : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t pending                      : 1;
+	uint64_t reserved_9_15                : 7;
+	uint64_t dest_id                      : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_tx_bell cvmx_sriox_tx_bell_t;
 
 /**
  * cvmx_srio#_tx_bell_info
  *
- * SRIO_TX_BELL_INFO = SRIO Transmit Doorbell Interrupt Information
- *
- * The SRIO Outgoing (TX) Doorbell Interrupt Information
+ * This register is only updated if the BELL_ERR bit is clear in SRIO()_INT_REG.
+ * This register displays SRIO Information, Device ID, Transaction Type and
+ * Priority of the Doorbell Transaction that generated the BELL_ERR Interrupt.
+ * The register includes either a RETRY, ERROR or TIMEOUT Status.
  *
- * Notes:
- * This register is only updated if the BELL_ERR bit is clear in SRIO(0,2..3)_INT_REG.  This register
- *  displays SRIO Information, Device ID, Transaction Type and Priority of the Doorbell Transaction
- *  that generated the BELL_ERR Interrupt.  The register includes either a RETRY, ERROR or TIMEOUT
- *  Status.
- *
- * Clk_Rst:        SRIO(0,2..3)_TX_BELL_INFO       hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tx_bell_info {
 	uint64_t u64;
 	struct cvmx_sriox_tx_bell_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field from last doorbell operation. */
+	uint64_t dest_id                      : 16; /**< Doorbell destination device ID[15:0]. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t timeout                      : 1;  /**< Transmit doorbell failed with timeout. */
+	uint64_t error                        : 1;  /**< Transmit doorbell destination returned error. */
+	uint64_t retry                        : 1;  /**< Transmit doorbell requests a retransmission. */
+	uint64_t src_id                       : 1;  /**< Source device id 0=primary, 1=secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t id16                         : 1;
+	uint64_t src_id                       : 1;
+	uint64_t retry                        : 1;
+	uint64_t error                        : 1;
+	uint64_t timeout                      : 1;
+	uint64_t reserved_8_15                : 8;
+	uint64_t dest_id                      : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_sriox_tx_bell_info_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
 	uint64_t data                         : 16; /**< Information field from last doorbell operation */
 	uint64_t dest_id                      : 16; /**< Doorbell Destination Device ID[15:0] */
 	uint64_t reserved_8_15                : 8;
@@ -3708,27 +4861,50 @@ union cvmx_sriox_tx_bell_info {
 	uint64_t data                         : 16;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} s;
-	struct cvmx_sriox_tx_bell_info_s      cn63xx;
-	struct cvmx_sriox_tx_bell_info_s      cn63xxp1;
-	struct cvmx_sriox_tx_bell_info_s      cn66xx;
+	} cn63xx;
+	struct cvmx_sriox_tx_bell_info_cn63xx cn63xxp1;
+	struct cvmx_sriox_tx_bell_info_cn63xx cn66xx;
+	struct cvmx_sriox_tx_bell_info_cn75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field from last doorbell operation. */
+	uint64_t dest_id                      : 16; /**< Doorbell destination device ID[15:0]. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t timeout                      : 1;  /**< Transmit doorbell failed with timeout. */
+	uint64_t error                        : 1;  /**< Transmit doorbell destination returned error. */
+	uint64_t retry                        : 1;  /**< Transmit doorbell requests a retransmission. */
+	uint64_t src_id                       : 1;  /**< Source device id 0=primary, 1=secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t prior                        : 2;  /**< Doorbell priority. */
+#else
+	uint64_t prior                        : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t id16                         : 1;
+	uint64_t src_id                       : 1;
+	uint64_t retry                        : 1;
+	uint64_t error                        : 1;
+	uint64_t timeout                      : 1;
+	uint64_t reserved_8_15                : 8;
+	uint64_t dest_id                      : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn75xx;
 };
 typedef union cvmx_sriox_tx_bell_info cvmx_sriox_tx_bell_info_t;
 
 /**
  * cvmx_srio#_tx_ctrl
  *
- * SRIO_TX_CTRL = SRIO Transmit Control
- *
- * The SRIO Transmit Control
+ * This register is used to control SRIO Outgoing Packet Allocation.
+ * TAG_TH[2:0] set the thresholds to allow priority traffic requiring
+ * responses to be queued based on the number of outgoing tags (TIDs)
+ * available.  16 Tags are available.  If a priority is blocked for
+ * lack of tags then all lower priority packets are also blocked
+ * irregardless of whether they require tags.
  *
- * Notes:
- * This register is used to control SRIO Outgoing Packet Allocation.  TAG_TH[2:0] set the thresholds
- *  to allow priority traffic requiring responses to be queued based on the number of outgoing tags
- *  (TIDs) available.  16 Tags are available.  If a priority is blocked for lack of tags then all
- *  lower priority packets are also blocked irregardless of whether they require tags.
- *
- * Clk_Rst:        SRIO(0,2..3)_TX_CTRL    hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tx_ctrl {
 	uint64_t u64;
@@ -3754,11 +4930,11 @@ union cvmx_sriox_tx_ctrl {
                                                          Generally, TAG_TH0 must be > TAG_TH1 to leave OTAGs
                                                          for outgoing priority 1 or 2 (or 3) requests. */
 	uint64_t reserved_20_31               : 12;
-	uint64_t tx_th2                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
+	uint64_t tx_th2                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
 	uint64_t reserved_12_15               : 4;
-	uint64_t tx_th1                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
+	uint64_t tx_th1                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
 	uint64_t reserved_4_7                 : 4;
-	uint64_t tx_th0                       : 4;  /**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
+	uint64_t tx_th0                       : 4;  /**< Reserved. See SRIOMAINT()_IR_BUFFER_CONFIG2. */
 #else
 	uint64_t tx_th0                       : 4;
 	uint64_t reserved_4_7                 : 4;
@@ -3777,6 +4953,7 @@ union cvmx_sriox_tx_ctrl {
 	struct cvmx_sriox_tx_ctrl_s           cn63xx;
 	struct cvmx_sriox_tx_ctrl_s           cn63xxp1;
 	struct cvmx_sriox_tx_ctrl_s           cn66xx;
+	struct cvmx_sriox_tx_ctrl_s           cn75xx;
 };
 typedef union cvmx_sriox_tx_ctrl cvmx_sriox_tx_ctrl_t;
 
@@ -3814,25 +4991,21 @@ typedef union cvmx_sriox_tx_emphasis cvmx_sriox_tx_emphasis_t;
 /**
  * cvmx_srio#_tx_status
  *
- * SRIO_TX_STATUS = SRIO Outbound Credits/Ops Status
- *
- * Specifies the current number of credits/ops by SRIO for Outbound Traffic
- *
- * Notes:
- * Debug Register specifying the number of credits/ops currently in use for Outbound Traffic.
- *  When all outbound traffic has stopped the values should eventually return to the reset values.
+ * Debug Register specifying the number of credits/ops currently
+ * in use for Outbound Traffic.  When all outbound traffic has
+ * stopped the values should eventually return to the reset values.
  *
- * Clk_Rst:        SRIO(0,2..3)_TX_STATUS  hclk    hrst_n
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_tx_status {
 	uint64_t u64;
 	struct cvmx_sriox_tx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t s2m_pr3                      : 8;  /**< Number of pending S2M Priority 3 Entries. */
-	uint64_t s2m_pr2                      : 8;  /**< Number of pending S2M Priority 2 Entries. */
-	uint64_t s2m_pr1                      : 8;  /**< Number of pending S2M Priority 1 Entries. */
-	uint64_t s2m_pr0                      : 8;  /**< Number of pending S2M Priority 0 Entries. */
+	uint64_t s2m_pr3                      : 8;  /**< Number of pending S2M priority 3 entries. */
+	uint64_t s2m_pr2                      : 8;  /**< Number of pending S2M priority 2 entries. */
+	uint64_t s2m_pr1                      : 8;  /**< Number of pending S2M priority 1 entries. */
+	uint64_t s2m_pr0                      : 8;  /**< Number of pending S2M priority 0 entries. */
 #else
 	uint64_t s2m_pr0                      : 8;
 	uint64_t s2m_pr1                      : 8;
@@ -3844,25 +5017,24 @@ union cvmx_sriox_tx_status {
 	struct cvmx_sriox_tx_status_s         cn63xx;
 	struct cvmx_sriox_tx_status_s         cn63xxp1;
 	struct cvmx_sriox_tx_status_s         cn66xx;
+	struct cvmx_sriox_tx_status_s         cn75xx;
 };
 typedef union cvmx_sriox_tx_status cvmx_sriox_tx_status_t;
 
 /**
  * cvmx_srio#_wr_done_counts
  *
- * SRIO_WR_DONE_COUNTS = SRIO Outgoing Write Done Counts
- *
- * The SRIO Outbound Write Done Counts
- *
- * Notes:
- * This register shows the number of successful and unsuccessful NwriteRs issued through this MAC.
- *  These count only considers the last NwriteR generated by each Store Instruction.  If any NwriteR
- *  in the series receives an ERROR Status then it is reported in SRIOMAINT(0,2..3)_ERB_LT_ERR_DET.IO_ERR.
- *  If any NwriteR does not receive a response within the timeout period then it is reported in
- *  SRIOMAINT(0,2..3)_ERB_LT_ERR_DET.PKT_TOUT.  Only errors on the last NwriteR's are counted as BAD.  This
- *  register is typically not written while Outbound SRIO Memory traffic is enabled.
- *
- * Clk_Rst:        SRIO(0,2..3)_WR_DONE_COUNTS     hclk    hrst_n
+ * This register shows the number of successful and unsuccessful
+ * NwriteRs issued through this MAC.  These count only considers
+ * the last NwriteR generated by each Store Instruction.  If any
+ * NwriteR in the series receives an ERROR Status then it is reported
+ * in SRIOMAINT()_ERB_LT_ERR_DET[IO_ERR].  If any NwriteR does not
+ * receive a response within the timeout period then it is reported in
+ * SRIOMAINT()_ERB_LT_ERR_DET[PKT_TOUT].  Only errors on the last NwriteR's
+ * are counted as BAD.  This register is typically not written while
+ * Outbound SRIO Memory traffic is enabled.
+ *
+ * This register is reset by the h-clock reset.
  */
 union cvmx_sriox_wr_done_counts {
 	uint64_t u64;
@@ -3870,10 +5042,10 @@ union cvmx_sriox_wr_done_counts {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t bad                          : 16; /**< Count of the final outbound NwriteR in the series
-                                                         associated with a Store Operation that have timed
+                                                         associated with a store operation that have timed
                                                          out or received a response with an ERROR status. */
 	uint64_t good                         : 16; /**< Count of the final outbound NwriteR in the series
-                                                         associated with a Store operation that has
+                                                         associated with a store operation that has
                                                          received a response with a DONE status. */
 #else
 	uint64_t good                         : 16;
@@ -3883,6 +5055,7 @@ union cvmx_sriox_wr_done_counts {
 	} s;
 	struct cvmx_sriox_wr_done_counts_s    cn63xx;
 	struct cvmx_sriox_wr_done_counts_s    cn66xx;
+	struct cvmx_sriox_wr_done_counts_s    cn75xx;
 };
 typedef union cvmx_sriox_wr_done_counts cvmx_sriox_wr_done_counts_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index b0a9b9d..e285396 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -68,6 +68,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_SSO_ACTIVE_CYCLESX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000001100ull) + ((offset) & 3) * 8;
@@ -79,7 +80,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 #define CVMX_SSO_AW_ADD CVMX_SSO_AW_ADD_FUNC()
 static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002080ull);
 }
@@ -90,7 +91,7 @@ static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 #define CVMX_SSO_AW_CFG CVMX_SSO_AW_CFG_FUNC()
 static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
 }
@@ -98,10 +99,21 @@ static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 #define CVMX_SSO_AW_CFG (CVMX_ADD_IO_SEG(0x00016700000010F0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SSO_AW_ECO CVMX_SSO_AW_ECO_FUNC()
+static inline uint64_t CVMX_SSO_AW_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_SSO_AW_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001670000001030ull);
+}
+#else
+#define CVMX_SSO_AW_ECO (CVMX_ADD_IO_SEG(0x0001670000001030ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SSO_AW_READ_ARB CVMX_SSO_AW_READ_ARB_FUNC()
 static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_READ_ARB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002090ull);
 }
@@ -112,7 +124,7 @@ static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 #define CVMX_SSO_AW_STATUS CVMX_SSO_AW_STATUS_FUNC()
 static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010E0ull);
 }
@@ -123,7 +135,7 @@ static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 #define CVMX_SSO_AW_TAG_LATENCY_PC CVMX_SSO_AW_TAG_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A8ull);
 }
@@ -134,7 +146,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_AW_TAG_REQ_PC CVMX_SSO_AW_TAG_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A0ull);
 }
@@ -145,7 +157,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 #define CVMX_SSO_AW_WE CVMX_SSO_AW_WE_FUNC()
 static inline uint64_t CVMX_SSO_AW_WE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_WE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001080ull);
 }
@@ -167,7 +179,7 @@ static inline uint64_t CVMX_SSO_BIST_STAT_FUNC(void)
 #define CVMX_SSO_BIST_STATUS0 CVMX_SSO_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001200ull);
 }
@@ -178,7 +190,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 #define CVMX_SSO_BIST_STATUS1 CVMX_SSO_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001208ull);
 }
@@ -189,7 +201,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 #define CVMX_SSO_BIST_STATUS2 CVMX_SSO_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001210ull);
 }
@@ -222,7 +234,7 @@ static inline uint64_t CVMX_SSO_DS_PC_FUNC(void)
 #define CVMX_SSO_ECC_CTL0 CVMX_SSO_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001280ull);
 }
@@ -233,7 +245,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 #define CVMX_SSO_ECC_CTL1 CVMX_SSO_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001288ull);
 }
@@ -244,7 +256,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 #define CVMX_SSO_ECC_CTL2 CVMX_SSO_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001290ull);
 }
@@ -266,7 +278,7 @@ static inline uint64_t CVMX_SSO_ERR_FUNC(void)
 #define CVMX_SSO_ERR0 CVMX_SSO_ERR0_FUNC()
 static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001240ull);
 }
@@ -277,7 +289,7 @@ static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 #define CVMX_SSO_ERR1 CVMX_SSO_ERR1_FUNC()
 static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001248ull);
 }
@@ -288,7 +300,7 @@ static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 #define CVMX_SSO_ERR2 CVMX_SSO_ERR2_FUNC()
 static inline uint64_t CVMX_SSO_ERR2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001250ull);
 }
@@ -344,6 +356,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((offset) & 255) * 0x10000ull;
@@ -356,6 +369,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_THR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((offset) & 255) * 0x10000ull;
@@ -368,6 +382,7 @@ static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_DS_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((offset) & 255) * 0x10000ull;
@@ -380,6 +395,7 @@ static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_EXT_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((offset) & 255) * 0x10000ull;
@@ -392,6 +408,7 @@ static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_IAQ_THR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((offset) & 255) * 0x10000ull;
@@ -404,6 +421,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((offset) & 255) * 0x10000ull;
@@ -416,6 +434,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((offset) & 255) * 0x10000ull;
@@ -428,6 +447,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_THR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((offset) & 255) * 0x10000ull;
@@ -440,6 +460,7 @@ static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_PRI(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((offset) & 255) * 0x10000ull;
@@ -452,6 +473,7 @@ static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_TAQ_THR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((offset) & 255) * 0x10000ull;
@@ -464,6 +486,7 @@ static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_TS_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((offset) & 255) * 0x10000ull;
@@ -476,6 +499,7 @@ static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_WA_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((offset) & 255) * 0x10000ull;
@@ -488,6 +512,7 @@ static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_WS_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((offset) & 255) * 0x10000ull;
@@ -499,7 +524,7 @@ static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long offset)
 #define CVMX_SSO_GWE_CFG CVMX_SSO_GWE_CFG_FUNC()
 static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001098ull);
 }
@@ -510,7 +535,7 @@ static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 #define CVMX_SSO_GWE_RANDOM CVMX_SSO_GWE_RANDOM_FUNC()
 static inline uint64_t CVMX_SSO_GWE_RANDOM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_RANDOM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010B0ull);
 }
@@ -518,6 +543,17 @@ static inline uint64_t CVMX_SSO_GWE_RANDOM_FUNC(void)
 #define CVMX_SSO_GWE_RANDOM (CVMX_ADD_IO_SEG(0x00016700000010B0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SSO_GW_ECO CVMX_SSO_GW_ECO_FUNC()
+static inline uint64_t CVMX_SSO_GW_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_SSO_GW_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001670000001038ull);
+}
+#else
+#define CVMX_SSO_GW_ECO (CVMX_ADD_IO_SEG(0x0001670000001038ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SSO_IDX_ECC_CTL CVMX_SSO_IDX_ECC_CTL_FUNC()
 static inline uint64_t CVMX_SSO_IDX_ECC_CTL_FUNC(void)
 {
@@ -544,6 +580,7 @@ static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_LINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0060000ull) + ((offset) & 4095) * 8;
@@ -556,6 +593,7 @@ static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_PENDTAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0040000ull) + ((offset) & 4095) * 8;
@@ -568,6 +606,7 @@ static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_QLINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0080000ull) + ((offset) & 4095) * 8;
@@ -580,6 +619,7 @@ static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_TAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0000000ull) + ((offset) & 4095) * 8;
@@ -592,6 +632,7 @@ static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_WQPGRP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0020000ull) + ((offset) & 4095) * 8;
@@ -604,6 +645,7 @@ static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_CONFX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080080000ull) + ((offset) & 255) * 8;
@@ -616,6 +658,7 @@ static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_DESCHEDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080060000ull) + ((offset) & 255) * 8;
@@ -628,6 +671,7 @@ static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_SSO_IPL_FREEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080000000ull) + ((offset) & 7) * 8;
@@ -640,6 +684,7 @@ static inline uint64_t CVMX_SSO_IPL_IAQX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_IAQX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080040000ull) + ((offset) & 255) * 8;
@@ -706,7 +751,7 @@ static inline uint64_t CVMX_SSO_IQ_THRX(unsigned long offset)
 #define CVMX_SSO_NOS_CNT CVMX_SSO_NOS_CNT_FUNC()
 static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NOS_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001040ull);
 }
@@ -717,7 +762,7 @@ static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 #define CVMX_SSO_NW_TIM CVMX_SSO_NW_TIM_FUNC()
 static inline uint64_t CVMX_SSO_NW_TIM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NW_TIM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001028ull);
 }
@@ -750,7 +795,7 @@ static inline uint64_t CVMX_SSO_OTH_ECC_ST_FUNC(void)
 #define CVMX_SSO_PAGE_CNT CVMX_SSO_PAGE_CNT_FUNC()
 static inline uint64_t CVMX_SSO_PAGE_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_PAGE_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001090ull);
 }
@@ -784,6 +829,7 @@ static inline uint64_t CVMX_SSO_PPX_ARB(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_PPX_ARB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((offset) & 63) * 0x10000ull;
@@ -818,6 +864,7 @@ static inline uint64_t CVMX_SSO_PPX_SX_GRPMSKX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 47)) && ((b <= 1)) && ((c <= 3))))))
 		cvmx_warn("CVMX_SSO_PPX_SX_GRPMSKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001670040001000ull) + ((a) << 16) + ((b) << 5) + ((c) << 3);
@@ -876,6 +923,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
@@ -892,6 +940,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN75XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
@@ -948,6 +997,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_LINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((offset) & 63) * 0x10000ull;
@@ -960,6 +1010,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDTAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((offset) & 63) * 0x10000ull;
@@ -972,6 +1023,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDWQP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((offset) & 63) * 0x10000ull;
@@ -984,6 +1036,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_TAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((offset) & 63) * 0x10000ull;
@@ -996,6 +1049,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_WQP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((offset) & 63) * 0x10000ull;
@@ -1008,6 +1062,7 @@ static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 319))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 319))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1279)))))
 		cvmx_warn("CVMX_SSO_TAQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700C0000000ull) + ((offset) & 2047) * 4096;
@@ -1020,6 +1075,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_TAG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000000ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -1032,6 +1088,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_WQP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000008ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -1043,7 +1100,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 #define CVMX_SSO_TAQ_ADD CVMX_SSO_TAQ_ADD_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020E0ull);
 }
@@ -1054,7 +1111,7 @@ static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 #define CVMX_SSO_TAQ_CNT CVMX_SSO_TAQ_CNT_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020C0ull);
 }
@@ -1066,6 +1123,7 @@ static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TIAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000C0000ull) + ((offset) & 255) * 8;
@@ -1078,6 +1136,7 @@ static inline uint64_t CVMX_SSO_TOAQX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TOAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000D0000ull) + ((offset) & 255) * 8;
@@ -1144,7 +1203,7 @@ static inline uint64_t CVMX_SSO_WQ_INT_CNTX(unsigned long offset)
 #define CVMX_SSO_WQ_INT_PC CVMX_SSO_WQ_INT_PC_FUNC()
 static inline uint64_t CVMX_SSO_WQ_INT_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WQ_INT_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001020ull);
 }
@@ -1177,7 +1236,7 @@ static inline uint64_t CVMX_SSO_WQ_IQ_DIS_FUNC(void)
 #define CVMX_SSO_WS_CFG CVMX_SSO_WS_CFG_FUNC()
 static inline uint64_t CVMX_SSO_WS_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WS_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001088ull);
 }
@@ -1185,6 +1244,17 @@ static inline uint64_t CVMX_SSO_WS_CFG_FUNC(void)
 #define CVMX_SSO_WS_CFG (CVMX_ADD_IO_SEG(0x0001670000001088ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SSO_WS_ECO CVMX_SSO_WS_ECO_FUNC()
+static inline uint64_t CVMX_SSO_WS_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX)))
+		cvmx_warn("CVMX_SSO_WS_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001670000001048ull);
+}
+#else
+#define CVMX_SSO_WS_ECO (CVMX_ADD_IO_SEG(0x0001670000001048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SSO_WS_PCX(unsigned long offset)
 {
 	if (!(
@@ -1200,6 +1270,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000A0000ull) + ((offset) & 255) * 8;
@@ -1212,6 +1283,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000080000ull) + ((offset) & 255) * 8;
@@ -1224,6 +1296,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000B0000ull) + ((offset) & 255) * 8;
@@ -1236,6 +1309,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000090000ull) + ((offset) & 255) * 8;
@@ -1247,7 +1321,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 #define CVMX_SSO_XAQ_AURA CVMX_SSO_XAQ_AURA_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002100ull);
 }
@@ -1258,7 +1332,7 @@ static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 #define CVMX_SSO_XAQ_LATENCY_PC CVMX_SSO_XAQ_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B8ull);
 }
@@ -1269,7 +1343,7 @@ static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_XAQ_REQ_PC CVMX_SSO_XAQ_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN75XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B0ull);
 }
@@ -1314,7 +1388,9 @@ union cvmx_sso_active_cyclesx {
 #endif
 	} s;
 	struct cvmx_sso_active_cyclesx_s      cn73xx;
+	struct cvmx_sso_active_cyclesx_s      cn75xx;
 	struct cvmx_sso_active_cyclesx_s      cn78xx;
+	struct cvmx_sso_active_cyclesx_s      cn78xxp2;
 };
 typedef union cvmx_sso_active_cyclesx cvmx_sso_active_cyclesx_t;
 
@@ -1336,7 +1412,9 @@ union cvmx_sso_aw_add {
 #endif
 	} s;
 	struct cvmx_sso_aw_add_s              cn73xx;
+	struct cvmx_sso_aw_add_s              cn75xx;
 	struct cvmx_sso_aw_add_s              cn78xx;
+	struct cvmx_sso_aw_add_s              cn78xxp2;
 };
 typedef union cvmx_sso_aw_add cvmx_sso_aw_add_t;
 
@@ -1352,7 +1430,8 @@ union cvmx_sso_aw_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t ldt_short                    : 1;  /**< Use LDT to bypass L2 allocations when reading short form work. */
-	uint64_t lol                          : 1;  /**< Reserved. */
+	uint64_t lol                          : 1;  /**< Legalize CCPI loopback by forcing ADD_WORKs arriving from IOBN to have node equal to
+                                                         global_node_id. For diagnostic use only. Added in pass 2. */
 	uint64_t xaq_alloc_dis                : 1;  /**< Disable FPA alloc requests to fill the SSO page cache. Also all existing cached free
                                                          buffers will be returned to FPA and will not be cached. */
 	uint64_t ocla_bp                      : 1;  /**< OCLA backpressure enable. When OCLA FIFOs are near full, allow OCLA to backpressure AW pipeline. */
@@ -1377,11 +1456,32 @@ union cvmx_sso_aw_cfg {
 #endif
 	} s;
 	struct cvmx_sso_aw_cfg_s              cn73xx;
+	struct cvmx_sso_aw_cfg_s              cn75xx;
 	struct cvmx_sso_aw_cfg_s              cn78xx;
+	struct cvmx_sso_aw_cfg_s              cn78xxp2;
 };
 typedef union cvmx_sso_aw_cfg cvmx_sso_aw_cfg_t;
 
 /**
+ * cvmx_sso_aw_eco
+ */
+union cvmx_sso_aw_eco {
+	uint64_t u64;
+	struct cvmx_sso_aw_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_sso_aw_eco_s              cn73xx;
+	struct cvmx_sso_aw_eco_s              cn75xx;
+};
+typedef union cvmx_sso_aw_eco cvmx_sso_aw_eco_t;
+
+/**
  * cvmx_sso_aw_read_arb
  *
  * This register fine tunes the AW read arbiter and is for diagnostic use.
@@ -1412,7 +1512,9 @@ union cvmx_sso_aw_read_arb {
 #endif
 	} s;
 	struct cvmx_sso_aw_read_arb_s         cn73xx;
+	struct cvmx_sso_aw_read_arb_s         cn75xx;
 	struct cvmx_sso_aw_read_arb_s         cn78xx;
+	struct cvmx_sso_aw_read_arb_s         cn78xxp2;
 };
 typedef union cvmx_sso_aw_read_arb cvmx_sso_aw_read_arb_t;
 
@@ -1434,7 +1536,9 @@ union cvmx_sso_aw_status {
 #endif
 	} s;
 	struct cvmx_sso_aw_status_s           cn73xx;
+	struct cvmx_sso_aw_status_s           cn75xx;
 	struct cvmx_sso_aw_status_s           cn78xx;
+	struct cvmx_sso_aw_status_s           cn78xxp2;
 };
 typedef union cvmx_sso_aw_status cvmx_sso_aw_status_t;
 
@@ -1452,7 +1556,9 @@ union cvmx_sso_aw_tag_latency_pc {
 #endif
 	} s;
 	struct cvmx_sso_aw_tag_latency_pc_s   cn73xx;
+	struct cvmx_sso_aw_tag_latency_pc_s   cn75xx;
 	struct cvmx_sso_aw_tag_latency_pc_s   cn78xx;
+	struct cvmx_sso_aw_tag_latency_pc_s   cn78xxp2;
 };
 typedef union cvmx_sso_aw_tag_latency_pc cvmx_sso_aw_tag_latency_pc_t;
 
@@ -1469,7 +1575,9 @@ union cvmx_sso_aw_tag_req_pc {
 #endif
 	} s;
 	struct cvmx_sso_aw_tag_req_pc_s       cn73xx;
+	struct cvmx_sso_aw_tag_req_pc_s       cn75xx;
 	struct cvmx_sso_aw_tag_req_pc_s       cn78xx;
+	struct cvmx_sso_aw_tag_req_pc_s       cn78xxp2;
 };
 typedef union cvmx_sso_aw_tag_req_pc cvmx_sso_aw_tag_req_pc_t;
 
@@ -1496,7 +1604,9 @@ union cvmx_sso_aw_we {
 #endif
 	} s;
 	struct cvmx_sso_aw_we_s               cn73xx;
+	struct cvmx_sso_aw_we_s               cn75xx;
 	struct cvmx_sso_aw_we_s               cn78xx;
+	struct cvmx_sso_aw_we_s               cn78xxp2;
 };
 typedef union cvmx_sso_aw_we cvmx_sso_aw_we_t;
 
@@ -1635,7 +1745,9 @@ union cvmx_sso_bist_status0 {
 #endif
 	} s;
 	struct cvmx_sso_bist_status0_s        cn73xx;
+	struct cvmx_sso_bist_status0_s        cn75xx;
 	struct cvmx_sso_bist_status0_s        cn78xx;
+	struct cvmx_sso_bist_status0_s        cn78xxp2;
 };
 typedef union cvmx_sso_bist_status0 cvmx_sso_bist_status0_t;
 
@@ -1664,7 +1776,9 @@ union cvmx_sso_bist_status1 {
 #endif
 	} s;
 	struct cvmx_sso_bist_status1_s        cn73xx;
+	struct cvmx_sso_bist_status1_s        cn75xx;
 	struct cvmx_sso_bist_status1_s        cn78xx;
+	struct cvmx_sso_bist_status1_s        cn78xxp2;
 };
 typedef union cvmx_sso_bist_status1 cvmx_sso_bist_status1_t;
 
@@ -1695,7 +1809,9 @@ union cvmx_sso_bist_status2 {
 #endif
 	} s;
 	struct cvmx_sso_bist_status2_s        cn73xx;
+	struct cvmx_sso_bist_status2_s        cn75xx;
 	struct cvmx_sso_bist_status2_s        cn78xx;
+	struct cvmx_sso_bist_status2_s        cn78xxp2;
 };
 typedef union cvmx_sso_bist_status2 cvmx_sso_bist_status2_t;
 
@@ -1863,7 +1979,9 @@ union cvmx_sso_ecc_ctl0 {
 #endif
 	} s;
 	struct cvmx_sso_ecc_ctl0_s            cn73xx;
+	struct cvmx_sso_ecc_ctl0_s            cn75xx;
 	struct cvmx_sso_ecc_ctl0_s            cn78xx;
+	struct cvmx_sso_ecc_ctl0_s            cn78xxp2;
 };
 typedef union cvmx_sso_ecc_ctl0 cvmx_sso_ecc_ctl0_t;
 
@@ -1909,7 +2027,9 @@ union cvmx_sso_ecc_ctl1 {
 #endif
 	} s;
 	struct cvmx_sso_ecc_ctl1_s            cn73xx;
+	struct cvmx_sso_ecc_ctl1_s            cn75xx;
 	struct cvmx_sso_ecc_ctl1_s            cn78xx;
+	struct cvmx_sso_ecc_ctl1_s            cn78xxp2;
 };
 typedef union cvmx_sso_ecc_ctl1 cvmx_sso_ecc_ctl1_t;
 
@@ -1947,7 +2067,9 @@ union cvmx_sso_ecc_ctl2 {
 #endif
 	} s;
 	struct cvmx_sso_ecc_ctl2_s            cn73xx;
+	struct cvmx_sso_ecc_ctl2_s            cn75xx;
 	struct cvmx_sso_ecc_ctl2_s            cn78xx;
+	struct cvmx_sso_ecc_ctl2_s            cn78xxp2;
 };
 typedef union cvmx_sso_ecc_ctl2 cvmx_sso_ecc_ctl2_t;
 
@@ -2111,7 +2233,9 @@ union cvmx_sso_err0 {
 #endif
 	} s;
 	struct cvmx_sso_err0_s                cn73xx;
+	struct cvmx_sso_err0_s                cn75xx;
 	struct cvmx_sso_err0_s                cn78xx;
+	struct cvmx_sso_err0_s                cn78xxp2;
 };
 typedef union cvmx_sso_err0 cvmx_sso_err0_t;
 
@@ -2159,7 +2283,9 @@ union cvmx_sso_err1 {
 #endif
 	} s;
 	struct cvmx_sso_err1_s                cn73xx;
+	struct cvmx_sso_err1_s                cn75xx;
 	struct cvmx_sso_err1_s                cn78xx;
+	struct cvmx_sso_err1_s                cn78xxp2;
 };
 typedef union cvmx_sso_err1 cvmx_sso_err1_t;
 
@@ -2221,7 +2347,9 @@ union cvmx_sso_err2 {
 #endif
 	} s;
 	struct cvmx_sso_err2_s                cn73xx;
+	struct cvmx_sso_err2_s                cn75xx;
 	struct cvmx_sso_err2_s                cn78xx;
+	struct cvmx_sso_err2_s                cn78xxp2;
 };
 typedef union cvmx_sso_err2 cvmx_sso_err2_t;
 
@@ -2378,7 +2506,9 @@ union cvmx_sso_grpx_aq_cnt {
 #endif
 	} s;
 	struct cvmx_sso_grpx_aq_cnt_s         cn73xx;
+	struct cvmx_sso_grpx_aq_cnt_s         cn75xx;
 	struct cvmx_sso_grpx_aq_cnt_s         cn78xx;
+	struct cvmx_sso_grpx_aq_cnt_s         cn78xxp2;
 };
 typedef union cvmx_sso_grpx_aq_cnt cvmx_sso_grpx_aq_cnt_t;
 
@@ -2398,7 +2528,9 @@ union cvmx_sso_grpx_aq_thr {
 #endif
 	} s;
 	struct cvmx_sso_grpx_aq_thr_s         cn73xx;
+	struct cvmx_sso_grpx_aq_thr_s         cn75xx;
 	struct cvmx_sso_grpx_aq_thr_s         cn78xx;
+	struct cvmx_sso_grpx_aq_thr_s         cn78xxp2;
 };
 typedef union cvmx_sso_grpx_aq_thr cvmx_sso_grpx_aq_thr_t;
 
@@ -2419,7 +2551,9 @@ union cvmx_sso_grpx_ds_pc {
 #endif
 	} s;
 	struct cvmx_sso_grpx_ds_pc_s          cn73xx;
+	struct cvmx_sso_grpx_ds_pc_s          cn75xx;
 	struct cvmx_sso_grpx_ds_pc_s          cn78xx;
+	struct cvmx_sso_grpx_ds_pc_s          cn78xxp2;
 };
 typedef union cvmx_sso_grpx_ds_pc cvmx_sso_grpx_ds_pc_t;
 
@@ -2441,7 +2575,9 @@ union cvmx_sso_grpx_ext_pc {
 #endif
 	} s;
 	struct cvmx_sso_grpx_ext_pc_s         cn73xx;
+	struct cvmx_sso_grpx_ext_pc_s         cn75xx;
 	struct cvmx_sso_grpx_ext_pc_s         cn78xx;
+	struct cvmx_sso_grpx_ext_pc_s         cn78xxp2;
 };
 typedef union cvmx_sso_grpx_ext_pc cvmx_sso_grpx_ext_pc_t;
 
@@ -2478,7 +2614,9 @@ union cvmx_sso_grpx_iaq_thr {
 #endif
 	} s;
 	struct cvmx_sso_grpx_iaq_thr_s        cn73xx;
+	struct cvmx_sso_grpx_iaq_thr_s        cn75xx;
 	struct cvmx_sso_grpx_iaq_thr_s        cn78xx;
+	struct cvmx_sso_grpx_iaq_thr_s        cn78xxp2;
 };
 typedef union cvmx_sso_grpx_iaq_thr cvmx_sso_grpx_iaq_thr_t;
 
@@ -2522,7 +2660,9 @@ union cvmx_sso_grpx_int {
 #endif
 	} s;
 	struct cvmx_sso_grpx_int_s            cn73xx;
+	struct cvmx_sso_grpx_int_s            cn75xx;
 	struct cvmx_sso_grpx_int_s            cn78xx;
+	struct cvmx_sso_grpx_int_s            cn78xxp2;
 };
 typedef union cvmx_sso_grpx_int cvmx_sso_grpx_int_t;
 
@@ -2564,7 +2704,9 @@ union cvmx_sso_grpx_int_cnt {
 #endif
 	} s;
 	struct cvmx_sso_grpx_int_cnt_s        cn73xx;
+	struct cvmx_sso_grpx_int_cnt_s        cn75xx;
 	struct cvmx_sso_grpx_int_cnt_s        cn78xx;
+	struct cvmx_sso_grpx_int_cnt_s        cn78xxp2;
 };
 typedef union cvmx_sso_grpx_int_cnt cvmx_sso_grpx_int_cnt_t;
 
@@ -2608,7 +2750,9 @@ union cvmx_sso_grpx_int_thr {
 #endif
 	} s;
 	struct cvmx_sso_grpx_int_thr_s        cn73xx;
+	struct cvmx_sso_grpx_int_thr_s        cn75xx;
 	struct cvmx_sso_grpx_int_thr_s        cn78xx;
+	struct cvmx_sso_grpx_int_thr_s        cn78xxp2;
 };
 typedef union cvmx_sso_grpx_int_thr cvmx_sso_grpx_int_thr_t;
 
@@ -2649,7 +2793,9 @@ union cvmx_sso_grpx_pri {
 #endif
 	} s;
 	struct cvmx_sso_grpx_pri_s            cn73xx;
+	struct cvmx_sso_grpx_pri_s            cn75xx;
 	struct cvmx_sso_grpx_pri_s            cn78xx;
+	struct cvmx_sso_grpx_pri_s            cn78xxp2;
 };
 typedef union cvmx_sso_grpx_pri cvmx_sso_grpx_pri_t;
 
@@ -2685,7 +2831,9 @@ union cvmx_sso_grpx_taq_thr {
 #endif
 	} s;
 	struct cvmx_sso_grpx_taq_thr_s        cn73xx;
+	struct cvmx_sso_grpx_taq_thr_s        cn75xx;
 	struct cvmx_sso_grpx_taq_thr_s        cn78xx;
+	struct cvmx_sso_grpx_taq_thr_s        cn78xxp2;
 };
 typedef union cvmx_sso_grpx_taq_thr cvmx_sso_grpx_taq_thr_t;
 
@@ -2706,7 +2854,9 @@ union cvmx_sso_grpx_ts_pc {
 #endif
 	} s;
 	struct cvmx_sso_grpx_ts_pc_s          cn73xx;
+	struct cvmx_sso_grpx_ts_pc_s          cn75xx;
 	struct cvmx_sso_grpx_ts_pc_s          cn78xx;
+	struct cvmx_sso_grpx_ts_pc_s          cn78xxp2;
 };
 typedef union cvmx_sso_grpx_ts_pc cvmx_sso_grpx_ts_pc_t;
 
@@ -2728,7 +2878,9 @@ union cvmx_sso_grpx_wa_pc {
 #endif
 	} s;
 	struct cvmx_sso_grpx_wa_pc_s          cn73xx;
+	struct cvmx_sso_grpx_wa_pc_s          cn75xx;
 	struct cvmx_sso_grpx_wa_pc_s          cn78xx;
+	struct cvmx_sso_grpx_wa_pc_s          cn78xxp2;
 };
 typedef union cvmx_sso_grpx_wa_pc cvmx_sso_grpx_wa_pc_t;
 
@@ -2749,11 +2901,32 @@ union cvmx_sso_grpx_ws_pc {
 #endif
 	} s;
 	struct cvmx_sso_grpx_ws_pc_s          cn73xx;
+	struct cvmx_sso_grpx_ws_pc_s          cn75xx;
 	struct cvmx_sso_grpx_ws_pc_s          cn78xx;
+	struct cvmx_sso_grpx_ws_pc_s          cn78xxp2;
 };
 typedef union cvmx_sso_grpx_ws_pc cvmx_sso_grpx_ws_pc_t;
 
 /**
+ * cvmx_sso_gw_eco
+ */
+union cvmx_sso_gw_eco {
+	uint64_t u64;
+	struct cvmx_sso_gw_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_sso_gw_eco_s              cn73xx;
+	struct cvmx_sso_gw_eco_s              cn75xx;
+};
+typedef union cvmx_sso_gw_eco cvmx_sso_gw_eco_t;
+
+/**
  * cvmx_sso_gwe_cfg
  *
  * This register controls the operation of the get-work examiner (GWE).
@@ -2843,7 +3016,9 @@ union cvmx_sso_gwe_cfg {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} cn73xx;
+	struct cvmx_sso_gwe_cfg_cn73xx        cn75xx;
 	struct cvmx_sso_gwe_cfg_cn73xx        cn78xx;
+	struct cvmx_sso_gwe_cfg_cn73xx        cn78xxp2;
 };
 typedef union cvmx_sso_gwe_cfg cvmx_sso_gwe_cfg_t;
 
@@ -2878,7 +3053,9 @@ union cvmx_sso_gwe_random {
 #endif
 	} s;
 	struct cvmx_sso_gwe_random_s          cn73xx;
+	struct cvmx_sso_gwe_random_s          cn75xx;
 	struct cvmx_sso_gwe_random_s          cn78xx;
+	struct cvmx_sso_gwe_random_s          cn78xxp2;
 };
 typedef union cvmx_sso_gwe_random cvmx_sso_gwe_random_t;
 
@@ -2975,6 +3152,7 @@ union cvmx_sso_ientx_links {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} cn73xx;
+	struct cvmx_sso_ientx_links_cn73xx    cn75xx;
 	struct cvmx_sso_ientx_links_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
@@ -2992,6 +3170,7 @@ union cvmx_sso_ientx_links {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} cn78xx;
+	struct cvmx_sso_ientx_links_cn78xx    cn78xxp2;
 };
 typedef union cvmx_sso_ientx_links cvmx_sso_ientx_links_t;
 
@@ -3020,7 +3199,9 @@ union cvmx_sso_ientx_pendtag {
 #endif
 	} s;
 	struct cvmx_sso_ientx_pendtag_s       cn73xx;
+	struct cvmx_sso_ientx_pendtag_s       cn75xx;
 	struct cvmx_sso_ientx_pendtag_s       cn78xx;
+	struct cvmx_sso_ientx_pendtag_s       cn78xxp2;
 };
 typedef union cvmx_sso_ientx_pendtag cvmx_sso_ientx_pendtag_t;
 
@@ -3042,7 +3223,9 @@ union cvmx_sso_ientx_qlinks {
 #endif
 	} s;
 	struct cvmx_sso_ientx_qlinks_s        cn73xx;
+	struct cvmx_sso_ientx_qlinks_s        cn75xx;
 	struct cvmx_sso_ientx_qlinks_s        cn78xx;
+	struct cvmx_sso_ientx_qlinks_s        cn78xxp2;
 };
 typedef union cvmx_sso_ientx_qlinks cvmx_sso_ientx_qlinks_t;
 
@@ -3073,7 +3256,9 @@ union cvmx_sso_ientx_tag {
 #endif
 	} s;
 	struct cvmx_sso_ientx_tag_s           cn73xx;
+	struct cvmx_sso_ientx_tag_s           cn75xx;
 	struct cvmx_sso_ientx_tag_s           cn78xx;
+	struct cvmx_sso_ientx_tag_s           cn78xxp2;
 };
 typedef union cvmx_sso_ientx_tag cvmx_sso_ientx_tag_t;
 
@@ -3126,7 +3311,9 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} cn73xx;
+	struct cvmx_sso_ientx_wqpgrp_cn73xx   cn75xx;
 	struct cvmx_sso_ientx_wqpgrp_s        cn78xx;
+	struct cvmx_sso_ientx_wqpgrp_s        cn78xxp2;
 };
 typedef union cvmx_sso_ientx_wqpgrp cvmx_sso_ientx_wqpgrp_t;
 
@@ -3158,7 +3345,9 @@ union cvmx_sso_ipl_confx {
 #endif
 	} s;
 	struct cvmx_sso_ipl_confx_s           cn73xx;
+	struct cvmx_sso_ipl_confx_s           cn75xx;
 	struct cvmx_sso_ipl_confx_s           cn78xx;
+	struct cvmx_sso_ipl_confx_s           cn78xxp2;
 };
 typedef union cvmx_sso_ipl_confx cvmx_sso_ipl_confx_t;
 
@@ -3190,7 +3379,9 @@ union cvmx_sso_ipl_deschedx {
 #endif
 	} s;
 	struct cvmx_sso_ipl_deschedx_s        cn73xx;
+	struct cvmx_sso_ipl_deschedx_s        cn75xx;
 	struct cvmx_sso_ipl_deschedx_s        cn78xx;
+	struct cvmx_sso_ipl_deschedx_s        cn78xxp2;
 };
 typedef union cvmx_sso_ipl_deschedx cvmx_sso_ipl_deschedx_t;
 
@@ -3248,7 +3439,9 @@ union cvmx_sso_ipl_freex {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} cn73xx;
+	struct cvmx_sso_ipl_freex_cn73xx      cn75xx;
 	struct cvmx_sso_ipl_freex_s           cn78xx;
+	struct cvmx_sso_ipl_freex_s           cn78xxp2;
 };
 typedef union cvmx_sso_ipl_freex cvmx_sso_ipl_freex_t;
 
@@ -3280,7 +3473,9 @@ union cvmx_sso_ipl_iaqx {
 #endif
 	} s;
 	struct cvmx_sso_ipl_iaqx_s            cn73xx;
+	struct cvmx_sso_ipl_iaqx_s            cn75xx;
 	struct cvmx_sso_ipl_iaqx_s            cn78xx;
+	struct cvmx_sso_ipl_iaqx_s            cn78xxp2;
 };
 typedef union cvmx_sso_ipl_iaqx cvmx_sso_ipl_iaqx_t;
 
@@ -3437,7 +3632,9 @@ union cvmx_sso_nos_cnt {
 	} cn68xx;
 	struct cvmx_sso_nos_cnt_cn68xx        cn68xxp1;
 	struct cvmx_sso_nos_cnt_s             cn73xx;
+	struct cvmx_sso_nos_cnt_s             cn75xx;
 	struct cvmx_sso_nos_cnt_s             cn78xx;
+	struct cvmx_sso_nos_cnt_s             cn78xxp2;
 };
 typedef union cvmx_sso_nos_cnt cvmx_sso_nos_cnt_t;
 
@@ -3466,7 +3663,9 @@ union cvmx_sso_nw_tim {
 	struct cvmx_sso_nw_tim_s              cn68xx;
 	struct cvmx_sso_nw_tim_s              cn68xxp1;
 	struct cvmx_sso_nw_tim_s              cn73xx;
+	struct cvmx_sso_nw_tim_s              cn75xx;
 	struct cvmx_sso_nw_tim_s              cn78xx;
+	struct cvmx_sso_nw_tim_s              cn78xxp2;
 };
 typedef union cvmx_sso_nw_tim cvmx_sso_nw_tim_t;
 
@@ -3558,7 +3757,9 @@ union cvmx_sso_page_cnt {
 #endif
 	} s;
 	struct cvmx_sso_page_cnt_s            cn73xx;
+	struct cvmx_sso_page_cnt_s            cn75xx;
 	struct cvmx_sso_page_cnt_s            cn78xx;
+	struct cvmx_sso_page_cnt_s            cn78xxp2;
 };
 typedef union cvmx_sso_page_cnt cvmx_sso_page_cnt_t;
 
@@ -3656,7 +3857,9 @@ union cvmx_sso_ppx_arb {
 #endif
 	} s;
 	struct cvmx_sso_ppx_arb_s             cn73xx;
+	struct cvmx_sso_ppx_arb_s             cn75xx;
 	struct cvmx_sso_ppx_arb_s             cn78xx;
+	struct cvmx_sso_ppx_arb_s             cn78xxp2;
 };
 typedef union cvmx_sso_ppx_arb cvmx_sso_ppx_arb_t;
 
@@ -3779,7 +3982,9 @@ union cvmx_sso_ppx_sx_grpmskx {
 #endif
 	} s;
 	struct cvmx_sso_ppx_sx_grpmskx_s      cn73xx;
+	struct cvmx_sso_ppx_sx_grpmskx_s      cn75xx;
 	struct cvmx_sso_ppx_sx_grpmskx_s      cn78xx;
+	struct cvmx_sso_ppx_sx_grpmskx_s      cn78xxp2;
 };
 typedef union cvmx_sso_ppx_sx_grpmskx cvmx_sso_ppx_sx_grpmskx_t;
 
@@ -3959,7 +4164,9 @@ union cvmx_sso_reset {
 #endif
 	} cn68xx;
 	struct cvmx_sso_reset_s               cn73xx;
+	struct cvmx_sso_reset_s               cn75xx;
 	struct cvmx_sso_reset_s               cn78xx;
+	struct cvmx_sso_reset_s               cn78xxp2;
 };
 typedef union cvmx_sso_reset cvmx_sso_reset_t;
 
@@ -4167,6 +4374,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t tailc                        : 1;
 #endif
 	} cn73xx;
+	struct cvmx_sso_sl_ppx_links_cn73xx   cn75xx;
 	struct cvmx_sso_sl_ppx_links_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
@@ -4199,6 +4407,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t tailc                        : 1;
 #endif
 	} cn78xx;
+	struct cvmx_sso_sl_ppx_links_cn78xx   cn78xxp2;
 };
 typedef union cvmx_sso_sl_ppx_links cvmx_sso_sl_ppx_links_t;
 
@@ -4238,7 +4447,9 @@ union cvmx_sso_sl_ppx_pendtag {
 #endif
 	} s;
 	struct cvmx_sso_sl_ppx_pendtag_s      cn73xx;
+	struct cvmx_sso_sl_ppx_pendtag_s      cn75xx;
 	struct cvmx_sso_sl_ppx_pendtag_s      cn78xx;
+	struct cvmx_sso_sl_ppx_pendtag_s      cn78xxp2;
 };
 typedef union cvmx_sso_sl_ppx_pendtag cvmx_sso_sl_ppx_pendtag_t;
 
@@ -4308,7 +4519,9 @@ union cvmx_sso_sl_ppx_pendwqp {
 	uint64_t pend_switch                  : 1;
 #endif
 	} cn73xx;
+	struct cvmx_sso_sl_ppx_pendwqp_cn73xx cn75xx;
 	struct cvmx_sso_sl_ppx_pendwqp_s      cn78xx;
+	struct cvmx_sso_sl_ppx_pendwqp_s      cn78xxp2;
 };
 typedef union cvmx_sso_sl_ppx_pendwqp cvmx_sso_sl_ppx_pendwqp_t;
 
@@ -4375,7 +4588,9 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t tailc                        : 1;
 #endif
 	} cn73xx;
+	struct cvmx_sso_sl_ppx_tag_cn73xx     cn75xx;
 	struct cvmx_sso_sl_ppx_tag_s          cn78xx;
+	struct cvmx_sso_sl_ppx_tag_s          cn78xxp2;
 };
 typedef union cvmx_sso_sl_ppx_tag cvmx_sso_sl_ppx_tag_t;
 
@@ -4416,7 +4631,9 @@ union cvmx_sso_sl_ppx_wqp {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} cn73xx;
+	struct cvmx_sso_sl_ppx_wqp_cn73xx     cn75xx;
 	struct cvmx_sso_sl_ppx_wqp_s          cn78xx;
+	struct cvmx_sso_sl_ppx_wqp_s          cn78xxp2;
 };
 typedef union cvmx_sso_sl_ppx_wqp cvmx_sso_sl_ppx_wqp_t;
 
@@ -4438,7 +4655,9 @@ union cvmx_sso_taqx_link {
 #endif
 	} s;
 	struct cvmx_sso_taqx_link_s           cn73xx;
+	struct cvmx_sso_taqx_link_s           cn75xx;
 	struct cvmx_sso_taqx_link_s           cn78xx;
+	struct cvmx_sso_taqx_link_s           cn78xxp2;
 };
 typedef union cvmx_sso_taqx_link cvmx_sso_taqx_link_t;
 
@@ -4462,7 +4681,9 @@ union cvmx_sso_taqx_waex_tag {
 #endif
 	} s;
 	struct cvmx_sso_taqx_waex_tag_s       cn73xx;
+	struct cvmx_sso_taqx_waex_tag_s       cn75xx;
 	struct cvmx_sso_taqx_waex_tag_s       cn78xx;
+	struct cvmx_sso_taqx_waex_tag_s       cn78xxp2;
 };
 typedef union cvmx_sso_taqx_waex_tag cvmx_sso_taqx_waex_tag_t;
 
@@ -4484,7 +4705,9 @@ union cvmx_sso_taqx_waex_wqp {
 #endif
 	} s;
 	struct cvmx_sso_taqx_waex_wqp_s       cn73xx;
+	struct cvmx_sso_taqx_waex_wqp_s       cn75xx;
 	struct cvmx_sso_taqx_waex_wqp_s       cn78xx;
+	struct cvmx_sso_taqx_waex_wqp_s       cn78xxp2;
 };
 typedef union cvmx_sso_taqx_waex_wqp cvmx_sso_taqx_waex_wqp_t;
 
@@ -4506,7 +4729,9 @@ union cvmx_sso_taq_add {
 #endif
 	} s;
 	struct cvmx_sso_taq_add_s             cn73xx;
+	struct cvmx_sso_taq_add_s             cn75xx;
 	struct cvmx_sso_taq_add_s             cn78xx;
+	struct cvmx_sso_taq_add_s             cn78xxp2;
 };
 typedef union cvmx_sso_taq_add cvmx_sso_taq_add_t;
 
@@ -4533,7 +4758,9 @@ union cvmx_sso_taq_cnt {
 #endif
 	} s;
 	struct cvmx_sso_taq_cnt_s             cn73xx;
+	struct cvmx_sso_taq_cnt_s             cn75xx;
 	struct cvmx_sso_taq_cnt_s             cn78xx;
+	struct cvmx_sso_taq_cnt_s             cn78xxp2;
 };
 typedef union cvmx_sso_taq_cnt cvmx_sso_taq_cnt_t;
 
@@ -4573,7 +4800,9 @@ union cvmx_sso_tiaqx_status {
 #endif
 	} s;
 	struct cvmx_sso_tiaqx_status_s        cn73xx;
+	struct cvmx_sso_tiaqx_status_s        cn75xx;
 	struct cvmx_sso_tiaqx_status_s        cn78xx;
+	struct cvmx_sso_tiaqx_status_s        cn78xxp2;
 };
 typedef union cvmx_sso_tiaqx_status cvmx_sso_tiaqx_status_t;
 
@@ -4616,7 +4845,9 @@ union cvmx_sso_toaqx_status {
 #endif
 	} s;
 	struct cvmx_sso_toaqx_status_s        cn73xx;
+	struct cvmx_sso_toaqx_status_s        cn75xx;
 	struct cvmx_sso_toaqx_status_s        cn78xx;
+	struct cvmx_sso_toaqx_status_s        cn78xxp2;
 };
 typedef union cvmx_sso_toaqx_status cvmx_sso_toaqx_status_t;
 
@@ -4806,7 +5037,9 @@ union cvmx_sso_wq_int_pc {
 	struct cvmx_sso_wq_int_pc_s           cn68xx;
 	struct cvmx_sso_wq_int_pc_s           cn68xxp1;
 	struct cvmx_sso_wq_int_pc_s           cn73xx;
+	struct cvmx_sso_wq_int_pc_s           cn75xx;
 	struct cvmx_sso_wq_int_pc_s           cn78xx;
+	struct cvmx_sso_wq_int_pc_s           cn78xxp2;
 };
 typedef union cvmx_sso_wq_int_pc cvmx_sso_wq_int_pc_t;
 
@@ -4932,6 +5165,7 @@ union cvmx_sso_ws_cfg {
 #endif
 	} s;
 	struct cvmx_sso_ws_cfg_s              cn73xx;
+	struct cvmx_sso_ws_cfg_s              cn75xx;
 	struct cvmx_sso_ws_cfg_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
@@ -4962,10 +5196,30 @@ union cvmx_sso_ws_cfg {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} cn78xx;
+	struct cvmx_sso_ws_cfg_cn78xx         cn78xxp2;
 };
 typedef union cvmx_sso_ws_cfg cvmx_sso_ws_cfg_t;
 
 /**
+ * cvmx_sso_ws_eco
+ */
+union cvmx_sso_ws_eco {
+	uint64_t u64;
+	struct cvmx_sso_ws_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_sso_ws_eco_s              cn73xx;
+	struct cvmx_sso_ws_eco_s              cn75xx;
+};
+typedef union cvmx_sso_ws_eco cvmx_sso_ws_eco_t;
+
+/**
  * cvmx_sso_ws_pc#
  *
  * CSR reserved addresses: (225): 0x3100..0x3800
@@ -5011,7 +5265,9 @@ union cvmx_sso_xaqx_head_next {
 #endif
 	} s;
 	struct cvmx_sso_xaqx_head_next_s      cn73xx;
+	struct cvmx_sso_xaqx_head_next_s      cn75xx;
 	struct cvmx_sso_xaqx_head_next_s      cn78xx;
+	struct cvmx_sso_xaqx_head_next_s      cn78xxp2;
 };
 typedef union cvmx_sso_xaqx_head_next cvmx_sso_xaqx_head_next_t;
 
@@ -5040,7 +5296,9 @@ union cvmx_sso_xaqx_head_ptr {
 #endif
 	} s;
 	struct cvmx_sso_xaqx_head_ptr_s       cn73xx;
+	struct cvmx_sso_xaqx_head_ptr_s       cn75xx;
 	struct cvmx_sso_xaqx_head_ptr_s       cn78xx;
+	struct cvmx_sso_xaqx_head_ptr_s       cn78xxp2;
 };
 typedef union cvmx_sso_xaqx_head_ptr cvmx_sso_xaqx_head_ptr_t;
 
@@ -5066,7 +5324,9 @@ union cvmx_sso_xaqx_tail_next {
 #endif
 	} s;
 	struct cvmx_sso_xaqx_tail_next_s      cn73xx;
+	struct cvmx_sso_xaqx_tail_next_s      cn75xx;
 	struct cvmx_sso_xaqx_tail_next_s      cn78xx;
+	struct cvmx_sso_xaqx_tail_next_s      cn78xxp2;
 };
 typedef union cvmx_sso_xaqx_tail_next cvmx_sso_xaqx_tail_next_t;
 
@@ -5093,7 +5353,9 @@ union cvmx_sso_xaqx_tail_ptr {
 #endif
 	} s;
 	struct cvmx_sso_xaqx_tail_ptr_s       cn73xx;
+	struct cvmx_sso_xaqx_tail_ptr_s       cn75xx;
 	struct cvmx_sso_xaqx_tail_ptr_s       cn78xx;
+	struct cvmx_sso_xaqx_tail_ptr_s       cn78xxp2;
 };
 typedef union cvmx_sso_xaqx_tail_ptr cvmx_sso_xaqx_tail_ptr_t;
 
@@ -5116,7 +5378,9 @@ union cvmx_sso_xaq_aura {
 #endif
 	} s;
 	struct cvmx_sso_xaq_aura_s            cn73xx;
+	struct cvmx_sso_xaq_aura_s            cn75xx;
 	struct cvmx_sso_xaq_aura_s            cn78xx;
+	struct cvmx_sso_xaq_aura_s            cn78xxp2;
 };
 typedef union cvmx_sso_xaq_aura cvmx_sso_xaq_aura_t;
 
@@ -5134,7 +5398,9 @@ union cvmx_sso_xaq_latency_pc {
 #endif
 	} s;
 	struct cvmx_sso_xaq_latency_pc_s      cn73xx;
+	struct cvmx_sso_xaq_latency_pc_s      cn75xx;
 	struct cvmx_sso_xaq_latency_pc_s      cn78xx;
+	struct cvmx_sso_xaq_latency_pc_s      cn78xxp2;
 };
 typedef union cvmx_sso_xaq_latency_pc cvmx_sso_xaq_latency_pc_t;
 
@@ -5151,7 +5417,9 @@ union cvmx_sso_xaq_req_pc {
 #endif
 	} s;
 	struct cvmx_sso_xaq_req_pc_s          cn73xx;
+	struct cvmx_sso_xaq_req_pc_s          cn75xx;
 	struct cvmx_sso_xaq_req_pc_s          cn78xx;
+	struct cvmx_sso_xaq_req_pc_s          cn78xxp2;
 };
 typedef union cvmx_sso_xaq_req_pc cvmx_sso_xaq_req_pc_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
index f99192a..fa4a420 100644
--- a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
@@ -1557,6 +1557,7 @@ union cvmx_uahcx_caplength {
 #endif
 	} s;
 	struct cvmx_uahcx_caplength_s         cn78xx;
+	struct cvmx_uahcx_caplength_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_caplength cvmx_uahcx_caplength_t;
 
@@ -1582,6 +1583,7 @@ union cvmx_uahcx_config {
 #endif
 	} s;
 	struct cvmx_uahcx_config_s            cn78xx;
+	struct cvmx_uahcx_config_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_config cvmx_uahcx_config_t;
 
@@ -1615,6 +1617,7 @@ union cvmx_uahcx_crcr {
 #endif
 	} s;
 	struct cvmx_uahcx_crcr_s              cn78xx;
+	struct cvmx_uahcx_crcr_s              cn78xxp2;
 };
 typedef union cvmx_uahcx_crcr cvmx_uahcx_crcr_t;
 
@@ -1644,6 +1647,7 @@ union cvmx_uahcx_dbx {
 #endif
 	} s;
 	struct cvmx_uahcx_dbx_s               cn78xx;
+	struct cvmx_uahcx_dbx_s               cn78xxp2;
 };
 typedef union cvmx_uahcx_dbx cvmx_uahcx_dbx_t;
 
@@ -1665,6 +1669,7 @@ union cvmx_uahcx_dboff {
 #endif
 	} s;
 	struct cvmx_uahcx_dboff_s             cn78xx;
+	struct cvmx_uahcx_dboff_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_dboff cvmx_uahcx_dboff_t;
 
@@ -1690,6 +1695,7 @@ union cvmx_uahcx_dcbaap {
 #endif
 	} s;
 	struct cvmx_uahcx_dcbaap_s            cn78xx;
+	struct cvmx_uahcx_dcbaap_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_dcbaap cvmx_uahcx_dcbaap_t;
 
@@ -1715,6 +1721,7 @@ union cvmx_uahcx_dnctrl {
 #endif
 	} s;
 	struct cvmx_uahcx_dnctrl_s            cn78xx;
+	struct cvmx_uahcx_dnctrl_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_dnctrl cvmx_uahcx_dnctrl_t;
 
@@ -2710,6 +2717,7 @@ union cvmx_uahcx_erdpx {
 #endif
 	} s;
 	struct cvmx_uahcx_erdpx_s             cn78xx;
+	struct cvmx_uahcx_erdpx_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_erdpx cvmx_uahcx_erdpx_t;
 
@@ -2735,6 +2743,7 @@ union cvmx_uahcx_erstbax {
 #endif
 	} s;
 	struct cvmx_uahcx_erstbax_s           cn78xx;
+	struct cvmx_uahcx_erstbax_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_erstbax cvmx_uahcx_erstbax_t;
 
@@ -2760,6 +2769,7 @@ union cvmx_uahcx_erstszx {
 #endif
 	} s;
 	struct cvmx_uahcx_erstszx_s           cn78xx;
+	struct cvmx_uahcx_erstszx_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_erstszx cvmx_uahcx_erstszx_t;
 
@@ -2794,6 +2804,7 @@ union cvmx_uahcx_gbuserraddr {
 #endif
 	} s;
 	struct cvmx_uahcx_gbuserraddr_s       cn78xx;
+	struct cvmx_uahcx_gbuserraddr_s       cn78xxp2;
 };
 typedef union cvmx_uahcx_gbuserraddr cvmx_uahcx_gbuserraddr_t;
 
@@ -2933,6 +2944,7 @@ union cvmx_uahcx_gctl {
 #endif
 	} s;
 	struct cvmx_uahcx_gctl_s              cn78xx;
+	struct cvmx_uahcx_gctl_s              cn78xxp2;
 };
 typedef union cvmx_uahcx_gctl cvmx_uahcx_gctl_t;
 
@@ -2959,6 +2971,7 @@ union cvmx_uahcx_gdbgbmu {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbgbmu_s           cn78xx;
+	struct cvmx_uahcx_gdbgbmu_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbgbmu cvmx_uahcx_gdbgbmu_t;
 
@@ -2979,6 +2992,7 @@ union cvmx_uahcx_gdbgepinfo {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbgepinfo_s        cn78xx;
+	struct cvmx_uahcx_gdbgepinfo_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbgepinfo cvmx_uahcx_gdbgepinfo_t;
 
@@ -3022,6 +3036,7 @@ union cvmx_uahcx_gdbgfifospace {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbgfifospace_s     cn78xx;
+	struct cvmx_uahcx_gdbgfifospace_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbgfifospace cvmx_uahcx_gdbgfifospace_t;
 
@@ -3048,6 +3063,7 @@ union cvmx_uahcx_gdbglnmcc {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbglnmcc_s         cn78xx;
+	struct cvmx_uahcx_gdbglnmcc_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbglnmcc cvmx_uahcx_gdbglnmcc_t;
 
@@ -3068,6 +3084,7 @@ union cvmx_uahcx_gdbglsp {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbglsp_s           cn78xx;
+	struct cvmx_uahcx_gdbglsp_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbglsp cvmx_uahcx_gdbglsp_t;
 
@@ -3105,6 +3122,7 @@ union cvmx_uahcx_gdbglspmux {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbglspmux_s        cn78xx;
+	struct cvmx_uahcx_gdbglspmux_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbglspmux cvmx_uahcx_gdbglspmux_t;
 
@@ -3161,6 +3179,7 @@ union cvmx_uahcx_gdbgltssm {
 #endif
 	} s;
 	struct cvmx_uahcx_gdbgltssm_s         cn78xx;
+	struct cvmx_uahcx_gdbgltssm_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gdbgltssm cvmx_uahcx_gdbgltssm_t;
 
@@ -3206,6 +3225,7 @@ union cvmx_uahcx_gdmahlratio {
 #endif
 	} s;
 	struct cvmx_uahcx_gdmahlratio_s       cn78xx;
+	struct cvmx_uahcx_gdmahlratio_s       cn78xxp2;
 };
 typedef union cvmx_uahcx_gdmahlratio cvmx_uahcx_gdmahlratio_t;
 
@@ -3309,6 +3329,7 @@ union cvmx_uahcx_gfladj {
 #endif
 	} s;
 	struct cvmx_uahcx_gfladj_s            cn78xx;
+	struct cvmx_uahcx_gfladj_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_gfladj cvmx_uahcx_gfladj_t;
 
@@ -3334,6 +3355,7 @@ union cvmx_uahcx_ggpio {
 #endif
 	} s;
 	struct cvmx_uahcx_ggpio_s             cn78xx;
+	struct cvmx_uahcx_ggpio_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_ggpio cvmx_uahcx_ggpio_t;
 
@@ -3364,6 +3386,7 @@ union cvmx_uahcx_ghwparams0 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams0_s        cn78xx;
+	struct cvmx_uahcx_ghwparams0_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams0 cvmx_uahcx_ghwparams0_t;
 
@@ -3415,6 +3438,7 @@ union cvmx_uahcx_ghwparams1 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams1_s        cn78xx;
+	struct cvmx_uahcx_ghwparams1_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams1 cvmx_uahcx_ghwparams1_t;
 
@@ -3435,6 +3459,7 @@ union cvmx_uahcx_ghwparams2 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams2_s        cn78xx;
+	struct cvmx_uahcx_ghwparams2_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams2 cvmx_uahcx_ghwparams2_t;
 
@@ -3475,6 +3500,7 @@ union cvmx_uahcx_ghwparams3 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams3_s        cn78xx;
+	struct cvmx_uahcx_ghwparams3_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams3 cvmx_uahcx_ghwparams3_t;
 
@@ -3511,6 +3537,7 @@ union cvmx_uahcx_ghwparams4 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams4_s        cn78xx;
+	struct cvmx_uahcx_ghwparams4_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams4 cvmx_uahcx_ghwparams4_t;
 
@@ -3541,6 +3568,7 @@ union cvmx_uahcx_ghwparams5 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams5_s        cn78xx;
+	struct cvmx_uahcx_ghwparams5_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams5 cvmx_uahcx_ghwparams5_t;
 
@@ -3581,6 +3609,7 @@ union cvmx_uahcx_ghwparams6 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams6_s        cn78xx;
+	struct cvmx_uahcx_ghwparams6_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams6 cvmx_uahcx_ghwparams6_t;
 
@@ -3603,6 +3632,7 @@ union cvmx_uahcx_ghwparams7 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams7_s        cn78xx;
+	struct cvmx_uahcx_ghwparams7_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams7 cvmx_uahcx_ghwparams7_t;
 
@@ -3623,6 +3653,7 @@ union cvmx_uahcx_ghwparams8 {
 #endif
 	} s;
 	struct cvmx_uahcx_ghwparams8_s        cn78xx;
+	struct cvmx_uahcx_ghwparams8_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_ghwparams8 cvmx_uahcx_ghwparams8_t;
 
@@ -3673,6 +3704,7 @@ union cvmx_uahcx_gpmsts {
 #endif
 	} s;
 	struct cvmx_uahcx_gpmsts_s            cn78xx;
+	struct cvmx_uahcx_gpmsts_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_gpmsts cvmx_uahcx_gpmsts_t;
 
@@ -3701,6 +3733,7 @@ union cvmx_uahcx_gprtbimap {
 #endif
 	} s;
 	struct cvmx_uahcx_gprtbimap_s         cn78xx;
+	struct cvmx_uahcx_gprtbimap_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gprtbimap cvmx_uahcx_gprtbimap_t;
 
@@ -3729,6 +3762,7 @@ union cvmx_uahcx_gprtbimap_fs {
 #endif
 	} s;
 	struct cvmx_uahcx_gprtbimap_fs_s      cn78xx;
+	struct cvmx_uahcx_gprtbimap_fs_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_gprtbimap_fs cvmx_uahcx_gprtbimap_fs_t;
 
@@ -3757,6 +3791,7 @@ union cvmx_uahcx_gprtbimap_hs {
 #endif
 	} s;
 	struct cvmx_uahcx_gprtbimap_hs_s      cn78xx;
+	struct cvmx_uahcx_gprtbimap_hs_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_gprtbimap_hs cvmx_uahcx_gprtbimap_hs_t;
 
@@ -3781,6 +3816,7 @@ union cvmx_uahcx_grlsid {
 #endif
 	} s;
 	struct cvmx_uahcx_grlsid_s            cn78xx;
+	struct cvmx_uahcx_grlsid_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_grlsid cvmx_uahcx_grlsid_t;
 
@@ -3824,6 +3860,7 @@ union cvmx_uahcx_grxfifoprihst {
 #endif
 	} s;
 	struct cvmx_uahcx_grxfifoprihst_s     cn78xx;
+	struct cvmx_uahcx_grxfifoprihst_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_grxfifoprihst cvmx_uahcx_grxfifoprihst_t;
 
@@ -3859,6 +3896,7 @@ union cvmx_uahcx_grxfifosizx {
 #endif
 	} s;
 	struct cvmx_uahcx_grxfifosizx_s       cn78xx;
+	struct cvmx_uahcx_grxfifosizx_s       cn78xxp2;
 };
 typedef union cvmx_uahcx_grxfifosizx cvmx_uahcx_grxfifosizx_t;
 
@@ -3922,6 +3960,7 @@ union cvmx_uahcx_grxthrcfg {
 #endif
 	} s;
 	struct cvmx_uahcx_grxthrcfg_s         cn78xx;
+	struct cvmx_uahcx_grxthrcfg_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_grxthrcfg cvmx_uahcx_grxthrcfg_t;
 
@@ -3988,6 +4027,7 @@ union cvmx_uahcx_gsbuscfg0 {
 #endif
 	} s;
 	struct cvmx_uahcx_gsbuscfg0_s         cn78xx;
+	struct cvmx_uahcx_gsbuscfg0_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gsbuscfg0 cvmx_uahcx_gsbuscfg0_t;
 
@@ -4032,6 +4072,7 @@ union cvmx_uahcx_gsbuscfg1 {
 #endif
 	} s;
 	struct cvmx_uahcx_gsbuscfg1_s         cn78xx;
+	struct cvmx_uahcx_gsbuscfg1_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gsbuscfg1 cvmx_uahcx_gsbuscfg1_t;
 
@@ -4071,6 +4112,7 @@ union cvmx_uahcx_gsts {
 #endif
 	} s;
 	struct cvmx_uahcx_gsts_s              cn78xx;
+	struct cvmx_uahcx_gsts_s              cn78xxp2;
 };
 typedef union cvmx_uahcx_gsts cvmx_uahcx_gsts_t;
 
@@ -4116,6 +4158,7 @@ union cvmx_uahcx_gtxfifoprihst {
 #endif
 	} s;
 	struct cvmx_uahcx_gtxfifoprihst_s     cn78xx;
+	struct cvmx_uahcx_gtxfifoprihst_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_gtxfifoprihst cvmx_uahcx_gtxfifoprihst_t;
 
@@ -4152,6 +4195,7 @@ union cvmx_uahcx_gtxfifosizx {
 #endif
 	} s;
 	struct cvmx_uahcx_gtxfifosizx_s       cn78xx;
+	struct cvmx_uahcx_gtxfifosizx_s       cn78xxp2;
 };
 typedef union cvmx_uahcx_gtxfifosizx cvmx_uahcx_gtxfifosizx_t;
 
@@ -4212,6 +4256,7 @@ union cvmx_uahcx_gtxthrcfg {
 #endif
 	} s;
 	struct cvmx_uahcx_gtxthrcfg_s         cn78xx;
+	struct cvmx_uahcx_gtxthrcfg_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_gtxthrcfg cvmx_uahcx_gtxthrcfg_t;
 
@@ -4337,6 +4382,7 @@ union cvmx_uahcx_guctl {
 #endif
 	} s;
 	struct cvmx_uahcx_guctl_s             cn78xx;
+	struct cvmx_uahcx_guctl_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_guctl cvmx_uahcx_guctl_t;
 
@@ -4363,6 +4409,7 @@ union cvmx_uahcx_guctl1 {
 #endif
 	} s;
 	struct cvmx_uahcx_guctl1_s            cn78xx;
+	struct cvmx_uahcx_guctl1_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_guctl1 cvmx_uahcx_guctl1_t;
 
@@ -4390,6 +4437,7 @@ union cvmx_uahcx_guid {
 #endif
 	} s;
 	struct cvmx_uahcx_guid_s              cn78xx;
+	struct cvmx_uahcx_guid_s              cn78xxp2;
 };
 typedef union cvmx_uahcx_guid cvmx_uahcx_guid_t;
 
@@ -4412,6 +4460,7 @@ union cvmx_uahcx_gusb2i2cctlx {
 #endif
 	} s;
 	struct cvmx_uahcx_gusb2i2cctlx_s      cn78xx;
+	struct cvmx_uahcx_gusb2i2cctlx_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_gusb2i2cctlx cvmx_uahcx_gusb2i2cctlx_t;
 
@@ -4513,6 +4562,7 @@ union cvmx_uahcx_gusb2phycfgx {
 #endif
 	} s;
 	struct cvmx_uahcx_gusb2phycfgx_s      cn78xx;
+	struct cvmx_uahcx_gusb2phycfgx_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_gusb2phycfgx cvmx_uahcx_gusb2phycfgx_t;
 
@@ -4686,6 +4736,7 @@ union cvmx_uahcx_gusb3pipectlx {
 #endif
 	} s;
 	struct cvmx_uahcx_gusb3pipectlx_s     cn78xx;
+	struct cvmx_uahcx_gusb3pipectlx_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_gusb3pipectlx cvmx_uahcx_gusb3pipectlx_t;
 
@@ -4727,6 +4778,7 @@ union cvmx_uahcx_hccparams {
 #endif
 	} s;
 	struct cvmx_uahcx_hccparams_s         cn78xx;
+	struct cvmx_uahcx_hccparams_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_hccparams cvmx_uahcx_hccparams_t;
 
@@ -4752,6 +4804,7 @@ union cvmx_uahcx_hcsparams1 {
 #endif
 	} s;
 	struct cvmx_uahcx_hcsparams1_s        cn78xx;
+	struct cvmx_uahcx_hcsparams1_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_hcsparams1 cvmx_uahcx_hcsparams1_t;
 
@@ -4781,6 +4834,7 @@ union cvmx_uahcx_hcsparams2 {
 #endif
 	} s;
 	struct cvmx_uahcx_hcsparams2_s        cn78xx;
+	struct cvmx_uahcx_hcsparams2_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_hcsparams2 cvmx_uahcx_hcsparams2_t;
 
@@ -4804,6 +4858,7 @@ union cvmx_uahcx_hcsparams3 {
 #endif
 	} s;
 	struct cvmx_uahcx_hcsparams3_s        cn78xx;
+	struct cvmx_uahcx_hcsparams3_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_hcsparams3 cvmx_uahcx_hcsparams3_t;
 
@@ -4831,6 +4886,7 @@ union cvmx_uahcx_imanx {
 #endif
 	} s;
 	struct cvmx_uahcx_imanx_s             cn78xx;
+	struct cvmx_uahcx_imanx_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_imanx cvmx_uahcx_imanx_t;
 
@@ -4856,6 +4912,7 @@ union cvmx_uahcx_imodx {
 #endif
 	} s;
 	struct cvmx_uahcx_imodx_s             cn78xx;
+	struct cvmx_uahcx_imodx_s             cn78xxp2;
 };
 typedef union cvmx_uahcx_imodx cvmx_uahcx_imodx_t;
 
@@ -4881,6 +4938,7 @@ union cvmx_uahcx_mfindex {
 #endif
 	} s;
 	struct cvmx_uahcx_mfindex_s           cn78xx;
+	struct cvmx_uahcx_mfindex_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_mfindex cvmx_uahcx_mfindex_t;
 
@@ -6086,6 +6144,7 @@ union cvmx_uahcx_pagesize {
 #endif
 	} s;
 	struct cvmx_uahcx_pagesize_s          cn78xx;
+	struct cvmx_uahcx_pagesize_s          cn78xxp2;
 };
 typedef union cvmx_uahcx_pagesize cvmx_uahcx_pagesize_t;
 
@@ -6126,6 +6185,7 @@ union cvmx_uahcx_porthlpmc_20x {
 #endif
 	} s;
 	struct cvmx_uahcx_porthlpmc_20x_s     cn78xx;
+	struct cvmx_uahcx_porthlpmc_20x_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_porthlpmc_20x cvmx_uahcx_porthlpmc_20x_t;
 
@@ -6150,6 +6210,7 @@ union cvmx_uahcx_porthlpmc_ssx {
 #endif
 	} s;
 	struct cvmx_uahcx_porthlpmc_ssx_s     cn78xx;
+	struct cvmx_uahcx_porthlpmc_ssx_s     cn78xxp2;
 };
 typedef union cvmx_uahcx_porthlpmc_ssx cvmx_uahcx_porthlpmc_ssx_t;
 
@@ -6169,6 +6230,7 @@ union cvmx_uahcx_portli_20x {
 #endif
 	} s;
 	struct cvmx_uahcx_portli_20x_s        cn78xx;
+	struct cvmx_uahcx_portli_20x_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_portli_20x cvmx_uahcx_portli_20x_t;
 
@@ -6190,6 +6252,7 @@ union cvmx_uahcx_portli_ssx {
 #endif
 	} s;
 	struct cvmx_uahcx_portli_ssx_s        cn78xx;
+	struct cvmx_uahcx_portli_ssx_s        cn78xxp2;
 };
 typedef union cvmx_uahcx_portli_ssx cvmx_uahcx_portli_ssx_t;
 
@@ -6225,6 +6288,7 @@ union cvmx_uahcx_portpmsc_20x {
 #endif
 	} s;
 	struct cvmx_uahcx_portpmsc_20x_s      cn78xx;
+	struct cvmx_uahcx_portpmsc_20x_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_portpmsc_20x cvmx_uahcx_portpmsc_20x_t;
 
@@ -6254,6 +6318,7 @@ union cvmx_uahcx_portpmsc_ssx {
 #endif
 	} s;
 	struct cvmx_uahcx_portpmsc_ssx_s      cn78xx;
+	struct cvmx_uahcx_portpmsc_ssx_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_portpmsc_ssx cvmx_uahcx_portpmsc_ssx_t;
 
@@ -6324,6 +6389,7 @@ union cvmx_uahcx_portscx {
 #endif
 	} s;
 	struct cvmx_uahcx_portscx_s           cn78xx;
+	struct cvmx_uahcx_portscx_s           cn78xxp2;
 };
 typedef union cvmx_uahcx_portscx cvmx_uahcx_portscx_t;
 
@@ -6345,6 +6411,7 @@ union cvmx_uahcx_rtsoff {
 #endif
 	} s;
 	struct cvmx_uahcx_rtsoff_s            cn78xx;
+	struct cvmx_uahcx_rtsoff_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_rtsoff cvmx_uahcx_rtsoff_t;
 
@@ -6370,6 +6437,7 @@ union cvmx_uahcx_suptprt2_dw0 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt2_dw0_s      cn78xx;
+	struct cvmx_uahcx_suptprt2_dw0_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt2_dw0 cvmx_uahcx_suptprt2_dw0_t;
 
@@ -6389,6 +6457,7 @@ union cvmx_uahcx_suptprt2_dw1 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt2_dw1_s      cn78xx;
+	struct cvmx_uahcx_suptprt2_dw1_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt2_dw1 cvmx_uahcx_suptprt2_dw1_t;
 
@@ -6424,6 +6493,7 @@ union cvmx_uahcx_suptprt2_dw2 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt2_dw2_s      cn78xx;
+	struct cvmx_uahcx_suptprt2_dw2_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt2_dw2 cvmx_uahcx_suptprt2_dw2_t;
 
@@ -6445,6 +6515,7 @@ union cvmx_uahcx_suptprt2_dw3 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt2_dw3_s      cn78xx;
+	struct cvmx_uahcx_suptprt2_dw3_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt2_dw3 cvmx_uahcx_suptprt2_dw3_t;
 
@@ -6471,6 +6542,7 @@ union cvmx_uahcx_suptprt3_dw0 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt3_dw0_s      cn78xx;
+	struct cvmx_uahcx_suptprt3_dw0_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt3_dw0 cvmx_uahcx_suptprt3_dw0_t;
 
@@ -6490,6 +6562,7 @@ union cvmx_uahcx_suptprt3_dw1 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt3_dw1_s      cn78xx;
+	struct cvmx_uahcx_suptprt3_dw1_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt3_dw1 cvmx_uahcx_suptprt3_dw1_t;
 
@@ -6515,6 +6588,7 @@ union cvmx_uahcx_suptprt3_dw2 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt3_dw2_s      cn78xx;
+	struct cvmx_uahcx_suptprt3_dw2_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt3_dw2 cvmx_uahcx_suptprt3_dw2_t;
 
@@ -6536,6 +6610,7 @@ union cvmx_uahcx_suptprt3_dw3 {
 #endif
 	} s;
 	struct cvmx_uahcx_suptprt3_dw3_s      cn78xx;
+	struct cvmx_uahcx_suptprt3_dw3_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_suptprt3_dw3 cvmx_uahcx_suptprt3_dw3_t;
 
@@ -6579,6 +6654,7 @@ union cvmx_uahcx_usbcmd {
 #endif
 	} s;
 	struct cvmx_uahcx_usbcmd_s            cn78xx;
+	struct cvmx_uahcx_usbcmd_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_usbcmd cvmx_uahcx_usbcmd_t;
 
@@ -6637,6 +6713,7 @@ union cvmx_uahcx_usblegctlsts {
 #endif
 	} s;
 	struct cvmx_uahcx_usblegctlsts_s      cn78xx;
+	struct cvmx_uahcx_usblegctlsts_s      cn78xxp2;
 };
 typedef union cvmx_uahcx_usblegctlsts cvmx_uahcx_usblegctlsts_t;
 
@@ -6670,6 +6747,7 @@ union cvmx_uahcx_usblegsup {
 #endif
 	} s;
 	struct cvmx_uahcx_usblegsup_s         cn78xx;
+	struct cvmx_uahcx_usblegsup_s         cn78xxp2;
 };
 typedef union cvmx_uahcx_usblegsup cvmx_uahcx_usblegsup_t;
 
@@ -6715,6 +6793,7 @@ union cvmx_uahcx_usbsts {
 #endif
 	} s;
 	struct cvmx_uahcx_usbsts_s            cn78xx;
+	struct cvmx_uahcx_usbsts_s            cn78xxp2;
 };
 typedef union cvmx_uahcx_usbsts cvmx_uahcx_usbsts_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
index 0a9c527..28bb1e3 100644
--- a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
@@ -489,6 +489,7 @@ union cvmx_uctlx_bist_status {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} cn78xx;
+	struct cvmx_uctlx_bist_status_cn78xx  cn78xxp2;
 	struct cvmx_uctlx_bist_status_cn61xx  cnf71xx;
 };
 typedef union cvmx_uctlx_bist_status cvmx_uctlx_bist_status_t;
@@ -829,6 +830,7 @@ union cvmx_uctlx_ctl {
 #endif
 	} s;
 	struct cvmx_uctlx_ctl_s               cn78xx;
+	struct cvmx_uctlx_ctl_s               cn78xxp2;
 };
 typedef union cvmx_uctlx_ctl cvmx_uctlx_ctl_t;
 
@@ -895,6 +897,7 @@ union cvmx_uctlx_ecc {
 #endif
 	} s;
 	struct cvmx_uctlx_ecc_s               cn78xx;
+	struct cvmx_uctlx_ecc_s               cn78xxp2;
 };
 typedef union cvmx_uctlx_ecc cvmx_uctlx_ecc_t;
 
@@ -1125,6 +1128,7 @@ union cvmx_uctlx_host_cfg {
 #endif
 	} s;
 	struct cvmx_uctlx_host_cfg_s          cn78xx;
+	struct cvmx_uctlx_host_cfg_s          cn78xxp2;
 };
 typedef union cvmx_uctlx_host_cfg cvmx_uctlx_host_cfg_t;
 
@@ -1299,6 +1303,7 @@ union cvmx_uctlx_intstat {
 #endif
 	} s;
 	struct cvmx_uctlx_intstat_s           cn78xx;
+	struct cvmx_uctlx_intstat_s           cn78xxp2;
 };
 typedef union cvmx_uctlx_intstat cvmx_uctlx_intstat_t;
 
@@ -1510,6 +1515,7 @@ union cvmx_uctlx_portx_cfg_hs {
 #endif
 	} s;
 	struct cvmx_uctlx_portx_cfg_hs_s      cn78xx;
+	struct cvmx_uctlx_portx_cfg_hs_s      cn78xxp2;
 };
 typedef union cvmx_uctlx_portx_cfg_hs cvmx_uctlx_portx_cfg_hs_t;
 
@@ -1643,6 +1649,7 @@ union cvmx_uctlx_portx_cfg_ss {
 #endif
 	} s;
 	struct cvmx_uctlx_portx_cfg_ss_s      cn78xx;
+	struct cvmx_uctlx_portx_cfg_ss_s      cn78xxp2;
 };
 typedef union cvmx_uctlx_portx_cfg_ss cvmx_uctlx_portx_cfg_ss_t;
 
@@ -1733,6 +1740,7 @@ union cvmx_uctlx_portx_cr_dbg_cfg {
 #endif
 	} s;
 	struct cvmx_uctlx_portx_cr_dbg_cfg_s  cn78xx;
+	struct cvmx_uctlx_portx_cr_dbg_cfg_s  cn78xxp2;
 };
 typedef union cvmx_uctlx_portx_cr_dbg_cfg cvmx_uctlx_portx_cr_dbg_cfg_t;
 
@@ -1762,6 +1770,7 @@ union cvmx_uctlx_portx_cr_dbg_status {
 #endif
 	} s;
 	struct cvmx_uctlx_portx_cr_dbg_status_s cn78xx;
+	struct cvmx_uctlx_portx_cr_dbg_status_s cn78xxp2;
 };
 typedef union cvmx_uctlx_portx_cr_dbg_status cvmx_uctlx_portx_cr_dbg_status_t;
 
@@ -1847,6 +1856,7 @@ union cvmx_uctlx_shim_cfg {
 #endif
 	} s;
 	struct cvmx_uctlx_shim_cfg_s          cn78xx;
+	struct cvmx_uctlx_shim_cfg_s          cn78xxp2;
 };
 typedef union cvmx_uctlx_shim_cfg cvmx_uctlx_shim_cfg_t;
 
@@ -1866,6 +1876,7 @@ union cvmx_uctlx_spare0 {
 #endif
 	} s;
 	struct cvmx_uctlx_spare0_s            cn78xx;
+	struct cvmx_uctlx_spare0_s            cn78xxp2;
 };
 typedef union cvmx_uctlx_spare0 cvmx_uctlx_spare0_t;
 
@@ -1886,6 +1897,7 @@ union cvmx_uctlx_spare1 {
 #endif
 	} s;
 	struct cvmx_uctlx_spare1_s            cn78xx;
+	struct cvmx_uctlx_spare1_s            cn78xxp2;
 };
 typedef union cvmx_uctlx_spare1 cvmx_uctlx_spare1_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 64ac510..3aa01b4 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -57,7 +57,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_CAPLENGTH(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_CAPLENGTH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -69,7 +70,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_CONFIG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -81,7 +83,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_CRCR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_CRCR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -93,7 +96,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DALEPENA(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DALEPENA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -105,7 +109,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DBOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DBOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -117,7 +122,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DBX(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 64)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 64)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 64)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 64)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DBX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -129,7 +135,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DCBAAP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DCBAAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -141,7 +148,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DCFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -153,7 +161,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DCTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -165,7 +174,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C808ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -177,7 +187,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C804ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -189,7 +200,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C800ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -201,7 +213,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDX(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -213,7 +226,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEVTEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEVTEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -225,7 +239,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DGCMD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -237,7 +252,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DGCMDPAR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMDPAR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -249,7 +265,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DNCTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DNCTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -261,7 +278,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -273,7 +291,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERDPX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERDPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000478ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -285,7 +304,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERSTBAX(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTBAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000470ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -297,7 +317,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERSTSZX(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTSZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -309,7 +330,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GBUSERRADDR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GBUSERRADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -321,7 +343,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GCTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -333,7 +356,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGBMU(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGBMU(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -345,7 +369,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGEPINFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGEPINFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -357,7 +382,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -369,7 +395,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLNMCC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLNMCC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -381,7 +408,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -393,7 +421,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSPMUX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSPMUX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -405,7 +434,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLTSSM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLTSSM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -417,7 +447,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GDMAHLRATIO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GDMAHLRATIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -429,7 +460,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTADRX(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTADRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C400ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -441,7 +473,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTCOUNTX(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTCOUNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C40Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -453,7 +486,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTSIZX(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -465,7 +499,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GFLADJ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GFLADJ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -477,7 +512,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GGPIO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GGPIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -489,7 +525,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -501,7 +538,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -513,7 +551,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -525,7 +564,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -537,7 +577,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -549,7 +590,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -561,7 +603,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -573,7 +616,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS7(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -585,7 +629,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS8(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -597,7 +642,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GPMSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GPMSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -609,7 +655,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -621,7 +668,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -633,7 +681,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -645,7 +694,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GRLSID(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GRLSID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -657,7 +707,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -669,7 +720,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOSIZX(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 2)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 2)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -681,7 +733,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GRXTHRCFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GRXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -693,7 +746,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -705,7 +759,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -717,7 +772,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -729,7 +785,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -741,7 +798,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -753,7 +811,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOSIZX(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -765,7 +824,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GTXTHRCFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GTXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -777,7 +837,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -789,7 +850,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -801,7 +863,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUID(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -813,7 +876,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C240ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -825,7 +889,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C200ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -837,7 +902,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -849,7 +915,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_HCCPARAMS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_HCCPARAMS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -861,7 +928,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -873,7 +941,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -885,7 +954,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -897,7 +967,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_IMANX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_IMANX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000460ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -909,7 +980,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_IMODX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_IMODX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -921,7 +993,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_MFINDEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_MFINDEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -933,7 +1006,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PAGESIZE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PAGESIZE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -945,7 +1019,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_20X(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000042Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -957,7 +1032,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000043Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -969,7 +1045,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_20X(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000428ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -981,7 +1058,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_SSX(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000438ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -993,7 +1071,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_20X(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000424ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -1005,7 +1084,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_SSX(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000434ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -1017,7 +1097,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTSCX(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTSCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -1029,7 +1110,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_RTSOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_RTSOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1041,7 +1123,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1053,7 +1136,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1065,7 +1149,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1077,7 +1162,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1089,7 +1175,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1101,7 +1188,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1113,7 +1201,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1125,7 +1214,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1137,7 +1227,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_USBCMD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_USBCMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1149,7 +1240,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGCTLSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGCTLSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1161,7 +1253,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGSUP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGSUP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1173,7 +1266,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_USBSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_USBSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((offset) & 1) * 0x10000000000ull;
 }
@@ -1185,7 +1279,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1197,7 +1292,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1209,7 +1305,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_ECC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_ECC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1221,7 +1318,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_HOST_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_HOST_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1233,7 +1331,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_INTSTAT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_INTSTAT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1245,7 +1344,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_HS(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_HS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000040ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1257,7 +1357,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_SS(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_SS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000048ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1269,7 +1370,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000050ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1281,7 +1383,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(unsigned long offse
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1293,7 +1396,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SHIM_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_SHIM_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1315,7 +1419,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0(unsigned long offset)
 static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0_ECO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE0_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1337,7 +1442,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long offset)
 static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1_ECO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE1_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((offset) & 1) * 0x1000000ull;
 }
@@ -1367,6 +1473,7 @@ union cvmx_usbdrdx_uahc_caplength {
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_caplength_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_caplength cvmx_usbdrdx_uahc_caplength_t;
 
@@ -1394,6 +1501,7 @@ union cvmx_usbdrdx_uahc_config {
 	struct cvmx_usbdrdx_uahc_config_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_config_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_config_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_config cvmx_usbdrdx_uahc_config_t;
 
@@ -1429,6 +1537,7 @@ union cvmx_usbdrdx_uahc_crcr {
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_crcr_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
 
@@ -1473,6 +1582,7 @@ union cvmx_usbdrdx_uahc_dalepena {
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn73xx;
+	struct cvmx_usbdrdx_uahc_dalepena_s   cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dalepena cvmx_usbdrdx_uahc_dalepena_t;
 
@@ -1505,6 +1615,7 @@ union cvmx_usbdrdx_uahc_dbx {
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xx;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn73xx;
+	struct cvmx_usbdrdx_uahc_dbx_s        cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dbx cvmx_usbdrdx_uahc_dbx_t;
 
@@ -1528,6 +1639,7 @@ union cvmx_usbdrdx_uahc_dboff {
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_dboff_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dboff cvmx_usbdrdx_uahc_dboff_t;
 
@@ -1555,6 +1667,7 @@ union cvmx_usbdrdx_uahc_dcbaap {
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_dcbaap_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
 
@@ -1632,6 +1745,7 @@ union cvmx_usbdrdx_uahc_dcfg {
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_dcfg_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
 
@@ -1828,6 +1942,7 @@ union cvmx_usbdrdx_uahc_dctl {
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_dctl_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
 
@@ -1983,6 +2098,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_depcmdx_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
 
@@ -2010,6 +2126,7 @@ union cvmx_usbdrdx_uahc_depcmdpar0_x {
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
 
@@ -2037,6 +2154,7 @@ union cvmx_usbdrdx_uahc_depcmdpar1_x {
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
 
@@ -2064,6 +2182,7 @@ union cvmx_usbdrdx_uahc_depcmdpar2_x {
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
 
@@ -2114,6 +2233,7 @@ union cvmx_usbdrdx_uahc_devten {
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_devten_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_devten_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
 
@@ -2166,6 +2286,7 @@ union cvmx_usbdrdx_uahc_dgcmd {
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_dgcmd_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
 
@@ -2196,6 +2317,7 @@ union cvmx_usbdrdx_uahc_dgcmdpar {
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn73xx;
+	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmdpar cvmx_usbdrdx_uahc_dgcmdpar_t;
 
@@ -2223,6 +2345,7 @@ union cvmx_usbdrdx_uahc_dnctrl {
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_dnctrl_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
 
@@ -2331,6 +2454,7 @@ union cvmx_usbdrdx_uahc_dsts {
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_dsts_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_dsts cvmx_usbdrdx_uahc_dsts_t;
 
@@ -2360,6 +2484,7 @@ union cvmx_usbdrdx_uahc_erdpx {
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_erdpx_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_erdpx cvmx_usbdrdx_uahc_erdpx_t;
 
@@ -2387,6 +2512,7 @@ union cvmx_usbdrdx_uahc_erstbax {
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_erstbax_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
 
@@ -2414,6 +2540,7 @@ union cvmx_usbdrdx_uahc_erstszx {
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_erstszx_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
 
@@ -2453,6 +2580,7 @@ union cvmx_usbdrdx_uahc_gbuserraddr {
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
 
@@ -2611,6 +2739,7 @@ union cvmx_usbdrdx_uahc_gctl {
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_gctl_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
 
@@ -2639,6 +2768,7 @@ union cvmx_usbdrdx_uahc_gdbgbmu {
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgbmu cvmx_usbdrdx_uahc_gdbgbmu_t;
 
@@ -2661,6 +2791,7 @@ union cvmx_usbdrdx_uahc_gdbgepinfo {
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
 
@@ -2706,6 +2837,7 @@ union cvmx_usbdrdx_uahc_gdbgfifospace {
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
 
@@ -2734,6 +2866,7 @@ union cvmx_usbdrdx_uahc_gdbglnmcc {
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglnmcc cvmx_usbdrdx_uahc_gdbglnmcc_t;
 
@@ -2756,6 +2889,7 @@ union cvmx_usbdrdx_uahc_gdbglsp {
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
 
@@ -2795,6 +2929,7 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
 
@@ -2854,6 +2989,7 @@ union cvmx_usbdrdx_uahc_gdbgltssm {
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
 
@@ -2901,6 +3037,7 @@ union cvmx_usbdrdx_uahc_gdmahlratio {
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
 
@@ -2934,6 +3071,7 @@ union cvmx_usbdrdx_uahc_gevntadrx {
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
 
@@ -2976,6 +3114,7 @@ union cvmx_usbdrdx_uahc_gevntcountx {
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gevntcountx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
 
@@ -3027,6 +3166,7 @@ union cvmx_usbdrdx_uahc_gevntsizx {
 	} cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx cn73xx;
+	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
 
@@ -3132,6 +3272,7 @@ union cvmx_usbdrdx_uahc_gfladj {
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_gfladj_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
 
@@ -3159,6 +3300,7 @@ union cvmx_usbdrdx_uahc_ggpio {
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_ggpio_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
 
@@ -3191,6 +3333,7 @@ union cvmx_usbdrdx_uahc_ghwparams0 {
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams0_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
 
@@ -3244,6 +3387,7 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams1_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
 
@@ -3266,6 +3410,7 @@ union cvmx_usbdrdx_uahc_ghwparams2 {
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams2_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
 
@@ -3308,6 +3453,7 @@ union cvmx_usbdrdx_uahc_ghwparams3 {
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams3_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
 
@@ -3346,6 +3492,7 @@ union cvmx_usbdrdx_uahc_ghwparams4 {
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams4_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
 
@@ -3378,6 +3525,7 @@ union cvmx_usbdrdx_uahc_ghwparams5 {
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams5_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
 
@@ -3420,6 +3568,7 @@ union cvmx_usbdrdx_uahc_ghwparams6 {
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams6_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
 
@@ -3444,6 +3593,7 @@ union cvmx_usbdrdx_uahc_ghwparams7 {
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams7_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams7 cvmx_usbdrdx_uahc_ghwparams7_t;
 
@@ -3466,6 +3616,7 @@ union cvmx_usbdrdx_uahc_ghwparams8 {
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn73xx;
+	struct cvmx_usbdrdx_uahc_ghwparams8_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
 
@@ -3518,6 +3669,7 @@ union cvmx_usbdrdx_uahc_gpmsts {
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_gpmsts_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
 
@@ -3548,6 +3700,7 @@ union cvmx_usbdrdx_uahc_gprtbimap {
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap cvmx_usbdrdx_uahc_gprtbimap_t;
 
@@ -3578,6 +3731,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_fs {
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_fs cvmx_usbdrdx_uahc_gprtbimap_fs_t;
 
@@ -3608,6 +3762,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_hs {
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
 
@@ -3634,6 +3789,7 @@ union cvmx_usbdrdx_uahc_grlsid {
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_grlsid_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
 
@@ -3679,6 +3835,7 @@ union cvmx_usbdrdx_uahc_grxfifoprihst {
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn73xx;
+	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
 
@@ -3716,6 +3873,7 @@ union cvmx_usbdrdx_uahc_grxfifosizx {
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
 
@@ -3787,6 +3945,7 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
 
@@ -3855,6 +4014,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
 
@@ -3901,6 +4061,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg1 {
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
 
@@ -3942,6 +4103,7 @@ union cvmx_usbdrdx_uahc_gsts {
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_gsts_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
 
@@ -3992,6 +4154,7 @@ union cvmx_usbdrdx_uahc_gtxfifopridev {
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
 
@@ -4040,6 +4203,7 @@ union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
 
@@ -4078,6 +4242,7 @@ union cvmx_usbdrdx_uahc_gtxfifosizx {
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
 
@@ -4140,6 +4305,7 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
 
@@ -4493,6 +4659,7 @@ union cvmx_usbdrdx_uahc_guctl {
 	uint32_t refclkper                    : 10;
 #endif
 	} cn73xx;
+	struct cvmx_usbdrdx_uahc_guctl_cn73xx cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
 
@@ -4522,6 +4689,7 @@ union cvmx_usbdrdx_uahc_guctl1 {
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_guctl1_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
 
@@ -4551,6 +4719,7 @@ union cvmx_usbdrdx_uahc_guid {
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xxp1;
 	struct cvmx_usbdrdx_uahc_guid_s       cn73xx;
+	struct cvmx_usbdrdx_uahc_guid_s       cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_guid cvmx_usbdrdx_uahc_guid_t;
 
@@ -4575,6 +4744,7 @@ union cvmx_usbdrdx_uahc_gusb2i2cctlx {
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
 
@@ -4685,6 +4855,7 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
 
@@ -4860,6 +5031,7 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb3pipectlx cvmx_usbdrdx_uahc_gusb3pipectlx_t;
 
@@ -4903,6 +5075,7 @@ union cvmx_usbdrdx_uahc_hccparams {
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_hccparams_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_hccparams cvmx_usbdrdx_uahc_hccparams_t;
 
@@ -4930,6 +5103,7 @@ union cvmx_usbdrdx_uahc_hcsparams1 {
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn73xx;
+	struct cvmx_usbdrdx_uahc_hcsparams1_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams1 cvmx_usbdrdx_uahc_hcsparams1_t;
 
@@ -4961,6 +5135,7 @@ union cvmx_usbdrdx_uahc_hcsparams2 {
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn73xx;
+	struct cvmx_usbdrdx_uahc_hcsparams2_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams2 cvmx_usbdrdx_uahc_hcsparams2_t;
 
@@ -4986,6 +5161,7 @@ union cvmx_usbdrdx_uahc_hcsparams3 {
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn73xx;
+	struct cvmx_usbdrdx_uahc_hcsparams3_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams3 cvmx_usbdrdx_uahc_hcsparams3_t;
 
@@ -5015,6 +5191,7 @@ union cvmx_usbdrdx_uahc_imanx {
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_imanx_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_imanx cvmx_usbdrdx_uahc_imanx_t;
 
@@ -5042,6 +5219,7 @@ union cvmx_usbdrdx_uahc_imodx {
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xxp1;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn73xx;
+	struct cvmx_usbdrdx_uahc_imodx_s      cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_imodx cvmx_usbdrdx_uahc_imodx_t;
 
@@ -5069,6 +5247,7 @@ union cvmx_usbdrdx_uahc_mfindex {
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_mfindex_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_mfindex cvmx_usbdrdx_uahc_mfindex_t;
 
@@ -5092,6 +5271,7 @@ union cvmx_usbdrdx_uahc_pagesize {
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xxp1;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn73xx;
+	struct cvmx_usbdrdx_uahc_pagesize_s   cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_pagesize cvmx_usbdrdx_uahc_pagesize_t;
 
@@ -5134,6 +5314,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_20x {
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_20x cvmx_usbdrdx_uahc_porthlpmc_20x_t;
 
@@ -5160,6 +5341,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_ssx {
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_ssx cvmx_usbdrdx_uahc_porthlpmc_ssx_t;
 
@@ -5181,6 +5363,7 @@ union cvmx_usbdrdx_uahc_portli_20x {
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_portli_20x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_20x cvmx_usbdrdx_uahc_portli_20x_t;
 
@@ -5204,6 +5387,7 @@ union cvmx_usbdrdx_uahc_portli_ssx {
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_portli_ssx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_ssx cvmx_usbdrdx_uahc_portli_ssx_t;
 
@@ -5241,6 +5425,7 @@ union cvmx_usbdrdx_uahc_portpmsc_20x {
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn73xx;
+	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_20x cvmx_usbdrdx_uahc_portpmsc_20x_t;
 
@@ -5272,6 +5457,7 @@ union cvmx_usbdrdx_uahc_portpmsc_ssx {
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn73xx;
+	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_ssx cvmx_usbdrdx_uahc_portpmsc_ssx_t;
 
@@ -5344,6 +5530,7 @@ union cvmx_usbdrdx_uahc_portscx {
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xxp1;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn73xx;
+	struct cvmx_usbdrdx_uahc_portscx_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_portscx cvmx_usbdrdx_uahc_portscx_t;
 
@@ -5367,6 +5554,7 @@ union cvmx_usbdrdx_uahc_rtsoff {
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_rtsoff_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_rtsoff cvmx_usbdrdx_uahc_rtsoff_t;
 
@@ -5394,6 +5582,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw0 {
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw0 cvmx_usbdrdx_uahc_suptprt2_dw0_t;
 
@@ -5415,6 +5604,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw1 {
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw1 cvmx_usbdrdx_uahc_suptprt2_dw1_t;
 
@@ -5452,6 +5642,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw2 {
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw2 cvmx_usbdrdx_uahc_suptprt2_dw2_t;
 
@@ -5475,6 +5666,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw3 {
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw3 cvmx_usbdrdx_uahc_suptprt2_dw3_t;
 
@@ -5505,6 +5697,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw0 {
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw0 cvmx_usbdrdx_uahc_suptprt3_dw0_t;
 
@@ -5526,6 +5719,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw1 {
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw1 cvmx_usbdrdx_uahc_suptprt3_dw1_t;
 
@@ -5553,6 +5747,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw2 {
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw2 cvmx_usbdrdx_uahc_suptprt3_dw2_t;
 
@@ -5576,6 +5771,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw3 {
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn73xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw3 cvmx_usbdrdx_uahc_suptprt3_dw3_t;
 
@@ -5621,6 +5817,7 @@ union cvmx_usbdrdx_uahc_usbcmd {
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_usbcmd_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbcmd cvmx_usbdrdx_uahc_usbcmd_t;
 
@@ -5681,6 +5878,7 @@ union cvmx_usbdrdx_uahc_usblegctlsts {
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xxp1;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn73xx;
+	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegctlsts cvmx_usbdrdx_uahc_usblegctlsts_t;
 
@@ -5716,6 +5914,7 @@ union cvmx_usbdrdx_uahc_usblegsup {
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xxp1;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn73xx;
+	struct cvmx_usbdrdx_uahc_usblegsup_s  cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegsup cvmx_usbdrdx_uahc_usblegsup_t;
 
@@ -5763,6 +5962,7 @@ union cvmx_usbdrdx_uahc_usbsts {
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xxp1;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn73xx;
+	struct cvmx_usbdrdx_uahc_usbsts_s     cn75xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbsts cvmx_usbdrdx_uahc_usbsts_t;
 
@@ -5811,6 +6011,7 @@ union cvmx_usbdrdx_uctl_bist_status {
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xxp1;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn73xx;
+	struct cvmx_usbdrdx_uctl_bist_status_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_bist_status cvmx_usbdrdx_uctl_bist_status_t;
 
@@ -6107,6 +6308,7 @@ union cvmx_usbdrdx_uctl_ctl {
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xx;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xxp1;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn73xx;
+	struct cvmx_usbdrdx_uctl_ctl_s        cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
 
@@ -6201,6 +6403,7 @@ union cvmx_usbdrdx_uctl_ecc {
 	} cn70xx;
 	struct cvmx_usbdrdx_uctl_ecc_cn70xx   cn70xxp1;
 	struct cvmx_usbdrdx_uctl_ecc_s        cn73xx;
+	struct cvmx_usbdrdx_uctl_ecc_s        cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_ecc cvmx_usbdrdx_uctl_ecc_t;
 
@@ -6281,6 +6484,7 @@ union cvmx_usbdrdx_uctl_host_cfg {
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xx;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xxp1;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn73xx;
+	struct cvmx_usbdrdx_uctl_host_cfg_s   cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_host_cfg cvmx_usbdrdx_uctl_host_cfg_t;
 
@@ -6379,6 +6583,7 @@ union cvmx_usbdrdx_uctl_intstat {
 	} cn70xx;
 	struct cvmx_usbdrdx_uctl_intstat_cn70xx cn70xxp1;
 	struct cvmx_usbdrdx_uctl_intstat_s    cn73xx;
+	struct cvmx_usbdrdx_uctl_intstat_s    cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_intstat cvmx_usbdrdx_uctl_intstat_t;
 
@@ -6503,6 +6708,7 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xxp1;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn73xx;
+	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_hs cvmx_usbdrdx_uctl_portx_cfg_hs_t;
 
@@ -6638,6 +6844,7 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xxp1;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn73xx;
+	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
 
@@ -6730,6 +6937,7 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg {
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xxp1;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn73xx;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_t;
 
@@ -6761,6 +6969,7 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xxp1;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn73xx;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_status cvmx_usbdrdx_uctl_portx_cr_dbg_status_t;
 
@@ -6858,6 +7067,7 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 	} cn70xx;
 	struct cvmx_usbdrdx_uctl_shim_cfg_cn70xx cn70xxp1;
 	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn73xx;
+	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_shim_cfg cvmx_usbdrdx_uctl_shim_cfg_t;
 
@@ -6900,6 +7110,7 @@ union cvmx_usbdrdx_uctl_spare0_eco {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_spare0_eco_s cn73xx;
+	struct cvmx_usbdrdx_uctl_spare0_eco_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_spare0_eco cvmx_usbdrdx_uctl_spare0_eco_t;
 
@@ -6943,6 +7154,7 @@ union cvmx_usbdrdx_uctl_spare1_eco {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_spare1_eco_s cn73xx;
+	struct cvmx_usbdrdx_uctl_spare1_eco_s cn75xx;
 };
 typedef union cvmx_usbdrdx_uctl_spare1_eco cvmx_usbdrdx_uctl_spare1_eco_t;
 
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index fcdfea1..84959a9 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -197,12 +197,15 @@ static inline int octeon_has_feature_OCTEON_FEATURE_ZIP(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_ZIP3(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+	     || OCTEON_IS_MODEL(OCTEON_CN75XX)
 	     || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BCH(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN70XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CRYPTO(void)
@@ -352,6 +355,7 @@ static inline int octeon_has_feature_OCTEON_FEATURE_NPEI(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_PKND(void)
 {
 	return OCTEON_IS_MODEL(OCTEON_CN68XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN78XX);
 }
@@ -368,12 +372,15 @@ static inline int octeon_has_feature_OCTEON_FEATURE_CIU2(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CIU3(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_FPA3(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
@@ -442,12 +449,14 @@ static inline int octeon_has_feature_OCTEON_FEATURE_MULTINODE(void)
 {
 	return (!OCTEON_IS_MODEL(OCTEON_CN76XX)
 		&& OCTEON_IS_MODEL(OCTEON_CN78XX)
+		&& !OCTEON_IS_MODEL(OCTEON_CN75XX)
 		&& !OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CN78XX_WQE(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
@@ -464,12 +473,14 @@ static inline int octeon_has_feature_OCTEON_FEATURE_SPI(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_PKI(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_PKO3(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
@@ -481,17 +492,22 @@ static inline int octeon_has_feature_OCTEON_FEATURE_OCLA(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_FAU(void)
 {
 	return (!OCTEON_IS_MODEL(OCTEON_CN78XX)
+		&& !OCTEON_IS_MODEL(OCTEON_CN75XX)
 		&& !OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BGX(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BGX_MIX(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN75XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 /*
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 171ba80..6076833 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -43,7 +43,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 107196 $<hr>
+ * <hr>$Revision: 111709 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
@@ -99,6 +99,10 @@ extern "C" {
  * CN7XXX models with new revision encoding
  */
 
+#define OCTEON_CN75XX_PASS1_0   0x000d9800
+#define OCTEON_CN75XX           (OCTEON_CN75XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CN75XX_PASS1_X   (OCTEON_CN75XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
+
 #define OCTEON_CN73XX_PASS1_0   0x000d9700
 #define OCTEON_CN73XX           (OCTEON_CN73XX_PASS1_0 | OM_IGNORE_REVISION)
 #define OCTEON_CN73XX_PASS1_X   (OCTEON_CN73XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
-- 
2.6.2

