From 05b73b5ea3593494b6f89ed6e4601c8c27ffe9c2 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Fri, 7 Feb 2014 13:46:59 -0800
Subject: [PATCH 448/974] MIPS: msi-octeon: Add msi-x support.

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/pci.h |   5 --
 arch/mips/pci/msi-octeon.c  | 186 ++++++++------------------------------------
 2 files changed, 33 insertions(+), 158 deletions(-)

diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index 6a28433..f43393d 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -21,25 +21,18 @@
 #include <asm/octeon/cvmx-ciu2-defs.h>
 #include <asm/octeon/pci-octeon.h>
 
-/*
- * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is
- * in use.
- */
-static u64 msi_free_irq_bitmask[4];
+#define MSI_IRQ_SIZE		256
 
 /*
- * Each bit in msi_multiple_irq_bitmask tells that the device using
- * this bit in msi_free_irq_bitmask is also using the next bit. This
- * is used so we can disable all of the MSI interrupts when a device
- * uses multiple.
+ * Each bit in msi_free_irq_bitmap represents a MSI interrupt that is
+ * in use.
  */
-static u64 msi_multiple_irq_bitmask[4];
+static DECLARE_BITMAP(msi_free_irq_bitmap, MSI_IRQ_SIZE);
 
 /*
- * This lock controls updates to msi_free_irq_bitmask and
- * msi_multiple_irq_bitmask.
+ * This lock controls updates to msi_free_irq_bitmap.
  */
-static DEFINE_SPINLOCK(msi_free_irq_bitmask_lock);
+static DEFINE_SPINLOCK(msi_free_irq_bitmap_lock);
 
 /*
  * Number of MSI IRQs used. This variable is set up in
@@ -62,89 +55,26 @@ static int msi_irq_size;
 int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 {
 	struct msi_msg msg;
-	u16 control;
-	int configured_private_bits;
-	int request_private_bits;
-	int irq = 0;
-	int irq_step;
-	u64 search_mask;
-	int index;
-
-	/*
-	 * Read the MSI config to figure out how many IRQs this device
-	 * wants.  Most devices only want 1, which will give
-	 * configured_private_bits and request_private_bits equal 0.
-	 */
-	pci_read_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
-			     &control);
-
-	/*
-	 * If the number of private bits has been configured then use
-	 * that value instead of the requested number. This gives the
-	 * driver the chance to override the number of interrupts
-	 * before calling pci_enable_msi().
-	 */
-	configured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4;
-	if (configured_private_bits == 0) {
-		/* Nothing is configured, so use the hardware requested size */
-		request_private_bits = (control & PCI_MSI_FLAGS_QMASK) >> 1;
-	} else {
-		/*
-		 * Use the number of configured bits, assuming the
-		 * driver wanted to override the hardware request
-		 * value.
-		 */
-		request_private_bits = configured_private_bits;
-	}
-
-	/*
-	 * The PCI 2.3 spec mandates that there are at most 32
-	 * interrupts. If this device asks for more, only give it one.
-	 */
-	if (request_private_bits > 5)
-		request_private_bits = 0;
-
-try_only_one:
-	/*
-	 * The IRQs have to be aligned on a power of two based on the
-	 * number being requested.
-	 */
-	irq_step = 1 << request_private_bits;
-
-	/* Mask with one bit for each IRQ */
-	search_mask = (1ull << irq_step) - 1;
+	int irq;
 
 	/*
-	 * We're going to search msi_free_irq_bitmask_lock for zero
-	 * bits. This represents an MSI interrupt number that isn't in
-	 * use.
+	 * We're going to search msi_free_irq_bitmap for zero bits. This
+	 * represents an MSI interrupt number that isn't in use.
 	 */
-	spin_lock(&msi_free_irq_bitmask_lock);
-	for (index = 0; index < msi_irq_size/64; index++) {
-		for (irq = 0; irq < 64; irq += irq_step) {
-			if ((msi_free_irq_bitmask[index] & (search_mask << irq)) == 0) {
-				msi_free_irq_bitmask[index] |= search_mask << irq;
-				msi_multiple_irq_bitmask[index] |= (search_mask >> 1) << irq;
-				goto msi_irq_allocated;
-			}
-		}
+	spin_lock(&msi_free_irq_bitmap_lock);
+	irq = find_next_zero_bit(msi_free_irq_bitmap, MSI_IRQ_SIZE, 1);
+	if (irq < MSI_IRQ_SIZE) {
+		set_bit(irq, msi_free_irq_bitmap);
+		spin_unlock(&msi_free_irq_bitmap_lock);
 	}
-msi_irq_allocated:
-	spin_unlock(&msi_free_irq_bitmask_lock);
-
-	/* Make sure the search for available interrupts didn't fail */
-	if (irq >= 64) {
-		if (request_private_bits) {
-			pr_err("arch_setup_msi_irq: Unable to find %d free interrupts, trying just one",
-			       1 << request_private_bits);
-			request_private_bits = 0;
-			goto try_only_one;
-		} else
-			panic("arch_setup_msi_irq: Unable to find a free MSI interrupt");
+	else {
+		spin_unlock(&msi_free_irq_bitmap_lock);
+		WARN(1, "arch_setup_msi_irq: Unable to find a free MSI "
+		     "interrupt");
+		return -ENOSPC;
 	}
 
 	/* MSI interrupts start at logical IRQ OCTEON_IRQ_MSI_BIT0 */
-	irq += index*64;
 	msg.data = irq;
 	irq += OCTEON_IRQ_MSI_BIT0;
 
@@ -175,46 +105,11 @@ msi_irq_allocated:
 		panic("arch_setup_msi_irq: Invalid octeon_dma_bar_type");
 	}
 
-	/* Update the number of IRQs the device has available to it */
-	control &= ~PCI_MSI_FLAGS_QSIZE;
-	control |= request_private_bits << 4;
-	pci_write_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
-			      control);
-
 	irq_set_msi_desc(irq, desc);
 	write_msi_msg(irq, &msg);
 	return 0;
 }
 
-int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
-{
-	struct msi_desc *entry;
-	int ret;
-
-	/*
-	 * MSI-X is not supported.
-	 */
-	if (type == PCI_CAP_ID_MSIX)
-		return -EINVAL;
-
-	/*
-	 * If an architecture wants to support multiple MSI, it needs to
-	 * override arch_setup_msi_irqs()
-	 */
-	if (type == PCI_CAP_ID_MSI && nvec > 1)
-		return 1;
-
-	list_for_each_entry(entry, &dev->msi_list, list) {
-		ret = arch_setup_msi_irq(dev, entry);
-		if (ret < 0)
-			return ret;
-		if (ret > 0)
-			return -ENOSPC;
-	}
-
-	return 0;
-}
-
 /**
  * Called when a device no longer needs its MSI interrupts. All
  * MSI interrupts for the device are freed.
@@ -223,10 +118,7 @@ int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
  */
 void arch_teardown_msi_irq(unsigned int irq)
 {
-	int number_irqs;
-	u64 bitmask;
-	int index = 0;
-	int irq0;
+	int old;
 
 	if ((irq < OCTEON_IRQ_MSI_BIT0)
 		|| (irq > msi_irq_size + OCTEON_IRQ_MSI_BIT0 - 1))
@@ -234,32 +126,14 @@ void arch_teardown_msi_irq(unsigned int irq)
 		      irq);
 
 	irq -= OCTEON_IRQ_MSI_BIT0;
-	index = irq / 64;
-	irq0 = irq % 64;
-	/*
-	 * Count the number of IRQs we need to free by looking at the
-	 * msi_multiple_irq_bitmask. Each bit set means that the next
-	 * IRQ is also owned by this device.
-	 */
-	number_irqs = 0;
-	while ((irq0 + number_irqs < 64) &&
-	       (msi_multiple_irq_bitmask[index]
-		& (1ull << (irq0 + number_irqs))))
-		number_irqs++;
-	number_irqs++;
-	/* Mask with one bit for each IRQ */
-	bitmask = (1ull << number_irqs) - 1;
-	/* Shift the mask to the correct bit location */
-	bitmask <<= irq0;
-	if ((msi_free_irq_bitmask[index] & bitmask) != bitmask)
-		panic("arch_teardown_msi_irq: Attempted to teardown MSI interrupt (%d) not in use",
-		      irq);
+	spin_lock(&msi_free_irq_bitmap_lock);
+	old = test_and_clear_bit(irq, msi_free_irq_bitmap);
+	spin_unlock(&msi_free_irq_bitmap_lock);
 
-	/* Checks are done, update the in use bitmask */
-	spin_lock(&msi_free_irq_bitmask_lock);
-	msi_free_irq_bitmask[index] &= ~bitmask;
-	msi_multiple_irq_bitmask[index] &= ~bitmask;
-	spin_unlock(&msi_free_irq_bitmask_lock);
+	if (!old) {
+		WARN(1, "arch_teardown_msi_irq: Attempted to teardown MSI "
+		     "interrupt (%d) not in use", irq);
+	}
 }
 
 static DEFINE_RAW_SPINLOCK(octeon_irq_msi_lock);
@@ -368,6 +242,7 @@ static void octeon_irq_msi_enable_pcie(struct irq_data *data)
 	cvmx_write_csr(msi_ena_reg[irq_index], en);
 	cvmx_read_csr(msi_ena_reg[irq_index]);
 	raw_spin_unlock_irqrestore(&octeon_irq_msi_lock, flags);
+	unmask_msi_irq(data);
 }
 
 static void octeon_irq_msi_disable_pcie(struct irq_data *data)
@@ -384,6 +259,7 @@ static void octeon_irq_msi_disable_pcie(struct irq_data *data)
 	cvmx_write_csr(msi_ena_reg[irq_index], en);
 	cvmx_read_csr(msi_ena_reg[irq_index]);
 	raw_spin_unlock_irqrestore(&octeon_irq_msi_lock, flags);
+	mask_msi_irq(data);
 }
 
 static struct irq_chip octeon_irq_chip_msi_pcie = {
@@ -626,6 +502,10 @@ int __init octeon_msi_initialize(void)
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 0;
+
+	/* Clear msi irq bitmap */
+	bitmap_zero(msi_free_irq_bitmap, MSI_IRQ_SIZE);
+
 #if 0
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
 		return octeon_msi_68XX_init();
-- 
2.6.2

