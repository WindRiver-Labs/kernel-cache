From 8286e9b75e4ca0f92d0c702fb27d2db30a620be3 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Mon, 10 Feb 2014 13:46:59 -0800
Subject: [PATCH 533/974] MIPS:OCTEON: NAND: Minor cleanup.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-nand.c | 21 ++++++---------------
 1 file changed, 6 insertions(+), 15 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-nand.c b/arch/mips/cavium-octeon/octeon-nand.c
index b58e16e..8eba9e2 100644
--- a/arch/mips/cavium-octeon/octeon-nand.c
+++ b/arch/mips/cavium-octeon/octeon-nand.c
@@ -232,10 +232,9 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
-	
+
 		DEV_DBG(DEBUG_READ, priv->dev, "Correcting block offset %ld, ecc offset %d\n",
 			p - buf, i);
-
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
 		if (stat < 0) {
 			mtd->ecc_stats.failed++;
@@ -268,7 +267,7 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 		int ret;
 		ret = chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 		if (ret < 0)
-			printk("\n=== chip->ecc.calculate(mtd, p=%p, &ecc_calc[i]) returned %d\n", p, ret);
+			DEV_DBG(DEBUG_WRITE, priv->dev, "=== chip->ecc.calculate(mtd, p=%p, &ecc_calc[i]) returned %d\n", p, ret);
 		
 		DEV_DBG(DEBUG_WRITE, priv->dev, "block offset %ld, ecc offset %d\n",
 			p - buf, i);
@@ -296,7 +295,6 @@ static int octeon_nand_write_page_raw(struct mtd_info *mtd,
 				      struct nand_chip *chip,
 				      const uint8_t *buf, int oob_required)
 {
-	// same as in drivers/mtd/nand/nand_base.c
 	chip->write_buf(mtd, buf, mtd->writesize);
 	if (oob_required)
 		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -315,7 +313,6 @@ static int octeon_nand_write_oob_std(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     int page)
 {
-	// same as in drivers/mtd/nand/nand_base.c
 	int status = 0;
 	const uint8_t *buf = chip->oob_poi;
 	int length = mtd->oobsize;
@@ -344,7 +341,6 @@ static int octeon_nand_read_page_raw(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     uint8_t *buf, int oob_required, int page)
 {
-	// same as in drivers/mtd/nand/nand_base.c
 	chip->read_buf(mtd, buf, mtd->writesize);
 	if (oob_required)
 		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -362,7 +358,6 @@ static int octeon_nand_read_oob_std(struct mtd_info *mtd,
 				    int page)
 
 {
-	// same as in drivers/mtd/nand/nand_base.c
 	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 	return 0;
@@ -532,7 +527,7 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 	int rc;
 	int i;
 	void *ecc_ptr;
-	uint8_t ecc_buffer[/*45*/nand_chip->ecc.bytes] __attribute__((__aligned__(8)));
+	uint8_t ecc_buffer[nand_chip->ecc.bytes] __attribute__((__aligned__(8)));
 
 	if ((ulong)code % 8) {
 		ecc_ptr = ecc_buffer;
@@ -928,7 +923,7 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 
 		{
 		/*
-		 * nand.ecc.strenght will be used as ecc_level so 
+		 * nand.ecc.strength will be used as ecc_level so 
 		 * it should be in {4, 8, 16, 24, 32, 40, 48, 56, 60, 64}
 		 * needed ecc_bytes for m=15 (hardcoded in NAND controller)
 		 */
@@ -967,12 +962,11 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		}
 		
 		/*
-		 * strenght=24 needs total of ecc.bytes=180 for 4k page
-		 * strenght=32 needs total of ecc.bytes=240 for 4k page
+		 * strength=24 needs total of ecc.bytes=180 for 4k page
+		 * strength=32 needs total of ecc.bytes=240 for 4k page
 		 * Our NAND has only 224 bytes OOB so we should use max
 		 * ecc.strength=24 ,ecc.bytes=45 and ecc_totalbytes=180
 		 */
-/*		if (priv->nand.ecc.strength > 24) priv->nand.ecc.strength = 24;*/
 		}
 		
 		/* The number of ECC bits required is m * t
@@ -989,9 +983,6 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		 */
 		priv->nand.ecc.bytes = ((15 * priv->nand.ecc.strength) + 7) / 8;
 		
-		/* priv->nand.ecc.strength =
-			(priv->nand.ecc.bytes * 8) / fls(8 * priv->nand.ecc.size);*/
-
 		priv->nand.ecc.steps = (1 << priv->nand.page_shift) / priv->nand.ecc.size;
 		priv->nand.ecc.calculate = octeon_nand_bch_calculate;
 		priv->nand.ecc.correct = octeon_nand_bch_correct;
-- 
2.6.2

