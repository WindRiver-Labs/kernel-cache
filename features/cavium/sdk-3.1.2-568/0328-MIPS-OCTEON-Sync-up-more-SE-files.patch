From 5aee5aed6e65f1baa8ff235f9e897d092f517952 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Sat, 7 Sep 2013 10:29:21 -0700
Subject: [PATCH 328/974] MIPS: OCTEON: Sync up more SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c | 62 ++++++++++++-----
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       | 78 +++++++++++++++-------
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     | 24 +++++++
 3 files changed, 124 insertions(+), 40 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 1396c91..ca9dbeb 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -81,10 +81,11 @@
 
 CVMX_SHARED struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_HELPER_MAX_IFACE][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE] =
 	{[0 ... CVMX_HELPER_MAX_IFACE - 1] = {[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] =
-					      { CVMX_HELPER_CFG_INVALID_VALUE, CVMX_HELPER_CFG_INVALID_VALUE,
-						CVMX_HELPER_CFG_INVALID_VALUE, CVMX_HELPER_CFG_INVALID_VALUE,
-						CVMX_HELPER_CFG_INVALID_VALUE, 0,
-						0}}};
+				      	      { CVMX_HELPER_CFG_INVALID_VALUE, CVMX_HELPER_CFG_INVALID_VALUE,
+				                CVMX_HELPER_CFG_INVALID_VALUE, CVMX_HELPER_CFG_INVALID_VALUE,
+	                                        CVMX_HELPER_CFG_INVALID_VALUE, 0,
+	                                        0}}};
+
 /*
  * Indexed by the pko_port number
  */
@@ -527,19 +528,21 @@ void cvmx_helper_cfg_store_short_packets_in_wqe()
 {
 	int interface, port;
 
-	for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
-		int num_ports = cvmx_helper_ports_on_interface(interface);
-		/* Enable storing short packets only in the WQE */
-		for (port = 0; port < num_ports; port++) {
-			cvmx_pip_port_cfg_t port_cfg;
-			int pknd = port;
-			if (octeon_has_feature(OCTEON_FEATURE_PKND))
-				pknd = cvmx_helper_get_pknd(interface, port);
-			else
-				pknd = cvmx_helper_get_ipd_port(interface, port);
-			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
-			port_cfg.s.dyn_rs = 1;
-			cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
+	if (!OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
+			int num_ports = cvmx_helper_ports_on_interface(interface);
+			/* Enable storing short packets only in the WQE */
+			for (port = 0; port < num_ports; port++) {
+				cvmx_pip_port_cfg_t port_cfg;
+				int pknd = port;
+				if (octeon_has_feature(OCTEON_FEATURE_PKND))
+					pknd = cvmx_helper_get_pknd(interface, port);
+				else
+					pknd = cvmx_helper_get_ipd_port(interface, port);
+				port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+				port_cfg.s.dyn_rs = 1;
+				cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
+			}
 		}
 	}
 }
@@ -724,6 +727,31 @@ bool cvmx_helper_get_1000x_mode(int interface, int index)
 }
 EXPORT_SYMBOL(cvmx_helper_get_1000x_mode);
 
+void cvmx_helper_set_agl_rx_clock_delay_bypass(int interface, int index,
+					       bool valid)
+{
+	cvmx_cfg_port[interface][index].agl_rx_clk_delay_bypass = valid;
+}
+EXPORT_SYMBOL(cvmx_helper_set_agl_rx_clock_delay_bypass);
+
+bool cvmx_helper_get_agl_rx_clock_delay_bypass(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].agl_rx_clk_delay_bypass;
+}
+EXPORT_SYMBOL(cvmx_helper_get_agl_rx_clock_delay_bypass);
+
+void cvmx_helper_set_agl_rx_clock_skew(int interface, int index, uint8_t value)
+{
+	cvmx_cfg_port[interface][index].agl_rx_clk_skew = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_agl_rx_clock_skew);
+
+uint8_t cvmx_helper_get_agl_rx_clock_skew(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].agl_rx_clk_skew;
+}
+EXPORT_SYMBOL(cvmx_helper_get_agl_rx_clock_skew);
+
 int __cvmx_helper_init_port_valid(void)
 {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index 5b496de..9c4706d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -43,7 +43,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 85169 $<hr>
+ * <hr>$Revision: 89166 $<hr>
  *
  */
 
@@ -383,15 +383,15 @@ int cvmx_l2c_lock_line(uint64_t addr)
 			/* make sure CVMX_L2C_TADX_TAG is updated */
 			CVMX_SYNC;
 			l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(tad));
-			if (OCTEON_IS_OCTEON2() && l2c_tadx_tag.s.valid &&
+			if (OCTEON_IS_OCTEON2() && l2c_tadx_tag.cn61xx.valid &&
 			    l2c_tadx_tag.cn61xx.tag == tag)
 				break;
 			else if (OCTEON_IS_MODEL(OCTEON_CN70XX)
 				 && l2c_tadx_tag.cn70xx.valid
 				 && l2c_tadx_tag.cn70xx.tag == tag)
 				break;
-			else if (l2c_tadx_tag.s.valid &&
-			    l2c_tadx_tag.cn78xx.tag == tag)
+			else if (l2c_tadx_tag.cn78xx.ts == 0
+				 && l2c_tadx_tag.cn78xx.tag == tag)
 			        break;
 
 			/* cvmx_dprintf("caddr=%lx tad=%d tagu64=%lx valid=%x tag=%x \n", caddr,
@@ -771,15 +771,22 @@ union cvmx_l2c_tag cvmx_l2c_get_tag_v2(uint32_t association, uint32_t index, uin
 		CVMX_SYNC;	/* make sure CVMX_L2C_TADX_TAG is updated */
 		l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(tad));
 
-		tag.s.V = l2c_tadx_tag.s.valid;
-		tag.s.D = l2c_tadx_tag.s.dirty;
-		tag.s.L = l2c_tadx_tag.s.lock;
-		tag.s.U = l2c_tadx_tag.cn61xx.use;
-		tag.s.addr = (OCTEON_IS_MODEL(OCTEON_CN70XX) 
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+			if (l2c_tadx_tag.cn78xx.ts == 0)
+				tag.s.V = 1;
+			tag.s.D = l2c_tadx_tag.cn78xx.sblkdty; /* FIXME */
+			tag.s.L = l2c_tadx_tag.cn78xx.lock;
+			tag.s.U = l2c_tadx_tag.cn78xx.used;
+			tag.s.addr = l2c_tadx_tag.cn78xx.tag;
+		} else {
+			tag.s.V = l2c_tadx_tag.cn61xx.valid;
+			tag.s.D = l2c_tadx_tag.cn61xx.dirty;
+			tag.s.L = l2c_tadx_tag.cn61xx.lock;
+			tag.s.U = l2c_tadx_tag.cn61xx.use;
+			tag.s.addr = (OCTEON_IS_MODEL(OCTEON_CN70XX)
 				? l2c_tadx_tag.cn70xx.tag
-				: (OCTEON_IS_MODEL(OCTEON_CN78XX)
-				   ? l2c_tadx_tag.cn78xx.tag
-				   : l2c_tadx_tag.cn61xx.tag));
+				   : l2c_tadx_tag.cn61xx.tag);
+		}
 	} else {
 		union __cvmx_l2c_tag tmp_tag;
 		/* __read_l2_tag is intended for internal use only */
@@ -857,15 +864,22 @@ union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 		CVMX_SYNC;	/* make sure CVMX_L2C_TADX_TAG is updated */
 		l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(0));
 
-		tag.s.V = l2c_tadx_tag.s.valid;
-		tag.s.D = l2c_tadx_tag.s.dirty;
-		tag.s.L = l2c_tadx_tag.s.lock;
-		tag.s.U = l2c_tadx_tag.cn61xx.use;
-		tag.s.addr = (OCTEON_IS_MODEL(OCTEON_CN70XX) 
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+			if (l2c_tadx_tag.cn78xx.ts == 0)
+				tag.s.V = 1;
+			tag.s.D = l2c_tadx_tag.cn78xx.sblkdty; /* FIXME */
+			tag.s.L = l2c_tadx_tag.cn78xx.lock;
+			tag.s.U = l2c_tadx_tag.cn78xx.used;
+			tag.s.addr = l2c_tadx_tag.cn78xx.tag;
+		} else {
+			tag.s.V = l2c_tadx_tag.cn61xx.valid;
+			tag.s.D = l2c_tadx_tag.cn61xx.dirty;
+			tag.s.L = l2c_tadx_tag.cn61xx.lock;
+			tag.s.U = l2c_tadx_tag.cn61xx.use;
+			tag.s.addr = (OCTEON_IS_MODEL(OCTEON_CN70XX)
 				? l2c_tadx_tag.cn70xx.tag
-				: (OCTEON_IS_MODEL(OCTEON_CN78XX)
-				   ? l2c_tadx_tag.cn78xx.tag
-				   : l2c_tadx_tag.cn61xx.tag));
+				   : l2c_tadx_tag.cn61xx.tag);
+		}
 	} else {
 		union __cvmx_l2c_tag tmp_tag;
 		/* __read_l2_tag is intended for internal use only */
@@ -1041,9 +1055,27 @@ int cvmx_l2c_get_num_assoc(void)
 	else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN30XX))
 		l2_assoc = 4;
-	else if (OCTEON_IS_MODEL(OCTEON_CN70XX))
-		return 4;
-	else {
+	else if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		union cvmx_mio_fus_dat3 mio_fus_dat3;
+
+		mio_fus_dat3.u64 = cvmx_read_csr(CVMX_MIO_FUS_DAT3);
+
+		switch (mio_fus_dat3.s.l2c_crip) {
+		case 3:  /* 1/4 size */
+			l2_assoc = 1;
+			break;
+		case 2:  /* 1/2 size */
+			l2_assoc = 2;
+			break; 
+		case 1:  /* 3/4 size */
+			l2_assoc = 3;
+			break;
+		default: /* Full size */
+			l2_assoc = 4;
+			break;
+		}
+		return l2_assoc;
+	} else {
 		cvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);
 		l2_assoc = 8;
 	}
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index fd3e1a5..8b8b4b4 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -124,6 +124,8 @@ struct cvmx_cfg_port_param {
 	bool valid;			/** 1 = port valid, 0 = invalid */
 	bool sgmii_phy_mode;		/** 1 = port in PHY mode, 0 = MAC mode */
 	bool sgmii_1000x_mode;		/** 1 = 1000Base-X mode, 0 = SGMII mode */
+	bool agl_rx_clk_delay_bypass;	/** 1 = use rx clock delay bypass for AGL mode */
+	uint8_t agl_rx_clk_skew;	/** AGL rx clock skew setting (default 0) */
 };
 
 /*
@@ -458,6 +460,28 @@ extern void cvmx_helper_set_mac_phy_mode(int interface, int index, bool valid);
 extern bool cvmx_helper_get_1000x_mode(int interface, int index);
 extern void cvmx_helper_set_1000x_mode(int interface, int index, bool valid);
 
+/**
+ * @INTERNAL
+ * Return if an AGL port should bypass the RX clock delay
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ */
+extern bool cvmx_helper_get_agl_rx_clock_delay_bypass(int interface, int index);
+extern void cvmx_helper_set_agl_rx_clock_delay_bypass(int interface, int index,
+						      bool valid);
+
+/**
+ * @INTERNAL
+ * Return the AGL port rx clock skew, only used
+ * if agl_rx_clock_delay_bypass is set.
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ */
+extern uint8_t cvmx_helper_get_agl_rx_clock_skew(int interface, int index);
+extern void cvmx_helper_set_agl_rx_clock_skew(int interface, int index,
+					      uint8_t value);
 /*
  * Initializes cvmx with user specified config info.
  */
-- 
2.6.2

