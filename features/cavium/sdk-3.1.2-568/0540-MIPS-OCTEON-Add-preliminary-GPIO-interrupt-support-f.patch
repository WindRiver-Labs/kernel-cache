From c17f33fdab5ef654f9b9770aa24b6b9e08091d3b Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 14 Feb 2014 13:46:59 -0800
Subject: [PATCH 540/974] MIPS: OCTEON: Add preliminary GPIO interrupt support
 for cn78XX.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 125 ++++++++++++++++++++++++++++++++++-
 1 file changed, 124 insertions(+), 1 deletion(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index ff0c0a8..fcdfafc 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -667,7 +667,7 @@ static void octeon_irq_gpio_setup(struct irq_data *data)
 	cfg.s.fil_cnt = 7;
 	cfg.s.fil_sel = 3;
 
-	cvmx_write_csr(CVMX_GPIO_BIT_CFGX(cd->gpio_line), cfg.u64);
+	cvmx_write_csr_node(cd->ciu_node, CVMX_GPIO_BIT_CFGX(cd->gpio_line), cfg.u64);
 }
 
 static void octeon_irq_ciu_enable_gpio_v2(struct irq_data *data)
@@ -719,6 +719,7 @@ static void octeon_irq_ciu_gpio_ack(struct irq_data *data)
 	mask = 1ull << (cd->gpio_line);
 
 	cvmx_write_csr(CVMX_GPIO_INT_CLR, mask);
+	cvmx_read_csr(CVMX_GPIO_INT_CLR);
 }
 
 static void octeon_irq_handle_trigger(unsigned int irq, struct irq_desc *desc)
@@ -1560,6 +1561,7 @@ static int __init octeon_irq_init_gpio(struct device_node *gpio_node, struct dev
 
 	return 0;
 }
+
 /*
  * Watchdog interrupts are special.  They are associated with a single
  * core, so we hardwire the affinity to that core.
@@ -2957,11 +2959,132 @@ static int __init octeon_irq_init_cib(struct device_node *ciu_node,
 	return 0;
 }
 
+static void octeon_irq_ciu3_enable_gpio(struct irq_data *data)
+{
+	octeon_irq_gpio_setup(data);
+	octeon_irq_ciu3_enable(data);
+}
+
+static void octeon_irq_ciu3_disable_gpio(struct irq_data *data)
+{
+	struct octeon_ciu_chip_data *cd;
+	cd = irq_data_get_irq_chip_data(data);
+
+	cvmx_write_csr_node(cd->ciu_node, CVMX_GPIO_BIT_CFGX(cd->gpio_line), 0);
+
+	octeon_irq_ciu3_disable(data);
+}
+
+static void octeon_irq_ciu3_gpio_ack(struct irq_data *data)
+{
+	struct octeon_ciu_chip_data *cd;
+
+	cd = irq_data_get_irq_chip_data(data);
+
+	cvmx_write_csr_node(cd->ciu_node, CVMX_GPIO_INTRX(cd->gpio_line), 1);
+	cvmx_read_csr_node(cd->ciu_node, CVMX_GPIO_INTRX(cd->gpio_line));
+}
+
+void octeon_irq_ciu3_gpio_mask_ack(struct irq_data *data)
+{
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	u64 isc_w1c_addr;
+	struct octeon_ciu_chip_data *cd;
+	u32 trigger_type = irqd_get_trigger_type(data);
+
+	if (!(trigger_type & IRQ_TYPE_LEVEL_MASK))
+		octeon_irq_ciu3_gpio_ack(data);
+
+	cd = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.en = 1;
+
+	isc_w1c_addr = cd->ciu3_addr + CIU3_ISC_W1C(cd->intsn);
+	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+	cvmx_read_csr(isc_w1c_addr);
+}
+
+
+static struct irq_chip octeon_irq_chip_ciu3_gpio = {
+	.name = "CIU3-GPIO",
+	.irq_enable	= octeon_irq_ciu3_enable_gpio,
+	.irq_disable	= octeon_irq_ciu3_disable_gpio,
+	.irq_ack	= octeon_irq_ciu3_gpio_ack,
+	.irq_mask	= octeon_irq_ciu3_mask,
+	.irq_mask_ack	= octeon_irq_ciu3_gpio_mask_ack,
+	.irq_unmask	= octeon_irq_ciu3_enable,
+	.irq_set_type	= octeon_irq_ciu_gpio_set_type,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = octeon_irq_ciu3_set_affinity,
+#endif
+	.flags = IRQCHIP_SET_TYPE_MASKED,
+};
+
+static int octeon_irq_gpio78_map(struct irq_domain *d,
+				 unsigned int virq, irq_hw_number_t hw)
+{
+	struct octeon_irq_gpio_domain_data *gpiod = d->host_data;
+	struct octeon_ciu3_info *ciu3_info;
+	struct octeon_ciu_chip_data *cd;
+
+	ciu3_info = octeon_irq_get_ciu3_info(of_node_to_nid(d->of_node));
+
+	cd = kzalloc_node(sizeof(*cd), GFP_KERNEL, of_node_to_nid(d->of_node));
+	if (!cd)
+		return -ENOMEM;
+
+	cd->intsn = gpiod->base_hwirq + hw;
+	cd->current_cpu = -1;
+	cd->ciu3_addr = ciu3_info->ciu3_addr;
+	cd->ciu_node = ciu3_info->node;
+
+	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3_gpio, octeon_irq_handle_trigger);
+	irq_set_chip_data(virq, cd);
+
+	return 0;
+}
+
+static struct irq_domain_ops octeon_irq_domain_gpio78_ops = {
+	.map = octeon_irq_gpio78_map,
+	.unmap = octeon_irq_free_cd,
+	.xlate = octeon_irq_gpio_xlat,
+};
+
+static int __init octeon_irq_init_gpio78(struct device_node *gpio_node,
+					 struct device_node *parent)
+{
+	struct octeon_irq_gpio_domain_data *gpiod;
+	unsigned int base_hwirq;
+	int r;
+	u32 v;
+
+	r = of_property_read_u32_index(gpio_node, "interrupts", 0, &v);
+	if (r) {
+		pr_warn("No \"interrupts\" property.\n");
+		return r;
+	}
+	base_hwirq = v;
+
+	gpiod = kzalloc(sizeof(*gpiod), GFP_KERNEL);
+	if (gpiod) {
+		/* gpio domain host_data is the base hwirq number. */
+		gpiod->base_hwirq = base_hwirq;
+		irq_domain_add_tree(gpio_node, &octeon_irq_domain_gpio78_ops, gpiod);
+	} else {
+		pr_warn("Cannot allocate memory for GPIO irq_domain.\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static struct of_device_id __initdata ciu_types[] = {
 	{.compatible = "cavium,octeon-3860-ciu", .data = octeon_irq_init_ciu},
 	{.compatible = "cavium,octeon-3860-gpio", .data = octeon_irq_init_gpio},
 	{.compatible = "cavium,octeon-6880-ciu2", .data = octeon_irq_init_ciu2},
 	{.compatible = "cavium,octeon-7890-ciu3", .data = octeon_irq_init_ciu3},
+	{.compatible = "cavium,octeon-7890-gpio", .data = octeon_irq_init_gpio78},
 	{.compatible = "cavium,octeon-7130-cib", .data = octeon_irq_init_cib},
 	{}
 };
-- 
2.6.2

