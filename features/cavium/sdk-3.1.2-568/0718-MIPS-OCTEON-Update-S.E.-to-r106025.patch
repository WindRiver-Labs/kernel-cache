From ade80db4f989ba1f9dcd0b690fc2a411f5415f27 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 14 Jul 2014 18:05:50 -0700
Subject: [PATCH 718/974] MIPS: OCTEON: Update S.E. to r106025

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../cavium-octeon/executive/cvmx-fpa-resource.c    |   9 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    |   3 +-
 arch/mips/cavium-octeon/executive/cvmx-range.c     |  67 ++--
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |   7 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |   4 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 342 ++++++++++++++++++++-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |  44 +++
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  18 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |   8 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  78 ++++-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |  81 ++---
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |   4 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      | 105 +------
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  19 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 326 +++++++++++++++-----
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  29 ++
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       | 153 ++++++---
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  19 +-
 20 files changed, 971 insertions(+), 349 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c b/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
index 1306a53..6f9d6c4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
@@ -180,8 +180,7 @@ cvmx_fpa3_reserve_pool(int node, int desired_pool_num)
 		rv = cvmx_resource_alloc_reverse(tag, owner);
 
 	if (rv < 0) {
-		cvmx_printf("ERROR: %s: node=%u desired_pool=%d\n",
-			__func__, node, desired_pool_num);
+		/* Desired pool is already in use */
 		return CVMX_FPA3_INVALID_POOL;
 	}
 
@@ -198,6 +197,12 @@ int cvmx_fpa3_release_pool(cvmx_fpa3_pool_t pool)
 	if (!__cvmx_fpa3_pool_valid(pool))
 		return -1;
 
+	if (cvmx_create_global_resource_range(tag, CVMX_FPA3_NUM_POOLX) != 0) {
+		cvmx_printf("ERROR: %s: global resource create node=%u\n",
+			__func__, pool.node);
+		return -1;
+	}
+
 	return
 		cvmx_free_global_resource_range_multiple(tag, &lpool, 1);
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index daa365e..1c49350 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -2739,7 +2739,7 @@ cvmx_helper_board_usb_clock_types_t __cvmx_helper_board_usb_get_clock_type(void)
 		return USB_CLOCK_TYPE_CRYSTAL_12;
 	return USB_CLOCK_TYPE_REF_48;
 }
-
+EXPORT_SYMBOL(__cvmx_helper_board_usb_get_clock_type);
 /**
  * @INTERNAL
  * Adjusts the number of available USB ports on Octeon based on board
@@ -2766,3 +2766,4 @@ int __cvmx_helper_board_usb_get_num_ports(int supported_ports)
 
 	return supported_ports;
 }
+EXPORT_SYMBOL(__cvmx_helper_board_usb_get_num_ports);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-range.c b/arch/mips/cavium-octeon/executive/cvmx-range.c
index 6669b7e..86bac75 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-range.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-range.c
@@ -78,8 +78,9 @@ static int64_t cvmx_range_find_next_available(uint64_t range_addr, uint64_t inde
 	for (i = index; i < size; i += align) {
 		uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (debug)
-			cvmx_dprintf("index=%d owner=%llx\n", (int) i,
-				     (unsigned long long) r_owner);
+			cvmx_dprintf("%s: index=%d owner=%llx\n",
+				__func__, (int) i, 
+				(unsigned long long) r_owner);
 		if (r_owner == CVMX_RANGE_AVAILABLE)
 			return i;
 	}
@@ -101,7 +102,8 @@ static int64_t cvmx_range_find_last_available(uint64_t range_addr, uint64_t inde
 		uint64_t r_owner = cvmx_read64_uint64(
 			addr_of_element(range_addr, i));
 		if (debug)
-			cvmx_dprintf("index=%d owner=%llx\n", (int) i,
+			cvmx_dprintf("%s: index=%d owner=%llx\n",
+				__func__, (int) i,
 				(unsigned long long) r_owner);
 		if (r_owner == CVMX_RANGE_AVAILABLE)
 			return i;
@@ -154,8 +156,13 @@ int cvmx_range_alloc_ordered(uint64_t range_addr, uint64_t owner, uint64_t cnt,
 			return first_available;
 		}
 	}
-	cvmx_dprintf("ERROR: failed to allocate range cnt=%d \n", (int)cnt);
-	cvmx_range_show(range_addr);
+
+	if (debug) {
+		cvmx_dprintf("ERROR: %s: failed to allocate range cnt=%d\n",
+			__func__, (int)cnt);
+		cvmx_range_show(range_addr);
+	}
+
 	return -1;
 }
 
@@ -174,8 +181,9 @@ int  cvmx_range_alloc_non_contiguos(uint64_t range_addr, uint64_t owner, uint64_
 	for (i = 0; i < size; i++) {
 		uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (debug)
-			cvmx_dprintf("index=%d owner=%llx\n", (int) i,
-				     (unsigned long long) r_owner);
+			cvmx_dprintf("%s: index=%d owner=%llx\n",
+				__func__, (int) i,
+				(unsigned long long) r_owner);
 		if (r_owner == CVMX_RANGE_AVAILABLE)
 			elements[element_index++] = (int) i;
 
@@ -184,8 +192,9 @@ int  cvmx_range_alloc_non_contiguos(uint64_t range_addr, uint64_t owner, uint64_
 	}
 	if (element_index != cnt) {
 		if (debug)
-			cvmx_dprintf("ERROR: failed to allocate non contiguous cnt=%d"
-				     " available=%d\n", (int)cnt, (int) element_index);
+			cvmx_dprintf("%s: failed to allocate non contiguous cnt=%d"
+				     " available=%d\n",
+				     __func__, (int)cnt, (int) element_index);
 		return -1;
 	}
 	for (i = 0; i < cnt; i++) {
@@ -203,9 +212,9 @@ int cvmx_range_reserve(uint64_t range_addr, uint64_t owner, uint64_t base, uint6
 
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
 	if (up > size) {
-		if (debug)
-			cvmx_dprintf("ERROR: invalid base or cnt. "
+		cvmx_dprintf("ERROR: %s: invalid base or cnt. "
 			    "range_addr=0x%llx, owner=0x%llx, size=%d base+cnt=%d\n",
+			     __func__,
 			     (unsigned long long)range_addr,
 			     (unsigned long long)owner,
 			     (int)size, (int)up);
@@ -214,9 +223,13 @@ int cvmx_range_reserve(uint64_t range_addr, uint64_t owner, uint64_t base, uint6
 	for (i = base; i < up; i++) {
 		r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (debug)
-			cvmx_dprintf("%d: %llx\n", (int) i, (unsigned long long) r_owner);
+			cvmx_dprintf("%s: %d: %llx\n",
+				__func__, (int) i,
+				(unsigned long long) r_owner);
 		if (r_owner != CVMX_RANGE_AVAILABLE) {
-			cvmx_dprintf("INFO: resource already reserved base+cnt=%d %llu %llu %llx %llx %llx\n",
+		    if (debug)
+			cvmx_dprintf("%s: resource already reserved base+cnt=%d %llu %llu %llx %llx %llx\n",
+				     __func__,
 				     (int)i, (unsigned long long)cnt, (unsigned long long)base,
 				     (unsigned long long)r_owner, (unsigned long long)range_addr,
 				     (unsigned long long)owner);
@@ -255,14 +268,16 @@ int __cvmx_range_is_allocated(uint64_t range_addr, int bases[], int count)
 	for (i = 0; i < cnt; i++) {
 		uint64_t base = bases[i];
 		if (base >= size) {
-			cvmx_dprintf("ERROR: invalid base or cnt size=%d "
-				     "base=%d \n", (int) size, (int)base);
+			cvmx_dprintf("ERROR: %s: invalid base or cnt size=%d "
+				     "base=%d \n",
+				     __func__, (int) size, (int)base);
 			return 0;
 		}
 		r_owner = cvmx_read64_uint64(addr_of_element(range_addr,base));
 		if (r_owner == CVMX_RANGE_AVAILABLE) {
-			cvmx_dprintf("ERROR: i=%d:base=%d is available\n",
-				     (int) i, (int) base);
+		    if (debug)
+			cvmx_dprintf("%s: i=%d:base=%d is available\n",
+				     __func__, (int) i, (int) base);
 			return 0;
 		}
 	}
@@ -292,7 +307,9 @@ int cvmx_range_free_with_base(uint64_t range_addr, int base, int cnt)
 
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
 	if (up > size) {
-		cvmx_dprintf("ERROR: invalid base or cnt size=%d base+cnt=%d \n", (int) size, (int)up);
+		cvmx_dprintf("ERROR: %s: invalid base or cnt size=%d"
+			" base+cnt=%d\n",
+			__func__, (int) size, (int)up);
 		return -1;
 	}
 	for (i = base; i < up; i++) {
@@ -304,9 +321,10 @@ int cvmx_range_free_with_base(uint64_t range_addr, int base, int cnt)
 uint64_t cvmx_range_get_owner(uint64_t range_addr, uint64_t base)
 {
 	uint64_t size = cvmx_read64_uint64(addr_of_size(range_addr));
+
 	if (base >= size) {
-		cvmx_dprintf("ERROR: invalid base or cnt size=%d base=%d\n",
-			(int) size, (int)base);
+		cvmx_dprintf("ERROR: %s: invalid base or cnt size=%d base=%d\n",
+			__func__, (int) size, (int)base);
 		return 0;
 	}
 	return cvmx_read64_uint64(addr_of_element(range_addr, base));
@@ -319,13 +337,18 @@ void cvmx_range_show(uint64_t range_addr)
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
 	pval = cvmx_read64_uint64(addr_of_element(range_addr, 0));
 	pindex = 0;
+
+	cvmx_dprintf ("index=%d: owner %llx\n",
+				(int) pindex, CAST_ULL(pval));
+
 	for (i = 1; i < size; i++) {
 		val = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (val != pval) {
-			cvmx_dprintf ("i=%d : %llx \n", (int) pindex, (unsigned long long)pval);
+			cvmx_dprintf ("index=%d: owner %llx\n",
+				(int) pindex, CAST_ULL(pval));
 			pindex = i;
 			pval = val;
 		}
 	}
-	cvmx_dprintf ("i=%d : %d \n", (int) pindex, (int)pval);
+	cvmx_dprintf("index=%d: owner %llx\n", (int) pindex, CAST_ULL(pval));
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 9c727b4..971eba2 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -4436,7 +4436,8 @@ union cvmx_bgxx_gmp_pcs_anx_lp_abil {
 	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t np                           : 1;  /**< 0 = Link partner not next page capable.
+	uint64_t np                           : 1;  /**< Next page capable:
+                                                         0 = Link partner not next page capable.
                                                          1 = Link partner next page capable. */
 	uint64_t ack                          : 1;  /**< When set, indicates acknowledgement received. */
 	uint64_t rem_flt                      : 2;  /**< Link partner's link status as follows:
@@ -4591,12 +4592,10 @@ typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
  * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or
  * 1000Base-X modes.
  *
- * Repeat note from SGM_AN_ADV register
- * NOTE: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the
+ * Note: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the
  * MAC_PHY mode bit in misc_ctl_reg is set (1=PHY mode). If the bit is not set (0=MAC mode), the
  * tx_config_reg[14] becomes ACK bit and [0] is always 1.
  * All other bits in tx_config_reg sent will be 0. The PHY dictates the Auto Negotiation results.
- * SGMII Misc Control Register
  */
 union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index c9c21eb..59d6038 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -470,7 +470,7 @@ union cvmx_ciu3_idtx_io {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t io                           : 5;  /**< Bitmask of which IO bridges or MCD to receive interrupts via this IDT.
-                                                         Enumerated with CIU_DEST_IO_E. */
+                                                         Enumerated by CIU_DEST_IO_E. */
 #else
 	uint64_t io                           : 5;
 	uint64_t reserved_5_63                : 59;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 155a93b..a82c84f 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -1632,8 +1632,8 @@ union cvmx_fpa_gen_cfg {
                                                          0x1 = 32 pools, 640 FPF entries per pool.
                                                          0x2 = 16 pools, 1280 FPF entries per pool.
                                                          0x3 = Reserved. */
-	uint64_t avg_en                       : 1;  /**< QoS averaging enable. When set, compute average buffer levels, and [LVL_DLY] must be non-
-                                                         zero. When clear, do not compute averages and save a few mW of power. */
+	uint64_t avg_en                       : 1;  /**< QoS averaging enable. When set, RED calculations use average buffer levels. When clear,
+                                                         RED calcuations use the current values. */
 	uint64_t clk_override                 : 1;  /**< Conditional clock override. */
 #else
 	uint64_t clk_override                 : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index 4b73089..6eb8f75 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -792,7 +792,7 @@ union cvmx_gpio_intrx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
-                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(5). */
+                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
 #else
 	uint64_t intr                         : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 92d23ce..a95e311 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -504,6 +504,17 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long block_id)
 #define CVMX_GSERX_EQ_WAIT_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((block_id) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_PLL_MONITOR(block_id) (CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((block_id) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long block_id)
 {
 	if (!(
@@ -647,6 +658,17 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned
 #define CVMX_GSERX_LANEX_PWR_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL_P2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL_P2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904600B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PWR_CTRL_P2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904600B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -680,6 +702,61 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsig
 #define CVMX_GSERX_LANEX_RX_AEQ_OUT_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440038ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CDR_CTRL_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440038ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440040ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CDR_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440040ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440208ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440208ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CDR_STATUS_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CDR_STATUS_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -790,6 +867,17 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, un
 #define CVMX_GSERX_LANEX_RX_PRECORR_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_VAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440078ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_PRECORR_VAL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440078ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -2886,6 +2974,39 @@ union cvmx_gserx_eq_wait_time {
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
 
 /**
+ * cvmx_gser#_glbl_pll_monitor
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_pll_monitor {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_pll_monitor_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t sds_pcs_glbl_status          : 6;  /**< Spare reserved for future use. Read data should be ignored. */
+	uint64_t sds_pcs_pll_lock             : 1;  /**< Status signal from Global indicates that PLL is locked. Not a true "lock" signal.
+                                                         Used to debug/test the PLL. */
+	uint64_t sds_pcs_clock_ready          : 1;  /**< Clock status signal, can be overriden with (I_PLL_CTRL_EN == 1).
+                                                         0 = Clock not ready.
+                                                         1 = Clock ready. */
+	uint64_t sds_pcs_pll_calstates        : 5;  /**< PLL calibration code. */
+	uint64_t sds_pcs_pll_caldone          : 1;  /**< PLL calibration done signal. */
+#else
+	uint64_t sds_pcs_pll_caldone          : 1;
+	uint64_t sds_pcs_pll_calstates        : 5;
+	uint64_t sds_pcs_clock_ready          : 1;
+	uint64_t sds_pcs_pll_lock             : 1;
+	uint64_t sds_pcs_glbl_status          : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_pll_monitor_s  cn78xx;
+};
+typedef union cvmx_gserx_glbl_pll_monitor cvmx_gserx_glbl_pll_monitor_t;
+
+/**
  * cvmx_gser#_glbl_tad
  *
  * These registers are for diagnostic use only.
@@ -3464,6 +3585,53 @@ union cvmx_gserx_lanex_pwr_ctrl {
 typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
 
 /**
+ * cvmx_gser#_lane#_pwr_ctrl_p2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_pwr_ctrl_p2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_pwr_ctrl_p2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t p2_rx_resetn                 : 1;  /**< Place the reciever in reset (active low). */
+	uint64_t p2_rx_allow_pll_pd           : 1;  /**< When asserted, it permits PLL powerdown (PLL is
+                                                         powered down if all other factors permit). */
+	uint64_t p2_rx_pcs_reset              : 1;  /**< When asserted, the RX Power state machine puts the Raw PCS
+                                                         RX logic in reset state to save power. */
+	uint64_t p2_rx_agc_en                 : 1;  /**< AGC enable. */
+	uint64_t p2_rx_dfe_en                 : 1;  /**< DFE enable. */
+	uint64_t p2_rx_cdr_en                 : 1;  /**< CDR enable. */
+	uint64_t p2_rx_cdr_coast              : 1;  /**< CDR coast; freezes the frequency of the CDR. */
+	uint64_t p2_rx_cdr_clr                : 1;  /**< CDR clear; clears the frequency register in the CDR. */
+	uint64_t p2_rx_subblk_pd              : 5;  /**< RX sub-block powerdown to RX:
+                                                         <4> = CTLE.
+                                                         <3> = Reserved.
+                                                         <2> = Lane DLL.
+                                                         <1> = DFE/Samplers.
+                                                         <0> = Termination. */
+	uint64_t p2_rx_chpd                   : 1;  /**< RX lane power down. */
+#else
+	uint64_t p2_rx_chpd                   : 1;
+	uint64_t p2_rx_subblk_pd              : 5;
+	uint64_t p2_rx_cdr_clr                : 1;
+	uint64_t p2_rx_cdr_coast              : 1;
+	uint64_t p2_rx_cdr_en                 : 1;
+	uint64_t p2_rx_dfe_en                 : 1;
+	uint64_t p2_rx_agc_en                 : 1;
+	uint64_t p2_rx_pcs_reset              : 1;
+	uint64_t p2_rx_allow_pll_pd           : 1;
+	uint64_t p2_rx_resetn                 : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_pwr_ctrl_p2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_pwr_ctrl_p2 cvmx_gserx_lanex_pwr_ctrl_p2_t;
+
+/**
  * cvmx_gser#_lane#_rx_aeq_out_0
  *
  * These registers are for diagnostic use only.
@@ -3535,6 +3703,137 @@ union cvmx_gserx_lanex_rx_aeq_out_2 {
 typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
 
 /**
+ * cvmx_gser#_lane#_rx_cdr_ctrl_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cdr_ctrl_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t cfg_rx_cdr_ctrl_ovrrd_val    : 16; /**< Set CFG_RX_CDR_CTRL_OVRRD_EN in register
+                                                         GSER()_LANE()_RX_MISC_OVRRD to override pcs_sds_rx_cdr_ctrl.
+                                                         <15:13> = CDR frequency gain.
+                                                         <12>    = Frequency accumulator manual enable.
+                                                         <11:5>  = Frequency accumulator manual value.
+                                                         <4>     = CDR phase offset override enable.
+                                                         <3:0>   = CDR phase offset override, DLL IQ. */
+#else
+	uint64_t cfg_rx_cdr_ctrl_ovrrd_val    : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cdr_ctrl_1 cvmx_gserx_lanex_rx_cdr_ctrl_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cdr_ctrl_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cdr_ctrl_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t cfg_rx_cdr_ctrl_ovrrd_val    : 16; /**< Set CFG_RX_CDR_CTRL_OVRRD_EN in register
+                                                         GSER()_LANE()_RX_MISC_OVRRD to override pcs_sds_rx_cdr_ctrl.
+                                                         <15>   = Shadow PI phase enable.
+                                                         <14:8> = Shadow PI phase value.
+                                                         <7>    = CDR manual phase enable.
+                                                         <6:0>  = CDR manual phase value. */
+#else
+	uint64_t cfg_rx_cdr_ctrl_ovrrd_val    : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cdr_ctrl_2 cvmx_gserx_lanex_rx_cdr_ctrl_2_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cdr_misc_ctrl_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t pcs_sds_rx_cdr_misc_ctrl     : 8;  /**< Per lane RX miscellaneous CDR control:
+                                                         <7> = RT-Eyemon counter enable, will start counting 5.4e9 bits.
+                                                         <6> = RT-Eyemon shadow PI control enable.
+                                                         <5:4> = RT-Eyemon error counter byte selection observable on
+                                                                 SDS_OCS_RX_CDR_STATUS[14:7] in register GSER_LANE_RX_CDR_STATUS_1.
+                                                         <3:0> = LBW adjustment thresholds. */
+#else
+	uint64_t pcs_sds_rx_cdr_misc_ctrl     : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cdr_status_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cdr_status_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t sds_pcs_rx_cdr_status        : 15; /**< Per lane RX CDR status:
+                                                         <14:7> = RT-Eyemon error counter.
+                                                         <6:4>  = LBW adjustment value.
+                                                         <3:0>  = LBW adjustment state. */
+#else
+	uint64_t sds_pcs_rx_cdr_status        : 15;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cdr_status_1 cvmx_gserx_lanex_rx_cdr_status_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cdr_status_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cdr_status_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t sds_pcs_rx_cdr_status        : 14; /**< CDR status.
+                                                         <13:7> = CDR phase control output.
+                                                         <6:0> = CDR frequency accumulator output. */
+#else
+	uint64_t sds_pcs_rx_cdr_status        : 14;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cdr_status_2 cvmx_gserx_lanex_rx_cdr_status_2_t;
+
+/**
  * cvmx_gser#_lane#_rx_cfg_0
  *
  * These registers are for diagnostic use only.
@@ -3939,6 +4238,31 @@ union cvmx_gserx_lanex_rx_precorr_ctrl {
 typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_t;
 
 /**
+ * cvmx_gser#_lane#_rx_precorr_val
+ *
+ * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
+ * diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_precorr_val {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_precorr_val_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t sds_pcs_rx_precorr_vld       : 1;  /**< RX pre-correlation count is valid. */
+	uint64_t sds_pcs_rx_precorr_cnt       : 12; /**< RX pre-correlation count. */
+#else
+	uint64_t sds_pcs_rx_precorr_cnt       : 12;
+	uint64_t sds_pcs_rx_precorr_vld       : 1;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_precorr_val_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_precorr_val cvmx_gserx_lanex_rx_precorr_val_t;
+
+/**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_0
  *
  * These registers are reset by hardware only during chip cold reset. The values of the CSR
@@ -6048,13 +6372,17 @@ union cvmx_gserx_pll_px_mode_0 {
 	uint64_t pll_pcs_div                  : 9;  /**< The divider that generates PCS_MAC_TX_CLK. The frequency of the clock is (pll_frequency /
                                                          PLL_PCS_DIV).
                                                          Recommended settings:
-                                                         _ 1.25G:    0x28
-                                                         _ 2.5G:     0x5
-                                                         _ 3.125G:   0x14
-                                                         _ 5.0G:     0xA
-                                                         _ 6.25G:    0xA
-                                                         _ 8.0G:     0xA
-                                                         _ 10.3125G: 0xA */
+                                                         <pre>
+                                                                     PCIE   Other
+                                                         _ 1.25G:     NS     0x28
+                                                         _ 2.5G:      0x5    0x5
+                                                         _ 3.125G:    NS     0x14
+                                                         _ 5.0G:      0x5    0xA
+                                                         _ 6.25G:     NS     0xA
+                                                         _ 8.0G:      0x8    0xA
+                                                         _ 10.3125G:  NS     0xA
+                                                         </pre>
+                                                         A 'NS' indicates that the rate is not supported at the specified reference clock. */
 #else
 	uint64_t pll_pcs_div                  : 9;
 	uint64_t pll_rloop                    : 3;
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 164c268..022efe4 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -163,6 +163,17 @@ static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 #define CVMX_IOBN_INT_SUM (CVMX_ADD_IO_SEG(0x00011800F0000020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_IOBN_NCBX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800F0004000ull) + ((offset) & 3) * 8;
+}
+#else
+#define CVMX_IOBN_NCBX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800F0004000ull) + ((offset) & 3) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_IOBN_PP_BIST_STATUS CVMX_IOBN_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 {
@@ -771,6 +782,39 @@ union cvmx_iobn_int_sum {
 typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
 
 /**
+ * cvmx_iobn_ncb#_ctl
+ *
+ * This register controls the type of store operation used for full cache blocks stores.
+ * Added in pass 2.
+ */
+union cvmx_iobn_ncbx_ctl {
+	uint64_t u64;
+	struct cvmx_iobn_ncbx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t stp                          : 2;  /**< When a complete cache block is written a STP will be converted to:
+                                                         0x0 = STF.
+                                                         0x1 = STY.
+                                                         0x2 = STT.
+                                                         0x3 = Reserved. */
+	uint64_t reserved_2_7                 : 6;
+	uint64_t rstp                         : 2;  /**< When a complete cache block is written a RSTP will be converted to:
+                                                         0x0 = STY.
+                                                         0x1 = STT.
+                                                         0x2 = STF.
+                                                         0x3 = Reserved. */
+#else
+	uint64_t rstp                         : 2;
+	uint64_t reserved_2_7                 : 6;
+	uint64_t stp                          : 2;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_iobn_ncbx_ctl_s           cn78xx;
+};
+typedef union cvmx_iobn_ncbx_ctl cvmx_iobn_ncbx_ctl_t;
+
+/**
  * cvmx_iobn_pp_bist_status
  *
  * This register contains the result of the BIST run on the cores.
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 05102f8..1ef42c6 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -2547,7 +2547,7 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t iorddisoci                   : 1;  /**< Reserved. */
 	uint64_t iowrdisoci                   : 1;  /**< Reserved. */
 	uint64_t reserved_59_61               : 3;
-	uint64_t cmd                          : 7;  /**< Encoding of XMC command.  INTERNAL: Enumerated with XMC_CMD_E. */
+	uint64_t cmd                          : 7;  /**< Encoding of XMC command.  INTERNAL: Enumerated by XMC_CMD_E. */
 	uint64_t ppvid                        : 6;  /**< CMB source PPVID. */
 	uint64_t node                         : 2;  /**< Destination node ID. */
 	uint64_t did                          : 8;  /**< Destination device ID. */
@@ -3195,17 +3195,15 @@ typedef union cvmx_l2c_cfg cvmx_l2c_cfg_t;
  *
  * Provides the address of the COP0 register to read/write when L2C_COP0_DAT is accessed.
  *
- * NOTE: for 78xx, if the PPID is outside the range of 0-47,255 the write will be ignored and
- * reads will return 0x2bad2bad2bad2bad
- *
  * 1. RD and SEL are as defined in the description of Core Coprocessor 0 registers.
  *
- * 2. If a COP0 register cannot be accessed by this mechanism the write be silently ignored and
- * the read data will be 0x2bad2bad2bad2bad. Otherwise, if the COP0 register doesn't exist,
- * the read data value will be 0x000000000BADDEED.
+ * 2. If the PPID is outside the range of valid cores, and not 255 (broadcast), or if
+ * the core in question is in reset a write will be ignored and reads will timeout the
+ * RSL bus.
  *
- * 3. If the PPID is outside the range of 0-47,255 or if the core in question is in reset
- * a write will be ignored and reads will timeout the RSL bus.
+ * 3. If a COP0 register cannot be accessed by this mechanism the write be silently
+ * ignored and the read data will be 0x2bad2bad2bad2bad. Otherwise, if the COP0
+ * register doesn't exist, the read data value will be 0x000000000baddeed.
  *
  * INTERNAL: In HRM, see table in L2C chapter body text.
  * Referring to note 1 above, the following root/rd/sel values are supported:
@@ -8060,7 +8058,7 @@ typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
 /**
  * cvmx_l2c_tad_ctl
  *
- * On CN78XX, MAXLFB, EXLRQ, EXRRQ, EXFWD, EXVIC refer to half-TAD LFBs/VABs. Therefore, even
+ * In CNXXXX, MAXLFB, EXLRQ, EXRRQ, EXFWD, EXVIC refer to half-TAD LFBs/VABs. Therefore, even
  * though there are 24 LFBs/VABs in a full TAD, the number applies to both halves.
  * * If MAXLFB is written to 0 or 13-15 operation is undefined. (CN78XX pass 1.0).
  * * If MAXLFB is != 0, VBF_THRESH should be less than MAXLFB.
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 6396113..a86010c 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -2355,7 +2355,7 @@ union cvmx_lmcx_comp_ctl2 {
                                                            0x0 = Reserved.
                                                            0x1 = Reserved.
                                                            0x2 = 26 ohm.
-                                                         0x3 = 30 ohm.
+                                                           0x3 = 30 ohm.
                                                            0x4 = 34 ohm.
                                                            0x5 = 40 ohm.
                                                            0x6 = 48 ohm.
@@ -2374,7 +2374,7 @@ union cvmx_lmcx_comp_ctl2 {
                                                            0x0 = Reserved.
                                                            0x1 = Reserved.
                                                            0x2 = 26 ohm.
-                                                         0x3 = 30 ohm.
+                                                           0x3 = 30 ohm.
                                                            0x4 = 34 ohm.
                                                            0x5 = 40 ohm.
                                                            0x6 = 48 ohm.
@@ -2394,7 +2394,7 @@ union cvmx_lmcx_comp_ctl2 {
                                                            0x0 = Reserved.
                                                            0x1 = Reserved.
                                                            0x2 = 26 ohm.
-                                                         0x3 = 30 ohm.
+                                                           0x3 = 30 ohm.
                                                            0x4 = 34 ohm.
                                                            0x5 = 40 ohm.
                                                            0x6 = 48 ohm.
@@ -6856,7 +6856,7 @@ typedef union cvmx_lmcx_ifb_cnt_lo cvmx_lmcx_ifb_cnt_lo_t;
 /**
  * cvmx_lmc#_int
  *
- * LMC_INT = LMC Interrupt Register
+ * This register contains the different interrupt-summary bits of the LMC.
  *
  */
 union cvmx_lmcx_int {
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 6b6dc06..74f8e9e 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -378,6 +378,17 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT (CVMX_ADD_IO_SEG(0x0001180000000190ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MIO_EMM_DMA_INT_W1S CVMX_MIO_EMM_DMA_INT_W1S_FUNC()
+static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_MIO_EMM_DMA_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180000000198ull);
+}
+#else
+#define CVMX_MIO_EMM_DMA_INT_W1S (CVMX_ADD_IO_SEG(0x0001180000000198ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_MIO_EMM_INT CVMX_MIO_EMM_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_FUNC(void)
 {
@@ -2243,7 +2254,16 @@ union cvmx_mio_boot_bist_stat {
 	struct cvmx_mio_boot_bist_stat_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t stat                         : 8;  /**< BIST status. */
+	uint64_t stat                         : 8;  /**< BIST status.
+                                                         INTERNAL:
+                                                           <0> = mio.mio_boot.boot_fifo.mem.
+                                                           <1> = mio.mio_boot.mio_boot_emm.mem.
+                                                           <2> = mio.mio_boot.mio_boot_mem2.mem.
+                                                           <3> = mio.mio_boot.boot_loc.mem.
+                                                           <4> = mio.mio_boot.dma_fifo.mem.
+                                                           <5> = mio.mio_nbt.mio_nbt_fifo.mem.
+                                                           <6> = mio.mio_emm.bufs.mem.mem.
+                                                           <7> = mio_boot_rom/mio_boot_rom1 (bootroms). */
 #else
 	uint64_t stat                         : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3808,6 +3828,29 @@ union cvmx_mio_emm_dma_int {
 typedef union cvmx_mio_emm_dma_int cvmx_mio_emm_dma_int_t;
 
 /**
+ * cvmx_mio_emm_dma_int_w1s
+ */
+union cvmx_mio_emm_dma_int_w1s {
+	uint64_t u64;
+	struct cvmx_mio_emm_dma_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t fifo                         : 1;  /**< INIERNAL Set as reserved in HRM
+                                                         Internal DMA FIFO has dropped to level specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL]. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_DMA_FIFO. */
+	uint64_t done                         : 1;  /**< Internal DMA engine request completion interrupt. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_DMA_DONE. */
+#else
+	uint64_t done                         : 1;
+	uint64_t fifo                         : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mio_emm_dma_int_w1s_s     cn78xx;
+};
+typedef union cvmx_mio_emm_dma_int_w1s cvmx_mio_emm_dma_int_w1s_t;
+
+/**
  * cvmx_mio_emm_int
  *
  * MIO_EMM_INT = MIO EMMC Interrupt Register
@@ -4353,7 +4396,30 @@ union cvmx_mio_emm_wdog {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
 	uint64_t clk_cnt                      : 26; /**< Number of CLK_CNT cycles to wait for the card to return a
-                                                         response, read data, or the 3-bit CRC status token. */
+                                                         response, read data, or the 3-bit CRC status token following
+                                                         write data.  The following timeouts are detected:
+
+                                                         1.  Expected response to a command doesn't occur
+                                                             causing MIO_EMM_RSP_STS[RSP_TIMEOUT]
+                                                         2.  On a read command, expected data isn't returned
+                                                             causing MIO_EMM_RSP_STS[BLK_TIMEOUT]
+                                                         3.  On a multi read command, expected data isn't returned
+                                                             causing MIO_EMM_RSP_STS[BLK_TIMEOUT]
+                                                         4.  On a write command, expected token to a write block isn't
+                                                             received causing MIO_EMM_RSP_STS[BLK_TIMEOUT]
+                                                         5.  If a stop command is issued by the hardware and no
+                                                             response is returned causing MIO_EMM_RSP_STS[STP_TIMEOUT]
+
+                                                         Issues this timeout doesn't cover are stalls induced by the
+                                                         card which are not limited by the specifications.
+                                                         For example, when a write multi command is issued to the card
+                                                         and a block (not the last) is transferred the card can "stall"
+                                                         the Octeon by forcing emmc_data<0> low for as long as it wants
+                                                         to free up buffer space.  The second case is when the last
+                                                         block of a write or multi write is being transferred and the
+                                                         card elects to perform some background tasks.  The same stall
+                                                         mechanism with emmc_data<0> is used but this can last for an
+                                                         extend time period. */
 #else
 	uint64_t clk_cnt                      : 26;
 	uint64_t reserved_26_63               : 38;
@@ -8957,8 +9023,12 @@ union cvmx_mio_twsx_int {
 	uint64_t reserved_12_63               : 52;
 	uint64_t scl                          : 1;  /**< SCL signal. */
 	uint64_t sda                          : 1;  /**< SDA signal. */
-	uint64_t scl_ovr                      : 1;  /**< SCL override. */
-	uint64_t sda_ovr                      : 1;  /**< SDA override. */
+	uint64_t scl_ovr                      : 1;  /**< SCL testing override:
+                                                         0 = Normal operation, SCL bus controlled by TWSI core.
+                                                         1 = Pull SCL low. */
+	uint64_t sda_ovr                      : 1;  /**< SDA testing override:
+                                                         0 = Normal operation, SDA bus controlled by TWSI core.
+                                                         1 = Pull SDA low. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t core_int                     : 1;  /**< TWSI core interrupt. Ignored when the HLC is enabled. Throws
                                                          TWS_INTSN_E::MIO_TWS()_INT_CORE. */
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 4f270cd..2555c91 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -649,7 +649,9 @@ union cvmx_oclax_fifo_wrap {
 	struct cvmx_oclax_fifo_wrap_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t wraps                        : 32; /**< Number of times FIFO has wrapped since trigger. Cleared when OCLA()_STATE_INT[TRIG] clear. */
+	uint64_t wraps                        : 32; /**< Number of times FIFO has wrapped since trigger.
+                                                         Cleared when OCLA()_STATE_INT[TRIG] is clear.
+                                                         This count has a one cycle lag observing when a trigger event occurs. */
 #else
 	uint64_t wraps                        : 32;
 	uint64_t reserved_32_63               : 32;
@@ -664,7 +666,7 @@ typedef union cvmx_oclax_fifo_wrap cvmx_oclax_fifo_wrap_t;
 /**
  * cvmx_ocla#_fsm#_and#_i#
  *
- * Values for PLA-AND plane. AND(0..15) represents the 15 allowed AND terms. I(0..1) for I=0
+ * Values for PLA-AND plane. AND(0..15) represents the 16 allowed AND terms. I(0..1) for I=0
  * indicates the term non-inverted, for I=1 indicates the term inverted. Any AND tree may be
  * disabled by setting the same bit in both _I(0) and _I(1), as '((1) & !(1))' is always false.
  */
@@ -672,17 +674,19 @@ union cvmx_oclax_fsmx_andx_ix {
 	uint64_t u64;
 	struct cvmx_oclax_fsmx_andx_ix_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
-	uint64_t mcd                          : 3;  /**< Multichip debug (MCD) 0..2 inputs. */
-	uint64_t match                        : 4;  /**< Matcher 0..3 input. */
-	uint64_t fsm1_state                   : 4;  /**< FSM 1 last state. */
-	uint64_t fsm0_state                   : 4;  /**< FSM 0 last state. */
+	uint64_t reserved_16_63               : 48;
+	uint64_t trig                         : 1;  /**< Reserved. */
+	uint64_t mcd                          : 3;  /**< AND plane control for multichip debug (MCD) 0..2 FSM inputs. */
+	uint64_t match                        : 4;  /**< AND plane control for matcher 0..3 FSM inputs. */
+	uint64_t fsm1_state                   : 4;  /**< AND plane control for FSM 1 last state input. */
+	uint64_t fsm0_state                   : 4;  /**< AND plane control for FSM 0 last state input. */
 #else
 	uint64_t fsm0_state                   : 4;
 	uint64_t fsm1_state                   : 4;
 	uint64_t match                        : 4;
 	uint64_t mcd                          : 3;
-	uint64_t reserved_15_63               : 49;
+	uint64_t trig                         : 1;
+	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xx;
@@ -730,9 +734,7 @@ union cvmx_oclax_fsmx_statex {
 	struct cvmx_oclax_fsmx_statex_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_31_63               : 33;
-	uint64_t sinfo_set                    : 1;  /**< If a control packet is generated in this state (due to capture starting
-                                                         in the next cycle), set OCLA_CAP_CTL_S[SINFO].
-                                                         Added in pass 2. */
+	uint64_t sinfo_set                    : 1;  /**< Reserved. */
 	uint64_t set_int                      : 1;  /**< In this state set interrupt. */
 	uint64_t cap                          : 1;  /**< In this state request capture this cycle. */
 	uint64_t set_mcd                      : 3;  /**< In this state set MCD. */
@@ -760,35 +762,8 @@ union cvmx_oclax_fsmx_statex {
 #endif
 	} s;
 	struct cvmx_oclax_fsmx_statex_s       cn70xx;
-	struct cvmx_oclax_fsmx_statex_cn70xxp1 {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_30_63               : 34;
-	uint64_t set_int                      : 1;  /**< In this state set interrupt. */
-	uint64_t cap                          : 1;  /**< In this state request capture this cycle. */
-	uint64_t set_mcd                      : 3;  /**< In this state set MCD. */
-	uint64_t set_trig                     : 1;  /**< In this state set internal trigger indication. */
-	uint64_t reserved_20_23               : 4;
-	uint64_t set_val                      : 4;  /**< In this state store match value into matcher 0..3. */
-	uint64_t reserved_12_15               : 4;
-	uint64_t clr_cnt                      : 4;  /**< In this state clear match counter. */
-	uint64_t reserved_4_7                 : 4;
-	uint64_t inc_cnt                      : 4;  /**< In this state increment match counter. See State Outputs for more information on this or
-                                                         any of the bits above. */
-#else
-	uint64_t inc_cnt                      : 4;
-	uint64_t reserved_4_7                 : 4;
-	uint64_t clr_cnt                      : 4;
-	uint64_t reserved_12_15               : 4;
-	uint64_t set_val                      : 4;
-	uint64_t reserved_20_23               : 4;
-	uint64_t set_trig                     : 1;
-	uint64_t set_mcd                      : 3;
-	uint64_t cap                          : 1;
-	uint64_t set_int                      : 1;
-	uint64_t reserved_30_63               : 34;
-#endif
-	} cn70xxp1;
-	struct cvmx_oclax_fsmx_statex_cn70xxp1 cn78xx;
+	struct cvmx_oclax_fsmx_statex_s       cn70xxp1;
+	struct cvmx_oclax_fsmx_statex_s       cn78xx;
 };
 typedef union cvmx_oclax_fsmx_statex cvmx_oclax_fsmx_statex_t;
 
@@ -799,12 +774,13 @@ union cvmx_oclax_gen_ctl {
 	uint64_t u64;
 	struct cvmx_oclax_gen_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_7_63                : 57;
+	uint64_t mcdtrig                      : 3;  /**< Reserved. */
 	uint64_t exten                        : 1;  /**< Enable external triggering.
                                                          0 = External triggering ignored.
                                                          1 = When the external trigger pin selected with GPIO_OCLA_EXTEN_TRIG is high it will cause
                                                          triggerring and set OCLA()_STATE_SET[TRIG]. The external device must de-assert the
-                                                         signal to release the trigger (it is not edge sensitive.) */
+                                                         signal (it is not edge sensitive.) */
 	uint64_t den                          : 1;  /**< Enable data bus and counter clocking. When set, the OCLA inbound data bus may be used and
                                                          counters may increment. When clear, the bus is always zero and internal flops may be clock
                                                          gated off to save power. Must be set for normal operation. */
@@ -815,7 +791,8 @@ union cvmx_oclax_gen_ctl {
 	uint64_t stt                          : 1;
 	uint64_t den                          : 1;
 	uint64_t exten                        : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t mcdtrig                      : 3;
+	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
 	struct cvmx_oclax_gen_ctl_s           cn70xx;
@@ -1237,17 +1214,23 @@ union cvmx_oclax_time {
 	uint64_t u64;
 	struct cvmx_oclax_time_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
-	uint64_t cycle                        : 32; /**< Current time as free running counter. Loaded into captured control packets.
+	uint64_t cycle                        : 64; /**< Current time as free running counter. Loaded into captured control packets.
                                                          Unconditionally clocked, independent of OCLA()_SFT_RST. */
 #else
-	uint64_t cycle                        : 32;
-	uint64_t reserved_32_63               : 32;
+	uint64_t cycle                        : 64;
 #endif
 	} s;
 	struct cvmx_oclax_time_s              cn70xx;
-	struct cvmx_oclax_time_s              cn70xxp1;
-	struct cvmx_oclax_time_s              cn78xx;
+	struct cvmx_oclax_time_cn70xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t cycle                        : 32; /**< Current time as free running counter. Loaded into captured control packets. */
+#else
+	uint64_t cycle                        : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} cn70xxp1;
+	struct cvmx_oclax_time_cn70xxp1       cn78xx;
 };
 typedef union cvmx_oclax_time cvmx_oclax_time_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 6552bf6..5d38c4b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -701,8 +701,8 @@ union cvmx_pcieepvfx_cfg000 {
 	uint32_t u32;
 	struct cvmx_pcieepvfx_cfg000_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t devid                        : 16; /**< Device ID. */
-	uint32_t vendid                       : 16; /**< Vendor ID. */
+	uint32_t devid                        : 16; /**< Device ID. For SR-IOV VFs always 0xFFFF. */
+	uint32_t vendid                       : 16; /**< Vendor ID. For SR-IOV VFs always 0xFFFF. */
 #else
 	uint32_t vendid                       : 16;
 	uint32_t devid                        : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 0e00f8b..92883f8 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -949,16 +949,7 @@ union cvmx_pemx_bist_status {
 	uint64_t rqhdrb1                      : 1;  /**< Rx queue header memory buffer 1. */
 	uint64_t rqdatab0                     : 1;  /**< Rx queue data buffer 0. */
 	uint64_t rqdatab1                     : 1;  /**< Rx queue data buffer 1. */
-	uint64_t tlpan_d0                     : 1;  /**< BIST Status for the tlp_n_afifo_data0. */
-	uint64_t tlpan_d1                     : 1;  /**< BIST Status for the tlp_n_afifo_data1. */
-	uint64_t tlpan_ctl                    : 1;  /**< BIST Status for the tlp_n_afifo_ctl. */
-	uint64_t tlpap_d0                     : 1;  /**< BIST Status for the tlp_p_afifo_data0. */
-	uint64_t tlpap_d1                     : 1;  /**< BIST Status for the tlp_p_afifo_data1. */
-	uint64_t tlpap_ctl                    : 1;  /**< BIST Status for the tlp_p_afifo_ctl. */
-	uint64_t tlpac_d0                     : 1;  /**< BIST Status for the tlp_c_afifo_data0. */
-	uint64_t tlpac_d1                     : 1;  /**< BIST Status for the tlp_c_afifo_data1. */
-	uint64_t tlpac_ctl                    : 1;  /**< BIST Status for the tlp_c_afifo_ctl. */
-	uint64_t peai_p2e                     : 1;  /**< BIST Status for the peai__pesc_fifo. */
+	uint64_t reserved_10_19               : 10;
 	uint64_t tlpn_d0                      : 1;  /**< BIST Status for the tlp_n_fifo_data0. */
 	uint64_t tlpn_d1                      : 1;  /**< BIST Status for the tlp_n_fifo_data1. */
 	uint64_t reserved_0_7                 : 8;
@@ -966,16 +957,7 @@ union cvmx_pemx_bist_status {
 	uint64_t reserved_0_7                 : 8;
 	uint64_t tlpn_d1                      : 1;
 	uint64_t tlpn_d0                      : 1;
-	uint64_t peai_p2e                     : 1;
-	uint64_t tlpac_ctl                    : 1;
-	uint64_t tlpac_d1                     : 1;
-	uint64_t tlpac_d0                     : 1;
-	uint64_t tlpap_ctl                    : 1;
-	uint64_t tlpap_d1                     : 1;
-	uint64_t tlpap_d0                     : 1;
-	uint64_t tlpan_ctl                    : 1;
-	uint64_t tlpan_d1                     : 1;
-	uint64_t tlpan_d0                     : 1;
+	uint64_t reserved_10_19               : 10;
 	uint64_t rqdatab1                     : 1;
 	uint64_t rqdatab0                     : 1;
 	uint64_t rqhdrb1                      : 1;
@@ -1042,16 +1024,7 @@ union cvmx_pemx_bist_status {
 	uint64_t rqhdrb1                      : 1;  /**< Rx queue header memory buffer 1. */
 	uint64_t rqdatab0                     : 1;  /**< Rx queue data buffer 0. */
 	uint64_t rqdatab1                     : 1;  /**< Rx queue data buffer 1. */
-	uint64_t tlpan_d0                     : 1;  /**< BIST Status for the tlp_n_afifo_data0. */
-	uint64_t tlpan_d1                     : 1;  /**< BIST Status for the tlp_n_afifo_data1. */
-	uint64_t tlpan_ctl                    : 1;  /**< BIST Status for the tlp_n_afifo_ctl. */
-	uint64_t tlpap_d0                     : 1;  /**< BIST Status for the tlp_p_afifo_data0. */
-	uint64_t tlpap_d1                     : 1;  /**< BIST Status for the tlp_p_afifo_data1. */
-	uint64_t tlpap_ctl                    : 1;  /**< BIST Status for the tlp_p_afifo_ctl. */
-	uint64_t tlpac_d0                     : 1;  /**< BIST Status for the tlp_c_afifo_data0. */
-	uint64_t tlpac_d1                     : 1;  /**< BIST Status for the tlp_c_afifo_data1. */
-	uint64_t tlpac_ctl                    : 1;  /**< BIST Status for the tlp_c_afifo_ctl. */
-	uint64_t peai_p2e                     : 1;  /**< BIST Status for the peai__pesc_fifo. */
+	uint64_t reserved_10_19               : 10;
 	uint64_t tlpn_d0                      : 1;  /**< BIST Status for the tlp_n_fifo_data0. */
 	uint64_t tlpn_d1                      : 1;  /**< BIST Status for the tlp_n_fifo_data1. */
 	uint64_t tlpn_ctl                     : 1;  /**< BIST Status for the tlp_n_fifo_ctl. */
@@ -1073,16 +1046,7 @@ union cvmx_pemx_bist_status {
 	uint64_t tlpn_ctl                     : 1;
 	uint64_t tlpn_d1                      : 1;
 	uint64_t tlpn_d0                      : 1;
-	uint64_t peai_p2e                     : 1;
-	uint64_t tlpac_ctl                    : 1;
-	uint64_t tlpac_d1                     : 1;
-	uint64_t tlpac_d0                     : 1;
-	uint64_t tlpap_ctl                    : 1;
-	uint64_t tlpap_d1                     : 1;
-	uint64_t tlpap_d0                     : 1;
-	uint64_t tlpan_ctl                    : 1;
-	uint64_t tlpan_d1                     : 1;
-	uint64_t tlpan_d0                     : 1;
+	uint64_t reserved_10_19               : 10;
 	uint64_t rqdatab1                     : 1;
 	uint64_t rqdatab0                     : 1;
 	uint64_t rqhdrb1                      : 1;
@@ -3369,70 +3333,17 @@ union cvmx_pemx_tlp_credits {
 	uint64_t pem_np                       : 8;  /**< TLP 16B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x8. */
 	uint64_t pem_p                        : 8;  /**< TLP 16B credits for posted TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t sli_cpl                      : 8;  /**< TLP 8B credits for completion TLPs in the SLI. Legal values are 0x24 to
-                                                         0xFF. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
+                                                         0x80. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. The
-                                                         reset value for this register assumes the minimum (e.g. 4-lane)
-                                                         configuration. This ensures that for configurations where the total number of
-                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
-                                                         oversubscribe the SLI.
-                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
-                                                         software may safely reprogram this register (i.e. increase the value) to achieve
-                                                         optimal performance.  See the following table of example configurations of PEM
-                                                         pairs for recommended credit values.
-                                                         <pre>
-                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
-                                                            --------------------------------------------
-                                                            1 8-ln PEM     n    8             0xFF
-                                                            2 4-ln PEMs    n    4             0x80
-                                                                          n+1   4             0x80
-                                                            1 4-ln PEM     n    4             0xFF
-                                                            1 8-ln PEM,    n    8             0xAA
-                                                            1 4-ln PEM    n+1   4             0x55
-                                                         </pre> */
+                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. */
 	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x4 to
                                                          0x20. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. The
-                                                         reset value for this register assumes the minimum (e.g. 4-lane)
-                                                         configuration. This ensures that for configurations where the total number of
-                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
-                                                         oversubscribe the SLI.
-                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
-                                                         software may safely reprogram this register (i.e. increase the value) to achieve
-                                                         optimal performance.  See the following table of example configurations of PEM
-                                                         pairs for recommended credit values.
-                                                         <pre>
-                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
-                                                            --------------------------------------------
-                                                            1 8-ln PEM     n    8             0x20
-                                                            2 4-ln PEMs    n    4             0x10
-                                                                          n+1   4             0x10
-                                                            1 4-ln PEM     n    4             0x20
-                                                            1 8-ln PEM,    n    8             0x15
-                                                            1 4-ln PEM    n+1   4             0x0B
-                                                         </pre> */
+                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. */
 	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0xFF. Pairs
                                                          of PEMs share a single SLI interface. PEM(0) and PEM(1) share one SLI interface,
                                                          while PEM(2) and PEM(3) share the other. When both PEMs of a pair are
-                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. The reset
-                                                         value for this register assumes the minimum (e.g. 4-lane) configuration. This
-                                                         ensures that for configurations where the total number of lanes for a pair of
-                                                         PEMs exceeds 8, the total allocated credits does not oversubscribe the SLI.
-                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
-                                                         software may safely reprogram this register (i.e. increase the value) to achieve
-                                                         optimal performance.  See the following table of example configurations of PEM
-                                                         pairs for recommended credit values.
-                                                         <pre>
-                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
-                                                            --------------------------------------------
-                                                            1 8-ln PEM     n    8             0xFF
-                                                            2 4-ln PEMs    n    4             0x80
-                                                                          n+1   4             0x80
-                                                            1 4-ln PEM     n    4             0xFF
-                                                            1 8-ln PEM,    n    8             0xAA
-                                                            1 4-ln PEM    n+1   4             0x55
-                                                         </pre> */
+                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. */
 #else
 	uint64_t sli_p                        : 8;
 	uint64_t sli_np                       : 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 3fe2b82..0a6bc39 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1288,7 +1288,7 @@ union cvmx_pki_buf_ctl {
                                                          RE_MEMOUT.
                                                          1 = Wait until buffers become available, only dropping packets if buffering ahead of PKI
                                                          fills. This may lead to head-of-line blocking of packets on other Auras. */
-	uint64_t fpa_cac_dis                  : 1;  /**< When set, disable caching any FPA buffers, and immediately return any cached buffers to the FPA. */
+	uint64_t fpa_cac_dis                  : 1;  /**< Reserved. */
 	uint64_t reserved_6_8                 : 3;
 	uint64_t pkt_off                      : 1;  /**< Packet buffer off. When this bit is set to 1, the PKI does not buffer the received packet
                                                          data; when it is clear to 0, the PKI works normally, buffering the received packet data. */
@@ -1429,11 +1429,7 @@ union cvmx_pki_clx_int {
 	uint64_t u64;
 	struct cvmx_pki_clx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_5_63                : 59;
-	uint64_t trapz                        : 1;  /**< Reserved. INTERNAL: Deprecated. PCAM sequencer trapz interrupt. Throws
-                                                         PKI_INTSN_E::PKI_CL()_INT_TRAPZ. Caused by TRAP sequence state, may indicate PKI
-                                                         enabled without proper sequencer code loaded in PKI_IMEM(). Based on PCAM sequencer
-                                                         execution, will likely throw an additional IPTINT interrupt. */
+	uint64_t reserved_4_63                : 60;
 	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. INTERNAL:
                                                          Caused by TRAP or INTR sequence state. */
 	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict. Internal error, should not occur. Throws
@@ -1448,8 +1444,7 @@ union cvmx_pki_clx_int {
 	uint64_t pcam_conf                    : 2;
 	uint64_t sched_conf                   : 1;
 	uint64_t iptint                       : 1;
-	uint64_t trapz                        : 1;
-	uint64_t reserved_5_63                : 59;
+	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
 	struct cvmx_pki_clx_int_s             cn78xx;
@@ -1510,7 +1505,7 @@ union cvmx_pki_clx_pcamx_actionx {
                                                          _ else = reserved.
                                                          Must be zero for invalid entries. */
 	uint64_t setty                        : 5;  /**< Set pointer type. If non-zero, indicates the layer type to be set as described under
-                                                         PKI_PCAM_TERM_E. Values are enumerated in PKI_LTYPE_E. Must be zero for invalid entries.
+                                                         PKI_PCAM_TERM_E. Values are enumerated by PKI_LTYPE_E. Must be zero for invalid entries.
                                                          The PKI_PCAM_TERM_E table enumerates legal/common SETTY values. */
 	uint64_t advance                      : 8;  /**< Relative number of bytes to advance scan pointer when entry matches.
                                                          Must be even. Must be zero for invalid entries and for TERMs that do not allow
@@ -1565,7 +1560,7 @@ union cvmx_pki_clx_pcamx_termx {
 	uint64_t term1                        : 8;  /**< See [TERM0]. */
 	uint64_t style1                       : 8;  /**< See [STYLE0]. */
 	uint64_t reserved_16_31               : 16;
-	uint64_t term0                        : 8;  /**< Comparison type. Enumerated with PKI_PCAM_TERM_E. The field value is ternary, where each
+	uint64_t term0                        : 8;  /**< Comparison type. Enumerated by PKI_PCAM_TERM_E. The field value is ternary, where each
                                                          bit matches as follows:
                                                          _ TERM1<n>=0, TERM0<n>=0: Always match; data<n> don't care.
                                                          _ TERM1<n>=0, TERM0<n>=1: Match when data<n> == 0.
@@ -1826,9 +1821,9 @@ union cvmx_pki_clx_stylex_alg {
 	struct cvmx_pki_clx_stylex_alg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t tt                           : 2;  /**< SSO tag type to schedule to, enumerated with SSO_TT_E. */
+	uint64_t tt                           : 2;  /**< SSO tag type to schedule to, enumerated by SSO_TT_E. */
 	uint64_t apad_nip                     : 3;  /**< Value for WQE[APAD] when packet is not IP. */
-	uint64_t qpg_qos                      : 3;  /**< Algorithm to select QoS field in QPG calculation. Enumerated with PKI_QPGQOS_E. */
+	uint64_t qpg_qos                      : 3;  /**< Algorithm to select QoS field in QPG calculation. Enumerated by PKI_QPGQOS_E. */
 	uint64_t qpg_port_sh                  : 3;  /**< Number of bits to shift port number in QPG calculation. */
 	uint64_t qpg_port_msb                 : 4;  /**< MSB to take from port number in QPG calculation.
                                                          0 = Exclude port number from QPG.
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 6648c33..2c0d8a4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -273,6 +273,39 @@ static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 #define CVMX_PKO_DQX_TOPOLOGY(offset) (CVMX_ADD_IO_SEG(0x0001540000300000ull) + ((offset) & 1023) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00015400008000E8ull) + ((offset) & 1023) * 512;
+}
+#else
+#define CVMX_PKO_DQX_WM_BUF_CNT(offset) (CVMX_ADD_IO_SEG(0x00015400008000E8ull) + ((offset) & 1023) * 512)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00015400008000F0ull) + ((offset) & 1023) * 512;
+}
+#else
+#define CVMX_PKO_DQX_WM_BUF_CTL(offset) (CVMX_ADD_IO_SEG(0x00015400008000F0ull) + ((offset) & 1023) * 512)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00015400008000F8ull) + ((offset) & 1023) * 512;
+}
+#else
+#define CVMX_PKO_DQX_WM_BUF_CTL_W1C(offset) (CVMX_ADD_IO_SEG(0x00015400008000F8ull) + ((offset) & 1023) * 512)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 {
 	if (!(
@@ -2796,17 +2829,6 @@ static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 #else
 #define CVMX_PKO_PTGFX_CFG(offset) (CVMX_ADD_IO_SEG(0x0001540000900200ull) + ((offset) & 7) * 8)
 #endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_PKO_RED_SEND_CFG CVMX_PKO_RED_SEND_CFG_FUNC()
-static inline uint64_t CVMX_PKO_RED_SEND_CFG_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_PKO_RED_SEND_CFG not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
-}
-#else
-#define CVMX_PKO_RED_SEND_CFG (CVMX_ADD_IO_SEG(0x00015400000800F8ull))
-#endif
 #define CVMX_PKO_REG_BIST_RESULT (CVMX_ADD_IO_SEG(0x0001180050000080ull))
 #define CVMX_PKO_REG_CMD_BUF (CVMX_ADD_IO_SEG(0x0001180050000010ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -3038,6 +3060,17 @@ static inline uint64_t CVMX_PKO_REG_TIMESTAMP_FUNC(void)
 #define CVMX_PKO_REG_TIMESTAMP (CVMX_ADD_IO_SEG(0x0001180050000060ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_SHAPER_CFG CVMX_PKO_SHAPER_CFG_FUNC()
+static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_SHAPER_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
+}
+#else
+#define CVMX_PKO_SHAPER_CFG (CVMX_ADD_IO_SEG(0x00015400000800F8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_STATUS CVMX_PKO_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 {
@@ -3154,12 +3187,14 @@ union cvmx_pko_dpfi_status {
 	uint64_t isrm_ptr0_val                : 1;  /**< ISRM pointer register 0 contains a valid pointer. */
 	uint64_t ptr_req_pend                 : 1;  /**< DPFI has pointer requests to FPA pending. */
 	uint64_t ptr_rtn_pend                 : 1;  /**< DPFI has pointer returns to FPA pending. */
-	uint64_t fpa_empty                    : 1;  /**< 1 = FPA responded to pointer request with 'no pointers available.'
-                                                         0 = FPA is providing pointers when requested. */
+	uint64_t fpa_empty                    : 1;  /**< FPA empty status:
+                                                         0 = FPA is providing pointers when requested.
+                                                         1 = FPA responded to pointer request with 'no pointers available.' */
 	uint64_t dpfi_empty                   : 1;  /**< DPFI pointer cache is empty. */
-	uint64_t cache_flushed                : 1;  /**< 1 = Cache flush has completed. PKO_DPFI_STATUS[PTR_CNT] will read zero if all outstanding
-                                                         pointers have been returned to the FPA.
-                                                         0 = Cache flush not enabled or in-progress. */
+	uint64_t cache_flushed                : 1;  /**< Cache flushed:
+                                                         0 = Cache flush not enabled or in-progress.
+                                                         1 = Cache flush has completed. PKO_DPFI_STATUS[PTR_CNT] will read zero if all outstanding
+                                                         pointers have been returned to the FPA. */
 #else
 	uint64_t cache_flushed                : 1;
 	uint64_t dpfi_empty                   : 1;
@@ -3355,7 +3390,7 @@ union cvmx_pko_dqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -3373,7 +3408,7 @@ union cvmx_pko_dqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -3513,10 +3548,12 @@ union cvmx_pko_dqx_schedule {
                                                             PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
                                                          where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
                                                          PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
                                                          else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
                                                          packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor. */
+                                                         in the send descriptor.
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -3646,6 +3683,77 @@ union cvmx_pko_dqx_topology {
 typedef union cvmx_pko_dqx_topology cvmx_pko_dqx_topology_t;
 
 /**
+ * cvmx_pko_dq#_wm_buf_cnt
+ */
+union cvmx_pko_dqx_wm_buf_cnt {
+	uint64_t u64;
+	struct cvmx_pko_dqx_wm_buf_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t count                        : 36; /**< Watermark buffer count. The running value of the buffer counter. */
+#else
+	uint64_t count                        : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_pko_dqx_wm_buf_cnt_s      cn78xx;
+};
+typedef union cvmx_pko_dqx_wm_buf_cnt cvmx_pko_dqx_wm_buf_cnt_t;
+
+/**
+ * cvmx_pko_dq#_wm_buf_ctl
+ */
+union cvmx_pko_dqx_wm_buf_ctl {
+	uint64_t u64;
+	struct cvmx_pko_dqx_wm_buf_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t enable                       : 1;  /**< Watermark enable. */
+	uint64_t reserved_49_49               : 1;
+	uint64_t intr                         : 1;  /**< Watermark Buffer Interrupt. The interrupt bit is asserted and an interrupt message to the
+                                                         CIU is
+                                                         generated when the specified threshold is reached or crossed. Subsequent interrupt
+                                                         messages are only generated after this bit has been cleared. */
+	uint64_t reserved_36_47               : 12;
+	uint64_t threshold                    : 36; /**< Watermark Buffer Threshold. This threshold is compared to the watermark count of
+                                                         PKO_DQ()_WM_BUF_CNT[COUNT] and an interrupt is generated when the count reaches or
+                                                         crosses the threshold. */
+#else
+	uint64_t threshold                    : 36;
+	uint64_t reserved_36_47               : 12;
+	uint64_t intr                         : 1;
+	uint64_t reserved_49_49               : 1;
+	uint64_t enable                       : 1;
+	uint64_t reserved_51_63               : 13;
+#endif
+	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_s      cn78xx;
+};
+typedef union cvmx_pko_dqx_wm_buf_ctl cvmx_pko_dqx_wm_buf_ctl_t;
+
+/**
+ * cvmx_pko_dq#_wm_buf_ctl_w1c
+ */
+union cvmx_pko_dqx_wm_buf_ctl_w1c {
+	uint64_t u64;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_49_63               : 15;
+	uint64_t intr                         : 1;  /**< Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is generated
+                                                         when the specified threshold is crossed. Subsequent interrupt messages are only generated
+                                                         after this bit has been cleared by writing 1. Throws PKO_INTSN_E::PKO_DQ()_WM_BUF. */
+	uint64_t reserved_0_47                : 48;
+#else
+	uint64_t reserved_0_47                : 48;
+	uint64_t intr                         : 1;
+	uint64_t reserved_49_63               : 15;
+#endif
+	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn78xx;
+};
+typedef union cvmx_pko_dqx_wm_buf_ctl_w1c cvmx_pko_dqx_wm_buf_ctl_w1c_t;
+
+/**
  * cvmx_pko_dq#_wm_cnt
  */
 union cvmx_pko_dqx_wm_cnt {
@@ -4048,7 +4156,7 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -4066,7 +4174,7 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -4552,7 +4660,7 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -4570,7 +4678,7 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -4726,10 +4834,12 @@ union cvmx_pko_l2_sqx_schedule {
                                                             PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
                                                          where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
                                                          PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
                                                          else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
                                                          packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor. */
+                                                         in the send descriptor.
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -5100,7 +5210,7 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -5118,7 +5228,7 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -5281,10 +5391,12 @@ union cvmx_pko_l3_sqx_schedule {
                                                             PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
                                                          where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
                                                          PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
                                                          else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
                                                          packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor. */
+                                                         in the send descriptor.
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -5587,7 +5699,7 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -5605,7 +5717,7 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -5765,10 +5877,12 @@ union cvmx_pko_l4_sqx_schedule {
                                                             PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
                                                          where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
                                                          PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
                                                          else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
                                                          packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor. */
+                                                         in the send descriptor.
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -6077,7 +6191,7 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
 	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
                                                          the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
@@ -6095,7 +6209,7 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t length                       : 16; /**< The packet length in bytes including pad.
                                                                PKO_SEND_HDR_S[TOTAL] + CALCPAD
                                                          where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
                                                          CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
                                                          DQ the packet used. */
 #else
@@ -6258,10 +6372,12 @@ union cvmx_pko_l5_sqx_schedule {
                                                             PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
                                                          where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
                                                          PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
-                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         PKO_SEND_HDR_S[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
                                                          else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
                                                          packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
-                                                         in the send descriptor. */
+                                                         in the send descriptor.
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of PKO_*_SCHED_STATE[RR_COUNT] (i.e. the deficit count)). */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -6474,6 +6590,35 @@ typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
 
 /**
  * cvmx_pko_lut#
+ *
+ * PKO_LUT has a location for each used PKI_CHAN_E. The following table
+ * shows the mapping between LINK/MAC_NUM's, PKI_CHAN_E channels, and
+ * PKO_LUT indices.
+ *
+ * <pre>
+ *   LINK/   PKI_CHAN_E    Corresponding
+ * MAC_NUM   Range         PKO_LUT index   Description
+ * -------   -----------   -------------   -----------------
+ *    0      0x000-0x03F   0x3C0-0x3FF     LBK Loopback
+ *    1      0x100-0x13F   0x380-0x3BF     DPI packet output
+ *    2      0x400-0x4FF   0x000-0x0FF     ILK link 0
+ *    3      0x500-0x5FF   0x100-0x1FF     ILK link 1
+ *    4      0x800-0x80F   0x200-0x20F     BGX0 Logical MAC 0
+ *    5      0x810-0x81F   0x210-0x21F     BGX0 Logical MAC 1
+ *    6      0x820-0x82F   0x220-0x22F     BGX0 Logical MAC 2
+ *    7      0x830-0x83F   0x230-0x23F     BGX0 Logical MAC 3
+ *    8      0x900-0x90F   0x240-0x24F     BGX1 Logical MAC 0
+ *    9      0x910-0x91F   0x250-0x25F     BGX1 Logical MAC 1
+ *   10      0x920-0x92F   0x260-0x26F     BGX1 Logical MAC 2
+ *   11      0x930-0x93F   0x270-0x27F     BGX1 Logical MAC 3
+ *   12      0xA00-0xA0F   0x280-0x28F     BGX2 Logical MAC 0
+ *   13      0xA10-0xA1F   0x290-0x29F     BGX2 Logical MAC 1
+ *   ...         ...           ...               ...
+ *   24      0xD00-0xD0F   0x340-0x34F     BGX5 Logical MAC 0
+ *   25      0xD10-0xD1F   0x350-0x35F     BGX5 Logical MAC 1
+ *   26      0xD20-0xD2F   0x360-0x36F     BGX5 Logical MAC 2
+ *   27      0xD30-0xD3F   0x370-0x37F     BGX5 Logical MAC 3
+ * </pre>
  */
 union cvmx_pko_lutx {
 	uint64_t u64;
@@ -9101,9 +9246,11 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t minpad_ram_bist_status       : 1;  /**< BIST status for MINPAD_RAM. */
 	uint64_t mwp_hi_spt_ram_bist_status   : 1;  /**< Reserved. */
 	uint64_t mwp_lo_spt_ram_bist_status   : 1;  /**< Reserved. */
-	uint64_t reserved_0_35                : 36;
+	uint64_t buf_wm_ram_bist_status       : 1;  /**< Reserved. */
+	uint64_t reserved_0_34                : 35;
 #else
-	uint64_t reserved_0_35                : 36;
+	uint64_t reserved_0_34                : 35;
+	uint64_t buf_wm_ram_bist_status       : 1;
 	uint64_t mwp_lo_spt_ram_bist_status   : 1;
 	uint64_t mwp_hi_spt_ram_bist_status   : 1;
 	uint64_t minpad_ram_bist_status       : 1;
@@ -9445,7 +9592,9 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_ctl1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_12_63               : 52;
+	uint64_t reserved_15_63               : 49;
+	uint64_t buf_wm_ram_flip              : 2;  /**< Reserved. */
+	uint64_t buf_wm_ram_cdis              : 1;  /**< Reserved. */
 	uint64_t mwp_mem0_ram_flip            : 2;  /**< Reserved. */
 	uint64_t mwp_mem1_ram_flip            : 2;  /**< Reserved. */
 	uint64_t mwp_mem2_ram_flip            : 2;  /**< Reserved. */
@@ -9461,7 +9610,9 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	uint64_t mwp_mem2_ram_flip            : 2;
 	uint64_t mwp_mem1_ram_flip            : 2;
 	uint64_t mwp_mem0_ram_flip            : 2;
-	uint64_t reserved_12_63               : 52;
+	uint64_t buf_wm_ram_cdis              : 1;
+	uint64_t buf_wm_ram_flip              : 2;
+	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
@@ -9520,9 +9671,11 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
 	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Reserved. */
 	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Reserved. */
-	uint64_t reserved_0_39                : 40;
+	uint64_t buf_wm_ram_dbe               : 1;  /**< Reserved. */
+	uint64_t reserved_0_38                : 39;
 #else
-	uint64_t reserved_0_39                : 40;
+	uint64_t reserved_0_38                : 39;
+	uint64_t buf_wm_ram_dbe               : 1;
 	uint64_t mwp_lo_spt_ram_dbe           : 1;
 	uint64_t mwp_hi_spt_ram_dbe           : 1;
 	uint64_t minpad_ram_dbe               : 1;
@@ -9647,9 +9800,11 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
 	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Reserved. */
 	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Reserved. */
-	uint64_t reserved_0_39                : 40;
+	uint64_t buf_wm_ram_sbe               : 1;  /**< Reserved. */
+	uint64_t reserved_0_38                : 39;
 #else
-	uint64_t reserved_0_39                : 40;
+	uint64_t reserved_0_38                : 39;
+	uint64_t buf_wm_ram_sbe               : 1;
 	uint64_t mwp_lo_spt_ram_sbe           : 1;
 	uint64_t mwp_hi_spt_ram_sbe           : 1;
 	uint64_t minpad_ram_sbe               : 1;
@@ -11033,15 +11188,19 @@ union cvmx_pko_peb_tso_cfg {
 	uint64_t u64;
 	struct cvmx_pko_peb_tso_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t fsf                          : 8;  /**< Reserved. */
-	uint64_t msf                          : 8;  /**< Reserved. */
-	uint64_t lsf                          : 8;  /**< Reserved. */
+	uint64_t reserved_44_63               : 20;
+	uint64_t fsf                          : 12; /**< Reserved. */
+	uint64_t reserved_28_31               : 4;
+	uint64_t msf                          : 12; /**< Reserved. */
+	uint64_t reserved_12_15               : 4;
+	uint64_t lsf                          : 12; /**< Reserved. */
 #else
-	uint64_t lsf                          : 8;
-	uint64_t msf                          : 8;
-	uint64_t fsf                          : 8;
-	uint64_t reserved_24_63               : 40;
+	uint64_t lsf                          : 12;
+	uint64_t reserved_12_15               : 4;
+	uint64_t msf                          : 12;
+	uint64_t reserved_28_31               : 4;
+	uint64_t fsf                          : 12;
+	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
 	struct cvmx_pko_peb_tso_cfg_s         cn78xx;
@@ -13588,34 +13747,6 @@ union cvmx_pko_ptgfx_cfg {
 typedef union cvmx_pko_ptgfx_cfg cvmx_pko_ptgfx_cfg_t;
 
 /**
- * cvmx_pko_red_send_cfg
- */
-union cvmx_pko_red_send_cfg {
-	uint64_t u64;
-	struct cvmx_pko_red_send_cfg_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_1_63                : 63;
-	uint64_t red_send_as_yellow           : 1;  /**< RED_SEND as YELLOW. Configures the way packets colored RED_SEND are
-                                                         handled by the DQ through L2 shapers.  Packets colored RED_DROP do not decrement
-                                                         the PIR in DQ through L2 shapers while packets colored YELLOW do.  (Neither RED_DROP
-                                                         nor YELLOW packets decrement the CIR in DQ through L2 shapers.)  Packets colored
-                                                         RED_SEND are treated as either RED_DROP or YELLOW in the DQ through L2 shapers
-                                                         as follows:
-                                                         0 = treat RED_SEND as RED_DROP.
-                                                         1 = treat RED_SEND as YELLOW.
-                                                         In the L1 shapers, RED_DROP packets do not decrement the CIR, while YELLOW do.
-                                                         RED_SEND packets are always treated the same as YELLOW is in the L1 shapers,
-                                                         irrespective of [RED_SEND_AS_YELLOW]. */
-#else
-	uint64_t red_send_as_yellow           : 1;
-	uint64_t reserved_1_63                : 63;
-#endif
-	} s;
-	struct cvmx_pko_red_send_cfg_s        cn78xx;
-};
-typedef union cvmx_pko_red_send_cfg cvmx_pko_red_send_cfg_t;
-
-/**
  * cvmx_pko_reg_bist_result
  *
  * Notes:
@@ -15262,6 +15393,37 @@ union cvmx_pko_reg_timestamp {
 typedef union cvmx_pko_reg_timestamp cvmx_pko_reg_timestamp_t;
 
 /**
+ * cvmx_pko_shaper_cfg
+ */
+union cvmx_pko_shaper_cfg {
+	uint64_t u64;
+	struct cvmx_pko_shaper_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t color_aware                  : 1;  /**< Color aware. Selects whether or not the PSE shapers take into account
+                                                         the color of the incoming packet.  0: color blind, 1: color aware */
+	uint64_t red_send_as_yellow           : 1;  /**< RED_SEND as YELLOW. Configures the way packets colored RED_SEND are
+                                                         handled by the DQ through L2 shapers.  Packets colored RED_DROP do not decrement
+                                                         the PIR in DQ through L2 shapers while packets colored YELLOW do.  (Neither RED_DROP
+                                                         nor YELLOW packets decrement the CIR in DQ through L2 shapers.)  Packets colored
+                                                         RED_SEND are treated as either RED_DROP or YELLOW in the DQ through L2 shapers
+                                                         as follows:
+                                                         0 = treat RED_SEND as RED_DROP.
+                                                         1 = treat RED_SEND as YELLOW.
+                                                         In the L1 shapers, RED_DROP packets do not decrement the CIR, while YELLOW do.
+                                                         RED_SEND packets are always treated the same as YELLOW is in the L1 shapers,
+                                                         irrespective of [RED_SEND_AS_YELLOW]. */
+#else
+	uint64_t red_send_as_yellow           : 1;
+	uint64_t color_aware                  : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_pko_shaper_cfg_s          cn78xx;
+};
+typedef union cvmx_pko_shaper_cfg cvmx_pko_shaper_cfg_t;
+
+/**
  * cvmx_pko_status
  */
 union cvmx_pko_status {
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 9db8d35..17d74dc 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -109,6 +109,17 @@ static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 #define CVMX_RST_DELAY (CVMX_ADD_IO_SEG(0x0001180006001608ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_ECO CVMX_RST_ECO_FUNC()
+static inline uint64_t CVMX_RST_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_RST_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800060017B8ull);
+}
+#else
+#define CVMX_RST_ECO (CVMX_ADD_IO_SEG(0x00011800060017B8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_INT CVMX_RST_INT_FUNC()
 static inline uint64_t CVMX_RST_INT_FUNC(void)
 {
@@ -403,6 +414,24 @@ union cvmx_rst_delay {
 typedef union cvmx_rst_delay cvmx_rst_delay_t;
 
 /**
+ * cvmx_rst_eco
+ */
+union cvmx_rst_eco {
+	uint64_t u64;
+	struct cvmx_rst_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< ECO flops. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_rst_eco_s                 cn78xx;
+};
+typedef union cvmx_rst_eco cvmx_rst_eco_t;
+
+/**
  * cvmx_rst_int
  */
 union cvmx_rst_int {
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 079bd89..2fdddcd 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -1285,6 +1285,17 @@ static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 #define CVMX_SLI_PORTX_PKIND(offset) (0x0000000000000800ull + ((offset) & 31) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_S2C_END_MERGE CVMX_SLI_S2C_END_MERGE_FUNC()
+static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_SLI_S2C_END_MERGE not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+}
+#else
+#define CVMX_SLI_S2C_END_MERGE (CVMX_ADD_IO_SEG(0x00011F0000015000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 {
 	if (!(
@@ -3351,8 +3362,8 @@ typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
  * cvmx_sli_int_sum
  *
  * The fields in this register are set when an interrupt condition occurs; write 1 to clear. All
- * fields of the CSR are valid when a PF reads the CSR. When read by a VF, only fields PTIME and
- * PCNT are valid.
+ * fields of the CSR are valid when a PF reads the CSR. Not available to VF's, and writes by the
+ * VF do not modify the register.
  */
 union cvmx_sli_int_sum {
 	uint64_t u64;
@@ -5658,9 +5669,15 @@ union cvmx_sli_pktx_cnts {
 	uint64_t u64;
 	struct cvmx_sli_pktx_cnts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t po_int                       : 1;  /**< "Returns a 1 when either the corresponding bit in SLI_PKT_TIME_INT[RING[\#]] or
-                                                         SLI_PKT_CNT_INT[RING[\#]] is set." */
-	uint64_t pi_int                       : 1;  /**< Returns a 1 when corresponding bit of SLI_PKT_IN_INT[RING[\#]] is set. */
+	uint64_t po_int                       : 1;  /**< Packet output interrupt bit for the ring (i). [PO_INT] reads as one whenever:
+                                                          * [CNT]   > SLI_PKT(i)_INT_LEVELS[CNT], or
+                                                          * [TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]
+                                                         [PO_INT] can cause an MSI-X interrupt for ring i, and its [CNT] ([TIMER]) component
+                                                         can cause SLI_INT_SUM[PCNT] (SLI_INT_SUM[PTIME]) to be set if
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB] (SLI_PKT(i)_OUTPUT_CONTROL[TENB]) is set.
+                                                         SLI_PKT_CNT_INT (SLI_PKT_TIME_INT) shows the [CNT] ([TIMER]) component
+                                                         for this and all other rings. See also SLI_PKT_IN_DONE(i)_CNTS[PO_INT]. */
+	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. A copy of SLI_PKT_IN_DONE(0..63)_CNTS[PI_INT]. */
 	uint64_t reserved_54_61               : 8;
 	uint64_t timer                        : 22; /**< Timer incremented every 1024 core clocks
                                                          when SLI_PKTS#_CNTS[CNT] is non zero. Field
@@ -6125,10 +6142,18 @@ union cvmx_sli_pktx_int_levels {
 	struct cvmx_sli_pktx_int_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t time                         : 22; /**< Output ring counter time interrupt threshold.
-                                                         SLI sets SLI_PKT_TIME_INT[PORT<i>] whenever SLI_PKT()_CNTS[TIMER] > TIME. */
-	uint64_t cnt                          : 32; /**< Output ring counter interrupt threshold. SLI sets SLI_PKT_CNT_INT[PORT<i>] whenever
-                                                         SLI_PKT()_CNTS[CNT] > CNT. */
+	uint64_t time                         : 22; /**< Output ring counter time interrupt threshold. SLI sets SLI_PKT(i)_CNTS[PO_INT]
+                                                         (and SLI_PKT_TIME_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
+                                                         INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[TIMER] > [TIME].
+                                                         Whenever software changes the value of [TIME], it should also subsequently write
+                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
+	uint64_t cnt                          : 32; /**< Output ring counter interrupt threshold. SLI sets SLI_PKT(i)_CNTS[PO_INT]
+                                                         (and SLI_PKT_CNT_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
+                                                         INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[CNT] > [CNT].
+                                                         Whenever software changes the value of [TIME], it should also subsequently write
+                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
 #else
 	uint64_t cnt                          : 32;
 	uint64_t time                         : 22;
@@ -6373,8 +6398,11 @@ typedef union cvmx_sli_pktx_vf_sig cvmx_sli_pktx_vf_sig_t;
 /**
  * cvmx_sli_pkt_cnt_int
  *
- * This register specifies which packet rings are interrupting because of packet counters.
- *
+ * This register specifies which output packet rings are interrupting because of packet counters.
+ * A bit set in this interrupt register will set a corresponding bit in SLI_PKT_INT and can
+ * also cause SLI_INT_SUM[PCNT] to be set if SLI_PKT(0..63)_OUTPUT_CONTROL[CENB] is set.
+ * When read by a function, this register informs which rings owned by the function (0 to N,
+ * N as large as 63) have this interrupt pending.
  */
 union cvmx_sli_pkt_cnt_int {
 	uint64_t u64;
@@ -6407,10 +6435,13 @@ union cvmx_sli_pkt_cnt_int {
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn70xxp1;
 	struct cvmx_sli_pkt_cnt_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< Output ring packet counter interrupt bits SLI sets RING<i> whenever
-                                                         SLI_PKT()_CNTS[CNT] > SLI_PKT()_INT_LEVELS[CNT].
-                                                         SLI_PKT_CNT_INT_ENB[RING<i>] is the corresponding enable.
-                                                         This field will be updated whenever there is a change in SLI_PKT()_CNTS[CNT]; */
+	uint64_t ring                         : 64; /**< Multi-ring output ring packet counter interrupt bits. RING<i> is one
+                                                         whenever SLI_PKT(i)_CNTS[CNT] > SLI_PKT(i)_INT_LEVELS[CNT].
+                                                         RING<i> is the CNT component of SLI_PKT(i)_CNTS[PO_INT]
+                                                         (and SLI_PKT_IN_DONE(i)_CNTS[PO_INT]), and one of the components
+                                                         of SLI_PKT_INT[RING<i>]. Hardware may not update RING<i> when
+                                                         software modifies SLI_PKT(i)_INT_LEVELS[CNT] - refer to the
+                                                         description of SLI_PKT(0..63)_INT_LEVELS[CNT]. */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -6680,15 +6711,19 @@ union cvmx_sli_pkt_in_donex_cnts {
 	uint64_t u64;
 	struct cvmx_sli_pkt_in_donex_cnts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t po_int                       : 1;  /**< "Returns a 1 when either the corresponding bit in SLI_PKT_TIME_INT[RING[\#]] or
-                                                         SLI_PKT_CNT_INT[RING[\#]] is set." */
-	uint64_t pi_int                       : 1;  /**< "Returns a 1 when corresponding bit of SLI_PKT_IN_INT[RING[\#]] is set. Writing a 1 to this
-                                                         field clears the corresponding bit in SLI_PKT_IN_INT[RING[\#]]." */
+	uint64_t po_int                       : 1;  /**< Packet output interrupt bit for the ring. A copy of SLI_PKT(i)_CNTS[PO_INT]. */
+	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. The hardware sets [PI_INT] whenever it updates
+                                                         [CNT<15:0>] to equal [WMARK] when CINT_ENB is set. Writing a 1 clears [PI_INT].
+                                                         [PI_INT] can cause an MSI-X interrupt for the ring, but will never cause an INTA/B/C/D
+                                                         nor MSI interrupt nor set any SLI_INT_SUM bit. SLI_PKT_IN_INT is a multi-ring version of
+                                                         [PI_INT], and [PI_INT] is one component of SLI_PKT_INT. See also
+                                                         SLI_PKT(0..63)_CNTS[PI_INT]. */
 	uint64_t reserved_49_61               : 13;
-	uint64_t cint_enb                     : 1;  /**< When set, allows corresponding bit in SLI_PKT_IN_INT[RING[\#]] to be set. */
-	uint64_t wmark                        : 16; /**< "When the value of SLI_PKT_IN_DONE()_CNTS[CNT[15:0]] is updated to be equal to
-                                                         SLI_PKT_IN_DONE()_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE()_CNTS[CINT_ENB] is also
-                                                         set, the corresponding bit in SLI_PKT_IN_INT[RING[\#]] will be set." */
+	uint64_t cint_enb                     : 1;  /**< Packet input interrupt enable bit for the ring. When [CINT_ENB] is set, the hardware will
+                                                         set [PI_INT] whenever it updates [CNT<15:0>] to equal [WMARK]. When [CINT_ENB]
+                                                         is clear, the hardware will never set [PI_INT]. */
+	uint64_t wmark                        : 16; /**< Packet input interrupt watermark for the ring. If [CINT_ENB] is set, the hardware
+                                                         sets [PI_INT] whenever it updates [CNT<15:0>] to equal [WMARK]. */
 	uint64_t cnt                          : 32; /**< This field is incrmented by '1' when an instruction
                                                          is completed. This field is incremented as the
                                                          last of the data is read from the MAC. */
@@ -6759,18 +6794,19 @@ typedef union cvmx_sli_pkt_in_instr_counts cvmx_sli_pkt_in_instr_counts_t;
 /**
  * cvmx_sli_pkt_in_int
  *
- * When read by a VF, this register informs which rings owned by the VF (0 to 63) have an
- * interrupt pending. In PF mode, this register returns an unpredictable value. Writing 1s to
- * clear this register clears both packet count and packet time interrupts. The clearing of the
- * interrupts will be reflected in SLI_PKT_CNT_INT and SLI_PKT_TIME_INT.
+ * This register specifies which inpit packets rings are interrupting because of done cnts.
+ * A bit set in this intterupt register will set a corresponding bit in SLI_PKT_INT which
+ * can cause a MSIX interrupt.  When read by a function, this register informs which rings
+ * owned by the function (0 to N, N as large as 63) have this interrupt pending.
+ * SLI_PKT_IN_INT conditions can cause MSI-X interrupts, but do not cause any SLI_INT_SUM
+ * bit to set, and cannot cause INTA/B/C/D nor MSI interrupts.
  */
 union cvmx_sli_pkt_in_int {
 	uint64_t u64;
 	struct cvmx_sli_pkt_in_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< Set when SLI_PKT_IN_DONE()_CNTS[CNT[15:0]] is updated to be equal to
-                                                         SLI_PKT_IN_DONE()_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE()_CNTS[CINT_ENB] is set.
-                                                         Cleared when SLI_PKT_IN_DONE()_CNTS[PI_INT] is cleared. */
+	uint64_t ring                         : 64; /**< Multi-ring packet input interrupt register. Each RING<i> is a read-only copy of
+                                                         SLI_PKT_IN_DONE(i)_CNTS[PI_INT]. */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -7109,16 +7145,26 @@ typedef union cvmx_sli_pkt_instr_size cvmx_sli_pkt_instr_size_t;
 /**
  * cvmx_sli_pkt_int
  *
- * When read by a VF, this register informs which rings owned by the VF (0 to 63) have an
- * interrupt pending. In PF mode, this register returns an unpredictable value. Writing 1s to
- * clear this register clears both packet count and packet time interrupts. The clearing of the
- * interrupts will be reflected in SLI_PKT_CNT_INT and SLI_PKT_TIME_INT.
+ * This register combines the SLI_PKT_CNT_INT, SLI_PKT_TIME_INT or SLI_PKT_IN_INT interrupt
+ * registers. When read by a function, this register informs which rings owned by the function
+ * (0 to N, N as large as 63) have an interrupt pending.
+ * attributes:
+ * vf_reg_type: "bw"
  */
 union cvmx_sli_pkt_int {
 	uint64_t u64;
 	struct cvmx_sli_pkt_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< Ring 63-0 has packet count or packet time interrupt. */
+	uint64_t ring                         : 64; /**< Multi-ring packet interrupt register. Each RING<i> is set whenever any
+                                                         of these three conditions are true:
+                                                          * SLI_PKT(i)_CNTS[CNT] > SLI_PKT(i)_INT_LEVELS[CNT] (i.e. SLI_PKT_CNT_INT<i>
+                                                            is set), or
+                                                          * SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME] (i.e. SLI_PKT_TIME_INT<i>
+                                                            is set), or
+                                                          * SLI_PKT_IN_DONE(i)_CNTS[PI_INT] (i.e. SLI_PKT_IN_INT<i>) is set.
+                                                         Any of these three conditions can cause an MSI-X interrupt, but only
+                                                         the first two (i.e. SLI_PKT_CNT_INT and SLI_PKT_TIME_INT) can cause
+                                                         INTA/B/C/D and MSI interrupts. */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -7704,8 +7750,11 @@ typedef union cvmx_sli_pkt_slist_ror cvmx_sli_pkt_slist_ror_t;
 /**
  * cvmx_sli_pkt_time_int
  *
- * This register specifies which packets' rings are interrupting because of packet timers.
- *
+ * This register specifies which output packets rings are interrupting because of packet timers.
+ * A bit set in this interrupt register will set a corresponding bit in SLI_PKT_INT and can
+ * also cause SLI_INT_SUM[PTIME] to be set if SLI_PKT(0..63)_OUTPUT_CONTROL[TENB] is set.
+ * When read by a function, this register informs which rings owned by the function (0 to N,
+ * N as large as 63) have this interrupt pending.
  */
 union cvmx_sli_pkt_time_int {
 	uint64_t u64;
@@ -7738,10 +7787,13 @@ union cvmx_sli_pkt_time_int {
 	struct cvmx_sli_pkt_time_int_cn61xx   cn70xxp1;
 	struct cvmx_sli_pkt_time_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< Output ring packet timer interrupt bits SLI sets RING<i> whenever
-                                                         SLI_PKT()_CNTS[TIMER] > SLI_PKT()_INT_LEVELS[TIME]. SLI_PKT_TIME_INT_ENB[RING<i>] is
-                                                         the corresponding enable. This field will be updated whenever there is a change
-                                                         in SLI_PKT()_CNTS[TIMER]; */
+	uint64_t ring                         : 64; /**< Multi-ring output ring packet time interrupt bits. RING<i> reads as one
+                                                         whenever SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME].
+                                                         RING<i> is the TIMER component of SLI_PKT(i)_CNTS[PO_INT]
+                                                         (and SLI_PKT_IN_DONE(i)_CNTS[PO_INT]), and one of the components
+                                                         of SLI_PKT_INT[RING<i>]. Hardware may not update RING<i> when
+                                                         software modifies SLI_PKT(i)_INT_LEVELS[TIME] - refer to the
+                                                         description of SLI_PKT(0..63)_INT_LEVELS[TIME]. */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -7845,6 +7897,25 @@ union cvmx_sli_portx_pkind {
 typedef union cvmx_sli_portx_pkind cvmx_sli_portx_pkind_t;
 
 /**
+ * cvmx_sli_s2c_end_merge
+ *
+ * Writing this CSR will cause a merge to end.
+ *
+ */
+union cvmx_sli_s2c_end_merge {
+	uint64_t u64;
+	struct cvmx_sli_s2c_end_merge_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_sli_s2c_end_merge_s       cn78xx;
+};
+typedef union cvmx_sli_s2c_end_merge cvmx_sli_s2c_end_merge_t;
+
+/**
  * cvmx_sli_s2m_port#_ctl
  *
  * These registers contain control for access from SLI to a MAC port. Write operations to these
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 4c16b7c..5eca181 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -2432,17 +2432,16 @@ union cvmx_sso_grpx_int {
 	uint64_t exe_dis                      : 1;  /**< Executable interrupt temporary disable. Corresponding [EXE_INT] bit cannot be set due to
                                                          IAQ_CNT/IAQ_THR check when this bit is set. EXE_DIS is cleared by hardware whenever:
                                                          * SSO_GRP()_INT_CNT[IAQ_CNT] is zero, or
-                                                         * SSO_GRP()_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
+                                                         * The hardware decrements the time counter for this group to zero, i.e.
+                                                         SSO_GRP()_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
                                                          equal to 0. */
 	uint64_t reserved_2_62                : 61;
 	uint64_t exe_int                      : 1;  /**< Work-executable interrupt. Generally used to indicate work is waiting for software. Throws
                                                          SSO_INTSN_E::SSO_GRP()_EXE. Set by hardware whenever:
                                                          * SSO_GRP()_INT_CNT[IAQ_CNT] >= SSO_GRP()_INT_THR [IAQ_THR] and [IAQ_THR] != 0
                                                          and EXE_DIS is clear.
-                                                         * SSO_GRP()_INT_CNT[DS_CNT] >= SSO_GRP()_INT_THR[DS_THR] and [DS_THR] != 0 and
-                                                         EXE_DIS is clear.
-                                                         * SSO_GRP()_INT_CNT[CQ_CNT] >= SSO_GRP()_INT_THR[CQ_THR] and [CQ_THR] != 0 and
-                                                         EXE_DIS is clear.
+                                                         * SSO_GRP()_INT_CNT[DS_CNT] >= SSO_GRP()_INT_THR[DS_THR] and [DS_THR] != 0.
+                                                         * SSO_GRP()_INT_CNT[CQ_CNT] >= SSO_GRP()_INT_THR[CQ_THR] and [CQ_THR] != 0.
                                                          * SSO_GRP()_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
                                                          equal to 0 and SSO_GRP()_INT_THR[TC_EN] is set and at least one of the following is
                                                          true:
@@ -2478,7 +2477,7 @@ union cvmx_sso_grpx_int_cnt {
                                                          SSO_GRP()_INT_THR[TC_THR] whenever:
                                                          * Corresponding SSO_GRP()_INT_CNT[IAQ_CNT, DS_CNT and CQ_CNT] are all equal to 0.
                                                          * Corresponding SSO_GRP()_INT[EXE_INT] is written with a one to clear by software.
-                                                         * Corresponding SSO_GRP()_INT[EXE_DIS] is written with a one to clear by software.
+                                                         * Corresponding SSO_GRP()_INT[EXE_DIS] is written with a one to set by software.
                                                          * Corresponding SSO_GRP()_INT_THR is written by software.
                                                          * TC_CNT is equal to 1 and periodic counter SSO_WQ_INT_PC[PC] is equal to 0.
                                                          Otherwise, hardware decrements this field whenever the periodic counter SSO_WQ_INT_PC[PC]
@@ -4261,7 +4260,9 @@ union cvmx_sso_tiaqx_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t wae_head                     : 4;  /**< Head's WAE number within current cache line, 0-12. This provides the second index into
                                                          SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
-	uint64_t wae_tail                     : 4;  /**< Tail's WAE number within current cache line, 0-12. This provides the second index into
+	uint64_t wae_tail                     : 4;  /**< When WAE_USED is non-zero, this provides the next free WAE number in the cache line of the
+                                                         tail entry. If 0, the next entry will be placed at the beginning of a new cache line.
+                                                         This provides the second index into
                                                          SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_47_55               : 9;
 	uint64_t wae_used                     : 15; /**< Number of WAEs in use. */
@@ -4299,7 +4300,9 @@ union cvmx_sso_toaqx_status {
 	uint64_t reserved_62_63               : 2;
 	uint64_t ext_vld                      : 1;  /**< External queuing is in use on this group. */
 	uint64_t partial                      : 1;  /**< Partial cache line is allocated to tail of queue. */
-	uint64_t wae_tail                     : 4;  /**< If PARTIAL is set, tail's WAE number within current cache line, 0-12. This provides the
+	uint64_t wae_tail                     : 4;  /**< If PARTIAL is set, this provides the next free WAE number in the cache line of the tail
+                                                         entry. If PARTIAL is clear, the next entry will be placed at the beginning of a new cache
+                                                         line. This provides the
                                                          second index into SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_43_55               : 13;
 	uint64_t cl_used                      : 11; /**< Number of cache lines in use. */
-- 
2.6.2

