From 29909be1745bd44e0cd410dd6132d85e2d03a531 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 28 Feb 2014 13:46:59 -0800
Subject: [PATCH 509/974] mmc octeon_mmc: Do request_irq later to avoid OOPS.

We have to be mostly initialized before request_irq, otherwise bad
things happen.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 171 ++++++++++++++++++++++++------------------
 1 file changed, 100 insertions(+), 71 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index f17a241..bd6e30a 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -38,8 +38,7 @@
 #define OCTEON_MAX_MMC			4
 
 #define OCT_MIO_NDF_DMA_CFG		0x00
-#define OCT_MIO_NDF_DMA_INT		0x08
-#define OCT_MIO_NDF_DMA_INT_EN		0x10
+#define OCT_MIO_EMM_DMA_ADR		0x08
 
 #define OCT_MIO_EMM_CFG			0x00
 #define OCT_MIO_EMM_SWITCH		0x48
@@ -75,6 +74,8 @@ struct octeon_mmc_host {
 	int global_pwr_gpio;
 	bool global_pwr_gpio_low;
 	bool dma_err_pending;
+	bool need_bus_lock;
+	bool big_dma_addr;
 
 	struct octeon_mmc_slot	*slot[OCTEON_MAX_MMC];
 };
@@ -112,16 +113,22 @@ MODULE_PARM_DESC(limit_max_blk,
 static inline octeon_mmc_dbg(const char *s, ...) { }
 #endif
 
-static void octeon_mmc_acquire_bus(void)
+static void octeon_mmc_acquire_bus(struct octeon_mmc_host *host)
 {
+	if (!host->need_bus_lock)
+		return;
+
 	down(&octeon_bootbus_sem);
 	/* On cn70XX switch the mmc unit onto the bus. */
 	if (OCTEON_IS_MODEL(OCTEON_CN70XX))
 		cvmx_write_csr(CVMX_MIO_BOOT_CTL, 0);
 }
 
-static void octeon_mmc_release_bus(void)
+static void octeon_mmc_release_bus(struct octeon_mmc_host *host)
 {
+	if (!host->need_bus_lock)
+		return;
+
 	up(&octeon_bootbus_sem);
 }
 
@@ -418,7 +425,7 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 	}
 no_req_done:
 	if (host_done)
-		octeon_mmc_release_bus();
+		octeon_mmc_release_bus(host);
 out:
 	return IRQ_RETVAL(emm_int.u64 != 0);
 }
@@ -479,7 +486,7 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	octeon_mmc_acquire_bus();
+	octeon_mmc_acquire_bus(host);
 
 	octeon_mmc_switch_to(slot);
 
@@ -497,9 +504,6 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 
 	host->sg_idx = 0;
 
-	/* Clear any pending irqs */
-	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT, 1);
-
 	WARN_ON(data->blksz * data->blocks > host->linear_buf_size);
 
 	if ((data->flags & MMC_DATA_WRITE) && data->sg_len > 1) {
@@ -515,12 +519,23 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	dma_cfg.s.endian = 1;
 #endif
 	dma_cfg.s.size = ((data->blksz * data->blocks) / 8) - 1;
-	if (data->sg_len > 1)
-		dma_cfg.s.adr = virt_to_phys(host->linear_buf);
-	else
-		dma_cfg.s.adr = sg_phys(data->sg);
+	if (!host->big_dma_addr) {
+		if (data->sg_len > 1)
+			dma_cfg.s.adr = virt_to_phys(host->linear_buf);
+		else
+			dma_cfg.s.adr = sg_phys(data->sg);
+	}
 	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG, dma_cfg.u64);
-	trace_printk("MIO_NDF_DMA_CFG: %016llx\n", (unsigned long long)dma_cfg.u64);
+	octeon_mmc_dbg("MIO_NDF_DMA_CFG: %016llx\n", (unsigned long long)dma_cfg.u64);
+	if (host->big_dma_addr) {
+		u64 addr;
+		if (data->sg_len > 1)
+			addr = virt_to_phys(host->linear_buf);
+		else
+			addr = sg_phys(data->sg);
+		cvmx_write_csr(host->ndf_base + OCT_MIO_EMM_DMA_ADR, addr);
+		octeon_mmc_dbg("MIO_EMM_DMA_ADR: %016llx\n", (unsigned long long)addr);
+	}
 
 	emm_dma.u64 = 0;
 	emm_dma.s.bus_id = slot->bus_id;
@@ -572,7 +587,7 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	octeon_mmc_acquire_bus();
+	octeon_mmc_acquire_bus(host);
 
 	octeon_mmc_switch_to(slot);
 
@@ -700,7 +715,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	octeon_mmc_acquire_bus();
+	octeon_mmc_acquire_bus(host);
 
 	octeon_mmc_switch_to(slot);
 
@@ -791,7 +806,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		}
 	}
 out:
-	octeon_mmc_release_bus();
+	octeon_mmc_release_bus(host);
 }
 
 static int octeon_mmc_get_ro(struct mmc_host *mmc)
@@ -969,13 +984,13 @@ static int __init octeon_init_slot(struct octeon_mmc_host *host, int id,
 	slot->cached_rca = 1;
 
 	/* Only a single user of the bootbus at a time. */
-	octeon_mmc_acquire_bus();
+	octeon_mmc_acquire_bus(host);
 
 	octeon_mmc_switch_to(slot);
 	/* Initialize MMC Block. */
 	octeon_mmc_initlowlevel(slot, bus_width);
 
-	octeon_mmc_release_bus();
+	octeon_mmc_release_bus(host);
 
 	host->slot[id] = slot;
 	ret = mmc_add_host(mmc);
@@ -989,25 +1004,43 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 	union cvmx_mio_emm_cfg emm_cfg;
 	struct octeon_mmc_host *host;
 	struct resource	*res;
-	int mmc_irq, dma_irq;
+	void __iomem *base;
+	int mmc_irq[9];
+	int i;
 	int ret = 0;
 	struct device_node *node = pdev->dev.of_node;
 	int found = 0;
+	bool cn78xx_style;
+	u64 t;
 	enum of_gpio_flags f;
 
-	mmc_irq = platform_get_irq(pdev, 0);
-	if (mmc_irq < 0)
-		return mmc_irq;
-
-	dma_irq = platform_get_irq(pdev, 1);
-	if (dma_irq < 0)
-		return dma_irq;
-
 	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
 	if (!host) {
 		dev_err(&pdev->dev, "devm_kzalloc failed\n");
-		ret = -ENOMEM;
-		goto err;
+		return -ENOMEM;
+	}
+	cn78xx_style = of_device_is_compatible(node, "cavium,octeon-7890-mmc");
+	if (cn78xx_style) {
+		host->need_bus_lock = false;
+		host->big_dma_addr = true;
+		/*
+		 * First seven are the EMM_INT bits 0..6, then two for
+		 * the EMM_DMA_INT bits
+		 */
+		for (i = 0; i < 9; i++) {
+			mmc_irq[i] = platform_get_irq(pdev, i);
+			if (mmc_irq[i] < 0)
+				return mmc_irq[i];
+		}
+	} else {
+		host->need_bus_lock = true;
+		host->big_dma_addr = false;
+		/* First one is EMM second NDF_DMA */
+		for (i = 0; i < 2; i++) {
+			mmc_irq[i] = platform_get_irq(pdev, i);
+			if (mmc_irq[i] < 0)
+				return mmc_irq[i];
+		}
 	}
 	host->last_slot = -1;
 	if (bb_size > 512 && bb_size < (1 << 24))
@@ -1017,56 +1050,55 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 	host->linear_buf = devm_kzalloc(&pdev->dev, host->linear_buf_size, GFP_KERNEL);
 	if (!host->linear_buf) {
 		dev_err(&pdev->dev, "devm_kzalloc failed\n");
-		ret = -ENOMEM;
-		goto err;
+		return -ENOMEM;
 	}
 
 	host->pdev = pdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
-		dev_err(&pdev->dev, "Platform resource is missing\n");
-		ret = -ENXIO;
-		goto err;
-	}
-	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
-				     res->name)) {
-		dev_err(&pdev->dev, "request_mem_region 0 failed\n");
-		goto err;
-	}
-
-	host->base = (u64)devm_ioremap(&pdev->dev, res->start,
-				       resource_size(res));
-	if (!host->base) {
-		dev_err(&pdev->dev, "Platform resource0 is missing\n");
-		ret = -EINVAL;
-		goto err;
+		dev_err(&pdev->dev, "Platform resource[0] is missing\n");
+		return -ENXIO;
 	}
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+	host->base = (u64)base;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 	if (!res) {
-		dev_err(&pdev->dev, "Platform resource1 is missing\n");
+		dev_err(&pdev->dev, "Platform resource[1] is missing\n");
 		ret = -EINVAL;
 		goto err;
 	}
-	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
-				     res->name)) {
-		dev_err(&pdev->dev, "request_mem_region 1 failed\n");
-		goto err;
-	}
-	host->ndf_base = (u64)devm_ioremap(&pdev->dev, res->start,
-					   resource_size(res));
-	if (!host->ndf_base) {
-		dev_err(&pdev->dev, "Platform resource0 is missing\n");
-		ret = -EINVAL;
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		ret = PTR_ERR(base);
 		goto err;
 	}
-
-	ret = devm_request_irq(&pdev->dev, mmc_irq, octeon_mmc_interrupt,
-			       0, DRV_NAME, host);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Error: devm_request_irq %d\n", mmc_irq);
-		goto err;
+	host->ndf_base = (u64)base;
+	/*
+	 * Clear out any pending interrupts that may be left over from
+	 * bootloader.
+	 */
+	t = cvmx_read_csr(host->base + OCT_MIO_EMM_INT);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_INT, t);
+	if (cn78xx_style) {
+		for (i = 0; i < 7; i++) {
+			ret = devm_request_irq(&pdev->dev, mmc_irq[i], octeon_mmc_interrupt,
+					       0, DRV_NAME, host);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "Error: devm_request_irq %d\n", mmc_irq[i]);
+				goto err;
+			}
+		}
+	} else {
+		ret = devm_request_irq(&pdev->dev, mmc_irq[0], octeon_mmc_interrupt,
+				       0, DRV_NAME, host);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Error: devm_request_irq %d\n", mmc_irq[0]);
+			goto err;
+		}
 	}
 
 	ret = of_get_named_gpio_flags(node, "power-gpios", 0, &f);
@@ -1170,7 +1202,6 @@ err:
 
 static int octeon_mmc_remove(struct platform_device *pdev)
 {
-	union cvmx_mio_ndf_dma_int ndf_dma_int;
 	union cvmx_mio_ndf_dma_cfg ndf_dma_cfg;
 	struct octeon_mmc_host *host = platform_get_drvdata(pdev);
 
@@ -1186,11 +1217,6 @@ static int octeon_mmc_remove(struct platform_device *pdev)
 		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG,
 			       ndf_dma_cfg.u64);
 
-		/* Disable the interrupt */
-		ndf_dma_int.u64 = 0;
-		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT,
-			       ndf_dma_int.u64);
-
 		for (i = 0; i < OCTEON_MAX_MMC; i++) {
 			struct octeon_mmc_slot *slot;
 			slot = host->slot[i];
@@ -1225,6 +1251,9 @@ static struct of_device_id octeon_mmc_match[] = {
 	{
 		.compatible = "cavium,octeon-6130-mmc",
 	},
+	{
+		.compatible = "cavium,octeon-7890-mmc",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, octeon_mmc_match);
-- 
2.6.2

