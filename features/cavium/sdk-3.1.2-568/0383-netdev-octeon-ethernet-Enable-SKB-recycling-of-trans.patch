From e9410e33f2d818e7f547ed173a13e0d5ee52dac2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 6 Nov 2013 14:50:46 -0800
Subject: [PATCH 383/974] netdev: octeon-ethernet: Enable SKB recycling of
 transmitted packets.

New module parameter "octeon_recycle_tx" turns it on and off.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-defines.h |  2 +-
 drivers/net/ethernet/octeon/ethernet-tx.c      | 38 +++++++++++------------
 drivers/net/ethernet/octeon/ethernet-xmit.c    | 42 ++++++++++----------------
 drivers/net/ethernet/octeon/ethernet.c         |  4 +++
 drivers/net/ethernet/octeon/octeon-ethernet.h  |  1 +
 5 files changed, 39 insertions(+), 48 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-defines.h b/drivers/net/ethernet/octeon/ethernet-defines.h
index c6aedfa..4636eb5 100644
--- a/drivers/net/ethernet/octeon/ethernet-defines.h
+++ b/drivers/net/ethernet/octeon/ethernet-defines.h
@@ -76,7 +76,7 @@
 #ifdef CONFIG_NETFILTER
 #define REUSE_SKBUFFS_WITHOUT_FREE  0
 #else
-#define REUSE_SKBUFFS_WITHOUT_FREE  0
+#define REUSE_SKBUFFS_WITHOUT_FREE  1
 #endif
 
 #define USE_HW_TCPUDP_CHECKSUM      1
diff --git a/drivers/net/ethernet/octeon/ethernet-tx.c b/drivers/net/ethernet/octeon/ethernet-tx.c
index 9c700f9..cd8b1e8 100644
--- a/drivers/net/ethernet/octeon/ethernet-tx.c
+++ b/drivers/net/ethernet/octeon/ethernet-tx.c
@@ -27,6 +27,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
+#include <linux/skbuff.h>
 #include <linux/init.h>
 #include <linux/etherdevice.h>
 #include <linux/ip.h>
@@ -60,7 +61,6 @@
 #define GET_SKBUFF_QOS(skb) 0
 #endif
 
-#if REUSE_SKBUFFS_WITHOUT_FREE
 static bool cvm_oct_skb_ok_for_reuse(struct sk_buff *skb)
 {
 	unsigned char *fpa_head = cvm_oct_get_fpa_head(skb);
@@ -82,17 +82,30 @@ static bool cvm_oct_skb_ok_for_reuse(struct sk_buff *skb)
 	return true;
 }
 
+static void skb_recycle(struct sk_buff *skb)
+{
+	struct skb_shared_info *shinfo;
+
+	skb_release_head_state(skb);
+
+	shinfo = skb_shinfo(skb);
+	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	atomic_set(&shinfo->dataref, 1);
+
+	memset(skb, 0, offsetof(struct sk_buff, tail));
+	skb->data = skb->head + NET_SKB_PAD;
+	skb_reset_tail_pointer(skb);
+}
+
 static void cvm_oct_skb_prepare_for_reuse(struct sk_buff *skb)
 {
-	int r;
 	unsigned char *fpa_head = cvm_oct_get_fpa_head(skb);
 
 	skb->data_len = 0;
 	skb_frag_list_init(skb);
 
 	/* The check also resets all the fields. */
-	r = skb_recycle_check(skb, FPA_PACKET_POOL_SIZE);
-	WARN(!r, "SKB recycle logic fail\n");
+	skb_recycle(skb);
 
 	*(struct sk_buff **)(fpa_head - sizeof(void *)) = skb;
 	skb->truesize = sizeof(*skb) + skb_end_pointer(skb) - skb->head;
@@ -105,23 +118,6 @@ static inline void cvm_oct_set_back(struct sk_buff *skb,
 
 	hw_buffer->s.back = ((unsigned long)skb->data >> 7) - ((unsigned long)fpa_head >> 7);
 }
-#else
-static bool cvm_oct_skb_ok_for_reuse(struct sk_buff *skb)
-{
-	return false;
-}
-static void cvm_oct_skb_prepare_for_reuse(struct sk_buff *skb)
-{
-	/* Do nothing */
-}
-
-static inline void cvm_oct_set_back(struct sk_buff *skb,
-				    union cvmx_buf_ptr *hw_buffer)
-{
-	/* Do nothing. */
-}
-
-#endif
 
 #define CVM_OCT_LOCKLESS 1
 #include "ethernet-xmit.c"
diff --git a/drivers/net/ethernet/octeon/ethernet-xmit.c b/drivers/net/ethernet/octeon/ethernet-xmit.c
index 864c793..f19d8f2 100644
--- a/drivers/net/ethernet/octeon/ethernet-xmit.c
+++ b/drivers/net/ethernet/octeon/ethernet-xmit.c
@@ -63,6 +63,7 @@ CVM_OCT_XMIT
 	unsigned long flags;
 	cvmx_wqe_t *work = NULL;
 	bool timestamp_this_skb = false;
+	bool can_do_reuse = true;
 
 	/* Prefetch the private data structure.  It is larger than one
 	 * cache line.
@@ -167,7 +168,6 @@ CVM_OCT_XMIT
 		buffers_being_recycled = 1;
 	} else {
 		u64 *hw_buffer_list;
-		bool can_do_reuse = true;
 
 		work = cvmx_fpa_alloc(wqe_pool);
 		if (unlikely(!work)) {
@@ -211,42 +211,32 @@ CVM_OCT_XMIT
 		buffers_being_recycled = i;
 		pko_command.s.segs = hw_buffer.s.size;
 		pko_command.s.gather = 1;
-		if (!can_do_reuse)
-			goto dont_put_skbuff_in_hw;
 	}
 
-	if (unlikely(priv->tx_timestamp_hw &&
-		     (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))) {
+	if (unlikely(priv->tx_timestamp_hw) &&
+	    (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 		timestamp_this_skb = true;
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-		goto dont_put_skbuff_in_hw;
+		can_do_reuse = false;
 	}
+
 	/* See if we can put this skb in the FPA pool. Any strange
 	 * behavior from the Linux networking stack will most likely
 	 * be caused by a bug in the following code. If some field is
 	 * in use by the network stack and get carried over when a
 	 * buffer is reused, bad thing may happen.  If in doubt and
-	 * you dont need the absolute best performance, disable the
-	 * define REUSE_SKBUFFS_WITHOUT_FREE. The reuse of buffers has
-	 * shown a 25% increase in performance under some loads.
-	 */
-#if REUSE_SKBUFFS_WITHOUT_FREE
-	if (!cvm_oct_skb_ok_for_reuse(skb))
-		goto dont_put_skbuff_in_hw;
-	if (unlikely(skb_header_cloned(skb)))
-		goto dont_put_skbuff_in_hw;
-	if (unlikely(skb->destructor))
-		goto dont_put_skbuff_in_hw;
-
-
-	/* We can use this buffer in the FPA.  We don't need the FAU
-	 * update anymore
+	 * you dont need the absolute best performance, set recycle_tx
+	 * to zero . The reuse of buffers has shown a 25% increase in
+	 * performance under some loads.
 	 */
-	pko_command.s.dontfree = 0;
-
-#endif /* REUSE_SKBUFFS_WITHOUT_FREE */
-
-dont_put_skbuff_in_hw:
+	if (octeon_recycle_tx && can_do_reuse &&
+	    cvm_oct_skb_ok_for_reuse(skb) &&
+	    likely(!skb_header_cloned(skb)) &&
+	    likely(!skb->destructor))
+		/* We can use this buffer in the FPA.  We don't need
+		 * the FAU update anymore
+		 */
+		pko_command.s.dontfree = 0;
 
 	/* Check if we can use the hardware checksumming */
 	if (USE_HW_TCPUDP_CHECKSUM && (skb->protocol == htons(ETH_P_IP)) &&
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 76b98fb..930a047c 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -59,6 +59,10 @@ module_param(rx_cpu_factor, int, S_IRUGO | S_IWUSR | S_IWGRP);
 MODULE_PARM_DESC(rx_cpu_factor, "Control how many CPUs are used for packet reception.\n"
 		 "\tLarger numbers result in fewer CPUs used.");
 
+int octeon_recycle_tx = REUSE_SKBUFFS_WITHOUT_FREE;
+module_param(octeon_recycle_tx, int, S_IRUGO | S_IWUSR | S_IWGRP);
+MODULE_PARM_DESC(octeon_recycle_tx, "Allow hardware SKB recycling.");
+
 int num_packet_buffers = 1024;
 module_param(num_packet_buffers, int, 0444);
 MODULE_PARM_DESC(num_packet_buffers, "\n"
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index c541afc..f0efedc 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -164,6 +164,7 @@ void cvm_oct_mem_cleanup(void);
 extern const struct ethtool_ops cvm_oct_ethtool_ops;
 
 extern int rx_cpu_factor;
+extern int octeon_recycle_tx;
 extern int packet_pool;
 extern int wqe_pool;
 extern int output_pool;
-- 
2.6.2

