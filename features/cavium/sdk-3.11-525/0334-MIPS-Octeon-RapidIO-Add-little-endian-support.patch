From 1a07b157723610ecc0f393aa8aa572abeb532e41 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Tue, 12 Nov 2013 14:11:54 -0800
Subject: [PATCH 334/518] MIPS: Octeon: RapidIO: Add little endian support.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 636368fb2d4936e5dbcd3c0101b3de3ccff72bca
Description:

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig               |  1 -
 arch/mips/cavium-octeon/executive/cvmx-srio.c | 16 ++++++++++++++++
 drivers/net/ethernet/octeon/ethernet-napi.c   |  1 +
 drivers/net/ethernet/octeon/ethernet-srio.c   |  6 +++---
 4 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 5da5486..eed2e3a 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -172,7 +172,6 @@ config CAVIUM_OCTEON_NAND
 
 config CAVIUM_OCTEON_RAPIDIO
 	bool "Enable support for Octeon Serial Rapid IO"
-	depends on !CPU_LITTLE_ENDIAN
 	select RAPIDIO
 	select OCTEON_ETHERNET_MEM
 	help
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
index 88a4563..8a2bfce 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-srio.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -967,6 +967,14 @@ int _cvmx_srio_config_read32(int srio_port, int srcid_index, int destid, int is1
 				cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, (unsigned int)offset);
 
 			/* Finally do the maintenance read to complete the config request */
+#ifdef __LITTLE_ENDIAN
+			/*
+			 * When running in little endian mode, the cpu xor's bit
+			 * 2 of the address. We need to xor it here to cancel it
+			 * out.
+			 */
+			physical ^= 0x4;
+#endif
 			*result = cvmx_read64_uint32(CVMX_ADD_IO_SEG(physical));
 			cvmx_srio_physical_unmap(physical, 4);
 
@@ -1150,6 +1158,14 @@ int _cvmx_srio_config_write32(int srio_port, int srcid_index, int destid, int is
 					     (unsigned int)data);
 
 			/* Finally do the maintenance write to complete the config request */
+#ifdef __LITTLE_ENDIAN
+			/*
+			 * When running in little endian mode, the cpu xor's bit
+			 * 2 of the address. We need to xor it here to cancel it
+			 * out.
+			 */
+			physical ^= 0x4;
+#endif
 			cvmx_write64_uint32(CVMX_ADD_IO_SEG(physical), data);
 			return cvmx_srio_physical_unmap(physical, 4);
 #else
diff --git a/drivers/net/ethernet/octeon/ethernet-napi.c b/drivers/net/ethernet/octeon/ethernet-napi.c
index 8608598..b44929b 100644
--- a/drivers/net/ethernet/octeon/ethernet-napi.c
+++ b/drivers/net/ethernet/octeon/ethernet-napi.c
@@ -338,6 +338,7 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 		if (!CVM_OCT_NAPI_HAS_CN68XX_SSO && unlikely(priv == NULL)) {
 			const struct cvmx_srio_rx_message_header *rx_header =
 				(const struct cvmx_srio_rx_message_header *)skb->data;
+			*(u64 *)rx_header = be64_to_cpu(*(u64 *)rx_header);
 			priv = cvm_oct_by_srio_mbox[(port - 40) >> 1][rx_header->word0.s.mbox];
 		}
 
diff --git a/drivers/net/ethernet/octeon/ethernet-srio.c b/drivers/net/ethernet/octeon/ethernet-srio.c
index ad98a76..c112e16 100644
--- a/drivers/net/ethernet/octeon/ethernet-srio.c
+++ b/drivers/net/ethernet/octeon/ethernet-srio.c
@@ -140,7 +140,7 @@ int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	/* Extract the destination MAC address from the packet */
-	dest_mac = *(u64 *)skb->data >> 16;
+	dest_mac = cpu_to_be64(*(u64 *)skb->data >> 16);
 
 	/* If this is a broadcast/multicast we must manually send to everyone */
 	if (dest_mac>>40) {
@@ -155,7 +155,7 @@ int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
 			new_skb = skb_copy(skb, GFP_ATOMIC);
 			if (new_skb) {
 				tx_header.s.did = t->destid;
-				*(u64 *)__skb_push(new_skb, 8) = tx_header.u64;
+				*(u64 *)__skb_push(new_skb, 8) = cpu_to_be64(tx_header.u64);
 				cvm_oct_xmit(new_skb, dev);
 			} else {
 				netdev_dbg(dev, "SKB allocation failed\n");
@@ -185,7 +185,7 @@ int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
 
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += skb->len;
-		*(u64 *)__skb_push(skb, 8) = tx_header.u64;
+		*(u64 *)__skb_push(skb, 8) = cpu_to_be64(tx_header.u64);
 		return cvm_oct_xmit(skb, dev);
 	}
 }
-- 
1.9.1

