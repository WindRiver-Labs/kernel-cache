From 63f475d53a71a671620b4a7d1531c78aeb56e3cb Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Tue, 6 Aug 2013 12:15:01 -0700
Subject: [PATCH 185/518] netdev: octeon-ethernet: Add common module for
 setting mac address

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 8d3e4ec43d0cc43e44fa19aa545686398e115044
Description:

Moved setting of mac address and RX filter to a common place.
Modified mgmt and ethernet driver to use this code.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/Kconfig           |   5 +
 drivers/net/ethernet/octeon/Makefile          |   1 +
 drivers/net/ethernet/octeon/ethernet.c        | 129 ++++++----------------
 drivers/net/ethernet/octeon/octeon-ethernet.h |   3 +
 drivers/net/ethernet/octeon/octeon_common.c   | 152 ++++++++++++++++++++++++++
 drivers/net/ethernet/octeon/octeon_common.h   |  16 +++
 drivers/net/ethernet/octeon/octeon_mgmt.c     |  94 +---------------
 7 files changed, 214 insertions(+), 186 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/octeon_common.c
 create mode 100644 drivers/net/ethernet/octeon/octeon_common.h

diff --git a/drivers/net/ethernet/octeon/Kconfig b/drivers/net/ethernet/octeon/Kconfig
index 2402fff..172a10e 100644
--- a/drivers/net/ethernet/octeon/Kconfig
+++ b/drivers/net/ethernet/octeon/Kconfig
@@ -8,6 +8,7 @@ config OCTEON_ETHERNET
 	select MDIO_OCTEON
 	select NET_VENDOR_OCTEON
 	select OCTEON_ETHERNET_MEM
+	select OCTEON_ETHERNET_COMMON
 	help
 	  This driver supports the builtin ethernet ports on Cavium
 	  Inc.' products in the Octeon family. This driver supports the
@@ -39,6 +40,7 @@ config OCTEON_MGMT_ETHERNET
 	select PHYLIB
 	select MDIO_OCTEON
 	select NET_VENDOR_OCTEON
+	select OCTEON_ETHERNET_COMMON
 	default y
 	---help---
 	  This option enables the ethernet driver for the management
@@ -47,3 +49,6 @@ config OCTEON_MGMT_ETHERNET
 
 config NET_VENDOR_OCTEON
 	bool
+
+config OCTEON_ETHERNET_COMMON
+	tristate
diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 9c1c7f8..4f37869 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
 obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET) +=  octeon-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET_MEM) += ethernet-mem.o
+obj-$(CONFIG_OCTEON_ETHERNET_COMMON) += octeon_common.o
 
 octeon-ethernet-objs := ethernet.o
 octeon-ethernet-objs += ethernet-mdio.o
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index eebe6e5..86a23bf 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -41,6 +41,7 @@
 
 #include "ethernet-defines.h"
 #include "octeon-ethernet.h"
+#include "octeon_common.h"
 
 #include <asm/octeon/cvmx-pip.h>
 #include <asm/octeon/cvmx-pko.h>
@@ -519,104 +520,34 @@ static int cvm_oct_common_change_mtu(struct net_device *dev, int new_mtu)
 }
 
 /**
- * cvm_oct_common_set_multicast_list - set the multicast list
+ * Set RX filtering
  * @dev:    Device to work on
  */
-static void cvm_oct_common_set_multicast_list(struct net_device *dev)
+static void cvm_oct_set_rx_filter(struct net_device *dev)
 {
-	union cvmx_gmxx_prtx_cfg gmx_cfg;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 
-	if (priv->has_gmx_regs) {
-		union cvmx_gmxx_rxx_adr_ctl control;
-		control.u64 = 0;
-		control.s.bcst = 1;	/* Allow broadcast MAC addresses */
-
-		if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI) ||
-		    (dev->flags & IFF_PROMISC))
-			/* Force accept multicast packets */
-			control.s.mcst = 2;
-		else
-			/* Force reject multicat packets */
-			control.s.mcst = 1;
-
-		if (dev->flags & IFF_PROMISC)
-			/* Reject matches if promisc. Since CAM is
-			 * shut off, should accept everything.
-			 */
-			control.s.cam_mode = 0;
-		else
-			/* Filter packets based on the CAM */
-			control.s.cam_mode = 1;
-
-		gmx_cfg.u64 =
-		    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface));
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface),
-			       gmx_cfg.u64 & ~1ull);
-
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CTL(priv->interface_port, priv->interface),
-			       control.u64);
-		if (dev->flags & IFF_PROMISC)
-			cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM_EN(priv->interface_port, priv->interface), 0);
-		else
-			cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM_EN(priv->interface_port, priv->interface), 1);
-
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface),
-			       gmx_cfg.u64);
-	}
+	if (priv->gmx_base)
+		cvm_oct_common_set_rx_filtering(dev, priv->gmx_base,
+					 &priv->poll_lock);
 }
 
 /**
- * cvm_oct_common_set_mac_address - set the hardware MAC address for a device
+ * Set the hardware MAC address for a device
  * @dev:    The device in question.
  * @addr:   Address structure to change it too.
  *
  * Returns Zero on success
  */
-static int cvm_oct_set_mac_filter(struct net_device *dev)
+static int cvm_oct_set_mac_address(struct net_device *dev, void *addr)
 {
 	struct octeon_ethernet *priv = netdev_priv(dev);
-	union cvmx_gmxx_prtx_cfg gmx_cfg;
 
-	if (priv->has_gmx_regs) {
-		int i;
-		u8 *ptr = dev->dev_addr;
-		u64 mac = 0;
-		for (i = 0; i < 6; i++)
-			mac = (mac << 8) | (u64)ptr[i];
-
-		gmx_cfg.u64 =
-		    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface));
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface),
-			       gmx_cfg.u64 & ~1ull);
-
-		cvmx_write_csr(CVMX_GMXX_SMACX(priv->interface_port, priv->interface), mac);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM0(priv->interface_port, priv->interface),
-			       ptr[0]);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM1(priv->interface_port, priv->interface),
-			       ptr[1]);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM2(priv->interface_port, priv->interface),
-			       ptr[2]);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM3(priv->interface_port, priv->interface),
-			       ptr[3]);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM4(priv->interface_port, priv->interface),
-			       ptr[4]);
-		cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM5(priv->interface_port, priv->interface),
-			       ptr[5]);
-		cvm_oct_common_set_multicast_list(dev);
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface),
-			       gmx_cfg.u64);
-	}
-	return 0;
-}
-
-static int cvm_oct_common_set_mac_address(struct net_device *dev, void *addr)
-{
-	int r = eth_mac_addr(dev, addr);
+	if (priv->gmx_base)
+		cvm_oct_common_set_mac_address(dev, addr, priv->gmx_base,
+					 &priv->poll_lock);
 
-	if (r)
-		return r;
-	return cvm_oct_set_mac_filter(dev);
+	return 0;
 }
 
 /**
@@ -631,6 +562,7 @@ int cvm_oct_common_init(struct net_device *dev)
 	cvmx_pko_port_status_t tx_status;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	const u8 *mac = NULL;
+	struct sockaddr sa;
 
 	if (priv->of_node)
 		mac = of_get_mac_address(priv->of_node);
@@ -652,7 +584,8 @@ int cvm_oct_common_init(struct net_device *dev)
 	dev->features |= NETIF_F_LLTX;
 	SET_ETHTOOL_OPS(dev, &cvm_oct_ethtool_ops);
 
-	cvm_oct_set_mac_filter(dev);
+	memcpy(sa.sa_data, dev->dev_addr, ETH_ALEN);
+	cvm_oct_common_set_mac_address(dev, &sa, priv->gmx_base, &priv->poll_lock);
 	dev->netdev_ops->ndo_change_mtu(dev, dev->mtu);
 
 	spin_lock_irqsave(&cvm_oct_tx_stat_lock, flags);
@@ -671,8 +604,8 @@ int cvm_oct_common_init(struct net_device *dev)
 static const struct net_device_ops cvm_oct_npi_netdev_ops = {
 	.ndo_init		= cvm_oct_common_init,
 	.ndo_start_xmit		= cvm_oct_xmit,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -688,8 +621,8 @@ static const struct net_device_ops cvm_oct_sgmii_netdev_ops = {
 	.ndo_open		= cvm_oct_sgmii_open,
 	.ndo_stop		= cvm_oct_sgmii_stop,
 	.ndo_start_xmit		= cvm_oct_xmit,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -703,8 +636,8 @@ static const struct net_device_ops cvm_oct_sgmii_lockless_netdev_ops = {
 	.ndo_open		= cvm_oct_sgmii_open,
 	.ndo_stop		= cvm_oct_sgmii_stop,
 	.ndo_start_xmit		= cvm_oct_xmit_lockless,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -717,8 +650,8 @@ static const struct net_device_ops cvm_oct_spi_netdev_ops = {
 	.ndo_uninit		= cvm_oct_spi_uninit,
 	.ndo_open		= cvm_oct_phy_setup_device,
 	.ndo_start_xmit		= cvm_oct_xmit,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -731,8 +664,8 @@ static const struct net_device_ops cvm_oct_spi_lockless_netdev_ops = {
 	.ndo_uninit		= cvm_oct_spi_uninit,
 	.ndo_open		= cvm_oct_phy_setup_device,
 	.ndo_start_xmit		= cvm_oct_xmit_lockless,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -745,8 +678,8 @@ static const struct net_device_ops cvm_oct_rgmii_netdev_ops = {
 	.ndo_open		= cvm_oct_rgmii_open,
 	.ndo_stop		= cvm_oct_rgmii_stop,
 	.ndo_start_xmit		= cvm_oct_xmit,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -759,8 +692,8 @@ static const struct net_device_ops cvm_oct_rgmii_lockless_netdev_ops = {
 	.ndo_open		= cvm_oct_rgmii_open,
 	.ndo_stop		= cvm_oct_rgmii_stop,
 	.ndo_start_xmit		= cvm_oct_xmit_lockless,
-	.ndo_set_rx_mode	= cvm_oct_common_set_multicast_list,
-	.ndo_set_mac_address	= cvm_oct_common_set_mac_address,
+	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
+	.ndo_set_mac_address	= cvm_oct_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
 	.ndo_change_mtu		= cvm_oct_common_change_mtu,
 	.ndo_get_stats		= cvm_oct_common_get_stats,
@@ -1014,6 +947,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 			priv->netdev = dev;
 			priv->interface = interface;
 			priv->interface_port = interface_port;
+			priv->gmx_base = 0;
 			spin_lock_init(&priv->poll_lock);
 			INIT_DELAYED_WORK(&priv->port_periodic_work,
 					  cvm_oct_periodic_worker);
@@ -1078,6 +1012,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 				priv->tx_lockless = priv->tx_multiple_queues && !disable_lockless_pko;
 				dev->netdev_ops = priv->tx_lockless ?
 					&cvm_oct_sgmii_lockless_netdev_ops : &cvm_oct_sgmii_netdev_ops;
+				priv->gmx_base = CVMX_GMXX_RXX_INT_REG(interface_port, interface);
 				priv->has_gmx_regs = 1;
 				strcpy(dev->name, "xaui%d");
 				break;
@@ -1092,6 +1027,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 				priv->tx_lockless = priv->tx_multiple_queues && !disable_lockless_pko;
 				dev->netdev_ops = priv->tx_lockless ?
 					&cvm_oct_sgmii_lockless_netdev_ops : &cvm_oct_sgmii_netdev_ops;
+				priv->gmx_base = CVMX_GMXX_RXX_INT_REG(interface_port, interface);
 				priv->has_gmx_regs = 1;
 				strcpy(dev->name, "eth%d");
 				break;
@@ -1108,6 +1044,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 				priv->tx_lockless = priv->tx_multiple_queues && !disable_lockless_pko;
 				dev->netdev_ops = priv->tx_lockless ?
 					&cvm_oct_rgmii_lockless_netdev_ops : &cvm_oct_rgmii_netdev_ops;
+				priv->gmx_base = CVMX_GMXX_RXX_INT_REG(interface_port, interface);
 				priv->has_gmx_regs = 1;
 				strcpy(dev->name, "eth%d");
 				break;
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index a7bfe57..fc9cd9d 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -67,6 +67,9 @@ struct octeon_ethernet {
 	unsigned int tx_multiple_queues:1;
 	unsigned int tx_lockless:1;
 
+	/* Base address for accessing GMX registers */
+	u64 gmx_base;
+
 	/* Optional intecept callback defined above */
 	cvm_oct_callback_t      intercept_cb;
 
diff --git a/drivers/net/ethernet/octeon/octeon_common.c b/drivers/net/ethernet/octeon/octeon_common.c
new file mode 100644
index 0000000..5a944fd
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon_common.c
@@ -0,0 +1,152 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2013 Cavium, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
+#include <asm/octeon/octeon.h>
+#include "octeon_common.h"
+
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-agl-defs.h>
+
+#define GMX_PRT_CFG                 0x10
+
+#define GMX_RX_ADR_CTL              0x100
+#define GMX_RX_ADR_CAM_EN           0x108
+#define GMX_RX_ADR_CAM0             0x180
+#define GMX_RX_ADR_CAM1             0x188
+#define GMX_RX_ADR_CAM2             0x190
+#define GMX_RX_ADR_CAM3             0x198
+#define GMX_RX_ADR_CAM4             0x1a0
+#define GMX_RX_ADR_CAM5             0x1a8
+
+
+struct cvm_oct_cam_state {
+	u64 cam[6];
+	u64 cam_mask;
+	int cam_index;
+};
+
+static void cvm_oct_cam_state_add(struct cvm_oct_cam_state *cs, unsigned char *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		cs->cam[i] |= (u64)addr[i] << (8 * (cs->cam_index));
+	cs->cam_mask |= (1ULL << cs->cam_index);
+	cs->cam_index++;
+}
+
+/**
+ * Set the multicast list
+ * @dev      : Device to work on
+ * @base_reg : Base address of register bank
+ * @rx_lock  : For locking
+ *
+ */
+void cvm_oct_common_set_rx_filtering(struct net_device *dev, u64 base_reg, spinlock_t *lock)
+{
+	u64 reg, saved_reg;
+	unsigned long flags;
+	unsigned int cam_mode = 1; /* 1 - Accept on CAM match */
+	unsigned int multicast_mode = 1; /* 1 - Reject all multicast.  */
+	struct cvm_oct_cam_state cam_state;
+	struct netdev_hw_addr *ha;
+	int available_cam_entries;
+
+	if (base_reg == 0)
+		return;
+
+	memset(&cam_state, 0, sizeof(cam_state));
+
+	if ((dev->flags & IFF_PROMISC) || dev->uc.count > 7) {
+		cam_mode = 0;
+		available_cam_entries = 8;
+	} else {
+		/* One CAM entry for the primary address, leaves seven
+		 * for the secondary addresses.
+		 */
+		available_cam_entries = 7 - dev->uc.count;
+	}
+
+	if (dev->flags & IFF_MULTICAST) {
+		if (cam_mode == 0 || (dev->flags & IFF_ALLMULTI) ||
+		    netdev_mc_count(dev) > available_cam_entries)
+			multicast_mode = 2; /* 2 - Accept all multicast.  */
+		else
+			multicast_mode = 0; /* 0 - Use CAM.  */
+	}
+
+	if (cam_mode == 1) {
+		/* Add primary address. */
+		cvm_oct_cam_state_add(&cam_state, dev->dev_addr);
+		netdev_for_each_uc_addr(ha, dev)
+			cvm_oct_cam_state_add(&cam_state, ha->addr);
+	}
+	if (multicast_mode == 0) {
+		netdev_for_each_mc_addr(ha, dev)
+			cvm_oct_cam_state_add(&cam_state, ha->addr);
+	}
+
+	/* Disable packet I/O. */
+	spin_lock_irqsave(lock, flags);
+
+	reg = cvmx_read_csr(base_reg + GMX_PRT_CFG);
+	saved_reg = reg;
+	cvmx_write_csr(base_reg + GMX_PRT_CFG, reg & ~1ull);
+
+	reg = 0;
+	reg |= (cam_mode << 3) & 0x8;
+	reg |= (multicast_mode << 1) & 0x6;
+	reg |= 1;     /* Allow broadcast */
+
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CTL, reg);
+
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM0, cam_state.cam[0]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM1, cam_state.cam[1]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM2, cam_state.cam[2]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM3, cam_state.cam[3]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM4, cam_state.cam[4]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM5, cam_state.cam[5]);
+	cvmx_write_csr(base_reg + GMX_RX_ADR_CAM_EN, cam_state.cam_mask);
+
+	/* Restore packet I/O. */
+	cvmx_write_csr(base_reg + GMX_PRT_CFG, saved_reg);
+
+	spin_unlock_irqrestore(lock, flags);
+}
+EXPORT_SYMBOL(cvm_oct_common_set_rx_filtering);
+
+
+/**
+ * Set the hardware MAC address for a device.
+ * @dev      : Device to work on
+ * @addr     : Address to change it to
+ * @base_reg : Base address of register bank
+ * @rx_lock  : For locking
+ *
+ * Returns zero on success
+ */
+int cvm_oct_common_set_mac_address(struct net_device *dev, void *addr,
+	 u64 base_reg, spinlock_t *lock)
+{
+	int r = eth_mac_addr(dev, addr);
+
+	if (r)
+		return r;
+
+	cvm_oct_common_set_rx_filtering(dev, base_reg, lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvm_oct_common_set_mac_address);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cavium, Inc. Common Network Driver");
diff --git a/drivers/net/ethernet/octeon/octeon_common.h b/drivers/net/ethernet/octeon/octeon_common.h
new file mode 100644
index 0000000..f1dcdae
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon_common.h
@@ -0,0 +1,16 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2013 Cavium, Inc.
+ */
+#ifndef _ETHERNET_OCTEON_OCTEON_COMMON_H
+#define _ETHERNET_OCTEON_OCTEON_COMMON_H
+
+extern void cvm_oct_common_set_rx_filtering(struct net_device *dev, u64 base_reg,
+					spinlock_t *lock);
+
+extern int cvm_oct_common_set_mac_address(struct net_device *dev, void *addr,
+					u64 base_reg, spinlock_t *lock);
+#endif
diff --git a/drivers/net/ethernet/octeon/octeon_mgmt.c b/drivers/net/ethernet/octeon/octeon_mgmt.c
index 3ffdfa2..7577c63 100644
--- a/drivers/net/ethernet/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/octeon/octeon_mgmt.c
@@ -26,6 +26,7 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-mixx-defs.h>
 #include <asm/octeon/cvmx-agl-defs.h>
+#include "octeon_common.h"
 
 #define DRV_NAME "octeon_mgmt"
 #define DRV_VERSION "2.0"
@@ -559,105 +560,18 @@ static void octeon_mgmt_reset_hw(struct octeon_mgmt *p)
 			 (unsigned long long)agl_gmx_bist.u64);
 }
 
-struct octeon_mgmt_cam_state {
-	u64 cam[6];
-	u64 cam_mask;
-	int cam_index;
-};
-
-static void octeon_mgmt_cam_state_add(struct octeon_mgmt_cam_state *cs,
-				      unsigned char *addr)
-{
-	int i;
-
-	for (i = 0; i < 6; i++)
-		cs->cam[i] |= (u64)addr[i] << (8 * (cs->cam_index));
-	cs->cam_mask |= (1ULL << cs->cam_index);
-	cs->cam_index++;
-}
-
 static void octeon_mgmt_set_rx_filtering(struct net_device *netdev)
 {
 	struct octeon_mgmt *p = netdev_priv(netdev);
-	union cvmx_agl_gmx_rxx_adr_ctl adr_ctl;
-	union cvmx_agl_gmx_prtx_cfg agl_gmx_prtx;
-	unsigned long flags;
-	unsigned int prev_packet_enable;
-	unsigned int cam_mode = 1; /* 1 - Accept on CAM match */
-	unsigned int multicast_mode = 1; /* 1 - Reject all multicast.  */
-	struct octeon_mgmt_cam_state cam_state;
-	struct netdev_hw_addr *ha;
-	int available_cam_entries;
-
-	memset(&cam_state, 0, sizeof(cam_state));
-
-	if ((netdev->flags & IFF_PROMISC) || netdev->uc.count > 7) {
-		cam_mode = 0;
-		available_cam_entries = 8;
-	} else {
-		/* One CAM entry for the primary address, leaves seven
-		 * for the secondary addresses.
-		 */
-		available_cam_entries = 7 - netdev->uc.count;
-	}
 
-	if (netdev->flags & IFF_MULTICAST) {
-		if (cam_mode == 0 || (netdev->flags & IFF_ALLMULTI) ||
-		    netdev_mc_count(netdev) > available_cam_entries)
-			multicast_mode = 2; /* 2 - Accept all multicast.  */
-		else
-			multicast_mode = 0; /* 0 - Use CAM.  */
-	}
-
-	if (cam_mode == 1) {
-		/* Add primary address. */
-		octeon_mgmt_cam_state_add(&cam_state, netdev->dev_addr);
-		netdev_for_each_uc_addr(ha, netdev)
-			octeon_mgmt_cam_state_add(&cam_state, ha->addr);
-	}
-	if (multicast_mode == 0) {
-		netdev_for_each_mc_addr(ha, netdev)
-			octeon_mgmt_cam_state_add(&cam_state, ha->addr);
-	}
-
-	spin_lock_irqsave(&p->lock, flags);
-
-	/* Disable packet I/O. */
-	agl_gmx_prtx.u64 = cvmx_read_csr(p->agl + AGL_GMX_PRT_CFG);
-	prev_packet_enable = agl_gmx_prtx.s.en;
-	agl_gmx_prtx.s.en = 0;
-	cvmx_write_csr(p->agl + AGL_GMX_PRT_CFG, agl_gmx_prtx.u64);
-
-	adr_ctl.u64 = 0;
-	adr_ctl.s.cam_mode = cam_mode;
-	adr_ctl.s.mcst = multicast_mode;
-	adr_ctl.s.bcst = 1;     /* Allow broadcast */
-
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CTL, adr_ctl.u64);
-
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM0, cam_state.cam[0]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM1, cam_state.cam[1]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM2, cam_state.cam[2]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM3, cam_state.cam[3]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM4, cam_state.cam[4]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM5, cam_state.cam[5]);
-	cvmx_write_csr(p->agl + AGL_GMX_RX_ADR_CAM_EN, cam_state.cam_mask);
-
-	/* Restore packet I/O. */
-	agl_gmx_prtx.s.en = prev_packet_enable;
-	cvmx_write_csr(p->agl + AGL_GMX_PRT_CFG, agl_gmx_prtx.u64);
-
-	spin_unlock_irqrestore(&p->lock, flags);
+	cvm_oct_common_set_rx_filtering(netdev, p->agl, &p->lock);
 }
 
 static int octeon_mgmt_set_mac_address(struct net_device *netdev, void *addr)
 {
-	int r = eth_mac_addr(netdev, addr);
-
-	if (r)
-		return r;
+	struct octeon_mgmt *p = netdev_priv(netdev);
 
-	octeon_mgmt_set_rx_filtering(netdev);
+	cvm_oct_common_set_mac_address(netdev, addr, p->agl, &p->lock);
 
 	return 0;
 }
-- 
1.9.1

