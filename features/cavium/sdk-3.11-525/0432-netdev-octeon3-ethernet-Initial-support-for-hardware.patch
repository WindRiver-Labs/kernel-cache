From 681ecde659004d0150e226dacd0b2af4403fd73e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 22 Apr 2014 15:19:52 -0700
Subject: [PATCH 432/518] netdev: octeon3-ethernet: Initial support for
 hardware checksumming.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: fb46975147339bde4a76b9fb0e923e8c5afc4ac9
Description:

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 64 +++++++++++++++++++++++++-
 1 file changed, 62 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index a617735..99291cd 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -31,6 +31,8 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/platform_device.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
@@ -364,6 +366,11 @@ static int octeon3_eth_rx_one(struct octeon3_ethernet *priv)
 	skb = octeon3_eth_work_to_skb(work);
 	segments = work->word0.bufs;
 	ret = segments;
+
+	if (unlikely(work->word2.err_level <= CVMX_PKI_ERRLEV_LA &&
+		     work->word2.err_code != CVMX_PKI_OPCODE_RE_NONE))
+		goto drop; /* FIXME:  Free chained buffers in this case */
+
 	packet_len = work->word1.len;
 	packet_ptr = work->packet_ptr;
 	data = phys_to_virt(packet_ptr.addr);
@@ -404,11 +411,23 @@ static int octeon3_eth_rx_one(struct octeon3_ethernet *priv)
 		}
 	}
 	if (likely(priv->netdev->flags & IFF_UP)) {
+		skb_checksum_none_assert(skb);
 		skb->protocol = eth_type_trans(skb, priv->netdev);
 		skb->dev = priv->netdev;
-		skb->ip_summed = CHECKSUM_NONE;
+		if (priv->netdev->features & NETIF_F_RXCSUM) {
+			if ((work->word2.lc_hdr_type == CVMX_PKI_LTYPE_IPV4 ||
+			     work->word2.lc_hdr_type == CVMX_PKI_LTYPE_IPV6) &&
+			    (work->word2.lf_hdr_type == CVMX_PKI_LTYPE_TCP ||
+			     work->word2.lf_hdr_type == CVMX_PKI_LTYPE_UDP ||
+			     work->word2.lf_hdr_type == CVMX_PKI_LTYPE_SCTP))
+				if (work->word2.err_code == 0)
+					skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+
+		}
 		netif_receive_skb(skb);
 	} else {
+	drop:
 		/* Drop any packet received for a device that isn't up */
 		atomic64_add(1, (atomic64_t *)&priv->netdev->stats.rx_dropped);
 		dev_kfree_skb_any(skb);
@@ -457,6 +476,8 @@ static int octeon3_eth_napi(struct napi_struct *napi, int budget)
 	return rx_count;
 }
 
+#define BROKEN_SIMULATOR_CSUM 1
+
 static int octeon3_eth_ndo_init(struct net_device *netdev)
 {
 	struct octeon3_ethernet *priv = netdev_priv(netdev);
@@ -464,7 +485,17 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 
 	netif_carrier_off(netdev);
 
-	netdev->features |= NETIF_F_SG | NETIF_F_FRAGLIST;
+	netdev->features |=
+		NETIF_F_SG |
+		NETIF_F_FRAGLIST |
+		NETIF_F_RXCSUM
+#ifndef BROKEN_SIMULATOR_CSUM
+		|
+		NETIF_F_IP_CSUM |
+		NETIF_F_IPV6_CSUM |
+		NETIF_F_SCTP_CSUM
+#endif
+		;
 
 	netif_napi_add(netdev, &priv->napi, octeon3_eth_napi, 32);
 	napi_enable(&priv->napi);
@@ -540,6 +571,7 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	union cvmx_pko_send_mem send_mem;
 	union cvmx_pko_lmtdma_data lmtdma_data;
 	union cvmx_pko_query_rtn query_rtn;
+	u8 l4_hdr = 0;
 	long backlog;
 	int frag_count;
 	int head_len, i;
@@ -579,6 +611,34 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	send_hdr.s.df = 1; /* Don't automatically free to FPA */
 	send_hdr.s.total = skb->len;
 
+#ifndef BROKEN_SIMULATOR_CSUM
+	switch (skb->protocol) {
+	case __constant_htons(ETH_P_IP):
+		send_hdr.s.l3ptr = ETH_HLEN;
+		send_hdr.s.ckl3 = 1;
+		l4_hdr = ip_hdr(skb)->protocol;
+		break;
+	case __constant_htons(ETH_P_IPV6):
+		l4_hdr = ipv6_hdr(skb)->nexthdr;
+		break;
+	default:
+		break;
+	}
+#endif
+	switch (l4_hdr) {
+	case IPPROTO_TCP:
+	case IPPROTO_SCTP:
+	case IPPROTO_UDP:
+		if (skb_transport_header_was_set(skb)) {
+			int l4ptr = skb_transport_header(skb) - skb->data;
+			send_hdr.s.l4ptr = l4ptr;
+			send_hdr.s.ckl4 = 1;
+		}
+		break;
+	default:
+		break;
+	}
+
 	cvmx_scratch_write64(scr_off, send_hdr.u64);
 	scr_off += sizeof(send_hdr);
 
-- 
1.9.1

