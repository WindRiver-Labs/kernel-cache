From ab41e4b3019be5ac354248719c4797157df7731d Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Tue, 27 May 2014 10:56:56 -0700
Subject: [PATCH 497/518] mmc: octeon_mmc: correct memcpy of short transfer

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 9a3f2a7dbd50f9189c8f769a32ab8627f5e0bda0
Description:

Transfers > 512b but < 256kB were being over-copied.
Also expose actual bb_size value in sysfs

Signed-off-by: Peter Swain <pswain@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index 170496f..2f14bae 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -458,7 +458,7 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 			req->data->bytes_xfered = req->data->blocks * req->data->blksz;
 			if (!(req->data->flags & MMC_DATA_WRITE) && req->data->sg_len > 1) {
 				size_t r = sg_copy_from_buffer(req->data->sg, req->data->sg_len,
-							       host->linear_buf, host->linear_buf_size);
+						   host->linear_buf, req->data->bytes_xfered);
 				WARN_ON(r != req->data->bytes_xfered);
 			}
 		}
@@ -603,7 +603,7 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 
 	if ((data->flags & MMC_DATA_WRITE) && data->sg_len > 1) {
 		size_t r = sg_copy_to_buffer(data->sg, data->sg_len,
-					     host->linear_buf, host->linear_buf_size);
+			 host->linear_buf, data->blksz * data->blocks);
 		WARN_ON(data->blksz * data->blocks != r);
 	}
 
@@ -1175,11 +1175,12 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 		}
 	}
 	host->last_slot = -1;
-	if (bb_size > 512 && bb_size < (1 << 24))
-		host->linear_buf_size = bb_size;
-	else
-		host->linear_buf_size = 1 << 18;
+
+	if (bb_size < 512 || bb_size >= (1 << 24))
+		bb_size = 1 << 18;
+	host->linear_buf_size = bb_size;
 	host->linear_buf = devm_kzalloc(&pdev->dev, host->linear_buf_size, GFP_KERNEL);
+
 	if (!host->linear_buf) {
 		dev_err(&pdev->dev, "devm_kzalloc failed\n");
 		return -ENOMEM;
-- 
1.9.1

