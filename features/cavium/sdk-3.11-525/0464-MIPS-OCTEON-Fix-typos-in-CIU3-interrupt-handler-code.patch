From 6c0262f390816d057a89ee69916dc3564ee06ac4 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 9 May 2014 13:18:03 -0400
Subject: [PATCH 464/518] MIPS: OCTEON: Fix typos in CIU3 interrupt handler
 code.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 04a6cd7ac055ebc29f3ce0f79cc9c91cd8949c52
Description:

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c  | 25 ++++++++++++++++++-------
 arch/mips/include/asm/octeon/octeon.h |  1 +
 2 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index cc9a5b8..1522da5 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -41,6 +41,7 @@ static DEFINE_PER_CPU(struct octeon_ciu3_info *, octeon_ciu3_info);
 /* Information for each ciu3 in the system */
 struct octeon_ciu3_info {
 	u64			ciu3_addr;
+	int			node;
 	struct irq_domain	*domain[MAX_CIU3_DOMAINS];
 };
 
@@ -2226,6 +2227,7 @@ int octeon_irq_ciu3_mapx(struct irq_domain *d, unsigned int virq,
 	cd->intsn = hw;
 	cd->current_cpu = -1;
 	cd->ciu3_addr = ciu3_info->ciu3_addr;
+	cd->ciu_node = ciu3_info->node;
 
 	irq_set_chip_and_handler(virq, chip, octeon_irq_handle_trigger);
 	irq_set_chip_data(virq, cd);
@@ -2265,15 +2267,19 @@ static void octeon_irq_ciu3_ip2(void)
 	if (likely(dest_pp_int.s.intr)) {
 		irq_hw_number_t intsn = dest_pp_int.s.intsn;
 		/* Get the domain to use from the major block */
-		int block = intsn > 12;
+		int block = intsn >> 12;
 		int irq = irq_find_mapping(ciu3_info->domain[block], intsn);
 
 		if (likely(irq)) {
 			do_IRQ(irq);
 		} else {
-			u64 isc_ctl_addr = ciu3_addr + CIU3_ISC_CTL(intsn);
-			cvmx_write_csr(isc_ctl_addr, 0);
-			cvmx_read_csr(isc_ctl_addr);
+			union cvmx_ciu3_iscx_w1c isc_w1c;
+			u64 isc_w1c_addr = ciu3_addr + CIU3_ISC_W1C(intsn);
+
+			isc_w1c.u64 = 0;
+			isc_w1c.s.en = 1;
+			cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+			cvmx_read_csr(isc_w1c_addr);
 			spurious_interrupt();
 		}
 	} else {
@@ -2321,9 +2327,13 @@ static void octeon_irq_ciu3_mbox(void)
 		if (likely(mbox >= 0 && mbox < CIU3_MBOX_PER_CORE)) {
 			do_IRQ(mbox + OCTEON_IRQ_MBOX0);
 		} else {
-			u64 isc_ctl_addr = ciu3_addr + CIU3_ISC_CTL(intsn);
-			cvmx_write_csr(isc_ctl_addr, 0);
-			cvmx_read_csr(isc_ctl_addr);
+			union cvmx_ciu3_iscx_w1c isc_w1c;
+			u64 isc_w1c_addr = ciu3_addr + CIU3_ISC_W1C(intsn);
+
+			isc_w1c.u64 = 0;
+			isc_w1c.s.en = 1;
+			cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+			cvmx_read_csr(isc_w1c_addr);
 			spurious_interrupt();
 		}
 	} else {
@@ -2690,6 +2700,7 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 	node = (base_addr >> 36) & 3;
 
 	ciu3_info->ciu3_addr = base_addr;
+	ciu3_info->node = node;
 
 	consts.u64 = cvmx_read_csr(base_addr + CIU3_CONST);
 
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 789ef74..637c47d 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -353,6 +353,7 @@ struct octeon_ciu_chip_data {
 		};
 	};
 	int current_cpu;	/* Next CPU expected to take this irq */
+	int ciu_node; /* NUMA node number of the CIU */
 };
 
 extern void octeon_write_lcd(const char *s);
-- 
1.9.1

