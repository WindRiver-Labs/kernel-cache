From 36dcfa142825934bb6ee61438b40a7464aba9358 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 22 Apr 2014 15:19:19 -0700
Subject: [PATCH 431/518] MIPS: OCTEON: Update S.E. Files.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 55d342a77cca93928a65650d517e4a656d29708f
Description:

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../cavium-octeon/executive/cvmx-helper-pko3.c     | 154 ++++++++-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c | 359 +++++++++++++++++----
 arch/mips/include/asm/octeon/cvmx-pko3-queue.h     |  12 +
 arch/mips/include/asm/octeon/cvmx-wqe.h            |  18 ++
 4 files changed, 456 insertions(+), 87 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 7d3495a..8a0c9c8 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -303,6 +303,135 @@ static int __cvmx_pko3_config_ilk_interface(int xiface)
 	return -1;
 }
 
+
+/** Initialize a channelized port
+ * This is intended for LOOP and NPI interfaces which have one MAC
+ * per interface and need a channel per subinterface (e.g. ring).
+ *
+ * FIXME: Consider merging this function with the ILK configuration code
+ */
+static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
+	uint8_t num_queues, bool prioritized)
+{
+	int l1_q_num;
+	int l2_q_num;
+	int res;
+	int pko_mac_num;
+	uint16_t ipd_port;
+	int res_owner, prio;
+	unsigned i;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	if (prioritized && num_queues > 1)
+		prio = num_queues;
+	else
+		prio = -1;
+
+	if(debug)
+		cvmx_dprintf("%s: configuring xiface %u:%u with "
+				"%u chans %u queues each\n",
+				__FUNCTION__, xi.node, xi.interface,
+				num_chans, num_queues);
+
+	/* all channels all go to the same mac */
+	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, 0);
+	if (pko_mac_num < 0) {
+                cvmx_dprintf ("%s: ERROR Invalid interface\n", __FUNCTION__);
+		return -1;
+	}
+
+	/* Resources of all channels on this port have common owner */
+	ipd_port = cvmx_helper_get_ipd_port(xiface, 0);
+
+	/* Build an identifiable owner */
+	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
+
+	/* Reserve port queue to make sure the MAC is not already configured */
+	l1_q_num = pko_mac_num;
+        l1_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_PORT_QUEUES,
+				res_owner, l1_q_num, 1);
+
+	if (l1_q_num != pko_mac_num) {
+                cvmx_dprintf ("%s: ERROR Reserving L1 PQ\n", __FUNCTION__);
+		return -1;
+	}
+
+
+        /* allocate level 2 queues, one per channel */
+        l2_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L2_QUEUES, res_owner,
+					 -1, num_chans);
+        if (l2_q_num < 0) {
+                cvmx_dprintf ("%s: ERROR allocation L2 SQ\n", __FUNCTION__);
+                return -1;
+        }
+
+
+	/* Configre <num_chans> children for MAC, non-prioritized */
+	res = cvmx_pko3_pq_config_children( xi.node,
+			pko_mac_num, l2_q_num, num_chans, -1);
+
+	if (res < 0) {
+		cvmx_dprintf("%s: ERROR: Failed channel queues\n",
+			__FUNCTION__);
+		return -1;
+	}
+
+	/* Configure children with one DQ per channel */
+	for (i = 0; i < num_chans; i++) {
+		int l3_q, l4_q, l5_q, dq, res;
+		unsigned chan = i;
+
+		l3_q = l4_q = l5_q = dq = -1;
+
+		ipd_port = cvmx_helper_get_ipd_port(xiface, chan);
+
+		/* map channels to l2 queues */
+		cvmx_pko3_map_channel(xi.node, l1_q_num, l2_q_num+chan,
+			ipd_port);
+
+		l3_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L3_QUEUES,
+			res_owner, -1, 1);
+		if(l3_q < 0) goto _fail;
+
+		res = cvmx_pko3_sq_config_children(xi.node, 2, l2_q_num+chan,
+			l3_q, 1, 1);
+		if(res < 0) goto _fail;
+
+		l4_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L4_QUEUES,
+			res_owner, -1, 1);
+		if(l4_q < 0) goto _fail;
+
+		res = cvmx_pko3_sq_config_children(xi.node, 3,
+			l3_q, l4_q, 1, 1);
+		if(res < 0) goto _fail;
+
+		l5_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L5_QUEUES,
+			res_owner, -1, 1);
+		if(l5_q < 0) goto _fail;
+		res = cvmx_pko3_sq_config_children(xi.node, 4,
+			l4_q, l5_q, 1, 1);
+		if(res < 0) goto _fail;
+
+		dq = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_DESCR_QUEUES,
+			res_owner, -1, num_queues);
+		if(dq < 0) goto _fail;
+
+		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q,
+			dq, num_queues, prio);
+		if(res < 0) goto _fail;
+
+		/* register DQ range with the translation table */
+		res = __cvmx_pko3_ipd_dq_register(xiface, chan, dq, num_queues);
+		if(res < 0) goto _fail;
+	}
+
+	return 0;
+  _fail:
+	cvmx_dprintf("%s: ERROR:configuring queues for xiface %u chan %u\n",
+		     __FILE__, (unsigned int)xiface, i);
+	return -1;
+}
+
 /** Initialize a single Ethernet port with PFC-style channels
  *
  * One interface can contain multiple ports, this function is per-port
@@ -690,6 +819,7 @@ int cvmx_helper_pko3_init_interface(int xiface)
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 	num_ports = cvmx_helper_interface_enumerate(xiface);
+	subif = 0;
 
 	if ((unsigned) xi.interface <
 		NUM_ELEMENTS(__cvmx_pko_queue_static_config
@@ -707,12 +837,6 @@ int cvmx_helper_pko3_init_interface(int xiface)
 			.qos_enable;
 	}
 
-	//XXX convert NPI/LB to configure channelized logical interfaces !!
-	/* Override port-count for some interface types */
-	if ((mode == CVMX_HELPER_INTERFACE_MODE_NPI) ||
-		(mode == CVMX_HELPER_INTERFACE_MODE_LOOP))
-		num_ports = 1;
-
 	/* For ILK there is one IPD port per channel */
 	if ((mode == CVMX_HELPER_INTERFACE_MODE_ILK))
 		num_ports =  __cvmx_helper_ilk_enumerate(xiface);
@@ -731,12 +855,10 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		qos =
 			__cvmx_pko_queue_static_config.
 				pknd.pko_cfg_loop.qos_enable;
-		for (subif = 0; subif < num_ports; subif++) {
-			res = __cvmx_pko3_config_gen_interface(xiface, subif,
+		res = __cvmx_pko3_config_chan_interface(xiface, num_ports,
 				num_queues, qos);
-			if (res < 0) {
-				goto __cfg_error;
-			}
+		if (res < 0) {
+			goto __cfg_error;
 		}
 	}
 
@@ -747,23 +869,21 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		qos =
 			__cvmx_pko_queue_static_config.
 				pknd.pko_cfg_npi.qos_enable;
-		for (subif = 0; subif < num_ports; subif++) {
-			res = __cvmx_pko3_config_gen_interface(xiface, subif,
+		res = __cvmx_pko3_config_chan_interface(xiface, num_ports,
 				num_queues, qos);
-			if (res < 0) {
-				goto __cfg_error;
-			}
+		if (res < 0) {
+			goto __cfg_error;
 		}
 	}
 
 	/* ILK-specific queue configuration */
 	else if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
+		num_queues = 1; qos = false; pfc = false;
 		res = __cvmx_pko3_config_ilk_interface(xiface);
 	}
 
 	/* Setup all ethernet configured for PFC */
 	else if (pfc) {
-
 		/* PFC interfaces have 8 prioritized queues */
 		for (subif = 0; subif < num_ports; subif++) {
 			res = __cvmx_pko3_config_pfc_interface(
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 5861daf..af14f93 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -741,6 +741,7 @@ int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
 		else if (stat_prio_count > 0)
 			rr_quantum -= CVMX_PKO3_RR_QUANTUM_MIN;
 	} /* for child */
+
 	return 0;
 }
 
@@ -848,57 +849,37 @@ int cvmx_pko3_sq_config_children(unsigned int node, unsigned parent_level,
 }
 
 /**
- * Configure per-port CIR rate limit parameters
- *
- * This function configures rate limit at the L1/PQ level,
- * i.e. for an entire MAC or physical port.
- *
- * @param node The OCI node where the target port is located
- * @param pq_num The L1/PQ queue number for this setting
- * @param rate_kbips The desired throughput in kilo-bits-per-second
- * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ * Convert bitrate and burst size to SQx_xIR register values
+ * 
+ * @INTERNAL
  *
- * @return Returns zero if both settings applied within allowed tolerance,
- * otherwise the error is returned in parts-per-million.
- * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
- * is returned as a positive integer.
+ * FIXME:
+ * The calculation is based on partial understanding of 
+ * register fields. Must update when more details become
+ * available.
  */
-int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
+static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
+		cvmx_pko_l1_sqx_cir_t *reg,
 		unsigned long rate_kbips, unsigned burst_bytes)
 {
-	const unsigned time_wheel_turn = 96; /* S-Clock cycles */
 	const unsigned max_exp = 12;	/* maximum exponent */
 	const unsigned tock_bytes_exp = 3;	/* rate in 8-byte words */
-	unsigned long rate_tocks, burst_tocks;
-	unsigned long long burst_v, rate_v;
-	uint64_t s_clk;
-	unsigned long tclk, min_burst;
+	long long burst_v, rate_v;
+	unsigned long long rate_tocks, burst_tocks;
+	unsigned long min_burst;
 	unsigned div_exp, mant, exp;
-	cvmx_pko_l1_sqx_cir_t sqx_cir;
-	uint64_t tmp, fmax;
+	unsigned long long tmp, fmax;
+	int debug = 1;	// XXX
 
 	if (debug)
-		cvmx_dprintf("%s: pq=%u rate=%lu kbps, burst=%u bytes\n",
-			__func__, pq_num, rate_kbips, burst_bytes);
-
-	sqx_cir.u64 = 0;
-
-	/* When rate == 0, disable the shaper */
-	if( rate_kbips == 0ULL) {
-		/* Disable shaping */
-		sqx_cir.s.enable = 0;
-		cvmx_write_csr_node(node,
-			CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
-		return 0;
-	}
+		cvmx_dprintf("%s: tclk=%lu, rate=%lu kbps, burst=%u bytes\n",
+			__func__, tclk, rate_kbips, burst_bytes);
 
 	/* Convert API args into tocks: PSE native units */
-	rate_tocks = (1000ULL * rate_kbips) >> (3 + tock_bytes_exp);
-	burst_tocks = burst_bytes >> tock_bytes_exp;
-
-	/* Compute time-wheel frequency */
-	s_clk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK);
-	tclk = s_clk / time_wheel_turn;
+	tmp = (1 << (3 + tock_bytes_exp))-1;
+	rate_tocks = (1000ULL * rate_kbips + tmp) >> (3 + tock_bytes_exp);
+	tmp = (1 << tock_bytes_exp) - 1;
+	burst_tocks = (burst_bytes+tmp) >> tock_bytes_exp;
 
 	/* Compute largest short-float that fits in register fields */
 	fmax = CVMX_SHOFT_TO_U64((1<<CVMX_SHOFT_MANT_BITS)-1, max_exp);
@@ -912,6 +893,13 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 		}
 	}
 
+	/* Make sure exponent is within valid range */
+	if (div_exp > max_exp)
+		div_exp = max_exp;
+
+	/* Store common divider */
+	reg->s.rate_divider_exponent = div_exp;
+
 	/* XXX-
 	 * Assu,ing the BURST field is the actual satiration value
 	 * for the rate accumulator, while the argument is the 
@@ -925,47 +913,39 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 	/* Apply the minimum */
 	burst_tocks += min_burst;
 
-	/* Store common divider */
-	sqx_cir.s.rate_divider_exponent = div_exp;
-
-	/* Calculate the CIR short float */
+	/* Calculate the rate short float */
 	tmp = (rate_tocks << (div_exp + 8)) / tclk;
 	CVMX_SHOFT_FROM_U64(tmp, mant, exp);
-	sqx_cir.s.rate_mantissa = mant;
-	sqx_cir.s.rate_exponent = exp - 8;
+	reg->s.rate_mantissa = mant;
+	reg->s.rate_exponent = exp - 8;
 
 	/* Calculate the BURST short float */
-	tmp = (burst_tocks << (8));
+	tmp = (burst_tocks << 8);
 	CVMX_SHOFT_FROM_U64(tmp, mant, exp);
-	sqx_cir.s.burst_mantissa = mant;
-	sqx_cir.s.burst_exponent = exp - 8;
-	/* Enable shaping */
-	sqx_cir.s.enable = 1;
-
-	/* Apply new settings */
-	cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
+	reg->s.burst_mantissa = mant;
+	reg->s.burst_exponent = exp - 8;
 
 	if (debug)
-		cvmx_dprintf("%s: CIR_RATE=%llu BURST=%llu DIV_EXP=%d\n",
+		cvmx_dprintf("%s: RATE=%llu BURST=%llu DIV_EXP=%d\n",
 			__func__,
-			CVMX_SHOFT_TO_U64(sqx_cir.s.rate_mantissa,
-					sqx_cir.s.rate_exponent),
-			CVMX_SHOFT_TO_U64(sqx_cir.s.burst_mantissa,
-					sqx_cir.s.burst_exponent),
+			CVMX_SHOFT_TO_U64(reg->s.rate_mantissa,
+					reg->s.rate_exponent),
+			CVMX_SHOFT_TO_U64(reg->s.burst_mantissa,
+					reg->s.burst_exponent),
 			div_exp);
 
 	/* Validate the resulting rate */
-	tmp = CVMX_SHOFT_TO_U64(sqx_cir.s.rate_mantissa,
-				8 + sqx_cir.s.rate_exponent),
-	rate_v =  ((s_clk / time_wheel_turn) * tmp) >> (div_exp + 8);
+	rate_v = CVMX_SHOFT_TO_U64(reg->s.rate_mantissa,
+				reg->s.rate_exponent) * tclk;
 	/* Convert to kbips for comaring with argument */
 	rate_v = (rate_v << (3+tock_bytes_exp)) /1000ULL;
+	/* Finally apply divider for best accuracy */
+	rate_v >>= div_exp;
 
-	tmp = CVMX_SHOFT_TO_U64(sqx_cir.s.burst_mantissa,
-				8 + sqx_cir.s.burst_exponent),
-	burst_v = tmp >> 8;
+	burst_v = CVMX_SHOFT_TO_U64(reg->s.burst_mantissa,
+				reg->s.burst_exponent);
 	/* Convert in additional bytes as in argument */
-	burst_v = (burst_v - min_burst) << tock_bytes_exp;
+	burst_v = (burst_v - min_burst) << (tock_bytes_exp);
 	
 	if (debug)
 		cvmx_dprintf("%s: result rate=%'llu kbips burst=%llu bytes\n",
@@ -975,19 +955,258 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 	rate_v = abs(rate_v - rate_kbips);
 	burst_v = abs(burst_v - burst_bytes);
 
-	rate_v = rate_v * 1000000 / rate_kbips;
-	burst_v = burst_v * 1000000 / burst_bytes;
+	if (debug)
+		cvmx_dprintf("%s: diff rate=%llu burst=%llu ppm\n",
+			__func__, rate_v, burst_v);
+
+	rate_v = (rate_v * 1000000ULL) / rate_kbips;
+	burst_v = (burst_v * 1000000ULL) / burst_bytes;
 
 	if (debug)
 		cvmx_dprintf("%s: error rate=%llu burst=%llu ppm\n",
 			__func__, rate_v, burst_v);
 
-	/* Allow ~ 100 ppm error for CIR, and 1% for BURST */
+	/* Allow ~ 100 ppm error for CIR, and 5% for BURST */
 	if (rate_v > 100)
 		return -rate_v;
-	if (burst_v > 1000)
+	if (burst_v > 5000)
 		return burst_v;
 
 	return 0;
 }
 
+/**
+ * Configure per-port CIR rate limit parameters
+ *
+ * This function configures rate limit at the L1/PQ level,
+ * i.e. for an entire MAC or physical port.
+ *
+ * @param node The OCI node where the target port is located
+ * @param pq_num The L1/PQ queue number for this setting
+ * @param rate_kbips The desired throughput in kilo-bits-per-second
+ * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ *
+ * @return Returns zero if both settings applied within allowed tolerance,
+ * otherwise the error is returned in parts-per-million.
+ * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
+ * is returned as a positive integer.
+ */
+int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
+		unsigned long rate_kbips, unsigned burst_bytes)
+{
+	const unsigned time_wheel_turn = 96; /* S-Clock cycles */
+	unsigned long tclk;
+	cvmx_pko_l1_sqx_cir_t sqx_cir;
+	int rc;
+
+	if (debug)
+		cvmx_dprintf("%s: pq=%u rate=%lu kbps, burst=%u bytes\n",
+			__func__, pq_num, rate_kbips, burst_bytes);
+
+	sqx_cir.u64 = 0;
+
+	/* When rate == 0, disable the shaper */
+	if( rate_kbips == 0ULL) {
+		/* Disable shaping */
+		sqx_cir.s.enable = 0;
+		cvmx_write_csr_node(node,
+			CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
+		return 0;
+	}
+
+	/* Compute time-wheel frequency */
+	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
+		time_wheel_turn;
+
+	/* Compute shaper values */
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
+		rate_kbips, burst_bytes);
+
+	/* FIXME: should refuse to set register if insane rates ? */
+
+	/* Enable shaping */
+	sqx_cir.s.enable = 1;
+
+	/* Apply new settings */
+	cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
+
+	return rc;
+}
+
+/**
+ * Configure per-queue CIR rate limit parameters
+ *
+ * This function configures rate limit at the descriptor queue level.
+ *
+ * @param node The OCI node where the target port is located
+ * @param dq_num The descriptor queue number for this setting
+ * @param rate_kbips The desired throughput in kilo-bits-per-second
+ * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ *
+ * @return Returns zero if both settings applied within allowed tolerance,
+ * otherwise the error is returned in parts-per-million.
+ * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
+ * is returned as a positive integer.
+ */
+int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
+		unsigned long rate_kbips, unsigned burst_bytes)
+{
+	const unsigned time_wheel_turn = 768; /* S-Clock cycles */
+	unsigned long tclk;
+	cvmx_pko_l1_sqx_cir_t sqx_cir;
+	cvmx_pko_dqx_cir_t dqx_cir;
+	int rc;
+
+	dq_num &= (1<<10)-1;
+
+	if (debug)
+		cvmx_dprintf("%s: dq=%u rate=%lu kbps, burst=%u bytes\n",
+			__func__, dq_num, rate_kbips, burst_bytes);
+
+	dqx_cir.u64 = 0;
+
+	/* When rate == 0, disable the shaper */
+	if( rate_kbips == 0ULL) {
+		/* Disable shaping */
+		dqx_cir.s.enable = 0;
+		cvmx_write_csr_node(node,
+			CVMX_PKO_DQX_CIR(dq_num), dqx_cir.u64);
+		return 0;
+	}
+
+	/* Compute time-wheel frequency */
+	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
+		time_wheel_turn;
+
+	/* Compute shaper values */
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
+		rate_kbips, burst_bytes);
+
+	/* FIXME: should refuse to set register if insane rates ? */
+
+	/* Enable shaping */
+	dqx_cir.s.enable = 1;
+	dqx_cir.s. rate_divider_exponent = sqx_cir.s. rate_divider_exponent;
+	dqx_cir.s. rate_mantissa  = sqx_cir.s. rate_mantissa;
+	dqx_cir.s. rate_exponent  = sqx_cir.s. rate_exponent;
+	dqx_cir.s. burst_mantissa = sqx_cir.s. burst_mantissa;
+	dqx_cir.s. burst_exponent = sqx_cir.s. burst_exponent ;
+
+	/* Apply new settings */
+	cvmx_write_csr_node(node, CVMX_PKO_DQX_CIR(dq_num), dqx_cir.u64);
+
+	return rc;
+}
+
+/**
+ * Configure per-queue PIR rate limit parameters
+ *
+ * This function configures rate limit at the descriptor queue level.
+ *
+ * @param node The OCI node where the target port is located
+ * @param dq_num The descriptor queue number for this setting
+ * @param rate_kbips The desired throughput in kilo-bits-per-second
+ * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ *
+ * @return Returns zero if both settings applied within allowed tolerance,
+ * otherwise the error is returned in parts-per-million.
+ * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
+ * is returned as a positive integer.
+ */
+int cvmx_pko3_dq_pir_set(unsigned node, unsigned dq_num,
+		unsigned long rate_kbips, unsigned burst_bytes)
+{
+	const unsigned time_wheel_turn = 768; /* S-Clock cycles */
+	unsigned long tclk;
+	cvmx_pko_l1_sqx_cir_t sqx_cir;
+	cvmx_pko_dqx_pir_t dqx_pir;
+	int rc;
+
+	dq_num &= (1<<10)-1;
+	if (debug)
+		cvmx_dprintf("%s: dq=%u rate=%lu kbps, burst=%u bytes\n",
+			__func__, dq_num, rate_kbips, burst_bytes);
+
+	dqx_pir.u64 = 0;
+
+	/* When rate == 0, disable the shaper */
+	if( rate_kbips == 0ULL) {
+		/* Disable shaping */
+		dqx_pir.s.enable = 0;
+		cvmx_write_csr_node(node,
+			CVMX_PKO_DQX_PIR(dq_num), dqx_pir.u64);
+		return 0;
+	}
+
+	/* Compute time-wheel frequency */
+	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
+		time_wheel_turn;
+
+	/* Compute shaper values */
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
+		rate_kbips, burst_bytes);
+
+	/* FIXME: should refuse to set register if insane rates ? */
+
+	/* Enable shaping */
+	dqx_pir.s.enable = 1;
+	dqx_pir.s. rate_divider_exponent = sqx_cir.s. rate_divider_exponent;
+	dqx_pir.s. rate_mantissa  = sqx_cir.s. rate_mantissa;
+	dqx_pir.s. rate_exponent  = sqx_cir.s. rate_exponent;
+	dqx_pir.s. burst_mantissa = sqx_cir.s. burst_mantissa;
+	dqx_pir.s. burst_exponent = sqx_cir.s. burst_exponent ;
+
+	/* Apply new settings */
+	cvmx_write_csr_node(node, CVMX_PKO_DQX_PIR(dq_num), dqx_pir.u64);
+
+	return rc;
+}
+
+/**
+ * Configure per-queue treatment of excess traffic
+ *
+ * The default and most sensible behavior is to stall the packets
+ * colored Red (i.e. exceeding the PIR rate in full 3-color mode).
+ * There is also the option to discard excess traffic, which is
+ * the desired action for some applications that do not rely on
+ * back-pressure flow control.
+ * The shaper may be programmed to pass the RED packets onwards,
+ * which may be useful it the color is translated to a change
+ * in packet priority on egress.
+ *
+ * @param node The OCI node where the target port is located
+ * @param dq_num The descriptor queue number for this setting
+ * @param red_act The action required for all packets in excess of PIR
+ * @param len_adjust A 2's complement 8 bit value to add/subtract from
+ * packet length for the purpose of shaping calculations, e.g.
+ * a value of -14 will subtract the length of the Ethernet header
+ * and hence only account IP packet size.
+ *
+ * @return N/A
+ */
+void cvmx_pko3_dq_red(unsigned node, unsigned dq_num, red_action_t red_act,
+	int8_t len_adjust)
+{
+	cvmx_pko_dqx_shape_t dqx_shape;
+
+	dq_num &= (1<<10)-1;
+
+	dqx_shape.u64 = 0;
+        dqx_shape.s.adjust = len_adjust;
+
+	switch(red_act) {
+		default:
+		case CVMX_PKO3_SHAPE_RED_STALL:
+			dqx_shape.s.red_algo = 0x0;
+			break;
+		case CVMX_PKO3_SHAPE_RED_DISCARD:
+			dqx_shape.s.red_algo = 0x3;
+			break;
+		case CVMX_PKO3_SHAPE_RED_PASS:
+			dqx_shape.s.red_algo = 0x1;
+			break;
+		}
+
+	cvmx_write_csr_node(node, CVMX_PKO_DQX_SHAPE(dq_num), dqx_shape.u64);
+}
+
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
index a3202d7..60c5f10 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
@@ -190,6 +190,18 @@ void cvmx_pko3_map_channel(unsigned node,
 
 extern int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 		unsigned long rate_kbips, unsigned burst_bytes);
+extern int cvmx_pko3_dq_cir_set(unsigned node, unsigned pq_num,
+		unsigned long rate_kbips, unsigned burst_bytes);
+extern int cvmx_pko3_dq_pir_set(unsigned node, unsigned pq_num,
+		unsigned long rate_kbips, unsigned burst_bytes);
+typedef enum {
+	CVMX_PKO3_SHAPE_RED_STALL,
+	CVMX_PKO3_SHAPE_RED_DISCARD,
+	CVMX_PKO3_SHAPE_RED_PASS
+} red_action_t;
+
+extern void cvmx_pko3_dq_red(unsigned node, unsigned dq_num,
+	red_action_t red_act, int8_t len_adjust);
 
 /**
  * Macros to deal with short floating point numbers,
diff --git a/arch/mips/include/asm/octeon/cvmx-wqe.h b/arch/mips/include/asm/octeon/cvmx-wqe.h
index 168fbb3..f527dc5 100644
--- a/arch/mips/include/asm/octeon/cvmx-wqe.h
+++ b/arch/mips/include/asm/octeon/cvmx-wqe.h
@@ -725,6 +725,24 @@ typedef union {
 #endif
 } cvmx_pki_wqe_word2_t;
 
+#define CVMX_PKI_LTYPE_NONE 0
+#define CVMX_PKI_LTYPE_IPV4 0x8
+#define CVMX_PKI_LTYPE_IPV6 0xa
+#define CVMX_PKI_LTYPE_TCP 0x10
+#define CVMX_PKI_LTYPE_UDP 0x11
+#define CVMX_PKI_LTYPE_SCTP 0x12
+
+#define CVMX_PKI_ERRLEV_RE 0
+#define CVMX_PKI_ERRLEV_LA 1
+#define CVMX_PKI_ERRLEV_LB 2
+#define CVMX_PKI_ERRLEV_LC 3
+#define CVMX_PKI_ERRLEV_LD 4
+#define CVMX_PKI_ERRLEV_LE 5
+#define CVMX_PKI_ERRLEV_LF 6
+#define CVMX_PKI_ERRLEV_LG 7
+
+#define CVMX_PKI_OPCODE_RE_NONE 0
+
 typedef union {
 	uint64_t u64;
 	cvmx_pki_wqe_word2_t pki;
-- 
1.9.1

