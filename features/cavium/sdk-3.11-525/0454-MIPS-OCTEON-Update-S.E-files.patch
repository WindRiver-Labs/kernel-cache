From 1308d0e6573cc22240f064650568a2e26fe01daf Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 5 May 2014 15:55:32 -0400
Subject: [PATCH 454/518] MIPS: OCTEON: Update S.E files.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 662c9fee0a94c648a50a0ecd59f282f24a70438d
Description:

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile         |    2 +-
 .../cavium-octeon/executive/cvmx-fpa-resource.c    |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-gser.c      |  277 ----
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  452 +++--
 .../cavium-octeon/executive/cvmx-helper-board.c    |  297 +++-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |  129 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |   81 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |    4 -
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       |   20 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |   50 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  266 ++-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |   14 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |    6 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 1740 +++++++++++++++-----
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |    4 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |    8 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |  425 ++---
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |  172 +-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  292 ++--
 arch/mips/include/asm/octeon/cvmx-pki.h            |  126 ++
 arch/mips/include/asm/octeon/cvmx-pow.h            |    5 +
 23 files changed, 2869 insertions(+), 1522 deletions(-)
 delete mode 100644 arch/mips/cavium-octeon/executive/cvmx-gser.c

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 9328373..a5e3474 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -20,7 +20,7 @@ obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-helper-cfg.o	\
 	cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o		\
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o	\
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o		\
-	cvmx-pki-resources.o cvmx-gser.o cvmx-bgx.o cvmx-pko3-queue.o	\
+	cvmx-pki-resources.o cvmx-bgx.o cvmx-pko3-queue.o		\
 	cvmx-helper-bgx.o cvmx-pko3.o cvmx-helper-pki.o			\
 	cvmx-helper-pko3.o cvmx-pko3-resources.o cvmx-helper-pko.o	\
 	cvmx-helper-ipd.o cvmx-sso-resources.o cvmx-ocla.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c b/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
index c2766a7..4e9c92f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-fpa-resource.c
@@ -119,7 +119,7 @@ int cvmx_fpa_allocate_fpa_pools(int node, int pools_allocated[], int count)
 	if (pools_allocated[0] >= 0) {
 		while (count--) {
 			rv = cvmx_reserve_global_resource_range(tag, owner, pools_allocated[count], 1);
-			if (rv == -1)
+			if (rv < 0)
 				return CVMX_RESOURCE_ALREADY_RESERVED;
 		}
 
@@ -187,7 +187,8 @@ int cvmx_fpa3_allocate_auras(int node, int auras_allocated[], int count)
 	struct global_resource_tag tag = get_aura_resource_tag(node);
 
 	if (!OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		cvmx_dprintf("ERROR :  Aura allocation not supported on this model\n");
+		cvmx_dprintf("ERROR:  Aura allocation not supported on this model\n");
+		return -1;
 	}
 
 	if (cvmx_create_global_resource_range(tag, num_aura) != 0) {
@@ -197,7 +198,7 @@ int cvmx_fpa3_allocate_auras(int node, int auras_allocated[], int count)
 	if (auras_allocated[0] >= 0) {
 		while (count--) {
 			rv = cvmx_reserve_global_resource_range(tag, owner, auras_allocated[count], 1);
-			if (rv == -1)
+			if (rv < 0)
 				return CVMX_RESOURCE_ALREADY_RESERVED;
 		}
 	} else
diff --git a/arch/mips/cavium-octeon/executive/cvmx-gser.c b/arch/mips/cavium-octeon/executive/cvmx-gser.c
deleted file mode 100644
index 89fafcf..0000000
--- a/arch/mips/cavium-octeon/executive/cvmx-gser.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/***********************license start***************
- * Copyright (c) 2013  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
-
-/**
- * @file
- *
- * Helper utilities for qlm.
- *
- * <hr>$Revision$<hr>
- */
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-#include <asm/octeon/cvmx.h>
-#include <asm/octeon/cvmx-helper.h>
-#include <asm/octeon/cvmx-qlm.h>
-#include <asm/octeon/cvmx-gserx-defs.h>
-#else
-#include "cvmx.h"
-#include "cvmx-helper.h"
-#include "cvmx-qlm.h"
-#endif
-
-
-/**
- * @INTERNAL
- * Configure the gser pll registers.
- *
- * @param interface Interface to bring up
- *
- * @param mode      Mode to configure the gser as
- *
- * @param qlm       QLM attached to this interface
- *
- * @parma num_ports Number of ports on this interface
- *
- * @return Zero on success, negative on failure
- */
-static int gser_pll_init(int				interface,
-			 cvmx_helper_interface_mode_t	mode,
-			 int				qlm,
-			 int				num_ports)
-{
-	cvmx_gserx_pll_px_mode_0_t	gser_pll_p_mode_0;
-	cvmx_gserx_pll_px_mode_1_t	gser_pll_p_mode_1;
-	cvmx_gserx_lanex_px_mode_0_t	gser_lane_p_mode_0;
-	int				lane_mode;
-	int				i;
-
-	/* Figure out the lane mode */
-	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		lane_mode = 0x6;
-		break;
-
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		lane_mode = 0x4;
-		break;
-
-	default:
-		lane_mode = 0;
-		break;
-	}
-
-	/* Configure pll_p_mode_0 */
-	gser_pll_p_mode_0.u64 = 0;
-	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		gser_pll_p_mode_0.s.pll_icp = 1;
-		gser_pll_p_mode_0.s.pll_rloop = 3;
-		gser_pll_p_mode_0.s.pll_pcs_div = 0x28;
-		break;
-
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		gser_pll_p_mode_0.s.pll_icp = 1;
-		gser_pll_p_mode_0.s.pll_rloop = 3;
-		gser_pll_p_mode_0.s.pll_pcs_div = 0x24;
-		break;
-
-	default:
-		break;
-	}
-	cvmx_write_csr(CVMX_GSERX_PLL_PX_MODE_0(qlm, lane_mode),
-		       gser_pll_p_mode_0.u64);
-
-	/* Configure pll_p_mode_1 */
-	gser_pll_p_mode_1.u64 = 0;
-	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		gser_pll_p_mode_1.s.pll_div = 16;
-		gser_pll_p_mode_1.s.pll_opr = 0;
-		gser_pll_p_mode_1.s.pll_pcie3en = 0;
-		gser_pll_p_mode_1.s.pll_cpadj = 3;
-		gser_pll_p_mode_1.s.pll_16p5en = 1;
-		break;
-
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		gser_pll_p_mode_1.s.pll_div = 20;
-		gser_pll_p_mode_1.s.pll_opr = 0;
-		gser_pll_p_mode_1.s.pll_pcie3en = 0;
-		gser_pll_p_mode_1.s.pll_cpadj = 2;
-		gser_pll_p_mode_1.s.pll_16p5en = 1;
-		break;
-
-	default:
-		break;
-	}
-	cvmx_write_csr(CVMX_GSERX_PLL_PX_MODE_1(qlm, lane_mode),
-		       gser_pll_p_mode_1.u64);
-
-	/* Configure lane_p_mode */
-	for (i = 0; i < num_ports; i++) {
-		gser_lane_p_mode_0.u64 = 0;
-		gser_lane_p_mode_0.s.srate = 0;
-		gser_lane_p_mode_0.s.rx_mode = 3;
-		gser_lane_p_mode_0.s.tx_mode = 3;
-
-		switch (mode) {
-		case CVMX_HELPER_INTERFACE_MODE_SGMII:
-			gser_lane_p_mode_0.s.ctle = 0;
-			gser_lane_p_mode_0.s.pcie = 0;
-			gser_lane_p_mode_0.s.tx_ldiv = 2;
-			gser_lane_p_mode_0.s.rx_ldiv = 2;
-			break;
-
-		case CVMX_HELPER_INTERFACE_MODE_XAUI:
-			gser_lane_p_mode_0.s.ctle = 0;
-			gser_lane_p_mode_0.s.pcie = 0;
-			gser_lane_p_mode_0.s.tx_ldiv = 2;
-			gser_lane_p_mode_0.s.rx_ldiv = 2;
-			break;
-
-		default:
-			break;
-		}
-		cvmx_write_csr(CVMX_GSERX_LANEX_PX_MODE_0(qlm, i, lane_mode),
-			       gser_lane_p_mode_0.u64);
-	}
-
-	return 0;
-}
-
-/**
- * @INTERNAL
- * Configure the gser.
- *
- * @param interface Interface to bring up
- *
- * @param mode      Mode to configure the gser as
- *
- * @return Zero on success, negative on failure
- */
-int gser_init(int				interface,
-	      cvmx_helper_interface_mode_t	mode)
-{
-	cvmx_gserx_phy_ctl_t		gser_phy_ctl;
-	cvmx_gserx_cfg_t		gser_cfg;
-	cvmx_gserx_rx_coast_t		gser_rx_coast;
-	cvmx_gserx_rx_eie_deten_t	gser_rx_eie_deten;
-	cvmx_gserx_lane_mode_t		gser_lane_mode;
-	cvmx_gserx_qlm_stat_t		gser_qlm_stat;
-	cvmx_gserx_pll_stat_t		gser_pll_stat;
-	cvmx_gserx_rx_eie_detsts_t	gser_rx_eie_detsts;
-	int				lane_mode;
-	int				qlm;
-	int				num_ports;
-
-	qlm = cvmx_qlm_interface(interface);
-	num_ports = cvmx_helper_ports_on_interface(interface);
-
-	/* Figure out the lane mode */
-	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		lane_mode = 0x6;
-		break;
-
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		lane_mode = 0x4;
-		break;
-
-	default:
-		lane_mode = 0;
-		break;
-	}
-
-	/* Power up phy, but keek it in reset */
-	gser_phy_ctl.u64 = 0;
-	gser_phy_ctl.s.phy_pd = 0;
-	gser_phy_ctl.s.phy_reset = 1;
-	cvmx_write_csr(CVMX_GSERX_PHY_CTL(qlm), gser_phy_ctl.u64);
-
-	/* Set gser for the interface mode */
-	gser_cfg.u64 = 0;
-	gser_cfg.s.ila = mode == CVMX_HELPER_INTERFACE_MODE_ILK ? 1 : 0;
-	gser_cfg.s.bgx = mode == CVMX_HELPER_INTERFACE_MODE_ILK ? 0 : 1;
-	gser_cfg.s.bgx_quad = mode == CVMX_HELPER_INTERFACE_MODE_XAUI ? 1 : 0;
-	gser_cfg.s.bgx_dual = 0;
-	gser_cfg.s.pcie = 0;
-	cvmx_write_csr(CVMX_GSERX_CFG(qlm), gser_cfg.u64);
-
-	/* Enable the port lanes */
-	gser_rx_coast.u64 = cvmx_read_csr(CVMX_GSERX_RX_COAST(qlm));
-	gser_rx_coast.s.coast |= ((1 << num_ports) - 1);
-	cvmx_write_csr(CVMX_GSERX_RX_COAST(qlm), gser_rx_coast.u64);
-
-	gser_rx_eie_deten.u64 = cvmx_read_csr(CVMX_GSERX_RX_EIE_DETEN(qlm));
-	gser_rx_eie_deten.s.eiede |= ((1 << num_ports) - 1);
-	cvmx_write_csr(CVMX_GSERX_RX_EIE_DETEN(qlm), gser_rx_eie_deten.u64);
-
-	/* Lane mode */
-	gser_lane_mode.u64 = 0;
-	gser_lane_mode.s.lmode = lane_mode;
-	cvmx_write_csr(CVMX_GSERX_LANE_MODE(qlm), gser_lane_mode.u64);
-
-	/* Bring phy out of reset */
-	gser_phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
-	gser_phy_ctl.s.phy_reset = 0;
-	cvmx_write_csr(CVMX_GSERX_PHY_CTL(qlm), gser_phy_ctl.u64);
-	gser_phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
-
-	/*
-	 * Wait 250 ns until the managment interface is ready to accept
-	 * read/write commands.
-	 */
-	cvmx_wait_usec(3);
-
-	/* Configure the gser pll */
-	gser_pll_init(interface, mode, qlm, num_ports);
-
-	/* Wait for reset to complete and the PLL to lock */
-	do {
-		gser_qlm_stat.u64 = cvmx_read_csr(CVMX_GSERX_QLM_STAT(qlm));
-		gser_pll_stat.u64 = cvmx_read_csr(CVMX_GSERX_PLL_STAT(qlm));
-	} while(!gser_qlm_stat.s.rst_rdy || !gser_pll_stat.s.pll_lock);
-
-	/* Wait for cdrlock */
-	do {
-		gser_rx_eie_detsts.u64 =
-			cvmx_read_csr(CVMX_GSERX_RX_EIE_DETSTS(qlm));
-	} while((gser_rx_eie_detsts.s.cdrlock & 0xf) != 0xf);
-
-	return 0;
-}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 1edaa24..dd5e5f2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -232,18 +232,12 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_one_time(int xiface, int index)
 	int interface = xi.interface;
 	int node = xi.node;
 	const uint64_t clock_mhz = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK) / 1000000;
-	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
 	cvmx_bgxx_gmp_pcs_linkx_timer_t gmp_timer;
 
 	if (!cvmx_helper_is_port_valid(interface, index))
 		return 0;
 
-	/* Disable BGX */
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	cmr_config.s.enable = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-
 	/*
 	 * Write PCS*_LINK*_TIMER_COUNT_REG[COUNT] with the
 	 * appropriate value. 1000BASE-X specifies a 10ms
@@ -763,153 +757,183 @@ int __cvmx_helper_bgx_sgmii_configure_loopback(int xipd_port, int enable_interna
  *
  * @return Zero on success, negative on failure
  */
-static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
+static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 {
-	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
+	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_bgxx_spux_misc_control_t spu_misc_control;
 	cvmx_bgxx_spux_control1_t spu_control1;
-	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_bgxx_spux_an_control_t spu_an_control;
+	cvmx_bgxx_spux_an_adv_t spu_an_adv;
+	cvmx_bgxx_spux_fec_control_t spu_fec_control;
+	cvmx_bgxx_spu_dbg_control_t spu_dbg_control;
+	cvmx_bgxx_smux_tx_append_t  smu_tx_append;
+	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_helper_interface_mode_t mode;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	int use_auto_neg = 0;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
-	/* (1) Interface has already been enabled. */
-
-	/* (2) Disable BGX. */
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	cmr_config.s.enable = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-
-	/* (3) Disable GMX and PCSX interrupts. */
+	/* NOTE: This code was moved first, out of order compared to the HRM
+	   because the RESET causes all SPU registers to loose their value */
+	/* 4. Next, bring up the SMU/SPU and the BGX reconciliation layer logic: */
+	/* 4a. Take SMU/SPU through a reset sequence. Write
+	   BGX(0..5)_SPU(0..3)_CONTROL1[RESET] = 1. Read
+	   BGX(0..5)_SPU(0..3)_CONTROL1[RESET] until it changes value to 0. Keep
+	   BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1 to disable
+	   reception. */
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface), 0x0);
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface), 0x0);
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), 0x0);
-	}
-
-	/* Enable link training for 10GBASE-KR and 40GBASE-KR */
-	if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
-	    || mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
-		cvmx_bgxx_spux_br_pmd_control_t spu_pmd_control;
-		spu_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
-		spu_pmd_control.s.train_en = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface),
-				       spu_pmd_control.u64);
-	}
-
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
-	spu_control1.s.lo_pwr = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
-	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		/* (4)a Take SMU/SPU through a reset sequence */
-		/* (4)a Set polarity and lane swapping. */
 		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
 		spu_control1.s.reset = 1;
 		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
 
-		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
-		spu_misc_control.s.rx_packet_dis = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
-
 		/* Wait for PCS to come out of reset */
 		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(index, interface),
-					 cvmx_bgxx_spux_control1_t, reset, ==, 0, 10000))
+				cvmx_bgxx_spux_control1_t, reset, ==, 0, 10000)) {
+			cvmx_dprintf("BGX%d: SPU stuck in reset\n", interface);
 			return -1;
+		}
 	}
 
-	/* 4d. Select Deficit Idle Count mode and unidirection mode */
-	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
-	smu_tx_ctl.s.dic_en = 1;
-	smu_tx_ctl.s.uni_en = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface), smu_tx_ctl.u64);
-
-	if ((mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
-	     || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
-	    && cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_INT(index, interface),
-					  cvmx_bgxx_spux_int_t, training_done, ==, 1, 10000))
-			cvmx_dprintf("ERROR: %d:BGX%d:%d: Failed link training\n", node, interface, index);
-                	return -1;
-	}
+	/* 1. Write BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] to 0,
+	      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
+	      BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+	cmr_config.s.enable = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
-	/* (5) Check to make sure that the link appears up and stable. */
-	/* Wait for PCS to be aligned */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(index, interface),
-				  cvmx_bgxx_spux_bx_status_t, alignd, ==, 1, 10000)) {
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: Lanes not aligned\n", node, interface, index);
-		return -1;
-}
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.s.lo_pwr = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
 
-	/* Wait for RX to be ready */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_RX_CTL(index, interface),
-					  cvmx_bgxx_smux_rx_ctl_t, status, ==, 0, 10000)) {
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: Link not up\n", node, interface, index);
-		return -1;
-}
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.s.rx_packet_dis = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+
+	/* 2. At this point, it may be appropriate to disable all BGX and SMU/SPU
+	      interrupts, as a number of them will occur during bring-up of the Link.
+	      - zero BGX(0..5)_SMU(0..3)_RX_INT
+	      - zero BGX(0..5)_SMU(0..3)_TX_INT
+	      - zero BGX(0..5)_SPU(0..3)_INT */
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface),
+			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface)));
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface),
+			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface)));
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface),
+			cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface)));
+
+	/* 3. Configure the BGX LMAC. */
+	/* 3a. Configure the LMAC type (40GBASE-R/10GBASE-R/RXAUI/XAUI) and
+	     SerDes selection in the BGX(0..5)_CMR(0..3)_CONFIG register, but keep
+	     the ENABLE, DATA_PKT_TX_EN and DATA_PKT_RX_EN bits clear. */
+	/* Already done in bgx_setup_one_time */
+
+	/* 3b. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
+	     BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.s.lo_pwr = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
 
-	/* Clear all error interrupts before enabling the interface. */
-	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface), ~0x0ull);
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface), ~0x0ull);
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), ~0x0ull);
-	}
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.s.rx_packet_dis = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
 
-	/* Wait for GMX RX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
-				  cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000)) {
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not idle\n", node, interface, index);
-		return -1;
-}
+	/* 3c. Initialize the selected SerDes lane(s) in the QLM. See Section
+	       28.1.2.2 in the GSER chapter. */
+	/* Already done in QLM setup */
 
-	/* Wait for GMX TX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
-				  cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000)) {
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not idle\n", node, interface, index);
-		return -1;
-}
+	/* 3d. For 10GBASE-KR or 40GBASE-KR, enable link training by writing
+	       BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] = 1. */
+	if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+		cvmx_bgxx_spux_br_pmd_control_t spu_br_pmd_control;
+		spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+		spu_br_pmd_control.s.train_en = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_br_pmd_control.u64);
 
-	/* Wait for receive link */
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface),
-				  cvmx_bgxx_spux_br_status1_t, rcv_lnk, ==, 1, 10000))
-{
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: rcv_lnk not up\n", node, interface, index);
-		return -1;
-}
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_STATUS2(index, interface),
-				  cvmx_bgxx_spux_status2_t, xmtflt, ==, 0, 10000))
-{
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: xmtflt not 0\n", node, interface, index);
-		return -1;
-}
+	}
+	
+	/* 3e. Program all other relevant BGX configuration while
+	       BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 0. This includes all things
+	       described in this chapter. */
+	/* Don't add a FCS as PKO does that */
+	smu_tx_append.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface));
+	smu_tx_append.s.fcs_d = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface), smu_tx_append.u64);
+
+	/* 3f. If Forward Error Correction is desired for 10GBASE-R or 40GBASE-R,
+	       enable it by writing BGX(0..5)_SPU(0..3)_FEC_CONTROL[FEC_EN] = 1. */
+	if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+		spu_fec_control.s.fec_en = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_fec_control.u64);
 
-	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_STATUS2(index, interface),
-				  cvmx_bgxx_spux_status2_t, rcvflt, ==, 0, 10000)) {
-		cvmx_dprintf("ERROR: %d:BGX%d:%d: rcvflt not latched\n", node, interface, index);
-		return -1;
-}
+	}
 
-	/* (7) Enable packet transmit and receive */
+	/* 3g. If Auto-Negotiation is desired, configure and enable
+	       Auto-Negotiation as described in Section 33.6.2. */
+	spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
+	spu_an_control.s.an_en = use_auto_neg;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface), spu_an_control.u64);
+
+	spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_FEC_CONTROL(index, interface));
+	spu_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface));
+	spu_an_adv.s.fec_req = spu_fec_control.s.fec_en;
+	spu_an_adv.s.fec_able = 1;
+	spu_an_adv.s.a100g_cr10 = 0;
+	spu_an_adv.s.a40g_cr4 = (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) ;
+	spu_an_adv.s.a40g_kr4 = (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) ;
+	spu_an_adv.s.a10g_kr = (mode == CVMX_HELPER_INTERFACE_MODE_XFI) ;
+	spu_an_adv.s.a10g_kx4 = (mode == CVMX_HELPER_INTERFACE_MODE_XFI) ;
+	spu_an_adv.s.a1g_kx = 0;
+	spu_an_adv.s.rf = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface), spu_an_adv.u64);
+
+	/* 3. Set BGX(0..5)_SPU_DBG_CONTROL[AN_ARB_LINK_CHK_EN] = 1. */
+	spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface));
+	spu_dbg_control.s.an_arb_link_chk_en = use_auto_neg;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface), spu_dbg_control.u64);
+
+	/* 4. Execute the link bring-up sequence in Section 33.6.3. */
+
+	/* 5. If the auto-negotiation protocol is successful,
+	   BGX(0..5)_SPU(0..3)_AN_ADV[AN_COMPLETE] is set along with
+	   BGX(0..5)_SPU(0..3)_INT[AN_COMPLETE] when the link is up. */
+	
+
+	/* 3h. Set BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 1 and
+	      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0 to enable the LMAC. */
 	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	cmr_config.s.data_pkt_tx_en = 1;
-	cmr_config.s.data_pkt_rx_en = 1;
 	cmr_config.s.enable = 1;
 	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
-	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
-		spu_misc_control.s.rx_packet_dis = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
-	}
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.s.lo_pwr = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+
+	/* 4b. Set the polarity and lane swapping of the QLM SerDes. Refer to
+	   Section 33.4.1, BGX(0..5)_SPU(0..3)_MISC_CONTROL[XOR_TXPLRT,XOR_RXPLRT]
+	   and BGX(0..5)_SPU(0..3)_MISC_CONTROL[TXPLRT,RXPLRT]. */
+
+	/* 4c. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0. */
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+	spu_control1.s.lo_pwr = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+
+	/* 4d. Select Deficit Idle Count mode and unidirectional enable/disable
+	   via BGX(0..5)_SMU(0..3)_TX_CTL[DIC_EN,UNI_EN]. */
+	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
+	smu_tx_ctl.s.dic_en = 1;
+	smu_tx_ctl.s.uni_en = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface), smu_tx_ctl.u64);
 
 	return 0;
 }
 
 int __cvmx_helper_bgx_xaui_enable(int xiface)
 {
-	cvmx_bgxx_smux_tx_append_t smu_tx_append;
+	//cvmx_bgxx_smux_tx_append_t smu_tx_append;
 	cvmx_bgxx_smux_tx_thresh_t smu_tx_thresh;
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	int index;
@@ -923,16 +947,11 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 
 	__cvmx_bgx_common_init(xiface);
 	for (index = 0; index < num_ports; index++) {
-		int res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
+		int res = __cvmx_helper_bgx_xaui_init(index, xiface);
 		if (res == -1) {
 			cvmx_dprintf("Failed to enable XAUI for BGX(%d,%d)\n", interface, index);
 			return res;
 		}
-		smu_tx_append.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface));
-		smu_tx_append.s.fcs_c = 0;
-		smu_tx_append.s.fcs_d = 0;
-		smu_tx_append.s.pad = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface), smu_tx_append.u64);
 		smu_tx_thresh.u64 = 0;
 		if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
 		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
@@ -953,47 +972,187 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 	return 0;
 }
 
+static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int interface = xi.interface;
+	int node = xi.node;
+	cvmx_bgxx_spux_br_status1_t spu_status1;
+	cvmx_bgxx_spux_status2_t spu_status2;
+	cvmx_bgxx_spux_int_t spu_int;
+	cvmx_bgxx_spux_misc_control_t spu_misc_control;
+	cvmx_helper_interface_mode_t mode;
+
+	mode = cvmx_helper_interface_get_mode(xiface);
+
+	/* Disable packet reception */
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.s.rx_packet_dis = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+
+	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+
+			spu_int.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface));
+			if (!spu_int.s.training_done) {
+				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+				/* Clear the training interrupts (W1C) */
+
+				spu_int.u64 = 0;
+				spu_int.s.training_failure = 1;
+				spu_int.s.training_done = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
+
+				/* Restart training */
+				pmd_control.u64 = cvmx_read_csr_node(node,
+							CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+				pmd_control.s.train_restart = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
+
+				//cvmx_dprintf("Restarting link training failed\n");
+				return -1;
+			}
+		}
+
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(index, interface),
+					  cvmx_bgxx_spux_control1_t, reset, ==, 0, 10000)) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS in reset", node, interface, index);
+			return -1;
+		}
+
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface),
+					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000))
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
+                		return -1;
+		} else {
+			/* (5) Check to make sure that the link appears up and stable. */
+			/* Wait for PCS to be aligned */
+			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(index, interface),
+				  cvmx_bgxx_spux_bx_status_t, alignd, ==, 1, 10000)) {
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS not aligned\n", node, interface, index);
+				return -1;
+			}
+		}
+
+		/* Clear rcvflt bit (latching high) and read it back */
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		spu_status2.s.rcvflt = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface), spu_status2.u64);
+
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		if (spu_status2.s.rcvflt) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n",
+					node, interface, index);
+			
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+				spu_int.u64 = 0;
+				spu_int.s.training_failure = 1;
+				spu_int.s.training_done = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
+
+				/* Restart training */
+				pmd_control.u64 = cvmx_read_csr_node(node,
+							CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+				pmd_control.s.train_restart = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
+			}
+			return -1;
+		}
+
+		/* Wait for MAC RX to be ready */
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_RX_CTL(index, interface),
+					  cvmx_bgxx_smux_rx_ctl_t, status, ==, 0, 10000)) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not ready\n", node, interface, index);
+			return -1;
+		}
+
+		/* Wait for BGX RX to be idle */
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
+				  cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000)) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: RX not idle\n", node, interface, index);
+			return -1;
+		}
+
+		/* Wait for GMX TX to be idle */
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
+				  cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000)) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: TX not idle\n", node, interface, index);
+			return -1;
+		}
+
+		/* rcvflt should still be 0 */
+		spu_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS2(index, interface));
+		if (spu_status2.s.rcvflt) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n", node, interface, index);
+			return -1;
+		}
+
+		/* Receive link is latching low. Force it high and verify it */
+		spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
+		spu_status1.s.rcv_lnk = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface), spu_status1.u64);
+
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_STATUS1(index, interface),
+				cvmx_bgxx_spux_status1_t, rcv_lnk, ==, 1, 10000)) {
+			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive link down\n", node, interface, index);
+			return -1;
+		}
+	}
+
+	/* (7) Enable packet transmit and receive */
+	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+	spu_misc_control.s.rx_packet_dis = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+
+	return 0;
+}
+
 cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 {
-	cvmx_helper_link_info_t result;
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
-	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
-	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_bgxx_spux_br_status1_t spu_status1;
+	cvmx_helper_link_info_t result;
 
-	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
-	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
-	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface));
 	result.u64 = 0;
 
-	/* Only return a link if both RX and TX are happy */
-	if ((smu_tx_ctl.s.ls == 0) &&
-	    (smu_rx_ctl.s.status == 0) &&
-	    (spu_status1.s.rcv_lnk == 1)) {
-		cvmx_bgxx_cmrx_config_t cmr_config;
-		int qlm = cvmx_qlm_interface(interface);
+	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
+	
+	if (spu_status1.s.rcv_lnk) {
+		int lanes;
+		int qlm = cvmx_qlm_interface(xiface);
+		uint64_t speed;
+		cvmx_helper_interface_mode_t mode;
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = cvmx_qlm_get_gbaud_mhz(qlm) * 8 / 10;
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-		if (cmr_config.s.enable) {
-			int res;
-			res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
-			if (res == -1)
-				cvmx_dprintf("Failed to get BGX(%d,%d) link\n", interface, index);
+		speed = cvmx_qlm_get_gbaud_mhz(qlm);
+		mode = cvmx_helper_interface_get_mode(xiface);
+		lanes = 4 / cvmx_helper_ports_on_interface(xiface);
+
+		switch(mode) {
+		case CVMX_HELPER_INTERFACE_MODE_XFI:
+		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+			/* Using 64b66b symbol encoding */
+			speed = (speed * 64 + 33) / 66;
+			break;
+		default:
+			/* Using 8b10b symbol encoding */
+			speed = (speed * 8 + 5) / 10;
+			break;
 		}
+		speed *= lanes;
+		result.s.speed = speed;
 	} else {
-		/* Disable GMX and PCSX interrupts. */
-		if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-			cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface), ~0x0ull);
-			cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface), ~0x0ull);
-			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), ~0x0ull);
-		}
+		int res;
+		res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
+		if (res == -1)
+			cvmx_dprintf("Failed to get BGX(%d,%d) link\n", interface, index);
 	}
 
 	return result;
@@ -1009,7 +1168,6 @@ int __cvmx_helper_bgx_xaui_link_set(int xipd_port, cvmx_helper_link_info_t link_
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
-	//cvmx_bgxx_spux_br_status1_t spu_status1;
 
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 4876a40..13b8cf7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -204,7 +204,7 @@ static int __switch_mdio_mux(int ipd_port, const cvmx_phy_info_t *phy_info);
 static int __mdiobus_addr_to_unit(uint32_t addr)
 {
 	int unit = (addr >> 7) & 3;
-	if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX) || !OCTEON_IS_MODEL(OCTEON_CN78XX))
 		unit >>= 1;
 	return unit;
 }
@@ -379,11 +379,263 @@ __cvmx_78xx_bgx_reg_addr_to_xiface(uint64_t bgx_addr)
 		xi.node = -1;
 		return xi;
 	}
-	xi.interface = (bgx_addr >> 28) & 0x0F;
+	xi.interface = (bgx_addr >> 24) & 0x0F;
 
 	return xi;
 }
 
+static void __cvmx_mdio_addr_to_node_bus(uint64_t addr, int *node, int *bus)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		if (node)
+			*node = cvmx_csr_addr_to_node(addr);
+		addr = cvmx_csr_addr_strip_node(addr);
+	} else {
+		if (node)
+			*node = 0;
+	}
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		switch (addr) {
+		case 0x0001180000003800:
+			*bus = 0;
+			break;
+		case 0x0001180000003880:
+			*bus = 1;
+			break;
+		case 0x0001180000003900:
+			*bus = 2;
+			break;
+		case 0x0001180000003980:
+			*bus = 3;
+			break;
+		default:
+			*bus = -1;
+			cvmx_printf("%s: Invalid SMI bus address 0x%llx\n",
+				    __func__, (unsigned long long) addr);
+			break;
+		}
+	} else {
+		switch (addr) {
+		case 0x0001180000001800:
+			*bus = 0;
+			break;
+		case 0x0001180000001900:
+			*bus = 1;
+			break;
+		default:
+			*bus = -1;
+			cvmx_printf("%s: Invalid SMI bus address 0x%llx\n",
+				    __func__, (unsigned long long) addr);
+			break;
+		}
+	}
+}
+
+#if 0
+static int __cvmx_helper_dt_process_mdio_mux(void *fdt_addr, int mdio_offset,
+					     int mux_offset,
+					     struct cvmx_phydev_mux_info *mux_info)
+{
+	int phandle;
+	uint32_t *pgpio_handle;
+	int smi_offset;
+	int gpio_offset;
+	uint64_t *smi_addrp;
+	uint64_t smi_addr;
+	uint64_t mdio_base;
+	int len;
+	int gpio_count;
+	uint32_t *prop_val;
+	int offset;
+	const char *prop_name;
+	int gpio_value;
+	int node = 0;
+	int bus = 0;
+
+	memset(mux_info, 0, sizeof(*mux_info));
+	mux_info->gpio_value = cvmx_fdt_get_int(fdt_addr, mdio_offset, "reg", -1);
+	if (mux_info->gpio_value < 0) {
+		cvmx_printf("Could not get register value from muxed MDIO bus from DT\n");
+		return -1;
+	}
+	mux_info->direct_connect = 0;
+
+	smi_offset = cvmx_fdt_lookup_phandle(fdt_addr, mux_offset,
+					     "mdio-parent-bus");
+	if (smi_offset < 0) {
+		cvmx_printf("Could not get parent mdio bus\n");
+		return -1;
+	}
+	/* Now have address of SMI controller, use to get node and MDIO
+	 * controller number
+	 */
+	smi_addr = cvmx_fdt_get_uint64(fdt_addr, smi_offset, "reg", 0);
+	if (smi_addr)
+		smi_addr = cvmx_fdt_translate_address(fdt_addr, smi_offset,
+						      smi_addr);
+
+	ret = fdt_node_check_compatible(fdt_addr, parent,
+					"cavium,octeon-3860-mdio");
+	if (!ret) {
+		mdio_base = cvmx_fdt_get_uint64_t(fdt_addr, parent, "reg", 0);
+		if (!mdio_base) {
+			cvmx_printf("ERROR: Unable to get reg property in PHY MDIO\n");
+			return -1;
+		}
+		mdio_base = cvmx_fdt_translate_address(fdt_addr, parent,
+						       mdio_base);
+		if (mdio_base == FDT_ADDR_T_NONE) {
+			cvmx_printf("ERROR: Unable to get reg property in PHY MDIO\n");
+			return -1;
+		}
+		__cvmx_mdio_addr_to_node_bus(mdio_base, &node, &bus);
+		if (device_tree_dbg)
+			cvmx_dprintf("%s: phy parent: %s, reg base: 0x%08x, node: %d, bus: %d\n",
+				     __func__,
+				     fdt_get_name(fdt_addr, parent, NULL),
+				     mdio_base, node, bus);
+	}
+
+}
+
+static int __cvmx_helper_dt_add_phy(void *fdt_addr, int phy_node)
+{
+	const char *compat_str;
+	int len;
+	int parent, mdio_parent;
+	int ret;
+
+	compat_str = (const char *)fdt_getprop(fdt_addr, phy_node,
+					       "compatible", NULL);
+	if (!compat_str) {
+		cvmx_printf("Error: PHY entry in device tree missing compatible string\n");
+		return -1;
+	}
+
+	parent = fdt_parent_offset(fdt_addr, phy_node);
+	/* For multi-phy devices and devices ona  MUX go to the parent */
+	if (!fdt_node_check_compatible(fdt_addr, parent, "ethernet-phy-nexus"))
+		parent = fdt_parent_offset(fdt_addr, parent);
+
+	/* Check for a muxed MDIO parent */
+	mdio_parent = fdt_parent_offset(fdt_addr, parent);
+	if (!fdt_node_check_compatible(fdt_addr, mdio_parent,
+				       "cavium,mdio-mux")) {
+		ret = __cvmx_helper_dt_process_mdio_mux(fdt_addr, parent,
+							mdio_parent);
+	}
+}
+#endif
+
+/** NOTE: Quick hack! */
+int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
+{
+	static void *fdt_addr = NULL;
+	const char *compat;
+	int phy;
+	int parent;
+	uint64_t mdio_base;
+	int node, bus;
+	int phy_addr;
+	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	int xiface = cvmx_helper_get_interface_num(ipd_port);
+
+	if (fdt_addr == NULL)
+		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
+						   OCTEON_FDT_MAX_SIZE);
+
+	if (device_tree_dbg)
+		cvmx_dprintf("%s(0x%p, %d) ENTER\n",
+			     __func__, phy_info, ipd_port);
+
+	phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
+	if (phy < 0) {
+		if (device_tree_dbg)
+			cvmx_dprintf("No config present, calling __cvmx_helper_parse_78xx_bgx_dt\n");
+		if (__cvmx_helper_parse_78xx_bgx_dt(fdt_addr)) {
+			cvmx_printf("Error: could not parse 78xx BGX\n");
+			return -1;
+		}
+		phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
+		if (phy < 0) {
+			cvmx_printf("%s: Cannot find PHY node in device tree\n", __func__);
+			return -1;
+		}
+	}
+
+	phy_info->direct_connect = 1;
+	compat = (const char *)fdt_getprop(fdt_addr, phy, "compatible", NULL);
+	if (!compat) {
+		cvmx_printf("ERROR: no compatible prop in phy\n");
+		return -1;
+	}
+
+	if (device_tree_dbg)
+		cvmx_dprintf("  compatible: %s\n", compat);
+
+	phy_addr = cvmx_fdt_get_int(fdt_addr, phy, "reg", -1);
+	if (phy_addr == -1) {
+		cvmx_printf("Error: could not get PHY address\n");
+		return -1;
+	}
+	if (device_tree_dbg)
+		cvmx_dprintf("  PHY address: %d\n", phy_addr);
+
+	if (!memcmp("marvell", compat, strlen("marvell")))
+		phy_info->phy_type = MARVELL_GENERIC_PHY;
+	else if (!memcmp("broadcom", compat, strlen("broadcom")))
+		phy_info->phy_type = BROADCOM_GENERIC_PHY;
+
+	parent = fdt_parent_offset(fdt_addr, phy);
+	if (!fdt_node_check_compatible(fdt_addr, parent, "ethernet-phy-nexus")) {
+		parent = fdt_parent_offset(fdt_addr, parent);
+		if (device_tree_dbg)
+			cvmx_dprintf("  nexus PHY found\n");
+	}
+
+	if (device_tree_dbg) {
+		cvmx_dprintf("  Parent: %s\n",
+			     fdt_get_name(fdt_addr, parent, NULL));
+	}
+	if (!fdt_node_check_compatible(fdt_addr, parent,
+				       "cavium,octeon-3860-mdio")) {
+		if (device_tree_dbg)
+			cvmx_dprintf("  Found Octeon MDIO\n");
+		mdio_base = cvmx_fdt_get_uint64(fdt_addr, parent, "reg",
+						FDT_ADDR_T_NONE);
+		if (device_tree_dbg)
+			cvmx_dprintf("  MDIO address: 0x%llx\n",
+				     (unsigned long long)mdio_base);
+
+		mdio_base = cvmx_fdt_translate_address(fdt_addr, parent,
+						       (uint32_t *)&mdio_base);
+		if (device_tree_dbg)
+			cvmx_dprintf("  Translated: 0x%llx\n",
+				     (unsigned long long)mdio_base);
+		if (mdio_base == FDT_ADDR_T_NONE) {
+			cvmx_printf("Could not get MDIO base address from reg field\n");
+			return -1;
+		}
+		__cvmx_mdio_addr_to_node_bus(mdio_base, &node, &bus);
+		if (bus < 0) {
+			cvmx_printf("Invalid MDIO address 0x%llx, could not detect bus and node\n",
+				    (unsigned long long)mdio_base);
+			return -1;
+		}
+		if (device_tree_dbg)
+			cvmx_dprintf("  MDIO node: %d, bus: %d\n", node, bus);
+		phy_info->mdio_unit = (node << 2) | (bus & 3);
+		phy_info->phy_addr = phy_addr | (phy_info->mdio_unit << 8);
+	} else {
+		cvmx_printf("%s: Error: incompatible MDIO bus %s for IPD port %d\n",
+			    __func__,
+			    (const char *)fdt_get_name(fdt_addr, parent, NULL), ipd_port);
+	}
+	if (device_tree_dbg)
+		cvmx_dprintf("%s: EXIT 0\n", __func__);
+	return 0;
+}
+
 /**
  * @INTERNAL
  * Parse the device tree and set whether a port is valid or not.
@@ -397,14 +649,13 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 	int port_index;
 	int dbg = device_tree_dbg;
 	struct cvmx_xiface xi;
-	int fdt_port_node;
+	int fdt_port_node = -1;
 	int fdt_interface_node;
 	int fdt_phy_node;
 	uint64_t reg_addr;
-	int index = -1;
 	int xiface;
 
-	while ((fdt_port_node = fdt_node_offset_by_compatible(fdt_addr, index,
+	while ((fdt_port_node = fdt_node_offset_by_compatible(fdt_addr, fdt_port_node,
 					"cavium,octeon-7890-bgx-port")) >= 0) {
 		/* Get the port number */
 		port_index = cvmx_fdt_get_int(fdt_addr, fdt_port_node,
@@ -413,6 +664,10 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 			cvmx_dprintf("Error: missing reg field for bgx port in device tree\n");
 			return -1;
 		}
+		if (dbg) {
+			cvmx_dprintf("%s: Parsing BGX port %d\n",
+				     __func__, port_index);
+		}
 		/* Get the interface number */
 		fdt_interface_node = fdt_parent_offset(fdt_addr, fdt_port_node);
 		if (fdt_interface_node < 0) {
@@ -443,6 +698,9 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 				     (unsigned long long)reg_addr);
 			return -1;
 		}
+		if (dbg)
+			cvmx_dprintf("%s: Found BGX node %d, interface %d\n",
+				     __func__, xi.node, xi.interface);
 		xiface = cvmx_helper_node_interface_to_xiface(xi.node,
 							      xi.interface);
 		cvmx_helper_set_port_fdt_node_offset(xiface, port_index,
@@ -450,13 +708,26 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 		cvmx_helper_set_port_valid(xiface, port_index, true);
 
 		fdt_phy_node = cvmx_fdt_lookup_phandle(fdt_addr, fdt_port_node,
-						       "phy");
+						       "phy-handle");
 		if (fdt_phy_node >= 0) {
 			cvmx_helper_set_phy_fdt_node_offset(xiface, port_index,
 							    fdt_phy_node);
+			if (dbg) {
+				cvmx_dprintf("%s: Setting PHY fdt node offset for interface 0x%x, port %d to %d\n",
+					     __func__, xiface, port_index,
+					     fdt_phy_node);
+				cvmx_dprintf("%s: PHY node name: %s\n",
+					     __func__,
+					     fdt_get_name(fdt_addr,
+							  fdt_phy_node, NULL));
+			}
+
 		} else {
 			cvmx_helper_set_phy_fdt_node_offset(xiface, port_index,
 							    -1);
+			if (dbg)
+				cvmx_dprintf("%s: No PHY fdt node offset for interface 0x%x, port %d to %d\n",
+					     __func__, xiface, port_index, fdt_phy_node);
 		}
 	}
 	return 0;
@@ -630,10 +901,15 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 	int dbg = device_tree_dbg;
 	int interface;
 
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return __cvmx_helper_78xx_parse_phy(phy_info, ipd_port);
+
 	if (fdt_addr == 0)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
 						   OCTEON_FDT_MAX_SIZE);
 
+	if (device_tree_dbg)
+		cvmx_dprintf("%s(%p, %d)\n", __func__, phy_info, ipd_port);
 	phy_info->phy_addr = -1;
 	phy_info->direct_connect = -1;
 	phy_info->phy_type = (cvmx_phy_type_t) -1;
@@ -1592,7 +1868,6 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
 	cvmx_phy_info_t phy_info;
-
 	result.u64 = 0;
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM) {
 		/* The simulator gives you a simulated 1Gbps full duplex link */
@@ -1602,7 +1877,13 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 		return result;
 	}
 
-	if (__get_phy_info_from_dt(&phy_info, ipd_port) < 0) {
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		if (__cvmx_helper_78xx_parse_phy(&phy_info, ipd_port)) {
+			cvmx_printf("Error parsing PHY info for 78xx for ipd port %d\n",
+				    ipd_port);
+		}
+	} else if (__get_phy_info_from_dt(&phy_info, ipd_port) < 0) {
 		/* If we can't get the PHY info from the device tree then try
 		 * the inband state.
 		 */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index 167b088..cbd4bd5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -205,8 +205,7 @@ int __cvmx_helper_pki_setup_fpa_pools(int node)
 		} else {
 			buffer_size = pki_dflt_pool[node].buffer_size;
 			if (pki_helper_debug)
-				cvmx_dprintf("pki-helper: set fpa pool %d with \
-					buffer size %d buffer cnt %d\n",
+				cvmx_dprintf("pki-helper: set fpa pool %d with buffer size %d buffer cnt %d\n",
 			pki_dflt_pool[node].pool_num, (int)buffer_size, (int)buffer_count);
 			cvmx_fpa3_pool_stack_init(node, pki_dflt_pool[node].pool_num, "PKI Pool0", 0,
 						 buffer_count, FPA_NATURAL_ALIGNMENT,
@@ -361,7 +360,7 @@ int __cvmx_helper_pki_global_setup(int node)
 	/* __cvmx_helper_setup_global_cfg(node);*/ /* vinita_to_do */
 	/*set up default cluster*/
 	__cvmx_helper_setup_pki_cluster_groups(node);
-	__cvmx_helper_pki_setup_sso_groups(node);
+	//__cvmx_helper_pki_setup_sso_groups(node);
 	__cvmx_helper_setup_pki_qpg_table(node);
 	/* __cvmx_helper_setup_pki_pcam_table(node); *//* vinita_to_do */
 	/*set up default vlan */
@@ -483,10 +482,14 @@ void cvmx_helper_pki_set_fcs_op(int node, int interface, int nports, int has_fcs
 
 	for (index = 0; index < nports; index++) {
 		pknd = cvmx_helper_get_pknd(interface, index);
-		/*vinita_to_do; find the cluster in use*/
-		pkind_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pknd, cluster));
-		pkind_cfg.s.fcs_pres = has_fcs;
-		cvmx_write_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pknd, cluster), pkind_cfg.u64);
+                while (cluster < CVMX_PKI_NUM_CLUSTER) {
+                    /*vinita_to_do; find the cluster in use*/
+                    pkind_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pknd, cluster));
+                    pkind_cfg.s.fcs_pres = has_fcs;
+                    cvmx_write_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pknd, cluster), pkind_cfg.u64);
+                    cluster++;
+                }
+                cluster =0;
 	}
 }
 
@@ -1238,7 +1241,7 @@ static const char* pki_ltype_sprint(int ltype) {
                 case CVMX_PKI_LTYPE_E_NVGRE:	return "(NVGRE)";
                 case CVMX_PKI_LTYPE_E_GTP:	return "(GTP)";
                 default: 			return "";
-}
+        }
 }
 
 void pki_wqe_dump(const cvmx_wqe_78xx_t* wqp)
@@ -1247,91 +1250,91 @@ void pki_wqe_dump(const cvmx_wqe_78xx_t* wqp)
         /* it is not cvmx_shared so per core only */
         static uint64_t count;
 
-        printf("Wqe entry for packet %ld\n", count++);
-        printf("    WORD%02d: %016lx", (int)0, wqp->word0.u64);
-        printf(" aura=0x%x", wqp->word0.aura);
-        printf(" apad=%d", wqp->word0.apad);
-        printf(" chan=0x%x", wqp->word0.channel);
-        printf(" bufs=%d" , wqp->word0.bufs);
-        printf(" style=0x%x" , wqp->word0.style);
-        printf(" pknd=0x%x" , wqp->word0.pknd);
-        printf("\n");
-        printf("    WORD%02d: %016lx", (int)1, wqp->word1.u64);
-        printf(" len=%d" , wqp->word1.len);
-        printf(" grp=0x%x" , wqp->word1.grp);
-        printf(" tt=%s", OCT_TAG_TYPE_STRING(wqp->word1.tag_type));
-        printf(" tag=0x%08x" , wqp->word1.tag);
-        printf("\n");
+        cvmx_dprintf("Wqe entry for packet %lld\n", (unsigned long long)count++);
+        cvmx_dprintf("    WORD%02d: %016llx", (int)0, (unsigned long long)wqp->word0.u64);
+        cvmx_dprintf(" aura=0x%x", wqp->word0.aura);
+        cvmx_dprintf(" apad=%d", wqp->word0.apad);
+        cvmx_dprintf(" chan=0x%x", wqp->word0.channel);
+        cvmx_dprintf(" bufs=%d" , wqp->word0.bufs);
+        cvmx_dprintf(" style=0x%x" , wqp->word0.style);
+        cvmx_dprintf(" pknd=0x%x" , wqp->word0.pknd);
+        cvmx_dprintf("\n");
+        cvmx_dprintf("    WORD%02d: %016llx", (int)1, (unsigned long long)wqp->word1.u64);
+        cvmx_dprintf(" len=%d" , wqp->word1.len);
+        cvmx_dprintf(" grp=0x%x" , wqp->word1.grp);
+        cvmx_dprintf(" tt=%s", OCT_TAG_TYPE_STRING(wqp->word1.tag_type));
+        cvmx_dprintf(" tag=0x%08x" , wqp->word1.tag);
+        cvmx_dprintf("\n");
         if (wqp->word2.u64) {
-                printf("    WORD%02d: %016lx"  , (int)2, wqp->word2.u64);
+                cvmx_dprintf("    WORD%02d: %016llx"  , (int)2, (unsigned long long)wqp->word2.u64);
                 if (wqp->word2.le_hdr_type)
-                        printf(" [LAE]");
+                        cvmx_dprintf(" [LAE]");
                 if (wqp->word2.lb_hdr_type)
-                        printf(" lbty=%d"  "%s",
+                        cvmx_dprintf(" lbty=%d"  "%s",
                                wqp->word2.lb_hdr_type, pki_ltype_sprint(wqp->word2.lb_hdr_type));
                 if (wqp->word2.lc_hdr_type)
-                        printf(" lcty=%d"  "%s",
+                        cvmx_dprintf(" lcty=%d"  "%s",
                                wqp->word2.lc_hdr_type, pki_ltype_sprint(wqp->word2.lc_hdr_type));
                 if (wqp->word2.ld_hdr_type)
-                        printf(" ldty=%d"  "%s",
+                        cvmx_dprintf(" ldty=%d"  "%s",
                                wqp->word2.ld_hdr_type, pki_ltype_sprint(wqp->word2.ld_hdr_type));
                 if (wqp->word2.le_hdr_type)
-                        printf(" lety=%d"  "%s",
+                        cvmx_dprintf(" lety=%d"  "%s",
                                wqp->word2.le_hdr_type, pki_ltype_sprint(wqp->word2.le_hdr_type));
                 if (wqp->word2.lf_hdr_type)
-                        printf(" lfty=%d"  "%s",
+                        cvmx_dprintf(" lfty=%d"  "%s",
                                wqp->word2.lf_hdr_type, pki_ltype_sprint(wqp->word2.lf_hdr_type));
                 if (wqp->word2.lg_hdr_type)
-                        printf(" lgty=%d"  "%s",
+                        cvmx_dprintf(" lgty=%d"  "%s",
                                wqp->word2.lg_hdr_type, pki_ltype_sprint(wqp->word2.lg_hdr_type));
                 if (wqp->word2.pcam_flag1)
-                        printf(" PF1");
+                        cvmx_dprintf(" PF1");
                 if (wqp->word2.pcam_flag2)
-                        printf(" PF2");
+                        cvmx_dprintf(" PF2");
                 if (wqp->word2.pcam_flag3)
-                        printf(" PF3");
+                        cvmx_dprintf(" PF3");
                 if (wqp->word2.pcam_flag4)
-                        printf(" PF4");
+                        cvmx_dprintf(" PF4");
                 if (wqp->word2.vlan_valid || wqp->word2.vlan_stacked) {
                         if (wqp->word2.vlan_valid)
-                                printf(" vlan valid");
+                                cvmx_dprintf(" vlan valid");
                         if (wqp->word2.vlan_stacked)
-                                printf(" vlan stacked");
-                        printf(" ");
+                                cvmx_dprintf(" vlan stacked");
+                        cvmx_dprintf(" ");
 }
-                if (wqp->word2.stat_inc) printf(" stat_inc");
-                if (wqp->word2.is_frag) printf(" L3 Fragment");
-                if (wqp->word2.is_l3_bcast) printf(" L3 Broadcast");
-                if (wqp->word2.is_l3_mcast) printf(" L3 Multicast");
-                if (wqp->word2.is_l2_bcast) printf(" L2 Broadcast");
-                if (wqp->word2.is_l2_mcast) printf(" L2 Multicast");
-                if (wqp->word2.is_raw) printf(" RAW");
+                if (wqp->word2.stat_inc) cvmx_dprintf(" stat_inc");
+                if (wqp->word2.is_frag) cvmx_dprintf(" L3 Fragment");
+                if (wqp->word2.is_l3_bcast) cvmx_dprintf(" L3 Broadcast");
+                if (wqp->word2.is_l3_mcast) cvmx_dprintf(" L3 Multicast");
+                if (wqp->word2.is_l2_bcast) cvmx_dprintf(" L2 Broadcast");
+                if (wqp->word2.is_l2_mcast) cvmx_dprintf(" L2 Multicast");
+                if (wqp->word2.is_raw) cvmx_dprintf(" RAW");
                 if (wqp->word2.err_level || wqp->word2.err_code) {
-                        printf(" errlev=%d" , wqp->word2.err_level);
-                        printf(" opcode=0x%x" , wqp->word2.err_code);
+                        cvmx_dprintf(" errlev=%d" , wqp->word2.err_level);
+                        cvmx_dprintf(" opcode=0x%x" , wqp->word2.err_code);
 }
-                printf("\n");
+                cvmx_dprintf("\n");
 }
-        printf("    WORD%02d: %016lx", (int)3, wqp->packet_ptr.u64);
+        cvmx_dprintf("    WORD%02d: %016llx", (int)3, (unsigned long long)wqp->packet_ptr.u64);
 
-        printf(" size=%d" , wqp->packet_ptr.size);
-        printf(" addr=0x%llx" , (unsigned long long)wqp->packet_ptr.addr);
+        cvmx_dprintf(" size=%d" , wqp->packet_ptr.size);
+        cvmx_dprintf(" addr=0x%llx" , (unsigned long long)wqp->packet_ptr.addr);
 
-        printf("\n");
+        cvmx_dprintf("\n");
         if (wqp->word4.u64) {
-                printf("    WORD%02d: %016lx", (int)4, wqp->word4.u64);
-                if (wqp->word4.ptr_layer_a) printf(" laptr=%d" , wqp->word4.ptr_layer_a);
-                if (wqp->word4.ptr_layer_b) printf(" lbptr=%d" , wqp->word4.ptr_layer_b);
-                if (wqp->word4.ptr_layer_c) printf(" lcptr=%d" , wqp->word4.ptr_layer_c);
-                if (wqp->word4.ptr_layer_d) printf(" ldptr=%d" , wqp->word4.ptr_layer_d);
-                if (wqp->word4.ptr_layer_e) printf(" leptr=%d" , wqp->word4.ptr_layer_e);
-                if (wqp->word4.ptr_layer_f) printf(" lfptr=%d" , wqp->word4.ptr_layer_f);
-                if (wqp->word4.ptr_layer_g) printf(" lgptr=%d" , wqp->word4.ptr_layer_g);
-                if (wqp->word4.ptr_vlan) printf(" vlptr=%d" , wqp->word4.ptr_vlan);
-                printf("\n");
+                cvmx_dprintf("    WORD%02d: %016llx", (int)4, (unsigned long long)wqp->word4.u64);
+                if (wqp->word4.ptr_layer_a) cvmx_dprintf(" laptr=%d" , wqp->word4.ptr_layer_a);
+                if (wqp->word4.ptr_layer_b) cvmx_dprintf(" lbptr=%d" , wqp->word4.ptr_layer_b);
+                if (wqp->word4.ptr_layer_c) cvmx_dprintf(" lcptr=%d" , wqp->word4.ptr_layer_c);
+                if (wqp->word4.ptr_layer_d) cvmx_dprintf(" ldptr=%d" , wqp->word4.ptr_layer_d);
+                if (wqp->word4.ptr_layer_e) cvmx_dprintf(" leptr=%d" , wqp->word4.ptr_layer_e);
+                if (wqp->word4.ptr_layer_f) cvmx_dprintf(" lfptr=%d" , wqp->word4.ptr_layer_f);
+                if (wqp->word4.ptr_layer_g) cvmx_dprintf(" lgptr=%d" , wqp->word4.ptr_layer_g);
+                if (wqp->word4.ptr_vlan) cvmx_dprintf(" vlptr=%d" , wqp->word4.ptr_vlan);
+                cvmx_dprintf("\n");
 }
         for (i=0; i < 10; ++i) {
-                if (wqp->wqe_data[i]) printf("    WORD%02d: %016lx"  "\n", i+5, wqp->wqe_data[i]);
+                if (wqp->wqe_data[i]) cvmx_dprintf("    WORD%02d: %016llx"  "\n", i+5, (unsigned long long)wqp->wqe_data[i]);
 }
 }
 #endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 8a0c9c8..0ca9e46 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -88,8 +88,8 @@ static const int cvmx_pko_default_channel_level = 0;
 static const int debug = 0;
 
 /* These global variables are relevant for boot CPU only */
-uint16_t __cvmx_pko3_aura_num = -1;
-uint16_t __cvmx_pko3_pool_num = -1;
+int16_t __cvmx_pko3_aura_num = 1020;
+int16_t __cvmx_pko3_pool_num = -1;
 
 /* This constant can not be modified, defined here for clarity only */
 #define CVMX_PKO3_POOL_BUFFER_SIZE 4096 /* 78XX PKO requires 4KB */
@@ -135,10 +135,14 @@ static int __cvmx_helper_pko3_res_owner(int ipd_port)
  */
 static int __cvmx_pko3_config_memory(unsigned node)
 {
-	int pool_num = 62, aura_num = 1022;
+	int pool_num , aura_num;
 	int pool, block_size;
+	unsigned buf_count;
 	int res;
 
+	aura_num = __cvmx_pko3_aura_num;
+	pool_num = __cvmx_pko3_pool_num;
+
         /* Check for legacy PKO buffer pool */
         pool = cvmx_fpa_get_pko_pool();
 	block_size = cvmx_fpa_get_block_size(pool);
@@ -158,12 +162,19 @@ static int __cvmx_pko3_config_memory(unsigned node)
 	}
 
 	if (aura_num != pool) {
-		res = cvmx_helper_fpa3_init_pool(node, node, &pool_num, CVMX_PKO3_POOL_BUFFER_SIZE,
-						 CVMX_PKO3_POOL_BUFFERS, "PKO Pool");
-		if (res < 0) return res;
-		res = cvmx_helper_fpa3_add_aura_to_pool(node, pool_num, &aura_num,
-							CVMX_PKO3_POOL_BUFFERS,
-							NULL, "PKO Aura");
+		/* XXX- temporary - learn buffer count from SSO */
+		unsigned int cvmx_sso_entries = 0;
+		buf_count = CVMX_PKO3_POOL_BUFFERS;
+		buf_count += cvmx_sso_entries * 4 * 9 / CVMX_PKO3_POOL_BUFFER_SIZE;
+		cvmx_dprintf("%s: creating aura %u with %u buffers\n",
+			__func__, aura_num, buf_count);
+
+		res = cvmx_helper_fpa_init(node, &pool_num, &aura_num,
+				CVMX_PKO3_POOL_BUFFER_SIZE,
+				buf_count,
+				"PKO Aura",
+				NULL);
+
 		if (res < 0) return res;
 	}
 
@@ -176,6 +187,8 @@ static int __cvmx_pko3_config_memory(unsigned node)
 
 	return aura_num;
 }
+
+
 #endif
 
 /** Initialize a single ILK link
@@ -988,16 +1001,16 @@ EXPORT_SYMBOL(__cvmx_helper_pko3_init_global);
  *
  * Should only be called once on each node
  *
- * TBD: Resolve the kernel case.
  * When Linux eats up the entire memory, bootmem will be unable to
  * satisfy our request, and the memory needs to come from Linux free pages.
  */
 int cvmx_helper_pko3_init_global(unsigned int node)
 {
-	uint16_t aura = -1;
+	void *ptr;
+	int res = -1;
+	int16_t aura = -1;
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	int res = 0;
 	/* Allocate memory required by PKO3 */
 	res = __cvmx_pko3_config_memory(node);
 	if(res < 0) {
@@ -1007,7 +1020,24 @@ int cvmx_helper_pko3_init_global(unsigned int node)
 	}
 	aura = res;
 #endif
-	return __cvmx_helper_pko3_init_global(node, aura);
+	/* Exercise the FPA to make sure the AURA is functional */
+	ptr = cvmx_fpa3_alloc_aura(node, aura);	/* FIXME: aura is global here ? */
+
+	if (ptr == NULL )
+		res = -1;
+	else {
+		cvmx_fpa3_free_aura(ptr, node, aura, 0);
+		res = 0;
+	}
+
+	if (res < 0) {
+		cvmx_dprintf("ERROR: %s: FPA failure AURA=%#x\n", __func__, aura);
+		return -1;
+	}
+
+	res = __cvmx_helper_pko3_init_global(node, aura);
+
+	return res;
 }
 
 /**
@@ -1030,17 +1060,13 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	if(__cvmx_helper_xiface_is_null(xiface)) {
-		/* Special case for interface=-1 is NULL interface */
+		/* Special case for NULL interface */
 		num_ports = 1;
 	} else {
 		cvmx_helper_interface_mode_t mode;
 		mode = cvmx_helper_interface_get_mode(xiface);
 		num_ports = cvmx_helper_interface_enumerate(xiface);
-
-		/* Override port-count for some interface types */
-		if ((mode == CVMX_HELPER_INTERFACE_MODE_NPI) ||
-			(mode == CVMX_HELPER_INTERFACE_MODE_LOOP))
-			num_ports = 1;
+		(void) mode;
 	}
 
 	/* Skip non-existent interfaces silently */
@@ -1152,7 +1178,10 @@ int cvmx_helper_pko3_shutdown(unsigned int node)
 	 /* destroy NULL interface here, only PKO knows about it */
 	cvmx_helper_pko3_shut_interface(cvmx_helper_node_interface_to_xiface(node, __CVMX_XIFACE_NULL));
 
-	 /* Check that all DQs are closed */
+#if 0
+	//XXX- this seems to cause issue on HW
+	// At least the error code differs from expected
+	/* Check that all DQs are closed */
 	for(dq =0; dq < (1<<10); dq++) {
 		res = cvmx_pko3_dq_close(node, dq);
 		if (res != 0) {
@@ -1162,13 +1191,13 @@ int cvmx_helper_pko3_shutdown(unsigned int node)
 			return -1;
 		}
 	}
-
+#endif
+	(void) dq;
 	res = cvmx_pko3_hw_disable(node);
 
-#if 0
-	//XXX- shut down AURA/POOL we created, avoid warning
-	cvmx_fpa3_assign_aura(node, __cvmx_pko3_aura_num, 0);
-	cvmx_fpa3_disable_pool(node, __cvmx_pko3_pool_num);
-#endif
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* shut down AURA/POOL we created, and free its resources */
+	cvmx_helper_fpa3_shutdown_aura_and_pool(node, __cvmx_pko3_aura_num);
+#endif /* CVMX_BUILD_FOR_LINUX_KERNEL */
 	return res;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 3b376e0..56a68ee 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -549,10 +549,6 @@ void cvmx_helper_free_packet_data(cvmx_wqe_t *work)
 		bptr.u64 = buffer_ptr.u64;
 		next_buffer_ptr = *(uint64_t *)
 			cvmx_phys_to_ptr(bptr.addr - 8);
-		if (!bptr.packet_outside_wqe) {
-			buffer_ptr.u64 = next_buffer_ptr;
-			number_buffers--;
-		}
 	} else {
 		start_of_buffer =
 			((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 38dda54..89596e9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -1583,12 +1583,15 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		//FIXME- ILK needs this config data for now - must fix!
 		__cvmx_helper_init_port_config_data();
-		cvmx_helper_pko3_init_global(node);
+		result = cvmx_helper_pko3_init_global(node);
 	}
 	else {
-		cvmx_helper_pko_init();
+		result = cvmx_helper_pko_init();
 	}
 
+	if (result < 0)
+		return result;
+
 	for (interface = 0; interface < num_interfaces; interface++) {
 		/* Skip invalid/disabled interfaces */
 		if (cvmx_helper_ports_on_interface(interface) <= 0)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index d2513d8..c5ef6b7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -43,7 +43,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 95721 $<hr>
+ * <hr>$Revision: 97778 $<hr>
  *
  */
 
@@ -75,13 +75,14 @@ CVMX_SHARED cvmx_spinlock_t cvmx_l2c_spinlock;
 int cvmx_l2c_get_core_way_partition(uint32_t core)
 {
 	uint32_t field;
+	int node = cvmx_get_node_num();
 
 	/* Validate the core number */
 	if (core >= cvmx_octeon_num_cores())
 		return -1;
 
 	if (OCTEON_IS_OCTEON2() || OCTEON_IS_OCTEON3())
-		return (cvmx_read_csr(CVMX_L2C_WPAR_PPX(core)) & 0xffff);
+		return (cvmx_read_csr_node(node, CVMX_L2C_WPAR_PPX(core)) & 0xffff);
 
 	/*
 	 * Use the lower two bits of the coreNumber to determine the
@@ -111,6 +112,7 @@ int cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)
 {
 	uint32_t field;
 	uint32_t valid_mask;
+	int node = cvmx_get_node_num();
 
 	valid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;
 
@@ -125,7 +127,7 @@ int cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)
 		return -1;
 
 	if (OCTEON_IS_OCTEON2() || OCTEON_IS_OCTEON3()) {
-		cvmx_write_csr(CVMX_L2C_WPAR_PPX(core), mask);
+		cvmx_write_csr_node(node, CVMX_L2C_WPAR_PPX(core), mask);
 		return 0;
 	}
 
@@ -160,6 +162,7 @@ int cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)
 int cvmx_l2c_set_hw_way_partition(uint32_t mask)
 {
 	uint32_t valid_mask;
+	int node = cvmx_get_node_num();
 
 	valid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;
 	mask &= valid_mask;
@@ -169,7 +172,7 @@ int cvmx_l2c_set_hw_way_partition(uint32_t mask)
 		return -1;
 
 	if (OCTEON_IS_OCTEON2() || OCTEON_IS_OCTEON3())
-		cvmx_write_csr(CVMX_L2C_WPAR_IOBX(0), mask);
+		cvmx_write_csr_node(node, CVMX_L2C_WPAR_IOBX(0), mask);
 	else
 		cvmx_write_csr(CVMX_L2C_SPAR4, (cvmx_read_csr(CVMX_L2C_SPAR4) & ~0xFF) | mask);
 	return 0;
@@ -177,8 +180,9 @@ int cvmx_l2c_set_hw_way_partition(uint32_t mask)
 
 int cvmx_l2c_get_hw_way_partition(void)
 {
+	int node = cvmx_get_node_num();
 	if (OCTEON_IS_OCTEON2() || OCTEON_IS_OCTEON3())
-		return cvmx_read_csr(CVMX_L2C_WPAR_IOBX(0)) & 0xffff;
+		return cvmx_read_csr_node(node, CVMX_L2C_WPAR_IOBX(0)) & 0xffff;
 	else
 		return cvmx_read_csr(CVMX_L2C_SPAR4) & (0xFF);
 }
@@ -186,23 +190,25 @@ int cvmx_l2c_get_hw_way_partition(void)
 int cvmx_l2c_set_hw_way_partition2(uint32_t mask)
 {
 	uint32_t valid_mask;
+	int node = cvmx_get_node_num();
 
 	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		return -1;
 
 	valid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;
 	mask &= valid_mask;
-	cvmx_write_csr(CVMX_L2C_WPAR_IOBX(1), mask);
+	cvmx_write_csr_node(node, CVMX_L2C_WPAR_IOBX(1), mask);
 	return 0;
 }
 
 int cvmx_l2c_get_hw_way_partition2(void)
 {
+	int node = cvmx_get_node_num();
 	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX))) {
 		cvmx_warn("only one IOB on this chip");
 		return -1;
 	}
-	return cvmx_read_csr(CVMX_L2C_WPAR_IOBX(1)) & 0xffff;
+	return cvmx_read_csr_node(node, CVMX_L2C_WPAR_IOBX(1)) & 0xffff;
 }
 
 void cvmx_l2c_config_perf(uint32_t counter, enum cvmx_l2c_event event, uint32_t clear_on_read)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index a13536b..c271410 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 97385 $<hr>
+ * <hr>$Revision: 97721 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1385,10 +1385,9 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		bar1_index.s.addr_idx += (((1ull << 28) / 16ull) >> 22);
 	}
 
-	/* Allow config retries for 250ms. Count is based off the 5Ghz SERDES
-	   clock */
+	/* Value is recommended in CSR files */
 	pemx_ctl_status.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(pcie_port));
-	pemx_ctl_status.cn63xx.cfg_rtry = 250 * 5000000 / 0x10000;
+	pemx_ctl_status.cn63xx.cfg_rtry = 32;
 	cvmx_write_csr(CVMX_PEMX_CTL_STATUS(pcie_port), pemx_ctl_status.u64);
 
 	/* Display the link status */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index 14e8371..d6bea5f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -753,13 +753,15 @@ void cvmx_pki_endis_fcs_check(int node, int pknd, bool fcs_chk, bool fcs_strip)
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
-	/*vinita_to_do; find the cluster in use*/
-	pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-	style = pkind_style.s.style;
-	style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-	style_cfg.s.fcs_chk = fcs_chk;
-	style_cfg.s.fcs_strip = fcs_strip;
-	cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+        while (cluster < CVMX_PKI_NUM_CLUSTER) {
+            pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+            style = pkind_style.s.style;
+            style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+            style_cfg.s.fcs_chk = fcs_chk;
+            style_cfg.s.fcs_strip = fcs_strip;
+            cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+            cluster++;
+        }
 }
 
 /**
@@ -780,14 +782,16 @@ void cvmx_pki_endis_l2_errs(int node, int pknd, bool l2len_err,
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
-	/*vinita_to_do; find the cluster in use*/
-	pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-	style = pkind_style.s.style;
-	style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-	style_cfg.s.lenerr_en = l2len_err;
-	style_cfg.s.maxerr_en = maxframe_err;
-	style_cfg.s.minerr_en = minframe_err;
-	cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+	while (cluster < CVMX_PKI_NUM_CLUSTER) {
+            pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+            style = pkind_style.s.style;
+            style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+            style_cfg.s.lenerr_en = l2len_err;
+            style_cfg.s.maxerr_en = maxframe_err;
+            style_cfg.s.minerr_en = minframe_err;
+            cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+            cluster++;
+        }
 }
 
 /**
@@ -802,13 +806,15 @@ void cvmx_pki_dis_frame_len_chk(int node, int pknd)
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
-	/*vinita_to_do; find the cluster in use*/
-	pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-	style = pkind_style.s.style;
-	style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-	style_cfg.s.maxerr_en = 0;
-	style_cfg.s.minerr_en = 0;
-	cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+	while (cluster < CVMX_PKI_NUM_CLUSTER) {
+            pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+            style = pkind_style.s.style;
+            style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+            style_cfg.s.maxerr_en = 0;
+            style_cfg.s.minerr_en = 0;
+            cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+            cluster++;
+        }
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index e883729..c9a6fe4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -123,6 +123,22 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	cvmx_pko_ptf_iobp_cfg_t ptf_iobp_cfg;
 	cvmx_pko_pdm_cfg_t pko_pdm_cfg;
 	cvmx_pko_enable_t pko_enable;
+	cvmx_pko_dpfi_status_t dpfi_status;
+	cvmx_pko_status_t pko_status;
+	uint64_t cycles;
+	const unsigned timeout = 100;	/* 100 milliseconds */
+
+	pko_enable.u64 = cvmx_read_csr_node(node, CVMX_PKO_ENABLE);
+	if (pko_enable.s.enable) {
+		cvmx_dprintf("WARNING: %s: PKO already enabled on node %u\n",
+			__func__, node);
+		return 0;
+	}
+
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 
 	/* Clear FLUSH command to be sure */
 	pko_flush.u64 = 0;
@@ -139,6 +155,31 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	dpfi_enable.s.enable = 1;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_ENA, dpfi_enable.u64);
 
+	/* Prepare timeout */
+        cycles = cvmx_get_cycle();
+        cycles += cvmx_clock_get_rate(CVMX_CLOCK_CORE)/1000 * timeout;
+
+	/* Wait until all pointers have been returned */
+	do {
+		pko_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_STATUS);
+		if (cycles < cvmx_get_cycle())
+			break;
+	} while (!pko_status.s.pko_rdy);
+
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+
+	if (!pko_status.s.pko_rdy) {
+		dpfi_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
+		cvmx_dprintf("ERROR: %s: PKO DFPI failed, "
+			"PKO_STATUS=%#llx DPFI_STATUS=%#llx\n", __func__,
+			(unsigned long long) pko_status.u64,
+			(unsigned long long) dpfi_status.u64);
+		return -1;
+	}
+
 	/* set max outstanding requests in IOBP for any FIFO */
 	ptf_iobp_cfg.u64 = 0;
 	ptf_iobp_cfg.s.max_read_size = 72;	/* HRM: typical=0x48 */
@@ -152,15 +193,19 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	/* Initialize MACs and FIFOs */
 	cvmx_pko_setup_macs(node);
 
-	//FIXME- error checking
-
-
 	/* enable PKO, although interfaces and queues are not up yet */
 	pko_enable.u64 = 0;
 	pko_enable.s.enable = 1;
 	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
 
-	return 0;
+	/* PKO_RDY set indicates succesful initialization */
+	pko_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_STATUS);
+	if (pko_status.s.pko_rdy)
+		return 0;
+
+	cvmx_dprintf("ERROR: %s: failed, PKO_STATUS=%#llx\n", __func__,
+		(unsigned long long) pko_status.u64);
+	return -1;
 }
 
 /**
@@ -169,11 +214,103 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 int cvmx_pko3_hw_disable(int node)
 {
 	cvmx_pko_dpfi_flush_t pko_flush;
-	cvmx_pko_dpfi_status_t pko_status;
+	cvmx_pko_dpfi_status_t dpfi_status;
 	cvmx_pko_dpfi_ena_t dpfi_enable;
 	cvmx_pko_enable_t pko_enable;
+	cvmx_pko_status_t pko_status;
 	uint64_t cycles;
 	const unsigned timeout = 100;	/* 100 milliseconds */
+	unsigned mac_num, fifo, i;
+
+	(void) pko_status;
+
+	/* Wait until there are no in-flight packets */
+	for(i = mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+		cvmx_pko_ptfx_status_t ptf_status;
+		ptf_status.u64 =
+			cvmx_read_csr_node(node, CVMX_PKO_PTFX_STATUS(mac_num));
+		if (debug)
+			cvmx_dprintf("%s: MAC %u in-flight %u total %u\n",
+				__func__, mac_num,
+				ptf_status.s.in_flight_cnt,
+				ptf_status.s.total_in_flight_cnt);
+		if (ptf_status.s.mac_num == 0x1f)
+			continue;
+		if (ptf_status.s.in_flight_cnt != 0) {
+			cvmx_dprintf("%s: MAC %d in-flight %d\n",
+				__func__, mac_num, ptf_status.s.in_flight_cnt);
+			mac_num --;
+			cvmx_wait(1000);
+		}
+	}
+
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+
+	//XXX- try to disable PKO first, then flush the DPFI
+	/* disable PKO - all packets should be out by now */
+	pko_enable.u64 = 0;
+	pko_enable.s.enable = 0;
+	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
+
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+
+	/* Reset L1_SQ */
+	for(i = 0; i < 32; i++) {
+		cvmx_pko_l1_sqx_topology_t pko_l1_topology;
+		cvmx_pko_l1_sqx_shape_t pko_l1_shape;
+		cvmx_pko_l1_sqx_link_t pko_l1_link;
+if(debug) cvmx_dprintf("%s: kill L1_SQ%d\n",__func__, i);
+		pko_l1_topology.u64 = 0;
+		pko_l1_topology.s.link = 0x1c;
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_TOPOLOGY(i),
+			pko_l1_topology.u64);
+
+		pko_l1_shape.u64 = 0;
+		pko_l1_shape.s.link = 0x1c;
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_SHAPE(i), pko_l1_shape.u64);
+
+		pko_l1_link.u64 = 0;
+		pko_l1_link.s.link = 0x1c;
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_LINK(i), pko_l1_link.u64);
+
+	}
+
+	/* Reset all MAC configurations */
+	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+		cvmx_pko_macx_cfg_t pko_mac_cfg;
+
+if(debug) cvmx_dprintf("%s: kill MAC %d\n",__func__, mac_num);
+		pko_mac_cfg.u64 = 0;
+		pko_mac_cfg.s.fifo_num = 0x1f;
+		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
+			pko_mac_cfg.u64);
+	}
+
+	/* Reset all FIFO groups */
+	for(fifo = 0; fifo < 8; fifo++) {
+		cvmx_pko_ptgfx_cfg_t pko_ptgfx_cfg;
+
+if(debug) cvmx_dprintf("%s: kill FIFO Group %d\n",__func__, fifo);
+		pko_ptgfx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_PTGFX_CFG(fifo));
+		/* Simulator asserts if an unused group is reset */
+		if (pko_ptgfx_cfg.u64 == 0)
+			continue;
+		pko_ptgfx_cfg.u64 = 0;
+		pko_ptgfx_cfg.s.reset = 1;
+		cvmx_write_csr_node(node, CVMX_PKO_PTGFX_CFG(fifo),
+					pko_ptgfx_cfg.u64);
+	}
+
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 
 	/* Set FLUSH_EN to return cached pointers to FPA */
 	pko_flush.u64 = 0;
@@ -184,81 +321,49 @@ int cvmx_pko3_hw_disable(int node)
         cycles = cvmx_get_cycle();
         cycles += cvmx_clock_get_rate(CVMX_CLOCK_CORE)/1000 * timeout;
 
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 	/* Wait until all pointers have been returned */
 	do {
-		pko_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
-		if (cycles > cvmx_get_cycle())
+		dpfi_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
+		if (cycles < cvmx_get_cycle())
 			break;
-	} while (!pko_status.s.cache_flushed);
+	} while (!dpfi_status.s.cache_flushed);
 
-	/* disable PKO - all packets should be out by now */
-	pko_enable.u64 = 0;
-	pko_enable.s.enable = 0;
-	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 
 	/* disable PKO buffer manager, should return all buffers to FPA */
 	dpfi_enable.u64 = 0;
 	dpfi_enable.s.enable = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_ENA, dpfi_enable.u64);
 
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+
 	/* Clear the FLISH_EN bit, as we are done */
 	pko_flush.u64 = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_FLUSH, pko_flush.u64);
 
-	if (pko_status.s.cache_flushed == 0) {
+	if (dpfi_status.s.cache_flushed == 0) {
 		cvmx_dprintf("%s: ERROR: timeout waiting for PKO3 ptr flush\n",
 			__FUNCTION__);
 		return -1;
 	}
 
-	return 0;
-}
-#if 0 //deprecated
-/*
- * Transmit packets through pko on specified node and queue.
- *
- * @param dq is the queue to write the commands to.
- * @param bufptr specifies packet in linked or gather mode.
- * @param packet_len is the total packet len of the packet in bufptr.
- * @param aura_free is the aura to free packet buffers after trasnmit.
- * @return returns 0 if successful and -1 on failure.
- *
- * NOTE: This is a tentative API, and supports a rather limitted
- * subset of PKO3 functionality. It only uses 2-word commands.
- */
-int cvmx_pko_transmit_packet(int dq, cvmx_buf_ptr_pki_t bufptr,
-			     int packet_len, int aura_free)
-{
-
-	unsigned port_node;
-	cvmx_pko_send_hdr_t pko_send_hdr;
-	cvmx_pko_query_rtn_t pko_status;
-	uint64_t words[2];
-
-	port_node = dq >> 14;
-	dq &= (1<<10)-1;
-
-	pko_send_hdr.u64 = 0;
-	pko_send_hdr.s.aura = aura_free;
-	/* TODO: n2 is not currently supported in simulator */
-	pko_send_hdr.s.n2 = 0;
-	pko_send_hdr.s.total = packet_len;
+if(debug)
+cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
+(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 
-	words[0] = pko_send_hdr.u64;
-	words[1] = bufptr.u64;
-
-	pko_status = __cvmx_pko3_do_dma(port_node, dq,
-		words, 2, CVMX_PKO_DQ_SEND);
-
-	if (pko_status.s.dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("%s: ERROR: failed to enqueue: %s\n",
-				__FUNCTION__,
-				pko_dqstatus_error(pko_status.s.dqstatus));
-		return -1;
-	}
 	return 0;
 }
-#endif
 
  /** Open configured descriptor queues before queueing packets into them.
  *
@@ -271,6 +376,9 @@ int cvmx_pko_dq_open(int node, int dq)
 	cvmx_pko_query_rtn_t pko_status;
 	pko_query_dqstatus_t dqstatus;
 
+	if(debug)
+		cvmx_dprintf("%s: DEBUG: dq %u\n", __FUNCTION__, dq);
+
 	pko_status = __cvmx_pko3_do_dma(node, dq, NULL, 0, CVMX_PKO_DQ_OPEN);
 
 	dqstatus = pko_status.s.dqstatus;
@@ -303,17 +411,24 @@ int cvmx_pko3_dq_close(int node, int dq)
 	cvmx_pko_query_rtn_t pko_status;
 	pko_query_dqstatus_t dqstatus;
 
+	if(debug)
+		cvmx_dprintf("%s: DEBUG: dq %u\n", __FUNCTION__, dq);
+
 	pko_status = __cvmx_pko3_do_dma(node, dq, NULL, 0, CVMX_PKO_DQ_CLOSE);
 
 	dqstatus = pko_status.s.dqstatus;
 
+#if 0
 	if (dqstatus == PKO_DQSTATUS_NOTCREATED)
 		return 0;
+#endif
 	if (dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("%s: ERROR: Failed to close dq :%u: %s\n",
+		cvmx_dprintf("%s: WARNING: Failed to close dq :%u: %s\n",	//XXX temp warn
 				__FUNCTION__, dq,
 				pko_dqstatus_error(dqstatus));
-		return -1;
+		cvmx_dprintf("%s: DEBUG: dq %u depth %u\n",
+			__FUNCTION__, dq, (unsigned) pko_status.s.depth);
+//		return -1; XXX- temporarily errors ignored XXX
 	}
 	return 0;
 }
@@ -327,16 +442,19 @@ int cvmx_pko3_dq_close(int node, int dq)
  */
 void cvmx_pko3_dq_drain(int node, int dq)
 {
-#ifdef	__SIM78XX_FIXED	//Until implemented in simulator
 	cvmx_pko_dqx_sw_xoff_t rxoff;
 
-	rxoff.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_SW_XOFF(dq));
-
+	rxoff.u64 = 0;
 	rxoff.s.drain_null_link = 1;
 	rxoff.s.drain = 1;
+	rxoff.s.xoff = 0;
 
 	cvmx_write_csr_node(node, CVMX_PKO_DQX_SW_XOFF(dq), rxoff.u64);
-#endif
+
+	cvmx_wait(100);
+
+	rxoff.u64 = 0;
+	cvmx_write_csr_node(node, CVMX_PKO_DQX_SW_XOFF(dq), rxoff.u64);
 }
 
  /**
@@ -365,6 +483,11 @@ int cvmx_pko3_dq_query(int node, int dq)
 		return -1;
 	}
 
+	/* Temp: debug for HW */
+	if (pko_status.s.depth > 0)
+		cvmx_dprintf("%s: DEBUG: dq %u depth %u\n",
+			__FUNCTION__, dq, (unsigned) pko_status.s.depth);
+
 	return pko_status.s.depth;
 }
 
@@ -757,6 +880,7 @@ int cvmx_pko3_interface_options(int xiface, int index,
 {
 	int mac_num;
 	cvmx_pko_macx_cfg_t pko_mac_cfg;
+	unsigned fifo_num;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	mac_num = __cvmx_pko3_get_mac_num(xiface, index);
@@ -769,16 +893,24 @@ int cvmx_pko3_interface_options(int xiface, int index,
 	if (pko_mac_cfg.s.fifo_num == 0x1f)
 		return -1;
 
+	/* WORKAROUND: Pass1 won't allow change any bits unless FIFO_NUM=0x1f */
+	fifo_num = pko_mac_cfg.s.fifo_num;
+	pko_mac_cfg.s.fifo_num = 0x1f;
+
 	pko_mac_cfg.s.min_pad_ena = pad_enable;
 	pko_mac_cfg.s.fcs_ena = fcs_enable;
 	pko_mac_cfg.s.fcs_sop_off = fcs_sop_off;
 
-	if (debug)
-		cvmx_dprintf("%s: PKO_MAC[%u]CFG=%#x\n",__func__,
-		mac_num, (unsigned) pko_mac_cfg.u64);
+	cvmx_write_csr_node(xi.node, CVMX_PKO_MACX_CFG(mac_num), pko_mac_cfg.u64);
 
+	pko_mac_cfg.s.fifo_num = fifo_num;
 	cvmx_write_csr_node(xi.node, CVMX_PKO_MACX_CFG(mac_num), pko_mac_cfg.u64);
 
+	if (debug)
+		cvmx_dprintf("%s: PKO_MAC[%u]CFG=%#llx\n",__func__,
+			mac_num, (unsigned long long)
+			cvmx_read_csr_node(xi.node, CVMX_PKO_MACX_CFG(mac_num)));
+
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_pko3_interface_options);
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index c674cb8..0f1410e 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -67,10 +67,13 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
-#define CVMX_FPA3_AURA_NUM       1024
-#define CVMX_FPA3_NUM_POOLS	64
-#define CVMX_FPA3_AURA_NAME_LEN  32
+#define CVMX_FPA3_AURA_NUM       	1024
+#define CVMX_FPA3_NUM_POOLS			64
+#define CVMX_FPA3_AURA_NAME_LEN  	32
 
+#define CVMX_FPA3_NULL_POOL 		0
+
+//#define CVMX_DEBUG_FPA3 			1
 /**
  * Struct describing load allocate operation addresses for FPA pool.
  */
@@ -159,6 +162,11 @@ static inline void *cvmx_fpa3_alloc_aura(unsigned int node, unsigned int aura)
 					 */
 	load_addr.aura = aura;   /* Aura number */
 
+#ifdef CVMX_DEBUG_FPA3
+	if (cvmx_fpa3_aura_to_pool(node, aura) == CVMX_FPA3_NULL_POOL)
+		cvmx_dprintf("Error: FPA aura %u assigned to null pool.\n", aura);
+#endif
+
 	address = cvmx_read64_uint64(load_addr.u64);
 	if (!address)
 		return NULL;
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index d8b46bd..4b73089 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -611,7 +611,7 @@ typedef union cvmx_gpio_clk_qlmx cvmx_gpio_clk_qlmx_t;
  * cvmx_gpio_clk_synce#
  *
  * A QLM can be configured as a clock source. The GPIO block can support up to two unique clocks
- * to send out any GPIO pin as configured by GPIO_BIT_CFG(0..19)[SYNCE_SEL]. The clock can be
+ * to send out any GPIO pin as configured by GPIO_BIT_CFG()[SYNCE_SEL]. The clock can be
  * divided by 20, 40, 80 or 160 of the selected RX lane clock.
  */
 union cvmx_gpio_clk_syncex {
@@ -792,7 +792,7 @@ union cvmx_gpio_intrx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
-                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(0..15). */
+                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(5). */
 #else
 	uint64_t intr                         : 1;
 	uint64_t reserved_1_63                : 63;
@@ -816,7 +816,7 @@ union cvmx_gpio_mc_intrx {
 	uint64_t intr                         : 48; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
                                                          is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
                                                          interrupt a different core using the CIU, and each core will then write one to clear its
-                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR(4..7)_PP(0..47). */
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
 #else
 	uint64_t intr                         : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 5b0a7c2..827a0e3 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -559,26 +559,169 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsi
 #define CVMX_GSERX_LANEX_LBERT_PAT_CFG(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_PX_MODE_0(unsigned long a, unsigned long b, unsigned long c)
+static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 13)) && ((b <= 3)) && ((c <= 11))))))
-		cvmx_warn("CVMX_GSERX_LANEX_PX_MODE_0(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
-	return CVMX_ADD_IO_SEG(0x00011800904E0040ull) + ((a) << 24) + ((b) << 20) + ((c) << 5);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904C0000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_MISC_CFG_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904C0008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_MISC_CFG_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904C0060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PCS_CTLIFC_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904C0068ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PCS_CTLIFC_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0068ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904C0070ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PCS_CTLIFC_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904C0070ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440280ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_AEQ_OUT_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440280ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440288ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_AEQ_OUT_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440288ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_AEQ_OUT_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
 #else
-#define CVMX_GSERX_LANEX_PX_MODE_0(a, b, c) (CVMX_ADD_IO_SEG(0x00011800904E0040ull) + ((a) << 24) + ((b) << 20) + ((c) << 5))
+#define CVMX_GSERX_LANEX_RX_CFG_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_PX_MODE_1(unsigned long a, unsigned long b, unsigned long c)
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 13)) && ((b <= 3)) && ((c <= 11))))))
-		cvmx_warn("CVMX_GSERX_LANEX_PX_MODE_1(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
-	return CVMX_ADD_IO_SEG(0x00011800904E0048ull) + ((a) << 24) + ((b) << 20) + ((c) << 5);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CFG_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440010ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CFG_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440010ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CFG_3(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_4(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CFG_4(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_5(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
 #else
-#define CVMX_GSERX_LANEX_PX_MODE_1(a, b, c) (CVMX_ADD_IO_SEG(0x00011800904E0048ull) + ((a) << 24) + ((b) << 20) + ((c) << 5))
+#define CVMX_GSERX_LANEX_RX_CFG_5(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsigned long block_id)
@@ -592,6 +735,17 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 #define CVMX_GSERX_LANEX_RX_CTLE_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_MISC_OVRRD(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_MISC_OVRRD(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -647,6 +801,28 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsign
 #define CVMX_GSERX_LANEX_RX_VMA_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_VMA_STATUS_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_VMA_STATUS_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -702,114 +878,136 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, un
 #define CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_COARSE_CTRL_0(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_COARSE_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_COARSE_CTRL_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_LPBKEN(block_id) (CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_COARSE_CTRL_1(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_COARSE_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_COARSE_CTRL_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_MODE(block_id) (CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_COARSE_CTRL_2(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_COARSE_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_COARSE_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_POFF(block_id) (CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E0040ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_PX_MODE_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E0040ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_PX_MODE_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(unsigned long offset, unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#define CVMX_GSERX_LANE_SRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull;
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_LPBKEN(block_id) (CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull;
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_MODE(block_id) (CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull;
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_POFF(block_id) (CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull;
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((block_id) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_SRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_0(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((block_id) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((block_id) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_1(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((block_id) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((block_id) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_2(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_PCIE_PCS_CLK_REQ(unsigned long block_id)
@@ -2856,184 +3054,571 @@ union cvmx_gserx_lanex_lbert_pat_cfg {
 typedef union cvmx_gserx_lanex_lbert_pat_cfg cvmx_gserx_lanex_lbert_pat_cfg_t;
 
 /**
- * cvmx_gser#_lane#_p#_mode_0
+ * cvmx_gser#_lane#_misc_cfg_0
  *
- * These are the RAW PCS per lane settings mode 0 registers. There is one register per
- * lane (0..3) per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a
- * given GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_px_mode_0 {
+union cvmx_gserx_lanex_misc_cfg_0 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_px_mode_0_s {
+	struct cvmx_gserx_lanex_misc_cfg_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
-	uint64_t ctle                         : 2;  /**< Continuous time linear equalizer pole configuration.
-                                                         0x0 = ~5dB of peaking at 4 GHz (Minimum bandwidth).
-                                                         0x1 =~10dB of peaking at 5 GHz
-                                                         0x2 = ~15dB of peaking at 5.5 GHz
-                                                         0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
-                                                         Recommended settings:
-                                                         R_25G_REFCLK100:          0x0
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x3
-                                                         R_125G_REFCLK15625_KX:    0x0
-                                                         R_3125G_REFCLK15625_XAUI: 0x0
-                                                         R_103125G_REFCLK15625_KR: 0x3
-                                                         R_125G_REFCLK15625_SGMII: 0x0
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x0
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x3 */
-	uint64_t pcie                         : 1;  /**< Selects between RX terminations.
-                                                         - 0: Differential termination
-                                                         - 1: Termination between pad and SDS_VDDS.
-                                                          Recommended settings:
-                                                          R_25G_REFCLK100:          0x1
-                                                          R_5G_REFCLK100:           0x1
-                                                          R_8G_REFCLK100:           0x0
-                                                          R_125G_REFCLK15625_KX:    0x0
-                                                          R_3125G_REFCLK15625_XAUI: 0x0
-                                                          R_103125G_REFCLK15625_KR: 0x0
-                                                          R_125G_REFCLK15625_SGMII: 0x0
-                                                          R_5G_REFCLK15625_QSGMII:  0x0
-                                                          R_625G_REFCLK15625_RXAUI: 0x0
-                                                          R_25G_REFCLK125:          0x1
-                                                          R_5G_REFCLK125:           0x1
-                                                          R_8G_REFCLK125:           0x0 */
-	uint64_t tx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
-                                                         0x0 = full data rate.
-                                                         0x1 = 1/2 data rate.
-                                                         0x2 = 1/4 data rate.
-                                                         0x3 = 1/8 data rate.
-                                                         Recommended settings:
-                                                         R_25G_REFCLK100:          0x1
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x0
-                                                         R_125G_REFCLK15625_KX:    0x2
-                                                         R_3125G_REFCLK15625_XAUI: 0x1
-                                                         R_103125G_REFCLK15625_KR: 0x0
-                                                         R_125G_REFCLK15625_SGMII: 0x2
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x1
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x0 */
-	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
-                                                         0x0 = full data rate
-                                                         0x1 = 1/2 data rate
-                                                         0x2 = 1/4 data rate
-                                                         0x3 = 1/8 data rate
-                                                         Recommended settings:
-                                                         R_25G_REFCLK100:          0x1
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x0
-                                                         R_125G_REFCLK15625_KX:    0x2
-                                                         R_3125G_REFCLK15625_XAUI: 0x1
-                                                         R_103125G_REFCLK15625_KR: 0x0
-                                                         R_125G_REFCLK15625_SGMII: 0x2
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x1
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x0 */
-	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
-                                                         rate.
-                                                         0x0 = Full rate
-                                                         0x1 = 1/2 data rate
-                                                         0x2 = 1/4 data rate
-                                                         0x3 = 1/8 data rate
-                                                         0x4 = 1/16 data rate
-                                                         else = Reserved.
-                                                         This field should always be cleared to zero (full rate). */
-	uint64_t reserved_4_4                 : 1;
-	uint64_t tx_mode                      : 2;  /**< TX data width:
+	uint64_t reserved_16_63               : 48;
+	uint64_t use_pma_polarity             : 1;  /**< If set, the PMA control is used to define the polarity.
+                                                         In not set, GSERX_LANE(0..3)_RX_CFG_0[CFG_RX_POL_INVERT]
+                                                         is used. */
+	uint64_t cfg_pcs_loopback             : 1;  /**< Assert for Parallel Loopback Raw PCS TX to Raw PCS RX. */
+	uint64_t pcs_tx_mode_ovrrd_en         : 1;  /**< Override enable for Raw PCS TX data width. */
+	uint64_t pcs_rx_mode_ovrrd_en         : 1;  /**< Override enable for Raw PCS RX data width. */
+	uint64_t cfg_eie_det_cnt              : 4;  /**< EIE detect state machine required number of consecutive
+                                                         PHY EIE status assertions to determine EIE and assert Raw
+                                                         PCS output pcs_mac_rx_eie_det_sts. */
+	uint64_t eie_det_stl_on_time          : 3;  /**< EIE detec state machine "on" delay prior to sampling
+                                                         PHY EIE status. */
+	uint64_t eie_det_stl_off_time         : 3;  /**< EIE detec state machine "off" delay prior to sampling
+                                                         PHY EIE status. */
+	uint64_t tx_bit_order                 : 1;  /**< 0x1: Reverse bit order of parallel data to SerDes TX.
+                                                         0x0: Maintain bit order of parallel data to SerDes TX. */
+	uint64_t rx_bit_order                 : 1;  /**< 0x1: Reverse bit order of parallel data to SerDes RX.
+                                                         0x0: Maintain bit order of parallel data to SerDes RX. */
+#else
+	uint64_t rx_bit_order                 : 1;
+	uint64_t tx_bit_order                 : 1;
+	uint64_t eie_det_stl_off_time         : 3;
+	uint64_t eie_det_stl_on_time          : 3;
+	uint64_t cfg_eie_det_cnt              : 4;
+	uint64_t pcs_rx_mode_ovrrd_en         : 1;
+	uint64_t pcs_tx_mode_ovrrd_en         : 1;
+	uint64_t cfg_pcs_loopback             : 1;
+	uint64_t use_pma_polarity             : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_misc_cfg_0_s  cn78xx;
+};
+typedef union cvmx_gserx_lanex_misc_cfg_0 cvmx_gserx_lanex_misc_cfg_0_t;
+
+/**
+ * cvmx_gser#_lane#_misc_cfg_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_misc_cfg_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_misc_cfg_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t par_tx_init                  : 1;  /**< Performs parallel initialization of SerDes interface TX
+                                                         fifo pointers. */
+	uint64_t tx_polarity                  : 1;  /**< Invert polarity of trasmitted bit stream.  Inversion is
+                                                         performed in the SerDes interface transmit datapth. */
+	uint64_t rx_polarity_ovrrd_en         : 1;  /**< Override mac_pcs_rxX_polarity control pin values
+                                                         When set, RX polarity inversion is specified from
+                                                         RX_POLARITY_OVRRD_VAL, and mac_pcs_rxX_polarity is ignored. */
+	uint64_t rx_polarity_ovrrd_val        : 1;  /**< Controls RX polarity inversion when RX_POLARITY_OVRRD_EN
+                                                         is set. Inversion is performed in the SerDes interface receive
+                                                         datapath. */
+	uint64_t reserved_2_8                 : 7;
+	uint64_t mac_tx_fifo_rd_ptr_ival      : 2;  /**< Initial value for MAC to PCS TX FIFO read pointer. */
+#else
+	uint64_t mac_tx_fifo_rd_ptr_ival      : 2;
+	uint64_t reserved_2_8                 : 7;
+	uint64_t rx_polarity_ovrrd_val        : 1;
+	uint64_t rx_polarity_ovrrd_en         : 1;
+	uint64_t tx_polarity                  : 1;
+	uint64_t par_tx_init                  : 1;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_misc_cfg_1_s  cn78xx;
+};
+typedef union cvmx_gserx_lanex_misc_cfg_1 cvmx_gserx_lanex_misc_cfg_1_t;
+
+/**
+ * cvmx_gser#_lane#_pcs_ctlifc_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_pcs_ctlifc_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t cfg_tx_vboost_en_ovrrd_val   : 1;  /**< Specifies TX VBOOST Enable request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_EN]. */
+	uint64_t cfg_tx_coeff_req_ovrrd_val   : 1;  /**< Specifies TX Coefficient request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_COEFF_REQ_OVRRD_EN]. */
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_val : 1;/**< Specifies RX CDR Coast request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_EN]. */
+	uint64_t cfg_tx_detrx_en_req_ovrrd_val : 1; /**< Specifies TX Detect RX request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_EN]. */
+	uint64_t cfg_soft_reset_req_ovrrd_val : 1;  /**< Specifies Soft Reset request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_EN]. */
+	uint64_t cfg_lane_pwr_off_ovrrd_val   : 1;  /**< Specifies Lane Power Off Reset request when its override bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_EN]. */
+	uint64_t cfg_tx_mode_ovrrd_val        : 2;  /**< Overide PCS TX mode (data width) when its overide bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_MODE_OVRRD_EN].
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
                                                          0x3 = 20-bit raw data. */
-	uint64_t rx_mode                      : 2;  /**< RX data width:
+	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;  /**< Overide TX pstate request when its overide bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
+	uint64_t cfg_lane_mode_req_ovrrd_val  : 4;  /**< Overide Lane Mode request when its overide bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_EN]. */
+#else
+	uint64_t cfg_lane_mode_req_ovrrd_val  : 4;
+	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;
+	uint64_t cfg_tx_mode_ovrrd_val        : 2;
+	uint64_t cfg_lane_pwr_off_ovrrd_val   : 1;
+	uint64_t cfg_soft_reset_req_ovrrd_val : 1;
+	uint64_t cfg_tx_detrx_en_req_ovrrd_val : 1;
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_val : 1;
+	uint64_t cfg_tx_coeff_req_ovrrd_val   : 1;
+	uint64_t cfg_tx_vboost_en_ovrrd_val   : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_pcs_ctlifc_0 cvmx_gserx_lanex_pcs_ctlifc_0_t;
+
+/**
+ * cvmx_gser#_lane#_pcs_ctlifc_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_pcs_ctlifc_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;  /**< Overide RX pstate request when its overide bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
+	uint64_t reserved_2_6                 : 5;
+	uint64_t cfg_rx_mode_ovrrd_val        : 2;  /**< Overide PCS RX mode (data width) when its overide bit
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_MODE_OVRRD_EN].
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
                                                          0x3 = 20-bit raw data. */
 #else
-	uint64_t rx_mode                      : 2;
-	uint64_t tx_mode                      : 2;
-	uint64_t reserved_4_4                 : 1;
-	uint64_t srate                        : 3;
-	uint64_t rx_ldiv                      : 2;
-	uint64_t tx_ldiv                      : 2;
-	uint64_t pcie                         : 1;
-	uint64_t ctle                         : 2;
-	uint64_t reserved_15_63               : 49;
+	uint64_t cfg_rx_mode_ovrrd_val        : 2;
+	uint64_t reserved_2_6                 : 5;
+	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;
+	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_px_mode_0_s   cn78xx;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_px_mode_0 cvmx_gserx_lanex_px_mode_0_t;
+typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
 
 /**
- * cvmx_gser#_lane#_p#_mode_1
+ * cvmx_gser#_lane#_pcs_ctlifc_2
  *
- * These are the RAW PCS per lane settings mode 1 registers. There is one register per lane
- * (0..3) per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a given
- * GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_px_mode_1 {
+union cvmx_gserx_lanex_pcs_ctlifc_2 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_px_mode_1_s {
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t vma_fine_cfg_sel             : 1;  /**< Recommended settings:
-                                                         1 = Enabled. Fine step adaptation selected (10.3125 Gbaud rate).
-                                                         0 = Disabled. Coarse step adaptation selected (rates lower than 10.3125 Gbaud). */
-	uint64_t vma_mm                       : 1;  /**< Manual DFE verses adaptive DFE mode. Recommended settings:
-                                                         0 = Adaptive DFE (5 Gbaud and higher)
-                                                         1 = Manual DFE, fixed tap (3.125 Gbaud and lower). */
-	uint64_t cdr_fgain                    : 4;  /**< CDR frequency gain.
-                                                         Recommended settings:
-                                                         R_25G_REFCLK100:          0xA
-                                                         R_5G_REFCLK100:           0xA
-                                                         R_8G_REFCLK100:           0xB
-                                                         R_125G_REFCLK15625_KX:    0xC
-                                                         R_3125G_REFCLK15625_XAUI: 0xC
-                                                         R_103125G_REFCLK15625_KR: 0xA
-                                                         R_125G_REFCLK15625_SGMII: 0xC
-                                                         R_5G_REFCLK15625_QSGMII:  0xC
-                                                         R_625G_REFCLK15625_RXAUI: 0xA
-                                                         R_25G_REFCLK125:          0xA
-                                                         R_5G_REFCLK125:           0xA
-                                                         R_8G_REFCLK125:           0xB */
-	uint64_t ph_acc_adj                   : 10; /**< Phase accumulator adjust.
-                                                         Recommended settings:
-                                                         R_25G_REFCLK100:          0x14
-                                                         R_5G_REFCLK100:           0x14
-                                                         R_8G_REFCLK100:           0x23
-                                                         R_125G_REFCLK15625_KX:    0x1E
-                                                         R_3125G_REFCLK15625_XAUI: 0x1E
-                                                         R_103125G_REFCLK15625_KR: 0xF
-                                                         R_125G_REFCLK15625_SGMII: 0x1E
-                                                         R_5G_REFCLK15625_QSGMII:  0x1E
-                                                         R_625G_REFCLK15625_RXAUI: 0x14
-                                                         R_25G_REFCLK125:          0x14
-                                                         R_5G_REFCLK125:           0x14
-                                                         R_8G_REFCLK125:           0x23 */
+	uint64_t ctlifc_ovrrd_req             : 1;  /**< Writing to set this bit initiates a state machine interface request
+                                                         for GSERX_LANE(0..3)_PCS_CTLIFC_0 and GSERX_LANE(0..3)_PCS_CTLIFC_1
+                                                         overide values. */
+	uint64_t reserved_9_14                : 6;
+	uint64_t cfg_tx_vboost_en_ovrrd_en    : 1;  /**< Override mac_pcs_txX vboost_en signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_VAL]. */
+	uint64_t cfg_tx_coeff_req_ovrrd_en    : 1;  /**< Override mac_pcs_txX_coeff_req signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_0[CFG_TX_COEFF_REQ_OVRRD_VAL]. */
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_en : 1; /**< Override mac_pcs_rxX_cdr_coast signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_VAL]. */
+	uint64_t cfg_tx_detrx_en_req_ovrrd_en : 1;  /**< Override mac_pcs_txX_detrx_en signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_VAL]. */
+	uint64_t cfg_soft_reset_req_ovrrd_en  : 1;  /**< Override mac_pcs_laneX_soft_rst signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_VAL]. */
+	uint64_t cfg_lane_pwr_off_ovrrd_en    : 1;  /**< Override mac_pcs_laneX_pwr_off signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_VAL]. */
+	uint64_t cfg_tx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_txX_pstate[1:0] signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_VAL].
+                                                         When using this field to change the TX Power State, you must also set
+                                                         the override enable bits for the lane_mode, soft_reset and lane_pwr_off
+                                                         fields.  The corresponding orrd_val fields should be programmed so as
+                                                         not to cause undesired changes. */
+	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_rxX_pstate[1:0] signal with the value specified in
+                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_PSTATE_REQ_OVRRD_VAL].
+                                                         When using this field to change the RX Power State, you must also set
+                                                         the override enable bits for the lane_mode, soft_reset and lane_pwr_off
+                                                         fields.  The corresponding orrd_val fields should be programmed so as
+                                                         not to cause undesired changes. */
+	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;  /**< Override mac_pcs_laneX_mode[3:0] signal with the value specified in
+                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_VAL]. */
+#else
+	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;
+	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;
+	uint64_t cfg_tx_pstate_req_ovrrd_en   : 1;
+	uint64_t cfg_lane_pwr_off_ovrrd_en    : 1;
+	uint64_t cfg_soft_reset_req_ovrrd_en  : 1;
+	uint64_t cfg_tx_detrx_en_req_ovrrd_en : 1;
+	uint64_t cfg_rx_cdr_coast_req_ovrrd_en : 1;
+	uint64_t cfg_tx_coeff_req_ovrrd_en    : 1;
+	uint64_t cfg_tx_vboost_en_ovrrd_en    : 1;
+	uint64_t reserved_9_14                : 6;
+	uint64_t ctlifc_ovrrd_req             : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
+
+/**
+ * cvmx_gser#_lane#_pma_loopback_ctrl
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_pma_loopback_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t cfg_ln_lpbk_mode_ovrrd_en    : 1;  /**< Enable override mac_pcs_loopbk_mode[3:0] with value of FG_LN_LPBK_MODE. */
+	uint64_t cfg_ln_lpbk_mode             : 1;  /**< Overide value when CFG_LN_LPBK_MODE_OVRRD_EN is set. */
 #else
-	uint64_t ph_acc_adj                   : 10;
-	uint64_t cdr_fgain                    : 4;
-	uint64_t vma_mm                       : 1;
-	uint64_t vma_fine_cfg_sel             : 1;
+	uint64_t cfg_ln_lpbk_mode             : 1;
+	uint64_t cfg_ln_lpbk_mode_ovrrd_en    : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_ctrl_t;
+
+/**
+ * cvmx_gser#_lane#_rx_aeq_out_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_aeq_out_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t sds_pcs_rx_aeq_out           : 10; /**< <9:5>: DFE TAP5
+                                                         <4:0>: DFE TAP4 */
+#else
+	uint64_t sds_pcs_rx_aeq_out           : 10;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_aeq_out_0 cvmx_gserx_lanex_rx_aeq_out_0_t;
+
+/**
+ * cvmx_gser#_lane#_rx_aeq_out_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_aeq_out_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t sds_pcs_rx_aeq_out           : 15; /**< <14:10>: DFE TAP3
+                                                         <9:5>: DFE TAP2
+                                                         <4:0>: DFE TAP1 */
+#else
+	uint64_t sds_pcs_rx_aeq_out           : 15;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_aeq_out_1 cvmx_gserx_lanex_rx_aeq_out_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_aeq_out_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_aeq_out_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t sds_pcs_rx_aeq_out           : 15; /**< <9:8> = Reserved.
+                                                         <7:4> = Pre-CTLE gain.
+                                                         <3:0> = Post-CTLE gain. */
+#else
+	uint64_t sds_pcs_rx_aeq_out           : 15;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
+	uint64_t pcs_sds_rx_tristate_enable   : 1;  /**< RX termination high-Z enable. */
+	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
+                                                         signal when GSEX_LANE(0..3)_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
+                                                         <10-8>:
+                                                           0x0 = 540mV.
+                                                           0x1 = 540mV + 20mV.
+                                                           0x2-0x3 = Reserved.
+                                                           0x4 = 100-620mV (default).
+                                                           0x5-0x7 = Reserved. */
+	uint64_t rx_datarate_ovrrd_val        : 2;  /**< Specifies the data rate when RX_DATARATE_OVRRD_EN is asserted:
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate. */
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSERX_LANE(0..3)_MISC_CFG_0[USE_PMA_POLARITY]
+                                                         is deasserted. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Override value for RX sub-block powerdown controls to RX
+                                                         when GSERX_LANE(0..3)_PWR_CTRL[RX_PD_OVVRD_EN] is asserted.
+                                                         <4> = CTLE.
+                                                         <3> = Reserved.
+                                                         <2> = Lane DLL.
+                                                         <1> = DFE/Samplers.
+                                                         <0> = Termination. */
+#else
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;
+	uint64_t cfg_rx_pol_invert            : 1;
+	uint64_t rx_datarate_ovrrd_val        : 2;
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;
+	uint64_t pcs_sds_rx_eyemon_en         : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;
+	uint64_t pcs_sds_rx_tristate_enable   : 1;
+	uint64_t rx_datarate_ovrrd_en         : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_0_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cfg_0 cvmx_gserx_lanex_rx_cfg_0_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_chpd_ovrrd_val            : 1;  /**< Override value for RX bias powerdown.  Applies when
+                                                         GSERX_LANE(3..0)_PWR_CTRL[RX_PD_PVRRD_EN] is asserted. */
+	uint64_t pcs_sds_rx_os_men            : 1;  /**< RX Offset manual enable. */
+	uint64_t eie_en_ovvrd_en              : 1;  /**< Override enable for Electrical-Idle-Exit circuit. */
+	uint64_t eie_en_ovvrd_val             : 1;  /**< Override value for Electrical-Idle-Exit circuit. */
+	uint64_t reserved_11_11               : 1;
+	uint64_t rx_pcie_mode_ovvrd_en        : 1;  /**< Override enable for RX_PCIE_MODE_OVVRD_VAL */
+	uint64_t rx_pcie_mode_ovvrd_val       : 1;  /**< Override value for RX_PCIE_MODE_OVVRD_VAL;
+                                                         selects between RX terminations.
+                                                         0x0 = pcs_sds_rx_terminate_to_vdda.
+                                                         0x1 = VDDA. */
+	uint64_t cfg_rx_dll_locken            : 1;  /**< Enable DLL lock when GSERX_LANE()_RX_MISC_OVRRD[CFG_RX_DLL_LOCKEN_OVRRD_EN] is asserted. */
+	uint64_t pcs_sds_rx_cdr_ssc_mode      : 8;  /**< Per lane RX CDR SSC control:
+                                                         <7:4> = Resrted.
+                                                         <3> = Clean SSC error flag.
+                                                         <2> = Diable SSC filter.
+                                                         <1> = Enable SSC value usage.
+                                                         <0> = Reserved. */
+#else
+	uint64_t pcs_sds_rx_cdr_ssc_mode      : 8;
+	uint64_t cfg_rx_dll_locken            : 1;
+	uint64_t rx_pcie_mode_ovvrd_val       : 1;
+	uint64_t rx_pcie_mode_ovvrd_en        : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t eie_en_ovvrd_val             : 1;
+	uint64_t eie_en_ovvrd_en              : 1;
+	uint64_t pcs_sds_rx_os_men            : 1;
+	uint64_t rx_chpd_ovrrd_val            : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_1_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cfg_1 cvmx_gserx_lanex_rx_cfg_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t pcs_sds_rx_terminate_to_vdda : 1;  /**< RX Termination control:
+                                                         0 = Floating.
+                                                         1 = Terminate to sds_vdda. */
+	uint64_t pcs_sds_rx_sampler_boost     : 2;  /**< Controls amount of boost.
+                                                         Note that this control can negatively impact reliability. */
+	uint64_t pcs_sds_rx_sampler_boost_en  : 1;  /**< Faster sampler c2q. For debug use only. */
+	uint64_t reserved_10_10               : 1;
+	uint64_t rx_sds_rx_agc_mval           : 10; /**< AGC manual value only used when GSERX_LANE()_RX_CFG_5[RX_AGC_MEN_OVVRD_VAL] is set.
+                                                         <9:8>: Reserved.
+                                                         <7:4>: Pre-CTL gain:
+                                                         0x0 = -6dB.
+                                                         0x1 = -5dB.
+                                                         0x3 = +5dB.
+                                                         <3:0>: Post-CTL gain (steps of 0.0875):
+                                                         0x0 = lowest.
+                                                         0xf = lowest * 2.3125. */
+#else
+	uint64_t rx_sds_rx_agc_mval           : 10;
+	uint64_t reserved_10_10               : 1;
+	uint64_t pcs_sds_rx_sampler_boost_en  : 1;
+	uint64_t pcs_sds_rx_sampler_boost     : 2;
+	uint64_t pcs_sds_rx_terminate_to_vdda : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_2_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cfg_2 cvmx_gserx_lanex_rx_cfg_2_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_3
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_3 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t cfg_rx_errdet_ctrl           : 16; /**< RX Adaptive Equalizer Control.
+                                                         Value of pcs_sds_rx_err_det_ctrl when
+                                                         GSERX_LANE(0..3)_MISC_OVVRD[CFG_RS_ERRDET_CTRL_OVRRD_EN]
+                                                         is set.
+                                                         <15:13>: Starting delta (6.7mV/step, 13.4mV + 6.7mV*N).
+                                                         <12:10>: Minimum delta to adapt to (6.7mV/step, 13.4mV + 6.7mV*N).
+                                                         <9:7>: Window mode (PM) delta (6.7mV/step, 13.4mV + 6.7mV*N).
+                                                         <6>: Enable DFE for edge samplers.
+                                                         <5:4>: Edge sampler DEF alpha:
+                                                         0x0 = 1/4.
+                                                         0x1 = 1/2.
+                                                         0x2 = 3/4.
+                                                         0x3 = 1.
+                                                         <3:0>: Q/QB error sampler 1 threshold, 6.7mV/step. */
+#else
+	uint64_t cfg_rx_errdet_ctrl           : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_3_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cfg_3 cvmx_gserx_lanex_rx_cfg_3_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_4
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_4 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t cfg_rx_errdet_ctrl           : 16; /**< RX adaptive equalizer control.
+                                                         Value of pcs_sds_rx_err_det_ctrl when
+                                                         GSERX_LANE()_MISC_OVVRD[CFG_RS_ERRDET_CTRL_OVRRD_EN] is set.
+                                                         <15:14>: Reserved
+                                                         <13:8>: Q/QB error sampler 0 threshold, 6.7mV/step, used for training/LMS.
+                                                         <7>: Enable Window mode, after training has finished.
+                                                         <6:5>: Control sds_pcs_rx_vma_status[15:8].
+                                                         0x0 = window counter[19:12] (FOM).
+                                                         0x1 = window ouunter[11:4].
+                                                         0x2 = CTLE pole, SDLL_IQ.
+                                                         0x3 = pre-CTLE gain, CTLE peak.
+                                                         <4>: Offset cancellation enable.
+                                                         <3:0>: Max CTLE peak setting during training when pcs_sds_rx_vma_ctl[7] is set in
+                                                         GSERX_LANE()_RX_VMA_CTRL. */
+#else
+	uint64_t cfg_rx_errdet_ctrl           : 16;
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_px_mode_1_s   cn78xx;
+	struct cvmx_gserx_lanex_rx_cfg_4_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_cfg_4 cvmx_gserx_lanex_rx_cfg_4_t;
+
+/**
+ * cvmx_gser#_lane#_rx_cfg_5
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_cfg_5 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_cfg_5_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t rx_agc_men_ovvrd_en          : 1;  /**< Override enable for AGC manual mode. */
+	uint64_t rx_agc_men_ovvrd_val         : 1;  /**< Override value for AGC manual mode. */
+	uint64_t rx_widthsel_ovvrd_en         : 1;  /**< Override enable for RX width select to the SerDes pcs_sds_rx_widthsel. */
+	uint64_t rx_widthsel_ovvrd_val        : 2;  /**< Override value for RX width select to the SerDes pcs_sds_rx_widthsel.
+                                                         0x0 = 8-bit raw data.
+                                                         0x1 = 10-bit raw data.
+                                                         0x2 = 16-bit raw data.
+                                                         0x3 = 20-bit raw data. */
+#else
+	uint64_t rx_widthsel_ovvrd_val        : 2;
+	uint64_t rx_widthsel_ovvrd_en         : 1;
+	uint64_t rx_agc_men_ovvrd_val         : 1;
+	uint64_t rx_agc_men_ovvrd_en          : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_5_s    cn78xx;
 };
-typedef union cvmx_gserx_lanex_px_mode_1 cvmx_gserx_lanex_px_mode_1_t;
+typedef union cvmx_gserx_lanex_rx_cfg_5 cvmx_gserx_lanex_rx_cfg_5_t;
 
 /**
  * cvmx_gser#_lane#_rx_ctle_ctrl
@@ -3082,19 +3667,71 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
 
 /**
- * cvmx_gser#_lane#_rx_precorr_ctrl
+ * cvmx_gser#_lane#_rx_misc_ovrrd
  *
- * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
- * diagnostic use only.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
- * fields in these registers do not change during chip warm or soft resets.
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_rx_precorr_ctrl {
+union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_rx_precorr_ctrl_s {
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_5_63                : 59;
-	uint64_t rx_precorr_disable           : 1;  /**< Disable RX precorrelation calculation. */
+	uint64_t reserved_12_63               : 52;
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;  /**< Override value for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Override enable for RX CDR Control
+                                                         When asserted, the pcs_sds_rx_cdr_ctrl value
+                                                         is defined in registers
+                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_0,
+                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_1, and
+                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_2. */
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;  /**< Training mode control in override mode. */
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;  /**< Override enable for RX-EQ Eval
+                                                         When asserted, training mode is controlled by
+                                                         CFG_RX_EQ_EVAL_OVRRD_VAL. */
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;  /**< When asserted, override DLL lock enable
+                                                         signal from the RX Power State machine with
+                                                         CFG_RX_DLL_LOCKEN in register
+                                                         GSERX_LANE()_RX_CFG_1. */
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
+                                                         to cfg_rx_errdet_ctrl in registers
+                                                         GSERX_LANE()_RX_CFG_3 and GSERX_LANE()_RX_CFG_4. */
+	uint64_t reserved_0_3                 : 4;
+#else
+	uint64_t reserved_0_3                 : 4;
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
+
+/**
+ * cvmx_gser#_lane#_rx_precorr_ctrl
+ *
+ * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
+ * diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_precorr_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t rx_precorr_disable           : 1;  /**< Disable RX precorrelation calculation. */
 	uint64_t rx_precorr_en_ovrrd_en       : 1;  /**< Override enable for RX precorrelation calculation enable. */
 	uint64_t rx_precorr_en_ovrrd_val      : 1;  /**< Override value for RX precorrelation calculation enable. */
 	uint64_t pcs_sds_rx_precorr_scnt_ctrl : 2;  /**< RX precorrelation sample counter control.
@@ -3292,6 +3929,61 @@ union cvmx_gserx_lanex_rx_vma_ctrl {
 typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
 
 /**
+ * cvmx_gser#_lane#_rx_vma_status_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_vma_status_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t sds_pcs_rx_vma_status        : 8;  /**< <8>: DFE Powerdown
+                                                         <7>: Reserved
+                                                         <6:2>: CTLE Peak
+                                                         <1:0>: CTLE Pole. */
+#else
+	uint64_t sds_pcs_rx_vma_status        : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_vma_status_0 cvmx_gserx_lanex_rx_vma_status_0_t;
+
+/**
+ * cvmx_gser#_lane#_rx_vma_status_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_vma_status_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSERX_LANE(0..3)_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]
+                                                         0x0 = Pre-CTL gain, CTLE Peak.
+                                                         0x1 = CTL pole, SDLL_IQ.
+                                                         0x2 = Window counter[11:3].
+                                                         0x3 = Window counter[19:12] (VMA RAW FOM).
+                                                         <7>: Training done
+                                                         <6>: Internal state machine training done
+                                                         <5:3>: Internal state machine Delta
+                                                         <2:0>: CDR Phase Offset, DLL IQ Training value. */
+#else
+	uint64_t sds_pcs_rx_vma_status        : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_vma_status_1 cvmx_gserx_lanex_rx_vma_status_1_t;
+
+/**
  * cvmx_gser#_lane#_tx_cfg_0
  *
  * These registers are for diagnostic use only. These registers are only reset by hardware during
@@ -3399,96 +4091,408 @@ typedef union cvmx_gserx_lanex_tx_cfg_1 cvmx_gserx_lanex_tx_cfg_1_t;
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
-union cvmx_gserx_lanex_tx_cfg_2 {
+union cvmx_gserx_lanex_tx_cfg_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_tx_cfg_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_tx_dcc_en            : 1;  /**< DCC Enable. */
+	uint64_t reserved_3_14                : 12;
+	uint64_t rcvr_test_ovrd_en            : 1;  /**< Override RX detect disable and test pulse. */
+	uint64_t rcvr_test_ovrd_val           : 1;  /**< Override value for RX detect test pulse; used to create a pulse during which the receiver
+                                                         detect test operation is performed. */
+	uint64_t tx_rx_detect_dis_ovrd_val    : 1;  /**< Override value of RX detect disable. */
+#else
+	uint64_t tx_rx_detect_dis_ovrd_val    : 1;
+	uint64_t rcvr_test_ovrd_val           : 1;
+	uint64_t rcvr_test_ovrd_en            : 1;
+	uint64_t reserved_3_14                : 12;
+	uint64_t pcs_sds_tx_dcc_en            : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
+
+/**
+ * cvmx_gser#_lane#_tx_cfg_3
+ *
+ * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * chip cold reset. The values of the CSR fields in these registers do not change during chip
+ * warm or soft resets.
+ */
+union cvmx_gserx_lanex_tx_cfg_3 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_tx_cfg_3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t cfg_tx_vboost_en             : 1;  /**< Specifies the value of TX VBoost enable when
+                                                         GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_VBOOST_EN_OVRRD_EN] is asserted. */
+	uint64_t reserved_7_13                : 7;
+	uint64_t pcs_sds_tx_gain              : 3;  /**< TX Gain. For debug use only. */
+	uint64_t pcs_sds_tx_srate_sel         : 3;  /**< Reserved. */
+	uint64_t cfg_tx_turbo_en              : 1;  /**< Specifies value ot TX turbo enable when GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_TURBO_EN] is set. */
+#else
+	uint64_t cfg_tx_turbo_en              : 1;
+	uint64_t pcs_sds_tx_srate_sel         : 3;
+	uint64_t pcs_sds_tx_gain              : 3;
+	uint64_t reserved_7_13                : 7;
+	uint64_t cfg_tx_vboost_en             : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
+
+/**
+ * cvmx_gser#_lane#_tx_pre_emphasis
+ *
+ * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * chip cold reset. The values of the CSR fields in these registers do not change during chip
+ * warm or soft resets.
+ */
+union cvmx_gserx_lanex_tx_pre_emphasis {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t cfg_tx_premptap              : 9;  /**< Override preemphasis control. Applies when
+                                                         GSER(0..13)_LANE(0..3)_TX_CFG_3[TX_PREMPTAP_OVRD_EN] is asserted.
+                                                         <8:4> = Post-cursor.
+                                                         <3:0> = Pre-cursor. */
+#else
+	uint64_t cfg_tx_premptap              : 9;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_t;
+
+/**
+ * cvmx_gser#_lane_lpbken
+ *
+ * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lane_lpbken {
+	uint64_t u64;
+	struct cvmx_gserx_lane_lpbken_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all OCI links). When asserted in P0 state,
+                                                         allows per lane TX-to-RX serial loopback activation.
+                                                         <3>: Lane 3.
+                                                         <2>: Lane 2.
+                                                         <1>: Lane 1.
+                                                         <0>: Lane 0. */
+#else
+	uint64_t lpbken                       : 4;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_gserx_lane_lpbken_s       cn78xx;
+};
+typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
+
+/**
+ * cvmx_gser#_lane_mode
+ *
+ * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lane_mode {
+	uint64_t u64;
+	struct cvmx_gserx_lane_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
+                                                         table to select electrical specs and link rate. Note that the PHY table can be modified
+                                                         such that any supported link rate can be derived regardless of the configured LMODE.
+                                                         0x0: R_25G_REFCLK100
+                                                         0x1: R_5G_REFCLK100
+                                                         0x2: R_8G_REFCLK100
+                                                         0x3: R_125G_REFCLK15625_KX (not supported)
+                                                         0x4: R_3125G_REFCLK15625_XAUI
+                                                         For XAUI applications.
+                                                         0x5: R_103125G_REFCLK15625_KR
+                                                         For XFI, XLAUI, KR applications.
+                                                         0x6: R_125G_REFCLK15625_SGMII
+                                                         For SGMII applications.
+                                                         0x7: R_5G_REFCLK15625_QSGMII (not supported)
+                                                         0x8: R_625G_REFCLK15625_RXAUI
+                                                         For RXAUI, DXAUI applications.
+                                                         0x9: R_25G_REFCLK125
+                                                         0xA: R_5G_REFCLK125
+                                                         0xB: R_8G_REFCLK125
+                                                         0xC - 0xF: reserved
+                                                         This register is not used for PCIE configurations. For non-OCI links, this register
+                                                         defaults to R_625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
+                                                         GSER_SPD and the appropriate table updates are performed so the rate is obtained for the
+                                                         particular reference clock.
+                                                         It is recommended that the PHY be in reset when reconfiguring the LMODE
+                                                         (GSER(0..13)_PHY_CTL[PHY_RESET] is set).
+                                                         Once the LMODE has been configured, and the PHY is out of reset, the table entries for the
+                                                         selected LMODE must be updated to reflect the reference clock speed. Refer to the register
+                                                         description and index into the table using the rate and reference speed to obtain the
+                                                         recommended values.
+                                                         Write GSER(0..13)_PLL_P(Z)_MODE_0.
+                                                         Write GSER(0..13)_PLL_P(Z)_MODE_1.
+                                                         Write GSER(0..13)_LANE_P(Z)_MODE_0.
+                                                         Write GSER(0..13)_LANE_P(Z)_MODE_1.
+                                                         where Z equals LMODE. */
+#else
+	uint64_t lmode                        : 4;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_gserx_lane_mode_s         cn78xx;
+};
+typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
+
+/**
+ * cvmx_gser#_lane_p#_mode_0
+ *
+ * These are the RAW PCS lane settings mode 0 registers. There is one register per
+ * 4 lanes per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a
+ * given GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lane_px_mode_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lane_px_mode_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t ctle                         : 2;  /**< Continuous time linear equalizer pole configuration.
+                                                         0x0 = ~5dB of peaking at 4 GHz (Minimum bandwidth).
+                                                         0x1 =~10dB of peaking at 5 GHz
+                                                         0x2 = ~15dB of peaking at 5.5 GHz
+                                                         0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
+                                                         Recommended settings:
+                                                         R_25G_REFCLK100:          0x0
+                                                         R_5G_REFCLK100:           0x0
+                                                         R_8G_REFCLK100:           0x3
+                                                         R_125G_REFCLK15625_KX:    0x0
+                                                         R_3125G_REFCLK15625_XAUI: 0x0
+                                                         R_103125G_REFCLK15625_KR: 0x3
+                                                         R_125G_REFCLK15625_SGMII: 0x0
+                                                         R_5G_REFCLK15625_QSGMII:  0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125:          0x0
+                                                         R_5G_REFCLK125:           0x0
+                                                         R_8G_REFCLK125:           0x3 */
+	uint64_t pcie                         : 1;  /**< Selects between RX terminations.
+                                                         - 0: Differential termination
+                                                         - 1: Termination between pad and SDS_VDDS.
+                                                          Recommended settings:
+                                                          R_25G_REFCLK100:          0x1
+                                                          R_5G_REFCLK100:           0x1
+                                                          R_8G_REFCLK100:           0x0
+                                                          R_125G_REFCLK15625_KX:    0x0
+                                                          R_3125G_REFCLK15625_XAUI: 0x0
+                                                          R_103125G_REFCLK15625_KR: 0x0
+                                                          R_125G_REFCLK15625_SGMII: 0x0
+                                                          R_5G_REFCLK15625_QSGMII:  0x0
+                                                          R_625G_REFCLK15625_RXAUI: 0x0
+                                                          R_25G_REFCLK125:          0x1
+                                                          R_5G_REFCLK125:           0x1
+                                                          R_8G_REFCLK125:           0x0 */
+	uint64_t tx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
+                                                         0x0 = full data rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate.
+                                                         Recommended settings:
+                                                         R_25G_REFCLK100:          0x1
+                                                         R_5G_REFCLK100:           0x0
+                                                         R_8G_REFCLK100:           0x0
+                                                         R_125G_REFCLK15625_KX:    0x2
+                                                         R_3125G_REFCLK15625_XAUI: 0x1
+                                                         R_103125G_REFCLK15625_KR: 0x0
+                                                         R_125G_REFCLK15625_SGMII: 0x2
+                                                         R_5G_REFCLK15625_QSGMII:  0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125:          0x1
+                                                         R_5G_REFCLK125:           0x0
+                                                         R_8G_REFCLK125:           0x0 */
+	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
+                                                         0x0 = full data rate
+                                                         0x1 = 1/2 data rate
+                                                         0x2 = 1/4 data rate
+                                                         0x3 = 1/8 data rate
+                                                         Recommended settings:
+                                                         R_25G_REFCLK100:          0x1
+                                                         R_5G_REFCLK100:           0x0
+                                                         R_8G_REFCLK100:           0x0
+                                                         R_125G_REFCLK15625_KX:    0x2
+                                                         R_3125G_REFCLK15625_XAUI: 0x1
+                                                         R_103125G_REFCLK15625_KR: 0x0
+                                                         R_125G_REFCLK15625_SGMII: 0x2
+                                                         R_5G_REFCLK15625_QSGMII:  0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125:          0x1
+                                                         R_5G_REFCLK125:           0x0
+                                                         R_8G_REFCLK125:           0x0 */
+	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
+                                                         rate.
+                                                         0x0 = Full rate
+                                                         0x1 = 1/2 data rate
+                                                         0x2 = 1/4 data rate
+                                                         0x3 = 1/8 data rate
+                                                         0x4 = 1/16 data rate
+                                                         else = Reserved.
+                                                         This field should always be cleared to zero (full rate). */
+	uint64_t reserved_4_4                 : 1;
+	uint64_t tx_mode                      : 2;  /**< TX data width:
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+	uint64_t rx_mode                      : 2;  /**< RX data width:
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+#else
+	uint64_t rx_mode                      : 2;
+	uint64_t tx_mode                      : 2;
+	uint64_t reserved_4_4                 : 1;
+	uint64_t srate                        : 3;
+	uint64_t rx_ldiv                      : 2;
+	uint64_t tx_ldiv                      : 2;
+	uint64_t pcie                         : 1;
+	uint64_t ctle                         : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lane_px_mode_0_s    cn78xx;
+};
+typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
+
+/**
+ * cvmx_gser#_lane_p#_mode_1
+ *
+ * These are the RAW PCS lane settings mode 1 registers. There is one register per 4 lanes,
+ * (0..3) per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a given
+ * GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lane_px_mode_1 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_tx_cfg_2_s {
+	struct cvmx_gserx_lane_px_mode_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t pcs_sds_tx_dcc_en            : 1;  /**< DCC Enable. */
-	uint64_t reserved_3_14                : 12;
-	uint64_t rcvr_test_ovrd_en            : 1;  /**< Override RX detect disable and test pulse. */
-	uint64_t rcvr_test_ovrd_val           : 1;  /**< Override value for RX detect test pulse; used to create a pulse during which the receiver
-                                                         detect test operation is performed. */
-	uint64_t tx_rx_detect_dis_ovrd_val    : 1;  /**< Override value of RX detect disable. */
+	uint64_t vma_fine_cfg_sel             : 1;  /**< Recommended settings:
+                                                         1 = Enabled. Fine step adaptation selected (10.3125 Gbaud rate).
+                                                         0 = Disabled. Coarse step adaptation selected (rates lower than 10.3125 Gbaud). */
+	uint64_t vma_mm                       : 1;  /**< Manual DFE verses adaptive DFE mode. Recommended settings:
+                                                         0 = Adaptive DFE (5 Gbaud and higher)
+                                                         1 = Manual DFE, fixed tap (3.125 Gbaud and lower). */
+	uint64_t cdr_fgain                    : 4;  /**< CDR frequency gain.
+                                                         Recommended settings:
+                                                         R_25G_REFCLK100:          0xA
+                                                         R_5G_REFCLK100:           0xA
+                                                         R_8G_REFCLK100:           0xB
+                                                         R_125G_REFCLK15625_KX:    0xC
+                                                         R_3125G_REFCLK15625_XAUI: 0xC
+                                                         R_103125G_REFCLK15625_KR: 0xA
+                                                         R_125G_REFCLK15625_SGMII: 0xC
+                                                         R_5G_REFCLK15625_QSGMII:  0xC
+                                                         R_625G_REFCLK15625_RXAUI: 0xA
+                                                         R_25G_REFCLK125:          0xA
+                                                         R_5G_REFCLK125:           0xA
+                                                         R_8G_REFCLK125:           0xB */
+	uint64_t ph_acc_adj                   : 10; /**< Phase accumulator adjust.
+                                                         Recommended settings:
+                                                         R_25G_REFCLK100:          0x14
+                                                         R_5G_REFCLK100:           0x14
+                                                         R_8G_REFCLK100:           0x23
+                                                         R_125G_REFCLK15625_KX:    0x1E
+                                                         R_3125G_REFCLK15625_XAUI: 0x1E
+                                                         R_103125G_REFCLK15625_KR: 0xF
+                                                         R_125G_REFCLK15625_SGMII: 0x1E
+                                                         R_5G_REFCLK15625_QSGMII:  0x1E
+                                                         R_625G_REFCLK15625_RXAUI: 0x14
+                                                         R_25G_REFCLK125:          0x14
+                                                         R_5G_REFCLK125:           0x14
+                                                         R_8G_REFCLK125:           0x23 */
 #else
-	uint64_t tx_rx_detect_dis_ovrd_val    : 1;
-	uint64_t rcvr_test_ovrd_val           : 1;
-	uint64_t rcvr_test_ovrd_en            : 1;
-	uint64_t reserved_3_14                : 12;
-	uint64_t pcs_sds_tx_dcc_en            : 1;
+	uint64_t ph_acc_adj                   : 10;
+	uint64_t cdr_fgain                    : 4;
+	uint64_t vma_mm                       : 1;
+	uint64_t vma_fine_cfg_sel             : 1;
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
+	struct cvmx_gserx_lane_px_mode_1_s    cn78xx;
 };
-typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
+typedef union cvmx_gserx_lane_px_mode_1 cvmx_gserx_lane_px_mode_1_t;
 
 /**
- * cvmx_gser#_lane#_tx_cfg_3
+ * cvmx_gser#_lane_poff
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
- * chip cold reset. The values of the CSR fields in these registers do not change during chip
- * warm or soft resets.
+ * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_tx_cfg_3 {
+union cvmx_gserx_lane_poff {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_tx_cfg_3_s {
+	struct cvmx_gserx_lane_poff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
-	uint64_t cfg_tx_vboost_en             : 1;  /**< Specifies the value of TX VBoost enable when
-                                                         GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_VBOOST_EN_OVRRD_EN] is asserted. */
-	uint64_t reserved_7_13                : 7;
-	uint64_t pcs_sds_tx_gain              : 3;  /**< TX Gain. For debug use only. */
-	uint64_t pcs_sds_tx_srate_sel         : 3;  /**< Reserved. */
-	uint64_t cfg_tx_turbo_en              : 1;  /**< Specifies value ot TX turbo enable when GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_TURBO_EN] is set. */
+	uint64_t reserved_4_63                : 60;
+	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), allows for per lane power
+                                                         down.
+                                                         <3>: Lane 3.
+                                                         <2>: Lane 2.
+                                                         <1>: Lane 1.
+                                                         <0>: Lane 0. */
 #else
-	uint64_t cfg_tx_turbo_en              : 1;
-	uint64_t pcs_sds_tx_srate_sel         : 3;
-	uint64_t pcs_sds_tx_gain              : 3;
-	uint64_t reserved_7_13                : 7;
-	uint64_t cfg_tx_vboost_en             : 1;
-	uint64_t reserved_15_63               : 49;
+	uint64_t lpoff                        : 4;
+	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
+	struct cvmx_gserx_lane_poff_s         cn78xx;
 };
-typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
+typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
 
 /**
- * cvmx_gser#_lane#_tx_pre_emphasis
+ * cvmx_gser#_lane_srst
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
- * chip cold reset. The values of the CSR fields in these registers do not change during chip
- * warm or soft resets.
+ * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_tx_pre_emphasis {
+union cvmx_gserx_lane_srst {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_tx_pre_emphasis_s {
+	struct cvmx_gserx_lane_srst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
-	uint64_t cfg_tx_premptap              : 9;  /**< Override preemphasis control. Applies when
-                                                         GSER(0..13)_LANE(0..3)_TX_CFG_3[TX_PREMPTAP_OVRD_EN] is asserted.
-                                                         <8:4> = Post-cursor.
-                                                         <3:0> = Pre-cursor. */
+	uint64_t reserved_1_63                : 63;
+	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE mode (including all OCI links), resets all 4 lanes
+                                                         (equivalent to the P2 power state) after any pending requests (power state change, rate
+                                                         change) are complete. The lanes remain in reset state while this signal is asserted. When
+                                                         the signal deasserts, the lanes exit the reset state and the PHY returns to the power
+                                                         state the PHY was in prior. For diagnostic use only. */
 #else
-	uint64_t cfg_tx_premptap              : 9;
-	uint64_t reserved_9_63                : 55;
+	uint64_t lsrst                        : 1;
+	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xx;
+	struct cvmx_gserx_lane_srst_s         cn78xx;
 };
-typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_t;
+typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
 
 /**
- * cvmx_gser#_lane#_vma_coarse_ctrl_0
+ * cvmx_gser#_lane_vma_coarse_ctrl_0
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_coarse_ctrl_0 {
+union cvmx_gserx_lane_vma_coarse_ctrl_0 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_0_s {
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t iq_max                       : 4;  /**< Slice DLL IQ maximum value in VMA coarse mode. */
@@ -3506,20 +4510,20 @@ union cvmx_gserx_lanex_vma_coarse_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_vma_coarse_ctrl_0 cvmx_gserx_lanex_vma_coarse_ctrl_0_t;
+typedef union cvmx_gserx_lane_vma_coarse_ctrl_0 cvmx_gserx_lane_vma_coarse_ctrl_0_t;
 
 /**
- * cvmx_gser#_lane#_vma_coarse_ctrl_1
+ * cvmx_gser#_lane_vma_coarse_ctrl_1
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_coarse_ctrl_1 {
+union cvmx_gserx_lane_vma_coarse_ctrl_1 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_1_s {
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t ctle_pmax                    : 4;  /**< RX CTLE peak maximum value in VMA coarse mode. */
@@ -3532,20 +4536,20 @@ union cvmx_gserx_lanex_vma_coarse_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_vma_coarse_ctrl_1 cvmx_gserx_lanex_vma_coarse_ctrl_1_t;
+typedef union cvmx_gserx_lane_vma_coarse_ctrl_1 cvmx_gserx_lane_vma_coarse_ctrl_1_t;
 
 /**
- * cvmx_gser#_lane#_vma_coarse_ctrl_2
+ * cvmx_gser#_lane_vma_coarse_ctrl_2
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_coarse_ctrl_2 {
+union cvmx_gserx_lane_vma_coarse_ctrl_2 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_2_s {
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t pctle_gmax                   : 4;  /**< RX PRE-CTLE gain maximum value in VMA coarse mode. */
@@ -3558,20 +4562,20 @@ union cvmx_gserx_lanex_vma_coarse_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_coarse_ctrl_2_s cn78xx;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_vma_coarse_ctrl_2 cvmx_gserx_lanex_vma_coarse_ctrl_2_t;
+typedef union cvmx_gserx_lane_vma_coarse_ctrl_2 cvmx_gserx_lane_vma_coarse_ctrl_2_t;
 
 /**
- * cvmx_gser#_lane#_vma_fine_ctrl_0
+ * cvmx_gser#_lane_vma_fine_ctrl_0
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_fine_ctrl_0 {
+union cvmx_gserx_lane_vma_fine_ctrl_0 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_0_s {
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rx_sdll_iq_max_fine          : 4;  /**< RX Slice DLL IQ maximum value in VMA Fine mode (valid when
@@ -3599,20 +4603,20 @@ union cvmx_gserx_lanex_vma_fine_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_0_s cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_vma_fine_ctrl_0 cvmx_gserx_lanex_vma_fine_ctrl_0_t;
+typedef union cvmx_gserx_lane_vma_fine_ctrl_0 cvmx_gserx_lane_vma_fine_ctrl_0_t;
 
 /**
- * cvmx_gser#_lane#_vma_fine_ctrl_1
+ * cvmx_gser#_lane_vma_fine_ctrl_1
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_fine_ctrl_1 {
+union cvmx_gserx_lane_vma_fine_ctrl_1 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_1_s {
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t rx_ctle_peak_max_fine        : 4;  /**< RX CTLE peak maximum value in VMA fine mode (valid when
@@ -3630,20 +4634,20 @@ union cvmx_gserx_lanex_vma_fine_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_1_s cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn78xx;
 };
-typedef union cvmx_gserx_lanex_vma_fine_ctrl_1 cvmx_gserx_lanex_vma_fine_ctrl_1_t;
+typedef union cvmx_gserx_lane_vma_fine_ctrl_1 cvmx_gserx_lane_vma_fine_ctrl_1_t;
 
 /**
- * cvmx_gser#_lane#_vma_fine_ctrl_2
+ * cvmx_gser#_lane_vma_fine_ctrl_2
  *
  * These registers are for diagnostic use only.
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
-union cvmx_gserx_lanex_vma_fine_ctrl_2 {
+union cvmx_gserx_lane_vma_fine_ctrl_2 {
 	uint64_t u64;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_2_s {
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t rx_prectle_peak_max_fine     : 4;  /**< RX PRE-CTLE peak maximum value in VMA fine mode (valid when
@@ -3662,141 +4666,9 @@ union cvmx_gserx_lanex_vma_fine_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_vma_fine_ctrl_2_s cn78xx;
-};
-typedef union cvmx_gserx_lanex_vma_fine_ctrl_2 cvmx_gserx_lanex_vma_fine_ctrl_2_t;
-
-/**
- * cvmx_gser#_lane_lpbken
- *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
- * fields in these registers do not change during chip warm or soft resets.
- */
-union cvmx_gserx_lane_lpbken {
-	uint64_t u64;
-	struct cvmx_gserx_lane_lpbken_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
-	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all OCI links). When asserted in P0 state,
-                                                         allows per lane TX-to-RX serial loopback activation.
-                                                         <3>: Lane 3.
-                                                         <2>: Lane 2.
-                                                         <1>: Lane 1.
-                                                         <0>: Lane 0. */
-#else
-	uint64_t lpbken                       : 4;
-	uint64_t reserved_4_63                : 60;
-#endif
-	} s;
-	struct cvmx_gserx_lane_lpbken_s       cn78xx;
-};
-typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
-
-/**
- * cvmx_gser#_lane_mode
- *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
- * fields in these registers do not change during chip warm or soft resets.
- */
-union cvmx_gserx_lane_mode {
-	uint64_t u64;
-	struct cvmx_gserx_lane_mode_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
-	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
-                                                         table to select electrical specs and link rate. Note that the PHY table can be modified
-                                                         such that any supported link rate can be derived regardless of the configured LMODE.
-                                                         0x0: R_25G_REFCLK100
-                                                         0x1: R_5G_REFCLK100
-                                                         0x2: R_8G_REFCLK100
-                                                         0x3: R_125G_REFCLK15625_KX (not supported)
-                                                         0x4: R_3125G_REFCLK15625_XAUI
-                                                         For XAUI applications.
-                                                         0x5: R_103125G_REFCLK15625_KR
-                                                         For XFI, XLAUI, KR applications.
-                                                         0x6: R_125G_REFCLK15625_SGMII
-                                                         For SGMII applications.
-                                                         0x7: R_5G_REFCLK15625_QSGMII (not supported)
-                                                         0x8: R_625G_REFCLK15625_RXAUI
-                                                         For RXAUI, DXAUI applications.
-                                                         0x9: R_25G_REFCLK125
-                                                         0xA: R_5G_REFCLK125
-                                                         0xB: R_8G_REFCLK125
-                                                         0xC - 0xF: reserved
-                                                         This register is not used for PCIE configurations. For non-OCI links, this register
-                                                         defaults to R_625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
-                                                         GSER_SPD and the appropriate table updates are performed so the rate is obtained for the
-                                                         particular reference clock.
-                                                         It is recommended that the PHY be in reset when reconfiguring the LMODE
-                                                         (GSER(0..13)_PHY_CTL[PHY_RESET] is set).
-                                                         Once the LMODE has been configured, and the PHY is out of reset, the table entries for the
-                                                         selected LMODE must be updated to reflect the reference clock speed. Refer to the register
-                                                         description and index into the table using the rate and reference speed to obtain the
-                                                         recommended values.
-                                                         Write GSER(0..13)_PLL_P(Z)_MODE_0.
-                                                         Write GSER(0..13)_PLL_P(Z)_MODE_1.
-                                                         Write GSER(0..13)_LANE(0..3)_P(Z)_MODE_0.
-                                                         Write GSER(0..13)_LANE(0..3)_P(Z)_MODE_1.
-                                                         where Z equals LMODE. */
-#else
-	uint64_t lmode                        : 4;
-	uint64_t reserved_4_63                : 60;
-#endif
-	} s;
-	struct cvmx_gserx_lane_mode_s         cn78xx;
-};
-typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
-
-/**
- * cvmx_gser#_lane_poff
- *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
- * fields in these registers do not change during chip warm or soft resets.
- */
-union cvmx_gserx_lane_poff {
-	uint64_t u64;
-	struct cvmx_gserx_lane_poff_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
-	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), allows for per lane power
-                                                         down.
-                                                         <3>: Lane 3.
-                                                         <2>: Lane 2.
-                                                         <1>: Lane 1.
-                                                         <0>: Lane 0. */
-#else
-	uint64_t lpoff                        : 4;
-	uint64_t reserved_4_63                : 60;
-#endif
-	} s;
-	struct cvmx_gserx_lane_poff_s         cn78xx;
-};
-typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
-
-/**
- * cvmx_gser#_lane_srst
- *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
- * fields in these registers do not change during chip warm or soft resets.
- */
-union cvmx_gserx_lane_srst {
-	uint64_t u64;
-	struct cvmx_gserx_lane_srst_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_1_63                : 63;
-	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE mode (including all OCI links), resets all 4 lanes
-                                                         (equivalent to the P2 power state) after any pending requests (power state change, rate
-                                                         change) are complete. The lanes remain in reset state while this signal is asserted. When
-                                                         the signal deasserts, the lanes exit the reset state and the PHY returns to the power
-                                                         state the PHY was in prior. For diagnostic use only. */
-#else
-	uint64_t lsrst                        : 1;
-	uint64_t reserved_1_63                : 63;
-#endif
-	} s;
-	struct cvmx_gserx_lane_srst_s         cn78xx;
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn78xx;
 };
-typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
+typedef union cvmx_gserx_lane_vma_fine_ctrl_2 cvmx_gserx_lane_vma_fine_ctrl_2_t;
 
 /**
  * cvmx_gser#_pcie_pcs_clk_req
@@ -5002,11 +5874,11 @@ union cvmx_gserx_pll_px_mode_0 {
                                                          Recommended settings:
                                                          1.25G:    0x28
                                                          2.5G:     0x5
-                                                         3.125G:   0x24
+                                                         3.125G:   0x14
                                                          5.0G:     0xA
                                                          6.25G:    0xA
                                                          8.0G:     0xA
-                                                         10.3125G: 0x24 */
+                                                         10.3125G: 0xA */
 #else
 	uint64_t pll_pcs_div                  : 9;
 	uint64_t pll_rloop                    : 3;
@@ -5765,14 +6637,14 @@ union cvmx_gserx_spd {
                                                          (Software must do all the OCI GSER configuration to use OCI in the case of SW_MODE.)
                                                          When SPD!=SW_MODE after a chip cold reset, the hardware has initialized the following
                                                          registers (based on the OCI_SPD selection):
-                                                          * GSER(8..13)_LANE_MODE[LMODE]=Z
-                                                          * GSER(8..13)_PLL_P(Z)_MODE_0
-                                                          * GSER(8..13)_PLL_P(Z)_MODE_1
-                                                          * GSER(8..13)_LANE(0..3)_P(Z)_MODE_0
-                                                          * GSER(8..13)_LANE(0..3)_P(Z)_MODE_1
-                                                          * GSER(8..13)_LANE(0..3)_RX_VALBBD_CTRL_0
-                                                          * GSER(8..13)_LANE(0..3)_RX_VALBBD_CTRL_1
-                                                          * GSER(8..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                          * GSER(8..13)_LANE_MODE[LMODE]=Z.
+                                                          * GSER(8..13)_PLL_P(Z)_MODE_0.
+                                                          * GSER(8..13)_PLL_P(Z)_MODE_1.
+                                                          * GSER(8..13)_LANE_P(Z)_MODE_0.
+                                                          * GSER(8..13)_LANE_P(Z)_MODE_1.
+                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_0.
+                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_1.
+                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_2.
                                                          where Z is the LMODE indicated by the prior table. */
 #else
 	uint64_t spd                          : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index fedc548..02b105a 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 97664 $<hr>
+ * <hr>$Revision: 97779 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
@@ -115,6 +115,7 @@ typedef enum {
 	GPIO_PCA8574	/** TWSI mux device */
 } cvmx_phy_gpio_type_t;
 
+struct cvmx_phy_device;
 /**
  * @INTERNAL
  * This data structure is used to hold PHY information and is subject to change.
@@ -145,6 +146,7 @@ typedef struct cvmx_phy_info {
 	cvmx_phy_mux_type_t mux_type;	/** Type of MDIO mux */
 	int mux_twsi_addr;		/** Address of the MDIO mux */
 	cvmx_phy_host_mode_t host_mode;	/** Used by Cortina PHY */
+	struct cvmx_phy_device *phydev;	/** Pointer to parent phy device */
 } cvmx_phy_info_t;
 #endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index db39020..0e37331 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -964,7 +964,8 @@ union cvmx_ocx_com_linkx_ctl {
 	uint64_t u64;
 	struct cvmx_ocx_com_linkx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_10_63               : 54;
+	uint64_t cclk_dis                     : 1;  /**< Reserved. */
 	uint64_t loopback                     : 1;  /**< Reserved. INTERNAL: Diagnostic data loopback.Set to force outgoing link to inbound port.
                                                          All data and link credits are returned and appear to come from link partner. Typically
                                                          SerDes should be disabled during this operation. */
@@ -972,7 +973,7 @@ union cvmx_ocx_com_linkx_ctl {
                                                          bit.
                                                          Setting the bit also causes the link to transmit a REINIT request to the link partner.
                                                          This bit must be cleared for link to operate normally. */
-	uint64_t gate                         : 1;  /**< Enable clock gating on this link to save power. */
+	uint64_t gate                         : 1;  /**< Reserved. */
 	uint64_t auto_clr                     : 1;  /**< Automatically clear DROP bit if link partner has cleared other side. Typically disabled if
                                                          software wishes to manage deassertion of DROP. */
 	uint64_t drop                         : 1;  /**< Drop all requests on given link. Typically set by hardware when link has failed or been
@@ -995,7 +996,8 @@ union cvmx_ocx_com_linkx_ctl {
 	uint64_t gate                         : 1;
 	uint64_t reinit                       : 1;
 	uint64_t loopback                     : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t cclk_dis                     : 1;
+	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
 	struct cvmx_ocx_com_linkx_ctl_s       cn78xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 3c5734f..8f440eb 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -694,7 +694,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long block_id)
 /**
  * cvmx_pcieepvf#_cfg000
  *
- * This register contains the first 32-bits of type 0 PCIe configuration space.
+ * This register contains the first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg000 {
@@ -715,7 +715,7 @@ typedef union cvmx_pcieepvfx_cfg000 cvmx_pcieepvfx_cfg000_t;
 /**
  * cvmx_pcieepvf#_cfg001
  *
- * This register contains the second 32-bits of type 0 PCIe configuration space.
+ * This register contains the second 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg001 {
@@ -740,9 +740,9 @@ union cvmx_pcieepvfx_cfg001 {
 	uint32_t see                          : 1;  /**< SERR# enable. */
 	uint32_t ids_wcc                      : 1;  /**< IDSEL stepping/wait cycle control. Not applicable for PCI Express. Must be hardwired to 0. */
 	uint32_t per                          : 1;  /**< Parity error response. */
-	uint32_t vps                          : 1;  /**< VGA palette snoop. */
-	uint32_t mwice                        : 1;  /**< Memory write & invalidate command enable. Not applicable for PCI Express. Must be hardwired to 0. */
-	uint32_t scse                         : 1;  /**< Special cycle snooping enable. Not applicable for PCI Express. Must be hardwired to 0. */
+	uint32_t vps                          : 1;  /**< VGA palette snoop. Not applicable for PCI Express. Must be hardwired to 0. */
+	uint32_t mwice                        : 1;  /**< Memory write and invalidate. Not applicable for PCI Express. Must be hardwired to 0. */
+	uint32_t scse                         : 1;  /**< Special cycle enable. Not applicable for PCI Express. Must be hardwired to 0. */
 	uint32_t me                           : 1;  /**< Bus master enable. */
 	uint32_t msae                         : 1;  /**< Memory space access enable. */
 	uint32_t isae                         : 1;  /**< I/O space access enable. */
@@ -780,7 +780,7 @@ typedef union cvmx_pcieepvfx_cfg001 cvmx_pcieepvfx_cfg001_t;
 /**
  * cvmx_pcieepvf#_cfg002
  *
- * This register contains the third 32-bits of type 0 PCIe configuration space.
+ * This register contains the third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg002 {
@@ -805,7 +805,7 @@ typedef union cvmx_pcieepvfx_cfg002 cvmx_pcieepvfx_cfg002_t;
 /**
  * cvmx_pcieepvf#_cfg003
  *
- * This register contains the fourth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fourth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg003 {
@@ -835,7 +835,7 @@ typedef union cvmx_pcieepvfx_cfg003 cvmx_pcieepvfx_cfg003_t;
 /**
  * cvmx_pcieepvf#_cfg004
  *
- * This register contains the fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg004 {
@@ -854,7 +854,7 @@ typedef union cvmx_pcieepvfx_cfg004 cvmx_pcieepvfx_cfg004_t;
 /**
  * cvmx_pcieepvf#_cfg005
  *
- * This register contains the sixth 32-bits of type 0 PCIe configuration space.
+ * This register contains the sixth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg005 {
@@ -873,7 +873,7 @@ typedef union cvmx_pcieepvfx_cfg005 cvmx_pcieepvfx_cfg005_t;
 /**
  * cvmx_pcieepvf#_cfg006
  *
- * This register contains the seventh 32-bits of type 0 PCIe configuration space.
+ * This register contains the seventh 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg006 {
@@ -892,7 +892,7 @@ typedef union cvmx_pcieepvfx_cfg006 cvmx_pcieepvfx_cfg006_t;
 /**
  * cvmx_pcieepvf#_cfg007
  *
- * This register contains the eighth 32-bits of type 0 PCIe configuration space.
+ * This register contains the eighth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg007 {
@@ -911,7 +911,7 @@ typedef union cvmx_pcieepvfx_cfg007 cvmx_pcieepvfx_cfg007_t;
 /**
  * cvmx_pcieepvf#_cfg008
  *
- * This register contains the ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg008 {
@@ -930,7 +930,7 @@ typedef union cvmx_pcieepvfx_cfg008 cvmx_pcieepvfx_cfg008_t;
 /**
  * cvmx_pcieepvf#_cfg009
  *
- * This register contains the tenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the tenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg009 {
@@ -949,7 +949,7 @@ typedef union cvmx_pcieepvfx_cfg009 cvmx_pcieepvfx_cfg009_t;
 /**
  * cvmx_pcieepvf#_cfg010
  *
- * This register contains the eleventh 32-bits of type 0 PCIe configuration space.
+ * This register contains the eleventh 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg010 {
@@ -968,7 +968,7 @@ typedef union cvmx_pcieepvfx_cfg010 cvmx_pcieepvfx_cfg010_t;
 /**
  * cvmx_pcieepvf#_cfg011
  *
- * This register contains the twelfth 32-bits of type 0 PCIe configuration space.
+ * This register contains the twelfth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg011 {
@@ -989,7 +989,7 @@ typedef union cvmx_pcieepvfx_cfg011 cvmx_pcieepvfx_cfg011_t;
 /**
  * cvmx_pcieepvf#_cfg012
  *
- * This register contains the thirteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg012 {
@@ -1012,7 +1012,7 @@ typedef union cvmx_pcieepvfx_cfg012 cvmx_pcieepvfx_cfg012_t;
 /**
  * cvmx_pcieepvf#_cfg013
  *
- * This register contains the fourteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fourteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg013 {
@@ -1033,7 +1033,7 @@ typedef union cvmx_pcieepvfx_cfg013 cvmx_pcieepvfx_cfg013_t;
 /**
  * cvmx_pcieepvf#_cfg015
  *
- * This register contains the sixteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the sixteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg015 {
@@ -1058,7 +1058,7 @@ typedef union cvmx_pcieepvfx_cfg015 cvmx_pcieepvfx_cfg015_t;
 /**
  * cvmx_pcieepvf#_cfg028
  *
- * This register contains the twenty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the twenty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg028 {
@@ -1089,7 +1089,7 @@ typedef union cvmx_pcieepvfx_cfg028 cvmx_pcieepvfx_cfg028_t;
 /**
  * cvmx_pcieepvf#_cfg029
  *
- * This register contains the thirtieth 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirtieth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg029 {
@@ -1130,7 +1130,7 @@ typedef union cvmx_pcieepvfx_cfg029 cvmx_pcieepvfx_cfg029_t;
 /**
  * cvmx_pcieepvf#_cfg030
  *
- * This register contains the thirty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg030 {
@@ -1149,7 +1149,7 @@ union cvmx_pcieepvfx_cfg030 {
 	uint32_t nfe_d                        : 1;  /**< Nonfatal error detected. Errors are logged in this register regardless of whether or not
                                                          error reporting is enabled in the device control register. This field is set if we receive
                                                          any of the errors in
-                                                         PCIEEP(0..3)_CFG066 that has a severity set to nonfatal and does not meet advisory
+                                                         PCIEEP()_CFG066 that has a severity set to nonfatal and does not meet advisory
                                                          nonfatal criteria, which most poisoned TLPs should. */
 	uint32_t ce_d                         : 1;  /**< Correctable error detected. All correctable errors are non-function specific and get
                                                          reported only in the PF. */
@@ -1165,9 +1165,9 @@ union cvmx_pcieepvfx_cfg030 {
 	uint32_t ap_en                        : 1;  /**< AUX power PM enable. */
 	uint32_t pf_en                        : 1;  /**< Phantom function enable. */
 	uint32_t etf_en                       : 1;  /**< Extended tag field enable. */
-	uint32_t mps                          : 3;  /**< Max payload size. Legal values: 0x0 = 128B, 0x1 = 256B.
+	uint32_t mps                          : 3;  /**< Max payload size. Legal values: 0x0 = 128 B, 0x1 = 256 B.
                                                          Larger sizes are not supported by CN78XX.
-                                                         DPI_SLI_PRT(0..3)_CFG[MPS] must be set to the same value as this field for proper
+                                                         DPI_SLI_PRT()_CFG[MPS] must be set to the same value as this field for proper
                                                          functionality. */
 	uint32_t ro_en                        : 1;  /**< Enable relaxed ordering. */
 	uint32_t ur_en                        : 1;  /**< Unsupported request reporting enable. */
@@ -1203,7 +1203,7 @@ typedef union cvmx_pcieepvfx_cfg030 cvmx_pcieepvfx_cfg030_t;
 /**
  * cvmx_pcieepvf#_cfg031
  *
- * This register contains the thirty-second 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-second 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg031 {
@@ -1226,21 +1226,15 @@ union cvmx_pcieepvfx_cfg031 {
                                                          during hardware configuration. */
 	uint32_t mlw                          : 6;  /**< Maximum link width.
                                                          The reset value of this field is determined by the value read from the PEM
-                                                         csr PEM(0..3)_CFG[LANES8].
-                                                         PEM(0..2)_CFG.LANES8       RST_VALUE     NOTE
-                                                           0                          0x4           4 lanes
-                                                           1                          0x8           8 lanes
-                                                         This field is writable through PEM(0..3)_CFG_WR. */
-	uint32_t mls                          : 4;  /**< Maximum link speed.The reset value of this field is controlled by the value read from
-                                                         PEM(0..3)_CFG[MD].
-                                                         PEM*_CFG
-                                                         [MD] RST_VALUE NOTE
-                                                         0x0 0001b 2.5 GHz supported
-                                                         0x1 0010b 5.0 GHz and 2.5 GHz supported
-                                                         0x2 0011b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         0x3 0011b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         (RC Mode)
-                                                         This field is writable through PEM(0..3)_CFG_WR. However, the application must not change
+                                                         csr PEM()_CFG[LANES8]. If LANES8 is set the reset value is 0x4, otherwise 0x8.
+                                                         This field is writable through PEM()_CFG_WR. */
+	uint32_t mls                          : 4;  /**< Maximum link speed. The reset value of this field is controlled by the value read from
+                                                         PEM()_CFG[MD].
+                                                         _ MD is 0x0, reset to 0x1: 2.5 GHz supported.
+                                                         _ MD is 0x1, reset to 0x2: 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x2, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x3, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode).
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
                                                          this field. */
 #else
 	uint32_t mls                          : 4;
@@ -1264,7 +1258,7 @@ typedef union cvmx_pcieepvfx_cfg031 cvmx_pcieepvfx_cfg031_t;
 /**
  * cvmx_pcieepvf#_cfg032
  *
- * This register contains the thirty-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg032 {
@@ -1280,9 +1274,9 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t reserved_26_26               : 1;
 	uint32_t nlw                          : 6;  /**< Negotiated link width. Set automatically by hardware after Link initialization. */
 	uint32_t ls                           : 4;  /**< Link speed.
-                                                         0x1 = The negotiated link speed: 2.5 Gbps
-                                                         0x2 = The negotiated link speed: 5.0 Gbps
-                                                         0x4 = The negotiated link speed: 8.0 Gbps */
+                                                         0x1 = The negotiated link speed: 2.5 Gbps.
+                                                         0x2 = The negotiated link speed: 5.0 Gbps.
+                                                         0x4 = The negotiated link speed: 8.0 Gbps. */
 	uint32_t reserved_12_15               : 4;
 	uint32_t lab_int_enb                  : 1;  /**< Link autonomous bandwidth interrupt enable. This bit is not applicable and is reserved for
                                                          endpoints. */
@@ -1297,7 +1291,7 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t ld                           : 1;  /**< Link disable. Not applicable for an upstream port or endpoint device. Hardwired to 0. */
 	uint32_t rcb                          : 1;  /**< Read completion boundary (RCB). */
 	uint32_t reserved_2_2                 : 1;
-	uint32_t aslpc                        : 2;  /**< Active state Link PM control. */
+	uint32_t aslpc                        : 2;  /**< Active state link PM control. */
 #else
 	uint32_t aslpc                        : 2;
 	uint32_t reserved_2_2                 : 1;
@@ -1328,7 +1322,7 @@ typedef union cvmx_pcieepvfx_cfg032 cvmx_pcieepvfx_cfg032_t;
 /**
  * cvmx_pcieepvf#_cfg037
  *
- * This register contains the thirty-eighth 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-eighth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg037 {
@@ -1337,12 +1331,12 @@ union cvmx_pcieepvfx_cfg037 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
-                                                         0x1 = 1
-                                                         0x2 = 2
-                                                         0x3 = 3
-                                                         0x0 = 4 */
-	uint32_t eetps                        : 1;  /**< End-end TLP prefix supported. */
-	uint32_t effs                         : 1;  /**< Extended Fmt field supported. */
+                                                         0x1 = 1.
+                                                         0x2 = 2.
+                                                         0x3 = 3.
+                                                         0x0 = 4. */
+	uint32_t eetps                        : 1;  /**< End-end TLP prefix supported (not supported). */
+	uint32_t effs                         : 1;  /**< Extended fmt field supported (not supported). */
 	uint32_t obffs                        : 2;  /**< Optimized buffer flush fill (OBFF) supported (not supported). */
 	uint32_t reserved_14_17               : 4;
 	uint32_t tphs                         : 2;  /**< TPH completer supported (not supported). */
@@ -1381,7 +1375,7 @@ typedef union cvmx_pcieepvfx_cfg037 cvmx_pcieepvfx_cfg037_t;
 /**
  * cvmx_pcieepvf#_cfg038
  *
- * This register contains the thirty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg038 {
@@ -1421,7 +1415,7 @@ typedef union cvmx_pcieepvfx_cfg038 cvmx_pcieepvfx_cfg038_t;
 /**
  * cvmx_pcieepvf#_cfg039
  *
- * This register contains the fortieth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fortieth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg039 {
@@ -1433,18 +1427,15 @@ union cvmx_pcieepvfx_cfg039 {
 	uint32_t slsv                         : 7;  /**< Supported link speeds vector. Indicates the supported link speeds of the associated port.
                                                          For each bit, a value of 1b indicates that the corresponding link speed is supported;
                                                          otherwise, the link speed is not supported. Bit definitions are:
-                                                         Bit <1> = 2.5 GT/s
-                                                         Bit <2> = 5.0 GT/s
-                                                         Bit <3> = 8.0 GT/s
-                                                         Bits <7:4> are reserved
-                                                         The reset value of this field is controlled by the value read from PEM(0..3)_CFG[MD].
-                                                         PEM*_CFG
-                                                         [MD] RST_VALUE NOTE
-                                                         0x0 0001b 2.5 GHz supported
-                                                         0x1 0011b 5.0 GHz and 2.5 GHz supported
-                                                         0x2 0111b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         0x3 0111b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         (RC Mode) */
+                                                         _ Bit <1> =  2.5 GT/s.
+                                                         _ Bit <2> = 5.0 GT/s.
+                                                         _ Bit <3> = 8.0 GT/s.
+                                                         _ Bits <7:4> are reserved.
+                                                         The reset value of this field is controlled by the value read from PEM()_CFG[MD].
+                                                         _ MD is 0x0, reset to 0x1: 2.5 GHz supported.
+                                                         _ MD is 0x1, reset to 0x3: 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x2, reset to 0x7: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x3, reset to 0x7: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode). */
 	uint32_t reserved_0_0                 : 1;
 #else
 	uint32_t reserved_0_0                 : 1;
@@ -1460,7 +1451,7 @@ typedef union cvmx_pcieepvfx_cfg039 cvmx_pcieepvfx_cfg039_t;
 /**
  * cvmx_pcieepvf#_cfg040
  *
- * This register contains the forty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg040 {
@@ -1470,26 +1461,26 @@ union cvmx_pcieepvfx_cfg040 {
 	uint32_t reserved_17_31               : 15;
 	uint32_t cdl                          : 1;  /**< Current deemphasis level. When the link is operating at 5 GT/s speed, this bit reflects
                                                          the level of deemphasis. Encodings:
-                                                         1 = -3.5 dB
-                                                         0 = -6 dB
+                                                         1 = -3.5 dB.
+                                                         0 = -6 dB.
                                                          The value in this bit is undefined when the link is operating at 2.5 GT/s speed. */
 	uint32_t reserved_13_15               : 3;
 	uint32_t cde                          : 1;  /**< Compliance deemphasis. This bit sets the deemphasis level in polling. Compliance state if
                                                          the entry occurred due to the Tx compliance receive bit being 1. Encodings:
-                                                         1 =  -3.5 dB
-                                                         0 =  -6 dB
+                                                         1 = -3.5 dB.
+                                                         0 = -6 dB.
                                                          When the link is operating at 2.5 GT/s, the setting of this bit has no effect. */
 	uint32_t csos                         : 1;  /**< Compliance SOS. When set to 1, the LTSSM is required to send SKP ordered sets periodically
                                                          in between the (modified) compliance patterns.
                                                          When the link is operating at 2.5 GT/s, the setting of this bit has no effect. */
 	uint32_t emc                          : 1;  /**< Enter modified compliance. When this bit is set to 1, the device transmits a modified
-                                                         compliance pattern if the LTSSM enters polling.Compliance state. */
+                                                         compliance pattern if the LTSSM enters polling compliance state. */
 	uint32_t tm                           : 3;  /**< Transmit margin. This field controls the value of the non-deemphasized voltage level at
                                                          the transmitter pins:
-                                                         0x0 =  800-1200 mV for full swing 400-600 mV for half-swing
-                                                         0x1-0x2 = Values must be monotonic with a nonzero slope
-                                                         0x3 = 200-400 mV for full-swing and 100-200 mV for halfswing
-                                                         0x4-0x7 = Reserved
+                                                         0x0 =  800-1200 mV for full swing 400-600 mV for half-swing.
+                                                         0x1-0x2 = Values must be monotonic with a nonzero slope.
+                                                         0x3 = 200-400 mV for full-swing and 100-200 mV for halfswing.
+                                                         0x4-0x7 = Reserved.
                                                          This field is reset to 0x0 on entry to the LTSSM polling compliance substate. When
                                                          operating in 5.0 GT/s mode with full swing, the deemphasis ratio must be maintained within
                                                          +/- 1 dB from the specification-defined operational value either -3.5 or -6 dB. */
@@ -1504,23 +1495,20 @@ union cvmx_pcieepvfx_cfg040 {
 	uint32_t tls                          : 4;  /**< Target link speed. For downstream ports, this field sets an upper limit on link
                                                          operational speed by restricting the values advertised by the upstream component in its
                                                          training sequences:
-                                                         0x1: 2.5 Gb/s target link speed
-                                                         0x2: 5 Gb/s target link speed
-                                                         0x4: 8Gb/s target link speed (not supported)
+                                                         0x1 = 2.5 Gb/s target link speed.
+                                                         0x2 = 5 Gb/s target link speed.
+                                                         0x4 = 8 Gb/s target link speed (not supported).
                                                          All other encodings are reserved.
                                                          If a value is written to this field that does not correspond to a speed included in the
                                                          supported link speeds field, the result is undefined.
                                                          For both upstream and downstream ports, this field is used to set the target compliance
                                                          mode speed when software is using the enter compliance bit to force a link into compliance
                                                          mode.
-                                                         The reset value of this field is controlled by the value read from PEM(0..3)_CFG[MD].
-                                                         PEM*_CFG
-                                                         [MD] RST_VALUE NOTE
-                                                         00 0001b 2.5 GHz supported
-                                                         01 0010b 5.0 GHz and 2.5 GHz supported
-                                                         10 0011b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         11 0011b 8.0 Ghz, 5.0 GHz and 2.5 GHz supported
-                                                         (RC Mode) */
+                                                         The reset value of this field is controlled by the value read from PEM()_CFG[MD].
+                                                         _ MD is 0x0, reset to 0x1: 2.5 GHz supported.
+                                                         _ MD is 0x1, reset to 0x2: 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x2, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported.
+                                                         _ MD is 0x3, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode). */
 #else
 	uint32_t tls                          : 4;
 	uint32_t ec                           : 1;
@@ -1542,7 +1530,7 @@ typedef union cvmx_pcieepvfx_cfg040 cvmx_pcieepvfx_cfg040_t;
 /**
  * cvmx_pcieepvf#_cfg044
  *
- * This register contains the forty-fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg044 {
@@ -1574,7 +1562,7 @@ typedef union cvmx_pcieepvfx_cfg044 cvmx_pcieepvfx_cfg044_t;
 /**
  * cvmx_pcieepvf#_cfg045
  *
- * This register contains the forty-sixth 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-sixth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg045 {
@@ -1583,10 +1571,8 @@ union cvmx_pcieepvfx_cfg045 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixtoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X Table, as an offset from the base
                                                          address of the BAR indicated by the Table BIR bits. */
-	uint32_t msixtbir                     : 3;  /**< "MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
-                                                         table into memory space.
-                                                         0x0 - 0x4 = BAR#
-                                                         0x6 - 0x7 = Reserved" */
+	uint32_t msixtbir                     : 3;  /**< MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
+                                                         table into memory space. */
 #else
 	uint32_t msixtbir                     : 3;
 	uint32_t msixtoffs                    : 29;
@@ -1599,7 +1585,7 @@ typedef union cvmx_pcieepvfx_cfg045 cvmx_pcieepvfx_cfg045_t;
 /**
  * cvmx_pcieepvf#_cfg046
  *
- * This register contains the forty-seventh 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-seventh 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg046 {
@@ -1608,11 +1594,9 @@ union cvmx_pcieepvfx_cfg046 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixpoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X PBA, as an offset from the base
                                                          address of the BAR indicated by the table PBA bits. */
-	uint32_t msixpbir                     : 3;  /**< "MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
-                                                         pending bit array                                                  into memory space.
-                                                         0x0 - 0x4 = BAR#
-                                                         0x6 - 0x7 = Reserved
-                                                         Writable through PEM(0..3)_CFG_WR. However, the application must not change this field." */
+	uint32_t msixpbir                     : 3;  /**< MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
+                                                         pending bit array into memory space.
+                                                         Writable through PEM()_CFG_WR. However, the application must not change this field. */
 #else
 	uint32_t msixpbir                     : 3;
 	uint32_t msixpoffs                    : 29;
@@ -1625,7 +1609,7 @@ typedef union cvmx_pcieepvfx_cfg046 cvmx_pcieepvfx_cfg046_t;
 /**
  * cvmx_pcieepvf#_cfg048
  *
- * This register contains the forty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg048 {
@@ -1633,11 +1617,11 @@ union cvmx_pcieepvfx_cfg048 {
 	struct cvmx_pcieepvfx_cfg048_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t pmes                         : 5;  /**< PME_Support.
-                                                         Bit 11: If set, PME messages can be generated from D0
-                                                         Bit 12: If set, PME messages can be generated from D1
-                                                         Bit 13: If set, PME messages can be generated from D2
-                                                         Bit 14: If set, PME messages can be generated from D3hot
-                                                         Bit 15: Always zero. VFs do not support D3cold */
+                                                         _ Bit 11: If set, PME Messages can be generated from D0.
+                                                         _ Bit 12: If set, PME Messages can be generated from D1.
+                                                         _ Bit 13: If set, PME Messages can be generated from D2.
+                                                         _ Bit 14: If set, PME Messages can be generated from D3hot.
+                                                         _ Bit 15: If set, PME Messages can be generated from D3cold. */
 	uint32_t d2s                          : 1;  /**< D2 support. */
 	uint32_t d1s                          : 1;  /**< D1 support. */
 	uint32_t auxc                         : 3;  /**< AUX current. */
@@ -1667,7 +1651,7 @@ typedef union cvmx_pcieepvfx_cfg048 cvmx_pcieepvfx_cfg048_t;
 /**
  * cvmx_pcieepvf#_cfg049
  *
- * This register contains the fiftieth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fiftieth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg049 {
@@ -1686,10 +1670,10 @@ union cvmx_pcieepvfx_cfg049 {
 	uint32_t nsr                          : 1;  /**< No soft reset. */
 	uint32_t reserved_2_2                 : 1;
 	uint32_t ps                           : 2;  /**< Power state. Controls the device power state:
-                                                         0x0 = D0
-                                                         0x1 = D1
-                                                         0x2 = D2
-                                                         0x3 = D3
+                                                         0x0 = D0.
+                                                         0x1 = D1.
+                                                         0x2 = D2.
+                                                         0x3 = D3.
                                                          The written value is ignored if the specific state is not supported. */
 #else
 	uint32_t ps                           : 2;
@@ -1713,7 +1697,7 @@ typedef union cvmx_pcieepvfx_cfg049 cvmx_pcieepvfx_cfg049_t;
 /**
  * cvmx_pcieepvf#_cfg064
  *
- * This register contains the sixty-fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the sixty-fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg064 {
@@ -1736,15 +1720,15 @@ typedef union cvmx_pcieepvfx_cfg064 cvmx_pcieepvfx_cfg064_t;
 /**
  * cvmx_pcieepvf#_cfg082
  *
- * This register contains the eighty-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the eighty-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg082 {
 	uint32_t u32;
 	struct cvmx_pcieepvfx_cfg082_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t nco                          : 12; /**< Next capability offset */
-	uint32_t cv                           : 4;  /**< Capability version */
+	uint32_t nco                          : 12; /**< Next capability offset. */
+	uint32_t cv                           : 4;  /**< Capability version. */
 	uint32_t ariid                        : 16; /**< PCIE Express extended capability */
 #else
 	uint32_t ariid                        : 16;
@@ -1759,7 +1743,7 @@ typedef union cvmx_pcieepvfx_cfg082 cvmx_pcieepvfx_cfg082_t;
 /**
  * cvmx_pcieepvf#_cfg083
  *
- * This register contains the eighty-fourth 32-bits of type 0 PCIe configuration space.
+ * This register contains the eighty-fourth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg083 {
@@ -1794,7 +1778,7 @@ typedef union cvmx_pcieepvfx_cfg083 cvmx_pcieepvfx_cfg083_t;
 /**
  * cvmx_pcieepvf#_cfg448
  *
- * This register contains the four hundred forty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred forty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg448 {
@@ -1805,7 +1789,7 @@ union cvmx_pcieepvfx_cfg448 {
                                                          bus initiates a replay upon reception of a nak or when the replay timer expires. This
                                                          value is set correctly by the hardware out of reset or when the negotiated link width or
                                                          payload size changes. If the user changes this value through a CSR write or by an EEPROM
-                                                         load, they should refer to the PCIe Specification for the correct value. */
+                                                         load, they should refer to the PCIe specification for the correct value. */
 	uint32_t rtltl                        : 16; /**< Round trip latency time limit. The ack/nak latency timer expires when it reaches this
                                                          limit. This value is set correctly by the hardware out of reset or when the negotiated
                                                          link width or payload size changes. If the user changes this value through a CSR write or
@@ -1822,7 +1806,7 @@ typedef union cvmx_pcieepvfx_cfg448 cvmx_pcieepvfx_cfg448_t;
 /**
  * cvmx_pcieepvf#_cfg449
  *
- * This register contains the four hundred fiftieth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fiftieth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg449 {
@@ -1848,7 +1832,7 @@ typedef union cvmx_pcieepvfx_cfg449 cvmx_pcieepvfx_cfg449_t;
 /**
  * cvmx_pcieepvf#_cfg450
  *
- * This register contains the four hundred fifty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg450 {
@@ -1856,29 +1840,46 @@ union cvmx_pcieepvfx_cfg450 {
 	struct cvmx_pcieepvfx_cfg450_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lpec                         : 8;  /**< Low power entrance count. The power management state waits this many clock cycles for the
-                                                         associated completion of a CfgWr to PCIE_CFG017 register, power state (PS) field register
+                                                         associated completion of a CfgWr to PCIEEP()_CFG017 register, power state (PS) field
+                                                         register
                                                          to go low-power. This register is intended for applications that do not let the PCI
                                                          Express bus handle a completion for configuration request to the power management control
-                                                         and status (PCIE_CFG017) register. */
+                                                         and status (PCIEP()_CFG017) register. */
 	uint32_t reserved_22_23               : 2;
 	uint32_t link_state                   : 6;  /**< Link state. The link state that the PCI Express bus is forced to when bit 15 (force link)
                                                          is set. State encoding:
-                                                         0x0: DETECT_QUIET. 0x10: RCVRY_IDLE.
-                                                         0x1: DETECT_ACT. 0x11: L0.
-                                                         0x2: POLL_ACTIVE. 0x12: L0S.
-                                                         0x3: POLL_COMPLIANCE. 0x13: L123_SEND_EIDLE.
-                                                         0x4: POLL_CONFIG. 0x14: L1_IDLE.
-                                                         0x5: PRE_DETECT_QUIET. 0x15: L2_IDLE.
-                                                         0x6: DETECT_WAIT. 0x16: L2_WAKE.
-                                                         0x7: CFG_LINKWD_START. 0x17: DISABLED_ENTRY.
-                                                         0x8: CFG_LINKWD_ACEPT. 0x18: DISABLED_IDLE.
-                                                         0x9: CFG_LANENUM_WAIT. 0x19: DISABLED.
-                                                         0xA: CFG_LANENUM_ACEPT. 0x1A: LPBK_ENTRY.
-                                                         0xB: CFG_COMPLETE. 0x1B: LPBK_ACTIVE.
-                                                         0xC: CFG_IDLE. 0x1C: LPBK_EXIT.
-                                                         0xD: RCVRY_LOCK. 0x1D: LPBK_EXIT_TIMEOUT.
-                                                         0xE: RCVRY_SPEED. 0x1E: HOT_RESET_ENTRY.
-                                                         0xF: RCVRY_RCVRCFG. 0x1F: HOT_RESET. */
+                                                         0x0 = DETECT_QUIET.
+                                                         0x1 = DETECT_ACT.
+                                                         0x2 = POLL_ACTIVE.
+                                                         0x3 = POLL_COMPLIANCE.
+                                                         0x4 = POLL_CONFIG.
+                                                         0x5 = PRE_DETECT_QUIET.
+                                                         0x6 = DETECT_WAIT.
+                                                         0x7 = CFG_LINKWD_START.
+                                                         0x8 = CFG_LINKWD_ACEPT.
+                                                         0x9 = CFG_LANENUM_WAIT.
+                                                         0xA = CFG_LANENUM_ACEPT.
+                                                         0xB = CFG_COMPLETE.
+                                                         0xC = CFG_IDLE.
+                                                         0xD = RCVRY_LOCK.
+                                                         0xE = RCVRY_SPEED.
+                                                         0xF = RCVRY_RCVRCFG.
+                                                         0x10 = RCVRY_IDLE.
+                                                         0x11 = L0.
+                                                         0x12 = L0S.
+                                                         0x13 = L123_SEND_EIDLE.
+                                                         0x14 = L1_IDLE.
+                                                         0x15 = L2_IDLE.
+                                                         0x16 = L2_WAKE.
+                                                         0x17 = DISABLED_ENTRY.
+                                                         0x18 = DISABLED_IDLE.
+                                                         0x19 = DISABLED.
+                                                         0x1A = LPBK_ENTRY.
+                                                         0x1B = LPBK_ACTIVE.
+                                                         0x1C = LPBK_EXIT.
+                                                         0x1D = LPBK_EXIT_TIMEOUT.
+                                                         0x1E = HOT_RESET_ENTRY.
+                                                         0x1F = HOT_RESET. */
 	uint32_t force_link                   : 1;  /**< Force link. Forces the link to the state specified by the LINK_STATE field. The force link
                                                          pulse triggers link renegotiation.
                                                          As the force link is a pulse, writing a 1 to it does trigger the forced link state event,
@@ -1901,7 +1902,7 @@ typedef union cvmx_pcieepvfx_cfg450 cvmx_pcieepvfx_cfg450_t;
 /**
  * cvmx_pcieepvf#_cfg451
  *
- * This register contains the four hundred fifty-second 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-second 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg451 {
@@ -1913,21 +1914,21 @@ union cvmx_pcieepvfx_cfg451 {
                                                          did not go to L0s (receive is not in L0s). When not set, core goes to ASPM L1 only after
                                                          idle period, during which both receive and transmit are in L0s. */
 	uint32_t l1el                         : 3;  /**< L1 entrance latency. Values correspond to:
-                                                         0x0 = 1 ms
-                                                         0x1 = 2 ms
-                                                         0x2 = 4 ms
-                                                         0x3 = 8 ms
-                                                         0x4 = 16 ms
-                                                         0x5 = 32 ms
-                                                         0x6 or 0x7 = 64 ms */
+                                                         0x0 = 1 ms.
+                                                         0x1 = 2 ms.
+                                                         0x2 = 4 ms.
+                                                         0x3 = 8 ms.
+                                                         0x4 = 16 ms.
+                                                         0x5 = 32 ms.
+                                                         0x6 or 0x7 = 64 ms. */
 	uint32_t l0el                         : 3;  /**< L0s entrance latency. Values correspond to:
-                                                         0x0 = 1 ms
-                                                         0x1 = 2 ms
-                                                         0x2 = 3 ms
-                                                         0x3 = 4 ms
-                                                         0x4 = 5 ms
-                                                         0x5 = 6 ms
-                                                         0x6 or 0x7 = 7 ms */
+                                                         0x0 = 1 ms.
+                                                         0x1 = 2 ms.
+                                                         0x2 = 3 ms.
+                                                         0x3 = 4 ms.
+                                                         0x4 = 5 ms.
+                                                         0x5 = 6 ms.
+                                                         0x6 or 0x7 = 7 ms. */
 	uint32_t n_fts_cc                     : 8;  /**< N_FTS when common clock is used.
                                                          The number of fast training sequence (FTS) ordered sets to be transmitted when
                                                          transitioning from L0s to L0. The maximum number of FTS ordered sets that a component can
@@ -1957,7 +1958,7 @@ typedef union cvmx_pcieepvfx_cfg451 cvmx_pcieepvfx_cfg451_t;
 /**
  * cvmx_pcieepvf#_cfg452
  *
- * This register contains the four hundred fifty-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg452 {
@@ -1966,28 +1967,29 @@ union cvmx_pcieepvfx_cfg452 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_22_31               : 10;
 	uint32_t lme                          : 6;  /**< Link mode enable set as follows:
-                                                         000001 (0x1) =  *1
-                                                         000011 (0x3) =  *2
-                                                         000111 (0x7) =  *4
-                                                         001111 (0xF) =  *8 (not supported)
-                                                         011111 (0x1F) =  *16 (not supported)
-                                                         111111 (0x3F) =  *32 (not supported)
+                                                         0x1 = x1.
+                                                         0x3 = x2.
+                                                         0x7 = x4.
+                                                         0xF = x8.
+                                                         0x1F = x16 (not supported).
+                                                         0x3F = x32 (not supported).
                                                          This field indicates the maximum number of lanes supported by the PCIe port. The value can
-                                                         be set less than 0x7 to limit the number of lanes that the PCIe will attempt to use. If
+                                                         be set less than 0xF to limit the number of lanes that the PCIe will attempt to use. If
                                                          the value of 0xF set by the hardware is not desired, this field can be programmed to a
-                                                         smaller value (i.e. EEPROM). See also PCIEEP(0..3)_CFG031[MLW].
+                                                         smaller value (i.e. EEPROM). See also PCIEEP()_CFG031[MLW].
                                                          The value of this field does not indicate the number of lanes in use by the PCIe. This
                                                          field sets the maximum number of lanes in the PCIe core that could be used. As per the
-                                                         PCIe specification, the PCIe core can negotiate a smaller link width, so all of *8, *4,
-                                                         *2, and *1 are supported when LME = 0xF, for example. */
+                                                         PCIe specification, the PCIe core can negotiate a smaller link width, so all of x8, x4,
+                                                         x2, and x1 are supported when
+                                                         LME = 0xF, for example. */
 	uint32_t reserved_12_15               : 4;
 	uint32_t link_rate                    : 4;  /**< Reserved. */
 	uint32_t flm                          : 1;  /**< Fast link mode. Sets all internal timers to fast mode for simulation purposes. If during
                                                          an EEPROM load, the first word loaded is 0xFFFFFFFF, the EEPROM load is terminated and
                                                          this bit is set. */
 	uint32_t reserved_6_6                 : 1;
-	uint32_t dllle                        : 1;  /**< DLL link enable. Enables Link initialization. If DLL Link Enable = 0, the PCI Express bus
-                                                         does not transmit InitFC DLLPs and does not establish a Link. */
+	uint32_t dllle                        : 1;  /**< DLL link enable. Enables link initialization. If DLL link enable = 0, the PCI Express bus
+                                                         does not transmit InitFC DLLPs and does not establish a link. */
 	uint32_t reserved_4_4                 : 1;
 	uint32_t ra                           : 1;  /**< Reset assert. Triggers a recovery and forces the LTSSM to the hot reset state (downstream
                                                          port only). */
@@ -2020,7 +2022,7 @@ typedef union cvmx_pcieepvfx_cfg452 cvmx_pcieepvfx_cfg452_t;
 /**
  * cvmx_pcieepvf#_cfg453
  *
- * This register contains the four hundred fifty-fourth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-fourth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg453 {
@@ -2050,7 +2052,7 @@ typedef union cvmx_pcieepvfx_cfg453 cvmx_pcieepvfx_cfg453_t;
 /**
  * cvmx_pcieepvf#_cfg454
  *
- * This register contains the four hundred fifty-fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg454 {
@@ -2058,9 +2060,9 @@ union cvmx_pcieepvfx_cfg454 {
 	struct cvmx_pcieepvfx_cfg454_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
-	uint32_t tmfcwt                       : 5;  /**< Used to be "timer modifier for flow control watchdog timer." No longer used. Repl and
-                                                         enhanced func moved to "queue status" register - CFG463. Kept for now to prevent software
-                                                         from breaking. */
+	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
+                                                         and has moved to the queue status register -- PCIEEP()_CFG463. This field remains to
+                                                         prevent software from breaking. */
 	uint32_t tmanlt                       : 5;  /**< Timer modifier for Ack/Nak latency timer. Increases the timer value for the Ack/Nak
                                                          latency timer, in increments of 64 clock cycles. */
 	uint32_t tmrt                         : 5;  /**< Timer modifier for replay timer. Increases the timer value for the replay timer, in
@@ -2083,7 +2085,7 @@ typedef union cvmx_pcieepvfx_cfg454 cvmx_pcieepvfx_cfg454_t;
 /**
  * cvmx_pcieepvf#_cfg455
  *
- * This register contains the four hundred fifty-sixth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-sixth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg455 {
@@ -2102,7 +2104,7 @@ union cvmx_pcieepvfx_cfg455 {
 	uint32_t m_cpl_rid_err                : 1;  /**< Mask requester ID mismatch error for received completions. */
 	uint32_t m_cpl_tag_err                : 1;  /**< Mask tag error rules for received completions. */
 	uint32_t m_lk_filt                    : 1;  /**< Mask locked request filtering. */
-	uint32_t m_cfg1_filt                  : 1;  /**< Mask Type 1 configuration request filtering */
+	uint32_t m_cfg1_filt                  : 1;  /**< Mask type 1 configuration request filtering. */
 	uint32_t m_bar_match                  : 1;  /**< Mask BAR match filtering. */
 	uint32_t m_pois_filt                  : 1;  /**< Mask poisoned TLP filtering. */
 	uint32_t m_fun                        : 1;  /**< Mask function. */
@@ -2138,7 +2140,7 @@ typedef union cvmx_pcieepvfx_cfg455 cvmx_pcieepvfx_cfg455_t;
 /**
  * cvmx_pcieepvf#_cfg456
  *
- * This register contains the four hundred fifty-seventh 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-seventh 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg456 {
@@ -2147,9 +2149,9 @@ union cvmx_pcieepvfx_cfg456 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_4_31                : 28;
 	uint32_t m_handle_flush               : 1;  /**< Mask core filter to handle flush request. */
-	uint32_t m_dabort_4ucpl               : 1;  /**< Mask DLLP abort for unexpected CPL */
-	uint32_t m_vend1_drp                  : 1;  /**< Mask vendor MSG Type 1 dropped silently. */
-	uint32_t m_vend0_drp                  : 1;  /**< Mask vendor MSG Type 0 dropped with UR error reporting. */
+	uint32_t m_dabort_4ucpl               : 1;  /**< Mask DLLP abort for unexpected CPL. */
+	uint32_t m_vend1_drp                  : 1;  /**< Mask vendor MSG type 1 dropped silently. */
+	uint32_t m_vend0_drp                  : 1;  /**< Mask vendor MSG type 0 dropped with UR error reporting. */
 #else
 	uint32_t m_vend0_drp                  : 1;
 	uint32_t m_vend1_drp                  : 1;
@@ -2165,7 +2167,7 @@ typedef union cvmx_pcieepvfx_cfg456 cvmx_pcieepvfx_cfg456_t;
 /**
  * cvmx_pcieepvf#_cfg458
  *
- * This register contains the four hundred fifty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred fifty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg458 {
@@ -2184,7 +2186,7 @@ typedef union cvmx_pcieepvfx_cfg458 cvmx_pcieepvfx_cfg458_t;
 /**
  * cvmx_pcieepvf#_cfg459
  *
- * This register contains the four hundred sixtieth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixtieth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg459 {
@@ -2203,7 +2205,7 @@ typedef union cvmx_pcieepvfx_cfg459 cvmx_pcieepvfx_cfg459_t;
 /**
  * cvmx_pcieepvf#_cfg460
  *
- * This register contains the four hundred sixty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg460 {
@@ -2228,7 +2230,7 @@ typedef union cvmx_pcieepvfx_cfg460 cvmx_pcieepvfx_cfg460_t;
 /**
  * cvmx_pcieepvf#_cfg461
  *
- * This register contains the four hundred sixty-second 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-second 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg461 {
@@ -2253,7 +2255,7 @@ typedef union cvmx_pcieepvfx_cfg461 cvmx_pcieepvfx_cfg461_t;
 /**
  * cvmx_pcieepvf#_cfg462
  *
- * This register contains the four hundred sixty-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg462 {
@@ -2278,7 +2280,7 @@ typedef union cvmx_pcieepvfx_cfg462 cvmx_pcieepvfx_cfg462_t;
 /**
  * cvmx_pcieepvf#_cfg463
  *
- * This register contains the four hundred sixty-fourth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-fourth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg463 {
@@ -2286,14 +2288,13 @@ union cvmx_pcieepvfx_cfg463 {
 	struct cvmx_pcieepvfx_cfg463_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t fcltoe                       : 1;  /**< FC latency timer override enable. When this bit is set, the value from
-                                                         PCIEEPVF(0..3)_CFG463[FCLTOV] will override the FC latency timer value that the core
+                                                         PCIEEPVF()_CFG463[FCLTOV] will override the FC latency timer value that the core
                                                          calculates according to the PCIe specification. */
 	uint32_t reserved_29_30               : 2;
-	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIEEPVF(0..3)_CFG463[FCLTOE], the value in
+	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIEEPVF()_CFG463[FCLTOE], the value in
                                                          this
                                                          field will override the FC latency timer value that the core calculates according to the
-                                                         PCIe
-                                                         specification. */
+                                                         PCIe specification. */
 	uint32_t reserved_3_15                : 13;
 	uint32_t rqne                         : 1;  /**< Received queue not empty. Indicates there is data in one or more of the receive buffers. */
 	uint32_t trbne                        : 1;  /**< Transmit retry buffer not empty. Indicates that there is data in the transmit retry buffer. */
@@ -2317,7 +2318,7 @@ typedef union cvmx_pcieepvfx_cfg463 cvmx_pcieepvfx_cfg463_t;
 /**
  * cvmx_pcieepvf#_cfg464
  *
- * This register contains the four hundred sixty-fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg464 {
@@ -2342,7 +2343,7 @@ typedef union cvmx_pcieepvfx_cfg464 cvmx_pcieepvfx_cfg464_t;
 /**
  * cvmx_pcieepvf#_cfg465
  *
- * This register contains the four hundred sixty-sixth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-sixth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg465 {
@@ -2367,7 +2368,7 @@ typedef union cvmx_pcieepvfx_cfg465 cvmx_pcieepvfx_cfg465_t;
 /**
  * cvmx_pcieepvf#_cfg466
  *
- * This register contains the four hundred sixty-seventh 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-seventh 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg466 {
@@ -2375,7 +2376,7 @@ union cvmx_pcieepvfx_cfg466 {
 	struct cvmx_pcieepvfx_cfg466_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t rx_queue_order               : 1;  /**< VC ordering for receive queues. Determines the VC ordering rule for the receive queues,
-                                                         used only in the segmented-buffer configuration, writable through PEM(0..3)_CFG_WR:
+                                                         used only in the segmented-buffer configuration, writable through PEM()_CFG_WR:
                                                          0 = Round robin.
                                                          1 = Strict ordering, higher numbered VCs have higher priority. */
 	uint32_t type_ordering                : 1;  /**< TLP type ordering for VC0. Determines the TLP type ordering rule for VC0 receive queues,
@@ -2384,12 +2385,12 @@ union cvmx_pcieepvfx_cfg466 {
                                                          1 = Ordering of received TLPs follows the rules in PCI Express Base Specification */
 	uint32_t reserved_24_29               : 6;
 	uint32_t queue_mode                   : 3;  /**< VC0 posted TLP queue mode. The operating mode of the posted receive queue for VC0, used
-                                                         only in the segmented-buffer configuration, writable through PEM(0..3)_CFG_WR.
+                                                         only in the segmented-buffer configuration, writable through PEM()_CFG_WR.
                                                          However, the application must not change this field.
                                                          Only one bit can be set at a time:
-                                                         Bit 23 = Bypass
-                                                         Bit 22 = Cut-through
-                                                         Bit 21 = Store-and-forward */
+                                                         _ Bit 23 = Bypass.
+                                                         _ Bit 22 = Cut-through.
+                                                         _ Bit 21 = Store-and-forward. */
 	uint32_t reserved_20_20               : 1;
 	uint32_t header_credits               : 8;  /**< VC0 posted header credits. The number of initial posted header credits for VC0, used for
                                                          all receive queue buffer configurations. */
@@ -2412,7 +2413,7 @@ typedef union cvmx_pcieepvfx_cfg466 cvmx_pcieepvfx_cfg466_t;
 /**
  * cvmx_pcieepvf#_cfg467
  *
- * This register contains the four hundred sixty-eighth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-eighth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg467 {
@@ -2422,18 +2423,18 @@ union cvmx_pcieepvfx_cfg467 {
 	uint32_t reserved_24_31               : 8;
 	uint32_t queue_mode                   : 3;  /**< VC0 nonposted TLP queue mode. The operating mode of the nonposted receive queue for VC0,
                                                          used only in the segmented-buffer configuration. This field is writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field.
+                                                         PEM()_CFG_WR. However, the application must not change this field.
                                                          Only one bit can be set at a time:
-                                                         Bit 23 = Bypass
-                                                         Bit 22 = Cut-through
-                                                         Bit 21 = Store-and-forward */
+                                                         _ Bit 23 = Bypass.
+                                                         _ Bit 22 = Cut-through.
+                                                         _ Bit 21 = Store-and-forward. */
 	uint32_t reserved_20_20               : 1;
 	uint32_t header_credits               : 8;  /**< VC0 nonposted header credits. The number of initial nonposted header credits for VC0, used
                                                          for all receive queue buffer configurations. This field is writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field. */
+                                                         PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t data_credits                 : 12; /**< VC0 non-posted data credits. The number of initial nonposted data credits for VC0, used
                                                          for all receive queue buffer configurations. This field is writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field. */
+                                                         PEM()_CFG_WR. However, the application must not change this field. */
 #else
 	uint32_t data_credits                 : 12;
 	uint32_t header_credits               : 8;
@@ -2449,7 +2450,7 @@ typedef union cvmx_pcieepvfx_cfg467 cvmx_pcieepvfx_cfg467_t;
 /**
  * cvmx_pcieepvf#_cfg468
  *
- * This register contains the four hundred sixty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred sixty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg468 {
@@ -2463,15 +2464,15 @@ union cvmx_pcieepvfx_cfg468 {
                                                          Bit 23 = Bypass
                                                          Bit 22 = Cut-through
                                                          Bit 21 = Store-and-forward
-                                                         This field is writable through PEM(0..3)_CFG_WR. However, the application must not change
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
                                                          this field. */
 	uint32_t reserved_20_20               : 1;
 	uint32_t header_credits               : 8;  /**< VC0 completion header credits. The number of initial completion header credits for VC0,
                                                          used for all receive queue buffer configurations. This field is writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field. */
+                                                         PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t data_credits                 : 12; /**< VC0 completion data credits. The number of initial completion data credits for VC0, used
                                                          for all receive queue buffer configurations. This field is writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field. */
+                                                         PEM()_CFG_WR. However, the application must not change this field. */
 #else
 	uint32_t data_credits                 : 12;
 	uint32_t header_credits               : 8;
@@ -2487,7 +2488,7 @@ typedef union cvmx_pcieepvfx_cfg468 cvmx_pcieepvfx_cfg468_t;
 /**
  * cvmx_pcieepvf#_cfg490
  *
- * This register contains the four hundred ninety-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred ninety-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg490 {
@@ -2514,7 +2515,7 @@ typedef union cvmx_pcieepvfx_cfg490 cvmx_pcieepvfx_cfg490_t;
 /**
  * cvmx_pcieepvf#_cfg491
  *
- * This register contains the four hundred ninety-second 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred ninety-second 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg491 {
@@ -2541,7 +2542,7 @@ typedef union cvmx_pcieepvfx_cfg491 cvmx_pcieepvfx_cfg491_t;
 /**
  * cvmx_pcieepvf#_cfg492
  *
- * This register contains the four hundred ninety-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the four hundred ninety-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg492 {
@@ -2568,7 +2569,7 @@ typedef union cvmx_pcieepvfx_cfg492 cvmx_pcieepvfx_cfg492_t;
 /**
  * cvmx_pcieepvf#_cfg515
  *
- * This register contains the five hundred sixteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the five hundred sixteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg515 {
@@ -2583,7 +2584,7 @@ union cvmx_pcieepvfx_cfg515 {
                                                          indicates full swing. When set to 0, indicates low swing. */
 	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change; always reads as zero. */
 	uint32_t le                           : 9;  /**< Lane enable. Indicates the number of lanes to check for exit from electrical idle in
-                                                         Polling.Active and Polling.Compliance. 0x1 = *1, 0x2 = *2, etc. Used to limit the maximum
+                                                         Polling.Active and Polling.Compliance. 0x1 = x1, 0x2 = x2, etc. Used to limit the maximum
                                                          link width to ignore broken lanes that detect a receiver, but will not exit electrical
                                                          idle and would otherwise prevent a valid link from being configured. */
 	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
@@ -2608,7 +2609,7 @@ typedef union cvmx_pcieepvfx_cfg515 cvmx_pcieepvfx_cfg515_t;
 /**
  * cvmx_pcieepvf#_cfg516
  *
- * This register contains the five hundred seventeenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the five hundred seventeenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg516 {
@@ -2627,7 +2628,7 @@ typedef union cvmx_pcieepvfx_cfg516 cvmx_pcieepvfx_cfg516_t;
 /**
  * cvmx_pcieepvf#_cfg517
  *
- * This register contains the five hundred eighteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the five hundred eighteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg517 {
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 7003b9b..a1dd087 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -4427,7 +4427,7 @@ typedef union cvmx_pcieepx_cfg003 cvmx_pcieepx_cfg003_t;
 /**
  * cvmx_pcieep#_cfg004
  *
- * This register contains the fifth 32-bits of type 0 PCIe configuration space.
+ * This register contains the fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg004 {
@@ -4495,17 +4495,17 @@ union cvmx_pcieepx_cfg004 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the BAR 0 base address. */
 	uint32_t reserved_4_14                : 11;
-	uint32_t pf                           : 1;  /**< Prefetchable. This field is writable through PEM(0..3)_CFG_WR. However, the application
+	uint32_t pf                           : 1;  /**< Prefetchable. This field is writable through PEM()_CFG_WR. However, the application
                                                          must not change this field. */
 	uint32_t typ                          : 2;  /**< BAR type.
                                                          0x0 = 32-bit BAR.
                                                          0x2 = 64-bit BAR.
-                                                         This field is writable through PEM(0..3)_CFG_WR. However, the application must not change
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
                                                          this field. */
 	uint32_t mspc                         : 1;  /**< Memory space indicator.
                                                          0 = BAR 0 is a memory BAR.
                                                          1 = BAR 0 is an I/O BAR.
-                                                         This field is writable through PEM(0..3)_CFG_WR. However, the application must not change
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
                                                          this field. */
 #else
 	uint32_t mspc                         : 1;
@@ -4523,7 +4523,7 @@ typedef union cvmx_pcieepx_cfg004 cvmx_pcieepx_cfg004_t;
  * cvmx_pcieep#_cfg004_mask
  *
  * The BAR 0 Mask register is invisible to host software and not readable from the application.
- * The BAR 0 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 0 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg004_mask {
 	uint32_t u32;
@@ -4562,7 +4562,7 @@ typedef union cvmx_pcieepx_cfg004_mask cvmx_pcieepx_cfg004_mask_t;
 /**
  * cvmx_pcieep#_cfg005
  *
- * This register contains the sixth 32-bits of type 0 PCIe configuration space.
+ * This register contains the sixth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg005 {
@@ -4595,7 +4595,7 @@ typedef union cvmx_pcieepx_cfg005 cvmx_pcieepx_cfg005_t;
  * cvmx_pcieep#_cfg005_mask
  *
  * The BAR 0 Mask register is invisible to host software and not readable from the application.
- * The BAR 0 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 0 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg005_mask {
 	uint32_t u32;
@@ -4677,7 +4677,7 @@ typedef union cvmx_pcieepx_cfg006 cvmx_pcieepx_cfg006_t;
  * cvmx_pcieep#_cfg006_mask
  *
  * The BAR 1 Mask register is invisible to host software and not readable from the application.
- * The BAR 1 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 1 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg006_mask {
 	uint32_t u32;
@@ -4749,7 +4749,7 @@ typedef union cvmx_pcieepx_cfg007 cvmx_pcieepx_cfg007_t;
  * cvmx_pcieep#_cfg007_mask
  *
  * The BAR 1 Mask register is invisible to host software and not readable from the application.
- * The BAR 1 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 1 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg007_mask {
 	uint32_t u32;
@@ -4853,7 +4853,7 @@ typedef union cvmx_pcieepx_cfg008 cvmx_pcieepx_cfg008_t;
  * cvmx_pcieep#_cfg008_mask
  *
  * The BAR 2 Mask register is invisible to host software and not readable from the application.
- * The BAR 2 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 2 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg008_mask {
 	uint32_t u32;
@@ -4947,7 +4947,7 @@ typedef union cvmx_pcieepx_cfg009 cvmx_pcieepx_cfg009_t;
  * cvmx_pcieep#_cfg009_mask
  *
  * The BAR 2 Mask register is invisible to host software and not readable from the application.
- * The BAR 2 Mask register is only writable through PEM(0..3)_CFG_WR.
+ * The BAR 2 Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg009_mask {
 	uint32_t u32;
@@ -5085,7 +5085,7 @@ typedef union cvmx_pcieepx_cfg012 cvmx_pcieepx_cfg012_t;
  * cvmx_pcieep#_cfg012_mask
  *
  * The ROM Mask register is invisible to host software and not readable from the application. The
- * ROM Mask register is only writable through PEM(0..3)_CFG_WR.
+ * ROM Mask register is only writable through PEM()_CFG_WR.
  */
 union cvmx_pcieepx_cfg012_mask {
 	uint32_t u32;
@@ -5161,7 +5161,7 @@ typedef union cvmx_pcieepx_cfg013 cvmx_pcieepx_cfg013_t;
 /**
  * cvmx_pcieep#_cfg015
  *
- * This register contains the sixteenth 32-bits of type 0 PCIe configuration space.
+ * This register contains the sixteenth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg015 {
@@ -5561,7 +5561,7 @@ typedef union cvmx_pcieepx_cfg025 cvmx_pcieepx_cfg025_t;
 /**
  * cvmx_pcieep#_cfg028
  *
- * This register contains the twenty-ninth 32-bits of type 0 PCIe configuration space.
+ * This register contains the twenty-ninth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg028 {
@@ -5762,7 +5762,7 @@ typedef union cvmx_pcieepx_cfg029 cvmx_pcieepx_cfg029_t;
 /**
  * cvmx_pcieep#_cfg030
  *
- * This register contains the thirty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg030 {
@@ -6098,7 +6098,7 @@ typedef union cvmx_pcieepx_cfg031 cvmx_pcieepx_cfg031_t;
 /**
  * cvmx_pcieep#_cfg032
  *
- * This register contains the thirty-third 32-bits of type 0 PCIe configuration space.
+ * This register contains the thirty-third 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg032 {
@@ -6445,10 +6445,10 @@ union cvmx_pcieepx_cfg037 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
-                                                         0x1 = 1
-                                                         0x2 = 2
-                                                         0x3 = 3
-                                                         0x4 = 4 */
+                                                         0x1 = 1.
+                                                         0x2 = 2.
+                                                         0x3 = 3.
+                                                         0x0 = 4. */
 	uint32_t eetps                        : 1;  /**< End-end TLP prefix supported (not supported). */
 	uint32_t effs                         : 1;  /**< Extended fmt field supported (not supported). */
 	uint32_t obffs                        : 2;  /**< Optimized Buffer Flush Fill (OBFF) Supported
@@ -6550,17 +6550,17 @@ union cvmx_pcieepx_cfg037 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
-                                                         0x1 = 1
-                                                         0x2 = 2
-                                                         0x3 = 3
-                                                         0x4 = 4 */
+                                                         0x1 = 1.
+                                                         0x2 = 2.
+                                                         0x3 = 3.
+                                                         0x0 = 4. */
 	uint32_t eetps                        : 1;  /**< End-end TLP prefix supported (not supported). */
 	uint32_t effs                         : 1;  /**< Extended fmt field supported (not supported). */
 	uint32_t obffs                        : 2;  /**< Optimized buffer flush fill (OBFF) supported (not supported). */
 	uint32_t reserved_14_17               : 4;
 	uint32_t tphs                         : 2;  /**< TPH completer supported (not supported). */
 	uint32_t ltrs                         : 1;  /**< Latency tolerance reporting (LTR) mechanism supported (not supported). */
-	uint32_t noroprpr                     : 1;  /**< No RO-enabled PR-PR passing (This bit applies to RCs). */
+	uint32_t noroprpr                     : 1;  /**< No RO-enabled PR-PR passing. (This bit applies to RCs.) */
 	uint32_t atom128s                     : 1;  /**< 128-bit AtomicOp supported (not supported). */
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported. */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported. */
@@ -6828,7 +6828,7 @@ typedef union cvmx_pcieepx_cfg039 cvmx_pcieepx_cfg039_t;
 /**
  * cvmx_pcieep#_cfg040
  *
- * This register contains the forty-first 32-bits of type 0 PCIe configuration space.
+ * This register contains the forty-first 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepx_cfg040 {
@@ -7109,7 +7109,7 @@ union cvmx_pcieepx_cfg044 {
                                                          1 = All vectors associated with the function are masked, regardless of their respective
                                                          per-vector mask bits. */
 	uint32_t reserved_27_29               : 3;
-	uint32_t msixts                       : 11; /**< MSI-X table size encoded as (table size - 1). Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t msixts                       : 11; /**< MSI-X table size encoded as (table size - 1). Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t ncp                          : 8;  /**< Next capability pointer */
 	uint32_t msixcid                      : 8;  /**< MSI-X Capability ID */
@@ -7137,13 +7137,12 @@ union cvmx_pcieepx_cfg045 {
 	struct cvmx_pcieepx_cfg045_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixtoffs                    : 29; /**< "MSI-X table offset register. Base address of the MSI-X Table, as an offset from the base
-                                                         address of the BAR indicated by the Table BIR bits. Writable through PEM#_CFG_WR. However,
+                                                         address of the BAR indicated by the Table BIR bits. Writable through PEM()_CFG_WR.
+                                                         However,
                                                          the application must not change this field." */
-	uint32_t msixtbir                     : 3;  /**< "MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
+	uint32_t msixtbir                     : 3;  /**< MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
                                                          table into memory space.
-                                                         000 - 100 = BAR#
-                                                         110 - 111 = Reserved
-                                                         Writable through PEM#_CFG_WR. However, the application must not change this field." */
+                                                         Writable through PEM()_CFG_WR. However, the application must not change this field. */
 #else
 	uint32_t msixtbir                     : 3;
 	uint32_t msixtoffs                    : 29;
@@ -7163,14 +7162,13 @@ union cvmx_pcieepx_cfg046 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg046_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t msixpoffs                    : 29; /**< "MSI-X table offset register. Base address of the MSI-X PBA, as an offset from the base
-                                                         address of the BAR indicated by the table PBA bits. Writable through PEM#_CFG_WR. However,
-                                                         the application must not change this field." */
-	uint32_t msixpbir                     : 3;  /**< "MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
-                                                         pending bit array                                                  into memory space.
-                                                         0x0 - 0x4 = BAR#
-                                                         0x6 - 0x7 = Reserved
-                                                         Writable through PEM(0..3)_CFG_WR. However, the application must not change this field." */
+	uint32_t msixpoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X PBA, as an offset from the base
+                                                         address of the BAR indicated by the table PBA bits. Writable through PEM()_CFG_WR.
+                                                         However,
+                                                         the application must not change this field. */
+	uint32_t msixpbir                     : 3;  /**< MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
+                                                         pending bit array into memory space.
+                                                         Writable through PEM()_CFG_WR. However, the application must not change this field. */
 #else
 	uint32_t msixpbir                     : 3;
 	uint32_t msixpoffs                    : 29;
@@ -8546,14 +8544,14 @@ union cvmx_pcieepx_cfg089 {
 	struct cvmx_pcieepx_cfg089_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l1dph                        : 3;  /**< Lane 1 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l1dph                        : 3;  /**< Lane 1 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l1dtp                        : 4;  /**< Lane 1 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l1dtp                        : 4;  /**< Lane 1 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_23               : 9;
-	uint32_t l0dph                        : 3;  /**< Lane 0 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l0dph                        : 3;  /**< Lane 0 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l0dtp                        : 4;  /**< Lane 0 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l0dtp                        : 4;  /**< Lane 0 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_0_7                 : 8;
 #else
@@ -8581,14 +8579,14 @@ union cvmx_pcieepx_cfg090 {
 	struct cvmx_pcieepx_cfg090_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l3dph                        : 3;  /**< Lane 3 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l3dph                        : 3;  /**< Lane 3 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l3dtp                        : 4;  /**< Lane 3 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l3dtp                        : 4;  /**< Lane 3 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_23               : 9;
-	uint32_t l2dph                        : 3;  /**< Lane 2 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l2dph                        : 3;  /**< Lane 2 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l2dtp                        : 4;  /**< Lane 2 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l2dtp                        : 4;  /**< Lane 2 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_0_7                 : 8;
 #else
@@ -8616,14 +8614,14 @@ union cvmx_pcieepx_cfg091 {
 	struct cvmx_pcieepx_cfg091_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l5dph                        : 3;  /**< Lane 5 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l5dph                        : 3;  /**< Lane 5 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l5dtp                        : 4;  /**< Lane 5 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l5dtp                        : 4;  /**< Lane 5 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_23               : 9;
-	uint32_t l4dph                        : 3;  /**< Lane 4 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l4dph                        : 3;  /**< Lane 4 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l4dtp                        : 4;  /**< Lane 4 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l4dtp                        : 4;  /**< Lane 4 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_0_7                 : 8;
 #else
@@ -8651,14 +8649,14 @@ union cvmx_pcieepx_cfg092 {
 	struct cvmx_pcieepx_cfg092_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l7dph                        : 3;  /**< Lane 7 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l7dph                        : 3;  /**< Lane 7 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l7dtp                        : 4;  /**< Lane 7 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l7dtp                        : 4;  /**< Lane 7 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_23               : 9;
-	uint32_t l6dph                        : 3;  /**< Lane 6 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l6dph                        : 3;  /**< Lane 6 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l6dtp                        : 4;  /**< Lane 6 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l6dtp                        : 4;  /**< Lane 6 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_0_7                 : 8;
 #else
@@ -8710,8 +8708,8 @@ union cvmx_pcieepx_cfg095 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t vfmimn                       : 11; /**< VF migration interrupt message number. */
 	uint32_t reserved_2_20                : 19;
-	uint32_t arichp                       : 1;  /**< "ARI capable hierarchy preserved. Writable through PEM#_CFG_WR. However, the application
-                                                         must not change this field." */
+	uint32_t arichp                       : 1;  /**< ARI capable hierarchy preserved. Writable through PEM()_CFG_WR. However, the application
+                                                         must not change this field. */
 	uint32_t vfmc                         : 1;  /**< VF migration capable. */
 #else
 	uint32_t vfmc                         : 1;
@@ -8738,8 +8736,8 @@ union cvmx_pcieepx_cfg096 {
 	uint32_t ms                           : 1;  /**< VF migration status. */
 	uint32_t reserved_5_15                : 11;
 	uint32_t ach                          : 1;  /**< ARI capable hierarchy.
-                                                         0b = All PFs have non-ARI capable hierarchy
-                                                         1b = All PFs have ARI capable hierarchy
+                                                         0 = All PFs have non-ARI capable hierarchy.
+                                                         1 = All PFs have ARI capable hierarchy.
                                                          The value in this field in PF0 is used for all other physical functions. */
 	uint32_t mse                          : 1;  /**< VF MSE. */
 	uint32_t mie                          : 1;  /**< VF migration interrupt enable. */
@@ -8897,10 +8895,10 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t lbab                         : 17; /**< Lower bits of the VF BAR 0 base address. */
 	uint32_t reserved_4_14                : 11;
 	uint32_t pf                           : 1;  /**< Prefetchable. */
-	uint32_t typ                          : 2;  /**< BAR type
+	uint32_t typ                          : 2;  /**< BAR type:
                                                          0x0 = 32-bit BAR.
                                                          0x2 = 64-bit BAR. */
-	uint32_t mspc                         : 1;  /**< Memory space indicator
+	uint32_t mspc                         : 1;  /**< Memory space indicator:
                                                          0 = BAR 0 is a memory BAR.
                                                          1 = BAR 0 is an I/O BAR. */
 #else
@@ -9068,7 +9066,7 @@ union cvmx_pcieepx_cfg111 {
 	uint32_t srs                          : 26; /**< "Supported resource sizes. PEM advertises the maximum allowable BAR size (512 GB -
                                                          0xF_FFFF) when the fus__bar2_size_conf is in tact. When the fuse is blown, the CN78XX
                                                          advertises a BAR size of 32TB (0x3FF_FFFF). The BAR is disabled at runtime by writing all
-                                                         zeros through PEM#_CFG_WR to this field." */
+                                                         zeros through PEM()_CFG_WR to this field." */
 	uint32_t reserved_0_3                 : 4;
 #else
 	uint32_t reserved_0_3                 : 4;
@@ -9945,7 +9943,7 @@ union cvmx_pcieepx_cfg454 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
-                                                         and has moved to the queue status register -- PCIEEP*_CFG463. This field remains to
+                                                         and has moved to the queue status register -- PCIEEP()_CFG463. This field remains to
                                                          prevent software from breaking. */
 	uint32_t tmanlt                       : 5;  /**< Timer modifier for Ack/Nak latency timer. Increases the timer value for the Ack/Nak
                                                          latency timer, in increments of 64 clock cycles. */
@@ -10280,10 +10278,10 @@ union cvmx_pcieepx_cfg463 {
 	struct cvmx_pcieepx_cfg463_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t fcltoe                       : 1;  /**< FC latency timer override enable. When this bit is set, the value in
-                                                         PCIEEP*_CFG463[FCLTOV] will override the FC latency timer value that the core calculates
+                                                         PCIEEP()_CFG463[FCLTOV] will override the FC latency timer value that the core calculates
                                                          according to the PCIe specification. */
 	uint32_t reserved_29_30               : 2;
-	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIEEP*_CFG463[FCLTOE], the value in this
+	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIEEP()_CFG463[FCLTOE], the value in this
                                                          field will override the FC latency timer value that the core calculates according to the
                                                          PCIe specification. */
 	uint32_t reserved_3_15                : 13;
@@ -10919,21 +10917,21 @@ union cvmx_pcieepx_cfg554 {
                                                          performed in the EQ Master, when finding the highest FOM among all preset evaluations. */
 	uint32_t prv                          : 16; /**< Preset request vector. Requesting of presets during the initial part of the EQ master
                                                          phase. Encoding scheme as follows:
-                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase
-                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase
-                                                         - 0000000000000000: No preset req/evaluated in EQ master phase
-                                                         00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
-                                                         00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
-                                                         00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
-                                                         00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
-                                                         00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
-                                                         00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
-                                                         00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
-                                                         00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
-                                                         00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
-                                                         00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
-                                                         000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
-                                                         All other encodings: Reserved */
+                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
+                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
+                                                         _ 0000000000000000: No preset req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
+                                                         _ 00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
+                                                         _ 00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
+                                                         _ 00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
+                                                         _ 00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
+                                                         _ 00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
+                                                         _ 000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
+                                                         _ All other encodings: Reserved */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
                                                          the PHY does not respond within 2 ms to the assertion of RxEqEval:
@@ -10942,12 +10940,12 @@ union cvmx_pcieepx_cfg554 {
                                                          1 = Ignore the 2 ms timeout and continue as normal. This is used to support PHYs that
                                                          require more than 2 ms to respond to the assertion of RxEqEval. */
 	uint32_t bt                           : 1;  /**< Behavior after 24 ms timeout (when optimal settings are not found).
-                                                         FOR a USP: determine the next LTSSM state from Phase2
-                                                         0 = Recovery.Speed
-                                                         1 = Recovry.Equalization.Phase3
-                                                         FOR a DSP: determine the next LTSSM state from Phase3
-                                                         0 = Recovery.Speed
-                                                         1 = Recovry.Equalization.RcrLock
+                                                         For a USP: determine the next LTSSM state from Phase2:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.Phase3.
+                                                         For a DSP: determine the next LTSSM state from Phase3:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.RcrLock.
                                                          When optimal settings are not found:
                                                          * Equalization phase 3 successful status bit is not set in the Link Status Register
                                                          * Equalization phase 3 complete status bit is set in the Link Status Register */
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 60d82f2..e56e364 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -3719,7 +3719,7 @@ static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long block_id)
 /**
  * cvmx_pcierc#_cfg000
  *
- * This register contains the first 32-bits of type 1 PCIe configuration space.
+ * This register contains the first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg000 {
@@ -3755,7 +3755,7 @@ typedef union cvmx_pciercx_cfg000 cvmx_pciercx_cfg000_t;
 /**
  * cvmx_pcierc#_cfg001
  *
- * This register contains the second 32-bits of type 1 PCIe configuration space.
+ * This register contains the second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg001 {
@@ -3843,7 +3843,7 @@ typedef union cvmx_pciercx_cfg001 cvmx_pciercx_cfg001_t;
 /**
  * cvmx_pcierc#_cfg002
  *
- * This register contains the third 32-bits of type 1 PCIe configuration space.
+ * This register contains the third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg002 {
@@ -3885,7 +3885,7 @@ typedef union cvmx_pciercx_cfg002 cvmx_pciercx_cfg002_t;
 /**
  * cvmx_pcierc#_cfg003
  *
- * This register contains the fourth 32-bits of type 1 PCIe configuration space.
+ * This register contains the fourth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg003 {
@@ -3934,7 +3934,7 @@ typedef union cvmx_pciercx_cfg003 cvmx_pciercx_cfg003_t;
 /**
  * cvmx_pcierc#_cfg004
  *
- * This register contains the fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg004 {
@@ -3966,7 +3966,7 @@ typedef union cvmx_pciercx_cfg004 cvmx_pciercx_cfg004_t;
 /**
  * cvmx_pcierc#_cfg005
  *
- * This register contains the sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg005 {
@@ -3998,7 +3998,7 @@ typedef union cvmx_pciercx_cfg005 cvmx_pciercx_cfg005_t;
 /**
  * cvmx_pcierc#_cfg006
  *
- * This register contains the seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg006 {
@@ -4037,7 +4037,7 @@ typedef union cvmx_pciercx_cfg006 cvmx_pciercx_cfg006_t;
 /**
  * cvmx_pcierc#_cfg007
  *
- * This register contains the eighth 32-bits of type 1 PCIe configuration space.
+ * This register contains the eighth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg007 {
@@ -4111,7 +4111,7 @@ typedef union cvmx_pciercx_cfg007 cvmx_pciercx_cfg007_t;
 /**
  * cvmx_pcierc#_cfg008
  *
- * This register contains the ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg008 {
@@ -4149,7 +4149,7 @@ typedef union cvmx_pciercx_cfg008 cvmx_pciercx_cfg008_t;
 /**
  * cvmx_pcierc#_cfg009
  *
- * This register contains the tenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the tenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg009 {
@@ -4200,7 +4200,7 @@ typedef union cvmx_pciercx_cfg009 cvmx_pciercx_cfg009_t;
 /**
  * cvmx_pcierc#_cfg010
  *
- * This register contains the eleventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the eleventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg010 {
@@ -4234,7 +4234,7 @@ typedef union cvmx_pciercx_cfg010 cvmx_pciercx_cfg010_t;
 /**
  * cvmx_pcierc#_cfg011
  *
- * This register contains the twelfth 32-bits of type 1 PCIe configuration space.
+ * This register contains the twelfth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg011 {
@@ -4268,7 +4268,7 @@ typedef union cvmx_pciercx_cfg011 cvmx_pciercx_cfg011_t;
 /**
  * cvmx_pcierc#_cfg012
  *
- * This register contains the thirteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg012 {
@@ -4304,7 +4304,7 @@ typedef union cvmx_pciercx_cfg012 cvmx_pciercx_cfg012_t;
 /**
  * cvmx_pcierc#_cfg013
  *
- * This register contains the fourteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the fourteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg013 {
@@ -4341,7 +4341,7 @@ typedef union cvmx_pciercx_cfg013 cvmx_pciercx_cfg013_t;
 /**
  * cvmx_pcierc#_cfg014
  *
- * This register contains the fifteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the fifteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg014 {
@@ -4373,7 +4373,7 @@ typedef union cvmx_pciercx_cfg014 cvmx_pciercx_cfg014_t;
 /**
  * cvmx_pcierc#_cfg015
  *
- * This register contains the sixteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg015 {
@@ -4450,7 +4450,7 @@ typedef union cvmx_pciercx_cfg015 cvmx_pciercx_cfg015_t;
 /**
  * cvmx_pcierc#_cfg016
  *
- * This register contains the seventeenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventeenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg016 {
@@ -4517,7 +4517,7 @@ typedef union cvmx_pciercx_cfg016 cvmx_pciercx_cfg016_t;
 /**
  * cvmx_pcierc#_cfg017
  *
- * This register contains the eighteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the eighteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg017 {
@@ -4582,7 +4582,7 @@ typedef union cvmx_pciercx_cfg017 cvmx_pciercx_cfg017_t;
 /**
  * cvmx_pcierc#_cfg020
  *
- * This register contains the twenty-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the twenty-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg020 {
@@ -4665,19 +4665,19 @@ union cvmx_pciercx_cfg020 {
 	struct cvmx_pciercx_cfg020_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
-	uint32_t pvms                         : 1;  /**< PCI PVM support. */
-	uint32_t m64                          : 1;  /**< 64-bit address capable, writable through PEM(0..3)_CFG_WR. However, the application must
+	uint32_t pvms                         : 1;  /**< Per-vector masking capable. */
+	uint32_t m64                          : 1;  /**< 64-bit address capable, writable through PEM()_CFG_WR. However, the application must
                                                          not change this field. */
 	uint32_t mme                          : 3;  /**< Multiple message enabled. Indicates that multiple message mode is enabled by system
                                                          software. The number of messages enabled must be less than or equal to the multiple
                                                          message capable (MMC) value. */
-	uint32_t mmc                          : 3;  /**< Multiple message capable, writable through PEM(0..3)_CFG_WR. However, the application must
+	uint32_t mmc                          : 3;  /**< Multiple message capable, writable through PEM()_CFG_WR. However, the application must
                                                          not change this field. */
 	uint32_t msien                        : 1;  /**< MSI enabled. When set, INTx must be disabled. This bit must never be set, as internal-MSI
                                                          is not supported in RC mode. (Note that this has no effect on external MSI, which is
                                                          commonly used in RC mode.) */
 	uint32_t ncp                          : 8;  /**< Next capability pointer. Points to PCI Express capabilities by default, writable through
-                                                         PEM(0..3)_CFG_WR. However, the application must not change this field. */
+                                                         PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t msicid                       : 8;  /**< MSI capability ID. */
 #else
 	uint32_t msicid                       : 8;
@@ -4697,7 +4697,7 @@ typedef union cvmx_pciercx_cfg020 cvmx_pciercx_cfg020_t;
 /**
  * cvmx_pcierc#_cfg021
  *
- * This register contains the twenty-second 32-bits of type 1 PCIe configuration space.
+ * This register contains the twenty-second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg021 {
@@ -4731,7 +4731,7 @@ typedef union cvmx_pciercx_cfg021 cvmx_pciercx_cfg021_t;
 /**
  * cvmx_pcierc#_cfg022
  *
- * This register contains the twenty-third 32-bits of type 1 PCIe configuration space.
+ * This register contains the twenty-third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg022 {
@@ -4763,7 +4763,7 @@ typedef union cvmx_pciercx_cfg022 cvmx_pciercx_cfg022_t;
 /**
  * cvmx_pcierc#_cfg023
  *
- * This register contains the twenty-fourth 32-bits of type 1 PCIe configuration space.
+ * This register contains the twenty-fourth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg023 {
@@ -4799,7 +4799,7 @@ typedef union cvmx_pciercx_cfg023 cvmx_pciercx_cfg023_t;
 /**
  * cvmx_pcierc#_cfg028
  *
- * This register contains the twenty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the twenty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg028 {
@@ -4851,7 +4851,7 @@ typedef union cvmx_pciercx_cfg028 cvmx_pciercx_cfg028_t;
 /**
  * cvmx_pcierc#_cfg029
  *
- * This register contains the thirtieth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirtieth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg029 {
@@ -4916,7 +4916,7 @@ typedef union cvmx_pciercx_cfg029 cvmx_pciercx_cfg029_t;
 /**
  * cvmx_pcierc#_cfg030
  *
- * This register contains the thirty-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg030 {
@@ -5033,7 +5033,7 @@ typedef union cvmx_pciercx_cfg030 cvmx_pciercx_cfg030_t;
 /**
  * cvmx_pcierc#_cfg031
  *
- * This register contains the thirty-second 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg031 {
@@ -5164,7 +5164,7 @@ typedef union cvmx_pciercx_cfg031 cvmx_pciercx_cfg031_t;
 /**
  * cvmx_pcierc#_cfg032
  *
- * This register contains the thirty-third 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg032 {
@@ -5267,7 +5267,7 @@ typedef union cvmx_pciercx_cfg032 cvmx_pciercx_cfg032_t;
 /**
  * cvmx_pcierc#_cfg033
  *
- * This register contains the thirty-fourth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-fourth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg033 {
@@ -5331,7 +5331,7 @@ typedef union cvmx_pciercx_cfg033 cvmx_pciercx_cfg033_t;
 /**
  * cvmx_pcierc#_cfg034
  *
- * This register contains the thirty-fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg034 {
@@ -5405,7 +5405,7 @@ typedef union cvmx_pciercx_cfg034 cvmx_pciercx_cfg034_t;
 /**
  * cvmx_pcierc#_cfg035
  *
- * This register contains the thirty-sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg035 {
@@ -5453,7 +5453,7 @@ typedef union cvmx_pciercx_cfg035 cvmx_pciercx_cfg035_t;
 /**
  * cvmx_pcierc#_cfg036
  *
- * This register contains the thirty-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg036 {
@@ -5491,7 +5491,7 @@ typedef union cvmx_pciercx_cfg036 cvmx_pciercx_cfg036_t;
 /**
  * cvmx_pcierc#_cfg037
  *
- * This register contains the thirty-eighth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-eighth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg037 {
@@ -5725,7 +5725,7 @@ typedef union cvmx_pciercx_cfg037 cvmx_pciercx_cfg037_t;
 /**
  * cvmx_pcierc#_cfg038
  *
- * This register contains the thirty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the thirty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg038 {
@@ -5886,7 +5886,7 @@ typedef union cvmx_pciercx_cfg038 cvmx_pciercx_cfg038_t;
 /**
  * cvmx_pcierc#_cfg039
  *
- * This register contains the fortieth 32-bits of type 1 PCIe configuration space.
+ * This register contains the fortieth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg039 {
@@ -5944,7 +5944,7 @@ typedef union cvmx_pciercx_cfg039 cvmx_pciercx_cfg039_t;
 /**
  * cvmx_pcierc#_cfg040
  *
- * This register contains the forty-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg040 {
@@ -6172,7 +6172,7 @@ typedef union cvmx_pciercx_cfg040 cvmx_pciercx_cfg040_t;
 /**
  * cvmx_pcierc#_cfg041
  *
- * This register contains the forty-second 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg041 {
@@ -6204,7 +6204,7 @@ typedef union cvmx_pciercx_cfg041 cvmx_pciercx_cfg041_t;
 /**
  * cvmx_pcierc#_cfg042
  *
- * This register contains the forty-third 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg042 {
@@ -6236,7 +6236,7 @@ typedef union cvmx_pciercx_cfg042 cvmx_pciercx_cfg042_t;
 /**
  * cvmx_pcierc#_cfg044
  *
- * This register contains the forty-fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg044 {
@@ -6269,7 +6269,7 @@ typedef union cvmx_pciercx_cfg044 cvmx_pciercx_cfg044_t;
 /**
  * cvmx_pcierc#_cfg045
  *
- * This register contains the forty-sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg045 {
@@ -6277,13 +6277,11 @@ union cvmx_pciercx_cfg045 {
 	struct cvmx_pciercx_cfg045_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixtoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X Table, as an offset from the base
-                                                         address of the BAR indicated by the table BIR bits. Writable through PEM(0..3)_CFG_WR.
+                                                         address of the BAR indicated by the table BIR bits. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t msixtbir                     : 3;  /**< "MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
                                                          table into memory space.
-                                                         0x0 - 0x4 = BAR#
-                                                         0x6 - 0x7 = Reserved
-                                                         Writable through PEM(0..3)_CFG_WR. However, the application must not change this field." */
+                                                         Writable through PEM()_CFG_WR. However, the application must not change this field." */
 #else
 	uint32_t msixtbir                     : 3;
 	uint32_t msixtoffs                    : 29;
@@ -6296,7 +6294,7 @@ typedef union cvmx_pciercx_cfg045 cvmx_pciercx_cfg045_t;
 /**
  * cvmx_pcierc#_cfg046
  *
- * This register contains the forty-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the forty-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg046 {
@@ -6304,13 +6302,11 @@ union cvmx_pciercx_cfg046 {
 	struct cvmx_pciercx_cfg046_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixpoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X PBA, as an offset from the base
-                                                         address of the BAR indicated by the table PBA bits. Writable through PEM(0..3)_CFG_WR.
+                                                         address of the BAR indicated by the table PBA bits. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t msixpbir                     : 3;  /**< "MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
-                                                         pending bit array                                                  into memory space.
-                                                         0x0 - 0x4 = BAR#
-                                                         0x6 - 0x7 = Reserved
-                                                         Writable through PEM(0..3)_CFG_WR. However, the application must not change this field." */
+                                                         pending bit array into memory space.
+                                                         Writable through PEM()_CFG_WR. However, the application must not change this field." */
 #else
 	uint32_t msixpbir                     : 3;
 	uint32_t msixpoffs                    : 29;
@@ -6323,7 +6319,7 @@ typedef union cvmx_pciercx_cfg046 cvmx_pciercx_cfg046_t;
 /**
  * cvmx_pcierc#_cfg064
  *
- * This register contains the sixty-fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixty-fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg064 {
@@ -6359,7 +6355,7 @@ typedef union cvmx_pciercx_cfg064 cvmx_pciercx_cfg064_t;
 /**
  * cvmx_pcierc#_cfg065
  *
- * This register contains the sixty-sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixty-sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg065 {
@@ -6535,7 +6531,7 @@ typedef union cvmx_pciercx_cfg065 cvmx_pciercx_cfg065_t;
 /**
  * cvmx_pcierc#_cfg066
  *
- * This register contains the sixty-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixty-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg066 {
@@ -6711,7 +6707,7 @@ typedef union cvmx_pciercx_cfg066 cvmx_pciercx_cfg066_t;
 /**
  * cvmx_pcierc#_cfg067
  *
- * This register contains the sixty-eighth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixty-eighth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg067 {
@@ -6921,7 +6917,7 @@ typedef union cvmx_pciercx_cfg067 cvmx_pciercx_cfg067_t;
 /**
  * cvmx_pcierc#_cfg068
  *
- * This register contains the sixty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the sixty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg068 {
@@ -6993,7 +6989,7 @@ typedef union cvmx_pciercx_cfg068 cvmx_pciercx_cfg068_t;
 /**
  * cvmx_pcierc#_cfg069
  *
- * This register contains the seventieth 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventieth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg069 {
@@ -7065,7 +7061,7 @@ typedef union cvmx_pciercx_cfg069 cvmx_pciercx_cfg069_t;
 /**
  * cvmx_pcierc#_cfg070
  *
- * This register contains the seventy-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventy-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg070 {
@@ -7127,7 +7123,7 @@ typedef union cvmx_pciercx_cfg070 cvmx_pciercx_cfg070_t;
 /**
  * cvmx_pcierc#_cfg071
  *
- * This register contains the seventy-second 32-bits of type 1 PCIe configuration space.  The
+ * This register contains the seventy-second 32-bits of PCIe type 1 configuration space.  The
  * header log registers collect the header for the TLP corresponding to a detected error.
  */
 union cvmx_pciercx_cfg071 {
@@ -7159,7 +7155,7 @@ typedef union cvmx_pciercx_cfg071 cvmx_pciercx_cfg071_t;
 /**
  * cvmx_pcierc#_cfg072
  *
- * This register contains the seventy-third 32-bits of type 1 PCIe configuration space.  The
+ * This register contains the seventy-third 32-bits of PCIe type 1 configuration space.  The
  * header log registers collect the header for the TLP corresponding to a detected error.
  */
 union cvmx_pciercx_cfg072 {
@@ -7191,7 +7187,7 @@ typedef union cvmx_pciercx_cfg072 cvmx_pciercx_cfg072_t;
 /**
  * cvmx_pcierc#_cfg073
  *
- * This register contains the seventy-fourth 32-bits of type 1 PCIe configuration space.  The
+ * This register contains the seventy-fourth 32-bits of PCIe type 1 configuration space.  The
  * header log registers collect the header for the TLP corresponding to a detected error.
  */
 union cvmx_pciercx_cfg073 {
@@ -7223,7 +7219,7 @@ typedef union cvmx_pciercx_cfg073 cvmx_pciercx_cfg073_t;
 /**
  * cvmx_pcierc#_cfg074
  *
- * This register contains the seventy-fifth 32-bits of type 1 PCIe configuration space.  The
+ * This register contains the seventy-fifth 32-bits of PCIe type 1 configuration space.  The
  * header log registers collect the header for the TLP corresponding to a detected error.
  */
 union cvmx_pciercx_cfg074 {
@@ -7255,7 +7251,7 @@ typedef union cvmx_pciercx_cfg074 cvmx_pciercx_cfg074_t;
 /**
  * cvmx_pcierc#_cfg075
  *
- * This register contains the seventy-sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventy-sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg075 {
@@ -7293,7 +7289,7 @@ typedef union cvmx_pciercx_cfg075 cvmx_pciercx_cfg075_t;
 /**
  * cvmx_pcierc#_cfg076
  *
- * This register contains the seventy-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventy-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg076 {
@@ -7342,7 +7338,7 @@ typedef union cvmx_pciercx_cfg076 cvmx_pciercx_cfg076_t;
 /**
  * cvmx_pcierc#_cfg077
  *
- * This register contains the seventy-eighth 32-bits of type 1 PCIe configuration space.
+ * This register contains the seventy-eighth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg077 {
@@ -7451,24 +7447,24 @@ union cvmx_pciercx_cfg089 {
 	struct cvmx_pciercx_cfg089_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l1urph                       : 3;  /**< Lane 1 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l1urph                       : 3;  /**< Lane 1 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l1utp                        : 4;  /**< Lane 1 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l1utp                        : 4;  /**< Lane 1 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l1drph                       : 3;  /**< Lane 1 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l1drph                       : 3;  /**< Lane 1 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l1ddtp                       : 4;  /**< Lane 1 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l1ddtp                       : 4;  /**< Lane 1 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l0urph                       : 3;  /**< Lane 0 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l0urph                       : 3;  /**< Lane 0 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l0utp                        : 4;  /**< Lane 0 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l0utp                        : 4;  /**< Lane 0 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l0drph                       : 3;  /**< Lane 0 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l0drph                       : 3;  /**< Lane 0 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l0dtp                        : 4;  /**< Lane 0 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l0dtp                        : 4;  /**< Lane 0 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 #else
 	uint32_t l0dtp                        : 4;
@@ -7500,24 +7496,24 @@ union cvmx_pciercx_cfg090 {
 	struct cvmx_pciercx_cfg090_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l3urph                       : 3;  /**< Lane 3 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l3urph                       : 3;  /**< Lane 3 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l3utp                        : 4;  /**< Lane 3 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l3utp                        : 4;  /**< Lane 3 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l3drph                       : 3;  /**< Lane 3 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l3drph                       : 3;  /**< Lane 3 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l3dtp                        : 4;  /**< Lane 3 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l3dtp                        : 4;  /**< Lane 3 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l2urph                       : 3;  /**< Lane 2 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l2urph                       : 3;  /**< Lane 2 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l2utp                        : 4;  /**< Lane 2 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l2utp                        : 4;  /**< Lane 2 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l2drph                       : 3;  /**< Lane 2 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l2drph                       : 3;  /**< Lane 2 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l2dtp                        : 4;  /**< Lane 2 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l2dtp                        : 4;  /**< Lane 2 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 #else
 	uint32_t l2dtp                        : 4;
@@ -7549,24 +7545,24 @@ union cvmx_pciercx_cfg091 {
 	struct cvmx_pciercx_cfg091_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l5urph                       : 3;  /**< Lane 5 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l5urph                       : 3;  /**< Lane 5 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l5utp                        : 4;  /**< Lane 5 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l5utp                        : 4;  /**< Lane 5 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l5drph                       : 3;  /**< Lane 5 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l5drph                       : 3;  /**< Lane 5 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l5dtp                        : 4;  /**< Lane 5 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l5dtp                        : 4;  /**< Lane 5 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l4urph                       : 3;  /**< Lane 4 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l4urph                       : 3;  /**< Lane 4 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l4utp                        : 4;  /**< Lane 4 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l4utp                        : 4;  /**< Lane 4 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l4drph                       : 3;  /**< Lane 4 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l4drph                       : 3;  /**< Lane 4 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l4dtp                        : 4;  /**< Lane 4 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l4dtp                        : 4;  /**< Lane 4 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 #else
 	uint32_t l4dtp                        : 4;
@@ -7598,24 +7594,24 @@ union cvmx_pciercx_cfg092 {
 	struct cvmx_pciercx_cfg092_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l7urph                       : 3;  /**< Lane 7 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l7urph                       : 3;  /**< Lane 7 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l7utp                        : 4;  /**< Lane 7 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l7utp                        : 4;  /**< Lane 7 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l7drph                       : 3;  /**< Lane 7 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l7drph                       : 3;  /**< Lane 7 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l7dtp                        : 4;  /**< Lane 7 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l7dtp                        : 4;  /**< Lane 7 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l6urph                       : 3;  /**< Lane 6 upstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l6urph                       : 3;  /**< Lane 6 upstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l6utp                        : 4;  /**< Lane 6 upstream component transmitter preset. Writable through PEM(0..3)_CFG_WR. However,
+	uint32_t l6utp                        : 4;  /**< Lane 6 upstream component transmitter preset. Writable through PEM()_CFG_WR. However,
                                                          the application must not change this field. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l6drph                       : 3;  /**< Lane 6 downstream component receiver preset hint. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l6drph                       : 3;  /**< Lane 6 downstream component receiver preset hint. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
-	uint32_t l6dtp                        : 4;  /**< Lane 6 downstream component transmitter preset. Writable through PEM(0..3)_CFG_WR.
+	uint32_t l6dtp                        : 4;  /**< Lane 6 downstream component transmitter preset. Writable through PEM()_CFG_WR.
                                                          However, the application must not change this field. */
 #else
 	uint32_t l6dtp                        : 4;
@@ -7639,7 +7635,7 @@ typedef union cvmx_pciercx_cfg092 cvmx_pciercx_cfg092_t;
 /**
  * cvmx_pcierc#_cfg448
  *
- * This register contains the four hundred forty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred forty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg448 {
@@ -7687,7 +7683,7 @@ typedef union cvmx_pciercx_cfg448 cvmx_pciercx_cfg448_t;
 /**
  * cvmx_pcierc#_cfg449
  *
- * This register contains the four hundred fiftieth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fiftieth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg449 {
@@ -7730,7 +7726,7 @@ typedef union cvmx_pciercx_cfg449 cvmx_pciercx_cfg449_t;
 /**
  * cvmx_pcierc#_cfg450
  *
- * This register contains the four hundred fifty-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg450 {
@@ -7900,7 +7896,7 @@ typedef union cvmx_pciercx_cfg450 cvmx_pciercx_cfg450_t;
 /**
  * cvmx_pcierc#_cfg451
  *
- * This register contains the four hundred fifty-second 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg451 {
@@ -8024,7 +8020,7 @@ typedef union cvmx_pciercx_cfg451 cvmx_pciercx_cfg451_t;
 /**
  * cvmx_pcierc#_cfg452
  *
- * This register contains the four hundred fifty-third 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg452 {
@@ -8297,7 +8293,7 @@ typedef union cvmx_pciercx_cfg452 cvmx_pciercx_cfg452_t;
 /**
  * cvmx_pcierc#_cfg453
  *
- * This register contains the four hundred fifty-fourth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-fourth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg453 {
@@ -8345,7 +8341,7 @@ typedef union cvmx_pciercx_cfg453 cvmx_pciercx_cfg453_t;
 /**
  * cvmx_pcierc#_cfg454
  *
- * This register contains the four hundred fifty-fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg454 {
@@ -8463,7 +8459,7 @@ union cvmx_pciercx_cfg454 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
-                                                         and has moved to the queue status register -- PCIEEP*_CFG463. This field remains to
+                                                         and has moved to the queue status register -- PCIEEP()_CFG463. This field remains to
                                                          prevent software from breaking. */
 	uint32_t tmanlt                       : 5;  /**< Timer modifier for Ack/Nak latency timer. Increases the timer value for the Ack/Nak
                                                          latency timer, in increments of 64 clock cycles. */
@@ -8487,7 +8483,7 @@ typedef union cvmx_pciercx_cfg454 cvmx_pciercx_cfg454_t;
 /**
  * cvmx_pcierc#_cfg455
  *
- * This register contains the four hundred fifty-sixth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-sixth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg455 {
@@ -8556,7 +8552,7 @@ typedef union cvmx_pciercx_cfg455 cvmx_pciercx_cfg455_t;
 /**
  * cvmx_pcierc#_cfg456
  *
- * This register contains the four hundred fifty-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg456 {
@@ -8606,7 +8602,7 @@ typedef union cvmx_pciercx_cfg456 cvmx_pciercx_cfg456_t;
 /**
  * cvmx_pcierc#_cfg458
  *
- * This register contains the four hundred fifty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred fifty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg458 {
@@ -8638,7 +8634,7 @@ typedef union cvmx_pciercx_cfg458 cvmx_pciercx_cfg458_t;
 /**
  * cvmx_pcierc#_cfg459
  *
- * This register contains the four hundred sixtieth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixtieth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg459 {
@@ -8670,7 +8666,7 @@ typedef union cvmx_pciercx_cfg459 cvmx_pciercx_cfg459_t;
 /**
  * cvmx_pcierc#_cfg460
  *
- * This register contains the four hundred sixty-first 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-first 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg460 {
@@ -8710,7 +8706,7 @@ typedef union cvmx_pciercx_cfg460 cvmx_pciercx_cfg460_t;
 /**
  * cvmx_pcierc#_cfg461
  *
- * This register contains the four hundred sixty-second 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-second 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg461 {
@@ -8750,7 +8746,7 @@ typedef union cvmx_pciercx_cfg461 cvmx_pciercx_cfg461_t;
 /**
  * cvmx_pcierc#_cfg462
  *
- * This register contains the four hundred sixty-third 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-third 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg462 {
@@ -8790,7 +8786,7 @@ typedef union cvmx_pciercx_cfg462 cvmx_pciercx_cfg462_t;
 /**
  * cvmx_pcierc#_cfg463
  *
- * This register contains the four hundred sixty-fourth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-fourth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg463 {
@@ -8798,10 +8794,10 @@ union cvmx_pciercx_cfg463 {
 	struct cvmx_pciercx_cfg463_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t fcltoe                       : 1;  /**< FC latency timer override enable. When this bit is set, the value in
-                                                         PCIERC(0..3)_CFG453[FCLTOV] will override the FC latency timer value that the core
+                                                         PCIERC()_CFG453[FCLTOV] will override the FC latency timer value that the core
                                                          calculates according to the PCIe specification. */
 	uint32_t reserved_29_30               : 2;
-	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIERC(0..3)_CFG453[FCLTOE], the value in
+	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIERC()_CFG453[FCLTOE], the value in
                                                          this field will override the FC latency timer value that the core calculates according to
                                                          the PCIe specification. */
 	uint32_t reserved_3_15                : 13;
@@ -8862,7 +8858,7 @@ typedef union cvmx_pciercx_cfg463 cvmx_pciercx_cfg463_t;
 /**
  * cvmx_pcierc#_cfg464
  *
- * This register contains the four hundred sixty-fifth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-fifth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg464 {
@@ -8938,7 +8934,7 @@ typedef union cvmx_pciercx_cfg465 cvmx_pciercx_cfg465_t;
 /**
  * cvmx_pcierc#_cfg466
  *
- * This register contains the four hundred sixty-seventh 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-seventh 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg466 {
@@ -9012,7 +9008,7 @@ typedef union cvmx_pciercx_cfg466 cvmx_pciercx_cfg466_t;
 /**
  * cvmx_pcierc#_cfg467
  *
- * This register contains the four hundred sixty-eighth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-eighth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg467 {
@@ -9068,7 +9064,7 @@ typedef union cvmx_pciercx_cfg467 cvmx_pciercx_cfg467_t;
 /**
  * cvmx_pcierc#_cfg468
  *
- * This register contains the four hundred sixty-ninth 32-bits of type 1 PCIe configuration space.
+ * This register contains the four hundred sixty-ninth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg468 {
@@ -9259,7 +9255,7 @@ typedef union cvmx_pciercx_cfg492 cvmx_pciercx_cfg492_t;
 /**
  * cvmx_pcierc#_cfg515
  *
- * This register contains the five hundred sixteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the five hundred sixteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg515 {
@@ -9319,7 +9315,7 @@ typedef union cvmx_pciercx_cfg515 cvmx_pciercx_cfg515_t;
 /**
  * cvmx_pcierc#_cfg516
  *
- * This register contains the five hundred seventeenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the five hundred seventeenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg516 {
@@ -9351,7 +9347,7 @@ typedef union cvmx_pciercx_cfg516 cvmx_pciercx_cfg516_t;
 /**
  * cvmx_pcierc#_cfg517
  *
- * This register contains the five hundred eighteenth 32-bits of type 1 PCIe configuration space.
+ * This register contains the five hundred eighteenth 32-bits of PCIe type 1 configuration space.
  *
  */
 union cvmx_pciercx_cfg517 {
@@ -9437,21 +9433,21 @@ union cvmx_pciercx_cfg554 {
                                                          performed in the EQ Master, when finding the highest FOM among all preset evaluations. */
 	uint32_t prv                          : 16; /**< Preset request vector. Requesting of presets during the initial part of the EQ master
                                                          phase. Encoding scheme as follows:
-                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase
-                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase
-                                                         - 0000000000000000: No preset req/evaluated in EQ master phase
-                                                         00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
-                                                         00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
-                                                         00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
-                                                         00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
-                                                         00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
-                                                         00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
-                                                         00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
-                                                         00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
-                                                         00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
-                                                         00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
-                                                         000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
-                                                         All other encodings: Reserved */
+                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
+                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
+                                                         _ 0000000000000000: No preset req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
+                                                         _ 00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
+                                                         _ 00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
+                                                         _ 00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
+                                                         _ 00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
+                                                         _ 00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
+                                                         _ 00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
+                                                         _ 000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
+                                                         _ All other encodings: Reserved */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
                                                          the PHY does not respond within 2 ms to the assertion of RxEqEval:
@@ -9460,15 +9456,15 @@ union cvmx_pciercx_cfg554 {
                                                          1 = Ignore the 2 ms timeout and continue as normal. This is used to support PHYs that
                                                          require more than 2 ms to respond to the assertion of RxEqEval. */
 	uint32_t bt                           : 1;  /**< Behavior after 24 ms timeout (when optimal settings are not found).
-                                                         FOR a USP: determine the next LTSSM state from Phase2
-                                                         0 = Recovery.Speed
-                                                         1 = Recovry.Equalization.Phase3
-                                                         FOR a DSP: determine the next LTSSM state from Phase3
-                                                         0 = Recovery.Speed
-                                                         1 = Recovry.Equalization.RcrLock
+                                                         For a USP: determine the next LTSSM state from Phase2:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.Phase3.
+                                                         For a DSP: determine the next LTSSM state from Phase3:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.RcrLock.
                                                          When optimal settings are not found:
-                                                         * Equalization Phase 3 Successful status bit is not set in the link Status Register
-                                                         * Equalization Phase 3 Complete status bit is set in the link Status Register */
+                                                         * Equalization phase 3 successful status bit is not set in the Link Status Register
+                                                         * Equalization phase 3 complete status bit is set in the Link Status Register */
 	uint32_t fm                           : 4;  /**< Feedback mode.
                                                          0 = Direction of change (not supported).
                                                          1 = Figure of merit.
@@ -9497,7 +9493,7 @@ union cvmx_pciercx_cfg558 {
 	uint32_t u32;
 	struct cvmx_pciercx_cfg558_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t ple                          : 1;  /**< Pipe loopback enable */
+	uint32_t ple                          : 1;  /**< Pipe loopback enable. */
 	uint32_t rxstatus                     : 31; /**< Reserved. */
 #else
 	uint32_t rxstatus                     : 31;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index dddb27a..261fcc3 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -706,6 +706,132 @@ static inline void cvmx_pki_enable_backpressure(int node)
 
 
 /**
+ * Get the statistics counters for a port.
+ *
+ * @param node	   node number
+ * @param port_num Port number (ipd_port) to get statistics for.
+ *		   Make sure PKI_STATS_CTL:mode is set to 0 for
+ *		   collecting per port/pkind stats.
+ *
+ */
+static inline void cvmx_pki_clear_port_stats(int node, uint64_t port)
+{
+	int interface = cvmx_helper_get_interface_num(port);
+	int index = cvmx_helper_get_interface_index_num(port);
+	int pknd = cvmx_helper_get_pknd(interface, index);
+
+	cvmx_pki_statx_stat0_t stat0;
+	cvmx_pki_statx_stat1_t stat1;
+	cvmx_pki_statx_stat2_t stat2;
+	cvmx_pki_statx_stat3_t stat3;
+	cvmx_pki_statx_stat4_t stat4;
+	cvmx_pki_statx_stat5_t stat5;
+	cvmx_pki_statx_stat6_t stat6;
+	cvmx_pki_statx_stat7_t stat7;
+	cvmx_pki_statx_stat8_t stat8;
+	cvmx_pki_statx_stat9_t stat9;
+	cvmx_pki_statx_stat10_t stat10;
+	cvmx_pki_statx_stat11_t stat11;
+	cvmx_pki_statx_stat14_t stat14;
+	cvmx_pki_statx_stat15_t stat15;
+	cvmx_pki_statx_stat16_t stat16;
+	cvmx_pki_statx_stat17_t stat17;
+	cvmx_pki_statx_hist0_t hist0;
+	cvmx_pki_statx_hist1_t hist1;
+	cvmx_pki_statx_hist2_t hist2;
+	cvmx_pki_statx_hist3_t hist3;
+	cvmx_pki_statx_hist4_t hist4;
+	cvmx_pki_statx_hist5_t hist5;
+	cvmx_pki_statx_hist6_t hist6;
+	cvmx_pki_pkndx_inb_stat0_t pki_pknd_inb_stat0;
+	cvmx_pki_pkndx_inb_stat1_t pki_pknd_inb_stat1;
+	cvmx_pki_pkndx_inb_stat2_t pki_pknd_inb_stat2;
+
+	stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT0(pknd));
+	stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT1(pknd));
+	stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT2(pknd));
+	stat3.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT3(pknd));
+	stat4.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT4(pknd));
+	stat5.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT5(pknd));
+	stat6.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT6(pknd));
+	stat7.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT7(pknd));
+	stat8.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT8(pknd));
+	stat9.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT9(pknd));
+	stat10.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT10(pknd));
+	stat11.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT11(pknd));
+	stat14.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT14(pknd));
+	stat15.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT15(pknd));
+	stat16.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT16(pknd));
+	stat17.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT17(pknd));
+	hist0.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST0(pknd));
+	hist1.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST1(pknd));
+	hist2.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST2(pknd));
+	hist3.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST3(pknd));
+	hist4.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST4(pknd));
+	hist5.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST5(pknd));
+	hist6.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST6(pknd));
+	pki_pknd_inb_stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd));
+	pki_pknd_inb_stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd));
+	pki_pknd_inb_stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd));
+
+	stat4.s.drp_octs = 0;
+	stat3.s.drp_pkts = 0;
+	stat1.s.octs = 0;
+	stat2.s.raw = 0;
+	stat0.s.pkts = 0;
+	stat6.s.mcast = 0;
+	stat5.s.bcast = 0;
+	hist0.s.h1to63 = 0;
+	hist1.s.h64to127 = 0;
+	hist2.s.h128to255 = 0;
+	hist3.s.h256to511 = 0;
+	hist4.s.h512to1023 = 0;
+	hist5.s.h1024to1518 = 0;
+	hist6.s.h1519 = 0;
+	stat7.s.fcs = 0;
+	stat9.s.undersz = 0;
+	stat8.s.frag = 0;
+	stat11.s.oversz = 0;
+	stat10.s.jabber = 0;
+	stat15.s.drp_mcast = 0;
+	stat14.s.drp_bcast = 0;
+	stat17.s.drp_mcast = 0;
+	stat16.s.drp_bcast = 0;
+	pki_pknd_inb_stat0.s.pkts = 0;
+	pki_pknd_inb_stat1.s.octs = 0;
+	pki_pknd_inb_stat2.s.errs = 0;
+
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT0(pknd), stat0.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT1(pknd), stat1.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT2(pknd), stat2.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT3(pknd), stat3.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT4(pknd), stat4.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT5(pknd), stat5.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT6(pknd), stat6.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT7(pknd), stat7.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT8(pknd), stat8.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT9(pknd), stat9.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT10(pknd), stat10.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT11(pknd), stat11.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT14(pknd), stat14.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT15(pknd), stat15.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT16(pknd), stat16.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT17(pknd), stat17.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST0(pknd), hist0.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST1(pknd), hist1.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST2(pknd), hist2.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST3(pknd), hist3.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST4(pknd), hist4.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST5(pknd), hist5.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST6(pknd), hist6.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd), pki_pknd_inb_stat0.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd), pki_pknd_inb_stat1.u64);
+        cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd), pki_pknd_inb_stat2.u64);
+
+}
+      
+
+/**
  * Get the status counters for index from PKI.
  *
  * @param node	   node number
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index 24b4477..c9ad04f 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -2576,7 +2576,12 @@ static inline void cvmx_sso_set_group_priority(int node, cvmx_xgrp_t xgrp,
 		return;
 	}
 
+	if (weight <= 0)
+		weight = 0x3f;	/* Force HW default when out of range */
+
 	grp_pri.u64 = cvmx_read_csr_node(node, CVMX_SSO_GRPX_PRI(xgrp.xgrp));
+	if(grp_pri.s.weight == 0)
+		grp_pri.s.weight = 0x3f;
 	if(modify_mask & CVMX_SSO_MODIFY_GROUP_PRIORITY)
 		grp_pri.s.pri = priority;
 	if(modify_mask & CVMX_SSO_MODIFY_GROUP_WEIGHT)
-- 
1.9.1

