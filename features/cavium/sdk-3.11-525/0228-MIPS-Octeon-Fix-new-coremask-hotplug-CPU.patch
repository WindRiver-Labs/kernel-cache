From 1223ed34452e9215de09e1e2d8c0332220c2d774 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Wed, 28 Aug 2013 11:17:42 -0700
Subject: [PATCH 228/518] MIPS: Octeon: Fix new coremask, hotplug CPU

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 1e9cfb8947d20c05d28d455bf5386528b9c7a7e4
Description:

Update HOTPLUG_CPU code to handle new cvmx_coremask_t structures,
make the allocation of global hotplug memory atomic,
fix atomic modification of available_coremask.
Validate hot-plugging CPUs passed between Linux and SE app.

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |  12 --
 arch/mips/cavium-octeon/smp.c   | 320 +++++++++++++++++++++++++++-------------
 2 files changed, 215 insertions(+), 117 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 08de2ec..aefb7de 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -164,13 +164,6 @@ static int octeon_uart;
 extern asmlinkage void handle_int(void);
 extern asmlinkage void plat_irq_dispatch(void);
 
-/*
- * If set to a non-zero value, the bootloader entry point for
- * HOTPLUG_CPU and other tricks.
- */
-u64 octeon_bootloader_entry_addr;
-EXPORT_SYMBOL(octeon_bootloader_entry_addr);
-
 /* If an initrd named block is specified, its name goes here. */
 static char __initdata rd_name[64];
 
@@ -565,7 +558,6 @@ void __init prom_init(void)
 	struct cvmx_sysinfo *sysinfo;
 	const char *arg;
 	char *p;
-	struct linux_app_boot_info *labi;
 	int i;
 	u64 t;
 	int argc;
@@ -820,10 +812,6 @@ append_arg:
 	octeon_user_io_init();
 	octeon_setup_smp();
 
-	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-	if (labi->labi_signature == LABI_SIGNATURE)
-		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
-
 #ifdef CONFIG_CAVIUM_GDB
 	cvmx_debug_init ();
 #endif
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index cfb1a25..a47e9a6 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004 - 2012 Cavium, Inc.
+ * Copyright (C) 2004 - 2013 Cavium, Inc.
  */
 #include <linux/cpu.h>
 #include <linux/init.h>
@@ -21,6 +21,7 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/octeon-boot-info.h>
 #include <asm/octeon/cvmx-app-hotplug.h>
+#include <asm/octeon/cvmx-spinlock.h>
 
 volatile unsigned long octeon_processor_boot = 0xff;
 volatile unsigned long octeon_processor_sp;
@@ -28,9 +29,14 @@ volatile unsigned long octeon_processor_gp;
 
 #ifdef CONFIG_HOTPLUG_CPU
 static uint32_t octeon_hotplug_entry_addr;
-extern void octeon_hotplug_entry(void);
+extern asmlinkage void octeon_hotplug_entry(void);
+static struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
 #endif
-struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
+
+uint64_t octeon_bootloader_entry_addr;
+EXPORT_SYMBOL(octeon_bootloader_entry_addr);
+
+static unsigned long long boot_core_mask;
 
 static void octeon_icache_flush(void)
 {
@@ -149,16 +155,57 @@ static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 		octeon_send_ipi_single(cpu, action);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+
+#ifndef	CVMX_HOTPLUG_MAGIC_VERSION
+#define CVMX_HOTPLUG_MAGIC_VERSION      0x1abe1000UL
+#endif
+
+/*
+ * Initialize the content of struct * cvmx_app_hotplug_global
+ * if it is allocated, atomically.
+ */
+static void octeon_hotplug_global_init(void *arg)
+{
+	struct linux_app_boot_info *labi;
+	cvmx_app_hotplug_global_t *hgp = arg;
+	memset(hgp, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
+
+	hgp->version = CVMX_HOTPLUG_MAGIC_VERSION;
+
+	/* Get legacy LABI data structure for initial parameters */
+	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
+
+	/* Valicate signature */
+	if (labi->labi_signature != LABI_SIGNATURE)
+		return;
+
+	/* Initialize available cores from LABI */
+	cvmx_coremask_set64(&hgp->avail_coremask,
+		(uint64_t) labi->avail_coremask);
+}
+#endif
+
 static void octeon_smp_setup(void)
 {
 	const int coreid = cvmx_get_core_num();
 	int cpus;
 	int id;
-	int core_mask = octeon_get_boot_coremask();
+	struct linux_app_boot_info *labi;
 #ifdef CONFIG_HOTPLUG_CPU
 	unsigned int num_cores = cvmx_octeon_num_cores();
+	struct cvmx_app_hotplug_global *hgp;
+	char hexstr[CVMX_MIPS_MAX_CORES/4+1];
+	unsigned long t;
 #endif
-	struct linux_app_boot_info *labi;
+
+	boot_core_mask = octeon_get_boot_coremask();
+
+	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
+
+	if (labi->labi_signature == LABI_SIGNATURE) {
+		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
+	}
 
 	/* The present CPUs are initially just the boot cpu (CPU 0). */
 	for (id = 0; id < NR_CPUS; id++) {
@@ -172,7 +219,7 @@ static void octeon_smp_setup(void)
 	/* The present CPUs get the lowest CPU numbers. */
 	cpus = 1;
 	for (id = 0; id < NR_CPUS; id++) {
-		if ((id != coreid) && (core_mask & (1 << id))) {
+		if ((id != coreid) && (boot_core_mask & (1 << id))) {
 			set_cpu_possible(cpus, true);
 			set_cpu_present(cpus, true);
 			__cpu_number_map[id] = cpus;
@@ -182,18 +229,10 @@ static void octeon_smp_setup(void)
 	}
 
 #ifdef CONFIG_HOTPLUG_CPU
+	t = __pa_symbol(octeon_hotplug_entry);
 
-	/*
-	 * HOTPLUG_CPU not possible if we don't know the bootloader
-	 * entrypoint.  Stop now before lulling people into thinking
-	 * it might work.
-	 */
-	if (!octeon_bootloader_entry_addr) {
-		if ((octeon_bootinfo->core_mask & 1) == 0)
-			panic("Linux not booted on core 0 with HOTPLUG_CPU");
-		else
-			panic("The bootloader version on this board is not compatible with HOTPLUG_CPU.");
-	}
+	if (t < 0x20000000)
+		octeon_hotplug_entry_addr = (uint32_t)CKSEG0ADDR(t);
 
 	/*
 	 * The possible CPUs are all those present on the chip.	 We
@@ -201,30 +240,36 @@ static void octeon_smp_setup(void)
 	 * are always consecutively numberd from 0.
 	 */
 	for (id = 0; id < num_cores && id < NR_CPUS; id++) {
-		if (!(core_mask & (1 << id))) {
+		if (!(boot_core_mask & (1 << id))) {
 			set_cpu_possible(cpus, true);
 			__cpu_number_map[id] = cpus;
 			__cpu_logical_map[cpus] = id;
 			cpus++;
 		}
 	}
-#endif
-	octeon_hotplug_global_ptr =
-		(struct cvmx_app_hotplug_global *) cvmx_bootmem_alloc_named_range(
-			CVMX_APP_HOTPLUG_INFO_REGION_SIZE, 0x0, 0x0, 0,
-			CVMX_APP_HOTPLUG_INFO_REGION_NAME);
-	if (!octeon_hotplug_global_ptr) {
+
+	/* Atomically allocate Hotplug global structure */
+	hgp = (struct cvmx_app_hotplug_global *)
+		cvmx_bootmem_alloc_named_range_once(
+			CVMX_APP_HOTPLUG_INFO_REGION_SIZE,
+			0x0, 0x0, 0,
+			CVMX_APP_HOTPLUG_INFO_REGION_NAME,
+			octeon_hotplug_global_init
+		);
+	if (!hgp) {
 		pr_err("Failed to allocate memory for Hotplug memory block\n");
+		octeon_hotplug_entry_addr = 0;
 		return;
 	}
-	memset(octeon_hotplug_global_ptr, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
 
-	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-#if 0
-	octeon_hotplug_global_ptr->avail_coremask = labi->avail_coremask;
+	/* Convert coremask to string for printing */
+	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
+
+	/* Print the available coremask on to the console */
+	pr_info("Cavium Hotplug: Available coremask 0x%s\n", hexstr);
 
-	pr_info("Cavium Hotplug: Available coremask 0x%x\n",
-		octeon_hotplug_global_ptr->avail_coremask);
+	/* Set global ptr for use by other functions */
+	octeon_hotplug_global_ptr = hgp;
 #endif
 }
 
@@ -279,22 +324,8 @@ static void __cpuinit octeon_init_secondary(void)
 void octeon_prepare_cpus(unsigned int max_cpus)
 {
 	u64 mask;
-#ifdef CONFIG_HOTPLUG_CPU
-	unsigned long t;
-	struct linux_app_boot_info *labi;
-
-	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-
-	if (labi->labi_signature != LABI_SIGNATURE)
-		panic("The bootloader version on this board is incorrect.");
-
-	t = __pa_symbol(octeon_hotplug_entry);
+	u64 coreid;
 
-	if (t >= 0x20000000)
-		panic("The kernel physical load address (%lx) is not compatible with CONFIG_HOTPLUG_CPU.\n", t);
-
-	octeon_hotplug_entry_addr = (uint32_t)CKSEG0ADDR(t);
-#endif
 	/*
 	 * Only the low order mailbox bits are used for IPIs, leave
 	 * the other bits alone.
@@ -303,7 +334,13 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 		mask = 0xff;
 	else
 		mask = 0xffff;
-	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(cvmx_get_core_num()), mask);
+
+	coreid = cvmx_get_core_num();
+
+	/* Clear pending mailbox interrupts */
+	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(coreid), mask);
+
+	/* Attach mailbox interrupt handler */
 	if (request_irq(OCTEON_IRQ_MBOX0, mailbox_interrupt,
 			IRQF_PERCPU | IRQF_NO_THREAD, "SMP-IPI",
 			mailbox_interrupt)) {
@@ -329,6 +366,31 @@ static void octeon_smp_finish(void)
  */
 static void octeon_cpus_done(void)
 {
+#ifdef CONFIG_HOTPLUG_CPU
+	struct cvmx_app_hotplug_global *hgp;
+	char hexstr[CVMX_MIPS_MAX_CORES/4+1];
+	unsigned int cpu;
+
+	hgp = octeon_hotplug_global_ptr;
+
+	/* Boot core_mask not needed any longer */
+	boot_core_mask = 0;
+
+	/* Boot core_mask CPUs are now all on-line,
+	 * make the rest of the CPUs available for HOTPLUG
+	 * regardless if they are presently available
+	 */
+	for_each_possible_cpu(cpu) {
+		if (!cpu_online(cpu))
+			set_cpu_present(cpu, true);
+	}
+
+	/* Convert coremask to string for printing */
+	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
+
+	/* Print the available coremask on to the console */
+	pr_info("Cavium Hotplug: Available coremask 0x%s\n", hexstr);
+#endif
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -338,6 +400,40 @@ DEFINE_PER_CPU(int, cpu_state);
 
 extern void fixup_irqs(void);
 
+/*
+ * Convert coremask to a printable hex string
+ * Same function by name and purpose is also found in cvmx-coremask.c
+ * but with a different implementation.
+ */
+int cvmx_coremask_bmp2str(const cvmx_coremask_t *pcm, char *hexstr)
+{
+	int core;
+	char *p;
+	unsigned int i, n;
+	unsigned int num_cores = cvmx_octeon_num_cores();
+	static const char hextab[16] = {
+		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+		'a', 'b', 'c', 'd', 'e', 'f'};
+
+	p = hexstr;
+	n = 1 + (num_cores >> 2);
+
+	for (i = 0; i <= n; i++)
+		p[i] = '\0';
+
+	for (core = num_cores - 1; core >= 0; core--) {
+		if (cvmx_coremask_is_core_set(pcm, core))
+			p[n - (core>>2)] |= 1 << (core & 3);
+	}
+
+	for (i = 0; i <= n; i++)
+		p[i] = hextab[p[i] & 0xf];
+
+	p[i] = '\0';
+
+	return n+1;
+}
+
 static int octeon_cpu_disable(void)
 {
 	unsigned int cpu = smp_processor_id();
@@ -357,42 +453,29 @@ static int octeon_cpu_disable(void)
 static void octeon_cpu_die(unsigned int cpu)
 {
 	int coreid = cpu_logical_map(cpu);
-	uint32_t new_mask ;	/* FIXME: extend beyond 32 cores */
-	const struct cvmx_bootmem_named_block_desc *block_desc;
+	int node;
+	struct cvmx_app_hotplug_global *hgp = octeon_hotplug_global_ptr;
+	char hexstr[CVMX_MIPS_MAX_CORES/4+3];
+
+	BUG_ON(!hgp);
 
 	while (per_cpu(cpu_state, cpu) != CPU_DEAD)
 		cpu_relax();
 
-	/*
-	 * This is a bit complicated strategics of getting/settig available
-	 * cores mask, copied from bootloader
-	 */
-	cvmx_coremask_set_core( 
-		&octeon_hotplug_global_ptr->avail_coremask,
-		coreid );
-
-	/* LINUX_APP_BOOT_BLOCK is initialized in bootoct binary */
-	block_desc = cvmx_bootmem_find_named_block(LINUX_APP_BOOT_BLOCK_NAME);
-
-	if (!block_desc) {
-		struct linux_app_boot_info *labi;
-
-		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-
-		labi->avail_coremask |= (1 << coreid);
-		new_mask = labi->avail_coremask;
-	} else {		       /* alternative, already initialized */
-		new_mask  = cvmx_coremask_get32( 
-				&octeon_hotplug_global_ptr->avail_coremask);
-	}
+	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
+	cvmx_coremask_set_core(&hgp->avail_coremask, coreid);
+	cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
 
 	mb();
 
-	/* FIXME: will only show up to 32 cores */
-	pr_info("Reset core %d. Available Coremask = 0x%x\n",
-		coreid, new_mask);
-	/* FIXME: handle cores over 31 */
-	cvmx_write_csr(CVMX_CIU_NMI, 1 << coreid);
+	/* Convert coremask to string for printing */
+	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
+	pr_info("Reset core %d. Available Coremask = 0x%s\n", coreid, hexstr);
+
+	/* Covert coreid to node/core spec and send NMI to target core */
+	node = cvmx_coremask_core_to_node(coreid);
+	coreid = cvmx_coremask_core_on_node(coreid);
+	cvmx_write_csr_node(node, CVMX_CIU_NMI, (1 << coreid));
 }
 
 void play_dead(void)
@@ -411,41 +494,54 @@ void play_dead(void)
 
 static int octeon_update_boot_vector(unsigned int cpu)
 {
-
 	int coreid = cpu_logical_map(cpu);
-	unsigned int avail_coremask;
-	const struct cvmx_bootmem_named_block_desc *block_desc;
-	struct boot_init_vector *boot_vect = phys_to_virt(BOOTLOADER_BOOT_VECTOR);
-
-	block_desc = cvmx_bootmem_find_named_block(LINUX_APP_BOOT_BLOCK_NAME);
-
-	if (!block_desc) {
-		struct linux_app_boot_info *labi;
-
-		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-
-		avail_coremask = labi->avail_coremask;
-		if (!(avail_coremask & (1<<coreid)))
-			return -1;
-		labi->avail_coremask &= ~(1 << coreid);
-	} else {		       /* alternative, already initialized */
-		if ( ! cvmx_coremask_is_core_set(
-			&octeon_hotplug_global_ptr->avail_coremask, coreid ))
-			return -1;
-		/* This core is no longer available */
-		cvmx_coremask_clear_core(
-			& octeon_hotplug_global_ptr->avail_coremask,
+	int node;
+	struct cvmx_app_hotplug_global *hgp = octeon_hotplug_global_ptr;
+	struct boot_init_vector *boot_vect =
+		phys_to_virt(BOOTLOADER_BOOT_VECTOR);
+
+	/* Verify that required entry points are known at this stage */
+	if (!hgp || !octeon_hotplug_entry_addr ||
+			!octeon_bootloader_entry_addr) {
+		pr_warn("Cavium Hotplog: boot-loader incompatible with Hotplog\n");
+		return -EINVAL;
+	}
+
+	/* Verify that coreid does not exceed the number of vector slots */
+	if (coreid >= CVMX_MAX_CORES) {
+		pr_warn("Cavium Hotplog: physical core %d is out of range\n",
 			coreid );
+		return -EINVAL;
+	}
+
+	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
+	/*
+	 * A core being brought up must be present either in the boot
+	 * core_mask or in the hotplug available coremask
+	 */
+	if (boot_core_mask & (1 << coreid)) {
+		boot_core_mask &= ~(1 << coreid);
+	} else if (!cvmx_coremask_is_core_set(&hgp->avail_coremask, coreid)) {
+		cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
+		pr_warn("Cavium Hotplog: cpu %u core %u is not available\n",
+			cpu, coreid);
+		return -EBUSY;
 	}
 
-	/* FIXME: extend beyond 32 cores */
+	/* This core is no longer available */
+	cvmx_coremask_clear_core(&hgp->avail_coremask, coreid);
+	cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
+
+	/* boot_vect array has CVMX_MAX_CORES slots */
 	boot_vect[coreid].app_start_func_addr = octeon_hotplug_entry_addr;
 	boot_vect[coreid].code_addr = octeon_bootloader_entry_addr;
 
 	mb();
 
-	/* FIXME: extend beyond 32 cores */
-	cvmx_write_csr(CVMX_CIU_NMI, (1 << coreid));
+	/* Convert coreid to node,core spair and send NMI to target core */
+	node = cvmx_coremask_core_to_node(coreid);
+	coreid = cvmx_coremask_core_on_node(coreid);
+	cvmx_write_csr_node(node, CVMX_CIU_NMI, (1 << coreid));
 
 	return 0;
 }
@@ -454,27 +550,41 @@ static int __cpuinit octeon_cpu_callback(struct notifier_block *nfb,
 	unsigned long action, void *hcpu)
 {
 	unsigned int cpu = (unsigned long)hcpu;
+	int ret;
 
 	switch (action) {
+	case CPU_UP_PREPARE_FROZEN:
 	case CPU_UP_PREPARE:
-		octeon_update_boot_vector(cpu);
+		ret = octeon_update_boot_vector(cpu);
+		if (ret)
+			return notifier_from_errno(ret);
 		break;
+	case CPU_ONLINE_FROZEN:
 	case CPU_ONLINE:
 		pr_info("Cpu %d online\n", cpu);
 		break;
+	case CPU_DEAD_FROZEN:
 	case CPU_DEAD:
+		pr_info("Cpu %d offline\n", cpu);
+		break;
+	default:
+		/* No action required for other events */
 		break;
 	}
 
 	return NOTIFY_OK;
 }
 
+static struct notifier_block __cpuinitdata octeon_cpu_notifer = {
+	.notifier_call = octeon_cpu_callback,
+};
+
 static int __cpuinit register_cavium_notifier(void)
 {
-	hotcpu_notifier(octeon_cpu_callback, 0);
-	return 0;
+	return register_cpu_notifier(&octeon_cpu_notifer);
 }
-late_initcall(register_cavium_notifier);
+
+early_initcall(register_cavium_notifier);
 
 #endif	/* CONFIG_HOTPLUG_CPU */
 
-- 
1.9.1

