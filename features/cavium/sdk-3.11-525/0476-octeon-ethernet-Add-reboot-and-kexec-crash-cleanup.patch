From 4dc2a10caebd28954a347e0a95267a84c6695071 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Fri, 16 May 2014 11:52:27 -0500
Subject: [PATCH 476/518] octeon-ethernet: Add reboot and kexec crash cleanup

Source: Cavium Networks, Inc
MR: 9761
Type: Defect Fix
Disposition: Submitted to Cavium Octeon team
ChangeID: 83cc42fefa6991a0fc201ec70dfa6afffe58109f
Description:

The Octeon ethernet driver holds on to global resources that
need to be freed so a newly kexec-ed kernel can then allocate and
use them.  So add a reboot and kexec crash notifier to free the
resources.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-rx.c     | 45 +++++++++-------
 drivers/net/ethernet/octeon/ethernet.c        | 74 +++++++++++++++++++++------
 drivers/net/ethernet/octeon/octeon-ethernet.h |  4 +-
 3 files changed, 87 insertions(+), 36 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-rx.c b/drivers/net/ethernet/octeon/ethernet-rx.c
index 45eeab0..584359f 100644
--- a/drivers/net/ethernet/octeon/ethernet-rx.c
+++ b/drivers/net/ethernet/octeon/ethernet-rx.c
@@ -488,7 +488,7 @@ err:
 	return;
 }
 
-void cvm_oct_rx_shutdown0(void)
+void cvm_oct_rx_shutdown0(bool in_crash)
 {
 	int i;
 
@@ -498,19 +498,21 @@ void cvm_oct_rx_shutdown0(void)
 	else
 		cvmx_write_csr(CVMX_POW_WQ_INT_THRX(pow_receive_group), 0);
 
-	/* Free the interrupt handler */
-	free_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group, &cvm_oct_list);
+	if (!in_crash) {
+		/* Free the interrupt handler */
+		free_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group, &cvm_oct_list);
 
 #ifdef CONFIG_SMP
-	octeon_release_ipi_handler(cvm_oct_enable_one_message);
+		octeon_release_ipi_handler(cvm_oct_enable_one_message);
 #endif
 
-	/* Shutdown all of the NAPIs */
-	for_each_possible_cpu(i)
-		netif_napi_del(&cvm_oct_napi[i].napi);
+		/* Shutdown all of the NAPIs */
+		for_each_possible_cpu(i)
+			netif_napi_del(&cvm_oct_napi[i].napi);
+	}
 }
 
-void cvm_oct_rx_shutdown1(void)
+void cvm_oct_rx_shutdown1(bool in_crash)
 {
 	union cvmx_fpa_quex_available queue_available;
 	union cvmx_sso_cfg sso_cfg;
@@ -561,16 +563,18 @@ void cvm_oct_rx_shutdown1(void)
 	sso_cfg.s.rwq_byp_dis = 0;
 	cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
 
-	for (i = 0; i < 8; i++) {
-		union cvmx_sso_rwq_head_ptrx head_ptr;
-		union cvmx_sso_rwq_tail_ptrx tail_ptr;
+	if (!in_crash) {
+		for (i = 0; i < 8; i++) {
+			union cvmx_sso_rwq_head_ptrx head_ptr;
+			union cvmx_sso_rwq_tail_ptrx tail_ptr;
 
-		head_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_HEAD_PTRX(i));
-		tail_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_TAIL_PTRX(i));
-		WARN_ON(head_ptr.s.ptr != tail_ptr.s.ptr);
+			head_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_HEAD_PTRX(i));
+			tail_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_TAIL_PTRX(i));
+			WARN_ON(head_ptr.s.ptr != tail_ptr.s.ptr);
 
-		mem = phys_to_virt(((u64)head_ptr.s.ptr) << 7);
-		kmem_cache_free(cvm_oct_kmem_sso, mem);
+			mem = phys_to_virt(((u64)head_ptr.s.ptr) << 7);
+			kmem_cache_free(cvm_oct_kmem_sso, mem);
+		}
 	}
 
 	count = 0;
@@ -580,7 +584,8 @@ void cvm_oct_rx_shutdown1(void)
 			pop_fptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_POP_FPTR);
 			if (pop_fptr.s.val) {
 				mem = phys_to_virt(((u64)pop_fptr.s.fptr) << 7);
-				kmem_cache_free(cvm_oct_kmem_sso, mem);
+				if (!in_crash)
+					kmem_cache_free(cvm_oct_kmem_sso, mem);
 				count++;
 			}
 		} while (pop_fptr.s.val);
@@ -592,8 +597,10 @@ void cvm_oct_rx_shutdown1(void)
 	sso_cfg.s.rwen = 0;
 	sso_cfg.s.rwq_byp_dis = 0;
 	cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
-	kmem_cache_destroy(cvm_oct_kmem_sso);
-	cvm_oct_kmem_sso = NULL;
+	if (!in_crash) {
+		kmem_cache_destroy(cvm_oct_kmem_sso);
+		cvm_oct_kmem_sso = NULL;
+	}
 
 	/* Clear any FPE indicators, and reenable. */
 	cvmx_write_csr(CVMX_SSO_ERR, 1ull << sso_fpe_bit);
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 69da1dc..514142f 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -32,6 +32,8 @@
 #include <linux/slab.h>
 #include <linux/of_net.h>
 #include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/kexec.h>
 
 #include <net/dst.h>
 
@@ -267,6 +269,55 @@ static void cvm_oct_set_pko_multiqueue(void)
 	}
 }
 
+static int num_devices_extra_wqe;
+#define PER_DEVICE_EXTRA_WQE (MAX_OUT_QUEUE_DEPTH)
+
+static void cleanup_fpa_pools(void)
+{
+	/* Free the HW pools */
+	cvm_oct_mem_empty_fpa(packet_pool, num_packet_buffers);
+	cvm_oct_release_fpa_pool(packet_pool);
+
+	cvm_oct_mem_empty_fpa(wqe_pool,
+			      num_packet_buffers + num_devices_extra_wqe * PER_DEVICE_EXTRA_WQE);
+	cvm_oct_release_fpa_pool(wqe_pool);
+
+	cvm_oct_mem_empty_fpa(output_pool,
+				cvm_oct_num_output_buffers);
+	cvm_oct_release_fpa_pool(output_pool);
+}
+
+static int cvm_reboot_handler(struct notifier_block *nb,
+			      unsigned long action, void *data)
+{
+	/*
+	 * Clean things up to a point where a new kernel can take over.
+	 */
+	mdelay(10);
+	cvmx_ipd_disable();
+	mdelay(10);
+	cvm_oct_rx_shutdown0(true);
+	cvmx_helper_shutdown_packet_io_global();
+	cvm_oct_rx_shutdown1(true);
+	cleanup_fpa_pools();
+	cvmx_pko_queue_free_all();
+	cvmx_pko_internal_ports_range_free_all();
+	__cvmx_export_app_config_cleanup();
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cvm_reboot_notify = {
+	.notifier_call = cvm_reboot_handler,
+	.next = NULL,
+	.priority = 0
+};
+
+static struct notifier_block cvm_kexec_crash_notify = {
+	.notifier_call = cvm_reboot_handler,
+	.next = NULL,
+	.priority = 0
+};
+
 static int cvm_oct_configure_common_hw(void)
 {
 	/* Setup the FPA */
@@ -337,6 +388,9 @@ static int cvm_oct_configure_common_hw(void)
 		cvmx_helper_setup_red(num_packet_buffers / 4,
 				      num_packet_buffers / 8);
 
+	register_reboot_notifier(&cvm_reboot_notify);
+	register_kexec_crash_notifier(&cvm_kexec_crash_notify);
+
 	return 0;
 }
 
@@ -683,9 +737,6 @@ static const struct net_device_ops cvm_oct_srio_netdev_ops = {
 
 extern void octeon_mdiobus_force_mod_depencency(void);
 
-static int num_devices_extra_wqe;
-#define PER_DEVICE_EXTRA_WQE (MAX_OUT_QUEUE_DEPTH)
-
 static struct rb_root cvm_oct_ipd_tree = RB_ROOT;
 
 void cvm_oct_add_ipd_port(struct octeon_ethernet *port)
@@ -1095,7 +1146,7 @@ static int cvm_oct_remove(struct platform_device *pdev)
 	atomic_inc_return(&cvm_oct_poll_queue_stopping);
 	cancel_delayed_work_sync(&cvm_oct_rx_refill_work);
 
-	cvm_oct_rx_shutdown0();
+	cvm_oct_rx_shutdown0(false);
 
 	/* unregister the ethernet devices */
 	list_for_each_entry(priv, &cvm_oct_list, list) {
@@ -1113,21 +1164,14 @@ static int cvm_oct_remove(struct platform_device *pdev)
 
 	cvmx_helper_shutdown_packet_io_global();
 
-	cvm_oct_rx_shutdown1();
+	cvm_oct_rx_shutdown1(false);
 
 	destroy_workqueue(cvm_oct_poll_queue);
 
-	/* Free the HW pools */
-	cvm_oct_mem_empty_fpa(packet_pool, num_packet_buffers);
-	cvm_oct_release_fpa_pool(packet_pool);
+	unregister_kexec_crash_notifier(&cvm_kexec_crash_notify);
+	unregister_reboot_notifier(&cvm_reboot_notify);
 
-	cvm_oct_mem_empty_fpa(wqe_pool,
-			      num_packet_buffers + num_devices_extra_wqe * PER_DEVICE_EXTRA_WQE);
-	cvm_oct_release_fpa_pool(wqe_pool);
-
-	cvm_oct_mem_empty_fpa(output_pool,
-				cvm_oct_num_output_buffers);
-	cvm_oct_release_fpa_pool(output_pool);
+	cleanup_fpa_pools();
 
 	cvm_oct_mem_cleanup();
 
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index 10ffdea..41a9364 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -152,8 +152,8 @@ int cvm_oct_xmit_lockless(struct sk_buff *skb, struct net_device *dev);
 
 void cvm_oct_poll_controller(struct net_device *dev);
 void cvm_oct_rx_initialize(int);
-void cvm_oct_rx_shutdown0(void);
-void cvm_oct_rx_shutdown1(void);
+void cvm_oct_rx_shutdown0(bool in_crash);
+void cvm_oct_rx_shutdown1(bool in_crash);
 
 int cvm_oct_mem_fill_fpa(int pool, int elements);
 int cvm_oct_mem_empty_fpa(int pool, int elements);
-- 
1.9.1

