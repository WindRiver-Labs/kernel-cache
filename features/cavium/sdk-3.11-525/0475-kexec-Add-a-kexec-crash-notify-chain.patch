From be6ebf5504731b85946c29e273c0b4fba380e6d1 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Fri, 16 May 2014 11:53:55 -0500
Subject: [PATCH 475/518] kexec: Add a kexec crash notify chain

Source: Cavium Networks, Inc
MR: 9761
Type: Defect Fix
Disposition: Submitted to Octeon kernel team
ChangeID: c227e5c0ea230eb10d676e852abf2ec77a1cb5f0
Description:

A driver may need a way to clean things up so that a new kernel
can take over after a crash that kexec handles.  For instance,
the Octeon ethernet driver holds global resources that have to
be freed so a new kernel can use them.  Add a notify chain that
gets called on a kexec crash.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 include/linux/kexec.h | 11 +++++++++++
 kernel/kexec.c        | 25 +++++++++++++++++++++++++
 2 files changed, 36 insertions(+)

diff --git a/include/linux/kexec.h b/include/linux/kexec.h
index f145da3..22022ac 100644
--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@ -218,10 +218,21 @@ int crash_shrink_memory(unsigned long new_size);
 size_t crash_get_memory_size(void);
 void crash_free_reserved_phys_range(unsigned long begin, unsigned long end);
 
+int register_kexec_crash_notifier(struct notifier_block *nb);
+int unregister_kexec_crash_notifier(struct notifier_block *nb);
+
 #else /* !CONFIG_KEXEC */
 struct pt_regs;
 struct task_struct;
 static inline void crash_kexec(struct pt_regs *regs) { }
 static inline int kexec_should_crash(struct task_struct *p) { return 0; }
+static inline int register_kexec_crash_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline int unregister_kexec_crash_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
 #endif /* CONFIG_KEXEC */
 #endif /* LINUX_KEXEC_H */
diff --git a/kernel/kexec.c b/kernel/kexec.c
index 1459bdb..80d62fd 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -64,6 +64,29 @@ struct resource crashk_low_res = {
 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
 };
 
+static RAW_NOTIFIER_HEAD(kexec_crash_notifier_list);
+static DEFINE_MUTEX(crash_notifier_mutex);
+
+int register_kexec_crash_notifier(struct notifier_block *nb)
+{
+	int ret;
+	mutex_lock(&crash_notifier_mutex);
+	ret = raw_notifier_chain_register(&kexec_crash_notifier_list, nb);
+	mutex_unlock(&crash_notifier_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(register_kexec_crash_notifier);
+
+int unregister_kexec_crash_notifier(struct notifier_block *nb)
+{
+	int ret;
+	mutex_lock(&crash_notifier_mutex);
+	ret = raw_notifier_chain_unregister(&kexec_crash_notifier_list, nb);
+	mutex_unlock(&crash_notifier_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(unregister_kexec_crash_notifier);
+
 int kexec_should_crash(struct task_struct *p)
 {
 	if (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)
@@ -1092,6 +1115,8 @@ void crash_kexec(struct pt_regs *regs)
 
 			crash_setup_regs(&fixed_regs, regs);
 			crash_save_vmcoreinfo();
+			raw_notifier_call_chain(&kexec_crash_notifier_list,
+						0, NULL);
 			machine_crash_shutdown(&fixed_regs);
 			machine_kexec(kexec_crash_image);
 		}
-- 
1.9.1

