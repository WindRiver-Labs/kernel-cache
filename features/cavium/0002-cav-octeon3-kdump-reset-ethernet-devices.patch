From 69a5d0d0080030e75fab08b1aaad3510dc95cdd8 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Mon, 22 Apr 2013 16:52:42 +0800
Subject: [PATCH 2/7] cav-octeon3: kdump: reset ethernet devices

The octeon ethernet can't work when boot crash kernel, since the resources
of octeon ethernet are not released.
Cleanup them and reset devices.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../executive/cvmx-global-resources.c              |   21 ++++
 arch/mips/cavium-octeon/executive/cvmx-range.c     |   10 ++
 .../include/asm/octeon/cvmx-global-resources.h     |    3 +
 drivers/net/ethernet/octeon/Makefile               |    1 +
 drivers/net/ethernet/octeon/ethernet.c             |    4 +
 drivers/net/ethernet/octeon/octeon-ethernet.h      |    3 +
 drivers/net/ethernet/octeon/octeon-kexec-net.c     |  119 ++++++++++++++++++++
 7 files changed, 161 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/octeon-kexec-net.c

diff --git a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
index 7f08f55..bd742c3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
@@ -561,3 +561,24 @@ void cvmx_global_resources_show(void)
 
 }
 EXPORT_SYMBOL(free_global_resources);
+
+void cvmx_resource_cleanup(struct global_resource_tag tag)
+{
+	uint64_t range_addr = cvmx_get_global_resource(tag, 1);
+	if (range_addr == 0) {
+		char tagname[256];
+		 __cvmx_get_tagname(&tag, tagname);
+		 cvmx_dprintf("ERROR: cannot find resource %s\n", tagname);
+	}
+	__cvmx_global_resource_lock();
+	cvmx_range_cleanup(range_addr);
+	 __cvmx_global_resource_unlock();
+}
+
+void octeon_ethernet_resource_cleanup(void)
+{
+	cvmx_resource_cleanup(CVMX_GR_TAG_PKO_QUEUES);
+	cvmx_resource_cleanup(CVMX_GR_TAG_PKO_IPORTS);
+	cvmx_resource_cleanup(CVMX_GR_TAG_FPA);
+}
+EXPORT_SYMBOL(octeon_ethernet_resource_cleanup);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-range.c b/arch/mips/cavium-octeon/executive/cvmx-range.c
index 6917eef..da9583d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-range.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-range.c
@@ -263,3 +263,13 @@ void cvmx_range_show (uint64_t range_addr)
 	}
 	cvmx_dprintf ("i=%d : %d \n", (int) pindex, (int)pval);
 }
+
+void cvmx_range_cleanup(uint64_t range_addr)
+{
+	uint64_t size, i;
+	size = cvmx_read64_uint64(addr_of_size(range_addr));
+	for (i = 0; i < size; i++) {
+		cvmx_write64_uint64(addr_of_element(range_addr, i),
+			CVMX_RANGE_AVAILABLE);
+	}
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-global-resources.h b/arch/mips/include/asm/octeon/cvmx-global-resources.h
index e12d06d..2fcc067 100644
--- a/arch/mips/include/asm/octeon/cvmx-global-resources.h
+++ b/arch/mips/include/asm/octeon/cvmx-global-resources.h
@@ -165,6 +165,9 @@ void  cvmx_show_global_resource_range(struct global_resource_tag tag);
  */
 void cvmx_global_resources_show(void);
 
+void cvmx_range_cleanup(uint64_t range_addr);
+
+void octeon_ethernet_resource_cleanup(void);
 
 #endif
 
diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 4f37869..fd2cd24 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET) +=  octeon-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET_MEM) += ethernet-mem.o
 obj-$(CONFIG_OCTEON_ETHERNET_COMMON) += octeon_common.o
+obj-${CONFIG_CRASH_DUMP} += octeon-kexec-net.o
 
 octeon-ethernet-objs := ethernet.o
 octeon-ethernet-objs += ethernet-mdio.o
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index d849420..13b9d36 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -826,6 +826,10 @@ static int cvm_oct_probe(struct platform_device *pdev)
 	int qos, r;
 	struct device_node *pip;
 
+#if defined(CONFIG_CRASH_DUMP)
+	if (reset_devices)
+		octeon_shutdown_network_hw();
+#endif
 	octeon_mdiobus_force_mod_depencency();
 	pr_notice("octeon-ethernet %s\n", OCTEON_ETHERNET_VERSION);
 
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index f0efedc..480db62 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -225,4 +225,7 @@ static inline u8 *cvm_oct_get_fpa_head(struct sk_buff *skb)
 	return (u8 *)((unsigned long)(skb->head + CVM_OCT_SKB_TO_FPA_PADDING) & ~0x7ful);
 }
 
+#if defined(CONFIG_CRASH_DUMP)
+extern void octeon_shutdown_network_hw(void);
+#endif
 #endif
diff --git a/drivers/net/ethernet/octeon/octeon-kexec-net.c b/drivers/net/ethernet/octeon/octeon-kexec-net.c
new file mode 100644
index 0000000..2ed3507
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-kexec-net.c
@@ -0,0 +1,119 @@
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon-model.h>
+#include <asm/octeon/cvmx-agl-defs.h>
+#include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-mixx-defs.h>
+#include <linux/netdevice.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-config.h>
+#include <asm/octeon/cvmx-fpa-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-pow.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-global-resources.h>
+
+void octeon_shutdown_network_hw(void)
+{
+	cvmx_wqe_t *work = NULL;
+	int num_ints = 0;
+	int interface = 0;
+	int num_ports = 0;
+	int port = 0;
+	union cvmx_pko_reg_flags pko_reg_flags;
+	union cvmx_fpa_ctl_status fpa_status;
+	union cvmx_smix_en smix_en;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+	union cvmx_pip_sft_rst pip_sft_rst;
+	union cvmx_pow_wq_int wq_int;
+
+	/* halt the interfaces */
+	num_ints = cvmx_helper_get_number_of_interfaces();
+
+	/* Check to see what interface and ports we should use */
+	for (interface = 0; interface < num_ints; interface++) {
+		cvmx_helper_interface_mode_t mode =
+			cvmx_helper_interface_get_mode(interface);
+		int XGMII_MODE = (CVMX_HELPER_INTERFACE_MODE_RGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_SGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_GMII  == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_XAUI  == mode);
+
+		if (XGMII_MODE) {
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			if (num_ports > 4)
+				num_ports = 4;
+			for (port = 0; port < num_ports; port++) {
+				union cvmx_gmxx_prtx_cfg gmx_cfg;
+				gmx_cfg.u64 = cvmx_read_csr(
+					CVMX_GMXX_PRTX_CFG(port, interface));
+				gmx_cfg.s.en = 0;
+				cvmx_write_csr(
+					CVMX_GMXX_PRTX_CFG(port, interface),
+						gmx_cfg.u64);
+			}
+		}
+	}
+
+	/* drain the work queue and free it */
+	while ((work = cvmx_pow_work_request_sync(CVMX_POW_WAIT))) {
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* clear possible pending interrupt */
+	wq_int.u64 = 0;
+	wq_int.s.wq_int = 1 << 15;
+	cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
+
+	/* Newer chips actually have two SMI/MDIO interfaces */
+	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN58XX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
+		if (smix_en.s.en) {
+			smix_en.s.en = 0;
+			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
+		}
+	}
+
+	/* Reset the IPD to get all buffers out of it */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.reset = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	/* Reset the PIP */
+	pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
+	pip_sft_rst.s.rst = 1;
+	cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
+
+	/* disable the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.ena_pko = 0;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* reset the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.reset = 1;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* disable the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.enb = 0;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* reset the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.reset = 1;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* free the cvmx_cmd_queues from bootmemory */
+	cvmx_bootmem_free_named("cvmx_cmd_queues");
+
+	/* Cleanup octeon ethernet resources */
+	octeon_ethernet_resource_cleanup();
+}
+EXPORT_SYMBOL(octeon_shutdown_network_hw);
-- 
1.7.0.4

