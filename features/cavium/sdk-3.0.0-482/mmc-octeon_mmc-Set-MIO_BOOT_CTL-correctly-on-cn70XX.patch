From 485b3bebf911d821365d27d7d524e66a4eceb6a8 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 15 Nov 2013 12:07:15 -0800
Subject: [PATCH 15/20] mmc octeon_mmc: Set MIO_BOOT_CTL correctly on cn70XX

Source: Cavium SDK 3.1.0-515

Part of acquiring access to the bootbus is selecting mmc mode on
cn70xx.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   28 +++++++++++++++++++++-------
 1 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index f028003..200321c 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -109,6 +109,20 @@ module_param(force_no_multi, int, S_IRUGO);
 MODULE_PARM_DESC(force_no_multi,
 		 "Force the interface to emulate multi-block transfers as a series of single block transfres.");
 
+
+static void octeon_mmc_acquire_bus(void)
+{
+	down(&octeon_bootbus_sem);
+	/* On cn70XX switch the mmc unit onto the bus. */
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX))
+		cvmx_write_csr(CVMX_MIO_BOOT_CTL, 0);
+}
+
+static void octeon_mmc_release_bus(void)
+{
+	up(&octeon_bootbus_sem);
+}
+
 struct octeon_mmc_cr_type {
 	u8 ctype;
 	u8 rtype;
@@ -417,7 +431,7 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 no_req_done:
 	spin_unlock_irqrestore(&host->lock, flags);
 	if (host_done)
-		up(&octeon_bootbus_sem);
+		octeon_mmc_release_bus();
 out:
 	return IRQ_RETVAL(emm_int.u64 != 0);
 }
@@ -477,7 +491,7 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	down(&octeon_bootbus_sem);
+	octeon_mmc_acquire_bus();
 
 	octeon_mmc_switch_to(slot);
 
@@ -552,7 +566,7 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	down(&octeon_bootbus_sem);
+	octeon_mmc_acquire_bus();
 
 	octeon_mmc_switch_to(slot);
 
@@ -695,7 +709,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	host = slot->host;
 
 	/* Only a single user of the bootbus at a time. */
-	down(&octeon_bootbus_sem);
+	octeon_mmc_acquire_bus();
 
 	octeon_mmc_switch_to(slot);
 
@@ -786,7 +800,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		}
 	}
 out:
-	up(&octeon_bootbus_sem);
+	octeon_mmc_release_bus();
 }
 
 static int octeon_mmc_get_ro(struct mmc_host *mmc)
@@ -966,13 +980,13 @@ static int __devinit octeon_init_slot(struct octeon_mmc_host *host, int id,
 	slot->bus_id = id;
 
 	/* Only a single user of the bootbus at a time. */
-	down(&octeon_bootbus_sem);
+	octeon_mmc_acquire_bus();
 
 	octeon_mmc_switch_to(slot);
 	/* Initialize MMC Block. */
 	octeon_mmc_initlowlevel(slot, bus_width);
 
-	up(&octeon_bootbus_sem);
+	octeon_mmc_release_bus();
 
 	host->slot[id] = slot;
 	ret = mmc_add_host(mmc);
-- 
1.7.5.4

