From 50491acea2bbbfdcaa69a0e3b6d68a9cb76da283 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 23 Jan 2013 11:26:37 -0800
Subject: [PATCH 337/337] netdev/octeon-ethernet: Handle XAUI LOC_FAULT and
 REM_FAULT.

Based On SDK 3.0.0-482

On these error conditions, we need to call cvmx_helper_link_autoconf()
instead of just having the error reporting framework print nice
messages.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-sgmii.c |  125 +++++++++++++++++++++++---
 1 files changed, 111 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-sgmii.c b/drivers/net/ethernet/octeon/ethernet-sgmii.c
index 957ad9b..00d5f7a 100644
--- a/drivers/net/ethernet/octeon/ethernet-sgmii.c
+++ b/drivers/net/ethernet/octeon/ethernet-sgmii.c
@@ -31,6 +31,7 @@
 #include <net/dst.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/octeon-hw-status.h>
 
 #include "ethernet-defines.h"
 #include "octeon-ethernet.h"
@@ -38,6 +39,10 @@
 #include <asm/octeon/cvmx-helper.h>
 
 #include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-npei-defs.h>
+
+#define INT_BIT_LOC_FAULT 20
+#define INT_BIT_REM_FAULT 21
 
 /* Although these functions are called cvm_oct_sgmii_*, they also
  * happen to be used for the XAUI ports as well.
@@ -58,13 +63,34 @@ static void cvm_oct_sgmii_poll(struct net_device *dev)
 	/* Tell the core */
 	cvm_oct_set_carrier(priv, link_info);
 }
+static int cvm_oct_sgmii_hw_status(struct notifier_block *nb,
+				   unsigned long val, void *v)
+{
+	struct octeon_ethernet *priv = container_of(nb, struct octeon_ethernet,
+						    hw_status_notifier);
+
+	if (val == OCTEON_HW_STATUS_SOURCE_ASSERTED) {
+		struct octeon_hw_status_data *d = v;
+		if (d->reg == CVMX_GMXX_RXX_INT_REG(priv->interface_port,
+						    priv->interface) &&
+		    (d->bit == INT_BIT_LOC_FAULT ||
+		     d->bit == INT_BIT_REM_FAULT)) {
+			cvmx_helper_link_autoconf(priv->ipd_port);
+			return NOTIFY_STOP;
+		}
+	}
+	return NOTIFY_DONE;
+}
 
 int cvm_oct_sgmii_open(struct net_device *dev)
 {
+	struct octeon_hw_status_reg sr[3];
 	union cvmx_gmxx_prtx_cfg gmx_cfg;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	cvmx_helper_link_info_t link_info;
-	int rv;
+	cvmx_helper_interface_mode_t imode;
+	int rv, i;
+	u64 en_mask;
 
 	rv = cvm_oct_phy_setup_device(dev);
 	if (rv)
@@ -74,21 +100,75 @@ int cvm_oct_sgmii_open(struct net_device *dev)
 	gmx_cfg.s.en = 1;
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface), gmx_cfg.u64);
 
-	if (!octeon_is_simulation()) {
-		if (priv->phydev) {
-			int r = phy_read_status(priv->phydev);
-			if (r == 0 && priv->phydev->link == 0)
-				netif_carrier_off(dev);
-			cvm_oct_adjust_link(dev);
+	if (octeon_is_simulation())
+		return 0;
+
+	if (priv->phydev) {
+		int r = phy_read_status(priv->phydev);
+		if (r == 0 && priv->phydev->link == 0)
+			netif_carrier_off(dev);
+		cvm_oct_adjust_link(dev);
+	} else {
+		link_info = cvmx_helper_link_get(priv->ipd_port);
+		if (!link_info.s.link_up)
+			netif_carrier_off(dev);
+		spin_lock(&priv->poll_lock);
+		priv->poll = cvm_oct_sgmii_poll;
+		spin_unlock(&priv->poll_lock);
+		cvm_oct_sgmii_poll(dev);
+	}
+	imode = cvmx_helper_interface_get_mode(priv->interface);
+	switch (imode) {
+	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		/* Handle GMXX_RXX_INT_REG[LOC_FAULT,REM_FAULT]*/
+		priv->hw_status_notifier.priority = 10;
+		priv->hw_status_notifier.notifier_call = cvm_oct_sgmii_hw_status;
+		octeon_hw_status_notifier_register(&priv->hw_status_notifier);
+		memset(sr, 0, sizeof(sr));
+		i = 0;
+		en_mask = 0;
+		if (OCTEON_IS_OCTEONPLUS()) {
+			sr[i].reg = 46; /* RML */
+			sr[i].reg_is_hwint = 1;
+			sr[i].has_child = 1;
+			i++;
+			sr[i].reg = CVMX_NPEI_RSL_INT_BLOCKS;
+			/* GMX[priv->interface]*/
+			sr[i].bit = priv->interface + 1;
+			sr[i].has_child = 1;
+			i++;
+		} else if (octeon_has_feature(OCTEON_FEATURE_CIU2)) {
+			/* PKT[AGX[priv->interface]]*/
+			sr[i].reg = (6 << 6) | priv->interface;
+			sr[i].reg_is_hwint = 1;
+			sr[i].has_child = 1;
+			i++;
 		} else {
-			link_info = cvmx_helper_link_get(priv->ipd_port);
-			if (!link_info.s.link_up)
-				netif_carrier_off(dev);
-			spin_lock(&priv->poll_lock);
-			priv->poll = cvm_oct_sgmii_poll;
-			spin_unlock(&priv->poll_lock);
-			cvm_oct_sgmii_poll(dev);
+			/* INT_SUM1[AGX[priv->interface]]*/
+			sr[i].reg = (1 << 6) | (priv->interface + 36);
+			sr[i].reg_is_hwint = 1;
+			sr[i].has_child = 1;
+			i++;
 		}
+		sr[i].reg = CVMX_GMXX_RXX_INT_REG(priv->interface_port,
+						  priv->interface);
+		sr[i].mask_reg = CVMX_GMXX_RXX_INT_EN(priv->interface_port,
+						      priv->interface);
+		sr[i].ack_w1c = 1;
+
+		sr[i].bit = INT_BIT_LOC_FAULT;
+		en_mask |= 1ull << sr[i].bit;
+		octeon_hw_status_add_source(sr);
+
+		sr[i].bit = INT_BIT_REM_FAULT;
+		en_mask |= 1ull << sr[i].bit;
+		octeon_hw_status_add_source(sr);
+
+		octeon_hw_status_enable(sr[i].reg, en_mask);
+		break;
+	default:
+		break;
 	}
 	return 0;
 }
@@ -102,6 +182,23 @@ int cvm_oct_sgmii_stop(struct net_device *dev)
 	gmx_cfg.s.en = 0;
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface), gmx_cfg.u64);
 
+	if (priv->hw_status_notifier.notifier_call) {
+		struct octeon_hw_status_reg sr;
+		memset(&sr, 0, sizeof(sr));
+
+		sr.reg = CVMX_GMXX_RXX_INT_REG(priv->interface_port,
+					       priv->interface);
+		sr.mask_reg = CVMX_GMXX_RXX_INT_EN(priv->interface_port,
+						   priv->interface);
+		sr.ack_w1c = 1;
+		sr.bit = INT_BIT_LOC_FAULT;
+		octeon_hw_status_remove_source(&sr);
+		sr.bit = INT_BIT_REM_FAULT;
+		octeon_hw_status_remove_source(&sr);
+		octeon_hw_status_notifier_unregister(&priv->hw_status_notifier);
+		priv->hw_status_notifier.notifier_call = NULL;
+	}
+
 	spin_lock(&priv->poll_lock);
 	priv->poll = NULL;
 	spin_unlock(&priv->poll_lock);
-- 
1.7.5.4

