From 99fac96143afe7493b9bff962e894f7b8d98a7e3 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 15 Jan 2013 15:17:21 -0800
Subject: [PATCH 312/337] MIPS: OCTEON: Allow for error tree reporting to be
 enabled per group.

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/octeon-error-tree.c |   99 +++++++++++++++++++++++----
 arch/mips/cavium-octeon/octeon-hw-status.c  |    1 +
 arch/mips/include/asm/octeon/octeon.h       |   13 ++++
 3 files changed, 99 insertions(+), 14 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-error-tree.c b/arch/mips/cavium-octeon/octeon-error-tree.c
index 80d7e97..c7fd63f 100644
--- a/arch/mips/cavium-octeon/octeon-error-tree.c
+++ b/arch/mips/cavium-octeon/octeon-error-tree.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/export.h>
 #include <linux/interrupt.h>
 
 #include <asm/mipsregs.h>
@@ -16,8 +17,44 @@
 
 static struct cvmx_error_muxchild *octeon_error_tree_current;
 
-static void __init octeon_error_tree_process_branch(struct octeon_hw_status_reg *sr,
-						    int idx, int max_idx, struct cvmx_error_muxchild *n)
+static void octeon_error_tree_remove(int idx, int max_idx, struct cvmx_error_muxchild *n,
+				     enum cvmx_error_groups group, int unit)
+{
+	struct cvmx_error_regbit *bit;
+	struct cvmx_error_childbit *child;
+	bit = n->bits;
+
+	while (bit && bit->valid && bit->group == group && (unit < 0 || unit == bit->unit)) {
+		struct octeon_hw_status_reg r;
+
+		memset(&r, 0, sizeof(r));
+		r.reg = n->reg;
+		r.mask_reg = n->mask_reg;
+		r.bit = bit->bit;
+		octeon_hw_status_remove_source(&r);
+
+		bit++;
+	}
+
+	child = n->children;
+
+	while (child && child->valid) {
+		struct cvmx_error_muxchild *child_bit;
+		child_bit = child->children;
+		while (child_bit && child_bit->reg) {
+			if (WARN(idx + 1 > max_idx, "Maximum depth exceeded: %d", max_idx))
+				return;
+
+			octeon_error_tree_remove(idx + 1, max_idx, child_bit, group, unit);
+			child_bit++;
+		}
+		child++;
+	}
+}
+
+static void octeon_error_tree_add(struct octeon_hw_status_reg *sr,
+				  int idx, int max_idx, struct cvmx_error_muxchild *n,
+				  enum cvmx_error_groups group, int unit)
 {
 	struct cvmx_error_regbit *bit;
 	struct cvmx_error_childbit *child;
@@ -26,7 +63,7 @@ static void __init octeon_error_tree_process_branch(struct octeon_hw_status_reg
 	sr[idx].reg = n->reg;
 	sr[idx].mask_reg = n->mask_reg;
 
-	while (bit && bit->valid && bit->group == CVMX_ERROR_GROUP_INTERNAL) {
+	while (bit && bit->valid && bit->group == group && (unit < 0 || unit == bit->unit)) {
 		sr[idx].bit = bit->bit;
 		sr[idx].ack_w1c = bit->w1c;
 		sr[idx].has_child = 0;
@@ -49,14 +86,14 @@ static void __init octeon_error_tree_process_branch(struct octeon_hw_status_reg
 			if (WARN(idx + 1 > max_idx, "Maximum depth exceeded: %d", max_idx))
 				return;
 
-			octeon_error_tree_process_branch(sr, idx + 1, max_idx, child_bit);
+			octeon_error_tree_add(sr, idx + 1, max_idx, child_bit, group, unit);
 			child_bit++;
 		}
 		child++;
 	}
 }
 
-static int __init octeon_error_tree_map_irq_reg(u64 r)
+static int octeon_error_tree_map_irq_reg(u64 r)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 		if ((0xf8fff & r) == 0x80000)
@@ -124,21 +161,47 @@ static int octeon_error_tree_hw_status(struct notifier_block *nb, unsigned long
 
 static struct notifier_block octeon_error_tree_notifier;
 
-static int __init octeon_error_tree_ciu(struct cvmx_error_muxchild *r)
+int octeon_error_tree_disable(enum cvmx_error_groups group, int unit)
 {
-	struct octeon_hw_status_reg sr[6];
 	struct cvmx_error_muxchild *base;
 	struct cvmx_error_childbit *line;
 	int irq_reg;
 
-	octeon_error_tree_current = r;
+	if (!octeon_error_tree_current)
+		return -ENODEV;
 
-	octeon_error_tree_notifier.notifier_call = octeon_error_tree_hw_status;
-	octeon_error_tree_notifier.priority = 10;
-	octeon_hw_status_notifier_register(&octeon_error_tree_notifier);
+	base = octeon_error_tree_current->children->children;
+
+	while (base->reg) {
+		irq_reg = octeon_error_tree_map_irq_reg(base->reg);
+		if (irq_reg < 0)
+			return irq_reg;
+
+		line = base->children;
+		while (line && line->valid) {
+			octeon_error_tree_remove(1, 5, line->children,
+						 group, unit);
+			line++;
+		}
+		base++;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(octeon_error_tree_disable);
+
+int octeon_error_tree_enable(enum cvmx_error_groups group, int unit)
+{
+	struct octeon_hw_status_reg sr[6];
+	struct cvmx_error_muxchild *base;
+	struct cvmx_error_childbit *line;
+	int irq_reg;
+
+	if (!octeon_error_tree_current)
+		return -ENODEV;
 
 	memset(sr, 0, sizeof(sr));
-	base = r->children->children;
+	base = octeon_error_tree_current->children->children;
 
 	while (base->reg) {
 		irq_reg = octeon_error_tree_map_irq_reg(base->reg);
@@ -150,7 +213,8 @@ static int __init octeon_error_tree_ciu(struct cvmx_error_muxchild *r)
 			sr[0].reg = irq_reg << 6 | line->bit;
 			sr[0].reg_is_hwint = 1;
 			sr[0].has_child = 1;
-			octeon_error_tree_process_branch(sr, 1, ARRAY_SIZE(sr) - 1, line->children);
+			octeon_error_tree_add(sr, 1, ARRAY_SIZE(sr) - 1, line->children,
+					      group, unit);
 			line++;
 		}
 		base++;
@@ -158,6 +222,7 @@ static int __init octeon_error_tree_ciu(struct cvmx_error_muxchild *r)
 
 	return 0;
 }
+EXPORT_SYMBOL(octeon_error_tree_enable);
 
 static int __init octeon_error_tree_init(void)
 {
@@ -176,6 +241,12 @@ static int __init octeon_error_tree_init(void)
 	}
 	pr_notice("Installing handlers for error tree at: %p\n", tree->tree);
 
-	return octeon_error_tree_ciu(tree->tree);
+	octeon_error_tree_current = tree->tree;
+
+	octeon_error_tree_notifier.notifier_call = octeon_error_tree_hw_status;
+	octeon_error_tree_notifier.priority = 10;
+	octeon_hw_status_notifier_register(&octeon_error_tree_notifier);
+
+	return octeon_error_tree_enable(CVMX_ERROR_GROUP_INTERNAL, -1);
 }
 arch_initcall(octeon_error_tree_init);
diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index d8a6253..d5d7c2c 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -308,6 +308,7 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 	n->users--;
 	if (n->users == 0) {
 		if (!n->is_hwint && n->mask_reg) {
+			/* Disable the source if we are removing it. */
 			u64 mask = 1ull << n->bit;
 			u64 csr = cvmx_read_csr(n->mask_reg);
 			csr &= ~mask;
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index fd8e03e..58f575f 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -416,5 +416,18 @@ int unregister_co_cache_error_notifier(struct notifier_block *nb);
 
 extern unsigned long long cache_err_dcache[NR_CPUS];
 
+#if IS_ENABLED(CONFIG_CAVIUM_OCTEON_ERROR_TREE)
+int octeon_error_tree_enable(enum cvmx_error_groups group, int unit);
+int octeon_error_tree_disable(enum cvmx_error_groups group, int unit);
+#else
+static inline int octeon_error_tree_enable(enum cvmx_error_groups group, int unit)
+{
+	return 0;
+}
+static inline int octeon_error_tree_disable(enum cvmx_error_groups group, int unit)
+{
+	return 0;
+}
+#endif
 
 #endif /* __ASM_OCTEON_OCTEON_H */
-- 
1.7.5.4

