From 33ff746a1c5cc3760e25ef5eb58e01860c191fef Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 11 Jul 2012 15:33:40 -0700
Subject: [PATCH 127/337] staging/netdev: octeon-ethernet: Fix data race in TX
 statistics

Based On SDK 3.0.0-482

Access to PKO_MEM_COUNT* requires two register accesses, so it must be
done under a lock.  Also reading and clearing the registers is racy
with the hardware, so we never clear the values, just take the
difference from the previous read value.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/staging/octeon/ethernet.c        |   73 ++++++++++++++++++++---------
 drivers/staging/octeon/octeon-ethernet.h |    2 +
 2 files changed, 52 insertions(+), 23 deletions(-)

diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index bb0f0e0..5448f41 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -206,6 +206,9 @@ int cvm_oct_free_work(void *work_queue_entry)
 }
 EXPORT_SYMBOL(cvm_oct_free_work);
 
+/* Lock to protect racy cvmx_pko_get_port_status() */
+static DEFINE_SPINLOCK(cvm_oct_tx_stat_lock);
+
 /**
  * cvm_oct_common_get_stats - get the low level ethernet statistics
  * @dev:    Device to get the statistics from
@@ -214,36 +217,54 @@ EXPORT_SYMBOL(cvm_oct_free_work);
  */
 static struct net_device_stats *cvm_oct_common_get_stats(struct net_device *dev)
 {
+	unsigned long flags;
 	cvmx_pip_port_status_t rx_status;
 	cvmx_pko_port_status_t tx_status;
+	u64 current_tx_octets;
+	u32 current_tx_packets;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 
-	if (priv->ipd_port < CVMX_PIP_NUM_INPUT_PORTS) {
-		if (octeon_is_simulation()) {
-			/* The simulator doesn't support statistics */
-			memset(&rx_status, 0, sizeof(rx_status));
-			memset(&tx_status, 0, sizeof(tx_status));
-		} else {
-			cvmx_pip_get_port_status(priv->ipd_port, 1, &rx_status);
-			cvmx_pko_get_port_status(priv->ipd_port, 1, &tx_status);
-		}
-
-		dev->stats.rx_packets += rx_status.inb_packets;
-		dev->stats.tx_packets += tx_status.packets;
-		dev->stats.rx_bytes += rx_status.inb_octets;
-		dev->stats.tx_bytes += tx_status.octets;
-		dev->stats.multicast += rx_status.multicast_packets;
-		dev->stats.rx_crc_errors += rx_status.inb_errors;
-		dev->stats.rx_frame_errors += rx_status.fcs_align_err_packets;
+	if (octeon_is_simulation()) {
+		/* The simulator doesn't support statistics */
+		memset(&rx_status, 0, sizeof(rx_status));
+		memset(&tx_status, 0, sizeof(tx_status));
+	} else {
+		cvmx_pip_get_port_status(priv->ipd_port, 1, &rx_status);
 
+		spin_lock_irqsave(&cvm_oct_tx_stat_lock, flags);
+		cvmx_pko_get_port_status(priv->ipd_port, 0, &tx_status);
+		current_tx_packets = tx_status.packets;
+		current_tx_octets = tx_status.octets;
+		/*
+		 * The tx_packets counter is 32-bits as are all these
+		 * variables.  No truncation necessary.
+		 */
+		tx_status.packets = current_tx_packets - priv->last_tx_packets;
 		/*
-		 * The drop counter must be incremented atomically
-		 * since the RX tasklet also increments it.
+		 * The tx_octets counter is only 48-bits, so we need
+		 * to truncate in case there was a wrap-around
 		 */
-		atomic64_add(rx_status.dropped_packets,
-			     (atomic64_t *)&dev->stats.rx_dropped);
+		tx_status.octets = (current_tx_octets - priv->last_tx_octets) & 0xffffffffffffull;
+		priv->last_tx_packets = current_tx_packets;
+		priv->last_tx_octets = current_tx_octets;
+		spin_unlock_irqrestore(&cvm_oct_tx_stat_lock, flags);
 	}
 
+	dev->stats.rx_packets += rx_status.inb_packets;
+	dev->stats.tx_packets += tx_status.packets;
+	dev->stats.rx_bytes += rx_status.inb_octets;
+	dev->stats.tx_bytes += tx_status.octets;
+	dev->stats.multicast += rx_status.multicast_packets;
+	dev->stats.rx_crc_errors += rx_status.inb_errors;
+	dev->stats.rx_frame_errors += rx_status.fcs_align_err_packets;
+
+	/*
+	 * The drop counter must be incremented atomically since the
+	 * RX tasklet also increments it.
+	 */
+	atomic64_add(rx_status.dropped_packets,
+		     (atomic64_t *)&dev->stats.rx_dropped);
+
 	return &dev->stats;
 }
 
@@ -427,6 +448,8 @@ static int cvm_oct_common_set_mac_address(struct net_device *dev, void *addr)
  */
 int cvm_oct_common_init(struct net_device *dev)
 {
+	unsigned long flags;
+	cvmx_pko_port_status_t tx_status;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	const u8 *mac = NULL;
 
@@ -453,12 +476,16 @@ int cvm_oct_common_init(struct net_device *dev)
 	cvm_oct_set_mac_filter(dev);
 	dev->netdev_ops->ndo_change_mtu(dev, dev->mtu);
 
+	spin_lock_irqsave(&cvm_oct_tx_stat_lock, flags);
+	cvmx_pko_get_port_status(priv->ipd_port, 0, &tx_status);
+	priv->last_tx_packets = tx_status.packets;
+	priv->last_tx_octets = tx_status.octets;
 	/*
 	 * Zero out stats for port so we won't mistakenly show
 	 * counters from the bootloader.
 	 */
-	memset(dev->netdev_ops->ndo_get_stats(dev), 0,
-	       sizeof(struct net_device_stats));
+	memset(&dev->stats, 0, sizeof(struct net_device_stats));
+	spin_unlock_irqrestore(&cvm_oct_tx_stat_lock, flags);
 
 	return 0;
 }
diff --git a/drivers/staging/octeon/octeon-ethernet.h b/drivers/staging/octeon/octeon-ethernet.h
index 1227436..e75fc65 100644
--- a/drivers/staging/octeon/octeon-ethernet.h
+++ b/drivers/staging/octeon/octeon-ethernet.h
@@ -81,6 +81,8 @@ struct octeon_ethernet {
 	struct delayed_work	port_periodic_work;
 	struct work_struct	port_work;	/* may be unused. */
 	struct device_node	*of_node;
+	u64 last_tx_octets;
+	u32 last_tx_packets;
 };
 
 int cvm_oct_free_work(void *work_queue_entry);
-- 
1.7.5.4

