From ebb9c3018d8b02c36d9764c46e5511e9baadc688 Mon Sep 17 00:00:00 2001
From: Venkat Subbiah <venkat.subbiah@cavium.com>
Date: Mon, 7 Jan 2013 13:59:28 -0800
Subject: [PATCH 292/337] MIPS: Octeon: Update SE to r79722

Based On SDK 3.0.0-482

Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-dma-engine.c |   10 ++++
 .../mips/cavium-octeon/executive/cvmx-helper-ilk.c |   33 ++++++++----
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |    3 +-
 arch/mips/cavium-octeon/executive/cvmx-ilk.c       |    6 +-
 arch/mips/cavium-octeon/executive/cvmx-pko.c       |   10 ++++
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |    2 +-
 arch/mips/cavium-octeon/executive/cvmx-range.c     |    2 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    4 ++
 arch/mips/include/asm/octeon/cvmx-cmd-queue.h      |    2 +-
 arch/mips/include/asm/octeon/cvmx-ipd.h            |   16 ++++++
 arch/mips/include/asm/octeon/cvmx-pko.h            |   16 ++++++
 arch/mips/include/asm/octeon/cvmx-pow-defs.h       |   55 --------------------
 12 files changed, 87 insertions(+), 72 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
index ab3a5e3..f175c20 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
@@ -62,6 +62,7 @@
 #include "cvmx-cmd-queue.h"
 #include "cvmx-dma-engine.h"
 #include "cvmx-helper-cfg.h"
+#include "cvmx-helper-fpa.h"
 #endif
 
 
@@ -94,6 +95,15 @@ int cvmx_dma_engine_initialize(void)
 	int outputbuffer_pool = (int)cvmx_fpa_get_dma_pool();
 	uint64_t outputbuffer_pool_size = cvmx_fpa_get_dma_pool_block_size();
 
+	/** It allocate pools for dma command queues
+	 */
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+	cvmx_fpa_global_initialize();
+	if(dma_config.command_queue_pool.buffer_count != 0)
+		__cvmx_helper_initialize_fpa_pool(outputbuffer_pool, outputbuffer_pool_size,
+			  dma_config.command_queue_pool.buffer_count, "Dma Cmd Buffers");
+#endif
+
 	for (engine = 0; engine < cvmx_dma_engine_get_num(); engine++) {
 		cvmx_cmd_queue_result_t result;
 		result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_DMA(engine), 0, outputbuffer_pool, outputbuffer_pool_size);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
index aa04c28..0bb7827 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
@@ -89,12 +89,7 @@ int __cvmx_helper_ilk_enumerate(int interface)
  */
 int __cvmx_helper_ilk_probe(int interface)
 {
-	int i, j, num_pknd, res = -1;
-	static int pipe_base = 0, pknd_base = 0;
-	static cvmx_ilk_pipe_chan_t *pch = NULL, *tmp;
-	static cvmx_ilk_chan_pknd_t *chpknd = NULL, *tmp1;
-	static cvmx_ilk_cal_entry_t *calent = NULL, *tmp2;
-	int enable_rx_cal;
+	int res;
 
 	if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
 		return 0;
@@ -112,6 +107,24 @@ int __cvmx_helper_ilk_probe(int interface)
 	if (res < 0)
 		return 0;
 
+	res = __cvmx_helper_ilk_enumerate(interface + CVMX_ILK_GBL_BASE);
+
+	return res;
+}
+
+static int __cvmx_helper_ilk_init_port(int interface)
+{
+	int i, j, num_pknd, res = -1;
+	static int pipe_base = 0, pknd_base = 0;
+	static cvmx_ilk_pipe_chan_t *pch = NULL, *tmp;
+	static cvmx_ilk_chan_pknd_t *chpknd = NULL, *tmp1;
+	static cvmx_ilk_cal_entry_t *calent = NULL, *tmp2;
+	int enable_rx_cal;
+
+	interface -= CVMX_ILK_GBL_BASE;
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return 0;
+
 	/* set up the group of pipes available to ilk */
 	if (pipe_base == 0)
 		pipe_base = __cvmx_pko_get_pipe(interface + CVMX_ILK_GBL_BASE, 0);
@@ -244,8 +257,6 @@ int __cvmx_helper_ilk_probe(int interface)
 		res = 0;
 		goto err_free_calent;
 	}
-	res = __cvmx_helper_ilk_enumerate(interface + CVMX_ILK_GBL_BASE);
-
 	goto out;
 
 err_free_calent:
@@ -284,8 +295,10 @@ out:
  */
 int __cvmx_helper_ilk_enable(int interface)
 {
-	interface -= CVMX_ILK_GBL_BASE;
-	return cvmx_ilk_enable(interface);
+	if (__cvmx_helper_ilk_init_port(interface) < 0)
+		return -1;
+
+	return cvmx_ilk_enable(interface - CVMX_ILK_GBL_BASE);
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 8909bd0..247b53b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -796,6 +796,7 @@ static int __cvmx_helper_interface_setup_ipd(int interface)
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 int __cvmx_helper_ipd_setup_fpa_pools(void)
 {
+	cvmx_fpa_global_initialize();
 	if(cvmx_ipd_cfg.packet_pool.buffer_count == 0)
 		return 0;
 		__cvmx_helper_initialize_fpa_pool(cvmx_ipd_cfg.packet_pool.pool_num, cvmx_ipd_cfg.packet_pool.buffer_size,
@@ -817,7 +818,7 @@ int __cvmx_helper_ipd_setup_fpa_pools(void)
  */
 static int __cvmx_helper_global_setup_ipd(void)
 {
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL 
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	/* Setup the packet and wqe pools*/
 	__cvmx_helper_ipd_setup_fpa_pools();
 #endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
index 69144b5..2eac82e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-ilk.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
@@ -72,9 +72,9 @@
  * cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF] = {0xff, 0x0} and
  * cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = {8, 0}
  */
-CVMX_SHARED unsigned char cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF];
+CVMX_SHARED unsigned char cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF] = {0xf, (0xf << 4)};
 
-CVMX_SHARED unsigned char cvmx_ilk_chans[CVMX_NUM_ILK_INTF];
+CVMX_SHARED unsigned char cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = {8,8};
 
 unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_ILK_MAX_CHANS] = { {0, 1, 2, 3, 4, 5, 6, 7},
 {0, 1, 2, 3, 4, 5, 6, 7}
@@ -116,7 +116,7 @@ void cvmx_ilk_config_set_lane_mask(int interface, unsigned char mask)
 		cvmx_dprintf("ERROR: Invalid interface=%d in cvmx_ilk_set_lane_mask\n",
 			     interface);
 	else
-		cvmx_ilk_lane_mask[interface] = mask;
+		cvmx_ilk_lane_mask[interface] = mask << (4*interface);
 }
 
 void cvmx_ilk_config_set_max_channels(int interface, unsigned char channels)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko.c b/arch/mips/cavium-octeon/executive/cvmx-pko.c
index b3af62d..1fdf723 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko.c
@@ -523,6 +523,16 @@ void cvmx_pko_initialize_global(void)
 	int i;
     	int outputbuffer_pool = (int)cvmx_fpa_get_pko_pool();
     	uint64_t outputbuffer_pool_size = cvmx_fpa_get_pko_pool_block_size();
+	uint64_t outputbuffer_pool_count;
+
+	outputbuffer_pool_count = cvmx_fpa_get_pko_pool_buffer_count();
+	/** It allocate pools for pko command queues */
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+	cvmx_fpa_global_initialize();
+	if(outputbuffer_pool_count != 0)
+		__cvmx_helper_initialize_fpa_pool(outputbuffer_pool, outputbuffer_pool_size,
+			outputbuffer_pool_count, "Pko Cmd Buffers");
+#endif
 
 #ifdef CVMX_BUILD_FOR_STANDALONE
 	__cvmx_install_gmx_error_handler_for_xaui();
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index e217e56..f6be04c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -979,7 +979,7 @@ static void __cvmx_qlm_set_qlm_pcie_mode(int pcie_port, int root_complex)
 		} else {
 			soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
 			soft_prst.s.soft_prst = 0;
-			cvmx_write_csr(CVMX_CIU_SOFT_PRST, soft_prst1.u64);
+			cvmx_write_csr(CVMX_CIU_SOFT_PRST, soft_prst.u64);
 		}
 	}
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-range.c b/arch/mips/cavium-octeon/executive/cvmx-range.c
index f102709..9eb1eb2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-range.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-range.c
@@ -134,7 +134,7 @@ int cvmx_range_reserve (uint64_t range_addr, uint64_t owner, uint64_t base, uint
 		r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		//cvmx_dprintf("%d: %llx\n", (int) i,(unsigned long long) r_owner);
 		if (r_owner != CVMX_RANGE_AVAILABLE) {
-			cvmx_dprintf("ERROR: failed to reserver base+cnt=%d \n", (int)i);
+			cvmx_dprintf("ERROR: failed to reserve base+cnt=%d \n", (int)i);
 			cvmx_range_show(range_addr);
 			return -1;
 		}
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 60772d5..aeda0f4 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -250,6 +250,8 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NIC4E_66 = 49,
 	CVMX_BOARD_TYPE_SNIC10E = 50,
 	CVMX_BOARD_TYPE_SNIC10E_61 = 51,
+	CVMX_BOARD_TYPE_IW_EVB = 52,
+	CVMX_BOARD_TYPE_CNF71XX_REF = 53,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -369,6 +371,8 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC4E_66)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SNIC10E)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SNIC10E_61)
+		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_IW_EVB)
+		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CNF71XX_REF)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		    /* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
index 330ec56..5e1b63f 100644
--- a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
@@ -82,7 +82,7 @@
  * internal cycle counter to completely eliminate any causes of
  * bus traffic.
  *
- * <hr> $Revision: 79133 $ <hr>
+ * <hr> $Revision$ <hr>
  */
 
 #ifndef __CVMX_CMD_QUEUE_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd.h b/arch/mips/include/asm/octeon/cvmx-ipd.h
index 1c87e9d..a1b60ca 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd.h
@@ -120,6 +120,14 @@ static inline uint64_t cvmx_fpa_get_packet_pool_block_size(void)
 }
 
 /**
+ * Gets the buffer count of packet pool
+ */
+static inline uint64_t cvmx_fpa_get_packet_pool_buffer_count(void)
+{
+	return (cvmx_ipd_cfg.packet_pool.buffer_count);
+}
+
+/**
  * Gets the fpa pool number of wqe pool
  */
 static inline int64_t cvmx_fpa_get_wqe_pool(void)
@@ -136,6 +144,14 @@ static inline uint64_t cvmx_fpa_get_wqe_pool_block_size(void)
 }
 
 /**
+ * Gets the buffer count of wqe pool
+ */
+static inline uint64_t cvmx_fpa_get_wqe_pool_buffer_count(void)
+{
+	return (cvmx_ipd_cfg.wqe_pool.buffer_count);
+}
+
+/**
  * Sets the ipd related configuration in internal structure which is then used
  * for seting IPD hardware block
  */
diff --git a/arch/mips/include/asm/octeon/cvmx-pko.h b/arch/mips/include/asm/octeon/cvmx-pko.h
index 6db1c1e..c8261d7 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko.h
@@ -243,16 +243,32 @@ typedef struct {
 } cvmx_pko_state_elem_t;
 
 extern CVMX_SHARED cvmx_fpa_pool_config_t pko_fpa_config;
+
+/**
+ * Gets the fpa pool number of pko pool
+ */
 static inline int64_t cvmx_fpa_get_pko_pool(void)
 {
 	return (pko_fpa_config.pool_num);
 }
+
+/**
+ * Gets the buffer size of pko pool
+ */
 static inline uint64_t cvmx_fpa_get_pko_pool_block_size(void)
 {
 	return (pko_fpa_config.buffer_size);
 }
 
 /**
+ * Gets the buffer size  of pko pool
+ */
+static inline uint64_t cvmx_fpa_get_pko_pool_buffer_count(void)
+{
+	return (pko_fpa_config.buffer_count);
+}
+
+/**
  * Sets the internal PKO pool data structure for command queue pool.
  * @param pool	fpa pool number yo use
  * @param buffer_size	buffer size of pool
diff --git a/arch/mips/include/asm/octeon/cvmx-pow-defs.h b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
index 6f614b1..be162b4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
@@ -86,17 +86,6 @@ static inline uint64_t CVMX_POW_ECC_ERR_FUNC(void)
 #define CVMX_POW_ECC_ERR (CVMX_ADD_IO_SEG(0x0001670000000218ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_POW_INT_CTL CVMX_POW_INT_CTL_FUNC()
-static inline uint64_t CVMX_POW_INT_CTL_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_POW_INT_CTL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001670000000220ull);
-}
-#else
-#define CVMX_POW_INT_CTL (CVMX_ADD_IO_SEG(0x0001670000000220ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_POW_IQ_CNTX(unsigned long offset)
 {
 	if (!(
@@ -792,50 +781,6 @@ union cvmx_pow_ecc_err {
 typedef union cvmx_pow_ecc_err cvmx_pow_ecc_err_t;
 
 /**
- * cvmx_pow_int_ctl
- *
- * POW_INT_CTL = POW Internal Control Register
- *
- * Contains POW internal control values (for internal use, not typically for customer use):
- *
- * PFR_DIS = Disable high-performance pre-fetch reset mode.
- *
- * NBR_THR = Assert ncb__busy when the number of remaining coherent bus NBR credits equals is less
- * than or equal to this value.
- */
-union cvmx_pow_int_ctl {
-	uint64_t u64;
-	struct cvmx_pow_int_ctl_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_6_63                : 58;
-	uint64_t pfr_dis                      : 1;  /**< High-perf pre-fetch reset mode disable */
-	uint64_t nbr_thr                      : 5;  /**< NBR busy threshold */
-#else
-	uint64_t nbr_thr                      : 5;
-	uint64_t pfr_dis                      : 1;
-	uint64_t reserved_6_63                : 58;
-#endif
-	} s;
-	struct cvmx_pow_int_ctl_s             cn30xx;
-	struct cvmx_pow_int_ctl_s             cn31xx;
-	struct cvmx_pow_int_ctl_s             cn38xx;
-	struct cvmx_pow_int_ctl_s             cn38xxp2;
-	struct cvmx_pow_int_ctl_s             cn50xx;
-	struct cvmx_pow_int_ctl_s             cn52xx;
-	struct cvmx_pow_int_ctl_s             cn52xxp1;
-	struct cvmx_pow_int_ctl_s             cn56xx;
-	struct cvmx_pow_int_ctl_s             cn56xxp1;
-	struct cvmx_pow_int_ctl_s             cn58xx;
-	struct cvmx_pow_int_ctl_s             cn58xxp1;
-	struct cvmx_pow_int_ctl_s             cn61xx;
-	struct cvmx_pow_int_ctl_s             cn63xx;
-	struct cvmx_pow_int_ctl_s             cn63xxp1;
-	struct cvmx_pow_int_ctl_s             cn66xx;
-	struct cvmx_pow_int_ctl_s             cnf71xx;
-};
-typedef union cvmx_pow_int_ctl cvmx_pow_int_ctl_t;
-
-/**
  * cvmx_pow_iq_cnt#
  *
  * POW_IQ_CNTX = POW Input Queue Count Register (1 per QOS level)
-- 
1.7.5.4

