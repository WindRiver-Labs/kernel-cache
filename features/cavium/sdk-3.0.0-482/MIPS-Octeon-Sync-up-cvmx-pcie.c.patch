From d1dc04ea3b0a1e5b1052e1b0605563ce45677b83 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Wed, 9 Jan 2013 11:31:57 -0800
Subject: [PATCH 300/337] MIPS: Octeon: Sync up cvmx-pcie.c.

Based On SDK 3.0.0-482

Added support for 2x1 DLM mode support in SFF6100 board.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-pcie.c |   57 ++++++++++++++++++-------
 1 files changed, 42 insertions(+), 15 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 287f685..345d94a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision$<hr>
+ * <hr>$Revision: 79783 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -958,22 +958,49 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	ciu_soft_prst_reg = (pcie_port) ?
 				 CVMX_CIU_SOFT_PRST1 : CVMX_CIU_SOFT_PRST;
 
-	/* Bring the PCIe out of reset */
-	ciu_soft_prst.u64 = cvmx_read_csr(ciu_soft_prst_reg);
-	/* After a chip reset the PCIe will also be in reset. If it
-	 * isn't, most likely someone is trying to init it again without
-	 * a proper PCIe reset
-	 */
-	if (ciu_soft_prst.s.soft_prst == 0) {
-		/* Reset the port */
-		ciu_soft_prst.s.soft_prst = 1;
+	/* On SFF6100 board, if QLM1 is configured as 2X1 DLM mode
+	   then first initialize PCIe1 followed by PCIe0. */
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SFF6100 &&
+	    (cvmx_read_csr(CVMX_MIO_QLMX_CFG(1)) & 0x7) == 1) {
+		if (pcie_port == 0) {
+			ciu_soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+			if (ciu_soft_prst.s.soft_prst == 0) {
+				/* Reset the port */
+				ciu_soft_prst.s.soft_prst = 1;	
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST1,
+					ciu_soft_prst.u64);
+				/* Wait until pcie resets the ports. */
+				cvmx_wait_usec(2000);
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST,
+					ciu_soft_prst.u64);
+				/* Wait until pcie resets the ports. */
+				cvmx_wait_usec(2000);
+			}
+			ciu_soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+			ciu_soft_prst.s.soft_prst = 0;
+			cvmx_write_csr(CVMX_CIU_SOFT_PRST1, ciu_soft_prst.u64);
+			ciu_soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+			ciu_soft_prst.s.soft_prst = 0;
+			cvmx_write_csr(CVMX_CIU_SOFT_PRST, ciu_soft_prst.u64);
+		}
+	} else {
+		/* Bring the PCIe out of reset */
+		ciu_soft_prst.u64 = cvmx_read_csr(ciu_soft_prst_reg);
+		/* After a chip reset the PCIe will also be in reset. If it
+	 	 * isn't, most likely someone is trying to init it again
+	 	 * without a proper PCIe reset.
+	 	 */
+		if (ciu_soft_prst.s.soft_prst == 0) {
+			/* Reset the port */
+			ciu_soft_prst.s.soft_prst = 1;
+			cvmx_write_csr(ciu_soft_prst_reg, ciu_soft_prst.u64);
+			/* Wait until pcie resets the ports. */
+			cvmx_wait_usec(2000);
+		}
+		ciu_soft_prst.u64 = cvmx_read_csr(ciu_soft_prst_reg);
+		ciu_soft_prst.s.soft_prst = 0;
 		cvmx_write_csr(ciu_soft_prst_reg, ciu_soft_prst.u64);
-		/* Wait until pcie resets the ports. */
-		cvmx_wait_usec(2000);
 	}
-	ciu_soft_prst.u64 = cvmx_read_csr(ciu_soft_prst_reg);
-	ciu_soft_prst.s.soft_prst = 0;
-	cvmx_write_csr(ciu_soft_prst_reg, ciu_soft_prst.u64);
 
 	/* Wait for PCIe reset to complete */
 	cvmx_wait_usec(1000);
-- 
1.7.5.4

