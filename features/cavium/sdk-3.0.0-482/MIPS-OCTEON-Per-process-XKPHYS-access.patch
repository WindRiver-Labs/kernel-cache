From cf64ff664d3c14441bcae050500de40de1a93c31 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 11 Apr 2012 13:29:59 -0700
Subject: [PATCH 040/337] MIPS: OCTEON: Per-process XKPHYS access.

Based On SDK 3.0.0-482

Access to XKPHYS from userspace can be one of:

o Disabled.

o Enabled via sysmips() call.

o Available for all processes.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig     |   58 +++++++++++++
 arch/mips/cavium-octeon/setup.c     |  155 +++++++++++++++++++++++++++++++++++
 arch/mips/include/asm/processor.h   |    5 +
 arch/mips/include/asm/sysmips.h     |   12 ++-
 arch/mips/include/asm/thread_info.h |    4 +
 arch/mips/kernel/ptrace.c           |   62 ++++++++++++++
 arch/mips/kernel/syscall.c          |    9 ++
 7 files changed, 300 insertions(+), 5 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 63a7d88..3641ec2 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -122,6 +122,64 @@ config CAVIUM_OCTEON_LOCK_L2_MEMCPY
 	help
 	  Lock the kernel's implementation of memcpy() into L2.
 
+choice
+	prompt "Allow User space to access hardware IO directly"
+	default CAVIUM_OCTEON_USER_IO_PER_PROCESS
+	depends on CPU_CAVIUM_OCTEON
+
+config CAVIUM_OCTEON_USER_IO
+	bool "Allowed"
+	depends on CPU_CAVIUM_OCTEON
+	help
+	  Allows user applications to directly access the Octeon hardware
+	  IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
+	  performance networking applications to run in user space with minimal
+	  performance penalties. This also means a user application can bring
+	  down the entire system. Only use this option on embedded devices
+	  where all user applications are strictly controlled.
+
+config CAVIUM_OCTEON_USER_IO_PER_PROCESS
+	bool "Per process"
+	help
+	  Allows user applications to use XKPHYS addresses directly to IO.
+	  This option dynamically enable/disable with sysmips syscall,
+	  by a process with root privilege. Without root privilege you can
+	  only remove access.
+
+config CAVIUM_OCTEON_USER_IO_DISABLED
+	bool "Disabled"
+
+endchoice
+
+choice
+	prompt "Allow User space to access memory directly"
+	default CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+	depends on CPU_CAVIUM_OCTEON
+
+config CAVIUM_OCTEON_USER_MEM
+	bool "Allowed"
+	help
+	  Allows user applications to use XKPHYS addresses directly to memory.
+	  This allows user space direct access to shared memory not in use by
+	  Linux. This memory is suitable for use with the Octeon hardware.
+	  Cavium simple executive applications also share this memory. Since
+	  this bypass all of the Linux memory protection, only use this option
+	  on embedded devices where all user applications are strictly
+	  controlled.
+
+config CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+	bool "Per process"
+	help
+	  Allows user applications to use XKPHYS addresses directly to memory.
+	  This option dynamically enable/disable with sysmips syscall,
+	  by a process with root privilege. Without root privilege you can only
+	  remove access.
+
+config CAVIUM_OCTEON_USER_MEM_DISABLED
+	bool "Disabled"
+
+endchoice
+
 config ARCH_SPARSEMEM_ENABLE
 	def_bool y
 	select SPARSEMEM_STATIC
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index c2a21cb..703d8b2 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -321,7 +321,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==0 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	cvmmemctl.s.xkmemenau = 1;
+#else
 	cvmmemctl.s.xkmemenau = 0;
+#endif
 
 	/* R/W If set (and SX set), supervisor-level loads/stores can
 	 * use XKPHYS addresses with VA<48>==1 */
@@ -329,7 +333,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==1 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO
+	cvmmemctl.s.xkioenau = 1;
+#else
 	cvmmemctl.s.xkioenau = 0;
+#endif
 
 	/* R/W If set, all stores act as SYNCW (NOMERGE must be set
 	 * when this is set) RW, reset to 0. */
@@ -407,6 +415,153 @@ void octeon_user_io_init(void)
 	write_octeon_c0_icacheerr(0);
 	write_c0_derraddr1(0);
 }
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+
+void octeon_prepare_arch_switch(struct task_struct *next)
+{
+	struct task_struct *group_leader = next->group_leader;
+	union octeon_cvmemctl cvmmemctl;
+	cvmmemctl.u64 = read_c0_cvmmemctl();
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	cvmmemctl.s.xkmemenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN) ? 1 : 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	cvmmemctl.s.xkioenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN) ? 1 : 0;
+#endif
+	write_c0_cvmmemctl(cvmmemctl.u64);
+}
+#else
+static void octeon_prepare_arch_switch(struct task_struct *next)
+{
+}
+#endif
+
+static struct task_struct *xkphys_get_task(pid_t pid)
+{
+	struct task_struct *task, *group_leader;
+
+	rcu_read_lock();
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		read_unlock(&tasklist_lock);
+		return NULL;
+	}
+	group_leader = task->group_leader;
+	get_task_struct(group_leader);
+
+	rcu_read_unlock();
+	return group_leader;
+}
+
+int xkphys_usermem_read(long pid)
+{
+	struct task_struct *task;
+	int io, mem;
+
+	task = xkphys_get_task(pid);
+	if (!task)
+		return -ESRCH;
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	io = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	io = test_tsk_thread_flag(task, TIF_XKPHYS_IO_EN);
+#else
+	io = 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	mem = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	mem = test_tsk_thread_flag(task, TIF_XKPHYS_MEM_EN);
+#else
+	mem = 0;
+#endif
+	put_task_struct(task);
+	return (io ? 2 : 0) | (mem ? 1 : 0);
+}
+
+/* the caller must hold RCU read lock */
+int is_task_and_current_same(struct task_struct *t)
+{
+	const struct cred *cred = current_cred(), *tcred;
+
+	tcred = __task_cred(t);
+	if ((cred->euid ^ tcred->suid) &&
+	    (cred->euid ^ tcred->uid) &&
+	    (cred->uid  ^ tcred->suid) &&
+	    (cred->uid  ^ tcred->uid)) {
+		return 0;
+	}
+	return 1;
+}
+
+int xkphys_usermem_write(long pid, int value)
+{
+	struct task_struct *task, *group_leader;
+	int permission_ok = 0;
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	if ((value & 2) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	if (value & 2)
+		return -EINVAL;
+#endif
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	if ((value & 1) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	if (value & 1)
+		return -EINVAL;
+#endif
+
+	task = xkphys_get_task(pid);
+	group_leader = task->group_leader;
+
+	if (!task)
+		return -ESRCH;
+
+	rcu_read_lock();
+	/* Allow XKPHYS disable of other tasks from the current user*/
+	if (value == 0 && is_task_and_current_same(task))
+		permission_ok = 1;
+	rcu_read_unlock();
+
+	if (capable(CAP_SYS_RAWIO))
+		permission_ok = 1;
+
+	if (!permission_ok) {
+		put_task_struct(task);
+		return -EPERM;
+	}
+
+	if (value & 1)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+
+	if (value & 2)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+
+	preempt_disable();
+
+	/*
+	 * If we are adjusting ourselves, make the change effective
+	 * immediatly.
+	 */
+	if (group_leader == current->group_leader)
+		octeon_prepare_arch_switch(current);
+
+	preempt_enable();
+
+	put_task_struct(task);
+	return 0;
+}
 
 /**
  * Early entry point for arch setup
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index 20e9dcf..233afbf 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -363,4 +363,9 @@ unsigned long get_wchan(struct task_struct *p);
 
 #endif
 
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+#define prepare_arch_switch(next)  octeon_prepare_arch_switch(next)
+extern void octeon_prepare_arch_switch(struct task_struct *next);
+#endif
+
 #endif /* _ASM_PROCESSOR_H */
diff --git a/arch/mips/include/asm/sysmips.h b/arch/mips/include/asm/sysmips.h
index 4f47b7d..065b33c 100644
--- a/arch/mips/include/asm/sysmips.h
+++ b/arch/mips/include/asm/sysmips.h
@@ -16,10 +16,12 @@
  * sysmips(2) is deprecated - though some existing software uses it.
  * We only support the following commands.
  */
-#define SETNAME                    1	/* set hostname                  */
-#define FLUSH_CACHE		   3	/* writeback and invalidate caches */
-#define MIPS_FIXADE                7	/* control address error fixing  */
-#define MIPS_RDNVRAM              10	/* read NVRAM */
-#define MIPS_ATOMIC_SET		2001	/* atomically set variable       */
+#define SETNAME                     1	/* set hostname                  */
+#define FLUSH_CACHE		    3	/* writeback and invalidate caches */
+#define MIPS_FIXADE                 7	/* control address error fixing  */
+#define MIPS_RDNVRAM               10	/* read NVRAM */
+#define MIPS_ATOMIC_SET		 2001	/* atomically set variable       */
+#define MIPS_CAVIUM_XKPHYS_READ  2010	/* XKPHYS */
+#define MIPS_CAVIUM_XKPHYS_WRITE 2011	/* XKPHYS */
 
 #endif /* _ASM_SYSMIPS_H */
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index 9778e32..b4cd283 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -123,6 +123,8 @@ register struct thread_info *__current_thread_info __asm__("$28");
 #define TIF_32BIT_ADDR		23	/* 32-bit address space (o32/n32) */
 #define TIF_FPUBOUND		24	/* thread bound to FPU-full CPU set */
 #define TIF_LOAD_WATCH		25	/* If set, load watch registers */
+#define TIF_XKPHYS_MEM_EN	26
+#define TIF_XKPHYS_IO_EN	27
 #define TIF_KERNEL_TRACE	30	/* kernel trace active */
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
@@ -148,6 +150,8 @@ register struct thread_info *__current_thread_info __asm__("$28");
 #define _TIF_32BIT_ADDR		(1<<TIF_32BIT_ADDR)
 #define _TIF_FPUBOUND		(1<<TIF_FPUBOUND)
 #define _TIF_LOAD_WATCH		(1<<TIF_LOAD_WATCH)
+#define _TIF_XKPHYS_MEM_EN	(1<<TIF_XKPHYS_MEM_EN)
+#define _TIF_XKPHYS_IO_EN	(1<<TIF_XKPHYS_IO_EN)
 
 /* work to do in syscall_trace_leave() */
 #define _TIF_WORK_SYSCALL_EXIT	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT)
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 5729343..2d4d476 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -39,6 +39,10 @@
 #include <asm/bootinfo.h>
 #include <asm/reg.h>
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/octeon/octeon.h>
+#endif
+
 DEFINE_TRACE(syscall_entry);
 DEFINE_TRACE(syscall_exit);
 
@@ -270,6 +274,64 @@ long arch_ptrace(struct task_struct *child, long request,
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
 	case PTRACE_PEEKDATA:
+		ret = -EIO;
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+		/* check whether its a XKPHYS IO addr (we only allow the
+		   0x80xx.. alias) */
+		if (((unsigned long)addr >> 48) == 0x8001) {
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS
+			struct task_struct *group_leader;
+
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN))
+				break;
+#endif
+			ret = put_user(*(unsigned long *)addr,
+					(unsigned long __user *) data);
+			break;
+		}
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_IO_DISABLED) */
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+		/* check whether its a XKPHYS MEM addr */
+		if (((unsigned long)addr >> 48) == 0x8000) {
+			unsigned long tmp;
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+			struct task_struct *group_leader;
+
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN))
+				break;
+#endif
+			ret = -EIO;
+			/* ensure that task is 64 bit */
+			if (test_tsk_thread_flag(child, TIF_32BIT_ADDR))
+				break;
+
+			/* extract phy addr from XKPHYS alias */
+			tmp = (unsigned long)addr - 0x8000000000000000ull;
+
+			/* check for boot-bus addr range */
+			if ((tmp >= 0x10000000) && (tmp < 0x20000000))
+				break;
+
+			/* this is for the dram_size comparison below */
+			if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
+				/* subtract 256MB hole for dram_size comparison */
+				if (tmp >= 0x20000000ull)
+					tmp -= 0x10000000ull;
+			} else {
+				if ((tmp >= 0x410000000ull) && (tmp < 0x420000000ull))
+					tmp -= 0x400000000ull;
+			}
+
+			/* verify that "addr" is within installed dram */
+			if (tmp <= ((octeon_bootinfo->dram_size << 20) - sizeof(tmp)))
+				ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
+
+			break;
+		}
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) */
+
 		ret = generic_ptrace_peekdata(child, addr, data);
 		break;
 
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index ed97e67..3cb5bc6 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -44,6 +44,9 @@
 #include <asm/uaccess.h>
 #include <asm/switch_to.h>
 
+extern int xkphys_usermem_read(long);
+extern int xkphys_usermem_write(long, int);
+
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.  It returns results in registers $v0 / $v1 which means there
@@ -300,6 +303,12 @@ _sys_sysmips(nabi_no_regargs struct pt_regs regs)
 	case FLUSH_CACHE:
 		__flush_cache_all();
 		return 0;
+
+	case MIPS_CAVIUM_XKPHYS_READ:
+		return xkphys_usermem_read(arg1);
+
+	case MIPS_CAVIUM_XKPHYS_WRITE:
+		return xkphys_usermem_write(arg1, arg2);
 	}
 
 	return -EINVAL;
-- 
1.7.5.4

