From 93629f0f78e6cb24438db62147a954a74c56589b Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 18 Jan 2013 14:35:52 -0800
Subject: [PATCH 330/337] MIPS: OCTEON: Fix enabling and disabling of error
 tree bits.

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/octeon-error-tree.c |   53 ++++++++++++++++-----------
 1 files changed, 31 insertions(+), 22 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-error-tree.c b/arch/mips/cavium-octeon/octeon-error-tree.c
index 9f0abc5..9b1aa9f 100644
--- a/arch/mips/cavium-octeon/octeon-error-tree.c
+++ b/arch/mips/cavium-octeon/octeon-error-tree.c
@@ -28,16 +28,17 @@ static void octeon_error_tree_remove(int idx, int max_idx, struct cvmx_error_mux
 	struct cvmx_error_childbit *child;
 	bit = n->bits;
 
-	while (bit && bit->valid && bit->group == group && (unit < 0 || unit == bit->unit)) {
-		struct octeon_hw_status_reg r;
-
-		memset(&r, 0, sizeof(r));
-		r.reg = n->reg;
-		r.mask_reg = n->mask_reg;
-		r.bit = bit->bit;
-		r.ack_w1c = bit->w1c;
-		octeon_hw_status_remove_source(&r);
-
+	while (bit && bit->valid) {
+		if ( bit->group == group && (unit < 0 || unit == bit->unit)) {
+			struct octeon_hw_status_reg r;
+
+			memset(&r, 0, sizeof(r));
+			r.reg = n->reg;
+			r.mask_reg = n->mask_reg;
+			r.bit = bit->bit;
+			r.ack_w1c = bit->w1c;
+			octeon_hw_status_remove_source(&r);
+		}
 		bit++;
 	}
 
@@ -68,14 +69,15 @@ static void octeon_error_tree_add(struct octeon_hw_status_reg *sr,
 	sr[idx].reg = n->reg;
 	sr[idx].mask_reg = n->mask_reg;
 
-	while (bit && bit->valid && bit->group == group && (unit < 0 || unit == bit->unit)) {
-		sr[idx].bit = bit->bit;
-		sr[idx].ack_w1c = bit->w1c;
-		sr[idx].has_child = 0;
-		octeon_hw_status_add_source(sr);
-		/* Enable it now. */
-		octeon_hw_status_enable(n->reg, 1ull << bit->bit);
-
+	while (bit && bit->valid) {
+		if (bit->group == group && (unit < 0 || unit == bit->unit)) {
+			sr[idx].bit = bit->bit;
+			sr[idx].ack_w1c = bit->w1c;
+			sr[idx].has_child = 0;
+			octeon_hw_status_add_source(sr);
+			/* Enable it now. */
+			octeon_hw_status_enable(n->reg, 1ull << bit->bit);
+		}
 		bit++;
 	}
 
@@ -187,8 +189,11 @@ int octeon_error_tree_disable(enum cvmx_error_groups group, int unit)
 
 		line = base->children;
 		while (line && line->valid) {
-			octeon_error_tree_remove(1, 5, line->children,
-						 group, unit);
+			struct cvmx_error_muxchild *child = line->children;
+			while (child->reg) {
+				octeon_error_tree_remove(1, 5, child, group, unit);
+				child++;
+			}
 			line++;
 		}
 		base++;
@@ -221,11 +226,15 @@ int octeon_error_tree_enable(enum cvmx_error_groups group, int unit)
 
 		line = base->children;
 		while (line && line->valid) {
+			struct cvmx_error_muxchild *child = line->children;
 			sr[0].reg = irq_reg << 6 | line->bit;
 			sr[0].reg_is_hwint = 1;
 			sr[0].has_child = 1;
-			octeon_error_tree_add(sr, 1, ARRAY_SIZE(sr) - 1, line->children,
-					      group, unit);
+			while (child->reg) {
+				octeon_error_tree_add(sr, 1, ARRAY_SIZE(sr) - 1, child,
+						      group, unit);
+				child++;
+			}
 			line++;
 		}
 		base++;
-- 
1.7.5.4

