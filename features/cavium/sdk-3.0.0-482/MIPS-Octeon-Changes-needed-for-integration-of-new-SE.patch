From d554a006048f40fd5bc0fa7856e64295e05efd6f Mon Sep 17 00:00:00 2001
From: Rajeev Surampally <rsurampally@cavium.com>
Date: Sun, 2 Dec 2012 21:14:33 -0800
Subject: [PATCH 255/337] MIPS: Octeon: Changes needed for integration of new
 SE files.

Based On SDK 3.0.0-482

Signed-off-by: Rajeev Surampally <rsurampally@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/Makefile                              |   18 ++
 arch/mips/cavium-octeon/dma-octeon.c            |    4 +-
 arch/mips/cavium-octeon/executive/Makefile      |    9 +-
 arch/mips/cavium-octeon/octeon-irq.c            |    2 +-
 arch/mips/cavium-octeon/octeon-power-throttle.c |    2 +-
 arch/mips/cavium-octeon/setup.c                 |    4 +
 arch/mips/include/asm/octeon/cvmx-bootinfo.h    |  371 +----------------------
 arch/mips/include/asm/octeon/cvmx.h             |   58 +++--
 arch/mips/include/asm/octeon/octeon.h           |    2 +
 arch/mips/pci/pci-octeon.c                      |    3 +-
 10 files changed, 77 insertions(+), 396 deletions(-)

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 1f388ab..2f21d3a 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -171,6 +171,24 @@ endif
 endif
 
 cflags-$(CONFIG_CAVIUM_CN63XXP1) += -Wa,-mfix-cn63xxp1
+cflags-$(CONFIG_CPU_CAVIUM_OCTEON) += -DCVMX_BUILD_FOR_LINUX_KERNEL=1 -DUSE_RUNTIME_MODEL_CHECKS=1
+
+ifdef  CONFIG_CAVIUM_OCTEON_CHK_CVMX_PARAMETER
+cflags-y += -DCVMX_ENABLE_PARAMETER_CHECKING=1
+else
+cflags-y += -DCVMX_ENABLE_PARAMETER_CHECKING=0
+endif
+ifdef  CONFIG_CAVIUM_OCTEON_CHK_CVMX_ADDRESS
+cflags-y += -DCVMX_ENABLE_CSR_ADDRESS_CHECKING=1
+else
+cflags-y += -DCVMX_ENABLE_CSR_ADDRESS_CHECKING=0
+endif
+ifdef  CONFIG_CAVIUM_OCTEON_CHK_CVMX_POW
+cflags-y += -DCVMX_ENABLE_POW_CHECKS=1
+else
+cflags-y += -DCVMX_ENABLE_POW_CHECKS=0
+endif
+
 cflags-$(CONFIG_CPU_BMIPS)	+= -march=mips32 -Wa,-mips32 -Wa,--trap
 
 cflags-$(CONFIG_CPU_R4000_WORKAROUNDS)	+= $(call cc-option,-mfix-r4000,)
diff --git a/arch/mips/cavium-octeon/dma-octeon.c b/arch/mips/cavium-octeon/dma-octeon.c
index 89f5f03..b968c5f 100644
--- a/arch/mips/cavium-octeon/dma-octeon.c
+++ b/arch/mips/cavium-octeon/dma-octeon.c
@@ -276,7 +276,7 @@ void __init plat_swiotlb_setup(void)
 			continue;
 
 		/* These addresses map low for PCI. */
-		if (e->addr > 0x410000000ull && !OCTEON_IS_MODEL(OCTEON_FAM_2))
+		if (e->addr > 0x410000000ull && !OCTEON_IS_OCTEON2())
 			continue;
 
 		addr_size += e->size;
@@ -308,7 +308,7 @@ void __init plat_swiotlb_setup(void)
 #endif
 #ifdef CONFIG_USB_OCTEON_OHCI
 	/* OCTEON II ohci is only 32-bit. */
-	if (OCTEON_IS_MODEL(OCTEON_FAM_2) && max_addr >= 0x100000000ul)
+	if (OCTEON_IS_OCTEON2() && max_addr >= 0x100000000ul)
 		swiotlbsize = 64 * (1<<20);
 #endif
 	swiotlb_nslabs = swiotlbsize >> IO_TLB_SHIFT;
diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 06dcd92..56ffe16 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -11,8 +11,8 @@
 
 obj-y += cvmx-bootmem.o cvmx-l2c.o cvmx-sysinfo.o octeon-model.o
 obj-y += cvmx-pko.o cvmx-spi.o cvmx-spi4000.o cvmx-cmd-queue.o cvmx-ipd.o \
-	cvmx-ilk.o cvmx-srio.o cvmx-qlm.o cvmx-qlm-tables.o cvmx-twsi.o
-
+	cvmx-ilk.o cvmx-srio.o cvmx-qlm.o cvmx-qlm-tables.o cvmx-twsi.o \
+	cvmx-fpa-resource.o
 
 obj-y += cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o \
@@ -24,6 +24,11 @@ obj-y += cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 
+obj-y += cvmx-global-resources.o cvmx-range.o \
+	cvmx-pko-internal-ports-range.o
+
+obj-y += cvmx-clock.o octeon-feature.o
+
 obj-$(CONFIG_USB_OCTEON_HCD) += cvmx-usb.o
 obj-$(CONFIG_CAVIUM_OCTEON_RAPIDIO) += cvmx-dma-engine.o
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)	+= cvmx-nand.o
diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index f292855..0650657 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -1239,7 +1239,7 @@ static void __init octeon_irq_init_ciu(void)
 	if (OCTEON_IS_MODEL(OCTEON_CN58XX_PASS2_X) ||
 	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS2_X) ||
 	    OCTEON_IS_MODEL(OCTEON_CN52XX_PASS2_X) ||
-	    OCTEON_IS_MODEL(OCTEON_FAM_2)) {
+	    OCTEON_IS_OCTEON2()) {
 		chip = &octeon_irq_chip_ciu_v2;
 		chip_edge = &octeon_irq_chip_ciu_v2_edge;
 		chip_mbox = &octeon_irq_chip_ciu_mbox_v2;
diff --git a/arch/mips/cavium-octeon/octeon-power-throttle.c b/arch/mips/cavium-octeon/octeon-power-throttle.c
index ae6a3d1..5b5dd89 100644
--- a/arch/mips/cavium-octeon/octeon-power-throttle.c
+++ b/arch/mips/cavium-octeon/octeon-power-throttle.c
@@ -198,7 +198,7 @@ static __init int octeon_power_throttle_init(void)
 	unsigned int cpu = 0;
 	int err = 0;
 
-	if (!OCTEON_IS_MODEL(OCTEON_FAM_2))
+	if (!OCTEON_IS_OCTEON2())
 		return 0;
 
 	get_online_cpus();
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index bdf5f3a..9ab9782 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -159,6 +159,10 @@ static int octeon_uart;
 extern asmlinkage void handle_int(void);
 extern asmlinkage void plat_irq_dispatch(void);
 
+/* Any mdio busses that are configured for this kernel. */
+struct mii_bus *octeon_mdiobuses[4];
+EXPORT_SYMBOL(octeon_mdiobuses);
+
 /*
  * If set to a non-zero value, the bootloader entry point for
  * HOTPLUG_CPU and other tricks.
diff --git a/arch/mips/include/asm/octeon/cvmx-bootinfo.h b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
index f921d31..110b5a3 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootinfo.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
@@ -29,374 +29,5 @@
  * Header file containing the ABI with the bootloader.
  */
 
-#ifndef __CVMX_BOOTINFO_H__
-#define __CVMX_BOOTINFO_H__
+#include "cvmx-app-init.h"
 
-/*
- * Current major and minor versions of the CVMX bootinfo block that is
- * passed from the bootloader to the application.  This is versioned
- * so that applications can properly handle multiple bootloader
- * versions.
- */
-#define CVMX_BOOTINFO_MAJ_VER 1
-#define CVMX_BOOTINFO_MIN_VER 3
-
-#if (CVMX_BOOTINFO_MAJ_VER == 1)
-#define CVMX_BOOTINFO_OCTEON_SERIAL_LEN 20
-/*
- * This structure is populated by the bootloader.  For binary
- * compatibility the only changes that should be made are
- * adding members to the end of the structure, and the minor
- * version should be incremented at that time.
- * If an incompatible change is made, the major version
- * must be incremented, and the minor version should be reset
- * to 0.
- */
-struct cvmx_bootinfo {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t major_version;
-	uint32_t minor_version;
-
-	uint64_t stack_top;
-	uint64_t heap_base;
-	uint64_t heap_end;
-	uint64_t desc_vaddr;
-
-	uint32_t exception_base_addr;
-	uint32_t stack_size;
-	uint32_t flags;
-	uint32_t core_mask;
-	/* DRAM size in megabytes */
-	uint32_t dram_size;
-	/* physical address of free memory descriptor block*/
-	uint32_t phy_mem_desc_addr;
-	/* used to pass flags from app to debugger */
-	uint32_t debugger_flags_base_addr;
-
-	/* CPU clock speed, in hz */
-	uint32_t eclock_hz;
-
-	/* DRAM clock speed, in hz */
-	uint32_t dclock_hz;
-
-	uint32_t reserved0;
-	uint16_t board_type;
-	uint8_t board_rev_major;
-	uint8_t board_rev_minor;
-	uint16_t reserved1;
-	uint8_t reserved2;
-	uint8_t reserved3;
-	char board_serial_number[CVMX_BOOTINFO_OCTEON_SERIAL_LEN];
-	uint8_t mac_addr_base[6];
-	uint8_t mac_addr_count;
-#if (CVMX_BOOTINFO_MIN_VER >= 1)
-	/*
-	 * Several boards support compact flash on the Octeon boot
-	 * bus.  The CF memory spaces may be mapped to different
-	 * addresses on different boards.  These are the physical
-	 * addresses, so care must be taken to use the correct
-	 * XKPHYS/KSEG0 addressing depending on the application's
-	 * ABI.  These values will be 0 if CF is not present.
-	 */
-	uint64_t compact_flash_common_base_addr;
-	uint64_t compact_flash_attribute_base_addr;
-	/*
-	 * Base address of the LED display (as on EBT3000 board)
-	 * This will be 0 if LED display not present.
-	 */
-	uint64_t led_display_base_addr;
-#endif
-#if (CVMX_BOOTINFO_MIN_VER >= 2)
-	/* DFA reference clock in hz (if applicable)*/
-	uint32_t dfa_ref_clock_hz;
-
-	/*
-	 * flags indicating various configuration options.  These
-	 * flags supercede the 'flags' variable and should be used
-	 * instead if available.
-	 */
-	uint32_t config_flags;
-#endif
-#if (CVMX_BOOTINFO_MIN_VER >= 3)
-	/*
-	 * Address of the OF Flattened Device Tree structure
-	 * describing the board.
-	 */
-	uint64_t fdt_addr;
-#endif
-#else				/* __BIG_ENDIAN */
-	/*
-	 * Little-Endian: When the CPU mode is switched to
-	 * little-endian, the view of the structure has some of the
-	 * fields swapped.
-	 */
-	uint32_t minor_version;
-	uint32_t major_version;
-
-	uint64_t stack_top;
-	uint64_t heap_base;
-	uint64_t heap_end;
-	uint64_t desc_vaddr;
-
-	uint32_t stack_size;
-	uint32_t exception_base_addr;
-
-	uint32_t core_mask;
-	uint32_t flags;
-
-	uint32_t phy_mem_desc_addr;
-	uint32_t dram_size;
-
-	uint32_t eclock_hz;
-	uint32_t debugger_flags_base_addr;
-
-	uint32_t reserved0;
-	uint32_t dclock_hz;
-
-	uint8_t reserved3;
-	uint8_t reserved2;
-	uint16_t reserved1;
-	uint8_t board_rev_minor;
-	uint8_t board_rev_major;
-	uint16_t board_type;
-
-	char board_serial_number[CVMX_BOOTINFO_OCTEON_SERIAL_LEN];
-	uint8_t mac_addr_base[6];
-	uint8_t mac_addr_count;
-	uint8_t pad[5];
-
-#if (CVMX_BOOTINFO_MIN_VER >= 1)
-	uint64_t compact_flash_common_base_addr;
-	uint64_t compact_flash_attribute_base_addr;
-	uint64_t led_display_base_addr;
-#endif
-#if (CVMX_BOOTINFO_MIN_VER >= 2)
-	uint32_t config_flags;
-	uint32_t dfa_ref_clock_hz;
-#endif
-#if (CVMX_BOOTINFO_MIN_VER >= 3)
-	uint64_t fdt_addr;
-#endif
-#endif
-};
-
-#define CVMX_BOOTINFO_CFG_FLAG_PCI_HOST			(1ull << 0)
-#define CVMX_BOOTINFO_CFG_FLAG_PCI_TARGET		(1ull << 1)
-#define CVMX_BOOTINFO_CFG_FLAG_DEBUG			(1ull << 2)
-#define CVMX_BOOTINFO_CFG_FLAG_NO_MAGIC			(1ull << 3)
-/* This flag is set if the TLB mappings are not contained in the
- * 0x10000000 - 0x20000000 boot bus region. */
-#define CVMX_BOOTINFO_CFG_FLAG_OVERSIZE_TLB_MAPPING     (1ull << 4)
-#define CVMX_BOOTINFO_CFG_FLAG_BREAK			(1ull << 5)
-
-#endif /*   (CVMX_BOOTINFO_MAJ_VER == 1) */
-
-/* Type defines for board and chip types */
-enum cvmx_board_types_enum {
-	CVMX_BOARD_TYPE_NULL = 0,
-	CVMX_BOARD_TYPE_SIM = 1,
-	CVMX_BOARD_TYPE_EBT3000 = 2,
-	CVMX_BOARD_TYPE_KODAMA = 3,
-	CVMX_BOARD_TYPE_NIAGARA = 4,
-	CVMX_BOARD_TYPE_NAC38 = 5,	/* formerly NAO38 */
-	CVMX_BOARD_TYPE_THUNDER = 6,
-	CVMX_BOARD_TYPE_TRANTOR = 7,
-	CVMX_BOARD_TYPE_EBH3000 = 8,
-	CVMX_BOARD_TYPE_EBH3100 = 9,
-	CVMX_BOARD_TYPE_HIKARI = 10,
-	CVMX_BOARD_TYPE_CN3010_EVB_HS5 = 11,
-	CVMX_BOARD_TYPE_CN3005_EVB_HS5 = 12,
-	CVMX_BOARD_TYPE_KBP = 13,
-	/* Deprecated, CVMX_BOARD_TYPE_CN3010_EVB_HS5 supports the CN3020 */
-	CVMX_BOARD_TYPE_CN3020_EVB_HS5 = 14,
-	CVMX_BOARD_TYPE_EBT5800 = 15,
-	CVMX_BOARD_TYPE_NICPRO2 = 16,
-	CVMX_BOARD_TYPE_EBH5600 = 17,
-	CVMX_BOARD_TYPE_EBH5601 = 18,
-	CVMX_BOARD_TYPE_EBH5200 = 19,
-	CVMX_BOARD_TYPE_BBGW_REF = 20,
-	CVMX_BOARD_TYPE_NIC_XLE_4G = 21,
-	CVMX_BOARD_TYPE_EBT5600 = 22,
-	CVMX_BOARD_TYPE_EBH5201 = 23,
-	CVMX_BOARD_TYPE_EBT5200 = 24,
-	CVMX_BOARD_TYPE_CB5600  = 25,
-	CVMX_BOARD_TYPE_CB5601  = 26,
-	CVMX_BOARD_TYPE_CB5200  = 27,
-	/* Special 'generic' board type, supports many boards */
-	CVMX_BOARD_TYPE_GENERIC = 28,
-	CVMX_BOARD_TYPE_EBH5610 = 29,
-	CVMX_BOARD_TYPE_LANAI2_A = 30,
-	CVMX_BOARD_TYPE_LANAI2_U = 31,
-	CVMX_BOARD_TYPE_EBB5600 = 32,
-	CVMX_BOARD_TYPE_EBB6300 = 33,
-	CVMX_BOARD_TYPE_NIC_XLE_10G = 34,
-	CVMX_BOARD_TYPE_LANAI2_G = 35,
-	CVMX_BOARD_TYPE_EBT5810 = 36,
-	CVMX_BOARD_TYPE_NIC10E = 37,
-	CVMX_BOARD_TYPE_EP6300C = 38,
-	CVMX_BOARD_TYPE_EBB6800 = 39,
-	CVMX_BOARD_TYPE_NIC4E = 40,
-	CVMX_BOARD_TYPE_NIC2E = 41,
-	CVMX_BOARD_TYPE_EBB6600 = 42,
-	CVMX_BOARD_TYPE_REDWING = 43,
-	CVMX_BOARD_TYPE_NIC68_4 = 44,
-	CVMX_BOARD_TYPE_NIC10E_66 = 45,
-	CVMX_BOARD_TYPE_MAX,
-
-	/*
-	 * The range from CVMX_BOARD_TYPE_MAX to
-	 * CVMX_BOARD_TYPE_CUST_DEFINED_MIN is reserved for future
-	 * SDK use.
-	 */
-
-	/*
-	 * Set aside a range for customer boards.  These numbers are managed
-	 * by Cavium.
-	 */
-	CVMX_BOARD_TYPE_CUST_DEFINED_MIN = 10000,
-	CVMX_BOARD_TYPE_CUST_WSX16 = 10001,
-	CVMX_BOARD_TYPE_CUST_NS0216 = 10002,
-	CVMX_BOARD_TYPE_CUST_NB5 = 10003,
-	CVMX_BOARD_TYPE_CUST_WMR500 = 10004,
-	CVMX_BOARD_TYPE_CUST_ITB101 = 10005,
-	CVMX_BOARD_TYPE_CUST_NTE102 = 10006,
-	CVMX_BOARD_TYPE_CUST_AGS103 = 10007,
-	CVMX_BOARD_TYPE_CUST_GST104 = 10008,
-	CVMX_BOARD_TYPE_CUST_GCT105 = 10009,
-	CVMX_BOARD_TYPE_CUST_AGS106 = 10010,
-	CVMX_BOARD_TYPE_CUST_SGM107 = 10011,
-	CVMX_BOARD_TYPE_CUST_GCT108 = 10012,
-	CVMX_BOARD_TYPE_CUST_AGS109 = 10013,
-	CVMX_BOARD_TYPE_CUST_GCT110 = 10014,
-	CVMX_BOARD_TYPE_CUST_L2_AIR_SENDER = 10015,
-	CVMX_BOARD_TYPE_CUST_L2_AIR_RECEIVER = 10016,
-	CVMX_BOARD_TYPE_CUST_L2_ACCTON2_TX = 10017,
-	CVMX_BOARD_TYPE_CUST_L2_ACCTON2_RX = 10018,
-	CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_TX = 10019,
-	CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_RX = 10020,
-	CVMX_BOARD_TYPE_CUST_L2_ZINWELL = 10021,
-	CVMX_BOARD_TYPE_CUST_DEFINED_MAX = 20000,
-
-	/*
-	 * Set aside a range for customer private use.  The SDK won't
-	 * use any numbers in this range.
-	 */
-	CVMX_BOARD_TYPE_CUST_PRIVATE_MIN = 20001,
-	CVMX_BOARD_TYPE_CUST_PRIVATE_MAX = 30000,
-
-	/* The remaining range is reserved for future use. */
-};
-
-enum cvmx_chip_types_enum {
-	CVMX_CHIP_TYPE_NULL = 0,
-	CVMX_CHIP_SIM_TYPE_DEPRECATED = 1,
-	CVMX_CHIP_TYPE_OCTEON_SAMPLE = 2,
-	CVMX_CHIP_TYPE_MAX,
-};
-
-/* Compatibility alias for NAC38 name change, planned to be removed
- * from SDK 1.7 */
-#define CVMX_BOARD_TYPE_NAO38	CVMX_BOARD_TYPE_NAC38
-
-/* Functions to return string based on type */
-#define ENUM_BRD_TYPE_CASE(x) \
-	case x: return(#x + 16);	/* Skip CVMX_BOARD_TYPE_ */
-static inline const char *cvmx_board_type_to_string(enum
-						    cvmx_board_types_enum type)
-{
-	switch (type) {
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NULL)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SIM)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT3000)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_KODAMA)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NAC38)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_THUNDER)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_TRANTOR)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH3000)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH3100)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_HIKARI)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3010_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3005_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_KBP)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3020_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5800)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NICPRO2)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5601)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_BBGW_REF)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC_XLE_4G)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5201)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5601)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_GENERIC)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5610)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_LANAI2_A)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_LANAI2_U)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB6300)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC_XLE_10G)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_LANAI2_G)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5810)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC10E)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EP6300C)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB6800)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC4E)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC2E)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB6600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_REDWING)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC68_4)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC10E_66)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
-
-			/* Customer boards listed here */
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_DEFINED_MIN)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_WSX16)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_NS0216)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_NB5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_WMR500)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_ITB101)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_NTE102)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_AGS103)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_GST104)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_GCT105)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_AGS106)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_SGM107)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_GCT108)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_AGS109)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_GCT110)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_AIR_SENDER)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_AIR_RECEIVER)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_ACCTON2_TX)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_ACCTON2_RX)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_TX)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_RX)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_L2_ZINWELL)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_DEFINED_MAX)
-
-		    /* Customer private range */
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MIN)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MAX)
-	}
-	return "Unsupported Board";
-}
-
-#define ENUM_CHIP_TYPE_CASE(x) \
-	case x: return(#x + 15);	/* Skip CVMX_CHIP_TYPE */
-static inline const char *cvmx_chip_type_to_string(enum
-						   cvmx_chip_types_enum type)
-{
-	switch (type) {
-		ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_NULL)
-		ENUM_CHIP_TYPE_CASE(CVMX_CHIP_SIM_TYPE_DEPRECATED)
-		ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_OCTEON_SAMPLE)
-		ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_MAX)
-	}
-	return "Unsupported Chip";
-}
-
-#endif /* __CVMX_BOOTINFO_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx.h b/arch/mips/include/asm/octeon/cvmx.h
index 8f705ce..191cca9 100644
--- a/arch/mips/include/asm/octeon/cvmx.h
+++ b/arch/mips/include/asm/octeon/cvmx.h
@@ -33,12 +33,7 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 
-enum cvmx_mips_space {
-	CVMX_MIPS_SPACE_XKSEG = 3LL,
-	CVMX_MIPS_SPACE_XKPHYS = 2LL,
-	CVMX_MIPS_SPACE_XSSEG = 1LL,
-	CVMX_MIPS_SPACE_XUSEG = 0LL
-};
+#define CVMX_SHARED
 
 /* These macros for use when using 32 bit pointers. */
 #define CVMX_MIPS32_SPACE_KSEG0 1l
@@ -54,10 +49,36 @@ enum cvmx_mips_space {
 #define CVMX_ADD_IO_SEG(add) CVMX_ADD_SEG(CVMX_IO_SEG, (add))
 #endif
 
+#define cvmx_local_irq_save local_irq_save
+#define cvmx_local_irq_restore local_irq_restore
+
+#define cvmx_safe_printf pr_err
+#define cvmx_warn pr_warning
+#define cvmx_warn_if(p, fmt, ...) ({if (p) pr_warning(pr_fmt(fmt), ##__VA_ARGS__);})
+#define cvmx_unlikely unlikely
+#define cvmx_likely likely
+
+/*
+ * Returns processor ID, different Linux and simple exec versions
+ * provided in the cvmx-app-init*.c files.
+ */
+static inline uint32_t cvmx_get_proc_id(void) __attribute__ ((pure));
+static inline uint32_t cvmx_get_proc_id(void)
+{
+	uint32_t id;
+	asm("mfc0 %0, $15,0" : "=r"(id));
+	return id;
+}
+
 #include "cvmx-asm.h"
 #include "cvmx-packet.h"
 #include "cvmx-sysinfo.h"
 
+#include "cvmx-address.h"
+
+#include <asm/octeon/octeon-model.h>
+#include "cvmx-csr-enums.h"
+
 #include "cvmx-ciu-defs.h"
 #include "cvmx-gpio-defs.h"
 #include "cvmx-iob-defs.h"
@@ -68,6 +89,7 @@ enum cvmx_mips_space {
 #include "cvmx-led-defs.h"
 #include "cvmx-mio-defs.h"
 #include "cvmx-pow-defs.h"
+#include "cvmx-rnm-defs.h"
 
 #include "cvmx-bootinfo.h"
 #include "cvmx-bootmem.h"
@@ -83,24 +105,12 @@ enum cvmx_mips_space {
 #define cvmx_dprintf(...)   {}
 #endif
 
-#define CVMX_MAX_CORES          (16)
 #define CVMX_CACHE_LINE_SIZE    (128)	/* In bytes */
 #define CVMX_CACHE_LINE_MASK    (CVMX_CACHE_LINE_SIZE - 1)	/* In bytes */
 #define CVMX_CACHE_LINE_ALIGNED __attribute__ ((aligned(CVMX_CACHE_LINE_SIZE)))
 #define CAST64(v) ((long long)(long)(v))
 #define CASTPTR(type, v) ((type *)(long)(v))
 
-/*
- * Returns processor ID, different Linux and simple exec versions
- * provided in the cvmx-app-init*.c files.
- */
-static inline uint32_t cvmx_get_proc_id(void) __attribute__ ((pure));
-static inline uint32_t cvmx_get_proc_id(void)
-{
-	uint32_t id;
-	asm("mfc0 %0, $15,0" : "=r"(id));
-	return id;
-}
 
 /* turn the variable name into a string */
 #define CVMX_TMP_STR(x) CVMX_TMP_STR2(x)
@@ -152,6 +162,7 @@ static inline uint64_t cvmx_build_bits(uint64_t high_bit,
 	return (value & cvmx_build_mask(high_bit - low_bit + 1)) << low_bit;
 }
 
+
 /**
  * Convert a memory pointer (void*) into a hardware compatible
  * memory address (uint64_t). Octeon hardware widgets don't
@@ -360,6 +371,13 @@ static inline uint64_t cvmx_get_cycle(void)
 #define cvmx_wait(c) __delay(c)
 
 /**
+ *  * Wait for the specified number of micro seconds
+ *   *
+ *    * @param usec   micro seconds to wait
+ *     */
+#define cvmx_wait_usec(usec) udelay(usec)
+
+/**
  * Reads a chip global cycle counter.  This counts CPU cycles since
  * chip reset.  The counter is 64 bit.
  * This register does not exist on CN38XX pass 1 silicion
@@ -374,6 +392,8 @@ static inline uint64_t cvmx_get_cycle_global(void)
 		return cvmx_read64(CVMX_IPD_CLK_COUNT);
 }
 
+extern uint64_t octeon_get_clock_rate(void);
+
 /**
  * This macro spins on a field waiting for it to reach a value. It
  * is common in code to need to wait for a specific field in a CSR
@@ -455,6 +475,8 @@ static inline int cvmx_fuse_read(int fuse)
 	return (cvmx_fuse_read_byte(fuse >> 3) >> (fuse & 0x7)) & 1;
 }
 
+#include "octeon-feature.h"
+
 static inline int cvmx_octeon_model_CN36XX(void)
 {
 	return OCTEON_IS_MODEL(OCTEON_CN38XX)
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 404b5bf..6ee1699 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -8,6 +8,7 @@
 #ifndef __ASM_OCTEON_OCTEON_H
 #define __ASM_OCTEON_OCTEON_H
 
+#include <linux/phy.h>
 #include "cvmx.h"
 
 extern uint64_t octeon_bootmem_alloc_range_phys(uint64_t size,
@@ -348,6 +349,7 @@ static inline uint32_t octeon_npi_read32(uint64_t address)
 }
 
 extern struct cvmx_bootinfo *octeon_bootinfo;
+extern struct mii_bus *octeon_mdiobuses[];
 
 extern uint64_t octeon_bootloader_entry_addr;
 
diff --git a/arch/mips/pci/pci-octeon.c b/arch/mips/pci/pci-octeon.c
index 746357d9..8cb3696 100644
--- a/arch/mips/pci/pci-octeon.c
+++ b/arch/mips/pci/pci-octeon.c
@@ -594,8 +594,7 @@ static int __init octeon_pci_setup(void)
 
 	/* Only use the big bars on chips that support it */
 	if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2) ||
-	    OCTEON_IS_MODEL(OCTEON_CN38XX_PASS1))
+	    OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2))
 		octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_SMALL;
 	else
 		octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_BIG;
-- 
1.7.5.4

