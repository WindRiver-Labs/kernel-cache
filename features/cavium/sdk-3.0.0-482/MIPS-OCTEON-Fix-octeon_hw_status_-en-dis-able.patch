From b48e6250ef22f1fbb248daceddf407621825bd6e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 17 Jan 2013 18:14:24 -0800
Subject: [PATCH 327/337] MIPS: OCTEON: Fix octeon_hw_status_{en,dis}able()

Based On SDK 3.0.0-482

They didn't work for some registers.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/octeon-hw-status.c |   34 +++++++++++++++++++++------
 1 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index f90e7f3..f29dc68 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -54,17 +54,19 @@ static DEFINE_RWLOCK(octeon_hw_status_lock);
 static struct octeon_hw_status_node *octeon_hw_status_roots;
 
 /* call cb on each node.  stop if cb returns true. */
-static int visit_leaves(struct octeon_hw_status_node *s,
+static int visit_leaves(struct octeon_hw_status_node *s, bool visit_sibs,
 			  int (*cb)(struct octeon_hw_status_node *, void *),
 			  void *arg)
 {
+	int depth = 0;
 	struct octeon_hw_status_node *w = s;
 	int r;
 
-	while (w) {
+	while (w && depth >= 0) {
 		if (w->child) {
 			/* Go out to the leaves */
 			w = w->child;
+			depth++;
 			continue;
 		}
 
@@ -80,7 +82,10 @@ static int visit_leaves(struct octeon_hw_status_node *s,
 		}
 		/* back toward the root*/
 		for (;;) {
-			if (!w->parent || w->parent == s)
+			depth--;
+			if (!w->parent)
+				return 0;
+			if (!visit_sibs && w->parent == s)
 				return 0;
 			if (w->parent->next) {
 				w = w->parent->next;
@@ -126,7 +131,7 @@ static struct octeon_hw_status_node *find_node(struct octeon_hw_status_node *r,
 	d.r = NULL;
 	d.sr = sr;
 
-	visit_leaves(r, find_node_cb, &d);
+	visit_leaves(r, true, find_node_cb, &d);
 
 	return d.r;
 }
@@ -171,11 +176,24 @@ static irqreturn_t octeon_hw_status_irq(int irq, void *dev)
 
 	d.handled_one = false;
 	read_lock(&octeon_hw_status_lock);
-	visit_leaves(root, irq_cb, &d);
+	visit_leaves(root, false, irq_cb, &d);
 	read_unlock(&octeon_hw_status_lock);
 	return d.handled_one ? IRQ_HANDLED : IRQ_NONE;
 }
 
+static struct octeon_hw_status_node *find_child(struct octeon_hw_status_node *r,
+					       struct octeon_hw_status_reg *sr)
+{
+	struct octeon_hw_status_node *cw = r->child;
+
+	while(cw) {
+		if (find_node_cb(cw, sr))
+			break;
+		cw = cw->next;
+	}
+	return cw;
+}
+
 int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 {
 	struct octeon_hw_status_data ohsd;
@@ -211,7 +229,7 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 	w = root;
 	while (chain->has_child) {
 		chain++;
-		n = find_node(w->child, chain);
+		n = find_child(w, chain);
 		if (!n) {
 			n = kzalloc(sizeof(struct octeon_hw_status_node),
 				    GFP_KERNEL);
@@ -363,7 +381,7 @@ int octeon_hw_status_enable(u64 reg, u64 bit_mask)
 
 	read_lock(&octeon_hw_status_lock);
 
-	visit_leaves(octeon_hw_status_roots, enable_cb, &cbd);
+	visit_leaves(octeon_hw_status_roots, true, enable_cb, &cbd);
 
 	if (cbd.valid_mask && cbd.mask_reg) {
 		u64 csr = cvmx_read_csr(cbd.mask_reg);
@@ -386,7 +404,7 @@ int octeon_hw_status_disable(u64 reg, u64 bit_mask)
 
 	read_lock(&octeon_hw_status_lock);
 
-	visit_leaves(octeon_hw_status_roots, enable_cb, &cbd);
+	visit_leaves(octeon_hw_status_roots, true, enable_cb, &cbd);
 
 	if (cbd.valid_mask && cbd.mask_reg) {
 		u64 csr = cvmx_read_csr(cbd.mask_reg);
-- 
1.7.5.4

