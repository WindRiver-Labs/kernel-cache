From 0fe26f950169f31a575418e4a9f0ad906626def0 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 23 Jun 2011 18:00:38 -0700
Subject: [PATCH 007/337] MIPS: Octeon: Implement
 REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER

Based On SDK 3.0.0-482

Enable options to change how to handle the thead pointer access,
either normal, direct, debug-PC, or debug-break.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/kernel/traps.c |   48 ++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 48 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index a72dc17..b96962e 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -92,6 +92,20 @@ extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 				    struct mips_fpu_struct *ctx, int has_fpu,
 				    void *__user *fault_addr);
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+/*
+ *	0 - Use the normal kernel emulation without any changes.
+ *	1 - Replace emulated instructions with direct accesses to the thread
+ *	    register.
+ *	2 - Replace emulated instructions and log the replacement PC.
+ *	3 - Replace emulated instructions with break instructions. This will
+ *	    cause programs to fail, but makes it easy to stop gdb on the
+ *	    instruction.
+ */
+static int thread_pointer_mode;
+module_param(thread_pointer_mode, int, 0644);
+#endif
+
 void (*board_be_init)(void);
 int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
 void (*board_nmi_handler_setup)(void);
@@ -611,6 +625,9 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 {
 	struct thread_info *ti = task_thread_info(current);
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	unsigned int __user *epc = (unsigned int __user *)regs->cp0_epc + ((regs->cp0_cause & CAUSEF_BD) != 0);
+#endif
 
 	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
 		int rd = (opcode & RD) >> 11;
@@ -640,12 +657,43 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+			if (thread_pointer_mode) {
+				/* move [rt], k0 */
+				unsigned int new_instruction = 0x00000025 | (26 << 21) | (rt << 11);
+				if (thread_pointer_mode == 3)
+					new_instruction = 0x0000000d; /* break */
+				if (access_process_vm(current,
+						      (unsigned long)epc,
+						      &new_instruction,
+						      sizeof(new_instruction), 1) != sizeof(new_instruction))
+					pr_err("Failed to replaced emulated RDHWR at PC=%p\n", epc);
+				if (thread_pointer_mode == 2)
+					pr_info("Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n", epc, rt);
+				else if (thread_pointer_mode == 3)
+					pr_info("Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
+			}
+#endif
 			return 0;
 		default:
 			return -1;
 		}
 	}
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	else if (opcode == (0x00000025 | (26 << 21) | (3 << 11))) {
+		/*
+		 * opcode is: move v1, k0
+		 *
+		 * We need to flush the icache, not emulate an
+		 * instruction. The EPC is wrong, so we need to put it
+		 * back to the old instruction.
+		 */
+		regs->cp0_epc = (unsigned long)epc;
+		flush_cache_sigtramp((unsigned long)epc);
+		return 0;
+	}
+#endif
 	/* Not ours.  */
 	return -1;
 }
-- 
1.7.5.4

