From 3a0ad0cdf4c6d5dbf08229c928b0e37e61831704 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Mon, 19 Mar 2012 16:00:55 -0500
Subject: [PATCH 149/337] i2c: add operation queue

Based On SDK 3.0.0-482

This patch adds an operation queue structure and converts over the
passing around of data to use the operation queue.  The op queue
entry will be used for queueing in the non-blocking case.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/i2c-core.c |  288 ++++++++++++++++++++++++++++--------------------
 include/linux/i2c.h    |   80 +++++++++++++
 2 files changed, 246 insertions(+), 122 deletions(-)

diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index b1a9e97..e54aed7 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -1294,22 +1294,12 @@ module_exit(i2c_exit);
  * ----------------------------------------------------
  */
 
-/**
- * i2c_transfer - execute a single or combined I2C message
- * @adap: Handle to I2C bus
- * @msgs: One or more messages to execute before STOP is issued to
- *	terminate the operation; each message begins with a START.
- * @num: Number of messages to be executed.
- *
- * Returns negative errno, else the number of messages executed.
- *
- * Note that there is no requirement that each message be sent to
- * the same slave address, although that is the most common model.
- */
-int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+static void i2c_transfer_entry(struct i2c_adapter *adap,
+			       struct i2c_op_q_entry *entry)
 {
 	unsigned long orig_jiffies;
-	int ret, try;
+	int try;
+	const struct i2c_algorithm *algo = adap->algo;
 
 	/* REVISIT the fault reporting model here is weak:
 	 *
@@ -1328,42 +1318,80 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	 *    (discarding status on the first one).
 	 */
 
-	if (adap->algo->master_xfer) {
+	entry->xfer_type = I2C_OP_I2C;
+	if (algo->master_xfer) {
 #ifdef DEBUG
-		for (ret = 0; ret < num; ret++) {
+		int ret;
+		for (ret = 0; ret < entry->i2c.num; ret++) {
 			dev_dbg(&adap->dev, "master_xfer[%d] %c, addr=0x%02x, "
-				"len=%d%s\n", ret, (msgs[ret].flags & I2C_M_RD)
-				? 'R' : 'W', msgs[ret].addr, msgs[ret].len,
+				"len=%d%s\n", ret,
+				(entry->i2c.msgs[ret].flags & I2C_M_RD ?
+				 'R' : 'W'),
+				entry->i2c.msgs[ret].addr,
+				entry->i2c.msgs[ret].len,
 				(msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");
 		}
 #endif
 
 		if (in_atomic() || irqs_disabled()) {
-			ret = i2c_trylock_adapter(adap);
-			if (!ret)
+			if (!i2c_trylock_adapter(adap)) {
 				/* I2C activity is ongoing. */
-				return -EAGAIN;
+				entry->result = -EAGAIN;
+				return;
+			}
 		} else {
 			i2c_lock_adapter(adap);
 		}
 
 		/* Retry automatically on arbitration loss */
 		orig_jiffies = jiffies;
-		for (ret = 0, try = 0; try <= adap->retries; try++) {
-			ret = adap->algo->master_xfer(adap, msgs, num);
-			if (ret != -EAGAIN)
+		for (try = 0; try <= adap->retries; try++) {
+			entry->result = algo->master_xfer(adap,
+					entry->i2c.msgs, entry->i2c.num);
+			if (entry->result != -EAGAIN)
 				break;
 			if (time_after(jiffies, orig_jiffies + adap->timeout))
 				break;
 		}
 		i2c_unlock_adapter(adap);
-
-		return ret;
+		if (entry->complete)
+			entry->complete(adap, entry);
 	} else {
 		dev_dbg(&adap->dev, "I2C level transfers not supported\n");
-		return -EOPNOTSUPP;
+		entry->result = -EOPNOTSUPP;
 	}
 }
+
+/**
+ * i2c_transfer - execute a single or combined I2C message
+ * @adap: Handle to I2C bus
+ * @msgs: One or more messages to execute before STOP is issued to
+ *	terminate the operation; each message begins with a START.
+ * @num: Number of messages to be executed.
+ *
+ * Returns negative errno, else the number of messages executed.
+ *
+ * Note that there is no requirement that each message be sent to
+ * the same slave address, although that is the most common model.
+ */
+int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct i2c_op_q_entry *entry;
+	int                   rv;
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->i2c.msgs = msgs;
+	entry->i2c.num = num;
+	entry->complete = NULL;
+
+	i2c_transfer_entry(adap, entry);
+	rv = entry->result;
+	kfree(entry);
+	return rv;
+}
 EXPORT_SYMBOL(i2c_transfer);
 
 /**
@@ -1918,64 +1946,54 @@ s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,
 }
 EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);
 
-static int i2c_smbus_emu_complete(struct i2c_adapter *adapter, u16 addr,
-				  unsigned short flags, char read_write,
-				  u8 command, int size,
-				  union i2c_smbus_data *data,
-				  struct i2c_msg *msg,
-				  u8 pec, u8 partial_pec,
-				  int result)
-{
-	unsigned char *msgbuf0 = msg[0].buf;
-	unsigned char *msgbuf1 = msg[1].buf;
-	int num = read_write == I2C_SMBUS_READ ? 2 : 1;
+static void i2c_smbus_emu_complete(struct i2c_adapter *adapter,
+				   struct i2c_op_q_entry *entry)
+{
+	unsigned char *msgbuf0 = entry->i2c.msgs[0].buf;
+	unsigned char *msgbuf1 = entry->i2c.msgs[1].buf;
+	int num = entry->smbus.read_write == I2C_SMBUS_READ ? 2 : 1;
 	int i;
 	int status;
 
-	if (result < 0)
-		return result;
+	if (entry->result < 0)
+		return;
 
-	if (read_write != I2C_SMBUS_READ)
-		return result;
+	if (entry->smbus.read_write != I2C_SMBUS_READ)
+		return;
 
-	switch (size) {
+	switch (entry->smbus.size) {
 	case I2C_SMBUS_BYTE:
-		data->byte = msgbuf0[0];
+		entry->smbus.data->byte = msgbuf0[0];
 		break;
 	case I2C_SMBUS_BYTE_DATA:
-		data->byte = msgbuf1[0];
+		entry->smbus.data->byte = msgbuf1[0];
 		break;
 	case I2C_SMBUS_WORD_DATA:
 	case I2C_SMBUS_PROC_CALL:
-		data->word = msgbuf1[0] | (msgbuf1[1] << 8);
+		entry->smbus.data->word = msgbuf1[0] | (msgbuf1[1] << 8);
 		break;
 	case I2C_SMBUS_I2C_BLOCK_DATA:
-		for (i = 0; i < data->block[0]; i++)
-			data->block[i + 1] = msgbuf1[i];
+		for (i = 0; i < entry->smbus.data->block[0]; i++)
+			entry->smbus.data->block[i + 1] = msgbuf1[i];
 		break;
 	case I2C_SMBUS_BLOCK_DATA:
 	case I2C_SMBUS_BLOCK_PROC_CALL:
 		for (i = 0; i < msgbuf1[0] + 1; i++)
-			data->block[i] = msgbuf1[i];
+			entry->smbus.data->block[i] = msgbuf1[i];
 		break;
 	}
 
 	/* Check PEC if last message is a read */
-	if (pec && (msg[num - 1].flags & I2C_M_RD)) {
-		status = i2c_smbus_check_pec(partial_pec, &msg[num - 1]);
+	if (entry->pec && (entry->i2c.msgs[num - 1].flags & I2C_M_RD)) {
+		status = i2c_smbus_check_pec(entry->partial_pec,
+					     &entry->i2c.msgs[num - 1]);
 		if (status < 0)
-			return status;
+			entry->result = status;
 	}
-
-	return 0;
 }
 
-static int i2c_smbus_emu_format(struct i2c_adapter *adapter, u16 addr,
-				unsigned short flags, char read_write,
-				u8 command, int size,
-				union i2c_smbus_data *data,
-				u8 *pec, u8 *partial_pec,
-				struct i2c_msg *msg)
+static int i2c_smbus_emu_format(struct i2c_adapter *adapter,
+				struct i2c_op_q_entry *entry)
 {
 	/*
 	 * So we need to generate a series of msgs. In the case of
@@ -1983,126 +2001,140 @@ static int i2c_smbus_emu_format(struct i2c_adapter *adapter, u16 addr,
 	 * need two. We initialize most things with sane defaults, to
 	 * keep the code below somewhat simpler.
 	 */
-	unsigned char *msgbuf0 = msg[0].buf;
-	int num = read_write == I2C_SMBUS_READ ? 2 : 1;
+	unsigned char *msgbuf0 = entry->msgbuf0;
+	int num = entry->smbus.read_write == I2C_SMBUS_READ ? 2 : 1;
+	struct i2c_msg *msg = entry->msg;
 	int i;
 
-	msg[0].addr = addr;
-	msg[0].flags = flags;
+	entry->i2c.msgs = msg;
+	entry->i2c.msgs[0].buf = msgbuf0;
+	entry->i2c.msgs[1].buf = entry->msgbuf1;
+
+	msg[0].addr = entry->smbus.addr;
+	msg[0].flags = entry->smbus.flags;
 	msg[0].len = 1;
-	msg[1].addr = addr;
-	msg[1].flags = flags | I2C_M_RD;
+	msg[1].addr = entry->smbus.addr;
+	msg[1].flags = entry->smbus.flags | I2C_M_RD;
 	msg[1].len = 0;
 
-	msgbuf0[0] = command;
-	switch (size) {
+	msgbuf0[0] = entry->smbus.command;
+	switch (entry->smbus.size) {
 	case I2C_SMBUS_QUICK:
 		msg[0].len = 0;
 		/* Special case: The read/write field is used as data */
-		msg[0].flags = flags | (read_write == I2C_SMBUS_READ ?
-					I2C_M_RD : 0);
+		msg[0].flags = (entry->smbus.flags |
+				((entry->smbus.read_write == I2C_SMBUS_READ)
+				 ? I2C_M_RD : 0));
 		num = 1;
 		break;
 	case I2C_SMBUS_BYTE:
-		if (read_write == I2C_SMBUS_READ) {
+		if (entry->smbus.read_write == I2C_SMBUS_READ) {
 			/* Special case: only a read! */
-			msg[0].flags = I2C_M_RD | flags;
+			msg[0].flags = I2C_M_RD | entry->smbus.flags;
 			num = 1;
 		}
 		break;
 	case I2C_SMBUS_BYTE_DATA:
-		if (read_write == I2C_SMBUS_READ)
+		if (entry->smbus.read_write == I2C_SMBUS_READ)
 			msg[1].len = 1;
 		else {
 			msg[0].len = 2;
-			msgbuf0[1] = data->byte;
+			msgbuf0[1] = entry->smbus.data->byte;
 		}
 		break;
 	case I2C_SMBUS_WORD_DATA:
-		if (read_write == I2C_SMBUS_READ)
+		if (entry->smbus.read_write == I2C_SMBUS_READ)
 			msg[1].len = 2;
 		else {
 			msg[0].len = 3;
-			msgbuf0[1] = data->word & 0xff;
-			msgbuf0[2] = data->word >> 8;
+			msgbuf0[1] = entry->smbus.data->word & 0xff;
+			msgbuf0[2] = entry->smbus.data->word >> 8;
 		}
 		break;
 	case I2C_SMBUS_PROC_CALL:
 		num = 2; /* Special case */
-		read_write = I2C_SMBUS_READ;
+		entry->smbus.read_write = I2C_SMBUS_READ;
 		msg[0].len = 3;
 		msg[1].len = 2;
-		msgbuf0[1] = data->word & 0xff;
-		msgbuf0[2] = data->word >> 8;
+		msgbuf0[1] = entry->smbus.data->word & 0xff;
+		msgbuf0[2] = entry->smbus.data->word >> 8;
 		break;
 	case I2C_SMBUS_BLOCK_DATA:
-		if (read_write == I2C_SMBUS_READ) {
+		if (entry->smbus.read_write == I2C_SMBUS_READ) {
 			msg[1].flags |= I2C_M_RECV_LEN;
 			msg[1].len = 1; /* block length will be added by
 					   the underlying bus driver */
 		} else {
-			msg[0].len = data->block[0] + 2;
+			msg[0].len = entry->smbus.data->block[0] + 2;
 			if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {
 				dev_err(&adapter->dev,
 					"Invalid block write size %d\n",
-					data->block[0]);
+					entry->smbus.data->block[0]);
 				return -EINVAL;
 			}
 			for (i = 1; i < msg[0].len; i++)
-				msgbuf0[i] = data->block[i-1];
+				msgbuf0[i] = entry->smbus.data->block[i - 1];
 		}
 		break;
 	case I2C_SMBUS_BLOCK_PROC_CALL:
 		num = 2; /* Another special case */
-		read_write = I2C_SMBUS_READ;
-		if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {
+		entry->smbus.read_write = I2C_SMBUS_READ;
+		if (entry->smbus.data->block[0] > I2C_SMBUS_BLOCK_MAX) {
 			dev_err(&adapter->dev,
 				"Invalid block write size %d\n",
-				data->block[0]);
+				entry->smbus.data->block[0]);
 			return -EINVAL;
 		}
-		msg[0].len = data->block[0] + 2;
+		msg[0].len = entry->smbus.data->block[0] + 2;
 		for (i = 1; i < msg[0].len; i++)
-			msgbuf0[i] = data->block[i-1];
+			msgbuf0[i] = entry->smbus.data->block[i-1];
 		msg[1].flags |= I2C_M_RECV_LEN;
 		msg[1].len = 1; /* block length will be added by
 				   the underlying bus driver */
 		break;
 	case I2C_SMBUS_I2C_BLOCK_DATA:
-		if (read_write == I2C_SMBUS_READ) {
-			msg[1].len = data->block[0];
+		if (entry->smbus.read_write == I2C_SMBUS_READ) {
+			msg[1].len = entry->smbus.data->block[0];
 		} else {
-			msg[0].len = data->block[0] + 1;
+			msg[0].len = entry->smbus.data->block[0] + 1;
 			if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {
 				dev_err(&adapter->dev,
 					"Invalid block write size %d\n",
-					data->block[0]);
+					entry->smbus.data->block[0]);
 				return -EINVAL;
 			}
-			for (i = 1; i <= data->block[0]; i++)
-				msgbuf0[i] = data->block[i];
+			for (i = 1; i <= entry->smbus.data->block[0]; i++)
+				msgbuf0[i] = entry->smbus.data->block[i];
 		}
 		break;
 	default:
-		dev_err(&adapter->dev, "Unsupported transaction %d\n", size);
+		dev_err(&adapter->dev, "Unsupported transaction %d\n",
+			entry->smbus.size);
 		return -EOPNOTSUPP;
 	}
 
-	*pec = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK
-					 && size != I2C_SMBUS_I2C_BLOCK_DATA);
-	if (*pec) {
+	entry->pec = ((entry->smbus.flags & I2C_CLIENT_PEC)
+		      && entry->smbus.size != I2C_SMBUS_QUICK
+		      && entry->smbus.size != I2C_SMBUS_I2C_BLOCK_DATA);
+	if (entry->pec) {
 		/* Compute PEC if first message is a write */
 		if (!(msg[0].flags & I2C_M_RD)) {
 			if (num == 1) /* Write only */
 				i2c_smbus_add_pec(&msg[0]);
 			else /* Write followed by read */
-				*partial_pec = i2c_smbus_msg_pec(0, &msg[0]);
+				entry->partial_pec
+					= i2c_smbus_msg_pec(0, &msg[0]);
 		}
 		/* Ask for PEC if last message is a read */
 		if (msg[num - 1].flags & I2C_M_RD)
 			msg[num - 1].len++;
 	}
 
+	entry->xfer_type = I2C_OP_I2C;
+	entry->i2c.msgs = msg;
+	entry->i2c.num = num;
+	entry->complete = i2c_smbus_emu_complete;
+
 	return 0;
 }
 
@@ -2125,18 +2157,33 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 {
 	unsigned long orig_jiffies;
 	int try;
+	struct i2c_op_q_entry *entry;
 	s32 res;
 	const struct i2c_algorithm *algo = adapter->algo;
 
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->xfer_type = I2C_OP_SMBUS;
+	entry->smbus.addr = addr;
+	entry->smbus.flags = flags;
+	entry->smbus.read_write = read_write;
+	entry->smbus.command = command;
+	entry->smbus.size = protocol;
+	entry->smbus.data = data;
+	entry->complete = NULL;
+
 	if (algo->smbus_xfer) {
 		i2c_lock_adapter(adapter);
 
 		/* Retry automatically on arbitration loss */
 		orig_jiffies = jiffies;
 		for (res = 0, try = 0; try <= adapter->retries; try++) {
-			res = algo->smbus_xfer(adapter, addr, flags,
-					       read_write, command,
-					       protocol, data);
+			entry->result = algo->smbus_xfer
+				(adapter, entry->smbus.addr, entry->smbus.flags,
+				 entry->smbus.read_write, entry->smbus.command,
+				 entry->smbus.size, entry->smbus.data);
 			if (res != -EAGAIN)
 				break;
 			if (time_after(jiffies,
@@ -2144,30 +2191,27 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 				break;
 		}
 		i2c_unlock_adapter(adapter);
+		if (entry->complete)
+			entry->complete(adapter, entry);
 	} else {
-		unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX + 3];
-		unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX + 2];
-		struct i2c_msg msg[2];
-		u8 pec = 0;
-		u8 partial_pec = 0;
-
-		msg[0].buf = msgbuf0;
-		msg[1].buf = msgbuf1;
-		if (i2c_smbus_emu_format(adapter, addr, flags,
-					 read_write, command,
-					 protocol, data, &pec, &partial_pec,
-					 msg))
-			res = -EINVAL;
+		if (i2c_smbus_emu_format(adapter, entry))
+			entry->result = -EINVAL;
 		else {
-			res = i2c_transfer(adapter, msg, 2);
-			res = i2c_smbus_emu_complete(adapter, addr, flags,
-						     read_write, command,
-						     protocol, data, msg,
-						     pec, partial_pec,
-						     res);
+			i2c_transfer_entry(adapter, entry);
+			/*
+			 * We get these back with the result being the
+			 * number of bytes transferred.  We want zero for
+			 * success for this routine.
+			 */
+			if (entry->result > 0)
+				entry->result = 0;
 		}
 	}
 
+	res = entry->result;
+	kfree(entry);
+	if (res > 0)
+		res = 0; /* Always return 0 on success */
 	return res;
 }
 EXPORT_SYMBOL(i2c_smbus_xfer);
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 195d8b3..555a8a9 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -48,6 +48,7 @@ struct i2c_client;
 struct i2c_driver;
 union i2c_smbus_data;
 struct i2c_board_info;
+struct i2c_op_q_entry;
 
 struct module;
 
@@ -616,4 +617,83 @@ union i2c_smbus_data {
 #define I2C_SMBUS_BLOCK_PROC_CALL   7		/* SMBus 2.0 */
 #define I2C_SMBUS_I2C_BLOCK_DATA    8
 
+#ifdef __KERNEL__
+
+/*
+ * Hold an I2C operation to perform, and used to pass data around.
+ */
+#define I2C_OP_I2C	0
+#define I2C_OP_SMBUS	1
+struct i2c_op_q_entry {
+	/*
+	 * The result will be set to the result of the operation when
+	 * it completes.
+	 */
+	s32 result;
+
+	/**************************************************************/
+	/*
+	 * Public interface.  The user should set these up (and the
+	 * proper structure below).
+	 */
+
+	/*
+	 * Set to I2C_OP_I2C or I2C_OP_SMBUS depending on the transfer type.
+	 */
+	int            xfer_type;
+
+	/*
+	 * Set up the i2c or smbus structure, depending on the transfer
+	 * type.
+	 *
+	 * Note that i2c and smbus are not in a union because an smbus
+	 * operation may be converted into an i2c operation (thus both
+	 * structures will be used).  The data in these may be changed
+	 * by the driver.
+	 */
+	struct {
+		struct i2c_msg *msgs;
+		int num;
+	} i2c;
+	struct {
+		/*
+		 * Addr and flags are filled in by the non-blocking
+		 * send routine that takes a client.
+		 */
+		u16 addr;
+		unsigned short flags;
+
+		char read_write;
+		u8 command;
+
+		/*
+		 * Note that the size is *not* the length of the data.
+		 * It is the transaction type, like I2C_SMBUS_QUICK
+		 * and the ones after that below.  If this is a block
+		 * transaction, the length of the rest of the data is
+		 * in the first byte of the data, for both transmit
+		 * and receive.
+		 */
+		int size;
+		union i2c_smbus_data *data;
+	} smbus;
+
+	/**************************************************************/
+	/* Internals */
+	u8                pec;
+	u8                partial_pec;
+	void (*complete)(struct i2c_adapter    *adap,
+			 struct i2c_op_q_entry *entry);
+
+	/*
+	 * These are here for SMBus emulation over I2C.  I don't like
+	 * them taking this much room in the data structure, but they
+	 * need to be available in this case.
+	 */
+	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX + 3];
+	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX + 2];
+	struct i2c_msg msg[2];
+};
+
+#endif /* __KERNEL__ */
 #endif /* _LINUX_I2C_H */
-- 
1.7.5.4

