From 7219523084a708aeb0d4346fd1b1f0100ac23144 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 21 Jun 2012 16:42:39 -0700
Subject: [PATCH 091/337] MIPS: OCTEON: Update packet I/O initialization
 functions.

Based On SDK 3.0.0-482

We add support for OCTEON II SOCs.  This includes support for sRIO and
Interlaken present on some parts, as well as workarounds for some
hardware errata.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile         |   12 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    |  622 ++------
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |  598 ++++++++
 .../cavium-octeon/executive/cvmx-helper-errata.c   |  239 +++-
 .../mips/cavium-octeon/executive/cvmx-helper-ilk.c |  410 +++++
 .../cavium-octeon/executive/cvmx-helper-jtag.c     |   84 +-
 .../cavium-octeon/executive/cvmx-helper-loop.c     |   69 +-
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |   93 +-
 .../cavium-octeon/executive/cvmx-helper-rgmii.c    |  211 +--
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |  362 +++--
 .../mips/cavium-octeon/executive/cvmx-helper-spi.c |   54 +-
 .../cavium-octeon/executive/cvmx-helper-srio.c     |  316 ++++
 .../cavium-octeon/executive/cvmx-helper-util.c     |  668 ++++++---
 .../cavium-octeon/executive/cvmx-helper-xaui.c     |  358 +++--
 arch/mips/cavium-octeon/executive/cvmx-helper.c    | 1435 +++++++++++++-----
 arch/mips/cavium-octeon/executive/cvmx-ilk.c       | 1607 ++++++++++++++++++++
 arch/mips/cavium-octeon/executive/cvmx-ipd.c       |  370 +++++
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       |    2 -
 arch/mips/cavium-octeon/executive/cvmx-pko.c       |  713 +++++++--
 .../mips/cavium-octeon/executive/cvmx-qlm-tables.c |  428 ++++++
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 1089 +++++++++++++
 arch/mips/cavium-octeon/executive/cvmx-spi.c       |  107 +-
 arch/mips/cavium-octeon/executive/cvmx-srio.c      | 1589 +++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-fau.h            |    6 +-
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |   91 +-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |  232 +++
 arch/mips/include/asm/octeon/cvmx-helper-errata.h  |   49 +-
 arch/mips/include/asm/octeon/cvmx-helper-ilk.h     |   86 ++
 arch/mips/include/asm/octeon/cvmx-helper-jtag.h    |   57 +-
 arch/mips/include/asm/octeon/cvmx-helper-loop.h    |   28 +-
 arch/mips/include/asm/octeon/cvmx-helper-npi.h     |   18 +-
 arch/mips/include/asm/octeon/cvmx-helper-rgmii.h   |   25 +-
 arch/mips/include/asm/octeon/cvmx-helper-sgmii.h   |   20 +-
 arch/mips/include/asm/octeon/cvmx-helper-spi.h     |   11 +-
 arch/mips/include/asm/octeon/cvmx-helper-srio.h    |   84 +
 arch/mips/include/asm/octeon/cvmx-helper-util.h    |  162 ++-
 arch/mips/include/asm/octeon/cvmx-helper-xaui.h    |   21 +-
 arch/mips/include/asm/octeon/cvmx-helper.h         |  151 ++-
 arch/mips/include/asm/octeon/cvmx-ilk.h            |  198 +++
 arch/mips/include/asm/octeon/cvmx-ipd.h            |  300 +----
 arch/mips/include/asm/octeon/cvmx-pko.h            |  566 +++++--
 arch/mips/include/asm/octeon/cvmx-qlm.h            |  158 ++
 arch/mips/include/asm/octeon/cvmx-spi.h            |   19 +-
 arch/mips/include/asm/octeon/cvmx-srio.h           |  643 ++++++++
 arch/mips/include/asm/octeon/octeon-model.h        |    7 +
 drivers/staging/octeon/ethernet.c                  |    6 +-
 46 files changed, 11979 insertions(+), 2395 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-helper-srio.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-ilk.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-ipd.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-qlm.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-srio.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-helper-cfg.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-helper-ilk.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-helper-srio.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-ilk.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-qlm.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-srio.h

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index b6d6e84..b22929c 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -10,10 +10,16 @@
 #
 
 obj-y += cvmx-bootmem.o cvmx-l2c.o cvmx-sysinfo.o octeon-model.o
-obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o \
-	cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
+obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-ipd.o \
+	cvmx-ilk.o cvmx-srio.o cvmx-qlm.o cvmx-qlm-tables.o
+
+
+obj-y += cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o \
-	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
+	cvmx-helper-errata.o cvmx-helper-jtag.o cvmx-helper-cfg.o \
+	cvmx-helper-srio.o cvmx-helper-ilk.o
+
+obj-y += cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index fd20153..4bf610d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2011 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,40 +22,23 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  */
-
+#include <linux/export.h>
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-bootinfo.h>
-
-#include <asm/octeon/cvmx-config.h>
-
-#include <asm/octeon/cvmx-mdio.h>
-
+#include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-helper-board.h>
 
-#include <asm/octeon/cvmx-gmxx-defs.h>
-#include <asm/octeon/cvmx-asxx-defs.h>
-
-/**
- * cvmx_override_board_link_get(int ipd_port) is a function
- * pointer. It is meant to allow customization of the process of
- * talking to a PHY to determine link speed. It is called every
- * time a PHY must be polled for link status. Users should set
- * this pointer to a function before calling any cvmx-helper
- * operations.
- */
-cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) =
-    NULL;
-
 /**
  * Return the MII PHY address associated with the given IPD
  * port. A result of -1 means there isn't a MII capable PHY
@@ -74,6 +57,8 @@ cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) =
  */
 int cvmx_helper_board_get_mii_address(int ipd_port)
 {
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
+		return -1;
 	switch (cvmx_sysinfo_get()->board_type) {
 	case CVMX_BOARD_TYPE_SIM:
 		/* Simulator doesn't have MII */
@@ -87,6 +72,17 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
 			return ipd_port - 16;
 		else
 			return -1;
+	case CVMX_BOARD_TYPE_LANAI2_A:
+		if (ipd_port == 0)
+			return 0;
+		else
+			return -1;
+	case CVMX_BOARD_TYPE_LANAI2_U:
+	case CVMX_BOARD_TYPE_LANAI2_G:
+		if (ipd_port == 0)
+			return 0x1c;
+		else
+			return -1;
 	case CVMX_BOARD_TYPE_KODAMA:
 	case CVMX_BOARD_TYPE_EBH3100:
 	case CVMX_BOARD_TYPE_HIKARI:
@@ -143,6 +139,44 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
 			return ipd_port + 1;
 		else
 			return -1;
+	case CVMX_BOARD_TYPE_EBB6300:
+		/* Board has 2 management ports */
+		if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT) &&
+		    (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))
+			return ipd_port - CVMX_HELPER_BOARD_MGMT_IPD_PORT + 4;
+		if ((ipd_port >= 0) && (ipd_port < 4))
+			return ipd_port + 1 + (1 << 8);
+		else
+			return -1;
+	case CVMX_BOARD_TYPE_EBB6800:
+		/* Board has 1 management ports */
+		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+			return 6;
+		if (ipd_port >= 0x800 && ipd_port < 0x900)	/* QLM 0 */
+			return 0x101 + ((ipd_port >> 4) & 3);	/* SMI 1 */
+		if (ipd_port >= 0xa00 && ipd_port < 0xb00)	/* QLM 2 */
+			return 0x201 + ((ipd_port >> 4) & 3);	/* SMI 2 */
+		if (ipd_port >= 0xb00 && ipd_port < 0xc00)	/* QLM 3 */
+			return 0x301 + ((ipd_port >> 4) & 3);	/* SMI 3 */
+		if (ipd_port >= 0xc00 && ipd_port < 0xd00)	/* QLM 4 */
+			return 0x001 + ((ipd_port >> 4) & 3);	/* SMI 0 */
+		return -1;
+	case CVMX_BOARD_TYPE_EP6300C:
+		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+			return 0x01;
+		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT + 1)
+			return 0x02;
+		{
+			int interface = cvmx_helper_get_interface_num(ipd_port);
+			int mode = cvmx_helper_interface_get_mode(interface);
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI)
+				return ipd_port;
+			else if ((ipd_port >= 0) && (ipd_port < 4))
+				return ipd_port + 3;
+			else
+				return -1;
+		}
+		break;
 	case CVMX_BOARD_TYPE_CUST_NB5:
 		if (ipd_port == 2)
 			return 4;
@@ -167,13 +201,14 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
 			return ipd_port + 1;
 		else
 			return -1;
+	case CVMX_BOARD_TYPE_REDWING:
+		return -1;	/* No PHYs connected to Octeon */
 	case CVMX_BOARD_TYPE_BBGW_REF:
 		/*
 		 * No PHYs are connected to Octeon, everything is
 		 * through switch.
 		 */
 		return -1;
-
 	case CVMX_BOARD_TYPE_CUST_WSX16:
 		if (ipd_port >= 0 && ipd_port <= 3)
 			return ipd_port;
@@ -184,412 +219,10 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
 	}
 
 	/* Some unknown board. Somebody forgot to update this function... */
-	cvmx_dprintf
-	    ("cvmx_helper_board_get_mii_address: Unknown board type %d\n",
-	     cvmx_sysinfo_get()->board_type);
+	cvmx_dprintf("%s: Unknown board type %d\n", __func__, cvmx_sysinfo_get()->board_type);
 	return -1;
 }
-
-/**
- * This function is the board specific method of determining an
- * ethernet ports link speed. Most Octeon boards have Marvell PHYs
- * and are handled by the fall through case. This function must be
- * updated for boards that don't have the normal Marvell PHYs.
- *
- * This function must be modified for every new Octeon board.
- * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relies on the
- * fact that every Octeon board receives a unique board type
- * enumeration from the bootloader.
- *
- * @ipd_port: IPD input port associated with the port we want to get link
- *                 status for.
- *
- * Returns The ports link status. If the link isn't fully resolved, this must
- *         return zero.
- */
-cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
-{
-	cvmx_helper_link_info_t result;
-	int phy_addr;
-	int is_broadcom_phy = 0;
-
-	/* Give the user a chance to override the processing of this function */
-	if (cvmx_override_board_link_get)
-		return cvmx_override_board_link_get(ipd_port);
-
-	/* Unless we fix it later, all links are defaulted to down */
-	result.u64 = 0;
-
-	/*
-	 * This switch statement should handle all ports that either don't use
-	 * Marvell PHYS, or don't support in-band status.
-	 */
-	switch (cvmx_sysinfo_get()->board_type) {
-	case CVMX_BOARD_TYPE_SIM:
-		/* The simulator gives you a simulated 1Gbps full duplex link */
-		result.s.link_up = 1;
-		result.s.full_duplex = 1;
-		result.s.speed = 1000;
-		return result;
-	case CVMX_BOARD_TYPE_EBH3100:
-	case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3020_EVB_HS5:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 1) {
-			result.s.link_up = 1;
-			result.s.full_duplex = 1;
-			result.s.speed = 1000;
-			return result;
-		}
-		/* Fall through to the generic code below */
-		break;
-	case CVMX_BOARD_TYPE_CUST_NB5:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 1) {
-			result.s.link_up = 1;
-			result.s.full_duplex = 1;
-			result.s.speed = 1000;
-			return result;
-		} else		/* The other port uses a broadcom PHY */
-			is_broadcom_phy = 1;
-		break;
-	case CVMX_BOARD_TYPE_BBGW_REF:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 2) {
-			/* Port 2 is not hooked up */
-			result.u64 = 0;
-			return result;
-		} else {
-			/* Ports 0 and 1 connect to the switch */
-			result.s.link_up = 1;
-			result.s.full_duplex = 1;
-			result.s.speed = 1000;
-			return result;
-		}
-		break;
-	}
-
-	phy_addr = cvmx_helper_board_get_mii_address(ipd_port);
-	if (phy_addr != -1) {
-		if (is_broadcom_phy) {
-			/*
-			 * Below we are going to read SMI/MDIO
-			 * register 0x19 which works on Broadcom
-			 * parts
-			 */
-			int phy_status =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   0x19);
-			switch ((phy_status >> 8) & 0x7) {
-			case 0:
-				result.u64 = 0;
-				break;
-			case 1:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
-				result.s.speed = 10;
-				break;
-			case 2:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 10;
-				break;
-			case 3:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
-				result.s.speed = 100;
-				break;
-			case 4:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 100;
-				break;
-			case 5:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 100;
-				break;
-			case 6:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
-				result.s.speed = 1000;
-				break;
-			case 7:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 1000;
-				break;
-			}
-		} else {
-			/*
-			 * This code assumes we are using a Marvell
-			 * Gigabit PHY. All the speed information can
-			 * be read from register 17 in one
-			 * go. Somebody using a different PHY will
-			 * need to handle it above in the board
-			 * specific area.
-			 */
-			int phy_status =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);
-
-			/*
-			 * If the resolve bit 11 isn't set, see if
-			 * autoneg is turned off (bit 12, reg 0). The
-			 * resolve bit doesn't get set properly when
-			 * autoneg is off, so force it.
-			 */
-			if ((phy_status & (1 << 11)) == 0) {
-				int auto_status =
-				    cvmx_mdio_read(phy_addr >> 8,
-						   phy_addr & 0xff, 0);
-				if ((auto_status & (1 << 12)) == 0)
-					phy_status |= 1 << 11;
-			}
-
-			/*
-			 * Only return a link if the PHY has finished
-			 * auto negotiation and set the resolved bit
-			 * (bit 11)
-			 */
-			if (phy_status & (1 << 11)) {
-				result.s.link_up = 1;
-				result.s.full_duplex = ((phy_status >> 13) & 1);
-				switch ((phy_status >> 14) & 3) {
-				case 0:	/* 10 Mbps */
-					result.s.speed = 10;
-					break;
-				case 1:	/* 100 Mbps */
-					result.s.speed = 100;
-					break;
-				case 2:	/* 1 Gbps */
-					result.s.speed = 1000;
-					break;
-				case 3:	/* Illegal */
-					result.u64 = 0;
-					break;
-				}
-			}
-		}
-	} else if (OCTEON_IS_MODEL(OCTEON_CN3XXX)
-		   || OCTEON_IS_MODEL(OCTEON_CN58XX)
-		   || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-		/*
-		 * We don't have a PHY address, so attempt to use
-		 * in-band status. It is really important that boards
-		 * not supporting in-band status never get
-		 * here. Reading broken in-band status tends to do bad
-		 * things
-		 */
-		union cvmx_gmxx_rxx_rx_inbnd inband_status;
-		int interface = cvmx_helper_get_interface_num(ipd_port);
-		int index = cvmx_helper_get_interface_index_num(ipd_port);
-		inband_status.u64 =
-		    cvmx_read_csr(CVMX_GMXX_RXX_RX_INBND(index, interface));
-
-		result.s.link_up = inband_status.s.status;
-		result.s.full_duplex = inband_status.s.duplex;
-		switch (inband_status.s.speed) {
-		case 0:	/* 10 Mbps */
-			result.s.speed = 10;
-			break;
-		case 1:	/* 100 Mbps */
-			result.s.speed = 100;
-			break;
-		case 2:	/* 1 Gbps */
-			result.s.speed = 1000;
-			break;
-		case 3:	/* Illegal */
-			result.u64 = 0;
-			break;
-		}
-	} else {
-		/*
-		 * We don't have a PHY address and we don't have
-		 * in-band status. There is no way to determine the
-		 * link speed. Return down assuming this port isn't
-		 * wired
-		 */
-		result.u64 = 0;
-	}
-
-	/* If link is down, return all fields as zero. */
-	if (!result.s.link_up)
-		result.u64 = 0;
-
-	return result;
-}
-
-/**
- * This function as a board specific method of changing the PHY
- * speed, duplex, and auto-negotiation. This programs the PHY and
- * not Octeon. This can be used to force Octeon's links to
- * specific settings.
- *
- * @phy_addr:  The address of the PHY to program
- * @enable_autoneg:
- *                  Non zero if you want to enable auto-negotiation.
- * @link_info: Link speed to program. If the speed is zero and auto-negotiation
- *                  is enabled, all possible negotiation speeds are advertised.
- *
- * Returns Zero on success, negative on failure
- */
-int cvmx_helper_board_link_set_phy(int phy_addr,
-				   cvmx_helper_board_set_phy_link_flags_types_t
-				   link_flags,
-				   cvmx_helper_link_info_t link_info)
-{
-
-	/* Set the flow control settings based on link_flags */
-	if ((link_flags & set_phy_link_flags_flow_control_mask) !=
-	    set_phy_link_flags_flow_control_dont_touch) {
-		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
-		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
-		reg_autoneg_adver.s.asymmetric_pause =
-		    (link_flags & set_phy_link_flags_flow_control_mask) ==
-		    set_phy_link_flags_flow_control_enable;
-		reg_autoneg_adver.s.pause =
-		    (link_flags & set_phy_link_flags_flow_control_mask) ==
-		    set_phy_link_flags_flow_control_enable;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
-	}
-
-	/* If speed isn't set and autoneg is on advertise all supported modes */
-	if ((link_flags & set_phy_link_flags_autoneg)
-	    && (link_info.s.speed == 0)) {
-		cvmx_mdio_phy_reg_control_t reg_control;
-		cvmx_mdio_phy_reg_status_t reg_status;
-		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
-		cvmx_mdio_phy_reg_extended_status_t reg_extended_status;
-		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
-
-		reg_status.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_STATUS);
-		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
-		reg_autoneg_adver.s.advert_100base_t4 =
-		    reg_status.s.capable_100base_t4;
-		reg_autoneg_adver.s.advert_10base_tx_full =
-		    reg_status.s.capable_10_full;
-		reg_autoneg_adver.s.advert_10base_tx_half =
-		    reg_status.s.capable_10_half;
-		reg_autoneg_adver.s.advert_100base_tx_full =
-		    reg_status.s.capable_100base_x_full;
-		reg_autoneg_adver.s.advert_100base_tx_half =
-		    reg_status.s.capable_100base_x_half;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
-		if (reg_status.s.capable_extended_status) {
-			reg_extended_status.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_EXTENDED_STATUS);
-			reg_control_1000.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_CONTROL_1000);
-			reg_control_1000.s.advert_1000base_t_full =
-			    reg_extended_status.s.capable_1000base_t_full;
-			reg_control_1000.s.advert_1000base_t_half =
-			    reg_extended_status.s.capable_1000base_t_half;
-			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-					CVMX_MDIO_PHY_REG_CONTROL_1000,
-					reg_control_1000.u16);
-		}
-		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
-		reg_control.s.autoneg_enable = 1;
-		reg_control.s.restart_autoneg = 1;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
-	} else if ((link_flags & set_phy_link_flags_autoneg)) {
-		cvmx_mdio_phy_reg_control_t reg_control;
-		cvmx_mdio_phy_reg_status_t reg_status;
-		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
-		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
-
-		reg_status.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_STATUS);
-		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
-		reg_autoneg_adver.s.advert_100base_t4 = 0;
-		reg_autoneg_adver.s.advert_10base_tx_full = 0;
-		reg_autoneg_adver.s.advert_10base_tx_half = 0;
-		reg_autoneg_adver.s.advert_100base_tx_full = 0;
-		reg_autoneg_adver.s.advert_100base_tx_half = 0;
-		if (reg_status.s.capable_extended_status) {
-			reg_control_1000.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_CONTROL_1000);
-			reg_control_1000.s.advert_1000base_t_full = 0;
-			reg_control_1000.s.advert_1000base_t_half = 0;
-		}
-		switch (link_info.s.speed) {
-		case 10:
-			reg_autoneg_adver.s.advert_10base_tx_full =
-			    link_info.s.full_duplex;
-			reg_autoneg_adver.s.advert_10base_tx_half =
-			    !link_info.s.full_duplex;
-			break;
-		case 100:
-			reg_autoneg_adver.s.advert_100base_tx_full =
-			    link_info.s.full_duplex;
-			reg_autoneg_adver.s.advert_100base_tx_half =
-			    !link_info.s.full_duplex;
-			break;
-		case 1000:
-			reg_control_1000.s.advert_1000base_t_full =
-			    link_info.s.full_duplex;
-			reg_control_1000.s.advert_1000base_t_half =
-			    !link_info.s.full_duplex;
-			break;
-		}
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
-		if (reg_status.s.capable_extended_status)
-			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-					CVMX_MDIO_PHY_REG_CONTROL_1000,
-					reg_control_1000.u16);
-		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
-		reg_control.s.autoneg_enable = 1;
-		reg_control.s.restart_autoneg = 1;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
-	} else {
-		cvmx_mdio_phy_reg_control_t reg_control;
-		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
-		reg_control.s.autoneg_enable = 0;
-		reg_control.s.restart_autoneg = 1;
-		reg_control.s.duplex = link_info.s.full_duplex;
-		if (link_info.s.speed == 1000) {
-			reg_control.s.speed_msb = 1;
-			reg_control.s.speed_lsb = 0;
-		} else if (link_info.s.speed == 100) {
-			reg_control.s.speed_msb = 0;
-			reg_control.s.speed_lsb = 1;
-		} else if (link_info.s.speed == 10) {
-			reg_control.s.speed_msb = 0;
-			reg_control.s.speed_lsb = 0;
-		}
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
-	}
-	return 0;
-}
+EXPORT_SYMBOL(cvmx_helper_board_get_mii_address);
 
 /**
  * This function is called by cvmx_helper_interface_probe() after it
@@ -599,9 +232,9 @@ int cvmx_helper_board_link_set_phy(int phy_addr,
  * support and should return the number of actual ports on the
  * board.
  *
- * This function must be modifed for every new Octeon board.
+ * This function must be modified for every new Octeon board.
  * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relys on the
+ * data to determine board types and revisions. It relies on the
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
@@ -616,6 +249,9 @@ int __cvmx_helper_board_interface_probe(int interface, int supported_ports)
 {
 	switch (cvmx_sysinfo_get()->board_type) {
 	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
+	case CVMX_BOARD_TYPE_LANAI2_A:
+	case CVMX_BOARD_TYPE_LANAI2_U:
+	case CVMX_BOARD_TYPE_LANAI2_G:
 		if (interface == 0)
 			return 2;
 		break;
@@ -627,12 +263,28 @@ int __cvmx_helper_board_interface_probe(int interface, int supported_ports)
 		if (interface == 0)
 			return 0;
 		break;
-		/* The 2nd interface on the EBH5600 is connected to the Marvel switch,
-		   which we don't support. Disable ports connected to it */
+		/*
+		 * The 2nd interface on the EBH5600 is connected to
+		 * the Marvel switch, which we don't support. Disable
+		 * ports connected to it.
+		 */
 	case CVMX_BOARD_TYPE_EBH5600:
 		if (interface == 1)
 			return 0;
 		break;
+	case CVMX_BOARD_TYPE_EBB5600:
+		if (cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_PICMG)
+			return 0;
+		break;
+	case CVMX_BOARD_TYPE_EBT5810:
+		/*
+		 * Two ports on each SPI: 1 hooked to MAC, 1 loopback
+		 * Loopback disabled by default.
+		 */
+		return 1;
+	case CVMX_BOARD_TYPE_NIC2E:
+		if (interface == 0)
+			return 2;
 	}
 	return supported_ports;
 }
@@ -657,55 +309,65 @@ int __cvmx_helper_board_hardware_enable(int interface)
 			/*
 			 * Boards with gigabit WAN ports need a
 			 * different setting that is compatible with
-			 * 100 Mbit settings
+			 * 100 Mbit settings.
 			 */
-			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface),
-				       0xc);
-			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface),
-				       0xc);
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 0xc);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 0xc);
 		}
-	} else if (cvmx_sysinfo_get()->board_type ==
-		   CVMX_BOARD_TYPE_CN3010_EVB_HS5) {
-		/*
-		 * Broadcom PHYs require differnet ASX
-		 * clocks. Unfortunately many boards don't define a
-		 * new board Id and simply mangle the
-		 * CN3010_EVB_HS5
-		 */
+	} else if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_LANAI2_U) {
 		if (interface == 0) {
-			/*
-			 * Some boards use a hacked up bootloader that
-			 * identifies them as CN3010_EVB_HS5
-			 * evaluation boards.  This leads to all kinds
-			 * of configuration problems.  Detect one
-			 * case, and print warning, while trying to do
-			 * the right thing.
-			 */
-			int phy_addr = cvmx_helper_board_get_mii_address(0);
-			if (phy_addr != -1) {
-				int phy_identifier =
-				    cvmx_mdio_read(phy_addr >> 8,
-						   phy_addr & 0xff, 0x2);
-				/* Is it a Broadcom PHY? */
-				if (phy_identifier == 0x0143) {
-					cvmx_dprintf("\n");
-					cvmx_dprintf("ERROR:\n");
-					cvmx_dprintf
-					    ("ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n");
-					cvmx_dprintf
-					    ("ERROR: The board type is mis-configured, and software malfunctions are likely.\n");
-					cvmx_dprintf
-					    ("ERROR: All boards require a unique board type to identify them.\n");
-					cvmx_dprintf("ERROR:\n");
-					cvmx_dprintf("\n");
-					cvmx_wait(1000000000);
-					cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX
-						       (0, interface), 5);
-					cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX
-						       (0, interface), 5);
-				}
-			}
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 16);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 16);
 		}
+	}	return 0;
+}
+
+
+/**
+ * Gets the clock type used for the USB block based on board type.
+ * Used by the USB code for auto configuration of clock type.
+ *
+ * Returns USB clock type enumeration
+ */
+enum cvmx_helper_board_usb_clock_types __cvmx_helper_board_usb_get_clock_type(void)
+{
+	switch (cvmx_sysinfo_get()->board_type) {
+	case CVMX_BOARD_TYPE_BBGW_REF:
+	case CVMX_BOARD_TYPE_LANAI2_A:
+	case CVMX_BOARD_TYPE_LANAI2_U:
+	case CVMX_BOARD_TYPE_LANAI2_G:
+	case CVMX_BOARD_TYPE_NIC10E_66:
+		return USB_CLOCK_TYPE_CRYSTAL_12;
+	case CVMX_BOARD_TYPE_NIC10E:
+		return USB_CLOCK_TYPE_REF_12;
+	default:
+		break;
 	}
-	return 0;
+	/* Most boards except NIC10e use a 12MHz crystal */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) ||
+	    OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		return USB_CLOCK_TYPE_CRYSTAL_12;
+	return USB_CLOCK_TYPE_REF_48;
+}
+
+/**
+ * Adjusts the number of available USB ports on Octeon based on board
+ * specifics.
+ *
+ * @supported_ports: expected number of ports based on chip type;
+ *
+ *
+ * Returns number of available usb ports, based on board specifics.
+ *         Return value is supported_ports if function does not
+ *         override.
+ */
+int __cvmx_helper_board_usb_get_num_ports(int supported_ports)
+{
+	switch (cvmx_sysinfo_get()->board_type) {
+	case CVMX_BOARD_TYPE_NIC_XLE_4G:
+	case CVMX_BOARD_TYPE_NIC2E:
+		return 0;
+	}
+
+	return supported_ports;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
new file mode 100644
index 0000000..bf07318
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -0,0 +1,598 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Helper Functions for the Configuration Framework
+ */
+
+#include <linux/export.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-helper-ilk.h>
+
+/* #define CVMX_HELPER_CFG_DEBUG */
+
+/*
+ * Per physical port
+ */
+struct cvmx_cfg_port_param {
+	int8_t ccpp_pknd;
+	int8_t ccpp_bpid;
+	int8_t ccpp_pko_port_base;
+	int8_t ccpp_pko_num_ports;
+	/*
+	 * When the user explicitly assigns queues,
+	 * cvmx_cfg_pko_nqueue_pool[ ccpp_pko_nqueues ...
+	 * ccpp_pko_nqueues + ccpp_pko_num_ports - 1] are the numbers
+	 * of PKO queues assigned to the PKO ports for this physical
+	 * port.
+	 */
+	uint8_t ccpp_pko_nqueues;
+};
+
+/*
+ * Per pko_port
+ */
+struct cvmx_cfg_pko_port_param {
+	int16_t ccppp_queue_base;
+	int16_t ccppp_num_queues;
+};
+
+/*
+ * A map from pko_port to
+ *     interface,
+ *     index, and
+ *     pko engine id
+ */
+struct cvmx_cfg_pko_port_map {
+	int16_t ccppl_interface;
+	int16_t ccppl_index;
+	int16_t ccppl_eid;
+};
+
+/*
+ * This is for looking up pko_base_port and pko_nport for ipd_port
+ */
+struct cvmx_cfg_pko_port_pair {
+	int8_t ccppp_base_port;
+	int8_t ccppp_nports;
+};
+
+static struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_HELPER_CFG_MAX_IFACE][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE] = {
+	[0 ... CVMX_HELPER_CFG_MAX_IFACE - 1] = {
+		[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] = {
+			CVMX_HELPER_CFG_INVALID_VALUE,
+			CVMX_HELPER_CFG_INVALID_VALUE,
+			CVMX_HELPER_CFG_INVALID_VALUE,
+			CVMX_HELPER_CFG_INVALID_VALUE,
+			CVMX_HELPER_CFG_INVALID_VALUE
+		}
+	}
+};
+
+/*
+ * Indexed by the pko_port number
+ */
+static struct cvmx_cfg_pko_port_param cvmx_cfg_pko_port[CVMX_HELPER_CFG_MAX_PKO_PORT] = {
+	[0 ... CVMX_HELPER_CFG_MAX_PKO_PORT - 1] = {
+		CVMX_HELPER_CFG_INVALID_VALUE,
+		CVMX_HELPER_CFG_INVALID_VALUE
+	}
+};
+
+static struct cvmx_cfg_pko_port_map cvmx_cfg_pko_port_map[CVMX_HELPER_CFG_MAX_PKO_PORT] = {
+	[0 ... CVMX_HELPER_CFG_MAX_PKO_PORT - 1] = {
+		CVMX_HELPER_CFG_INVALID_VALUE,
+		CVMX_HELPER_CFG_INVALID_VALUE,
+		CVMX_HELPER_CFG_INVALID_VALUE
+	}
+};
+
+/*
+ * This array assists translation from ipd_port to pko_port.
+ * The ``16'' is the rounded value for the 3rd 4-bit value of
+ * ipd_port, used to differentiate ``interfaces.''
+ */
+static struct cvmx_cfg_pko_port_pair ipd2pko_port_cache[16][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE] = {
+	[0 ... 15] = {
+		[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] = {
+			CVMX_HELPER_CFG_INVALID_VALUE,
+			CVMX_HELPER_CFG_INVALID_VALUE
+		}
+	}
+};
+
+#ifdef CVMX_USER_DEFINED_HELPER_CONFIG_INIT
+
+static CVMX_SHARED int cvmx_cfg_default_pko_nqueues = 1;
+
+/*
+ * A pool for holding the pko_nqueues for the pko_ports assigned to a
+ * physical port.
+ */
+static uint8_t cvmx_cfg_pko_nqueue_pool[CVMX_HELPER_CFG_MAX_PKO_QUEUES] = {
+	[0 ... CVMX_HELPER_CFG_MAX_PKO_QUEUES - 1] = 1
+};
+
+#endif
+
+/*
+ * Options
+ *
+ * Each array-elem's intial value is also the option's default value.
+ */
+static uint64_t cvmx_cfg_opts[CVMX_HELPER_CFG_OPT_MAX] = {
+	[0 ... CVMX_HELPER_CFG_OPT_MAX - 1] = 1
+};
+
+/*
+ * MISC
+ */
+/* # of PKO DMA engines allocated */
+static int cvmx_cfg_max_pko_engines;
+int __cvmx_helper_cfg_pknd(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].ccpp_pknd;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pknd);
+
+int __cvmx_helper_cfg_bpid(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].ccpp_bpid;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_bpid);
+
+int __cvmx_helper_cfg_pko_port_base(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].ccpp_pko_port_base;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_base);
+
+int __cvmx_helper_cfg_pko_port_num(int interface, int index)
+{
+	return cvmx_cfg_port[interface][index].ccpp_pko_num_ports;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_num);
+
+int __cvmx_helper_cfg_pko_queue_num(int pko_port)
+{
+	return cvmx_cfg_pko_port[pko_port].ccppp_num_queues;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_queue_num);
+
+int __cvmx_helper_cfg_pko_queue_base(int pko_port)
+{
+	return cvmx_cfg_pko_port[pko_port].ccppp_queue_base;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_queue_base);
+
+int __cvmx_helper_cfg_pko_max_queue(void)
+{
+	int i;
+
+	i = CVMX_HELPER_CFG_MAX_PKO_PORT - 1;
+
+	while (i >= 0) {
+		if (cvmx_cfg_pko_port[i].ccppp_queue_base != CVMX_HELPER_CFG_INVALID_VALUE)
+			return cvmx_cfg_pko_port[i].ccppp_queue_base + cvmx_cfg_pko_port[i].ccppp_num_queues;
+		i--;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_max_queue);
+
+int __cvmx_helper_cfg_pko_max_engine(void)
+{
+	return cvmx_cfg_max_pko_engines;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_max_engine);
+
+int cvmx_helper_cfg_opt_set(enum cvmx_helper_cfg_option opt, uint64_t val)
+{
+	if (opt >= CVMX_HELPER_CFG_OPT_MAX)
+		return -1;
+
+	cvmx_cfg_opts[opt] = val;
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_helper_cfg_opt_set);
+
+uint64_t cvmx_helper_cfg_opt_get(enum cvmx_helper_cfg_option opt)
+{
+	if (opt >= CVMX_HELPER_CFG_OPT_MAX)
+		return (uint64_t) CVMX_HELPER_CFG_INVALID_VALUE;
+
+	return cvmx_cfg_opts[opt];
+}
+EXPORT_SYMBOL(cvmx_helper_cfg_opt_get);
+
+#ifdef CVMX_HELPER_CFG_DEBUG
+void cvmx_helper_cfg_show_cfg(void)
+{
+	int i, j;
+
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		cvmx_dprintf("cvmx_helper_cfg_show_cfg: interface%d mode %10s nports%4d\n", i,
+			     cvmx_helper_interface_mode_to_string(cvmx_helper_interface_get_mode(i)), cvmx_helper_interface_enumerate(i));
+
+		for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+			cvmx_dprintf("\tpknd[%i][%d]%d", i, j, __cvmx_helper_cfg_pknd(i, j));
+			cvmx_dprintf(" pko_port_base[%i][%d]%d", i, j, __cvmx_helper_cfg_pko_port_base(i, j));
+			cvmx_dprintf(" pko_port_num[%i][%d]%d\n", i, j, __cvmx_helper_cfg_pko_port_num(i, j));
+		}
+	}
+
+	for (i = 0; i < CVMX_HELPER_CFG_MAX_PKO_PORT; i++) {
+		if (__cvmx_helper_cfg_pko_queue_base(i) != CVMX_HELPER_CFG_INVALID_VALUE) {
+			cvmx_dprintf("cvmx_helper_cfg_show_cfg: pko_port%d qbase%d nqueues%d interface%d index%d\n",
+				     i, __cvmx_helper_cfg_pko_queue_base(i),
+				     __cvmx_helper_cfg_pko_queue_num(i),
+				     __cvmx_helper_cfg_pko_port_interface(i),
+				     __cvmx_helper_cfg_pko_port_index(i));
+		}
+	}
+}
+#endif
+
+/*
+ * initialize cvmx_cfg_pko_port_map
+ */
+static void cvmx_helper_cfg_init_pko_port_map(void)
+{
+	int i, j, k;
+	int pko_eid;
+	int pko_port_base, pko_port_max;
+	cvmx_helper_interface_mode_t mode;
+
+	/*
+	 * one pko_eid is allocated to each port except for ILK, NPI, and
+	 * LOOP. Each of the three has one eid.
+	 */
+	pko_eid = 0;
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		mode = cvmx_helper_interface_get_mode(i);
+		for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+			pko_port_base = cvmx_cfg_port[i][j].ccpp_pko_port_base;
+			pko_port_max = pko_port_base + cvmx_cfg_port[i][j].ccpp_pko_num_ports;
+			for (k = pko_port_base; k < pko_port_max; k++) {
+				cvmx_cfg_pko_port_map[k].ccppl_interface = i;
+				cvmx_cfg_pko_port_map[k].ccppl_index = j;
+				cvmx_cfg_pko_port_map[k].ccppl_eid = pko_eid;
+			}
+
+#if 0
+			/*
+			 * For a physical port that is not configured a PKO port,
+			 * pko_port_base here equals to pko_port_max. In this
+			 * case, the physical port does not take a DMA engine.
+			 */
+			if (pko_port_base > pko_port_max)
+#endif
+				if (!(mode == CVMX_HELPER_INTERFACE_MODE_NPI || mode == CVMX_HELPER_INTERFACE_MODE_LOOP || mode == CVMX_HELPER_INTERFACE_MODE_ILK))
+					pko_eid++;
+		}
+
+		if (mode == CVMX_HELPER_INTERFACE_MODE_NPI || mode == CVMX_HELPER_INTERFACE_MODE_LOOP || mode == CVMX_HELPER_INTERFACE_MODE_ILK)
+			pko_eid++;
+	}
+
+	cvmx_cfg_max_pko_engines = pko_eid;
+}
+
+int __cvmx_helper_cfg_pko_port_interface(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_interface;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_interface);
+
+int __cvmx_helper_cfg_pko_port_index(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_index;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_index);
+
+int __cvmx_helper_cfg_pko_port_eid(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_eid;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_eid);
+
+/**
+ * Perform common init tasks for all chips.
+ * Returns 1 for the caller to continue init and 0 otherwise.
+ *
+ * Note: ``common'' means this function is executed regardless of
+ *	- chip, and
+ *	- CVMX_ENABLE_HELPER_FUNCTIONS.
+ *
+ * This function decides based on these conditions if the
+ * configuration stage of the init process should continue.
+ *
+ * This is only meant to be called by __cvmx_helper_cfg_init().
+ */
+static int __cvmx_helper_cfg_init_common(void)
+{
+	int val;
+
+	val = (octeon_has_feature(OCTEON_FEATURE_PKND));
+
+	return val;
+}
+
+#define IPD2PKO_CACHE_Y(ipd_port)	((ipd_port) >> 8)
+#define IPD2PKO_CACHE_X(ipd_port)	((ipd_port) & 0xff)
+
+/*
+ * ipd_port to pko_port translation cache
+ */
+static int __cvmx_helper_cfg_init_ipd2pko_cache(void)
+{
+	int i, j, n;
+	int ipd_y, ipd_x, ipd_port;
+
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		n = cvmx_helper_interface_enumerate(i);
+
+		for (j = 0; j < n; j++) {
+			ipd_port = cvmx_helper_get_ipd_port(i, j);
+			ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+			ipd_x = IPD2PKO_CACHE_X(ipd_port);
+			ipd2pko_port_cache[ipd_y]
+			    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x] = (struct cvmx_cfg_pko_port_pair) {
+			__cvmx_helper_cfg_pko_port_base(i, j), __cvmx_helper_cfg_pko_port_num(i, j)};
+		}
+	}
+
+	return 0;
+}
+
+int cvmx_helper_cfg_ipd2pko_port_base(int ipd_port)
+{
+	int ipd_y, ipd_x;
+
+	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+	ipd_x = IPD2PKO_CACHE_X(ipd_port);
+
+	return ipd2pko_port_cache[ipd_y]
+	    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x].ccppp_base_port;
+}
+EXPORT_SYMBOL(cvmx_helper_cfg_ipd2pko_port_base);
+
+int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port)
+{
+	int ipd_y, ipd_x;
+
+	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+	ipd_x = IPD2PKO_CACHE_X(ipd_port);
+
+	return ipd2pko_port_cache[ipd_y]
+	    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x].ccppp_nports;
+}
+EXPORT_SYMBOL(cvmx_helper_cfg_ipd2pko_port_num);
+
+#ifdef CVMX_USER_DEFINED_HELPER_CONFIG_INIT
+/**
+ * Return the number of queues assigned to this pko_port by user
+ *
+ * @pko_port:
+ * Returns the number of queues for this pko_port
+ *
+ * Note: Called after the pko_port map is set up.
+ */
+static int __cvmx_ucfg_nqueues(int pko_port)
+{
+	int interface, index;
+	int i, k;
+
+	interface = __cvmx_helper_cfg_pko_port_interface(pko_port);
+	index = __cvmx_helper_cfg_pko_port_index(pko_port);
+
+	/*
+	 * pko_port belongs to no physical port,
+	 * don't assign a queue to it.
+	 */
+	if (interface == CVMX_HELPER_CFG_INVALID_VALUE || index == CVMX_HELPER_CFG_INVALID_VALUE)
+		return 0;
+
+	/*
+	 * Assign the default number of queues to those pko_ports not
+	 * assigned explicitly.
+	 */
+	i = cvmx_cfg_port[interface][index].ccpp_pko_nqueues;
+	if (i == (uint8_t) CVMX_HELPER_CFG_INVALID_VALUE)
+		return cvmx_cfg_default_pko_nqueues;
+
+	/*
+	 * The user has assigned nqueues to this pko_port,
+	 * recorded in the pool.
+	 */
+	k = pko_port - cvmx_cfg_port[interface][index].ccpp_pko_port_base;
+	return cvmx_cfg_pko_nqueue_pool[i + k];
+}
+
+#else
+
+/**
+ * Return the number of queues to be assigned to this pko_port
+ *
+ * @pko_port:
+ * Returns the number of queues for this pko_port
+ *
+ * Note: This function exists for backward compatibility.
+ * CVMX_PKO_QUEUES_PER_PORT_XXXX defines no of queues per HW port.
+ * pko_port is equivalent in pre-o68 SDK.
+ */
+static int cvmx_helper_cfg_dft_nqueues(int pko_port)
+{
+	cvmx_helper_interface_mode_t mode;
+	int interface;
+	int n;
+
+#ifndef CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE0
+#define CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE0 1
+#endif
+
+#ifndef CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE1
+#define CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE1 1
+#endif
+
+#ifndef CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE2
+#define CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE2 1
+#endif
+
+#ifndef CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE3
+#define CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE3 1
+#endif
+
+#ifndef CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE4
+#define CVMX_HELPER_PKO_QUEUES_PER_PORT_INTERFACE4 1
+#endif
+
+	n = 1;
+	interface = __cvmx_helper_cfg_pko_port_interface(pko_port);
+	if (interface == 0) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
+		n = CVMX_PKO_QUEUES_PER_PORT_INTERFACE0;
+#endif
+	}
+	if (interface == 1) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
+		n = CVMX_PKO_QUEUES_PER_PORT_INTERFACE1;
+#endif
+	}
+
+	if (interface == 2) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_INTERFACE2
+		n = CVMX_PKO_QUEUES_PER_PORT_INTERFACE2;
+#endif
+	}
+	if (interface == 3) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_INTERFACE3
+		n = CVMX_PKO_QUEUES_PER_PORT_INTERFACE3;
+#endif
+	}
+	if (interface == 4) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_INTERFACE4
+		n = CVMX_PKO_QUEUES_PER_PORT_INTERFACE4;
+#endif
+	}
+
+	mode = cvmx_helper_interface_get_mode(interface);
+	if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_LOOP
+		n = CVMX_PKO_QUEUES_PER_PORT_LOOP;
+#endif
+	}
+	if (mode == CVMX_HELPER_INTERFACE_MODE_NPI) {
+#ifdef CVMX_PKO_QUEUES_PER_PORT_PCI
+		n = CVMX_PKO_QUEUES_PER_PORT_PCI;
+#endif
+	}
+
+	return n;
+}
+#endif /* CVMX_USER_DEFINED_HELPER_CONFIG_INIT */
+
+int __cvmx_helper_cfg_init(void)
+{
+	struct cvmx_cfg_port_param *pport;
+	int cvmx_cfg_default_pko_nports;
+	int pknd, bpid, pko_port_base;
+	int qbase;
+	int i, j, n;
+
+	cvmx_cfg_default_pko_nports = 1;
+
+	if (!__cvmx_helper_cfg_init_common())
+		return 0;
+
+
+#ifdef CVMX_USER_DEFINED_HELPER_CONFIG_INIT
+	{
+		int cvmx_ucfg_nq;
+		cvmx_ucfg_nq = 0;
+#include "cvmx-helper-cfg-init.c"
+	}
+#endif
+
+	/*
+	 * per-port parameters
+	 */
+	pknd = 0;
+	bpid = 0;
+	pko_port_base = 0;
+
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		n = cvmx_helper_interface_enumerate(i);
+
+		pport = cvmx_cfg_port[i];
+		for (j = 0; j < n; j++, pport++) {
+			int t;
+
+			t = cvmx_cfg_default_pko_nports;
+			if (pport->ccpp_pko_num_ports != CVMX_HELPER_CFG_INVALID_VALUE)
+				t = pport->ccpp_pko_num_ports;
+
+			*pport = (struct cvmx_cfg_port_param) {
+			pknd++, bpid++, pko_port_base, t, pport->ccpp_pko_nqueues};
+			pko_port_base += t;
+		}
+	}
+
+	/*
+	 * pko_port map
+	 */
+	cvmx_helper_cfg_init_pko_port_map();
+
+	/*
+	 * per-pko_port parameters
+	 */
+	qbase = 0;
+	for (i = 0; i < pko_port_base; i++) {
+#ifdef CVMX_USER_DEFINED_HELPER_CONFIG_INIT
+		n = __cvmx_ucfg_nqueues(i);
+#else
+		n = cvmx_helper_cfg_dft_nqueues(i);
+#endif
+		cvmx_cfg_pko_port[i] = (struct cvmx_cfg_pko_port_param) {
+		qbase, n};
+		qbase += n;
+	}
+
+	__cvmx_helper_cfg_init_ipd2pko_cache();
+
+#ifdef CVMX_HELPER_CFG_DEBUG
+	cvmx_helper_cfg_show_cfg();
+#endif /* CVMX_HELPER_CFG_DEBUG */
+	return 0;
+}
+EXPORT_SYMBOL(__cvmx_helper_cfg_init);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-errata.c b/arch/mips/cavium-octeon/executive/cvmx-helper-errata.c
index 868659e..373fe1c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-errata.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-errata.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,22 +22,231 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- *
+/*
  * Fixes and workaround for Octeon chip errata. This file
  * contains functions called by cvmx-helper to workaround known
  * chip errata. For the most part, code doesn't need to call
  * these functions directly.
+ */
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-jtag.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+
+/**
+ * Function to adjust internal IPD pointer alignments
  *
+ * Returns 0 on success
+ *         !0 on failure
  */
-#include <linux/module.h>
+int __cvmx_helper_errata_fix_ipd_ptr_alignment(void)
+{
+#define FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES     (CVMX_FPA_PACKET_POOL_SIZE-8-CVMX_HELPER_FIRST_MBUFF_SKIP)
+#define FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES (CVMX_FPA_PACKET_POOL_SIZE-8-CVMX_HELPER_NOT_FIRST_MBUFF_SKIP)
+#define FIX_IPD_OUTPORT 0
+#define INTERFACE(port) (port >> 4)	/* Ports 0-15 are interface 0, 16-31 are interface 1 */
+#define INDEX(port) (port & 0xf)
+	uint64_t *p64;
+	cvmx_pko_command_word0_t pko_command;
+	union cvmx_buf_ptr g_buffer, pkt_buffer;
+	cvmx_wqe_t *work;
+	int size, num_segs = 0, wqe_pcnt, pkt_pcnt;
+	union cvmx_gmxx_prtx_cfg gmx_cfg;
+	int retry_cnt;
+	int retry_loop_cnt;
+	int i;
+	cvmx_helper_link_info_t link_info;
 
-#include <asm/octeon/octeon.h>
+	/* Save values for restore at end */
+	uint64_t prtx_cfg = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
+	uint64_t tx_ptr_en = cvmx_read_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)));
+	uint64_t rx_ptr_en = cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)));
+	uint64_t rxx_jabber = cvmx_read_csr(CVMX_GMXX_RXX_JABBER(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
+	uint64_t frame_max = cvmx_read_csr(CVMX_GMXX_RXX_FRM_MAX(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
+
+	/* Configure port to gig FDX as required for loopback mode */
+	cvmx_helper_rgmii_internal_loopback(FIX_IPD_OUTPORT);
+
+	/*
+	 * Disable reception on all ports so if traffic is present it
+	 * will not interfere.
+	 */
+	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), 0);
+
+	cvmx_wait(100000000ull);
+
+	for (retry_loop_cnt = 0; retry_loop_cnt < 10; retry_loop_cnt++) {
+		retry_cnt = 100000;
+		wqe_pcnt = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
+		pkt_pcnt = (wqe_pcnt >> 7) & 0x7f;
+		wqe_pcnt &= 0x7f;
+
+		num_segs = (2 + pkt_pcnt - wqe_pcnt) & 3;
+
+		if (num_segs == 0)
+			goto fix_ipd_exit;
+
+		num_segs += 1;
+
+		size = FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES + ((num_segs - 1) * FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES) - (FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES / 2);
+
+		cvmx_write_csr(CVMX_ASXX_PRT_LOOP(INTERFACE(FIX_IPD_OUTPORT)), 1 << INDEX(FIX_IPD_OUTPORT));
+		CVMX_SYNC;
+
+		g_buffer.u64 = 0;
+		g_buffer.s.addr = cvmx_ptr_to_phys(cvmx_fpa_alloc(CVMX_FPA_WQE_POOL));
+		if (g_buffer.s.addr == 0) {
+			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT buffer allocation failure.\n");
+			goto fix_ipd_exit;
+		}
+
+		g_buffer.s.pool = CVMX_FPA_WQE_POOL;
+		g_buffer.s.size = num_segs;
+
+		pkt_buffer.u64 = 0;
+		pkt_buffer.s.addr = cvmx_ptr_to_phys(cvmx_fpa_alloc(CVMX_FPA_PACKET_POOL));
+		if (pkt_buffer.s.addr == 0) {
+			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT buffer allocation failure.\n");
+			goto fix_ipd_exit;
+		}
+		pkt_buffer.s.i = 1;
+		pkt_buffer.s.pool = CVMX_FPA_PACKET_POOL;
+		pkt_buffer.s.size = FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES;
+
+		p64 = (uint64_t *) cvmx_phys_to_ptr(pkt_buffer.s.addr);
+		p64[0] = 0xffffffffffff0000ull;
+		p64[1] = 0x08004510ull;
+		p64[2] = ((uint64_t) (size - 14) << 48) | 0x5ae740004000ull;
+		p64[3] = 0x3a5fc0a81073c0a8ull;
+
+		for (i = 0; i < num_segs; i++) {
+			if (i > 0)
+				pkt_buffer.s.size = FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES;
+
+			if (i == (num_segs - 1))
+				pkt_buffer.s.i = 0;
+
+			*(uint64_t *) cvmx_phys_to_ptr(g_buffer.s.addr + 8 * i) = pkt_buffer.u64;
+		}
+
+		/* Build the PKO command */
+		pko_command.u64 = 0;
+		pko_command.s.segs = num_segs;
+		pko_command.s.total_bytes = size;
+		pko_command.s.dontfree = 0;
+		pko_command.s.gather = 1;
+
+		gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
+		gmx_cfg.s.en = 1;
+		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), gmx_cfg.u64);
+		cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), 1 << INDEX(FIX_IPD_OUTPORT));
+		cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), 1 << INDEX(FIX_IPD_OUTPORT));
+
+		cvmx_write_csr(CVMX_GMXX_RXX_JABBER(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), 65392 - 14 - 4);
+		cvmx_write_csr(CVMX_GMXX_RXX_FRM_MAX(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), 65392 - 14 - 4);
+
+		cvmx_pko_send_packet_prepare(FIX_IPD_OUTPORT, cvmx_pko_get_base_queue(FIX_IPD_OUTPORT), CVMX_PKO_LOCK_CMD_QUEUE);
+		cvmx_pko_send_packet_finish(FIX_IPD_OUTPORT, cvmx_pko_get_base_queue(FIX_IPD_OUTPORT), pko_command, g_buffer, CVMX_PKO_LOCK_CMD_QUEUE);
+
+		CVMX_SYNC;
+
+		do {
+			work = cvmx_pow_work_request_sync(CVMX_POW_WAIT);
+			retry_cnt--;
+		} while ((work == NULL) && (retry_cnt > 0));
+
+		if (!retry_cnt)
+			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT get_work() timeout occurred.\n");
+
+		/* Free packet */
+		if (work)
+			cvmx_helper_free_packet_data(work);
+	}
+
+fix_ipd_exit:
+
+	/* Return CSR configs to saved values */
+	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), prtx_cfg);
+	cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), tx_ptr_en);
+	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), rx_ptr_en);
+	cvmx_write_csr(CVMX_GMXX_RXX_JABBER(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), rxx_jabber);
+	cvmx_write_csr(CVMX_GMXX_RXX_FRM_MAX(INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)), frame_max);
+	cvmx_write_csr(CVMX_ASXX_PRT_LOOP(INTERFACE(FIX_IPD_OUTPORT)), 0);
+	/* Set link to down so autonegotiation will set it up again */
+	link_info.u64 = 0;
+	cvmx_helper_link_set(FIX_IPD_OUTPORT, link_info);
+
+	/*
+	 * Bring the link back up as autonegotiation is not done in
+	 * user applications.
+	 */
+	cvmx_helper_link_autoconf(FIX_IPD_OUTPORT);
+
+	CVMX_SYNC;
+	if (num_segs)
+		cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT failed.\n");
+
+	return !!num_segs;
+
+}
+
+/**
+ * This function needs to be called on all Octeon chips with
+ * errata PKI-100.
+ *
+ * The Size field is 8 too large in WQE and next pointers
+ *
+ *  The Size field generated by IPD is 8 larger than it should
+ *  be. The Size field is <55:40> of both:
+ *      - WORD3 in the work queue entry, and
+ *      - the next buffer pointer (which precedes the packet data
+ *        in each buffer).
+ *
+ * @work:   Work queue entry to fix
+ * Returns Zero on success. Negative on failure
+ */
+int cvmx_helper_fix_ipd_packet_chain(cvmx_wqe_t *work)
+{
+	uint64_t number_buffers = work->word2.s.bufs;
+
+	/* We only need to do this if the work has buffers */
+	if (number_buffers) {
+		union cvmx_buf_ptr buffer_ptr = work->packet_ptr;
+		/* Check for errata PKI-100 */
+		if ((buffer_ptr.s.pool == 0) && (((uint64_t) buffer_ptr.s.size + ((uint64_t) buffer_ptr.s.back << 7) + ((uint64_t) buffer_ptr.s.addr & 0x7F))
+						 != (CVMX_FPA_PACKET_POOL_SIZE + 8))) {
+			/* fix is not needed */
+			return 0;
+		}
+		/* Decrement the work packet pointer */
+		buffer_ptr.s.size -= 8;
+		work->packet_ptr = buffer_ptr;
+
+		/*
+		 * Now loop through decrementing the size for each
+		 * additional buffer.
+		 */
+		while (--number_buffers) {
+			/* Chain pointers are 8 bytes before the data */
+			union cvmx_buf_ptr *ptr = (union cvmx_buf_ptr *)cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
+			buffer_ptr = *ptr;
+			buffer_ptr.s.size -= 8;
+			*ptr = buffer_ptr;
+		}
+	}
+	/*
+	 * Make sure that these write go out before other operations
+	 * such as FPA frees.
+	 */
+	wmb();
+	return 0;
+}
 
-#include <asm/octeon/cvmx-helper-jtag.h>
 
 /**
  * Due to errata G-720, the 2nd order CDR circuit on CN52XX pass
@@ -49,13 +258,20 @@
 void __cvmx_helper_errata_qlm_disable_2nd_order_cdr(int qlm)
 {
 	int lane;
+	/* Apply the workaround only once. */
+	union cvmx_ciu_qlm_jtgd qlm_jtgd;
+	qlm_jtgd.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGD);
+	if (qlm_jtgd.s.select != 0)
+		return;
+
 	cvmx_helper_qlm_jtag_init();
 	/* We need to load all four lanes of the QLM, a total of 1072 bits */
 	for (lane = 0; lane < 4; lane++) {
 		/*
 		 * Each lane has 268 bits. We need to set
-		 * cfg_cdr_incx<67:64> = 3 and cfg_cdr_secord<77> =
-		 * 1. All other bits are zero. Bits go in LSB first,
+		 * cfg_cdr_incx<67:64> = 3 and
+		 * cfg_cdr_secord<77> = 1.
+		 * All other bits are zero. Bits go in LSB first,
 		 * so start off with the zeros for bits <63:0>.
 		 */
 		cvmx_helper_qlm_jtag_shift_zeros(qlm, 63 - 0 + 1);
@@ -70,4 +286,3 @@ void __cvmx_helper_errata_qlm_disable_2nd_order_cdr(int qlm)
 	}
 	cvmx_helper_qlm_jtag_update(qlm);
 }
-EXPORT_SYMBOL(__cvmx_helper_errata_qlm_disable_2nd_order_cdr);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
new file mode 100644
index 0000000..2a2bb27
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
@@ -0,0 +1,410 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Functions for ILK initialization, configuration,
+ * and monitoring.
+ */
+
+#include <linux/export.h>
+#include <linux/slab.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-ilk.h>
+#include <asm/octeon/cvmx-bootmem.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-ilk-defs.h>
+
+
+#ifndef CVMX_HELPER_ILK_LA_MODE_INTERFACE0
+#define CVMX_HELPER_ILK_LA_MODE_INTERFACE0 0
+#endif
+#ifndef CVMX_HELPER_ILK_LA_MODE_INTERFACE1
+#define CVMX_HELPER_ILK_LA_MODE_INTERFACE1 0
+#endif
+
+int __cvmx_helper_ilk_enumerate(int interface)
+{
+	interface -= CVMX_ILK_GBL_BASE;
+	return cvmx_ilk_chans[interface];
+}
+
+/**
+ * Probe a ILK interface and determine the number of ports
+ * connected to it. The ILK interface should still be down
+ * after this call.
+ *
+ * @interface: Interface to probe
+ *
+ * Returns Number of ports on the interface. Zero to disable.
+ */
+int __cvmx_helper_ilk_probe(int interface)
+{
+	int i, j, num_pknd, res = -1;
+	static int pipe_base, pknd_base;
+	static struct cvmx_ilk_pipe_chan *pch, *tmp;
+	static struct cvmx_ilk_chan_pknd *chpknd, *tmp1;
+	static struct cvmx_ilk_cal_entry *calent, *tmp2;
+	int enable_rx_cal;
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 0;
+
+	interface -= CVMX_ILK_GBL_BASE;
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return 0;
+
+	/* the configuration should be done only once */
+	if (cvmx_ilk_get_intf_ena(interface))
+		return cvmx_ilk_chans[interface];
+
+	/* configure lanes and enable the link */
+	res = cvmx_ilk_start_interface(interface, cvmx_ilk_lane_mask[interface]);
+	if (res < 0)
+		return 0;
+
+	/* set up the group of pipes available to ilk */
+	if (pipe_base == 0)
+		pipe_base = __cvmx_pko_get_pipe(interface + CVMX_ILK_GBL_BASE, 0);
+
+	if (pipe_base == -1) {
+		pipe_base = 0;
+		return 0;
+	}
+
+	res = cvmx_ilk_set_pipe(interface, pipe_base, cvmx_ilk_chans[interface]);
+	if (res < 0)
+		return 0;
+
+	/* set up pipe to channel mapping */
+	i = pipe_base;
+	if (pch == NULL) {
+		pch = kmalloc(CVMX_MAX_ILK_CHANS * sizeof(struct cvmx_ilk_pipe_chan),
+			      GFP_KERNEL);
+		if (pch == NULL)
+			return 0;
+	}
+
+	memset(pch, 0, CVMX_MAX_ILK_CHANS * sizeof(struct cvmx_ilk_pipe_chan));
+	tmp = pch;
+	for (j = 0; j < cvmx_ilk_chans[interface]; j++) {
+		tmp->pipe = i++;
+		tmp->chan = cvmx_ilk_chan_map[interface][j];
+		tmp++;
+	}
+	res = cvmx_ilk_tx_set_channel(interface, pch, cvmx_ilk_chans[interface]);
+	if (res < 0) {
+		res = 0;
+		goto err_free_pch;
+	}
+	pipe_base += cvmx_ilk_chans[interface];
+
+	/* set up channel to pkind mapping */
+	if (pknd_base == 0)
+		pknd_base = cvmx_helper_get_pknd(interface + CVMX_ILK_GBL_BASE, 0);
+
+	i = pknd_base;
+	if (chpknd == NULL) {
+		chpknd = kmalloc(CVMX_MAX_ILK_PKNDS * sizeof(struct cvmx_ilk_chan_pknd),
+				 GFP_KERNEL);
+		if (chpknd == NULL) {
+			pipe_base -= cvmx_ilk_chans[interface];
+			res = 0;
+			goto err_free_pch;
+		}
+	}
+
+	memset(chpknd, 0, CVMX_MAX_ILK_PKNDS * sizeof(struct cvmx_ilk_chan_pknd));
+	tmp1 = chpknd;
+	for (j = 0; j < cvmx_ilk_chans[interface]; j++) {
+		tmp1->chan = cvmx_ilk_chan_map[interface][j];
+		tmp1->pknd = i++;
+		tmp1++;
+	}
+
+	num_pknd = cvmx_ilk_chans[interface];
+	res = cvmx_ilk_rx_set_pknd(interface, chpknd, num_pknd);
+	if (res < 0) {
+		pipe_base -= cvmx_ilk_chans[interface];
+		res = 0;
+		goto err_free_chpknd;
+	}
+	pknd_base += cvmx_ilk_chans[interface];
+
+	/* Set up tx calendar */
+	if (calent == NULL) {
+		calent = kmalloc(CVMX_MAX_ILK_PIPES * sizeof(struct cvmx_ilk_cal_entry),
+				 GFP_KERNEL);
+		if (calent == NULL) {
+			pipe_base -= cvmx_ilk_chans[interface];
+			pknd_base -= cvmx_ilk_chans[interface];
+			res = 0;
+			goto err_free_chpknd;
+		}
+	}
+
+	memset(calent, 0, CVMX_MAX_ILK_PIPES * sizeof(struct cvmx_ilk_cal_entry));
+	tmp1 = chpknd;
+	tmp2 = calent;
+	for (j = 0; j < cvmx_ilk_chans[interface]; j++) {
+		tmp2->pipe_bpid = tmp1->pknd;
+		tmp2->ent_ctrl = PIPE_BPID;
+		tmp1++;
+		tmp2++;
+	}
+	res = cvmx_ilk_cal_setup_tx(interface, cvmx_ilk_chans[interface], calent, 1);
+	if (res < 0) {
+		pipe_base -= cvmx_ilk_chans[interface];
+		pknd_base -= cvmx_ilk_chans[interface];
+		res = 0;
+		goto err_free_calent;
+	}
+
+	/*
+	 * set up rx calendar. allocated memory can be reused.
+	 * this is because max pkind is always less than max pipe.
+	 */
+	memset(calent, 0, CVMX_MAX_ILK_PIPES * sizeof(struct cvmx_ilk_cal_entry));
+	tmp = pch;
+	tmp2 = calent;
+	for (j = 0; j < cvmx_ilk_chans[interface]; j++) {
+		tmp2->pipe_bpid = tmp->pipe;
+		tmp2->ent_ctrl = PIPE_BPID;
+		tmp++;
+		tmp2++;
+	}
+	if (cvmx_ilk_use_la_mode(interface, 0))
+		enable_rx_cal = cvmx_ilk_la_mode_enable_rx_calendar(interface);
+	else
+		enable_rx_cal = 1;
+
+	res = cvmx_ilk_cal_setup_rx(interface, cvmx_ilk_chans[interface], calent, CVMX_ILK_RX_FIFO_WM, enable_rx_cal);
+	if (res < 0) {
+		pipe_base -= cvmx_ilk_chans[interface];
+		pknd_base -= cvmx_ilk_chans[interface];
+		res = 0;
+		goto err_free_calent;
+	}
+	res = __cvmx_helper_ilk_enumerate(interface + CVMX_ILK_GBL_BASE);
+
+	goto out;
+
+err_free_calent:
+	kfree(calent);
+
+err_free_chpknd:
+	kfree(chpknd);
+
+err_free_pch:
+	kfree(pch);
+out:
+	return res;
+}
+
+/**
+ * Bringup and enable ILK interface. After this call packet
+ * I/O should be fully functional. This is called with IPD
+ * enabled but PKO disabled.
+ *
+ * @interface: Interface to bring up
+ *
+ * Returns Zero on success, negative on failure
+ */
+int __cvmx_helper_ilk_enable(int interface)
+{
+	interface -= CVMX_ILK_GBL_BASE;
+	return cvmx_ilk_enable(interface);
+}
+
+/**
+ * Return the link state of an IPD/PKO port as returned by ILK link status.
+ *
+ * @ipd_port: IPD/PKO port to query
+ *
+ * Returns Link state
+ */
+cvmx_helper_link_info_t __cvmx_helper_ilk_link_get(int ipd_port)
+{
+	cvmx_helper_link_info_t result;
+	int interface = cvmx_helper_get_interface_num(ipd_port);
+	int retry_count = 0;
+	union cvmx_ilk_rxx_cfg1 ilk_rxx_cfg1;
+	union cvmx_ilk_rxx_int ilk_rxx_int;
+	int lane_mask = 0;
+	int i;
+
+	result.u64 = 0;
+	interface -= CVMX_ILK_GBL_BASE;
+
+retry:
+	retry_count++;
+	if (retry_count > 10)
+		goto fail;
+
+	/* Read RX config and status bits */
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	ilk_rxx_int.u64 = cvmx_read_csr(CVMX_ILK_RXX_INT(interface));
+
+	if (ilk_rxx_cfg1.s.rx_bdry_lock_ena == 0) {
+		/* Clear the boundary lock status bit */
+		ilk_rxx_int.u64 = 0;
+		ilk_rxx_int.s.word_sync_done = 1;
+		cvmx_write_csr(CVMX_ILK_RXX_INT(interface), ilk_rxx_int.u64);
+
+		/* We need to start looking for work boundary lock */
+		ilk_rxx_cfg1.s.rx_bdry_lock_ena = cvmx_ilk_get_intf_ln_msk(interface);
+		ilk_rxx_cfg1.s.rx_align_ena = 0;
+		cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+		goto retry;
+	}
+
+	if (ilk_rxx_cfg1.s.rx_align_ena == 0) {
+		if (ilk_rxx_int.s.word_sync_done) {
+			/* Clear the lane align status bits */
+			ilk_rxx_int.u64 = 0;
+			ilk_rxx_int.s.lane_align_fail = 1;
+			ilk_rxx_int.s.lane_align_done = 1;
+			cvmx_write_csr(CVMX_ILK_RXX_INT(interface), ilk_rxx_int.u64);
+
+			ilk_rxx_cfg1.s.rx_align_ena = 1;
+			cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+			goto retry;
+		}
+		goto fail;
+	}
+
+	if (ilk_rxx_int.s.lane_align_fail) {
+		ilk_rxx_cfg1.s.rx_bdry_lock_ena = 0;
+		ilk_rxx_cfg1.s.rx_align_ena = 0;
+		cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+		goto fail;
+	}
+
+	lane_mask = ilk_rxx_cfg1.s.rx_bdry_lock_ena;
+
+	if (ilk_rxx_cfg1.s.pkt_ena == 0 && ilk_rxx_int.s.lane_align_done) {
+		union cvmx_ilk_txx_cfg1 ilk_txx_cfg1;
+
+		ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+		ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+		ilk_rxx_cfg1.s.pkt_ena = ilk_txx_cfg1.s.pkt_ena;
+		cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+
+		/*
+		 * Enable rxf_ctl_perr, rxf_lnk0_perr, rxf_lnk1_perr,
+		 * pop_empty, push_full
+		 */
+		cvmx_write_csr(CVMX_ILK_GBL_INT_EN, 0x1f);
+		/* Enable bad_pipe, bad_seq, txf_err */
+		cvmx_write_csr(CVMX_ILK_TXX_INT_EN(interface), 0x7);
+		/* Enable crc24_err, lane_bad_word, pkt_drop_{rid,rxf,sop} */
+		cvmx_write_csr(CVMX_ILK_RXX_INT_EN(interface), 0x1e2);
+
+		for (i = 0; i < CVMX_MAX_ILK_LANES; i++) {
+			if ((1 << i) & lane_mask) {
+				/* clear pending interrupts, before enabling. */
+				cvmx_write_csr(CVMX_ILK_RX_LNEX_INT(i), 0x1ff);
+				/*
+				 * Enable bad_64b67b, bdry_sync_loss,
+				 * crc32_err, dskew_fifo_ovfl,
+				 * scrm_sync_loss, serdes_lock_loss,
+				 * stat_msg, ukwn_cntl_word.
+				 */
+				cvmx_write_csr(CVMX_ILK_RX_LNEX_INT_EN(i), 0x1ff);
+			}
+		}
+	}
+
+	result.s.link_up = 1;
+	result.s.full_duplex = 1;
+	result.s.speed = cvmx_qlm_get_gbaud_mhz(1 + interface) * 64 / 67;
+	result.s.speed *= cvmx_pop(lane_mask);
+
+	return result;
+
+fail:
+	if (ilk_rxx_cfg1.s.pkt_ena) {
+		/* Disable the interface */
+		ilk_rxx_cfg1.s.pkt_ena = 0;
+		cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+
+		/* Disable error interrupts */
+		for (i = 0; i < CVMX_MAX_ILK_LANES; i++) {
+			/* Disable bad_64b67b, bdry_sync_loss, crc32_err, dskew_fifo_ovfl,
+			   scrm_sync_loss, serdes_lock_loss, stat_msg, ukwn_cntl_word */
+			if ((1 << i) & lane_mask) {
+				cvmx_write_csr(CVMX_ILK_RX_LNEX_INT(i), 0x1ff);
+				cvmx_write_csr(CVMX_ILK_RX_LNEX_INT_EN(i), ~0x1ff);
+			}
+		}
+	}
+
+	return result;
+}
+
+/**
+ * Set the link state of an IPD/PKO port.
+ *
+ * @ipd_port:  IPD/PKO port to configure
+ * @link_info: The new link state
+ *
+ * Returns Zero on success, negative on failure
+ */
+int __cvmx_helper_ilk_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
+{
+	/* Do nothing */
+	return 0;
+}
+
+/**
+ * Display ilk interface statistics.
+ *
+ */
+void __cvmx_helper_ilk_show_stats(void)
+{
+	int i, j;
+	unsigned char *pchans, num_chans;
+	unsigned int chan_tmp[CVMX_MAX_ILK_CHANS];
+	struct cvmx_ilk_stats_ctrl ilk_stats_ctrl;
+
+	for (i = 0; i < CVMX_NUM_ILK_INTF; i++) {
+		cvmx_ilk_get_chan_info(i, &pchans, &num_chans);
+
+		memset(chan_tmp, 0, CVMX_MAX_ILK_CHANS * sizeof(int));
+		for (j = 0; j < num_chans; j++)
+			chan_tmp[j] = pchans[j];
+
+		ilk_stats_ctrl.chan_list = chan_tmp;
+		ilk_stats_ctrl.num_chans = num_chans;
+		ilk_stats_ctrl.clr_on_rd = 0;
+		cvmx_ilk_show_stats(i, &ilk_stats_ctrl);
+	}
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-jtag.c b/arch/mips/cavium-octeon/executive/cvmx-helper-jtag.c
index c1c5489..4255265 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-jtag.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-jtag.c
@@ -1,11 +1,11 @@
 
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -23,19 +23,15 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- *
+/*
  * Helper utilities for qlm_jtag.
- *
  */
-
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-helper-jtag.h>
 
-
 /**
  * Initialize the internal QLM JTAG logic to allow programming
  * of the JTAG chain by the cvmx_helper_qlm_jtag_*() functions.
@@ -46,17 +42,20 @@
 void cvmx_helper_qlm_jtag_init(void)
 {
 	union cvmx_ciu_qlm_jtgc jtgc;
-	uint32_t clock_div = 0;
-	uint32_t divisor = cvmx_sysinfo_get()->cpu_clock_hz / (25 * 1000000);
+	int clock_div = 0;
+	int divisor;
+
+	divisor = octeon_get_io_clock_rate() / (1000000 * (OCTEON_IS_MODEL(OCTEON_CN68XX) ? 10 : 25));
+
 	divisor = (divisor - 1) >> 2;
 	/* Convert the divisor into a power of 2 shift */
 	while (divisor) {
 		clock_div++;
-		divisor = divisor >> 1;
+		divisor >>= 1;
 	}
 
 	/*
-	 * Clock divider for QLM JTAG operations.  eclk is divided by
+	 * Clock divider for QLM JTAG operations.  sclk is divided by
 	 * 2^(CLK_DIV + 2)
 	 */
 	jtgc.u64 = 0;
@@ -64,8 +63,12 @@ void cvmx_helper_qlm_jtag_init(void)
 	jtgc.s.mux_sel = 0;
 	if (OCTEON_IS_MODEL(OCTEON_CN52XX))
 		jtgc.s.bypass = 0x3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX))
+		jtgc.s.bypass = 0x7;
 	else
 		jtgc.s.bypass = 0xf;
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		jtgc.s.bypass_ext = 1;
 	cvmx_write_csr(CVMX_CIU_QLM_JTGC, jtgc.u64);
 	cvmx_read_csr(CVMX_CIU_QLM_JTGC);
 }
@@ -73,8 +76,9 @@ void cvmx_helper_qlm_jtag_init(void)
 /**
  * Write up to 32bits into the QLM jtag chain. Bits are shifted
  * into the MSB and out the LSB, so you should shift in the low
- * order bits followed by the high order bits. The JTAG chain is
- * 4 * 268 bits long, or 1072.
+ * order bits followed by the high order bits. The JTAG chain for
+ * CN52XX and CN56XX is 4 * 268 bits long, or 1072. The JTAG chain
+ * for CN63XX is 4 * 300 bits long, or 1200.
  *
  * @qlm:    QLM to shift value into
  * @bits:   Number of bits to shift in (1-32).
@@ -86,7 +90,16 @@ void cvmx_helper_qlm_jtag_init(void)
  */
 uint32_t cvmx_helper_qlm_jtag_shift(int qlm, int bits, uint32_t data)
 {
+	union cvmx_ciu_qlm_jtgc jtgc;
 	union cvmx_ciu_qlm_jtgd jtgd;
+
+	jtgc.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+	jtgc.s.mux_sel = qlm;
+	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX) && !OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		jtgc.s.bypass = 1 << qlm;
+	cvmx_write_csr(CVMX_CIU_QLM_JTGC, jtgc.u64);
+	cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+
 	jtgd.u64 = 0;
 	jtgd.s.shift = 1;
 	jtgd.s.shft_cnt = bits - 1;
@@ -123,15 +136,24 @@ void cvmx_helper_qlm_jtag_shift_zeros(int qlm, int bits)
 
 /**
  * Program the QLM JTAG chain into all lanes of the QLM. You must
- * have already shifted in 268*4, or 1072 bits into the JTAG
- * chain. Updating invalid values can possibly cause chip damage.
+ * have already shifted in the proper number of bits into the
+ * JTAG chain. Updating invalid values can possibly cause chip damage.
  *
  * @qlm:    QLM to program
  */
 void cvmx_helper_qlm_jtag_update(int qlm)
 {
+	union cvmx_ciu_qlm_jtgc jtgc;
 	union cvmx_ciu_qlm_jtgd jtgd;
 
+	jtgc.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+	jtgc.s.mux_sel = qlm;
+	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX) && !OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		jtgc.s.bypass = 1 << qlm;
+
+	cvmx_write_csr(CVMX_CIU_QLM_JTGC, jtgc.u64);
+	cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+
 	/* Update the new data */
 	jtgd.u64 = 0;
 	jtgd.s.update = 1;
@@ -142,3 +164,31 @@ void cvmx_helper_qlm_jtag_update(int qlm)
 		jtgd.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGD);
 	} while (jtgd.s.update);
 }
+
+/**
+ * Load the QLM JTAG chain with data from all lanes of the QLM.
+ *
+ * @qlm:    QLM to program
+ */
+void cvmx_helper_qlm_jtag_capture(int qlm)
+{
+	union cvmx_ciu_qlm_jtgc jtgc;
+	union cvmx_ciu_qlm_jtgd jtgd;
+
+	jtgc.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+	jtgc.s.mux_sel = qlm;
+	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX) && !OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		jtgc.s.bypass = 1 << qlm;
+
+	cvmx_write_csr(CVMX_CIU_QLM_JTGC, jtgc.u64);
+	cvmx_read_csr(CVMX_CIU_QLM_JTGC);
+
+	jtgd.u64 = 0;
+	jtgd.s.capture = 1;
+	if (!OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X))
+		jtgd.s.select = 1 << qlm;
+	cvmx_write_csr(CVMX_CIU_QLM_JTGD, jtgd.u64);
+	do {
+		jtgd.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGD);
+	} while (jtgd.s.capture);
+}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
index bfbd461..6a6e75d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,20 +22,23 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Functions for LOOP initialization, configuration,
  * and monitoring.
  */
-#include <asm/octeon/octeon.h>
-
+#include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-config.h>
-
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-pip-defs.h>
 
+int __cvmx_helper_loop_enumerate(int interface)
+{
+	return OCTEON_IS_MODEL(OCTEON_CN68XX) ? 8 : (OCTEON_IS_MODEL(OCTEON_CNF71XX) ? 2 : 4);
+}
+
 /**
  * Probe a LOOP interface and determine the number of ports
  * connected to it. The LOOP interface should still be down
@@ -47,26 +50,7 @@
  */
 int __cvmx_helper_loop_probe(int interface)
 {
-	union cvmx_ipd_sub_port_fcs ipd_sub_port_fcs;
-	int num_ports = 4;
-	int port;
-
-	/* We need to disable length checking so packet < 64 bytes and jumbo
-	   frames don't get errors */
-	for (port = 0; port < num_ports; port++) {
-		union cvmx_pip_prt_cfgx port_cfg;
-		int ipd_port = cvmx_helper_get_ipd_port(interface, port);
-		port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
-		port_cfg.s.maxerr_en = 0;
-		port_cfg.s.minerr_en = 0;
-		cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port), port_cfg.u64);
-	}
-
-	/* Disable FCS stripping for loopback ports */
-	ipd_sub_port_fcs.u64 = cvmx_read_csr(CVMX_IPD_SUB_PORT_FCS);
-	ipd_sub_port_fcs.s.port_bit2 = 0;
-	cvmx_write_csr(CVMX_IPD_SUB_PORT_FCS, ipd_sub_port_fcs.u64);
-	return num_ports;
+	return __cvmx_helper_loop_enumerate(interface);
 }
 
 /**
@@ -80,6 +64,35 @@ int __cvmx_helper_loop_probe(int interface)
  */
 int __cvmx_helper_loop_enable(int interface)
 {
-	/* Do nothing. */
+	union cvmx_pip_prt_cfgx port_cfg;
+	int num_ports, index;
+	unsigned long offset;
+
+	num_ports = __cvmx_helper_get_num_ipd_ports(interface);
+
+	/*
+	 * We need to disable length checking so packet < 64 bytes and jumbo
+	 * frames don't get errors
+	 */
+	for (index = 0; index < num_ports; index++) {
+		offset = ((octeon_has_feature(OCTEON_FEATURE_PKND)) ? cvmx_helper_get_pknd(interface, index) : cvmx_helper_get_ipd_port(interface, index));
+
+		port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(offset));
+		port_cfg.s.maxerr_en = 0;
+		port_cfg.s.minerr_en = 0;
+		cvmx_write_csr(CVMX_PIP_PRT_CFGX(offset), port_cfg.u64);
+	}
+
+	/*
+	 * Disable FCS stripping for loopback ports
+	 */
+	if (!octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		union cvmx_ipd_sub_port_fcs ipd_sub_port_fcs;
+		ipd_sub_port_fcs.u64 = cvmx_read_csr(CVMX_IPD_SUB_PORT_FCS);
+		ipd_sub_port_fcs.s.port_bit2 = 0;
+		cvmx_write_csr(CVMX_IPD_SUB_PORT_FCS, ipd_sub_port_fcs.u64);
+	}
+
 	return 0;
 }
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index cc94cfa..8acfb2a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,7 +22,7 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
@@ -30,11 +30,10 @@
  * and monitoring.
  */
 #include <asm/octeon/octeon.h>
-
-#include <asm/octeon/cvmx-config.h>
-
 #include <asm/octeon/cvmx-helper.h>
-
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
 #include <asm/octeon/cvmx-pip-defs.h>
 
 /**
@@ -49,28 +48,27 @@
 int __cvmx_helper_npi_probe(int interface)
 {
 #if CVMX_PKO_QUEUES_PER_PORT_PCI > 0
-	if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX))
-		return 4;
-	else if (OCTEON_IS_MODEL(OCTEON_CN56XX)
-		 && !OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X))
-		/* The packet engines didn't exist before pass 2 */
-		return 4;
-	else if (OCTEON_IS_MODEL(OCTEON_CN52XX)
-		 && !OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X))
-		/* The packet engines didn't exist before pass 2 */
-		return 4;
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 32;
 #if 0
 	/*
 	 * Technically CN30XX, CN31XX, and CN50XX contain packet
 	 * engines, but nobody ever uses them. Since this is the case,
 	 * we disable them here.
 	 */
-	else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
-		 || OCTEON_IS_MODEL(OCTEON_CN50XX))
+	else if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+		 OCTEON_IS_MODEL(OCTEON_CN50XX))
 		return 2;
 	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
 		return 1;
 #endif
+	else if (!(OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X) ||
+		   OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X) ||
+		   OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+		   OCTEON_IS_MODEL(OCTEON_CN50XX) ||
+		   OCTEON_IS_MODEL(OCTEON_CN30XX)))
+		/* The packet engines didn't exist before cn56xx pass 2 */
+		return 4;
 #endif
 	return 0;
 }
@@ -86,28 +84,55 @@ int __cvmx_helper_npi_probe(int interface)
  */
 int __cvmx_helper_npi_enable(int interface)
 {
+	int port;
+	int num_ports = cvmx_helper_ports_on_interface(interface);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN58XX))
+		/*
+		 * Enables are controlled by the remote host, so
+		 * nothing to do here.
+		 */
+		return 0;
+
 	/*
 	 * On CN50XX, CN52XX, and CN56XX we need to disable length
 	 * checking so packet < 64 bytes and jumbo frames don't get
 	 * errors.
 	 */
-	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN58XX)) {
-		int num_ports = cvmx_helper_ports_on_interface(interface);
-		int port;
-		for (port = 0; port < num_ports; port++) {
-			union cvmx_pip_prt_cfgx port_cfg;
-			int ipd_port =
-			    cvmx_helper_get_ipd_port(interface, port);
-			port_cfg.u64 =
-			    cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
-			port_cfg.s.maxerr_en = 0;
-			port_cfg.s.minerr_en = 0;
-			cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port),
-				       port_cfg.u64);
+	for (port = 0; port < num_ports; port++) {
+		union cvmx_pip_prt_cfgx port_cfg;
+		int ipd_port = (OCTEON_IS_MODEL(OCTEON_CN68XX)) ? cvmx_helper_get_pknd(interface, port) : cvmx_helper_get_ipd_port(interface, port);
+		port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
+		port_cfg.s.lenerr_en = 0;
+		port_cfg.s.maxerr_en = 0;
+		port_cfg.s.minerr_en = 0;
+		cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port), port_cfg.u64);
+
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+			/* Set up pknd and bpid */
+			union cvmx_sli_portx_pkind config;
+			config.u64 = cvmx_read_csr(CVMX_PEXP_SLI_PORTX_PKIND(port));
+			config.s.bpkind = cvmx_helper_get_bpid(interface, port);
+			config.s.pkind = cvmx_helper_get_pknd(interface, port);
+			cvmx_write_csr(CVMX_PEXP_SLI_PORTX_PKIND(port), config.u64);
 		}
 	}
 
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		/*
+		 * Set up pko pipes.
+		 */
+		union cvmx_sli_tx_pipe config;
+		config.u64 = cvmx_read_csr(CVMX_PEXP_SLI_TX_PIPE);
+		config.s.base = __cvmx_pko_get_pipe(interface, 0);
+#ifdef CVMX_HELPER_NPI_MAX_PIPES
+		config.s.nump = CVMX_HELPER_NPI_MAX_PIPES;
+#else
+		config.s.nump = num_ports;
+#endif
+		cvmx_write_csr(CVMX_PEXP_SLI_TX_PIPE, config.u64);
+	}
+
 	/* Enables are controlled by the remote host, so nothing to do here */
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
index 82b2184..c1db656 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,30 +22,25 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Functions for RGMII/GMII/MII initialization, configuration,
  * and monitoring.
  */
-#include <asm/octeon/octeon.h>
-
+#include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-config.h>
-
-
-#include <asm/octeon/cvmx-mdio.h>
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-board.h>
-
-#include <asm/octeon/cvmx-npi-defs.h>
-#include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-npi-defs.h>
 #include <asm/octeon/cvmx-dbg-defs.h>
 
-void __cvmx_interrupt_gmxx_enable(int interface);
-void __cvmx_interrupt_asxx_enable(int block);
+
 
 /**
  * Probe RGMII ports and determine the number present
@@ -61,34 +56,29 @@ int __cvmx_helper_rgmii_probe(int interface)
 	mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
 
 	if (mode.s.type) {
-		if (OCTEON_IS_MODEL(OCTEON_CN38XX)
-		    || OCTEON_IS_MODEL(OCTEON_CN58XX)) {
-			cvmx_dprintf("ERROR: RGMII initialize called in "
-				     "SPI interface\n");
-		} else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
-			   || OCTEON_IS_MODEL(OCTEON_CN30XX)
-			   || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		if (OCTEON_IS_MODEL(OCTEON_CN38XX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN58XX))
+			cvmx_dprintf("ERROR: RGMII initialize called in SPI interface\n");
+		else if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+			 OCTEON_IS_MODEL(OCTEON_CN30XX) ||
+			 OCTEON_IS_MODEL(OCTEON_CN50XX))
 			/*
 			 * On these chips "type" says we're in
 			 * GMII/MII mode. This limits us to 2 ports
 			 */
 			num_ports = 2;
-		} else {
-			cvmx_dprintf("ERROR: Unsupported Octeon model in %s\n",
-				     __func__);
-		}
+		else
+			cvmx_dprintf("ERROR: Unsupported Octeon model in %s\n", __func__);
 	} else {
-		if (OCTEON_IS_MODEL(OCTEON_CN38XX)
-		    || OCTEON_IS_MODEL(OCTEON_CN58XX)) {
+		if (OCTEON_IS_MODEL(OCTEON_CN38XX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN58XX))
 			num_ports = 4;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
-			   || OCTEON_IS_MODEL(OCTEON_CN30XX)
-			   || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		else if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+			 OCTEON_IS_MODEL(OCTEON_CN30XX) ||
+			 OCTEON_IS_MODEL(OCTEON_CN50XX))
 			num_ports = 3;
-		} else {
-			cvmx_dprintf("ERROR: Unsupported Octeon model in %s\n",
-				     __func__);
-		}
+		else
+			cvmx_dprintf("ERROR: Unsupported Octeon model in %s\n", __func__);
 	}
 	return num_ports;
 }
@@ -126,34 +116,6 @@ void cvmx_helper_rgmii_internal_loopback(int port)
 }
 
 /**
- * Workaround ASX setup errata with CN38XX pass1
- *
- * @interface: Interface to setup
- * @port:      Port to setup (0..3)
- * @cpu_clock_hz:
- *                  Chip frequency in Hertz
- *
- * Returns Zero on success, negative on failure
- */
-static int __cvmx_helper_errata_asx_pass1(int interface, int port,
-					  int cpu_clock_hz)
-{
-	/* Set hi water mark as per errata GMX-4 */
-	if (cpu_clock_hz >= 325000000 && cpu_clock_hz < 375000000)
-		cvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 12);
-	else if (cpu_clock_hz >= 375000000 && cpu_clock_hz < 437000000)
-		cvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 11);
-	else if (cpu_clock_hz >= 437000000 && cpu_clock_hz < 550000000)
-		cvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 10);
-	else if (cpu_clock_hz >= 550000000 && cpu_clock_hz < 687000000)
-		cvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 9);
-	else
-		cvmx_dprintf("Illegal clock frequency (%d). "
-			"CVMX_ASXX_TX_HI_WATERX not set\n", cpu_clock_hz);
-	return 0;
-}
-
-/**
  * Configure all of the ASX, GMX, and PKO regsiters required
  * to get RGMII to function on the supplied interface.
  *
@@ -165,13 +127,14 @@ int __cvmx_helper_rgmii_enable(int interface)
 {
 	int num_ports = cvmx_helper_ports_on_interface(interface);
 	int port;
-	struct cvmx_sysinfo *sys_info_ptr = cvmx_sysinfo_get();
 	union cvmx_gmxx_inf_mode mode;
 	union cvmx_asxx_tx_prt_en asx_tx;
 	union cvmx_asxx_rx_prt_en asx_rx;
 
 	mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
 
+	if (num_ports == -1)
+		return -1;
 	if (mode.s.en == 0)
 		return -1;
 	if ((OCTEON_IS_MODEL(OCTEON_CN38XX) ||
@@ -190,28 +153,15 @@ int __cvmx_helper_rgmii_enable(int interface)
 
 	/* Configure the GMX registers needed to use the RGMII ports */
 	for (port = 0; port < num_ports; port++) {
-		/* Setting of CVMX_GMXX_TXX_THRESH has been moved to
-		   __cvmx_helper_setup_gmx() */
-
-		if (cvmx_octeon_is_pass1())
-			__cvmx_helper_errata_asx_pass1(interface, port,
-						       sys_info_ptr->
-						       cpu_clock_hz);
-		else {
-			/*
-			 * Configure more flexible RGMII preamble
-			 * checking. Pass 1 doesn't support this
-			 * feature.
-			 */
-			union cvmx_gmxx_rxx_frm_ctl frm_ctl;
-			frm_ctl.u64 =
-			    cvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL
-					  (port, interface));
-			/* New field, so must be compile time */
-			frm_ctl.s.pre_free = 1;
-			cvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(port, interface),
-				       frm_ctl.u64);
-		}
+		/*
+		 * Configure more flexible RGMII preamble
+		 * checking. Pass 1 doesn't support this feature.
+		 */
+		union cvmx_gmxx_rxx_frm_ctl frm_ctl;
+		frm_ctl.u64 = cvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL(port, interface));
+		/* New field, so must be compile time */
+		frm_ctl.s.pre_free = 1;
+		cvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(port, interface), frm_ctl.u64);
 
 		/*
 		 * Each pause frame transmitted will ask for about 10M
@@ -220,21 +170,15 @@ int __cvmx_helper_rgmii_enable(int interface)
 		 * pause frame (0 time) will be transmitted to restart
 		 * the flow.
 		 */
-		cvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_TIME(port, interface),
-			       20000);
-		cvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL
-			       (port, interface), 19000);
+		cvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_TIME(port, interface), 20000);
+		cvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL(port, interface), 19000);
 
 		if (OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface),
-				       16);
-			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface),
-				       16);
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface), 16);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface), 16);
 		} else {
-			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface),
-				       24);
-			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface),
-				       24);
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface), 24);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface), 24);
 		}
 	}
 
@@ -243,17 +187,11 @@ int __cvmx_helper_rgmii_enable(int interface)
 	/* enable the ports now */
 	for (port = 0; port < num_ports; port++) {
 		union cvmx_gmxx_prtx_cfg gmx_cfg;
-		cvmx_helper_link_autoconf(cvmx_helper_get_ipd_port
-					  (interface, port));
-		gmx_cfg.u64 =
-		    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(port, interface));
+		cvmx_helper_link_autoconf(cvmx_helper_get_ipd_port(interface, port));
+		gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(port, interface));
 		gmx_cfg.s.en = 1;
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(port, interface),
-			       gmx_cfg.u64);
+		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(port, interface), gmx_cfg.u64);
 	}
-	__cvmx_interrupt_asxx_enable(interface);
-	__cvmx_interrupt_gmxx_enable(interface);
-
 	return 0;
 }
 
@@ -270,20 +208,17 @@ int __cvmx_helper_rgmii_enable(int interface)
 cvmx_helper_link_info_t __cvmx_helper_rgmii_link_get(int ipd_port)
 {
 	int interface = cvmx_helper_get_interface_num(ipd_port);
-	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	cvmx_helper_link_info_t result;
 	union cvmx_asxx_prt_loop asxx_prt_loop;
 
 	asxx_prt_loop.u64 = cvmx_read_csr(CVMX_ASXX_PRT_LOOP(interface));
-	if (asxx_prt_loop.s.int_loop & (1 << index)) {
-		/* Force 1Gbps full duplex on internal loopback */
-		cvmx_helper_link_info_t result;
-		result.u64 = 0;
-		result.s.full_duplex = 1;
-		result.s.link_up = 1;
-		result.s.speed = 1000;
-		return result;
-	} else
-		return __cvmx_helper_board_link_get(ipd_port);
+
+	/* Force 1Gbps full duplex on internal loopback */
+	result.u64 = 0;
+	result.s.full_duplex = 1;
+	result.s.link_up = 1;
+	result.s.speed = 1000;
+	return result;
 }
 
 /**
@@ -317,14 +252,11 @@ int __cvmx_helper_rgmii_link_set(int ipd_port,
 		return 0;
 
 	/* Read the current settings so we know the current enable state */
-	original_gmx_cfg.u64 =
-	    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+	original_gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
 	new_gmx_cfg = original_gmx_cfg;
 
 	/* Disable the lowest level RX */
-	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),
-		       cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) &
-				     ~(1 << index));
+	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) & ~(1 << index));
 
 	memset(pko_mem_queue_qos_save, 0, sizeof(pko_mem_queue_qos_save));
 	/* Disable all queues so that TX should become idle */
@@ -354,12 +286,9 @@ int __cvmx_helper_rgmii_link_set(int ipd_port,
 	 * change, but there is a slight chance that GMX will
 	 * lockup.
 	 */
-	cvmx_write_csr(CVMX_NPI_DBG_SELECT,
-		       interface * 0x800 + index * 0x100 + 0x880);
-	CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 7,
-			==, 0, 10000);
-	CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 0xf,
-			==, 0, 10000);
+	cvmx_write_csr(CVMX_NPI_DBG_SELECT, interface * 0x800 + index * 0x100 + 0x880);
+	CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 7, ==, 0, 10000);
+	CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 0xf, ==, 0, 10000);
 
 	/* Disable the port before we make any changes */
 	new_gmx_cfg.s.en = 0;
@@ -367,10 +296,7 @@ int __cvmx_helper_rgmii_link_set(int ipd_port,
 	cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
 
 	/* Set full/half duplex */
-	if (cvmx_octeon_is_pass1())
-		/* Half duplex is broken for 38XX Pass 1 */
-		new_gmx_cfg.s.duplex = 1;
-	else if (!link_info.s.link_up)
+	if (!link_info.s.link_up)
 		/* Force full duplex on down links */
 		new_gmx_cfg.s.duplex = 1;
 	else
@@ -420,10 +346,9 @@ int __cvmx_helper_rgmii_link_set(int ipd_port,
 	 */
 
 			/* In MII mode, CLK_CNT = 1. */
-			if (((index == 0) && (mode.s.p0mii == 1))
-			    || ((index != 0) && (mode.s.type == 1))) {
-				cvmx_write_csr(CVMX_GMXX_TXX_CLK
-					       (index, interface), 1);
+			if (((index == 0) && (mode.s.p0mii == 1)) ||
+			    ((index != 0) && (mode.s.type == 1))) {
+				cvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 1);
 			}
 		}
 	}
@@ -435,16 +360,14 @@ int __cvmx_helper_rgmii_link_set(int ipd_port,
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), new_gmx_cfg.u64);
 
 	/* Enable the lowest level RX */
-	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),
-		       cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) | (1 <<
-									index));
+	if (link_info.s.link_up)
+		cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) | (1 << index));
 
 	/* Re-enable the TX path */
 	for (i = 0; i < cvmx_pko_get_num_queues(ipd_port); i++) {
 		int queue = cvmx_pko_get_base_queue(ipd_port) + i;
 		cvmx_write_csr(CVMX_PKO_REG_READ_IDX, queue);
-		cvmx_write_csr(CVMX_PKO_MEM_QUEUE_QOS,
-			       pko_mem_queue_qos_save[i].u64);
+		cvmx_write_csr(CVMX_PKO_MEM_QUEUE_QOS, pko_mem_queue_qos_save[i].u64);
 	}
 
 	/* Restore backpressure */
@@ -511,11 +434,9 @@ int __cvmx_helper_rgmii_configure_loopback(int ipd_port, int enable_internal,
 	if (enable_internal) {
 		uint64_t tmp;
 		tmp = cvmx_read_csr(CVMX_ASXX_TX_PRT_EN(interface));
-		cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface),
-			       (1 << index) | tmp);
+		cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), (1 << index) | tmp);
 		tmp = cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface));
-		cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),
-			       (1 << index) | tmp);
+		cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), (1 << index) | tmp);
 		original_enable = 1;
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 0c0bf5d..d720ddd 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,28 +22,22 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  */
-
 #include <asm/octeon/octeon.h>
-
-#include <asm/octeon/cvmx-config.h>
-
-#include <asm/octeon/cvmx-mdio.h>
+#include <asm/octeon/cvmx-qlm.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-board.h>
-
-#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-pcsx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-ciu-defs.h>
 
-void __cvmx_interrupt_gmxx_enable(int interface);
-void __cvmx_interrupt_pcsx_intx_en_reg_enable(int index, int block);
-void __cvmx_interrupt_pcsxx_int_en_reg_enable(int index);
 
 /**
  * Perform initialization required only once for an SGMII port.
@@ -55,8 +49,8 @@ void __cvmx_interrupt_pcsxx_int_en_reg_enable(int index);
  */
 static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 {
-	const uint64_t clock_mhz = cvmx_sysinfo_get()->cpu_clock_hz / 1000000;
-	union cvmx_pcsx_miscx_ctl_reg pcs_misc_ctl_reg;
+	const uint64_t clock_mhz = octeon_get_io_clock_rate() / 1000000;
+	union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
 	union cvmx_pcsx_linkx_timer_count_reg pcsx_linkx_timer_count_reg;
 	union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
 
@@ -70,19 +64,15 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 	 * appropriate value. 1000BASE-X specifies a 10ms
 	 * interval. SGMII specifies a 1.6ms interval.
 	 */
-	pcs_misc_ctl_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-	pcsx_linkx_timer_count_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_LINKX_TIMER_COUNT_REG(index, interface));
-	if (pcs_misc_ctl_reg.s.mode) {
+	pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+	pcsx_linkx_timer_count_reg.u64 = cvmx_read_csr(CVMX_PCSX_LINKX_TIMER_COUNT_REG(index, interface));
+	if (pcsx_miscx_ctl_reg.s.mode)
 		/* 1000BASE-X */
-		pcsx_linkx_timer_count_reg.s.count =
-		    (10000ull * clock_mhz) >> 10;
-	} else {
+		pcsx_linkx_timer_count_reg.s.count = (10000ull * clock_mhz) >> 10;
+	else
 		/* SGMII */
-		pcsx_linkx_timer_count_reg.s.count =
-		    (1600ull * clock_mhz) >> 10;
-	}
+		pcsx_linkx_timer_count_reg.s.count = (1600ull * clock_mhz) >> 10;
+
 	cvmx_write_csr(CVMX_PCSX_LINKX_TIMER_COUNT_REG(index, interface),
 		       pcsx_linkx_timer_count_reg.u64);
 
@@ -95,11 +85,10 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 	 * tx_Config_Reg<D15:D0> is the fixed value 0x4001, so this
 	 * step can be skipped.
 	 */
-	if (pcs_misc_ctl_reg.s.mode) {
+	if (pcsx_miscx_ctl_reg.s.mode) {
 		/* 1000BASE-X */
 		union cvmx_pcsx_anx_adv_reg pcsx_anx_adv_reg;
-		pcsx_anx_adv_reg.u64 =
-		    cvmx_read_csr(CVMX_PCSX_ANX_ADV_REG(index, interface));
+		pcsx_anx_adv_reg.u64 = cvmx_read_csr(CVMX_PCSX_ANX_ADV_REG(index, interface));
 		pcsx_anx_adv_reg.s.rem_flt = 0;
 		pcsx_anx_adv_reg.s.pause = 3;
 		pcsx_anx_adv_reg.s.hfd = 1;
@@ -107,20 +96,26 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 		cvmx_write_csr(CVMX_PCSX_ANX_ADV_REG(index, interface),
 			       pcsx_anx_adv_reg.u64);
 	} else {
-		union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
-		pcsx_miscx_ctl_reg.u64 =
-		    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+#ifdef CVMX_HELPER_CONFIG_NO_PHY
+		/*
+		 * If the interface does not have PHY, then set
+		 * explicitly in PHY mode so that link will be set
+		 * during auto negotiation.
+		 */
+		if (!pcsx_miscx_ctl_reg.s.mac_phy) {
+			cvmx_dprintf("SGMII%d%d: Forcing PHY mode as PHY address is not set\n",
+				     interface, index);
+			pcsx_miscx_ctl_reg.s.mac_phy = 1;
+			cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface), pcsx_miscx_ctl_reg.u64);
+		}
+#endif
 		if (pcsx_miscx_ctl_reg.s.mac_phy) {
 			/* PHY Mode */
 			union cvmx_pcsx_sgmx_an_adv_reg pcsx_sgmx_an_adv_reg;
-			pcsx_sgmx_an_adv_reg.u64 =
-			    cvmx_read_csr(CVMX_PCSX_SGMX_AN_ADV_REG
-					  (index, interface));
-			pcsx_sgmx_an_adv_reg.s.link = 1;
+			pcsx_sgmx_an_adv_reg.u64 = cvmx_read_csr(CVMX_PCSX_SGMX_AN_ADV_REG(index, interface));
 			pcsx_sgmx_an_adv_reg.s.dup = 1;
 			pcsx_sgmx_an_adv_reg.s.speed = 2;
-			cvmx_write_csr(CVMX_PCSX_SGMX_AN_ADV_REG
-				       (index, interface),
+			cvmx_write_csr(CVMX_PCSX_SGMX_AN_ADV_REG(index, interface),
 				       pcsx_sgmx_an_adv_reg.u64);
 		} else {
 			/* MAC Mode - Nothing to do */
@@ -129,6 +124,19 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 	return 0;
 }
 
+static int __cvmx_helper_need_g15618(void)
+{
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM ||
+	    OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+	    OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0) ||
+	    OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_1) ||
+	    OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X) ||
+	    OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+		return 1;
+	else
+		return 0;
+}
+
 /**
  * Initialize the SERTES link for the first time or after a loss
  * of link.
@@ -150,18 +158,18 @@ static int __cvmx_helper_sgmii_hardware_init_link(int interface, int index)
 	 * PCS*_MR*_CONTROL_REG[RESET] until it changes value to
 	 * zero.
 	 */
-	control_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
-	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
+	control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+
+	/*
+	 * Errata G-15618 requires disabling PCS soft reset in CN63XX
+	 * pass upto 2.1.
+	 */
+	if (!__cvmx_helper_need_g15618()) {
 		control_reg.s.reset = 1;
-		cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
-			       control_reg.u64);
-		if (CVMX_WAIT_FOR_FIELD64
-		    (CVMX_PCSX_MRX_CONTROL_REG(index, interface),
-		     union cvmx_pcsx_mrx_control_reg, reset, ==, 0, 10000)) {
-			cvmx_dprintf("SGMII%d: Timeout waiting for port %d "
-				     "to finish reset\n",
-			     interface, index);
+		cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface), control_reg.u64);
+		if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
+					  union cvmx_pcsx_mrx_control_reg, reset, ==, 0, 10000)) {
+			cvmx_dprintf("SGMII%d: Timeout waiting for port %d to finish reset\n", interface, index);
 			return -1;
 		}
 	}
@@ -204,8 +212,7 @@ static int __cvmx_helper_sgmii_hardware_init_link(int interface, int index)
  */
 static int __cvmx_helper_sgmii_hardware_init_link_speed(int interface,
 							int index,
-							cvmx_helper_link_info_t
-							link_info)
+							cvmx_helper_link_info_t link_info)
 {
 	int is_enabled;
 	union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
@@ -218,15 +225,12 @@ static int __cvmx_helper_sgmii_hardware_init_link_speed(int interface,
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmxx_prtx_cfg.u64);
 
 	/* Wait for GMX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_GMXX_PRTX_CFG(index, interface), union cvmx_gmxx_prtx_cfg,
-	     rx_idle, ==, 1, 10000)
-	    || CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(index, interface),
-				     union cvmx_gmxx_prtx_cfg, tx_idle, ==, 1,
-				     10000)) {
-		cvmx_dprintf
-		    ("SGMII%d: Timeout waiting for port %d to be idle\n",
-		     interface, index);
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(index, interface),
+				  union cvmx_gmxx_prtx_cfg, rx_idle, ==, 1, 10000) ||
+	    CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(index, interface),
+				  union cvmx_gmxx_prtx_cfg, tx_idle, ==, 1, 10000)) {
+		cvmx_dprintf("SGMII%d: Timeout waiting for port %d to be idle\n",
+			     interface, index);
 		return -1;
 	}
 
@@ -237,8 +241,7 @@ static int __cvmx_helper_sgmii_hardware_init_link_speed(int interface,
 	 * Get the misc control for PCS. We will need to set the
 	 * duplication amount.
 	 */
-	pcsx_miscx_ctl_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+	pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
 
 	/*
 	 * Use GMXENO to force the link down if the status we get says
@@ -275,7 +278,12 @@ static int __cvmx_helper_sgmii_hardware_init_link_speed(int interface,
 		gmxx_prtx_cfg.s.slottime = 1;
 		pcsx_miscx_ctl_reg.s.samp_pt = 1;
 		cvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 512);
-		cvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 8192);
+		if (gmxx_prtx_cfg.s.duplex)
+			/* full duplex */
+			cvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0);
+		else
+			/* half duplex */
+			cvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 8192);
 		break;
 	default:
 		break;
@@ -311,16 +319,56 @@ static int __cvmx_helper_sgmii_hardware_init_link_speed(int interface,
 static int __cvmx_helper_sgmii_hardware_init(int interface, int num_ports)
 {
 	int index;
+	int do_link_set = 1;
+
+	/*
+	 * CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis
+	 * be programmed.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_0)) {
+		union cvmx_ciu_qlm2 ciu_qlm;
+		ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM2);
+		ciu_qlm.s.txbypass = 1;
+		ciu_qlm.s.txdeemph = 0xf;
+		ciu_qlm.s.txmargin = 0xd;
+		cvmx_write_csr(CVMX_CIU_QLM2, ciu_qlm.u64);
+	}
+
+	/*
+	 * CN63XX Pass 2.x errata G-15273 requires the QLM De-emphasis
+	 * be programmed when using a 156.25Mhz ref clock.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X)) {
+		/* Read the QLM speed pins */
+		union cvmx_mio_rst_boot mio_rst_boot;
+		mio_rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+
+		if (mio_rst_boot.cn63xx.qlm2_spd == 4) {
+			union cvmx_ciu_qlm2 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM2);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 0x0;
+			ciu_qlm.s.txmargin = 0xf;
+			cvmx_write_csr(CVMX_CIU_QLM2, ciu_qlm.u64);
+		}
+	}
 
 	__cvmx_helper_setup_gmx(interface, num_ports);
 
 	for (index = 0; index < num_ports; index++) {
 		int ipd_port = cvmx_helper_get_ipd_port(interface, index);
 		__cvmx_helper_sgmii_hardware_init_one_time(interface, index);
-		__cvmx_helper_sgmii_link_set(ipd_port,
-					     __cvmx_helper_sgmii_link_get
-					     (ipd_port));
-
+		/*
+		 * Linux kernel driver will call ....link_set with the
+		 * proper link state. In the simulator there is no
+		 * link state polling and hence it is set from
+		 * here.
+		 */
+		if (!(cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM))
+			do_link_set = 0;
+		if (do_link_set)
+			__cvmx_helper_sgmii_link_set(ipd_port,
+						     __cvmx_helper_sgmii_link_get(ipd_port));
 	}
 
 	return 0;
@@ -328,8 +376,11 @@ static int __cvmx_helper_sgmii_hardware_init(int interface, int num_ports)
 
 int __cvmx_helper_sgmii_enumerate(int interface)
 {
+	if (OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		return 2;
 	return 4;
 }
+
 /**
  * Probe a SGMII interface and determine the number of ports
  * connected to it. The SGMII interface should still be down after
@@ -344,13 +395,24 @@ int __cvmx_helper_sgmii_probe(int interface)
 	union cvmx_gmxx_inf_mode mode;
 
 	/*
+	 * Check if QLM is configured correct for SGMII, verify the
+	 * speed as well as mode.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		int qlm = cvmx_qlm_interface(interface);
+
+		if (cvmx_qlm_get_mode(qlm) != CVMX_QLM_MODE_SGMII)
+			return 0;
+	}
+	/*
 	 * Due to errata GMX-700 on CN56XXp1.x and CN52XXp1.x, the
 	 * interface needs to be enabled before IPD otherwise per port
-	 * backpressure may not work properly
+	 * backpressure may not work properly.
 	 */
 	mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
 	mode.s.en = 1;
 	cvmx_write_csr(CVMX_GMXX_INF_MODE(interface), mode.u64);
+
 	return __cvmx_helper_sgmii_enumerate(interface);
 }
 
@@ -368,19 +430,63 @@ int __cvmx_helper_sgmii_enable(int interface)
 	int num_ports = cvmx_helper_ports_on_interface(interface);
 	int index;
 
+	/* Setup PKND and BPID */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		for (index = 0; index < num_ports; index++) {
+			union cvmx_gmxx_bpid_msk bpid_msk;
+			union cvmx_gmxx_bpid_mapx bpid_map;
+			union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
+
+			/* Setup PKIND */
+			gmxx_prtx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+			gmxx_prtx_cfg.s.pknd = cvmx_helper_get_pknd(interface, index);
+			cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmxx_prtx_cfg.u64);
+
+			/* Setup BPID */
+			bpid_map.u64 = cvmx_read_csr(CVMX_GMXX_BPID_MAPX(index, interface));
+			bpid_map.s.val = 1;
+			bpid_map.s.bpid = cvmx_helper_get_bpid(interface, index);
+			cvmx_write_csr(CVMX_GMXX_BPID_MAPX(index, interface), bpid_map.u64);
+
+			bpid_msk.u64 = cvmx_read_csr(CVMX_GMXX_BPID_MSK(interface));
+			bpid_msk.s.msk_or |= (1 << index);
+			bpid_msk.s.msk_and &= ~(1 << index);
+			cvmx_write_csr(CVMX_GMXX_BPID_MSK(interface), bpid_msk.u64);
+		}
+	}
+
 	__cvmx_helper_sgmii_hardware_init(interface, num_ports);
 
+	/* CN68XX adds the padding and FCS in PKO, not GMX */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		union cvmx_gmxx_txx_append gmxx_txx_append_cfg;
+
+		for (index = 0; index < num_ports; index++) {
+			gmxx_txx_append_cfg.u64 = cvmx_read_csr(CVMX_GMXX_TXX_APPEND(index, interface));
+			gmxx_txx_append_cfg.s.fcs = 0;
+			gmxx_txx_append_cfg.s.pad = 0;
+			cvmx_write_csr(CVMX_GMXX_TXX_APPEND(index, interface), gmxx_txx_append_cfg.u64);
+		}
+	}
+
 	for (index = 0; index < num_ports; index++) {
+		union cvmx_gmxx_txx_append append_cfg;
+		union cvmx_gmxx_txx_sgmii_ctl sgmii_ctl;
 		union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
-		gmxx_prtx_cfg.u64 =
-		    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+
+		/*
+		 * Clear the align bit if preamble is set to attain
+		 * maximum tx rate.
+		 */
+		append_cfg.u64 = cvmx_read_csr(CVMX_GMXX_TXX_APPEND(index, interface));
+		sgmii_ctl.u64 = cvmx_read_csr(CVMX_GMXX_TXX_SGMII_CTL(index, interface));
+		sgmii_ctl.s.align = append_cfg.s.preamble ? 0 : 1;
+		cvmx_write_csr(CVMX_GMXX_TXX_SGMII_CTL(index, interface), sgmii_ctl.u64);
+
+		gmxx_prtx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
 		gmxx_prtx_cfg.s.en = 1;
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface),
-			       gmxx_prtx_cfg.u64);
-		__cvmx_interrupt_pcsx_intx_en_reg_enable(index, interface);
+		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmxx_prtx_cfg.u64);
 	}
-	__cvmx_interrupt_pcsxx_int_en_reg_enable(interface);
-	__cvmx_interrupt_gmxx_enable(interface);
 	return 0;
 }
 
@@ -397,40 +503,51 @@ int __cvmx_helper_sgmii_enable(int interface)
 cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
-	union cvmx_pcsx_miscx_ctl_reg pcs_misc_ctl_reg;
+	union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 	union cvmx_pcsx_mrx_control_reg pcsx_mrx_control_reg;
-
-	result.u64 = 0;
+	int speed = 1000;
+	int qlm;
 
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM) {
 		/* The simulator gives you a simulated 1Gbps full duplex link */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = 1000;
+		result.s.speed = speed;
 		return result;
 	}
 
-	pcsx_mrx_control_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		union cvmx_gmxx_inf_mode inf_mode;
+		inf_mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
+		if (inf_mode.s.rate & (1 << index))
+			speed = 2500;
+		else
+			speed = 1000;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		qlm = cvmx_qlm_interface(interface);
+		speed = cvmx_qlm_get_gbaud_mhz(qlm) * 8 / 10;
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		speed = cvmx_qlm_get_gbaud_mhz(0) * 8 / 10;
+	}
+
+	result.u64 = 0;
+
+	pcsx_mrx_control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
 	if (pcsx_mrx_control_reg.s.loopbck1) {
 		/* Force 1Gbps full duplex link for internal loopback */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = 1000;
+		result.s.speed = speed;
 		return result;
 	}
 
-	pcs_misc_ctl_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-	if (pcs_misc_ctl_reg.s.mode) {
+	pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+	if (pcsx_miscx_ctl_reg.s.mode) {
 		/* 1000BASE-X */
 		/* FIXME */
 	} else {
-		union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
-		pcsx_miscx_ctl_reg.u64 =
-		    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
 		if (pcsx_miscx_ctl_reg.s.mac_phy) {
 			/* PHY Mode */
 			union cvmx_pcsx_mrx_status_reg pcsx_mrx_status_reg;
@@ -438,39 +555,32 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 
 			/*
 			 * Don't bother continuing if the SERTES low
-			 * level link is down
+			 * level link is down.
 			 */
-			pcsx_mrx_status_reg.u64 =
-			    cvmx_read_csr(CVMX_PCSX_MRX_STATUS_REG
-					  (index, interface));
+			pcsx_mrx_status_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_STATUS_REG(index, interface));
 			if (pcsx_mrx_status_reg.s.lnk_st == 0) {
-				if (__cvmx_helper_sgmii_hardware_init_link
-				    (interface, index) != 0)
+				if (__cvmx_helper_sgmii_hardware_init_link(interface, index) != 0)
 					return result;
 			}
 
 			/* Read the autoneg results */
-			pcsx_anx_results_reg.u64 =
-			    cvmx_read_csr(CVMX_PCSX_ANX_RESULTS_REG
-					  (index, interface));
+			pcsx_anx_results_reg.u64 = cvmx_read_csr(CVMX_PCSX_ANX_RESULTS_REG(index, interface));
 			if (pcsx_anx_results_reg.s.an_cpt) {
 				/*
 				 * Auto negotiation is complete. Set
 				 * status accordingly.
 				 */
-				result.s.full_duplex =
-				    pcsx_anx_results_reg.s.dup;
-				result.s.link_up =
-				    pcsx_anx_results_reg.s.link_ok;
+				result.s.full_duplex = pcsx_anx_results_reg.s.dup;
+				result.s.link_up = pcsx_anx_results_reg.s.link_ok;
 				switch (pcsx_anx_results_reg.s.spd) {
 				case 0:
-					result.s.speed = 10;
+					result.s.speed = speed / 100;
 					break;
 				case 1:
-					result.s.speed = 100;
+					result.s.speed = speed / 10;
 					break;
 				case 2:
-					result.s.speed = 1000;
+					result.s.speed = speed;
 					break;
 				default:
 					result.s.speed = 0;
@@ -485,9 +595,6 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 				result.s.speed = 0;
 				result.s.link_up = 0;
 			}
-		} else {	/* MAC Mode */
-
-			result = __cvmx_helper_board_link_get(ipd_port);
 		}
 	}
 	return result;
@@ -510,16 +617,35 @@ int __cvmx_helper_sgmii_link_set(int ipd_port,
 {
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
-	__cvmx_helper_sgmii_hardware_init_link(interface, index);
-	return __cvmx_helper_sgmii_hardware_init_link_speed(interface, index,
-							    link_info);
+
+	if (link_info.s.link_up || !__cvmx_helper_need_g15618()) {
+		__cvmx_helper_sgmii_hardware_init_link(interface, index);
+	} else {
+		union cvmx_pcsx_mrx_control_reg control_reg;
+		union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
+
+		control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+		control_reg.s.an_en = 0;
+		cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
+			       control_reg.u64);
+		cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+		/*
+		 * Use GMXENO to force the link down it will get
+		 * reenabled later...
+		 */
+		pcsx_miscx_ctl_reg.s.gmxeno = 1;
+		cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface),
+			       pcsx_miscx_ctl_reg.u64);
+		cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+		return 0;
+	}
+	return __cvmx_helper_sgmii_hardware_init_link_speed(interface, index, link_info);
 }
 
 /**
- * Configure a port for internal and/or external loopback. Internal
- * loopback causes packets sent by the port to be received by
- * Octeon. External loopback causes packets received from the wire to
- * sent out again.
+ * Configure a port for internal and/or external loopback. Internal loopback
+ * causes packets sent by the port to be received by Octeon. External loopback
+ * causes packets received from the wire to sent out again.
  *
  * @ipd_port: IPD/PKO port to loopback.
  * @enable_internal:
@@ -537,14 +663,12 @@ int __cvmx_helper_sgmii_configure_loopback(int ipd_port, int enable_internal,
 	union cvmx_pcsx_mrx_control_reg pcsx_mrx_control_reg;
 	union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
 
-	pcsx_mrx_control_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+	pcsx_mrx_control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
 	pcsx_mrx_control_reg.s.loopbck1 = enable_internal;
 	cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
 		       pcsx_mrx_control_reg.u64);
 
-	pcsx_miscx_ctl_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+	pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
 	pcsx_miscx_ctl_reg.s.loopbck2 = enable_external;
 	cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface),
 		       pcsx_miscx_ctl_reg.u64);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
index 2830e4b..16c9bc2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,25 +22,19 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-void __cvmx_interrupt_gmxx_enable(int interface);
-void __cvmx_interrupt_spxx_int_msk_enable(int index);
-void __cvmx_interrupt_stxx_int_msk_enable(int index);
-
 /*
  * Functions for SPI initialization, configuration,
  * and monitoring.
  */
 #include <asm/octeon/octeon.h>
-
-#include <asm/octeon/cvmx-config.h>
 #include <asm/octeon/cvmx-spi.h>
 #include <asm/octeon/cvmx-helper.h>
-
-#include <asm/octeon/cvmx-pip-defs.h>
 #include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+
 
 /*
  * CVMX_HELPER_SPI_TIMEOUT is used to determine how long the SPI
@@ -54,11 +48,10 @@ void __cvmx_interrupt_stxx_int_msk_enable(int index);
 int __cvmx_helper_spi_enumerate(int interface)
 {
 	if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
-	    cvmx_spi4000_is_present(interface)) {
+	    cvmx_spi4000_is_present(interface))
 		return 10;
-	} else {
+	else
 		return 16;
-	}
 }
 
 /**
@@ -72,14 +65,10 @@ int __cvmx_helper_spi_enumerate(int interface)
  */
 int __cvmx_helper_spi_probe(int interface)
 {
-	int num_ports = 0;
+	int num_ports = __cvmx_helper_spi_enumerate(interface);
 
-	if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
-	    cvmx_spi4000_is_present(interface)) {
-		num_ports = 10;
-	} else {
+	if (num_ports == 16) {
 		union cvmx_pko_reg_crc_enable enable;
-		num_ports = 16;
 		/*
 		 * Unlike the SPI4000, most SPI devices don't
 		 * automatically put on the L2 CRC. For everything
@@ -126,9 +115,6 @@ int __cvmx_helper_spi_enable(int interface)
 		if (cvmx_spi4000_is_present(interface))
 			cvmx_spi4000_initialize(interface);
 	}
-	__cvmx_interrupt_spxx_int_msk_enable(interface);
-	__cvmx_interrupt_stxx_int_msk_enable(interface);
-	__cvmx_interrupt_gmxx_enable(interface);
 	return 0;
 }
 
@@ -149,14 +135,16 @@ cvmx_helper_link_info_t __cvmx_helper_spi_link_get(int ipd_port)
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 	result.u64 = 0;
 
+	if (interface == -1 || index == -1)
+		return result;
+
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM) {
 		/* The simulator gives you a simulated full duplex link */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
 		result.s.speed = 10000;
 	} else if (cvmx_spi4000_is_present(interface)) {
-		union cvmx_gmxx_rxx_rx_inbnd inband =
-		    cvmx_spi4000_check_speed(interface, index);
+		union cvmx_gmxx_rxx_rx_inbnd inband = cvmx_spi4000_check_speed(interface, index);
 		result.s.link_up = inband.s.status;
 		result.s.full_duplex = inband.s.duplex;
 		switch (inband.s.speed) {
@@ -175,8 +163,10 @@ cvmx_helper_link_info_t __cvmx_helper_spi_link_get(int ipd_port)
 			break;
 		}
 	} else {
-		/* For generic SPI we can't determine the link, just return some
-		   sane results */
+		/*
+		 * For generic SPI we can't determine the link, just
+		 * return some sane results.
+		 */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
 		result.s.speed = 10000;
@@ -198,8 +188,10 @@ cvmx_helper_link_info_t __cvmx_helper_spi_link_get(int ipd_port)
  */
 int __cvmx_helper_spi_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 {
-	/* Nothing to do. If we have a SPI4000 then the setup was already performed
-	   by cvmx_spi4000_check_speed(). If not then there isn't any link
-	   info */
+	/*
+	 * Nothing to do. If we have a SPI4000 then the setup was
+	 * already performed by cvmx_spi4000_check_speed(). If not
+	 * then there isn't any link info.
+	 */
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-srio.c b/arch/mips/cavium-octeon/executive/cvmx-helper-srio.c
new file mode 100644
index 0000000..c8a5f83
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-srio.c
@@ -0,0 +1,316 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Functions for SRIO initialization, configuration,
+ * and monitoring.
+ */
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-srio.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+#include <asm/octeon/cvmx-dpi-defs.h>
+
+
+/**
+ * Probe a SRIO interface and determine the number of ports
+ * connected to it. The SRIO interface should still be down
+ * after this call.
+ *
+ * @interface: Interface to probe
+ *
+ * Returns Number of ports on the interface. Zero to disable.
+ */
+int __cvmx_helper_srio_probe(int interface)
+{
+	union cvmx_sriox_status_reg srio0_status_reg;
+	union cvmx_sriox_status_reg srio1_status_reg;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_SRIO))
+		return 0;
+
+	/* Read MIO_QLMX_CFG CSRs to find SRIO mode. */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		enum cvmx_qlm_mode mode = cvmx_qlm_get_mode(0);
+		int srio_port = interface - 4;
+		switch (srio_port) {
+		case 0:	/* 1x4 lane */
+			if (mode == CVMX_QLM_MODE_SRIO_1X4 ||
+			    mode == CVMX_QLM_MODE_SRIO_2X2 ||
+			    mode == CVMX_QLM_MODE_SRIO_4X1)
+				return 2;
+			break;
+		case 2:	/* 2x2 lane */
+			if (mode == CVMX_QLM_MODE_SRIO_2X2 ||
+			    mode == CVMX_QLM_MODE_SRIO_4X1)
+				return 2;
+			break;
+		case 3:	/* 4x1 long/short */
+			if (mode == CVMX_QLM_MODE_SRIO_4X1)
+				return 2;
+			break;
+		default:
+			break;
+		}
+		return 0;
+	}
+
+	srio0_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(0));
+	srio1_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(1));
+	if (srio0_status_reg.s.srio || srio1_status_reg.s.srio)
+		return 2;
+	else
+		return 0;
+}
+
+/**
+ * Bringup and enable SRIO interface. After this call packet
+ * I/O should be fully functional. This is called with IPD
+ * enabled but PKO disabled.
+ *
+ * @interface: Interface to bring up
+ *
+ * Returns Zero on success, negative on failure
+ */
+int __cvmx_helper_srio_enable(int interface)
+{
+	int num_ports = cvmx_helper_ports_on_interface(interface);
+	int index;
+	union cvmx_sriomaintx_core_enables sriomaintx_core_enables;
+	union cvmx_sriox_imsg_ctrl sriox_imsg_ctrl;
+	union cvmx_sriox_status_reg srio_status_reg;
+	union cvmx_dpi_ctl dpi_ctl;
+	int srio_port = interface - 4;
+
+	/*
+	 * All SRIO ports have a cvmx_srio_rx_message_header_t header
+	 * on them that must be skipped by IPD.
+	 */
+	for (index = 0; index < num_ports; index++) {
+		union cvmx_pip_prt_cfgx port_config;
+		union cvmx_sriox_omsg_portx sriox_omsg_portx;
+		union cvmx_sriox_omsg_sp_mrx sriox_omsg_sp_mrx;
+		union cvmx_sriox_omsg_fmp_mrx sriox_omsg_fmp_mrx;
+		union cvmx_sriox_omsg_nmp_mrx sriox_omsg_nmp_mrx;
+		int ipd_port = cvmx_helper_get_ipd_port(interface, index);
+		port_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
+		/* Only change the skip if the user hasn't already set it */
+		if (!port_config.s.skip) {
+			port_config.s.skip = sizeof(struct cvmx_srio_rx_message_header);
+			cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port), port_config.u64);
+		}
+
+		/* Enable TX with PKO */
+		sriox_omsg_portx.u64 = cvmx_read_csr(CVMX_SRIOX_OMSG_PORTX(index, srio_port));
+		sriox_omsg_portx.s.port = (srio_port) * 2 + index;
+		sriox_omsg_portx.s.enable = 1;
+		cvmx_write_csr(CVMX_SRIOX_OMSG_PORTX(index, srio_port),
+			       sriox_omsg_portx.u64);
+
+		/*
+		 * Allow OMSG controller to send regardless of the
+		 * state of any other controller. Allow messages to
+		 * different IDs and MBOXes to go in parallel.
+		 */
+		sriox_omsg_sp_mrx.u64 = 0;
+		sriox_omsg_sp_mrx.s.xmbox_sp = 1;
+		sriox_omsg_sp_mrx.s.ctlr_sp = 1;
+		sriox_omsg_sp_mrx.s.ctlr_fmp = 1;
+		sriox_omsg_sp_mrx.s.ctlr_nmp = 1;
+		sriox_omsg_sp_mrx.s.id_sp = 1;
+		sriox_omsg_sp_mrx.s.id_fmp = 1;
+		sriox_omsg_sp_mrx.s.id_nmp = 1;
+		sriox_omsg_sp_mrx.s.mbox_sp = 1;
+		sriox_omsg_sp_mrx.s.mbox_fmp = 1;
+		sriox_omsg_sp_mrx.s.mbox_nmp = 1;
+		sriox_omsg_sp_mrx.s.all_psd = 1;
+		cvmx_write_csr(CVMX_SRIOX_OMSG_SP_MRX(index, srio_port),
+			       sriox_omsg_sp_mrx.u64);
+
+		/*
+		 * Allow OMSG controller to send regardless of the
+		 * state of any other controller. Allow messages to
+		 * different IDs and MBOXes to go in parallel.
+		 */
+		sriox_omsg_fmp_mrx.u64 = 0;
+		sriox_omsg_fmp_mrx.s.ctlr_sp = 1;
+		sriox_omsg_fmp_mrx.s.ctlr_fmp = 1;
+		sriox_omsg_fmp_mrx.s.ctlr_nmp = 1;
+		sriox_omsg_fmp_mrx.s.id_sp = 1;
+		sriox_omsg_fmp_mrx.s.id_fmp = 1;
+		sriox_omsg_fmp_mrx.s.id_nmp = 1;
+		sriox_omsg_fmp_mrx.s.mbox_sp = 1;
+		sriox_omsg_fmp_mrx.s.mbox_fmp = 1;
+		sriox_omsg_fmp_mrx.s.mbox_nmp = 1;
+		sriox_omsg_fmp_mrx.s.all_psd = 1;
+		cvmx_write_csr(CVMX_SRIOX_OMSG_FMP_MRX(index, srio_port),
+			       sriox_omsg_fmp_mrx.u64);
+
+		/*
+		 * Once the first part of a message is accepted,
+		 * always acept the rest of the message.
+		 */
+		sriox_omsg_nmp_mrx.u64 = 0;
+		sriox_omsg_nmp_mrx.s.all_sp = 1;
+		sriox_omsg_nmp_mrx.s.all_fmp = 1;
+		sriox_omsg_nmp_mrx.s.all_nmp = 1;
+		cvmx_write_csr(CVMX_SRIOX_OMSG_NMP_MRX(index, srio_port),
+			       sriox_omsg_nmp_mrx.u64);
+	}
+
+	/* Choose the receive controller based on the mailbox */
+	sriox_imsg_ctrl.u64 = cvmx_read_csr(CVMX_SRIOX_IMSG_CTRL(srio_port));
+	sriox_imsg_ctrl.s.prt_sel = 0;
+	sriox_imsg_ctrl.s.mbox = 0xa;
+	cvmx_write_csr(CVMX_SRIOX_IMSG_CTRL(srio_port), sriox_imsg_ctrl.u64);
+
+	/* DPI must be enabled for us to RX messages */
+	dpi_ctl.u64 = cvmx_read_csr(CVMX_DPI_CTL);
+	dpi_ctl.s.clk = 1;
+	dpi_ctl.s.en = 1;
+	cvmx_write_csr(CVMX_DPI_CTL, dpi_ctl.u64);
+
+	/* Make sure register access is allowed */
+	srio_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (!srio_status_reg.s.access)
+		return 0;
+
+	/* Enable RX */
+	if (!cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+				     CVMX_SRIOMAINTX_CORE_ENABLES(srio_port),
+				     &sriomaintx_core_enables.u32)) {
+		sriomaintx_core_enables.s.imsg0 = 1;
+		sriomaintx_core_enables.s.imsg1 = 1;
+		cvmx_srio_config_write32(srio_port, 0, -1, 0, 0,
+					 CVMX_SRIOMAINTX_CORE_ENABLES(srio_port),
+					 sriomaintx_core_enables.u32);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the link state of an IPD/PKO port as returned by SRIO link status.
+ *
+ * @ipd_port: IPD/PKO port to query
+ *
+ * Returns Link state
+ */
+cvmx_helper_link_info_t __cvmx_helper_srio_link_get(int ipd_port)
+{
+	int interface = cvmx_helper_get_interface_num(ipd_port);
+	int srio_port = interface - 4;
+	cvmx_helper_link_info_t result;
+	union cvmx_sriox_status_reg srio_status_reg;
+	union cvmx_sriomaintx_port_0_err_stat sriomaintx_port_0_err_stat;
+	union cvmx_sriomaintx_port_0_ctl sriomaintx_port_0_ctl;
+	union cvmx_sriomaintx_port_0_ctl2 sriomaintx_port_0_ctl2;
+
+	result.u64 = 0;
+
+	/* Make sure register access is allowed */
+	srio_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (!srio_status_reg.s.access)
+		return result;
+
+	/* Read the port link status */
+	if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+				    CVMX_SRIOMAINTX_PORT_0_ERR_STAT(srio_port),
+				    &sriomaintx_port_0_err_stat.u32))
+		return result;
+
+	/* Return if link is down */
+	if (!sriomaintx_port_0_err_stat.s.pt_ok)
+		return result;
+
+	/* Read the port link width and speed */
+	if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+				    CVMX_SRIOMAINTX_PORT_0_CTL(srio_port),
+				    &sriomaintx_port_0_ctl.u32))
+		return result;
+	if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+				    CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port),
+				    &sriomaintx_port_0_ctl2.u32))
+		return result;
+
+	/* Link is up */
+	result.s.full_duplex = 1;
+	result.s.link_up = 1;
+	switch (sriomaintx_port_0_ctl2.s.sel_baud) {
+	case 1:
+		result.s.speed = 1250;
+		break;
+	case 2:
+		result.s.speed = 2500;
+		break;
+	case 3:
+		result.s.speed = 3125;
+		break;
+	case 4:
+		result.s.speed = 5000;
+		break;
+	case 5:
+		result.s.speed = 6250;
+		break;
+	default:
+		result.s.speed = 0;
+		break;
+	}
+	switch (sriomaintx_port_0_ctl.s.it_width) {
+	case 2:		/* Four lanes */
+		result.s.speed += 40000;
+		break;
+	case 3:		/* Two lanes */
+		result.s.speed += 20000;
+		break;
+	default:		/* One lane */
+		result.s.speed += 10000;
+		break;
+	}
+	return result;
+}
+
+/**
+ * Configure an IPD/PKO port for the specified link state. This
+ * function does not influence auto negotiation at the PHY level.
+ * The passed link state must always match the link state returned
+ * by cvmx_helper_link_get(). It is normally best to use
+ * cvmx_helper_link_autoconf() instead.
+ *
+ * @ipd_port:  IPD/PKO port to configure
+ * @link_info: The new link state
+ *
+ * Returns Zero on success, negative on failure
+ */
+int __cvmx_helper_srio_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
+{
+	return 0;
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 116dea1..c866335 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2012 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,28 +22,38 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Small helper utilities.
  */
-#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/slab.h>
 
 #include <asm/octeon/octeon.h>
-
-#include <asm/octeon/cvmx-config.h>
-
-#include <asm/octeon/cvmx-fpa.h>
 #include <asm/octeon/cvmx-pip.h>
-#include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-ipd.h>
-#include <asm/octeon/cvmx-spi.h>
-
 #include <asm/octeon/cvmx-helper.h>
-#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+
+struct cvmx_iface {
+	int cvif_ipd_nports;
+	int cvif_has_fcs;	/* PKO fcs for this interface. */
+	enum cvmx_pko_padding cvif_padding;
+	cvmx_helper_link_info_t *cvif_ipd_port_link_info;
+};
+
+/*
+ * This has to be static as u-boot expects to probe an interface and
+ * gets the number of its ports.
+ */
+static struct cvmx_iface cvmx_interfaces[CVMX_HELPER_MAX_IFACE];
 
-#include <asm/octeon/cvmx-ipd-defs.h>
 
 /**
  * Convert a interface mode into a human readable string
@@ -52,8 +62,7 @@
  *
  * Returns String
  */
-const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t
-						 mode)
+const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t mode)
 {
 	switch (mode) {
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
@@ -68,6 +77,8 @@ const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t
 		return "PCIE";
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
 		return "XAUI";
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		return "RXAUI";
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 		return "SGMII";
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
@@ -76,98 +87,15 @@ const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t
 		return "NPI";
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		return "LOOP";
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		return "SRIO";
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		return "ILK";
 	}
 	return "UNKNOWN";
 }
 
 /**
- * Debug routine to dump the packet structure to the console
- *
- * @work:   Work queue entry containing the packet to dump
- * Returns
- */
-int cvmx_helper_dump_packet(cvmx_wqe_t *work)
-{
-	uint64_t count;
-	uint64_t remaining_bytes;
-	union cvmx_buf_ptr buffer_ptr;
-	uint64_t start_of_buffer;
-	uint8_t *data_address;
-	uint8_t *end_of_data;
-
-	cvmx_dprintf("Packet Length:   %u\n", work->len);
-	cvmx_dprintf("    Input Port:  %u\n", work->ipprt);
-	cvmx_dprintf("    QoS:         %u\n", work->qos);
-	cvmx_dprintf("    Buffers:     %u\n", work->word2.s.bufs);
-
-	if (work->word2.s.bufs == 0) {
-		union cvmx_ipd_wqe_fpa_queue wqe_pool;
-		wqe_pool.u64 = cvmx_read_csr(CVMX_IPD_WQE_FPA_QUEUE);
-		buffer_ptr.u64 = 0;
-		buffer_ptr.s.pool = wqe_pool.s.wqe_pool;
-		buffer_ptr.s.size = 128;
-		buffer_ptr.s.addr = cvmx_ptr_to_phys(work->packet_data);
-		if (likely(!work->word2.s.not_IP)) {
-			union cvmx_pip_ip_offset pip_ip_offset;
-			pip_ip_offset.u64 = cvmx_read_csr(CVMX_PIP_IP_OFFSET);
-			buffer_ptr.s.addr +=
-			    (pip_ip_offset.s.offset << 3) -
-			    work->word2.s.ip_offset;
-			buffer_ptr.s.addr += (work->word2.s.is_v6 ^ 1) << 2;
-		} else {
-			/*
-			 * WARNING: This code assumes that the packet
-			 * is not RAW. If it was, we would use
-			 * PIP_GBL_CFG[RAW_SHF] instead of
-			 * PIP_GBL_CFG[NIP_SHF].
-			 */
-			union cvmx_pip_gbl_cfg pip_gbl_cfg;
-			pip_gbl_cfg.u64 = cvmx_read_csr(CVMX_PIP_GBL_CFG);
-			buffer_ptr.s.addr += pip_gbl_cfg.s.nip_shf;
-		}
-	} else
-		buffer_ptr = work->packet_ptr;
-	remaining_bytes = work->len;
-
-	while (remaining_bytes) {
-		start_of_buffer =
-		    ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
-		cvmx_dprintf("    Buffer Start:%llx\n",
-			     (unsigned long long)start_of_buffer);
-		cvmx_dprintf("    Buffer I   : %u\n", buffer_ptr.s.i);
-		cvmx_dprintf("    Buffer Back: %u\n", buffer_ptr.s.back);
-		cvmx_dprintf("    Buffer Pool: %u\n", buffer_ptr.s.pool);
-		cvmx_dprintf("    Buffer Data: %llx\n",
-			     (unsigned long long)buffer_ptr.s.addr);
-		cvmx_dprintf("    Buffer Size: %u\n", buffer_ptr.s.size);
-
-		cvmx_dprintf("\t\t");
-		data_address = (uint8_t *) cvmx_phys_to_ptr(buffer_ptr.s.addr);
-		end_of_data = data_address + buffer_ptr.s.size;
-		count = 0;
-		while (data_address < end_of_data) {
-			if (remaining_bytes == 0)
-				break;
-			else
-				remaining_bytes--;
-			cvmx_dprintf("%02x", (unsigned int)*data_address);
-			data_address++;
-			if (remaining_bytes && (count == 7)) {
-				cvmx_dprintf("\n\t\t");
-				count = 0;
-			} else
-				count++;
-		}
-		cvmx_dprintf("\n");
-
-		if (remaining_bytes)
-			buffer_ptr = *(union cvmx_buf_ptr *)
-				cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
-	}
-	return 0;
-}
-
-/**
  * Setup Random Early Drop on a specific input queue
  *
  * @queue:  Input queue to setup RED on (0-7)
@@ -184,9 +112,11 @@ int cvmx_helper_setup_red_queue(int queue, int pass_thresh, int drop_thresh)
 	union cvmx_ipd_qosx_red_marks red_marks;
 	union cvmx_ipd_red_quex_param red_param;
 
-	/* Set RED to begin dropping packets when there are pass_thresh buffers
-	   left. It will linearly drop more packets until reaching drop_thresh
-	   buffers */
+	/*
+	 * Set RED to begin dropping packets when there are
+	 * pass_thresh buffers left. It will linearly drop more
+	 * packets until reaching drop_thresh buffers.
+	 */
 	red_marks.u64 = 0;
 	red_marks.s.drop = drop_thresh;
 	red_marks.s.pass = pass_thresh;
@@ -194,8 +124,7 @@ int cvmx_helper_setup_red_queue(int queue, int pass_thresh, int drop_thresh)
 
 	/* Use the actual queue 0 counter, not the average */
 	red_param.u64 = 0;
-	red_param.s.prb_con =
-	    (255ul << 24) / (red_marks.s.pass - red_marks.s.drop);
+	red_param.s.prb_con = (255ul << 24) / (red_marks.s.pass - red_marks.s.drop);
 	red_param.s.avg_con = 1;
 	red_param.s.new_con = 255;
 	red_param.s.use_pcnt = 1;
@@ -216,41 +145,100 @@ int cvmx_helper_setup_red_queue(int queue, int pass_thresh, int drop_thresh)
  */
 int cvmx_helper_setup_red(int pass_thresh, int drop_thresh)
 {
-	union cvmx_ipd_portx_bp_page_cnt page_cnt;
-	union cvmx_ipd_bp_prt_red_end ipd_bp_prt_red_end;
-	union cvmx_ipd_red_port_enable red_port_enable;
 	int queue;
 	int interface;
 	int port;
 
-	/* Disable backpressure based on queued buffers. It needs SW support */
-	page_cnt.u64 = 0;
-	page_cnt.s.bp_enb = 0;
-	page_cnt.s.page_cnt = 100;
-	for (interface = 0; interface < 2; interface++) {
-		for (port = cvmx_helper_get_first_ipd_port(interface);
-		     port < cvmx_helper_get_last_ipd_port(interface); port++)
-			cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port),
-				       page_cnt.u64);
+	/*
+	 * Disable backpressure based on queued buffers. It needs SW support
+	 */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		int bpid;
+		for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++) {
+			int num_ports;
+
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			for (port = 0; port < num_ports; port++) {
+				bpid = cvmx_helper_get_bpid(interface, port);
+				if (bpid == CVMX_INVALID_BPID)
+					cvmx_dprintf("setup_red: cvmx_helper_get_bpid(%d, %d) = %d\n",
+						     interface, port,
+						     cvmx_helper_get_bpid(interface, port));
+				else
+					cvmx_write_csr(CVMX_IPD_BPIDX_MBUF_TH(bpid), 0);
+			}
+		}
+	} else {
+		union cvmx_ipd_portx_bp_page_cnt page_cnt;
+
+		page_cnt.u64 = 0;
+		page_cnt.s.bp_enb = 0;
+		page_cnt.s.page_cnt = 100;
+		for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++) {
+			for (port = cvmx_helper_get_first_ipd_port(interface); port < cvmx_helper_get_last_ipd_port(interface); port++)
+				cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port), page_cnt.u64);
+		}
 	}
 
 	for (queue = 0; queue < 8; queue++)
 		cvmx_helper_setup_red_queue(queue, pass_thresh, drop_thresh);
 
-	/* Shutoff the dropping based on the per port page count. SW isn't
-	   decrementing it right now */
-	ipd_bp_prt_red_end.u64 = 0;
-	ipd_bp_prt_red_end.s.prt_enb = 0;
-	cvmx_write_csr(CVMX_IPD_BP_PRT_RED_END, ipd_bp_prt_red_end.u64);
+	/*
+	 * Shutoff the dropping based on the per port page count. SW isn't
+	 * decrementing it right now
+	 */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		cvmx_write_csr(CVMX_IPD_ON_BP_DROP_PKTX(0), 0);
+	else
+		cvmx_write_csr(CVMX_IPD_BP_PRT_RED_END, 0);
 
-	red_port_enable.u64 = 0;
-	red_port_enable.s.prt_enb = 0xfffffffffull;
-	red_port_enable.s.avg_dly = 10000;
-	red_port_enable.s.prb_dly = 10000;
-	cvmx_write_csr(CVMX_IPD_RED_PORT_ENABLE, red_port_enable.u64);
+#define IPD_RED_AVG_DLY	1000
+#define IPD_RED_PRB_DLY	1000
+	/*
+	 * Setting up avg_dly and prb_dly, enable bits
+	 */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		union cvmx_ipd_red_delay red_delay;
+		union cvmx_ipd_red_bpid_enablex red_bpid_enable;
+
+		red_delay.u64 = 0;
+		red_delay.s.avg_dly = IPD_RED_AVG_DLY;
+		red_delay.s.prb_dly = IPD_RED_PRB_DLY;
+		cvmx_write_csr(CVMX_IPD_RED_DELAY, red_delay.u64);
+
+		/*
+		 * Only enable the gmx ports
+		 */
+		red_bpid_enable.u64 = 0;
+		for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++) {
+			int num_ports = cvmx_helper_ports_on_interface(interface);
+			for (port = 0; port < num_ports; port++)
+				red_bpid_enable.u64 |= (((uint64_t) 1) << cvmx_helper_get_bpid(interface, port));
+		}
+		cvmx_write_csr(CVMX_IPD_RED_BPID_ENABLEX(0), red_bpid_enable.u64);
+	} else {
+		union cvmx_ipd_red_port_enable red_port_enable;
+
+		red_port_enable.u64 = 0;
+		red_port_enable.s.prt_enb = 0xfffffffffull;
+		red_port_enable.s.avg_dly = IPD_RED_AVG_DLY;
+		red_port_enable.s.prb_dly = IPD_RED_PRB_DLY;
+		cvmx_write_csr(CVMX_IPD_RED_PORT_ENABLE, red_port_enable.u64);
+
+		/*
+		 * Shutoff the dropping of packets based on RED for SRIO ports
+		 */
+		if (octeon_has_feature(OCTEON_FEATURE_SRIO)) {
+			union cvmx_ipd_red_port_enable2 red_port_enable2;
+			red_port_enable2.u64 = 0;
+			red_port_enable2.s.prt_enb = 0xf0;
+			cvmx_write_csr(CVMX_IPD_RED_PORT_ENABLE2, red_port_enable2.u64);
+		}
+	}
 
 	return 0;
 }
+EXPORT_SYMBOL(cvmx_helper_setup_red);
 
 /**
  * Setup the common GMX settings that determine the number of
@@ -275,19 +263,16 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 	gmx_tx_prts.s.prts = num_ports;
 	cvmx_write_csr(CVMX_GMXX_TX_PRTS(interface), gmx_tx_prts.u64);
 
-	/* Tell GMX the number of RX ports on this interface.  This only
-	 ** applies to *GMII and XAUI ports */
-	if (cvmx_helper_interface_get_mode(interface) ==
-	    CVMX_HELPER_INTERFACE_MODE_RGMII
-	    || cvmx_helper_interface_get_mode(interface) ==
-	    CVMX_HELPER_INTERFACE_MODE_SGMII
-	    || cvmx_helper_interface_get_mode(interface) ==
-	    CVMX_HELPER_INTERFACE_MODE_GMII
-	    || cvmx_helper_interface_get_mode(interface) ==
-	    CVMX_HELPER_INTERFACE_MODE_XAUI) {
+	/*
+	 * Tell GMX the number of RX ports on this interface.  This only applies
+	 * to *GMII and XAUI ports.
+	 */
+	if (cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_RGMII ||
+	    cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_SGMII ||
+	    cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_GMII ||
+	    cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_XAUI) {
 		if (num_ports > 4) {
-			cvmx_dprintf("__cvmx_helper_setup_gmx: Illegal "
-				     "num_ports\n");
+			cvmx_dprintf("__cvmx_helper_setup_gmx: Illegal num_ports\n");
 			return -1;
 		}
 
@@ -296,9 +281,14 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 		cvmx_write_csr(CVMX_GMXX_RX_PRTS(interface), gmx_rx_prts.u64);
 	}
 
-	/* Skip setting CVMX_PKO_REG_GMX_PORT_MODE on 30XX, 31XX, and 50XX */
-	if (!OCTEON_IS_MODEL(OCTEON_CN30XX) && !OCTEON_IS_MODEL(OCTEON_CN31XX)
-	    && !OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+	/*
+	 * Skip setting CVMX_PKO_REG_GMX_PORT_MODE on 30XX, 31XX, 50XX,
+	 * and 68XX.
+	 */
+	if (!OCTEON_IS_MODEL(OCTEON_CN30XX) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN31XX) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN50XX) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 		/* Tell PKO the number of ports on this interface */
 		pko_mode.u64 = cvmx_read_csr(CVMX_PKO_REG_GMX_PORT_MODE);
 		if (interface == 0) {
@@ -329,49 +319,148 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 
 	/*
 	 * Set GMX to buffer as much data as possible before starting
-	 * transmit.  This reduces the chances that we have a TX under
-	 * run due to memory contention. Any packet that fits entirely
-	 * in the GMX FIFO can never have an under run regardless of
-	 * memory load.
+	 * transmit. This reduces the chances that we have a TX under run
+	 * due to memory contention. Any packet that fits entirely in the
+	 * GMX FIFO can never have an under run regardless of memory load.
 	 */
 	gmx_tx_thresh.u64 = cvmx_read_csr(CVMX_GMXX_TXX_THRESH(0, interface));
-	if (OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX)
-	    || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN30XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN50XX)) {
 		/* These chips have a fixed max threshold of 0x40 */
 		gmx_tx_thresh.s.cnt = 0x40;
 	} else {
+		/* ccn - common cnt numberator */
+		int ccn = 0x100;
+
 		/* Choose the max value for the number of ports */
 		if (num_ports <= 1)
-			gmx_tx_thresh.s.cnt = 0x100 / 1;
+			gmx_tx_thresh.s.cnt = ccn / 1;
 		else if (num_ports == 2)
-			gmx_tx_thresh.s.cnt = 0x100 / 2;
+			gmx_tx_thresh.s.cnt = ccn / 2;
 		else
-			gmx_tx_thresh.s.cnt = 0x100 / 4;
+			gmx_tx_thresh.s.cnt = ccn / 4;
 	}
+
 	/*
 	 * SPI and XAUI can have lots of ports but the GMX hardware
-	 * only ever has a max of 4.
+	 * only ever has a max of 4
 	 */
 	if (num_ports > 4)
 		num_ports = 4;
 	for (index = 0; index < num_ports; index++)
-		cvmx_write_csr(CVMX_GMXX_TXX_THRESH(index, interface),
-			       gmx_tx_thresh.u64);
+		cvmx_write_csr(CVMX_GMXX_TXX_THRESH(index, interface), gmx_tx_thresh.u64);
+
+	/*
+	 * For o68, we need to setup the pipes
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && interface < CVMX_HELPER_MAX_GMX) {
+		union cvmx_gmxx_txx_pipe config;
+
+		for (index = 0; index < num_ports; index++) {
+			config.u64 = 0;
+
+			if (__cvmx_helper_cfg_pko_port_base(interface, index) >= 0) {
+				config.u64 = cvmx_read_csr(CVMX_GMXX_TXX_PIPE(index, interface));
+				config.s.nump = __cvmx_helper_cfg_pko_port_num(interface, index);
+				config.s.base = __cvmx_helper_cfg_pko_port_base(interface, index);
+				cvmx_write_csr(CVMX_GMXX_TXX_PIPE(index, interface), config.u64);
+			}
+		}
+	}
 
 	return 0;
 }
 
+int cvmx_helper_get_pko_port(int interface, int port)
+{
+	return cvmx_pko_get_base_pko_port(interface, port);
+}
+EXPORT_SYMBOL(cvmx_helper_get_pko_port);
+
 /**
- * Returns the IPD/PKO port number for a port on the given
- * interface.
+ * Given an IPD port output the interface and port number.
  *
- * @interface: Interface to use
- * @port:      Port on the interface
+ * @ipd_port - IPD port number to look up
+ * @interface - interface number IPD port is assigned to
+ * @port - port number IPD port is assigned to
  *
- * Returns IPD/PKO port number
+ * Returns zero for success, negative for error
  */
+int cvmx_helper_get_interface_and_port_from_ipd_port(int ipd_port, int *interface, int *port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (ipd_port >= 0x800) {
+			cvmx_helper_interface_mode_t mode;
+			/* 0-4 */
+			*interface = ((ipd_port - 0x800) / 0x100);
+			mode = cvmx_helper_interface_get_mode(*interface);
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI ||
+			    mode == CVMX_HELPER_INTERFACE_MODE_RXAUI)
+				*port = 0;
+			else
+				*port = (ipd_port & 0xff) / 16;
+		} else if (ipd_port >= 0x400) {
+			/* ILK 5-6 */
+			*interface = ((ipd_port - 0x400) / 0x100) + 5;
+			*port = ipd_port & 0xff;
+		} else if (ipd_port >= 0x100 && ipd_port < 0x3ff) {
+			*interface = 7;
+			*port = ipd_port - 0x100;
+		} else if (ipd_port < 0x100) {
+			*interface = 8;
+			*port = ipd_port;
+		} else {
+			return -1;
+		}
+	} else {
+		if (ipd_port < 0) {
+			return -1;
+		} else if (ipd_port < 16) {
+			*interface = 0;
+			*port = ipd_port;
+		} else if (ipd_port < 32) {
+			*interface = 1;
+			*port = ipd_port - 16;
+		} else if (ipd_port < 36) {
+			*interface = 2;
+			*port = ipd_port - 32;
+		} else if (ipd_port < 40) {
+			*interface = 3;
+			*port = ipd_port - 36;
+		} else if (ipd_port < 42) {
+			*interface = 4;
+			*port = ipd_port - 40;
+		} else if (ipd_port < 44) {
+			*interface = 5;
+			*port = ipd_port - 42;
+		} else if (ipd_port >= 44) {
+			*interface = 6;
+			*port = ipd_port - 44;
+		}
+	}
+	return 0;
+}
+
 int cvmx_helper_get_ipd_port(int interface, int port)
 {
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (interface >= 0 && interface <= 4) {
+			cvmx_helper_interface_mode_t mode = cvmx_helper_interface_get_mode(interface);
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI ||
+			    mode == CVMX_HELPER_INTERFACE_MODE_RXAUI)
+				return 0x840 + (interface * 0x100);
+			else
+				return 0x800 + (interface * 0x100) + (port * 16);
+		} else if (interface == 5 || interface == 6)
+			return 0x400 + (interface - 5) * 0x100 + port;
+		else if (interface == 7)
+			return 0x100 + port;
+		else if (interface == 8)
+			return port;
+		else
+			return -1;
+	}
 	switch (interface) {
 	case 0:
 		return port;
@@ -381,9 +470,189 @@ int cvmx_helper_get_ipd_port(int interface, int port)
 		return port + 32;
 	case 3:
 		return port + 36;
+	case 4:
+		return port + 40;
+	case 5:
+		return port + 42;
+	case 6:
+		return port + 44;
+	case 7:
+		return port + 46;
 	}
 	return -1;
 }
+EXPORT_SYMBOL(cvmx_helper_get_ipd_port);
+
+int __cvmx_helper_get_num_ipd_ports(int interface)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+	return piface->cvif_ipd_nports;
+}
+
+enum cvmx_pko_padding __cvmx_helper_get_pko_padding(int interface)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return CVMX_PKO_PADDING_NONE;
+
+	piface = &cvmx_interfaces[interface];
+	return piface->cvif_padding;
+}
+
+int __cvmx_helper_init_interface(int interface, int num_ipd_ports,
+				 int has_fcs, enum cvmx_pko_padding pad)
+{
+	struct cvmx_iface *piface;
+	cvmx_helper_link_info_t *p;
+	int i;
+	int sz;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+	piface->cvif_ipd_nports = num_ipd_ports;
+	piface->cvif_padding = pad;
+
+	piface->cvif_has_fcs = has_fcs;
+
+	/*
+	 * allocate the per-ipd_port link_info structure
+	 */
+	sz = piface->cvif_ipd_nports * sizeof(cvmx_helper_link_info_t);
+	if (sz == 0)
+		sz = sizeof(cvmx_helper_link_info_t);
+	piface->cvif_ipd_port_link_info = kmalloc(sz, GFP_KERNEL);
+	if (ZERO_OR_NULL_PTR(piface->cvif_ipd_port_link_info))
+		panic("Cannot allocate memory in __cvmx_helper_init_interface.");
+	if (!piface->cvif_ipd_port_link_info)
+		return -1;
+
+	/* Initialize them */
+	p = piface->cvif_ipd_port_link_info;
+
+	for (i = 0; i < piface->cvif_ipd_nports; i++) {
+		(*p).u64 = 0;
+		p++;
+	}
+	return 0;
+}
+
+/*
+ * Shut down the interfaces; free the resources.
+ */
+void __cvmx_helper_shutdown_interfaces(void)
+{
+	int i;
+	int nifaces;		/* number of interfaces */
+	struct cvmx_iface *piface;
+
+	nifaces = cvmx_helper_get_number_of_interfaces();
+	for (i = 0; i < nifaces; i++) {
+		piface = cvmx_interfaces + i;
+		kfree(piface->cvif_ipd_port_link_info);
+		piface->cvif_ipd_port_link_info = NULL;
+	}
+}
+
+int __cvmx_helper_set_link_info(int interface, int port, cvmx_helper_link_info_t link_info)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+
+	if (piface->cvif_ipd_port_link_info) {
+		piface->cvif_ipd_port_link_info[port] = link_info;
+		return 0;
+	}
+
+	return -1;
+}
+
+cvmx_helper_link_info_t __cvmx_helper_get_link_info(int interface, int port)
+{
+	struct cvmx_iface *piface;
+	cvmx_helper_link_info_t err;
+
+	err.u64 = 0;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return err;
+	piface = &cvmx_interfaces[interface];
+
+	if (piface->cvif_ipd_port_link_info)
+		return piface->cvif_ipd_port_link_info[port];
+
+	return err;
+}
+
+/**
+ * Returns if FCS is enabled for the specified interface and port
+ *
+ * @interface: - interface to check
+ *
+ * Returns zero if FCS is not used, otherwise FCS is used.
+ */
+int __cvmx_helper_get_has_fcs(int interface)
+{
+	return cvmx_interfaces[interface].cvif_has_fcs;
+}
+
+int cvmx_helper_get_pknd(int interface, int port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pknd(interface, port);
+
+	return CVMX_INVALID_PKND;
+}
+EXPORT_SYMBOL(cvmx_helper_get_pknd);
+
+int cvmx_helper_get_bpid(int interface, int port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_bpid(interface, port);
+
+	return CVMX_INVALID_BPID;
+}
+EXPORT_SYMBOL(cvmx_helper_get_bpid);
+
+/**
+ * Display interface statistics.
+ *
+ * @port: IPD/PKO port number
+ *
+ * Returns none
+ */
+void cvmx_helper_show_stats(int port)
+{
+	cvmx_pip_port_status_t status;
+	cvmx_pko_port_status_t pko_status;
+
+	/* ILK stats */
+	if (octeon_has_feature(OCTEON_FEATURE_ILK))
+		__cvmx_helper_ilk_show_stats();
+
+	/* PIP stats */
+	cvmx_pip_get_port_status(port, 0, &status);
+	cvmx_dprintf("port %d: the number of packets - ipd: %d\n",
+		     port, (int)status.packets);
+
+	/* PKO stats */
+	cvmx_pko_get_port_status(port, 0, &pko_status);
+	cvmx_dprintf("port %d: the number of packets - pko: %d\n",
+		     port, (int)pko_status.packets);
+
+	/* TODO: other stats */
+}
 
 /**
  * Returns the interface number for an IPD/PKO port number.
@@ -394,20 +663,48 @@ int cvmx_helper_get_ipd_port(int interface, int port)
  */
 int cvmx_helper_get_interface_num(int ipd_port)
 {
-	if (ipd_port < 16)
-		return 0;
-	else if (ipd_port < 32)
-		return 1;
-	else if (ipd_port < 36)
-		return 2;
-	else if (ipd_port < 40)
-		return 3;
-	else
-		cvmx_dprintf("cvmx_helper_get_interface_num: Illegal IPD "
-			     "port number\n");
-
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (ipd_port >= 0x800 && ipd_port < 0x900)
+			return 0;
+		else if (ipd_port >= 0x900 && ipd_port < 0xa00)
+			return 1;
+		else if (ipd_port >= 0xa00 && ipd_port < 0xb00)
+			return 2;
+		else if (ipd_port >= 0xb00 && ipd_port < 0xc00)
+			return 3;
+		else if (ipd_port >= 0xc00 && ipd_port < 0xd00)
+			return 4;
+		else if (ipd_port >= 0x400 && ipd_port < 0x500)
+			return 5;
+		else if (ipd_port >= 0x500 && ipd_port < 0x600)
+			return 6;
+		else if (ipd_port >= 0x100 && ipd_port < 0x120)
+			return 7;
+		else if (ipd_port < 8)
+			return 8;
+	} else {
+		if (ipd_port < 16)
+			return 0;
+		else if (ipd_port < 32)
+			return 1;
+		else if (ipd_port < 36)
+			return 2;
+		else if (ipd_port < 40)
+			return 3;
+		else if (ipd_port < 42)
+			return 4;
+		else if (ipd_port < 44)
+			return 5;
+		else if (ipd_port < 46)
+			return 6;
+		else if (ipd_port < 48)
+			return 7;
+	}
+	cvmx_dprintf("cvmx_helper_get_interface_num: Illegal IPD port number %d\n",
+		     ipd_port);
 	return -1;
 }
+EXPORT_SYMBOL(cvmx_helper_get_interface_num);
 
 /**
  * Returns the interface index number for an IPD/PKO port
@@ -419,15 +716,30 @@ int cvmx_helper_get_interface_num(int ipd_port)
  */
 int cvmx_helper_get_interface_index_num(int ipd_port)
 {
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (ipd_port >= 0x800 && ipd_port < 0xd00) {
+			int port = ((ipd_port & 0xff) >> 6);
+			return port ? (port - 1) : ((ipd_port & 0xff) >> 4);
+		} else if (ipd_port >= 0x400 && ipd_port < 0x600)
+			return ipd_port & 0xff;
+		else if (ipd_port >= 0x100 && ipd_port < 0x120)
+			return ipd_port & 0xff;
+		else if (ipd_port < 8)
+			return ipd_port;
+		else
+			cvmx_dprintf("cvmx_helper_get_interface_index_num: Illegal IPD port number %d\n",
+				     ipd_port);
+		return -1;
+	}
 	if (ipd_port < 32)
 		return ipd_port & 15;
-	else if (ipd_port < 36)
-		return ipd_port & 3;
 	else if (ipd_port < 40)
 		return ipd_port & 3;
+	else if (ipd_port < 48)
+		return ipd_port & 1;
 	else
-		cvmx_dprintf("cvmx_helper_get_interface_index_num: "
-			     "Illegal IPD port number\n");
+		cvmx_dprintf("cvmx_helper_get_interface_index_num: Illegal IPD port number\n");
 
 	return -1;
 }
+EXPORT_SYMBOL(cvmx_helper_get_interface_index_num);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
index 1723248e..ded2265 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,28 +22,24 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Functions for XAUI initialization, configuration,
  * and monitoring.
- *
  */
-
 #include <asm/octeon/octeon.h>
 
-#include <asm/octeon/cvmx-config.h>
-
+#include <asm/octeon/cvmx-qlm.h>
 #include <asm/octeon/cvmx-helper.h>
-
-#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-pcsx-defs.h>
 #include <asm/octeon/cvmx-pcsxx-defs.h>
+#include <asm/octeon/cvmx-ciu-defs.h>
 
-void __cvmx_interrupt_gmxx_enable(int interface);
-void __cvmx_interrupt_pcsx_intx_en_reg_enable(int index, int block);
-void __cvmx_interrupt_pcsxx_int_en_reg_enable(int index);
 
 int __cvmx_helper_xaui_enumerate(int interface)
 {
@@ -72,6 +68,51 @@ int __cvmx_helper_xaui_probe(int interface)
 	union cvmx_gmxx_inf_mode mode;
 
 	/*
+	 * CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis
+	 * be programmed.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_0)) {
+		union cvmx_ciu_qlm2 ciu_qlm;
+		ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM2);
+		ciu_qlm.s.txbypass = 1;
+		ciu_qlm.s.txdeemph = 0x5;
+		ciu_qlm.s.txmargin = 0x1a;
+		cvmx_write_csr(CVMX_CIU_QLM2, ciu_qlm.u64);
+	}
+
+	/*
+	 * CN63XX Pass 2.x errata G-15273 requires the QLM De-emphasis
+	 * be programmed when using a 156.25Mhz ref clock.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X)) {
+		/* Read the QLM speed pins */
+		union cvmx_mio_rst_boot mio_rst_boot;
+		mio_rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+
+		if (mio_rst_boot.cn63xx.qlm2_spd == 0xb) {
+			union cvmx_ciu_qlm2 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM2);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 0xa;
+			ciu_qlm.s.txmargin = 0x1f;
+			cvmx_write_csr(CVMX_CIU_QLM2, ciu_qlm.u64);
+		}
+	}
+
+	/*
+	 * Check if QLM is configured correct for XAUI/RXAUI, verify
+	 * the speed as well as mode.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		int qlm = cvmx_qlm_interface(interface);
+		enum cvmx_qlm_mode mode = cvmx_qlm_get_mode(qlm);
+
+		if (mode != CVMX_QLM_MODE_XAUI &&
+		    mode != CVMX_QLM_MODE_RXAUI)
+			return 0;
+	}
+
+	/*
 	 * Due to errata GMX-700 on CN56XXp1.x and CN52XXp1.x, the
 	 * interface needs to be enabled before IPD otherwise per port
 	 * backpressure may not work properly.
@@ -82,108 +123,146 @@ int __cvmx_helper_xaui_probe(int interface)
 
 	__cvmx_helper_setup_gmx(interface, 1);
 
-	/*
-	 * Setup PKO to support 16 ports for HiGig2 virtual
-	 * ports. We're pointing all of the PKO packet ports for this
-	 * interface to the XAUI. This allows us to use HiGig2
-	 * backpressure per port.
-	 */
-	for (i = 0; i < 16; i++) {
-		union cvmx_pko_mem_port_ptrs pko_mem_port_ptrs;
-		pko_mem_port_ptrs.u64 = 0;
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 		/*
-		 * We set each PKO port to have equal priority in a
-		 * round robin fashion.
+		 * Setup PKO to support 16 ports for HiGig2 virtual
+		 * ports. We're pointing all of the PKO packet ports
+		 * for this interface to the XAUI. This allows us to
+		 * use HiGig2 backpressure per port.
 		 */
-		pko_mem_port_ptrs.s.static_p = 0;
-		pko_mem_port_ptrs.s.qos_mask = 0xff;
-		/* All PKO ports map to the same XAUI hardware port */
-		pko_mem_port_ptrs.s.eid = interface * 4;
-		pko_mem_port_ptrs.s.pid = interface * 16 + i;
-		cvmx_write_csr(CVMX_PKO_MEM_PORT_PTRS, pko_mem_port_ptrs.u64);
+		for (i = 0; i < 16; i++) {
+			union cvmx_pko_mem_port_ptrs pko_mem_port_ptrs;
+			pko_mem_port_ptrs.u64 = 0;
+			/*
+			 * We set each PKO port to have equal priority
+			 * in a round robin fashion.
+			 */
+			pko_mem_port_ptrs.s.static_p = 0;
+			pko_mem_port_ptrs.s.qos_mask = 0xff;
+			/* All PKO ports map to the same XAUI hardware port */
+			pko_mem_port_ptrs.s.eid = interface * 4;
+			pko_mem_port_ptrs.s.pid = interface * 16 + i;
+			cvmx_write_csr(CVMX_PKO_MEM_PORT_PTRS,
+				       pko_mem_port_ptrs.u64);
+		}
 	}
+
 	return __cvmx_helper_xaui_enumerate(interface);
 }
 
 /**
- * Bringup and enable a XAUI interface. After this call packet
- * I/O should be fully functional. This is called with IPD
- * enabled but PKO disabled.
+ * Bringup XAUI interface. After this call packet I/O should be
+ * fully functional.
  *
  * @interface: Interface to bring up
  *
  * Returns Zero on success, negative on failure
  */
-int __cvmx_helper_xaui_enable(int interface)
+int __cvmx_helper_xaui_link_init(int interface)
 {
 	union cvmx_gmxx_prtx_cfg gmx_cfg;
-	union cvmx_pcsxx_control1_reg xauiCtl;
-	union cvmx_pcsxx_misc_ctl_reg xauiMiscCtl;
-	union cvmx_gmxx_tx_xaui_ctl gmxXauiTxCtl;
-	union cvmx_gmxx_rxx_int_en gmx_rx_int_en;
-	union cvmx_gmxx_tx_int_en gmx_tx_int_en;
-	union cvmx_pcsxx_int_en_reg pcsx_int_en_reg;
+	union cvmx_pcsxx_control1_reg xaui_ctl;
+	union cvmx_pcsxx_misc_ctl_reg misc_ctl;
+	union cvmx_gmxx_tx_xaui_ctl tx_ctl;
 
 	/* (1) Interface has already been enabled. */
 
 	/* (2) Disable GMX. */
-	xauiMiscCtl.u64 = cvmx_read_csr(CVMX_PCSXX_MISC_CTL_REG(interface));
-	xauiMiscCtl.s.gmxeno = 1;
-	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), xauiMiscCtl.u64);
+	misc_ctl.u64 = cvmx_read_csr(CVMX_PCSXX_MISC_CTL_REG(interface));
+	misc_ctl.s.gmxeno = 1;
+	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), misc_ctl.u64);
 
 	/* (3) Disable GMX and PCSX interrupts. */
-	gmx_rx_int_en.u64 = cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(0, interface));
 	cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(0, interface), 0x0);
-	gmx_tx_int_en.u64 = cvmx_read_csr(CVMX_GMXX_TX_INT_EN(interface));
 	cvmx_write_csr(CVMX_GMXX_TX_INT_EN(interface), 0x0);
-	pcsx_int_en_reg.u64 = cvmx_read_csr(CVMX_PCSXX_INT_EN_REG(interface));
 	cvmx_write_csr(CVMX_PCSXX_INT_EN_REG(interface), 0x0);
 
 	/* (4) Bring up the PCSX and GMX reconciliation layer. */
 	/* (4)a Set polarity and lane swapping. */
 	/* (4)b */
-	gmxXauiTxCtl.u64 = cvmx_read_csr(CVMX_GMXX_TX_XAUI_CTL(interface));
+	tx_ctl.u64 = cvmx_read_csr(CVMX_GMXX_TX_XAUI_CTL(interface));
 	/* Enable better IFG packing and improves performance */
-	gmxXauiTxCtl.s.dic_en = 1;
-	gmxXauiTxCtl.s.uni_en = 0;
-	cvmx_write_csr(CVMX_GMXX_TX_XAUI_CTL(interface), gmxXauiTxCtl.u64);
+	tx_ctl.s.dic_en = 1;
+	tx_ctl.s.uni_en = 0;
+	cvmx_write_csr(CVMX_GMXX_TX_XAUI_CTL(interface), tx_ctl.u64);
 
 	/* (4)c Aply reset sequence */
-	xauiCtl.u64 = cvmx_read_csr(CVMX_PCSXX_CONTROL1_REG(interface));
-	xauiCtl.s.lo_pwr = 0;
-	xauiCtl.s.reset = 1;
-	cvmx_write_csr(CVMX_PCSXX_CONTROL1_REG(interface), xauiCtl.u64);
+	xaui_ctl.u64 = cvmx_read_csr(CVMX_PCSXX_CONTROL1_REG(interface));
+	xaui_ctl.s.lo_pwr = 0;
+
+	/*
+	 * Errata G-15618 requires disabling PCS soft reset in some
+	 * OCTEON II models.
+	 */
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_1) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X) &&
+	    !OCTEON_IS_MODEL(OCTEON_CN68XX))
+		xaui_ctl.s.reset = 1;
+	cvmx_write_csr(CVMX_PCSXX_CONTROL1_REG(interface), xaui_ctl.u64);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X) && (interface != 1)
+	    && (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)) {
+		/*
+		 * Note that GMX 1 was skipped as GMX0 is on the same
+		 * QLM and will always be done first
+		 *
+		 * Workaround for Errata (G-16467).
+		 */
+		int qlm = interface;
+#ifdef CVMX_QLM_DUMP_STATE
+		cvmx_dprintf("%s:%d: XAUI%d: Applying workaround for Errata G-16467\n",
+			     __func__, __LINE__, qlm);
+		cvmx_qlm_display_registers(qlm);
+		cvmx_dprintf("\n");
+#endif
+		/*
+		 * This workaround only applies to QLMs running XAUI
+		 * at 6.25Ghz
+		 */
+		if ((cvmx_qlm_get_gbaud_mhz(qlm) == 6250) &&
+		    (cvmx_qlm_jtag_get(qlm, 0, "clkf_byp") != 20)) {
+			/* Wait 100us for links to stabalize */
+			udelay(100);
+			cvmx_qlm_jtag_set(qlm, -1, "clkf_byp", 20);
+			/* Allow the QLM to exit reset */
+			cvmx_qlm_jtag_set(qlm, -1, "cfg_rst_n_clr", 0);
+			/* Wait 100us for links to stabalize */
+			udelay(100);
+			/* Allow TX on QLM */
+			cvmx_qlm_jtag_set(qlm, -1, "cfg_tx_idle_set", 0);
+		}
+#ifdef CVMX_QLM_DUMP_STATE
+		cvmx_dprintf("%s:%d: XAUI%d: Done applying workaround for Errata G-16467\n",
+			     __func__, __LINE__, qlm);
+		cvmx_qlm_display_registers(qlm);
+		cvmx_dprintf("\n\n");
+#endif
+	}
 
 	/* Wait for PCS to come out of reset */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_PCSXX_CONTROL1_REG(interface), union cvmx_pcsxx_control1_reg,
-	     reset, ==, 0, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSXX_CONTROL1_REG(interface),
+				  union cvmx_pcsxx_control1_reg, reset, ==, 0, 10000))
 		return -1;
 	/* Wait for PCS to be aligned */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_PCSXX_10GBX_STATUS_REG(interface),
-	     union cvmx_pcsxx_10gbx_status_reg, alignd, ==, 1, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSXX_10GBX_STATUS_REG(interface),
+				  union cvmx_pcsxx_10gbx_status_reg, alignd, ==, 1, 10000))
 		return -1;
 	/* Wait for RX to be ready */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_GMXX_RX_XAUI_CTL(interface), union cvmx_gmxx_rx_xaui_ctl,
-		    status, ==, 0, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_RX_XAUI_CTL(interface),
+				  union cvmx_gmxx_rx_xaui_ctl, status, ==, 0, 10000))
 		return -1;
 
 	/* (6) Configure GMX */
-	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
-	gmx_cfg.s.en = 0;
-	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
 	/* Wait for GMX RX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_GMXX_PRTX_CFG(0, interface), union cvmx_gmxx_prtx_cfg,
-		    rx_idle, ==, 1, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(0, interface),
+				  union cvmx_gmxx_prtx_cfg, rx_idle, ==, 1, 10000))
 		return -1;
 	/* Wait for GMX TX to be idle */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_GMXX_PRTX_CFG(0, interface), union cvmx_gmxx_prtx_cfg,
-		    tx_idle, ==, 1, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(0, interface),
+				  union cvmx_gmxx_prtx_cfg, tx_idle, ==, 1, 10000))
 		return -1;
 
 	/* GMX configure */
@@ -196,48 +275,78 @@ int __cvmx_helper_xaui_enable(int interface)
 	cvmx_write_csr(CVMX_GMXX_TXX_BURST(0, interface), 8192);
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
-	/* (7) Clear out any error state */
-	cvmx_write_csr(CVMX_GMXX_RXX_INT_REG(0, interface),
-		       cvmx_read_csr(CVMX_GMXX_RXX_INT_REG(0, interface)));
-	cvmx_write_csr(CVMX_GMXX_TX_INT_REG(interface),
-		       cvmx_read_csr(CVMX_GMXX_TX_INT_REG(interface)));
-	cvmx_write_csr(CVMX_PCSXX_INT_REG(interface),
-		       cvmx_read_csr(CVMX_PCSXX_INT_REG(interface)));
-
 	/* Wait for receive link */
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_PCSXX_STATUS1_REG(interface), union cvmx_pcsxx_status1_reg,
-	     rcv_lnk, ==, 1, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSXX_STATUS1_REG(interface),
+				  union cvmx_pcsxx_status1_reg, rcv_lnk, ==, 1, 10000))
 		return -1;
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_PCSXX_STATUS2_REG(interface), union cvmx_pcsxx_status2_reg,
-	     xmtflt, ==, 0, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSXX_STATUS2_REG(interface),
+				  union cvmx_pcsxx_status2_reg, xmtflt, ==, 0, 10000))
 		return -1;
-	if (CVMX_WAIT_FOR_FIELD64
-	    (CVMX_PCSXX_STATUS2_REG(interface), union cvmx_pcsxx_status2_reg,
-	     rcvflt, ==, 0, 10000))
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_PCSXX_STATUS2_REG(interface),
+				  union cvmx_pcsxx_status2_reg, rcvflt, ==, 0, 10000))
 		return -1;
 
-	cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(0, interface), gmx_rx_int_en.u64);
-	cvmx_write_csr(CVMX_GMXX_TX_INT_EN(interface), gmx_tx_int_en.u64);
-	cvmx_write_csr(CVMX_PCSXX_INT_EN_REG(interface), pcsx_int_en_reg.u64);
-
-	cvmx_helper_link_autoconf(cvmx_helper_get_ipd_port(interface, 0));
-
 	/* (8) Enable packet reception */
-	xauiMiscCtl.s.gmxeno = 0;
-	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), xauiMiscCtl.u64);
+	misc_ctl.s.gmxeno = 0;
+	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), misc_ctl.u64);
 
+	/* Clear all error interrupts before enabling the interface. */
+	cvmx_write_csr(CVMX_GMXX_RXX_INT_REG(0, interface), ~0x0ull);
+	cvmx_write_csr(CVMX_GMXX_TX_INT_REG(interface), ~0x0ull);
+	cvmx_write_csr(CVMX_PCSXX_INT_REG(interface), ~0x0ull);
+
+	/* Enable GMX */
 	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
 	gmx_cfg.s.en = 1;
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
-	__cvmx_interrupt_pcsx_intx_en_reg_enable(0, interface);
-	__cvmx_interrupt_pcsx_intx_en_reg_enable(1, interface);
-	__cvmx_interrupt_pcsx_intx_en_reg_enable(2, interface);
-	__cvmx_interrupt_pcsx_intx_en_reg_enable(3, interface);
-	__cvmx_interrupt_pcsxx_int_en_reg_enable(interface);
-	__cvmx_interrupt_gmxx_enable(interface);
+	return 0;
+}
+
+/**
+ * Bringup and enable a XAUI interface. After this call packet
+ * I/O should be fully functional. This is called with IPD
+ * enabled but PKO disabled.
+ *
+ * @interface: Interface to bring up
+ *
+ * Returns Zero on success, negative on failure
+ */
+int __cvmx_helper_xaui_enable(int interface)
+{
+	/* Setup PKND and BPID */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		union cvmx_gmxx_bpid_msk bpid_msk;
+		union cvmx_gmxx_bpid_mapx bpid_map;
+		union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
+		union cvmx_gmxx_txx_append gmxx_txx_append_cfg;
+
+		/* Setup PKIND */
+		gmxx_prtx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
+		gmxx_prtx_cfg.s.pknd = cvmx_helper_get_pknd(interface, 0);
+		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface),
+			       gmxx_prtx_cfg.u64);
+
+		/* Setup BPID */
+		bpid_map.u64 = cvmx_read_csr(CVMX_GMXX_BPID_MAPX(0, interface));
+		bpid_map.s.val = 1;
+		bpid_map.s.bpid = cvmx_helper_get_bpid(interface, 0);
+		cvmx_write_csr(CVMX_GMXX_BPID_MAPX(0, interface), bpid_map.u64);
+
+		bpid_msk.u64 = cvmx_read_csr(CVMX_GMXX_BPID_MSK(interface));
+		bpid_msk.s.msk_or |= 1;
+		bpid_msk.s.msk_and &= ~1;
+		cvmx_write_csr(CVMX_GMXX_BPID_MSK(interface), bpid_msk.u64);
+
+		/* CN68XX adds the padding and FCS in PKO, not GMX */
+		gmxx_txx_append_cfg.u64 = cvmx_read_csr(CVMX_GMXX_TXX_APPEND(0, interface));
+		gmxx_txx_append_cfg.s.fcs = 0;
+		gmxx_txx_append_cfg.s.pad = 0;
+		cvmx_write_csr(CVMX_GMXX_TXX_APPEND(0, interface),
+			       gmxx_txx_append_cfg.u64);
+	}
+
+	__cvmx_helper_xaui_link_init(interface);
 
 	return 0;
 }
@@ -262,16 +371,35 @@ cvmx_helper_link_info_t __cvmx_helper_xaui_link_get(int ipd_port)
 
 	gmxx_tx_xaui_ctl.u64 = cvmx_read_csr(CVMX_GMXX_TX_XAUI_CTL(interface));
 	gmxx_rx_xaui_ctl.u64 = cvmx_read_csr(CVMX_GMXX_RX_XAUI_CTL(interface));
-	pcsxx_status1_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSXX_STATUS1_REG(interface));
+	pcsxx_status1_reg.u64 = cvmx_read_csr(CVMX_PCSXX_STATUS1_REG(interface));
 	result.u64 = 0;
 
 	/* Only return a link if both RX and TX are happy */
-	if ((gmxx_tx_xaui_ctl.s.ls == 0) && (gmxx_rx_xaui_ctl.s.status == 0) &&
+	if ((gmxx_tx_xaui_ctl.s.ls == 0) &&
+	    (gmxx_rx_xaui_ctl.s.status == 0) &&
 	    (pcsxx_status1_reg.s.rcv_lnk == 1)) {
+		union cvmx_pcsxx_misc_ctl_reg misc_ctl;
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = 10000;
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+			union cvmx_mio_qlmx_cfg qlm_cfg;
+			int lanes;
+			int qlm = (interface == 1) ? 0 : interface;
+
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+			result.s.speed = cvmx_qlm_get_gbaud_mhz(qlm) * 8 / 10;
+			lanes = (qlm_cfg.s.qlm_cfg == 7) ? 2 : 4;
+			result.s.speed *= lanes;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+			int qlm = cvmx_qlm_interface(interface);
+			result.s.speed = cvmx_qlm_get_gbaud_mhz(qlm) * 8 / 10;
+			result.s.speed *= 4;
+		} else {
+			result.s.speed = 10000;
+		}
+		misc_ctl.u64 = cvmx_read_csr(CVMX_PCSXX_MISC_CTL_REG(interface));
+		if (misc_ctl.s.gmxeno)
+			__cvmx_helper_xaui_link_init(interface);
 	} else {
 		/* Disable GMX and PCSX interrupts. */
 		cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(0, interface), 0x0);
@@ -311,7 +439,7 @@ int __cvmx_helper_xaui_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 		return 0;
 
 	/* Bring the link up */
-	return __cvmx_helper_xaui_enable(interface);
+	return __cvmx_helper_xaui_link_init(interface);
 }
 
 /**
@@ -336,19 +464,15 @@ extern int __cvmx_helper_xaui_configure_loopback(int ipd_port,
 	union cvmx_gmxx_xaui_ext_loopback gmxx_xaui_ext_loopback;
 
 	/* Set the internal loop */
-	pcsxx_control1_reg.u64 =
-	    cvmx_read_csr(CVMX_PCSXX_CONTROL1_REG(interface));
+	pcsxx_control1_reg.u64 = cvmx_read_csr(CVMX_PCSXX_CONTROL1_REG(interface));
 	pcsxx_control1_reg.s.loopbck1 = enable_internal;
-	cvmx_write_csr(CVMX_PCSXX_CONTROL1_REG(interface),
-		       pcsxx_control1_reg.u64);
+	cvmx_write_csr(CVMX_PCSXX_CONTROL1_REG(interface), pcsxx_control1_reg.u64);
 
 	/* Set the external loop */
-	gmxx_xaui_ext_loopback.u64 =
-	    cvmx_read_csr(CVMX_GMXX_XAUI_EXT_LOOPBACK(interface));
+	gmxx_xaui_ext_loopback.u64 = cvmx_read_csr(CVMX_GMXX_XAUI_EXT_LOOPBACK(interface));
 	gmxx_xaui_ext_loopback.s.en = enable_external;
-	cvmx_write_csr(CVMX_GMXX_XAUI_EXT_LOOPBACK(interface),
-		       gmxx_xaui_ext_loopback.u64);
+	cvmx_write_csr(CVMX_GMXX_XAUI_EXT_LOOPBACK(interface), gmxx_xaui_ext_loopback.u64);
 
 	/* Take the link through a reset */
-	return __cvmx_helper_xaui_enable(interface);
+	return __cvmx_helper_xaui_link_init(interface);
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index fa49638..fedcd52 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,17 +22,26 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * Helper functions for common, but complicated tasks.
- *
  */
-#include <asm/octeon/octeon.h>
+#include <linux/export.h>
 
+#include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-config.h>
+#include <asm/octeon/cvmx-bootmem.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-npi-defs.h>
+#include <asm/octeon/cvmx-mio-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-dbg-defs.h>
 
 #include <asm/octeon/cvmx-fpa.h>
 #include <asm/octeon/cvmx-pip.h>
@@ -41,37 +50,31 @@
 #include <asm/octeon/cvmx-spi.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-board.h>
+#include <asm/octeon/cvmx-helper-errata.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+
+cvmx_helper_link_info_t __cvmx_helper_get_link_info(int interface, int port);
 
-#include <asm/octeon/cvmx-pip-defs.h>
-#include <asm/octeon/cvmx-smix-defs.h>
-#include <asm/octeon/cvmx-asxx-defs.h>
 
 /**
- * cvmx_override_pko_queue_priority(int ipd_port, uint64_t
+ * cvmx_override_pko_queue_priority(int pko_port, uint64_t
  * priorities[16]) is a function pointer. It is meant to allow
  * customization of the PKO queue priorities based on the port
  * number. Users should set this pointer to a function before
  * calling any cvmx-helper operations.
  */
-void (*cvmx_override_pko_queue_priority) (int pko_port,
-					  uint64_t priorities[16]);
+void (*cvmx_override_pko_queue_priority) (int ipd_port, uint64_t *priorities);
+EXPORT_SYMBOL(cvmx_override_pko_queue_priority);
 
 /**
  * cvmx_override_ipd_port_setup(int ipd_port) is a function
- * pointer. It is meant to allow customization of the IPD port
- * setup before packet input/output comes online. It is called
- * after cvmx-helper does the default IPD configuration, but
- * before IPD is enabled. Users should set this pointer to a
+ * pointer. It is meant to allow customization of the IPD
+ * port/port kind setup before packet input/output comes online.
+ * It is called after cvmx-helper does the default IPD configuration,
+ * but before IPD is enabled. Users should set this pointer to a
  * function before calling any cvmx-helper operations.
  */
-void (*cvmx_override_ipd_port_setup) (int ipd_port);
-
-/* Port count per interface */
-static int interface_port_count[4] = { 0, 0, 0, 0 };
-
-/* Port last configured link info index by IPD/PKO port */
-static cvmx_helper_link_info_t
-    port_link_info[CVMX_PIP_NUM_INPUT_PORTS];
+void (*cvmx_override_ipd_port_setup) (int ipd_port) = NULL;
 
 /**
  * Return the number of interfaces the chip has. Each interface
@@ -83,11 +86,25 @@ static cvmx_helper_link_info_t
  */
 int cvmx_helper_get_number_of_interfaces(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 9;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+			return 7;
+		else
+			return 8;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 6;
+	else if (OCTEON_IS_MODEL(OCTEON_CN56XX) ||
+		 OCTEON_IS_MODEL(OCTEON_CN52XX) ||
+		 OCTEON_IS_MODEL(OCTEON_CN61XX) ||
+		 OCTEON_IS_MODEL(OCTEON_CNF71XX))
 		return 4;
 	else
 		return 3;
 }
+EXPORT_SYMBOL(cvmx_helper_get_number_of_interfaces);
 
 /**
  * Return the number of ports on an interface. Depending on the
@@ -100,7 +117,201 @@ int cvmx_helper_get_number_of_interfaces(void)
  */
 int cvmx_helper_ports_on_interface(int interface)
 {
-	return interface_port_count[interface];
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return cvmx_helper_interface_enumerate(interface);
+	else
+		return __cvmx_helper_get_num_ipd_ports(interface);
+}
+EXPORT_SYMBOL(cvmx_helper_ports_on_interface);
+
+/**
+ * Return interface mode for CN68xx.
+ */
+static cvmx_helper_interface_mode_t __cvmx_get_mode_cn68xx(int interface)
+{
+	union cvmx_mio_qlmx_cfg qlm_cfg;
+	switch (interface) {
+	case 0:
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (qlm_cfg.s.qlm_cfg == 7)
+			return CVMX_HELPER_INTERFACE_MODE_RXAUI;
+		else if (qlm_cfg.s.qlm_cfg == 2)
+			return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		else if (qlm_cfg.s.qlm_cfg == 3)
+			return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	case 1:
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (qlm_cfg.s.qlm_cfg == 7)
+			return CVMX_HELPER_INTERFACE_MODE_RXAUI;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	case 2:
+	case 3:
+	case 4:
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(interface));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (qlm_cfg.s.qlm_cfg == 2)
+			return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		else if (qlm_cfg.s.qlm_cfg == 3)
+			return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	case 5:
+	case 6:
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(interface - 4));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (qlm_cfg.s.qlm_cfg == 1)
+			return CVMX_HELPER_INTERFACE_MODE_ILK;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	case 7:
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(3));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlm_cfg.s.qlm_spd == 15) {
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		} else if (qlm_cfg.s.qlm_cfg != 0) {
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
+			if (qlm_cfg.s.qlm_cfg != 0)
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+		return CVMX_HELPER_INTERFACE_MODE_NPI;
+	case 8:
+		return CVMX_HELPER_INTERFACE_MODE_LOOP;
+	default:
+		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	}
+}
+
+/**
+ * Return interface mode for an Octeon II
+ */
+static cvmx_helper_interface_mode_t __cvmx_get_mode_octeon2(int interface)
+{
+	union cvmx_gmxx_inf_mode mode;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return __cvmx_get_mode_cn68xx(interface);
+
+	if (interface == 2)
+		return CVMX_HELPER_INTERFACE_MODE_NPI;
+
+	if (interface == 3)
+		return CVMX_HELPER_INTERFACE_MODE_LOOP;
+
+	/* Only present in CN63XX & CN66XX Octeon model */
+	if ((OCTEON_IS_MODEL(OCTEON_CN63XX) &&
+	     (interface == 4 || interface == 5)) ||
+	    (OCTEON_IS_MODEL(OCTEON_CN66XX) &&
+	     interface >= 4 && interface <= 7)) {
+		union cvmx_sriox_status_reg sriox_status_reg;
+
+		/* cn66xx pass1.0 has only 2 SRIO interfaces. */
+		if ((interface == 5 || interface == 7) &&
+		    OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		/*
+		 * Later passes of cn66xx support SRIO0 - x4/x2/x1,
+		 * SRIO2 - x2/x1, SRIO3 - x1
+		 */
+		else if (interface == 5 && OCTEON_IS_MODEL(OCTEON_CN66XX))
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		sriox_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(interface - 4));
+		if (sriox_status_reg.s.srio)
+			return CVMX_HELPER_INTERFACE_MODE_SRIO;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		union cvmx_mio_qlmx_cfg mio_qlm_cfg;
+
+		/* QLM2 is SGMII0 and QLM1 is SGMII1 */
+		if (interface == 0)
+			mio_qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(2));
+		else if (interface == 1)
+			mio_qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (mio_qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (mio_qlm_cfg.s.qlm_cfg == 9)
+			return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		else if (mio_qlm_cfg.s.qlm_cfg == 11)
+			return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		union cvmx_mio_qlmx_cfg qlm_cfg;
+
+		if (interface == 0) {
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(2));
+			if (qlm_cfg.s.qlm_cfg == 2)
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			else if (qlm_cfg.s.qlm_cfg == 3)
+				return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			else
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		} else if (interface == 1) {
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+			if (qlm_cfg.s.qlm_cfg == 2)
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			else if (qlm_cfg.s.qlm_cfg == 3)
+				return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			else
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		if (interface == 0) {
+			union cvmx_mio_qlmx_cfg qlm_cfg;
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+			if (qlm_cfg.s.qlm_cfg == 2)
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		}
+		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	}
+
+	if (interface == 1 && OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+	mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
+
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+		switch (mode.cn63xx.mode) {
+		case 0:
+			return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		case 1:
+			return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		default:
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+	} else {
+		if (!mode.s.en)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (mode.s.type)
+			return CVMX_HELPER_INTERFACE_MODE_GMII;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_RGMII;
+	}
 }
 
 /**
@@ -116,6 +327,21 @@ int cvmx_helper_ports_on_interface(int interface)
 cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 {
 	union cvmx_gmxx_inf_mode mode;
+
+	if (interface < 0 ||
+	    interface >= cvmx_helper_get_number_of_interfaces())
+		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+	/*
+	 * Octeon II models
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) ||
+	    OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		return __cvmx_get_mode_octeon2(interface);
+
+	/*
+	 * Octeon and Octeon Plus models
+	 */
 	if (interface == 2)
 		return CVMX_HELPER_INTERFACE_MODE_NPI;
 
@@ -127,9 +353,9 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
 	}
 
-	if (interface == 0
-	    && cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3005_EVB_HS5
-	    && cvmx_sysinfo_get()->board_rev_major == 1) {
+	if (interface == 0 &&
+	    cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3005_EVB_HS5 &&
+	    cvmx_sysinfo_get()->board_rev_major == 1) {
 		/*
 		 * Lie about interface type of CN3005 board.  This
 		 * board has a switch on port 1 like the other
@@ -145,7 +371,8 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 
 	/* Interface 1 is always disabled on CN31XX and CN30XX */
 	if ((interface == 1)
-	    && (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN30XX)
+	    && (OCTEON_IS_MODEL(OCTEON_CN31XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN30XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN50XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN52XX)))
 		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
@@ -170,8 +397,8 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
 
 		if (mode.s.type) {
-			if (OCTEON_IS_MODEL(OCTEON_CN38XX)
-			    || OCTEON_IS_MODEL(OCTEON_CN58XX))
+			if (OCTEON_IS_MODEL(OCTEON_CN38XX) ||
+			    OCTEON_IS_MODEL(OCTEON_CN58XX))
 				return CVMX_HELPER_INTERFACE_MODE_SPI;
 			else
 				return CVMX_HELPER_INTERFACE_MODE_GMII;
@@ -179,6 +406,7 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 			return CVMX_HELPER_INTERFACE_MODE_RGMII;
 	}
 }
+EXPORT_SYMBOL(cvmx_helper_interface_get_mode);
 
 /**
  * Configure the IPD/PIP tagging and QoS options for a specific
@@ -186,8 +414,8 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
  * contents for a port. The setup performed here is controlled by
  * the defines in executive-config.h.
  *
- * @ipd_port: Port to configure. This follows the IPD numbering, not the
- *                 per interface numbering
+ * @ipd_port: Port/Port kind to configure. This follows the IPD numbering,
+ *                 not the per interface numbering
  *
  * Returns Zero on success, negative on failure
  */
@@ -196,11 +424,30 @@ static int __cvmx_helper_port_setup_ipd(int ipd_port)
 	union cvmx_pip_prt_cfgx port_config;
 	union cvmx_pip_prt_tagx tag_config;
 
-	port_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
-	tag_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_TAGX(ipd_port));
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		int interface, index, pknd;
+		union cvmx_pip_prt_cfgbx prt_cfgbx;
+
+		interface = cvmx_helper_get_interface_num(ipd_port);
+		index = cvmx_helper_get_interface_index_num(ipd_port);
+		pknd = cvmx_helper_get_pknd(interface, index);
+
+		port_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+		tag_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_TAGX(pknd));
 
-	/* Have each port go to a different POW queue */
-	port_config.s.qos = ipd_port & 0x7;
+		port_config.s.qos = pknd & 0x7;
+
+		/* Default BPID to use for packets on this port-kind */
+		prt_cfgbx.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGBX(pknd));
+		prt_cfgbx.s.bpid = pknd;
+		cvmx_write_csr(CVMX_PIP_PRT_CFGBX(pknd), prt_cfgbx.u64);
+	} else {
+		port_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
+		tag_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_TAGX(ipd_port));
+
+		/* Have each port go to a different POW queue */
+		port_config.s.qos = ipd_port & 0x7;
+	}
 
 	/* Process the headers and place the IP header in the work queue */
 	port_config.s.mode = CVMX_HELPER_INPUT_PORT_SKIP_MODE;
@@ -234,85 +481,109 @@ static int __cvmx_helper_port_setup_ipd(int ipd_port)
 }
 
 /**
- * This function sets the interface_port_count[interface] correctly,
- * without modifying any hardware configuration.  Hardware setup of
- * the ports will be performed later.
+ * Enable or disable FCS stripping for all the ports on an interface.
  *
- * @interface: Interface to probe
+ * @interface:
+ * @nports: number of ports
+ * @has_fcs: 0 for disable and !0 for enable
+ */
+static int cvmx_helper_fcs_op(int interface, int nports, int has_fcs)
+{
+	uint64_t port_bit;
+	int index;
+	int pknd;
+	union cvmx_pip_sub_pkind_fcsx pkind_fcsx;
+	union cvmx_pip_prt_cfgx port_cfg;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
+		return 0;
+
+	port_bit = 0;
+	for (index = 0; index < nports; index++)
+		port_bit |= ((uint64_t) 1 << cvmx_helper_get_pknd(interface, index));
+
+	pkind_fcsx.u64 = cvmx_read_csr(CVMX_PIP_SUB_PKIND_FCSX(0));
+	if (has_fcs)
+		pkind_fcsx.s.port_bit |= port_bit;
+	else
+		pkind_fcsx.s.port_bit &= ~port_bit;
+	cvmx_write_csr(CVMX_PIP_SUB_PKIND_FCSX(0), pkind_fcsx.u64);
+
+	for (pknd = 0; pknd < 64; pknd++) {
+		if ((1ull << pknd) & port_bit) {
+			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+			port_cfg.s.crc_en = (has_fcs) ? 1 : 0;
+			cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Determine the actual number of hardware ports connected to an
+ * interface. It doesn't setup the ports or enable them.
  *
- * Returns Zero on success, negative on failure
+ * @interface: Interface to enumerate
+ *
+ * Returns The number of ports on the interface, negative on failure
  */
 int cvmx_helper_interface_enumerate(int interface)
 {
 	switch (cvmx_helper_interface_get_mode(interface)) {
-		/* These types don't support ports to IPD/PKO */
-	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
-	case CVMX_HELPER_INTERFACE_MODE_PCIE:
-		interface_port_count[interface] = 0;
-		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		interface_port_count[interface] =
-		    __cvmx_helper_xaui_enumerate(interface);
-		break;
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		return __cvmx_helper_xaui_enumerate(interface);
 		/*
 		 * RGMII/GMII/MII are all treated about the same. Most
-		 * functions refer to these ports as RGMII.
+		 * functions refer to these ports as RGMII
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_RGMII:
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
-		interface_port_count[interface] =
-		    __cvmx_helper_rgmii_enumerate(interface);
-		break;
+		return __cvmx_helper_rgmii_enumerate(interface);
 		/*
 		 * SPI4 can have 1-16 ports depending on the device at
 		 * the other end.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
-		interface_port_count[interface] =
-		    __cvmx_helper_spi_enumerate(interface);
-		break;
+		return __cvmx_helper_spi_enumerate(interface);
 		/*
 		 * SGMII can have 1-4 ports depending on how many are
 		 * hooked up.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
-		interface_port_count[interface] =
-		    __cvmx_helper_sgmii_enumerate(interface);
-		break;
+		return __cvmx_helper_sgmii_enumerate(interface);
 		/* PCI target Network Packet Interface */
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
-		interface_port_count[interface] =
-		    __cvmx_helper_npi_enumerate(interface);
-		break;
+		return __cvmx_helper_npi_enumerate(interface);
 		/*
 		 * Special loopback only ports. These are not the same
 		 * as other ports in loopback mode.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
-		interface_port_count[interface] =
-		    __cvmx_helper_loop_enumerate(interface);
-		break;
-	}
+		return __cvmx_helper_loop_enumerate(interface);
+		/* SRIO has 2^N ports, where N is number of interfaces */
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		return __cvmx_helper_srio_enumerate(interface);
 
-	interface_port_count[interface] =
-	    __cvmx_helper_board_interface_probe(interface,
-						interface_port_count
-						[interface]);
-
-	/* Make sure all global variables propagate to other cores */
-	CVMX_SYNCWS;
-
-	return 0;
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		return __cvmx_helper_ilk_enumerate(interface);
+		/* These types don't support ports to IPD/PKO */
+	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
+	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+	default:
+		return 0;
+	}
 }
 
 /**
- * This function probes an interface to determine the actual
- * number of hardware ports connected to it. It doesn't setup the
- * ports or enable them. The main goal here is to set the global
- * interface_port_count[interface] correctly. Hardware setup of the
- * ports will be performed later.
+ * This function probes an interface to determine the actual number of
+ * hardware ports connected to it. It does some setup the ports but
+ * doesn't enable them. The main goal here is to set the global
+ * interface_port_count[interface] correctly. Final hardware setup of
+ * the ports will be performed later.
  *
  * @interface: Interface to probe
  *
@@ -320,18 +591,30 @@ int cvmx_helper_interface_enumerate(int interface)
  */
 int cvmx_helper_interface_probe(int interface)
 {
-	cvmx_helper_interface_enumerate(interface);
-	/* At this stage in the game we don't want packets to be moving yet.
-	   The following probe calls should perform hardware setup
-	   needed to determine port counts. Receive must still be disabled */
+	/*
+	 * At this stage in the game we don't want packets to be
+	 * moving yet.  The following probe calls should perform
+	 * hardware setup needed to determine port counts. Receive
+	 * must still be disabled.
+	 */
+	int nports;
+	int has_fcs;
+	enum cvmx_pko_padding padding = CVMX_PKO_PADDING_NONE;
+
+	nports = -1;
+	has_fcs = 0;
 	switch (cvmx_helper_interface_get_mode(interface)) {
 		/* These types don't support ports to IPD/PKO */
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+		nports = 0;
 		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		__cvmx_helper_xaui_probe(interface);
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		nports = __cvmx_helper_xaui_probe(interface);
+		has_fcs = 1;
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * RGMII/GMII/MII are all treated about the same. Most
@@ -339,36 +622,58 @@ int cvmx_helper_interface_probe(int interface)
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_RGMII:
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
-		__cvmx_helper_rgmii_probe(interface);
+		nports = __cvmx_helper_rgmii_probe(interface);
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * SPI4 can have 1-16 ports depending on the device at
 		 * the other end.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
-		__cvmx_helper_spi_probe(interface);
+		nports = __cvmx_helper_spi_probe(interface);
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * SGMII can have 1-4 ports depending on how many are
 		 * hooked up.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		padding = CVMX_PKO_PADDING_60;
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
-		__cvmx_helper_sgmii_probe(interface);
+		nports = __cvmx_helper_sgmii_probe(interface);
+		has_fcs = 1;
 		break;
 		/* PCI target Network Packet Interface */
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
-		__cvmx_helper_npi_probe(interface);
+		nports = __cvmx_helper_npi_probe(interface);
 		break;
 		/*
 		 * Special loopback only ports. These are not the same
 		 * as other ports in loopback mode.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
-		__cvmx_helper_loop_probe(interface);
+		nports = __cvmx_helper_loop_probe(interface);
+		break;
+		/* SRIO has 2^N ports, where N is number of interfaces */
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		nports = __cvmx_helper_srio_probe(interface);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		nports = __cvmx_helper_ilk_probe(interface);
+		padding = CVMX_PKO_PADDING_60;
+		has_fcs = 1;
 		break;
 	}
 
+	if (nports == -1)
+		return -1;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
+		has_fcs = 0;
+
+	nports = __cvmx_helper_board_interface_probe(interface, nports);
+	__cvmx_helper_init_interface(interface, nports, has_fcs, padding);
+	cvmx_helper_fcs_op(interface, nports, has_fcs);
 	/* Make sure all global variables propagate to other cores */
 	CVMX_SYNCWS;
 
@@ -387,13 +692,31 @@ int cvmx_helper_interface_probe(int interface)
  */
 static int __cvmx_helper_interface_setup_ipd(int interface)
 {
+
+	cvmx_helper_interface_mode_t mode;
 	int ipd_port = cvmx_helper_get_ipd_port(interface, 0);
-	int num_ports = interface_port_count[interface];
+	int num_ports = cvmx_helper_ports_on_interface(interface);
+	int delta;
+
+	if (num_ports == CVMX_HELPER_CFG_INVALID_VALUE)
+		return 0;
+
+	mode = cvmx_helper_interface_get_mode(interface);
+
+	if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP)
+		__cvmx_helper_loop_enable(interface);
+
+	delta = 1;
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_SGMII)
+			delta = 16;
+	}
 
 	while (num_ports--) {
 		__cvmx_helper_port_setup_ipd(ipd_port);
-		ipd_port++;
+		ipd_port += delta;
 	}
+
 	return 0;
 }
 
@@ -405,6 +728,9 @@ static int __cvmx_helper_interface_setup_ipd(int interface)
  */
 static int __cvmx_helper_global_setup_ipd(void)
 {
+#ifndef CVMX_HELPER_IPD_DRAM_MODE
+#define CVMX_HELPER_IPD_DRAM_MODE   CVMX_IPD_OPC_MODE_STT
+#endif
 	/* Setup the global packet input options */
 	cvmx_ipd_config(CVMX_FPA_PACKET_POOL_SIZE / 8,
 			CVMX_HELPER_FIRST_MBUFF_SKIP / 8,
@@ -414,8 +740,7 @@ static int __cvmx_helper_global_setup_ipd(void)
 			/* The +8 is to account for the next ptr */
 			(CVMX_HELPER_NOT_FIRST_MBUFF_SKIP + 8) / 128,
 			CVMX_FPA_WQE_POOL,
-			CVMX_IPD_OPC_MODE_STT,
-			CVMX_HELPER_ENABLE_BACK_PRESSURE);
+			CVMX_HELPER_IPD_DRAM_MODE, 1);
 	return 0;
 }
 
@@ -442,8 +767,8 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 	 * the second half.  With per-core PKO queues (PKO lockless
 	 * operation) all queues have the same priority.
 	 */
-	uint64_t priorities[16] =
-	    { 8, 7, 6, 5, 4, 3, 2, 1, 8, 7, 6, 5, 4, 3, 2, 1 };
+	/* uint64_t priorities[16] = {8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1}; */
+	uint64_t priorities[16] = {[0 ... 15] = 8 };
 
 	/*
 	 * Setup the IPD/PIP and PKO for the ports discovered
@@ -451,7 +776,7 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 	 * priorities are set.
 	 */
 	int ipd_port = cvmx_helper_get_ipd_port(interface, 0);
-	int num_ports = interface_port_count[interface];
+	int num_ports = cvmx_helper_ports_on_interface(interface);
 	while (num_ports--) {
 		/*
 		 * Give the user a chance to override the per queue
@@ -461,8 +786,7 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 			cvmx_override_pko_queue_priority(ipd_port, priorities);
 
 		cvmx_pko_config_port(ipd_port,
-				     cvmx_pko_get_base_queue_per_core(ipd_port,
-								      0),
+				     cvmx_pko_get_base_queue_per_core(ipd_port, 0),
 				     cvmx_pko_get_num_queues(ipd_port),
 				     priorities);
 		ipd_port++;
@@ -487,6 +811,21 @@ static int __cvmx_helper_global_setup_pko(void)
 	fau_to.s.tout_val = 0xfff;
 	fau_to.s.tout_enb = 0;
 	cvmx_write_csr(CVMX_IOB_FAU_TIMEOUT, fau_to.u64);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		union cvmx_pko_reg_min_pkt min_pkt;
+
+		min_pkt.u64 = 0;
+		min_pkt.s.size1 = 59;
+		min_pkt.s.size2 = 59;
+		min_pkt.s.size3 = 59;
+		min_pkt.s.size4 = 59;
+		min_pkt.s.size5 = 59;
+		min_pkt.s.size6 = 59;
+		min_pkt.s.size7 = 59;
+		cvmx_write_csr(CVMX_PKO_REG_MIN_PKT, min_pkt.u64);
+	}
+
 	return 0;
 }
 
@@ -506,9 +845,12 @@ static int __cvmx_helper_global_setup_backpressure(void)
 		switch (cvmx_helper_interface_get_mode(interface)) {
 		case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 		case CVMX_HELPER_INTERFACE_MODE_PCIE:
+		case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		case CVMX_HELPER_INTERFACE_MODE_ILK:
 		case CVMX_HELPER_INTERFACE_MODE_NPI:
 		case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			break;
 		case CVMX_HELPER_INTERFACE_MODE_RGMII:
 		case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -519,12 +861,121 @@ static int __cvmx_helper_global_setup_backpressure(void)
 			break;
 		}
 	}
+	/* cvmx_dprintf("Disabling backpressure\n"); */
 #endif
 
 	return 0;
 }
 
 /**
+ * Verify the per port IPD backpressure is aligned properly.
+ * Returns Zero if working, non zero if misaligned
+ */
+int __cvmx_helper_backpressure_is_misaligned(void)
+{
+	uint64_t ipd_int_enb;
+	union cvmx_ipd_ctl_status ipd_reg;
+	uint64_t bp_status0;
+	uint64_t bp_status1;
+	const int port0 = 0;
+	const int port1 = 16;
+	cvmx_helper_interface_mode_t mode0 = cvmx_helper_interface_get_mode(0);
+	cvmx_helper_interface_mode_t mode1 = cvmx_helper_interface_get_mode(1);
+
+	/* Disable error interrupts while we check backpressure */
+	ipd_int_enb = cvmx_read_csr(CVMX_IPD_INT_ENB);
+	cvmx_write_csr(CVMX_IPD_INT_ENB, 0);
+
+	/* Enable per port backpressure */
+	ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_reg.s.pbp_en = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_reg.u64);
+
+	if (mode0 != CVMX_HELPER_INTERFACE_MODE_DISABLED) {
+		/* Enable backpressure for port with a zero threshold */
+		cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port0), 1 << 17);
+		/* Add 1000 to the page count to simulate packets coming in */
+		cvmx_write_csr(CVMX_IPD_SUB_PORT_BP_PAGE_CNT,
+			       (port0 << 25) | 1000);
+	}
+
+	if (mode1 != CVMX_HELPER_INTERFACE_MODE_DISABLED) {
+		/* Enable backpressure for port with a zero threshold */
+		cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port1), 1 << 17);
+		/* Add 1000 to the page count to simulate packets coming in */
+		cvmx_write_csr(CVMX_IPD_SUB_PORT_BP_PAGE_CNT,
+			       (port1 << 25) | 1000);
+	}
+
+	/* Wait 500 cycles for the BP to update */
+	cvmx_wait(500);
+
+	/* Read the BP state from the debug select register */
+	switch (mode0) {
+	case CVMX_HELPER_INTERFACE_MODE_SPI:
+		cvmx_write_csr(CVMX_NPI_DBG_SELECT, 0x9004);
+		bp_status0 = cvmx_read_csr(CVMX_DBG_DATA);
+		bp_status0 = 0xffff & ~bp_status0;
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_RGMII:
+	case CVMX_HELPER_INTERFACE_MODE_GMII:
+		cvmx_write_csr(CVMX_NPI_DBG_SELECT, 0x0e00);
+		bp_status0 = 0xffff & cvmx_read_csr(CVMX_DBG_DATA);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+	case CVMX_HELPER_INTERFACE_MODE_PICMG:
+		cvmx_write_csr(CVMX_PEXP_NPEI_DBG_SELECT, 0x0e00);
+		bp_status0 = 0xffff & cvmx_read_csr(CVMX_PEXP_NPEI_DBG_DATA);
+		break;
+	default:
+		bp_status0 = 1 << port0;
+		break;
+	}
+
+	/* Read the BP state from the debug select register */
+	switch (mode1) {
+	case CVMX_HELPER_INTERFACE_MODE_SPI:
+		cvmx_write_csr(CVMX_NPI_DBG_SELECT, 0x9804);
+		bp_status1 = cvmx_read_csr(CVMX_DBG_DATA);
+		bp_status1 = 0xffff & ~bp_status1;
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_RGMII:
+	case CVMX_HELPER_INTERFACE_MODE_GMII:
+		cvmx_write_csr(CVMX_NPI_DBG_SELECT, 0x1600);
+		bp_status1 = 0xffff & cvmx_read_csr(CVMX_DBG_DATA);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+	case CVMX_HELPER_INTERFACE_MODE_PICMG:
+		cvmx_write_csr(CVMX_PEXP_NPEI_DBG_SELECT, 0x1600);
+		bp_status1 = 0xffff & cvmx_read_csr(CVMX_PEXP_NPEI_DBG_DATA);
+		break;
+	default:
+		bp_status1 = 1 << (port1 - 16);
+		break;
+	}
+
+	if (mode0 != CVMX_HELPER_INTERFACE_MODE_DISABLED) {
+		/* Shutdown BP */
+		cvmx_write_csr(CVMX_IPD_SUB_PORT_BP_PAGE_CNT, (port0 << 25) | (0x1ffffff & -1000));
+		cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port0), 0);
+	}
+
+	if (mode1 != CVMX_HELPER_INTERFACE_MODE_DISABLED) {
+		/* Shutdown BP */
+		cvmx_write_csr(CVMX_IPD_SUB_PORT_BP_PAGE_CNT, (port1 << 25) | (0x1ffffff & -1000));
+		cvmx_write_csr(CVMX_IPD_PORTX_BP_PAGE_CNT(port1), 0);
+	}
+
+	/* Clear any error interrupts that might have been set */
+	cvmx_write_csr(CVMX_IPD_INT_SUM, 0x1f);
+	cvmx_write_csr(CVMX_IPD_INT_ENB, ipd_int_enb);
+
+	return (bp_status0 != (1ull << port0)) || (bp_status1 != (1ull << (port1 - 16)));
+}
+
+/**
  * Enable packet input/output from the hardware. This function is
  * called after all internal setup is complete and IPD is enabled.
  * After this function completes, packets will be accepted from the
@@ -542,15 +993,17 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 		/* These types don't support ports to IPD/PKO */
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		/* Nothing to do */
 		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_enable(interface);
 		break;
 		/*
 		 * RGMII/GMII/MII are all treated about the same. Most
-		 * functions refer to these ports as RGMII
+		 * functions refer to these ports as RGMII.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_RGMII:
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -558,14 +1011,14 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 		break;
 		/*
 		 * SPI4 can have 1-16 ports depending on the device at
-		 * the other end
+		 * the other end.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
 		result = __cvmx_helper_spi_enable(interface);
 		break;
 		/*
 		 * SGMII can have 1-4 ports depending on how many are
-		 * hooked up
+		 * hooked up.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
@@ -575,12 +1028,12 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 		result = __cvmx_helper_npi_enable(interface);
 		break;
-		/*
-		 * Special loopback only ports. These are not the same
-		 * as other ports in loopback mode
-		 */
-	case CVMX_HELPER_INTERFACE_MODE_LOOP:
-		result = __cvmx_helper_loop_enable(interface);
+		/* SRIO has 2^N ports, where N is number of interfaces */
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_enable(interface);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		result = __cvmx_helper_ilk_enable(interface);
 		break;
 	}
 	result |= __cvmx_helper_board_hardware_enable(interface);
@@ -588,210 +1041,6 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 }
 
 /**
- * Function to adjust internal IPD pointer alignments
- *
- * Returns 0 on success
- *         !0 on failure
- */
-int __cvmx_helper_errata_fix_ipd_ptr_alignment(void)
-{
-#define FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES \
-     (CVMX_FPA_PACKET_POOL_SIZE-8-CVMX_HELPER_FIRST_MBUFF_SKIP)
-#define FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES \
-	(CVMX_FPA_PACKET_POOL_SIZE-8-CVMX_HELPER_NOT_FIRST_MBUFF_SKIP)
-#define FIX_IPD_OUTPORT 0
-	/* Ports 0-15 are interface 0, 16-31 are interface 1 */
-#define INTERFACE(port) (port >> 4)
-#define INDEX(port) (port & 0xf)
-	uint64_t *p64;
-	cvmx_pko_command_word0_t pko_command;
-	union cvmx_buf_ptr g_buffer, pkt_buffer;
-	cvmx_wqe_t *work;
-	int size, num_segs = 0, wqe_pcnt, pkt_pcnt;
-	union cvmx_gmxx_prtx_cfg gmx_cfg;
-	int retry_cnt;
-	int retry_loop_cnt;
-	int i;
-	cvmx_helper_link_info_t link_info;
-
-	/* Save values for restore at end */
-	uint64_t prtx_cfg =
-	    cvmx_read_csr(CVMX_GMXX_PRTX_CFG
-			  (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
-	uint64_t tx_ptr_en =
-	    cvmx_read_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)));
-	uint64_t rx_ptr_en =
-	    cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)));
-	uint64_t rxx_jabber =
-	    cvmx_read_csr(CVMX_GMXX_RXX_JABBER
-			  (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
-	uint64_t frame_max =
-	    cvmx_read_csr(CVMX_GMXX_RXX_FRM_MAX
-			  (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)));
-
-	/* Configure port to gig FDX as required for loopback mode */
-	cvmx_helper_rgmii_internal_loopback(FIX_IPD_OUTPORT);
-
-	/*
-	 * Disable reception on all ports so if traffic is present it
-	 * will not interfere.
-	 */
-	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)), 0);
-
-	cvmx_wait(100000000ull);
-
-	for (retry_loop_cnt = 0; retry_loop_cnt < 10; retry_loop_cnt++) {
-		retry_cnt = 100000;
-		wqe_pcnt = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
-		pkt_pcnt = (wqe_pcnt >> 7) & 0x7f;
-		wqe_pcnt &= 0x7f;
-
-		num_segs = (2 + pkt_pcnt - wqe_pcnt) & 3;
-
-		if (num_segs == 0)
-			goto fix_ipd_exit;
-
-		num_segs += 1;
-
-		size =
-		    FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES +
-		    ((num_segs - 1) * FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES) -
-		    (FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES / 2);
-
-		cvmx_write_csr(CVMX_ASXX_PRT_LOOP(INTERFACE(FIX_IPD_OUTPORT)),
-			       1 << INDEX(FIX_IPD_OUTPORT));
-		CVMX_SYNC;
-
-		g_buffer.u64 = 0;
-		g_buffer.s.addr =
-		    cvmx_ptr_to_phys(cvmx_fpa_alloc(CVMX_FPA_WQE_POOL));
-		if (g_buffer.s.addr == 0) {
-			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT "
-				     "buffer allocation failure.\n");
-			goto fix_ipd_exit;
-		}
-
-		g_buffer.s.pool = CVMX_FPA_WQE_POOL;
-		g_buffer.s.size = num_segs;
-
-		pkt_buffer.u64 = 0;
-		pkt_buffer.s.addr =
-		    cvmx_ptr_to_phys(cvmx_fpa_alloc(CVMX_FPA_PACKET_POOL));
-		if (pkt_buffer.s.addr == 0) {
-			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT "
-				     "buffer allocation failure.\n");
-			goto fix_ipd_exit;
-		}
-		pkt_buffer.s.i = 1;
-		pkt_buffer.s.pool = CVMX_FPA_PACKET_POOL;
-		pkt_buffer.s.size = FIX_IPD_FIRST_BUFF_PAYLOAD_BYTES;
-
-		p64 = (uint64_t *) cvmx_phys_to_ptr(pkt_buffer.s.addr);
-		p64[0] = 0xffffffffffff0000ull;
-		p64[1] = 0x08004510ull;
-		p64[2] = ((uint64_t) (size - 14) << 48) | 0x5ae740004000ull;
-		p64[3] = 0x3a5fc0a81073c0a8ull;
-
-		for (i = 0; i < num_segs; i++) {
-			if (i > 0)
-				pkt_buffer.s.size =
-				    FIX_IPD_NON_FIRST_BUFF_PAYLOAD_BYTES;
-
-			if (i == (num_segs - 1))
-				pkt_buffer.s.i = 0;
-
-			*(uint64_t *) cvmx_phys_to_ptr(g_buffer.s.addr +
-						       8 * i) = pkt_buffer.u64;
-		}
-
-		/* Build the PKO command */
-		pko_command.u64 = 0;
-		pko_command.s.segs = num_segs;
-		pko_command.s.total_bytes = size;
-		pko_command.s.dontfree = 0;
-		pko_command.s.gather = 1;
-
-		gmx_cfg.u64 =
-		    cvmx_read_csr(CVMX_GMXX_PRTX_CFG
-				  (INDEX(FIX_IPD_OUTPORT),
-				   INTERFACE(FIX_IPD_OUTPORT)));
-		gmx_cfg.s.en = 1;
-		cvmx_write_csr(CVMX_GMXX_PRTX_CFG
-			       (INDEX(FIX_IPD_OUTPORT),
-				INTERFACE(FIX_IPD_OUTPORT)), gmx_cfg.u64);
-		cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)),
-			       1 << INDEX(FIX_IPD_OUTPORT));
-		cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)),
-			       1 << INDEX(FIX_IPD_OUTPORT));
-
-		cvmx_write_csr(CVMX_GMXX_RXX_JABBER
-			       (INDEX(FIX_IPD_OUTPORT),
-				INTERFACE(FIX_IPD_OUTPORT)), 65392 - 14 - 4);
-		cvmx_write_csr(CVMX_GMXX_RXX_FRM_MAX
-			       (INDEX(FIX_IPD_OUTPORT),
-				INTERFACE(FIX_IPD_OUTPORT)), 65392 - 14 - 4);
-
-		cvmx_pko_send_packet_prepare(FIX_IPD_OUTPORT,
-					     cvmx_pko_get_base_queue
-					     (FIX_IPD_OUTPORT),
-					     CVMX_PKO_LOCK_CMD_QUEUE);
-		cvmx_pko_send_packet_finish(FIX_IPD_OUTPORT,
-					    cvmx_pko_get_base_queue
-					    (FIX_IPD_OUTPORT), pko_command,
-					    g_buffer, CVMX_PKO_LOCK_CMD_QUEUE);
-
-		CVMX_SYNC;
-
-		do {
-			work = cvmx_pow_work_request_sync(CVMX_POW_WAIT);
-			retry_cnt--;
-		} while ((work == NULL) && (retry_cnt > 0));
-
-		if (!retry_cnt)
-			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT "
-				     "get_work() timeout occurred.\n");
-
-		/* Free packet */
-		if (work)
-			cvmx_helper_free_packet_data(work);
-	}
-
-fix_ipd_exit:
-
-	/* Return CSR configs to saved values */
-	cvmx_write_csr(CVMX_GMXX_PRTX_CFG
-		       (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)),
-		       prtx_cfg);
-	cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)),
-		       tx_ptr_en);
-	cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(INTERFACE(FIX_IPD_OUTPORT)),
-		       rx_ptr_en);
-	cvmx_write_csr(CVMX_GMXX_RXX_JABBER
-		       (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)),
-		       rxx_jabber);
-	cvmx_write_csr(CVMX_GMXX_RXX_FRM_MAX
-		       (INDEX(FIX_IPD_OUTPORT), INTERFACE(FIX_IPD_OUTPORT)),
-		       frame_max);
-	cvmx_write_csr(CVMX_ASXX_PRT_LOOP(INTERFACE(FIX_IPD_OUTPORT)), 0);
-	/* Set link to down so autonegotiation will set it up again */
-	link_info.u64 = 0;
-	cvmx_helper_link_set(FIX_IPD_OUTPORT, link_info);
-
-	/*
-	 * Bring the link back up as autonegotiation is not done in
-	 * user applications.
-	 */
-	cvmx_helper_link_autoconf(FIX_IPD_OUTPORT);
-
-	CVMX_SYNC;
-	if (num_segs)
-		cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT failed.\n");
-
-	return !!num_segs;
-
-}
-
-/**
  * Called after all internal packet IO paths are setup. This
  * function enables IPD/PIP and begins packet input and output.
  *
@@ -808,7 +1057,7 @@ int cvmx_helper_ipd_and_packet_input_enable(void)
 	/*
 	 * Time to enable hardware ports packet input and output. Note
 	 * that at this point IPD/PIP must be fully functional and PKO
-	 * must be disabled
+	 * must be disabled .
 	 */
 	num_interfaces = cvmx_helper_get_number_of_interfaces();
 	for (interface = 0; interface < num_interfaces; interface++) {
@@ -819,12 +1068,13 @@ int cvmx_helper_ipd_and_packet_input_enable(void)
 	/* Finally enable PKO now that the entire path is up and running */
 	cvmx_pko_enable();
 
-	if ((OCTEON_IS_MODEL(OCTEON_CN31XX_PASS1)
-	     || OCTEON_IS_MODEL(OCTEON_CN30XX_PASS1))
-	    && (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM))
+	if ((OCTEON_IS_MODEL(OCTEON_CN31XX_PASS1) ||
+	     OCTEON_IS_MODEL(OCTEON_CN30XX_PASS1)) &&
+	    (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM))
 		__cvmx_helper_errata_fix_ipd_ptr_alignment();
 	return 0;
 }
+EXPORT_SYMBOL(cvmx_helper_ipd_and_packet_input_enable);
 
 /**
  * Initialize the PIP, IPD, and PKO hardware to support
@@ -840,7 +1090,6 @@ int cvmx_helper_initialize_packet_io_global(void)
 	int result = 0;
 	int interface;
 	union cvmx_l2c_cfg l2c_cfg;
-	union cvmx_smix_en smix_en;
 	const int num_interfaces = cvmx_helper_get_number_of_interfaces();
 
 	/*
@@ -855,41 +1104,35 @@ int cvmx_helper_initialize_packet_io_global(void)
 	 * to the cores. This avoids conditions where IO blocks might
 	 * be starved under very high L2 loads.
 	 */
-	l2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);
-	l2c_cfg.s.lrf_arb_mode = 0;
-	l2c_cfg.s.rfb_arb_mode = 0;
-	cvmx_write_csr(CVMX_L2C_CFG, l2c_cfg.u64);
-
-	/* Make sure SMI/MDIO is enabled so we can query PHYs */
-	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
-	if (!smix_en.s.en) {
-		smix_en.s.en = 1;
-		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
+		union cvmx_l2c_ctl l2c_ctl;
+		l2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);
+		l2c_ctl.s.rsp_arb_mode = 1;
+		l2c_ctl.s.xmc_arb_mode = 0;
+		cvmx_write_csr(CVMX_L2C_CTL, l2c_ctl.u64);
+	} else {
+		l2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);
+		l2c_cfg.s.lrf_arb_mode = 0;
+		l2c_cfg.s.rfb_arb_mode = 0;
+		cvmx_write_csr(CVMX_L2C_CFG, l2c_cfg.u64);
 	}
 
-	/* Newer chips actually have two SMI/MDIO interfaces */
-	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN58XX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
-		if (!smix_en.s.en) {
-			smix_en.s.en = 1;
-			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
-		}
-	}
+
+	__cvmx_helper_cfg_init();
+
+	for (interface = 0; interface < num_interfaces; interface++)
+		result |= cvmx_helper_interface_probe(interface);
 
 	cvmx_pko_initialize_global();
 	for (interface = 0; interface < num_interfaces; interface++) {
-		result |= cvmx_helper_interface_probe(interface);
 		if (cvmx_helper_ports_on_interface(interface) > 0)
 			cvmx_dprintf("Interface %d has %d ports (%s)\n",
 				     interface,
 				     cvmx_helper_ports_on_interface(interface),
-				     cvmx_helper_interface_mode_to_string
-				     (cvmx_helper_interface_get_mode
-				      (interface)));
+				     cvmx_helper_interface_mode_to_string(cvmx_helper_interface_get_mode(interface)));
 		result |= __cvmx_helper_interface_setup_ipd(interface);
-		result |= __cvmx_helper_interface_setup_pko(interface);
+		if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
+			result |= __cvmx_helper_interface_setup_pko(interface);
 	}
 
 	result |= __cvmx_helper_global_setup_ipd();
@@ -903,6 +1146,7 @@ int cvmx_helper_initialize_packet_io_global(void)
 #endif
 	return result;
 }
+EXPORT_SYMBOL(cvmx_helper_initialize_packet_io_global);
 
 /**
  * Does core local initialization for packet io
@@ -915,6 +1159,430 @@ int cvmx_helper_initialize_packet_io_local(void)
 }
 
 /**
+ * wait for the pko queue to drain
+ *
+ * @queue: a valid pko queue
+ * Returns count is the length of the queue after calling this
+ * function
+ */
+static int cvmx_helper_wait_pko_queue_drain(int queue)
+{
+	const int timeout = 5;	/* Wait up to 5 seconds for timeouts */
+	int count;
+	uint64_t start_cycle, stop_cycle;
+
+	count = cvmx_cmd_queue_length(CVMX_CMD_QUEUE_PKO(queue));
+	start_cycle = cvmx_get_cycle();
+	stop_cycle = start_cycle + octeon_get_clock_rate() * timeout;
+	while (count && (cvmx_get_cycle() < stop_cycle)) {
+		cvmx_wait(10000);
+		count = cvmx_cmd_queue_length(CVMX_CMD_QUEUE_PKO(queue));
+	}
+
+	return count;
+}
+
+struct cvmx_buffer_list {
+	struct cvmx_buffer_list *next;
+};
+
+/**
+ * Disables the sending of flow control (pause) frames on the specified
+ * RGMII port(s).
+ *
+ * @interface: Which interface (0 or 1)
+ * @port_mask: Mask (4bits) of which ports on the interface to disable
+ *                  backpressure on.
+ *                  1 => disable backpressure
+ *                  0 => enable backpressure
+ *
+ * Returns 0 on success
+ *         -1 on error
+ */
+int cvmx_gmx_set_backpressure_override(uint32_t interface, uint32_t port_mask)
+{
+	union cvmx_gmxx_tx_ovr_bp gmxx_tx_ovr_bp;
+	/* Check for valid arguments */
+	if (port_mask & ~0xf || interface & ~0x1)
+		return -1;
+	gmxx_tx_ovr_bp.u64 = 0;
+	/* Per port Enable back pressure override */
+	gmxx_tx_ovr_bp.s.en = port_mask;
+	/* Ignore the RX FIFO full when computing BP */
+	gmxx_tx_ovr_bp.s.ign_full = port_mask;
+	cvmx_write_csr(CVMX_GMXX_TX_OVR_BP(interface), gmxx_tx_ovr_bp.u64);
+	return 0;
+
+}
+
+/**
+ * Undo the initialization performed in
+ * cvmx_helper_initialize_packet_io_global(). After calling this routine and the
+ * local version on each core, packet IO for Octeon will be disabled and placed
+ * in the initial reset state. It will then be safe to call the initialize
+ * later on. Note that this routine does not empty the FPA pools. It frees all
+ * buffers used by the packet IO hardware to the FPA so a function emptying the
+ * FPA after shutdown should find all packet buffers in the FPA.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_helper_shutdown_packet_io_global(void)
+{
+	const int timeout = 5;	/* Wait up to 5 seconds for timeouts */
+	int result = 0;
+	int num_interfaces;
+	int interface;
+	int num_ports;
+	int index;
+	struct cvmx_buffer_list *pool0_buffers;
+	struct cvmx_buffer_list *pool0_buffers_tail;
+	cvmx_wqe_t *work;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+
+	/* Step 1: Disable all backpressure */
+	for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++)
+		if (cvmx_helper_interface_get_mode(interface) != CVMX_HELPER_INTERFACE_MODE_DISABLED)
+			cvmx_gmx_set_backpressure_override(interface, 0xf);
+
+step2:
+	/* Step 2: Wait for the PKO queues to drain */
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		int queue, max_queue;
+
+		max_queue = __cvmx_helper_cfg_pko_max_queue();
+		for (queue = 0; queue < max_queue; queue++) {
+			if (cvmx_helper_wait_pko_queue_drain(queue)) {
+				result = -1;
+				goto step3;
+			}
+		}
+	} else {
+		num_interfaces = cvmx_helper_get_number_of_interfaces();
+		for (interface = 0; interface < num_interfaces; interface++) {
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			for (index = 0; index < num_ports; index++) {
+				int pko_port = cvmx_helper_get_ipd_port(interface, index);
+				int queue = cvmx_pko_get_base_queue(pko_port);
+				int max_queue = queue + cvmx_pko_get_num_queues(pko_port);
+				while (queue < max_queue) {
+					if (cvmx_helper_wait_pko_queue_drain(queue)) {
+						result = -1;
+						goto step3;
+					}
+					queue++;
+				}
+			}
+		}
+	}
+
+step3:
+	/* Step 3: Disable TX and RX on all ports */
+	for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++) {
+		switch (cvmx_helper_interface_get_mode(interface)) {
+		case CVMX_HELPER_INTERFACE_MODE_DISABLED:
+		case CVMX_HELPER_INTERFACE_MODE_PCIE:
+			/* Not a packet interface */
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_NPI:
+		case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		case CVMX_HELPER_INTERFACE_MODE_ILK:
+			/*
+			 * We don't handle the NPI/NPEI/SRIO packet
+			 * engines. The caller must know these are
+			 * idle.
+			 */
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_LOOP:
+			/*
+			 * Nothing needed. Once PKO is idle, the
+			 * loopback devices must be idle.
+			 */
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_SPI:
+			/*
+			 * SPI cannot be disabled from Octeon. It is
+			 * the responsibility of the caller to make
+			 * sure SPI is idle before doing shutdown.
+			 *
+			 * Fall through and do the same processing as
+			 * RGMII/GMII.
+			 */
+		case CVMX_HELPER_INTERFACE_MODE_GMII:
+		case CVMX_HELPER_INTERFACE_MODE_RGMII:
+			/* Disable outermost RX at the ASX block */
+			cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), 0);
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			if (num_ports > 4)
+				num_ports = 4;
+			for (index = 0; index < num_ports; index++) {
+				union cvmx_gmxx_prtx_cfg gmx_cfg;
+				gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+				gmx_cfg.s.en = 0;
+				cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);
+				/* Poll the GMX state machine waiting for it to become idle */
+				cvmx_write_csr(CVMX_NPI_DBG_SELECT, interface * 0x800 + index * 0x100 + 0x880);
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data,
+							  data & 7, ==, 0, timeout * 1000000)) {
+					cvmx_dprintf("GMX RX path timeout waiting for idle\n");
+					result = -1;
+				}
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data,
+							  data & 0xf, ==, 0, timeout * 1000000)) {
+					cvmx_dprintf("GMX TX path timeout waiting for idle\n");
+					result = -1;
+				}
+			}
+			/* Disable outermost TX at the ASX block */
+			cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), 0);
+			/* Disable interrupts for interface */
+			cvmx_write_csr(CVMX_ASXX_INT_EN(interface), 0);
+			cvmx_write_csr(CVMX_GMXX_TX_INT_EN(interface), 0);
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		case CVMX_HELPER_INTERFACE_MODE_PICMG:
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			if (num_ports > 4)
+				num_ports = 4;
+			for (index = 0; index < num_ports; index++) {
+				union cvmx_gmxx_prtx_cfg gmx_cfg;
+				gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+				gmx_cfg.s.en = 0;
+				cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(index, interface),
+							  union cvmx_gmxx_prtx_cfg, rx_idle, ==, 1, timeout * 1000000)) {
+					cvmx_dprintf("GMX RX path timeout waiting for idle\n");
+					result = -1;
+				}
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_GMXX_PRTX_CFG(index, interface),
+							  union cvmx_gmxx_prtx_cfg, tx_idle, ==, 1, timeout * 1000000)) {
+					cvmx_dprintf("GMX TX path timeout waiting for idle\n");
+					result = -1;
+				}
+			}
+			break;
+		}
+	}
+
+	/* Step 4: Retrieve all packets from the POW and free them */
+	while ((work = cvmx_pow_work_request_sync(CVMX_POW_WAIT))) {
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* Step 4b: Special workaround for pass 2 errata */
+	if (OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2)) {
+		union cvmx_ipd_ptr_count ipd_cnt;
+		int to_add;
+		ipd_cnt.u64 = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
+		to_add = (ipd_cnt.s.wqev_cnt + ipd_cnt.s.wqe_pcnt) & 0x7;
+		if (to_add) {
+			int port = -1;
+			cvmx_dprintf("Aligning CN38XX pass 2 IPD counters\n");
+			if (cvmx_helper_interface_get_mode(0) == CVMX_HELPER_INTERFACE_MODE_RGMII)
+				port = 0;
+			else if (cvmx_helper_interface_get_mode(1) == CVMX_HELPER_INTERFACE_MODE_RGMII)
+				port = 16;
+
+			if (port != -1) {
+				void *buffer = cvmx_fpa_alloc(CVMX_FPA_PACKET_POOL);
+				if (buffer) {
+					int queue = cvmx_pko_get_base_queue(port);
+					cvmx_pko_command_word0_t pko_command;
+					union cvmx_buf_ptr packet;
+					uint64_t start_cycle;
+					uint64_t stop_cycle;
+
+					/* Populate a minimal packet */
+					memset(buffer, 0xff, 6);
+					memset(buffer + 6, 0, 54);
+					pko_command.u64 = 0;
+					pko_command.s.dontfree = 1;
+					pko_command.s.total_bytes = 60;
+					pko_command.s.segs = 1;
+					packet.u64 = 0;
+					packet.s.addr = cvmx_ptr_to_phys(buffer);
+					packet.s.size = CVMX_FPA_PACKET_POOL_SIZE;
+					__cvmx_helper_rgmii_configure_loopback(port, 1, 0);
+					while (to_add--) {
+						cvmx_pko_send_packet_prepare(port, queue, CVMX_PKO_LOCK_CMD_QUEUE);
+						if (cvmx_pko_send_packet_finish(port, queue, pko_command, packet, CVMX_PKO_LOCK_CMD_QUEUE)) {
+							cvmx_dprintf("ERROR: Unable to align IPD counters (PKO failed)\n");
+							break;
+						}
+					}
+					cvmx_fpa_free(buffer, CVMX_FPA_PACKET_POOL, 0);
+
+					/* Wait for the packets to loop back */
+					start_cycle = cvmx_get_cycle();
+					stop_cycle = start_cycle + octeon_get_clock_rate() * timeout;
+					while (cvmx_cmd_queue_length(CVMX_CMD_QUEUE_PKO(queue)) && (cvmx_get_cycle() < stop_cycle))
+						cvmx_wait(1000);
+
+					cvmx_wait(1000);
+					__cvmx_helper_rgmii_configure_loopback(port, 0, 0);
+					if (to_add == -1)
+						goto step2;
+				} else {
+					cvmx_dprintf("ERROR: Unable to align IPD counters (Packet pool empty)\n");
+				}
+			} else {
+				cvmx_dprintf("ERROR: Unable to align IPD counters\n");
+			}
+		}
+	}
+
+	/* Step 5 */
+	cvmx_ipd_disable();
+
+	/* Step 6: Drain all prefetched buffers from IPD/PIP. Note that IPD/PIP
+	   have not been reset yet */
+	__cvmx_ipd_free_ptr();
+
+	/* Step 7: Free the PKO command buffers and put PKO in reset */
+	cvmx_pko_shutdown();
+
+	/* Step 8: Disable MAC address filtering */
+	for (interface = 0; interface < CVMX_HELPER_MAX_GMX; interface++) {
+		switch (cvmx_helper_interface_get_mode(interface)) {
+		case CVMX_HELPER_INTERFACE_MODE_DISABLED:
+		case CVMX_HELPER_INTERFACE_MODE_PCIE:
+		case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		case CVMX_HELPER_INTERFACE_MODE_ILK:
+		case CVMX_HELPER_INTERFACE_MODE_NPI:
+		case CVMX_HELPER_INTERFACE_MODE_LOOP:
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		case CVMX_HELPER_INTERFACE_MODE_GMII:
+		case CVMX_HELPER_INTERFACE_MODE_RGMII:
+		case CVMX_HELPER_INTERFACE_MODE_SPI:
+		case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		case CVMX_HELPER_INTERFACE_MODE_PICMG:
+			num_ports = cvmx_helper_ports_on_interface(interface);
+			if (num_ports > 4)
+				num_ports = 4;
+			for (index = 0; index < num_ports; index++) {
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CTL(index, interface), 1);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM_EN(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM0(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM1(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM2(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM3(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM4(index, interface), 0);
+				cvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM5(index, interface), 0);
+			}
+			break;
+		}
+	}
+
+	/*
+	 * Step 9: Drain all FPA buffers out of pool 0 before we reset
+	 * IPD/PIP.  This is needed to keep IPD_QUE0_FREE_PAGE_CNT in
+	 * sync. We temporarily keep the buffers in the pool0_buffers
+	 * list.
+	 */
+	pool0_buffers = NULL;
+	pool0_buffers_tail = NULL;
+	while (1) {
+		struct cvmx_buffer_list *buffer = cvmx_fpa_alloc(0);
+		if (buffer) {
+			buffer->next = NULL;
+
+			if (pool0_buffers == NULL)
+				pool0_buffers = buffer;
+			else
+				pool0_buffers_tail->next = buffer;
+
+			pool0_buffers_tail = buffer;
+		} else {
+			break;
+		}
+	}
+
+	/* Step 10: Reset IPD and PIP */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.reset = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
+	    (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
+	     OCTEON_IS_MODEL(OCTEON_CN5XXX))) {
+		/*
+		 * only try 1000 times.  Normally if this works it
+		 * will happen in the first 50 loops.
+		 */
+		int max_loops = 1000;
+		int loop = 0;
+		/*
+		 * Per port backpressure counters can get misaligned
+		 * after an IPD reset. This code realigns them by
+		 * performing repeated resets. See IPD-13473.
+		 */
+		cvmx_wait(100);
+		if (__cvmx_helper_backpressure_is_misaligned()) {
+			cvmx_dprintf("Starting to align per port backpressure counters.\n");
+			while (__cvmx_helper_backpressure_is_misaligned() &&
+			       (loop++ < max_loops)) {
+				cvmx_write_csr(CVMX_IPD_CTL_STATUS,
+					       ipd_ctl_status.u64);
+				cvmx_wait(123);
+			}
+			if (loop < max_loops)
+				cvmx_dprintf("Completed aligning per port backpressure counters (%d loops).\n", loop);
+			else
+				cvmx_dprintf("ERROR: unable to align per port backpressure counters.\n");
+			/* For now, don't hang.... */
+		}
+	}
+
+	/* PIP_SFT_RST not present in CN38XXp{1,2} */
+	if (!OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2)) {
+		union cvmx_pip_sft_rst pip_sft_rst;
+		pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
+		pip_sft_rst.s.rst = 1;
+		cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
+	}
+
+	/* Make sure IPD has finished reset. */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		if (CVMX_WAIT_FOR_FIELD64(CVMX_IPD_CTL_STATUS,
+					  union cvmx_ipd_ctl_status, rst_done, ==, 0, 1000)) {
+			cvmx_dprintf("IPD reset timeout waiting for idle\n");
+			result = -1;
+		}
+	}
+
+	/* Step 11: Restore the FPA buffers into pool 0 */
+	while (pool0_buffers) {
+		struct cvmx_buffer_list *n = pool0_buffers->next;
+		cvmx_fpa_free(pool0_buffers, 0, 0);
+		pool0_buffers = n;
+	}
+
+	/* Step 12: Release interface structures */
+	__cvmx_helper_shutdown_interfaces();
+
+	return result;
+}
+EXPORT_SYMBOL(cvmx_helper_shutdown_packet_io_global);
+
+/**
+ * Does core local shutdown of packet io
+ *
+ * Returns Zero on success, non-zero on failure
+ */
+int cvmx_helper_shutdown_packet_io_local(void)
+{
+	/*
+	 * Currently there is nothing to do per core. This may change
+	 * in the future.
+	 */
+	return 0;
+}
+
+/**
  * Auto configure an IPD/PKO port link state and speed. This
  * function basically does the equivalent of:
  * cvmx_helper_link_set(ipd_port, cvmx_helper_link_get(ipd_port));
@@ -929,24 +1597,24 @@ cvmx_helper_link_info_t cvmx_helper_link_autoconf(int ipd_port)
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 
-	if (index >= cvmx_helper_ports_on_interface(interface)) {
+	if (interface == -1 || index == -1 ||
+	    index >= cvmx_helper_ports_on_interface(interface)) {
 		link_info.u64 = 0;
 		return link_info;
 	}
 
 	link_info = cvmx_helper_link_get(ipd_port);
-	if (link_info.u64 == port_link_info[ipd_port].u64)
+	if (link_info.u64 == (__cvmx_helper_get_link_info(interface, index)).u64)
 		return link_info;
 
+
 	/* If we fail to set the link speed, port_link_info will not change */
 	cvmx_helper_link_set(ipd_port, link_info);
 
-	/*
-	 * port_link_info should be the current value, which will be
-	 * different than expect if cvmx_helper_link_set() failed.
-	 */
-	return port_link_info[ipd_port];
+
+	return link_info;
 }
+EXPORT_SYMBOL(cvmx_helper_link_autoconf);
 
 /**
  * Return the link state of an IPD/PKO port as returned by
@@ -964,11 +1632,14 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 
-	/* The default result will be a down link unless the code below
-	   changes it */
+	/*
+	 * The default result will be a down link unless the code
+	 * below changes it.
+	 */
 	result.u64 = 0;
 
-	if (index >= cvmx_helper_ports_on_interface(interface))
+	if (interface == -1 || index == -1 ||
+	    index >= cvmx_helper_ports_on_interface(interface))
 		return result;
 
 	switch (cvmx_helper_interface_get_mode(interface)) {
@@ -977,6 +1648,7 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 		/* Network links are not supported */
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_link_get(ipd_port);
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -998,6 +1670,12 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
 		result = __cvmx_helper_sgmii_link_get(ipd_port);
 		break;
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_link_get(ipd_port);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		result = __cvmx_helper_ilk_link_get(ipd_port);
+		break;
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		/* Network links are not supported */
@@ -1005,6 +1683,7 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 	}
 	return result;
 }
+EXPORT_SYMBOL(cvmx_helper_link_get);
 
 /**
  * Configure an IPD/PKO port for the specified link state. This
@@ -1024,7 +1703,8 @@ int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 
-	if (index >= cvmx_helper_ports_on_interface(interface))
+	if (interface == -1 || index == -1 ||
+	    index >= cvmx_helper_ports_on_interface(interface))
 		return -1;
 
 	switch (cvmx_helper_interface_get_mode(interface)) {
@@ -1032,6 +1712,7 @@ int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_link_set(ipd_port, link_info);
 		break;
 		/*
@@ -1049,17 +1730,26 @@ int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
 		result = __cvmx_helper_sgmii_link_set(ipd_port, link_info);
 		break;
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_link_set(ipd_port, link_info);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
+		result = __cvmx_helper_ilk_link_set(ipd_port, link_info);
+		break;
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		break;
 	}
-	/* Set the port_link_info here so that the link status is updated
-	   no matter how cvmx_helper_link_set is called. We don't change
-	   the value if link_set failed */
+	/*
+	 * Set the port_link_info here so that the link status is
+	 * updated no matter how cvmx_helper_link_set is called. We
+	 * don't change the value if link_set failed.
+	 */
 	if (result == 0)
-		port_link_info[ipd_port].u64 = link_info.u64;
+		__cvmx_helper_set_link_info(interface, index, link_info);
 	return result;
 }
+EXPORT_SYMBOL(cvmx_helper_link_set);
 
 /**
  * Configure a port for internal and/or external loopback. Internal loopback
@@ -1087,30 +1777,31 @@ int cvmx_helper_configure_loopback(int ipd_port, int enable_internal,
 	switch (cvmx_helper_interface_get_mode(interface)) {
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+	case CVMX_HELPER_INTERFACE_MODE_ILK:
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		result =
-		    __cvmx_helper_xaui_configure_loopback(ipd_port,
-							  enable_internal,
-							  enable_external);
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		result = __cvmx_helper_xaui_configure_loopback(ipd_port,
+							       enable_internal,
+							       enable_external);
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_RGMII:
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
-		result =
-		    __cvmx_helper_rgmii_configure_loopback(ipd_port,
-							   enable_internal,
-							   enable_external);
+		result = __cvmx_helper_rgmii_configure_loopback(ipd_port,
+								enable_internal,
+								enable_external);
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
-		result =
-		    __cvmx_helper_sgmii_configure_loopback(ipd_port,
-							   enable_internal,
-							   enable_external);
+		result = __cvmx_helper_sgmii_configure_loopback(ipd_port,
+								enable_internal,
+								enable_external);
 		break;
 	}
 	return result;
 }
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
new file mode 100644
index 0000000..a498e2e
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
@@ -0,0 +1,1607 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2012 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Support library for the ILK
+ */
+#include <linux/export.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-sysinfo.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-ilk.h>
+#include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-ilk-defs.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-ilk.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+
+
+/*
+ * global configurations. to disable the 2nd ILK, set
+ * cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF] = {0xff, 0x0} and
+ * cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = {8, 0}
+ */
+unsigned char cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF] = { 0xf, 0xf0 };
+
+/* #define SINGLE_PORT_SIM_ILK */
+#ifdef SINGLE_PORT_SIM_ILK
+unsigned char cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = { 1, 1 };
+unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_MAX_ILK_CHANS] = {
+	{0}, {0}
+};
+#else /* sample case */
+unsigned char cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = {
+	CVMX_MAX_ILK_CHANS0, CVMX_MAX_ILK_CHANS1
+};
+
+unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_MAX_ILK_CHANS] = {
+	{0, 1, 2, 3, 4, 5, 6, 7},
+	{0, 1, 2, 3, 4, 5, 6, 7}
+};
+#endif
+
+/* Default callbacks, can be overridden
+ *  using cvmx_ilk_get_callbacks/cvmx_ilk_set_callbacks
+ */
+static struct cvmx_ilk_callbacks cvmx_ilk_callbacks = {
+	.calendar_setup_rx = cvmx_ilk_cal_setup_rx,
+};
+
+static struct cvmx_ilk_intf cvmx_ilk_intf_cfg[CVMX_NUM_ILK_INTF];
+
+/**
+ * User-overrideable callback function that returns whether or not an interface
+ * should use look-aside mode.
+ *
+ * @interface: - interface being checked
+ * @channel: - channel number, can be 0 or 1 or -1 to see if LA mode
+ *                  should be enabled for the interface.
+ * Returns 0 to not use LA-mode, 1 to use LA-mode.
+ */
+int cvmx_ilk_use_la_mode(int interface, int channel)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_0))
+		return 0;
+
+#ifdef CVMX_HELPER_ILK_LA_MODE_INTERFACE0
+	if (interface == 0)
+		return CVMX_HELPER_ILK_LA_MODE_INTERFACE0;
+#endif
+#ifdef CVMX_HELPER_ILK_LA_MODE_INTERFACE1
+	if (interface == 1)
+		return CVMX_HELPER_ILK_LA_MODE_INTERFACE1;
+#endif
+	return 0;
+}
+
+/**
+ * User-overrideable callback function that returns whether or not an interface
+ * in look-aside mode should enable the RX calendar.
+ *
+ * @interface: - interface to check
+ * Returns 1 to enable RX calendar, 0 to disable RX calendar.
+ *
+ * NOTE: For the CN68XX pass 2.0 this will enable the RX calendar for interface
+ * 0 and not interface 1.  It is up to the customer to override this behavior.
+ */
+int cvmx_ilk_la_mode_enable_rx_calendar(int interface)
+{
+	/* There is an errata in the CN68XX pass 2.0 where if connected
+	 * in a loopback configuration or back to back then only one interface
+	 * can have the RX calendar enabled.
+	 */
+	if (interface == 0)
+#ifdef CVMX_HELPER_ILK_LA_MODE_CAL_ENABLE_INTERFACE0
+		return CVMX_HELPER_ILK_LA_MODE_CAL_ENABLE_INTERFACE0;
+#else
+		return 0;
+#endif
+	else if (interface == 1)
+#ifdef CVMX_HELPER_ILK_LA_MODE_CAL_ENABLE_INTERFACE1
+		return CVMX_HELPER_ILK_LA_MODE_CAL_ENABLE_INTERFACE1;
+#else
+		return 0;
+#endif
+	else
+		return 0;	/* Invalid interface number */
+}
+
+/**
+ * Get current ILK initialization callbacks
+ *
+ * @callbacks:  Pointer to the callbacks structure.to fill
+ *
+ * Returns Pointer to cvmx_ilk_callbacks_t structure.
+ */
+void cvmx_ilk_get_callbacks(struct cvmx_ilk_callbacks *callbacks)
+{
+	memcpy(callbacks, &cvmx_ilk_callbacks, sizeof(cvmx_ilk_callbacks));
+}
+
+/**
+ * Set new ILK initialization callbacks
+ *
+ * @new_callbacks:  Pointer to an updated callbacks structure.
+ */
+void cvmx_ilk_set_callbacks(struct cvmx_ilk_callbacks *new_callbacks)
+{
+	memcpy(&cvmx_ilk_callbacks, new_callbacks, sizeof(cvmx_ilk_callbacks));
+}
+
+/**
+ * Initialize and start the ILK interface.
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @lane_mask: the lane group for this interface
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_start_interface(int interface, unsigned char lane_mask)
+{
+	int res = -1;
+	int other_intf, this_qlm, other_qlm;
+	unsigned char uni_mask;
+	union cvmx_mio_qlmx_cfg mio_qlmx_cfg, other_mio_qlmx_cfg;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+	union cvmx_ilk_ser_cfg ilk_ser_cfg;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (lane_mask == 0)
+		return res;
+
+	/*
+	 * check conflicts between 2 ilk interfaces. 1 lane can be
+	 * assigned to 1 interface only.
+	 */
+	other_intf = !interface;
+	this_qlm = interface + CVMX_ILK_QLM_BASE;
+	other_qlm = other_intf + CVMX_ILK_QLM_BASE;
+	if (cvmx_ilk_intf_cfg[other_intf].lane_en_mask & lane_mask) {
+		cvmx_dprintf("ILK%d: %s: lane assignment conflict\n",
+			     interface, __func__);
+		return res;
+	}
+
+	/*
+	 * check the legality of the lane mask. interface 0 can have 8 lanes,
+	 * while interface 1 can have 4 lanes at most.
+	 */
+	uni_mask = lane_mask >> (interface * 4);
+	if ((uni_mask != 0x1 && uni_mask != 0x3 &&
+	     uni_mask != 0xf && uni_mask != 0xff) ||
+	    (interface == 1 && lane_mask > 0xf0)) {
+		cvmx_dprintf("ILK%d: %s: incorrect lane mask: 0x%x\n",
+			     interface, __func__, uni_mask);
+		return res;
+	}
+
+	/*
+	 * check the availability of qlms. qlm_cfg = 001 means the
+	 * chip is fused to give this qlm to ilk.
+	 */
+	mio_qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(this_qlm));
+	other_mio_qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(other_qlm));
+	if (mio_qlmx_cfg.s.qlm_cfg != 1 ||
+	    (uni_mask == 0xff && other_mio_qlmx_cfg.s.qlm_cfg != 1)) {
+		cvmx_dprintf("ILK%d: %s: qlm unavailable\n",
+			     interface, __func__);
+		return res;
+	}
+
+	/* power up the serdes */
+	ilk_ser_cfg.u64 = cvmx_read_csr(CVMX_ILK_SER_CFG);
+	if (ilk_ser_cfg.s.ser_pwrup == 0) {
+		ilk_ser_cfg.s.ser_rxpol_auto = 1;
+		ilk_ser_cfg.s.ser_rxpol = 0;
+		ilk_ser_cfg.s.ser_txpol = 0;
+		ilk_ser_cfg.s.ser_reset_n = 0xff;
+		ilk_ser_cfg.s.ser_haul = 0;
+	}
+	ilk_ser_cfg.s.ser_pwrup |= ((interface == 0) && (lane_mask > 0xf)) ? 0x3 : (1 << interface);
+	cvmx_write_csr(CVMX_ILK_SER_CFG, ilk_ser_cfg.u64);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X)
+	    && (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)) {
+		/* Workaround for Errata (G-16467) */
+		int qlm = (interface) ? 2 : 1;
+		int start_qlm, end_qlm;
+
+		/*
+		 * Apply the workaround to both the QLMs if configured
+		 * for x8 lanes.
+		 */
+		if (cvmx_pop(lane_mask) > 4) {
+			start_qlm = 1;
+			end_qlm = 2;
+		} else {
+			start_qlm = qlm;
+			end_qlm = qlm;
+		}
+
+		for (qlm = start_qlm; qlm <= end_qlm; qlm++) {
+#ifdef CVMX_QLM_DUMP_STATE
+			cvmx_dprintf("%s:%d: ILK%d: Applying workaround for Errata G-16467\n", __func__, __LINE__, qlm);
+			cvmx_qlm_display_registers(qlm);
+			cvmx_dprintf("\n");
+#endif
+			/* This workaround only applies to QLMs running ILK at 6.25Ghz */
+			if ((cvmx_qlm_get_gbaud_mhz(qlm) == 6250) && (cvmx_qlm_jtag_get(qlm, 0, "clkf_byp") != 20)) {
+				udelay(100);	/* Wait 100us for links to stabalize */
+				cvmx_qlm_jtag_set(qlm, -1, "clkf_byp", 20);
+				/* Allow the QLM to exit reset */
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_rst_n_clr", 0);
+				udelay(100);	/* Wait 100us for links to stabalize */
+				/* Allow TX on QLM */
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_tx_idle_set", 0);
+			}
+#ifdef CVMX_QLM_DUMP_STATE
+			cvmx_dprintf("%s:%d: ILK%d: Done applying workaround for Errata G-16467\n", __func__, __LINE__, qlm);
+			cvmx_qlm_display_registers(qlm);
+			cvmx_dprintf("\n\n");
+#endif
+		}
+	}
+
+	/* Enable ILK LA mode if configured. */
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		union cvmx_ilk_txx_cfg1 ilk_txx_cfg1;
+		union cvmx_ilk_rxx_cfg1 ilk_rxx_cfg1;
+
+		ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+		ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+		ilk_txx_cfg1.s.la_mode = 1;
+		ilk_txx_cfg1.s.tx_link_fc_jam = 1;
+		ilk_txx_cfg1.s.rx_link_fc_ign = 1;
+		ilk_rxx_cfg1.s.la_mode = 1;
+		cvmx_write_csr(CVMX_ILK_TXX_CFG1(interface), ilk_txx_cfg1.u64);
+		cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+		cvmx_ilk_intf_cfg[interface].la_mode = 1;	/* Enable look-aside mode */
+	} else
+		cvmx_ilk_intf_cfg[interface].la_mode = 0;	/* Disable look-aside mode */
+
+	/* configure the lane enable of the interface */
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	ilk_txx_cfg0.s.lane_ena = ilk_rxx_cfg0.s.lane_ena = lane_mask;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+
+	/* write to local cache. for lane speed, if interface 0 has 8 lanes,
+	 * assume both qlms have the same speed */
+	cvmx_ilk_intf_cfg[interface].intf_en = 1;
+	cvmx_ilk_intf_cfg[interface].lane_en_mask = lane_mask;
+	res = 0;
+
+	return res;
+}
+
+/**
+ * set pipe group base and length for the interface
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @pipe_base: the base of the pipe group
+ * @pipe_len:  the length of the pipe group
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_set_pipe(int interface, int pipe_base, unsigned int pipe_len)
+{
+	int res = -1;
+	union cvmx_ilk_txx_pipe ilk_txx_pipe;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	/* set them in ilk tx section */
+	ilk_txx_pipe.u64 = cvmx_read_csr(CVMX_ILK_TXX_PIPE(interface));
+	ilk_txx_pipe.s.base = pipe_base;
+	ilk_txx_pipe.s.nump = pipe_len;
+	cvmx_write_csr(CVMX_ILK_TXX_PIPE(interface), ilk_txx_pipe.u64);
+	res = 0;
+
+	return res;
+}
+
+/**
+ * set logical channels for tx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @pch:     pointer to an array of pipe-channel pair
+ * @num_chs: the number of entries in the pipe-channel array
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_tx_set_channel(int interface, struct cvmx_ilk_pipe_chan *pch,
+			    unsigned int num_chs)
+{
+	int res = -1;
+	union cvmx_ilk_txx_idx_pmap ilk_txx_idx_pmap;
+	union cvmx_ilk_txx_mem_pmap ilk_txx_mem_pmap;
+	unsigned int i;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (pch == NULL || num_chs > CVMX_MAX_ILK_PIPES)
+		return res;
+
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		ilk_txx_idx_pmap.u64 = 0;
+		ilk_txx_mem_pmap.u64 = 0;
+		for (i = 0; i < num_chs; i++) {
+			ilk_txx_idx_pmap.s.index = pch->pipe;
+			ilk_txx_mem_pmap.s.channel = pch->chan;
+			ilk_txx_mem_pmap.s.remap = 1;
+			cvmx_write_csr(CVMX_ILK_TXX_IDX_PMAP(interface), ilk_txx_idx_pmap.u64);
+			cvmx_write_csr(CVMX_ILK_TXX_MEM_PMAP(interface), ilk_txx_mem_pmap.u64);
+			pch++;
+		}
+	} else {
+		/* write the pair to ilk tx */
+		ilk_txx_mem_pmap.u64 = 0;
+		ilk_txx_idx_pmap.u64 = 0;
+		for (i = 0; i < num_chs; i++) {
+			ilk_txx_idx_pmap.s.index = pch->pipe;
+			ilk_txx_mem_pmap.s.channel = pch->chan;
+			cvmx_write_csr(CVMX_ILK_TXX_IDX_PMAP(interface), ilk_txx_idx_pmap.u64);
+			cvmx_write_csr(CVMX_ILK_TXX_MEM_PMAP(interface), ilk_txx_mem_pmap.u64);
+			pch++;
+		}
+	}
+	res = 0;
+
+	return res;
+}
+
+/**
+ * set pkind for rx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @chpknd:    pointer to an array of channel-pkind pair
+ * @num_pknd: the number of entries in the channel-pkind array
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_rx_set_pknd(int interface, struct cvmx_ilk_chan_pknd *chpknd,
+			 unsigned int num_pknd)
+{
+	int res = -1;
+	union cvmx_ilk_rxf_idx_pmap ilk_rxf_idx_pmap;
+	unsigned int i;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (chpknd == NULL || num_pknd > CVMX_MAX_ILK_PKNDS)
+		return res;
+
+	res = 0;
+
+	for (i = 0; i < num_pknd; i++) {
+		ilk_rxf_idx_pmap.u64 = 0;
+		/* write the pair to ilk rx. note the channels for different interfaces
+		 * are given in *chpknd and interface is not used as a param */
+		if ((chpknd->chan < 2) && cvmx_ilk_use_la_mode(interface, chpknd->chan)) {
+			ilk_rxf_idx_pmap.s.index = interface * 256 + 128 + chpknd->chan;
+			cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
+			cvmx_write_csr(CVMX_ILK_RXF_MEM_PMAP, chpknd->pknd);
+		}
+		ilk_rxf_idx_pmap.s.index = interface * 256 + chpknd->chan;
+		cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
+		cvmx_write_csr(CVMX_ILK_RXF_MEM_PMAP, chpknd->pknd);
+		chpknd++;
+	}
+	return res;
+}
+
+/**
+ * configure calendar for rx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_depth: the number of calendar entries
+ * @pent:      pointer to calendar entries
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_rx_cal_conf(int interface, int cal_depth,
+			 struct cvmx_ilk_cal_entry *pent)
+{
+	int res = -1, num_grp, num_rest, i, j;
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+	union cvmx_ilk_rxx_idx_cal ilk_rxx_idx_cal;
+	union cvmx_ilk_rxx_mem_cal0 ilk_rxx_mem_cal0;
+	union cvmx_ilk_rxx_mem_cal1 ilk_rxx_mem_cal1;
+	unsigned long int tmp;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (cal_depth < CVMX_ILK_RX_MIN_CAL || cal_depth > CVMX_ILK_MAX_CAL || pent == NULL)
+		return res;
+
+	/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
+	/* TODO: test effectiveness */
+#if 0
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_0) && pent->ent_ctrl == PIPE_BPID)
+		for (i = 0; i < cal_depth; i++)
+			pent->ent_ctrl = LINK;
+#endif
+
+	/* set the depth */
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		ilk_rxx_cfg0.s.mproto_ign = 1;
+		ilk_rxx_cfg0.s.lnk_stats_ena = 1;
+		ilk_rxx_cfg0.s.lnk_stats_wrap = 1;
+		if (cvmx_ilk_la_mode_enable_rx_calendar(interface)) {
+			ilk_rxx_cfg0.s.cal_depth = cvmx_ilk_use_la_mode(interface, 1) ? 2 : 1;
+			ilk_rxx_cfg0.s.cal_ena = 1;
+		} else {
+			ilk_rxx_cfg0.s.cal_depth = 0;
+			ilk_rxx_cfg0.s.cal_ena = 0;
+		}
+	} else
+		ilk_rxx_cfg0.s.cal_depth = cal_depth;
+
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+
+	/* set the calendar index */
+	num_grp = cal_depth / CVMX_ILK_CAL_GRP_SZ;
+	num_rest = cal_depth % CVMX_ILK_CAL_GRP_SZ;
+	ilk_rxx_idx_cal.u64 = 0;
+	ilk_rxx_idx_cal.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_RXX_IDX_CAL(interface), ilk_rxx_idx_cal.u64);
+
+	/* Note that calendar support is somewhat broken through pass 2.0 */
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		ilk_rxx_mem_cal0.u64 = 0;
+		ilk_rxx_mem_cal1.u64 = 0;
+
+		if (cvmx_ilk_la_mode_enable_rx_calendar(interface)) {
+			ilk_rxx_mem_cal0.s.entry_ctl0 = pent->ent_ctrl;
+			ilk_rxx_mem_cal0.s.port_pipe0 = pent->pipe_bpid;
+			pent++;
+
+			if (cvmx_ilk_use_la_mode(interface, 1)) {
+				ilk_rxx_mem_cal0.s.entry_ctl1 = pent->ent_ctrl;
+				ilk_rxx_mem_cal0.s.port_pipe1 = pent->pipe_bpid;
+			} else
+				ilk_rxx_mem_cal0.s.entry_ctl1 = XOFF;
+			pent++;
+
+			ilk_rxx_mem_cal0.s.entry_ctl2 = XOFF;
+			ilk_rxx_mem_cal0.s.entry_ctl3 = XOFF;
+			ilk_rxx_mem_cal1.s.entry_ctl4 = XOFF;
+			ilk_rxx_mem_cal1.s.entry_ctl5 = XOFF;
+			ilk_rxx_mem_cal1.s.entry_ctl6 = XOFF;
+			ilk_rxx_mem_cal1.s.entry_ctl7 = XOFF;
+		}
+		cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL0(interface), ilk_rxx_mem_cal0.u64);
+		cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL1(interface), ilk_rxx_mem_cal1.u64);
+		cvmx_read_csr(CVMX_ILK_RXX_MEM_CAL1(interface));
+		ilk_rxx_idx_cal.u64 = cvmx_read_csr(CVMX_ILK_RXX_IDX_CAL(interface));
+
+		return 0;
+	}
+
+	/* set the calendar entries. each group has both cal0 and cal1 registers */
+	for (i = 0; i < num_grp; i++) {
+		ilk_rxx_mem_cal0.u64 = 0;
+		for (j = 0; j < CVMX_ILK_CAL_GRP_SZ / 2; j++) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j;
+			ilk_rxx_mem_cal0.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_rxx_mem_cal0.u64 |= tmp;
+			pent++;
+		}
+		cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL0(interface), ilk_rxx_mem_cal0.u64);
+
+		ilk_rxx_mem_cal1.u64 = 0;
+		for (j = 0; j < CVMX_ILK_CAL_GRP_SZ / 2; j++) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j;
+			ilk_rxx_mem_cal1.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_rxx_mem_cal1.u64 |= tmp;
+			pent++;
+		}
+		cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL1(interface), ilk_rxx_mem_cal1.u64);
+	}
+
+	/* set the calendar entries, the fraction of a group. but both cal0 and
+	 * cal1 must be written */
+	ilk_rxx_mem_cal0.u64 = 0;
+	ilk_rxx_mem_cal1.u64 = 0;
+	for (i = 0; i < num_rest; i++) {
+		if (i < CVMX_ILK_CAL_GRP_SZ / 2) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * i;
+			ilk_rxx_mem_cal0.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * i + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_rxx_mem_cal0.u64 |= tmp;
+			pent++;
+		}
+
+		if (i >= CVMX_ILK_CAL_GRP_SZ / 2) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * (i - CVMX_ILK_CAL_GRP_SZ / 2);
+			ilk_rxx_mem_cal1.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * (i - CVMX_ILK_CAL_GRP_SZ / 2) + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_rxx_mem_cal1.u64 |= tmp;
+			pent++;
+		}
+	}
+	cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL0(interface), ilk_rxx_mem_cal0.u64);
+	cvmx_write_csr(CVMX_ILK_RXX_MEM_CAL1(interface), ilk_rxx_mem_cal1.u64);
+	cvmx_read_csr(CVMX_ILK_RXX_MEM_CAL1(interface));
+
+	return 0;
+}
+
+/**
+ * set high water mark for rx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @hi_wm:     high water mark for this interface
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_rx_set_hwm(int interface, int hi_wm)
+{
+	int res = -1;
+	union cvmx_ilk_rxx_cfg1 ilk_rxx_cfg1;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (hi_wm <= 0)
+		return res;
+
+	/* set the hwm */
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	ilk_rxx_cfg1.s.rx_fifo_hwm = hi_wm;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+	res = 0;
+
+	return res;
+}
+
+/**
+ * enable calendar for rx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_ena:   enable or disable calendar
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_rx_cal_ena(int interface, unsigned char cal_ena)
+{
+	int res = -1;
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (cvmx_ilk_use_la_mode(interface, 0) && !cvmx_ilk_la_mode_enable_rx_calendar(interface))
+		return 0;
+
+	/* set the enable */
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	ilk_rxx_cfg0.s.cal_ena = cal_ena;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+	cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	res = 0;
+
+	return res;
+}
+
+/**
+ * set up calendar for rx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_depth: the number of calendar entries
+ * @pent:      pointer to calendar entries
+ * @hi_wm:     high water mark for this interface
+ * @cal_ena:   enable or disable calendar
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_cal_setup_rx(int interface, int cal_depth,
+			  struct cvmx_ilk_cal_entry *pent,
+			  int hi_wm, unsigned char cal_ena)
+{
+	int res = -1;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	res = cvmx_ilk_rx_cal_conf(interface, cal_depth, pent);
+	if (res < 0)
+		return res;
+
+	res = cvmx_ilk_rx_set_hwm(interface, hi_wm);
+	if (res < 0)
+		return res;
+
+	res = cvmx_ilk_rx_cal_ena(interface, cal_ena);
+	return res;
+}
+EXPORT_SYMBOL(cvmx_ilk_cal_setup_rx);
+
+/**
+ * configure calendar for tx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_depth: the number of calendar entries
+ * @pent:      pointer to calendar entries
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_tx_cal_conf(int interface, int cal_depth, struct cvmx_ilk_cal_entry *pent)
+{
+	int res = -1, num_grp, num_rest, i, j;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+	union cvmx_ilk_txx_idx_cal ilk_txx_idx_cal;
+	union cvmx_ilk_txx_mem_cal0 ilk_txx_mem_cal0;
+	union cvmx_ilk_txx_mem_cal1 ilk_txx_mem_cal1;
+	struct cvmx_ilk_cal_entry *ent_tmp;
+	unsigned long int tmp;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	if (cal_depth < CVMX_ILK_TX_MIN_CAL || cal_depth > CVMX_ILK_MAX_CAL || pent == NULL)
+		return res;
+
+	/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
+	/* TODO: test effectiveness */
+#if 0
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_0) && pent->ent_ctrl == PIPE_BPID)
+		for (i = 0; i < cal_depth; i++)
+			pent->ent_ctrl = LINK;
+#endif
+
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		ilk_txx_idx_cal.u64 = cvmx_read_csr(CVMX_ILK_TXX_IDX_CAL(interface));
+		ilk_txx_idx_cal.s.inc = 1;
+		ilk_txx_idx_cal.s.index = 0;	/* channel */
+		cvmx_write_csr(CVMX_ILK_TXX_IDX_CAL(interface), ilk_txx_idx_cal.u64);
+
+		ilk_txx_mem_cal0.u64 = 0;
+		ilk_txx_mem_cal1.u64 = 0;
+		ilk_txx_mem_cal0.s.entry_ctl0 = pent->ent_ctrl;
+		ilk_txx_mem_cal0.s.bpid0 = pent->pipe_bpid;
+
+		pent++;
+		if (cvmx_ilk_use_la_mode(interface, 1)) {
+			ilk_txx_mem_cal0.s.entry_ctl1 = pent->ent_ctrl;
+			ilk_txx_mem_cal0.s.bpid1 = pent->pipe_bpid;
+		} else {
+			ilk_txx_mem_cal0.s.entry_ctl1 = XOFF;
+		}
+		pent++;
+		ilk_txx_mem_cal0.s.entry_ctl2 = XOFF;
+		ilk_txx_mem_cal0.s.entry_ctl3 = XOFF;
+		ilk_txx_mem_cal1.s.entry_ctl4 = XOFF;
+		ilk_txx_mem_cal1.s.entry_ctl5 = XOFF;
+		ilk_txx_mem_cal1.s.entry_ctl6 = XOFF;
+		ilk_txx_mem_cal1.s.entry_ctl7 = XOFF;
+
+		cvmx_write_csr(CVMX_ILK_TXX_MEM_CAL0(interface), ilk_txx_mem_cal0.u64);
+		cvmx_write_csr(CVMX_ILK_TXX_MEM_CAL1(interface), ilk_txx_mem_cal1.u64);
+		cvmx_read_csr(CVMX_ILK_TXX_MEM_CAL1(interface));
+
+		ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+		ilk_txx_cfg0.s.cal_depth = 8;
+		ilk_txx_cfg0.s.lnk_stats_ena = 1;
+		cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+
+		return 0;
+	}
+
+	/* tx calendar depth must be a multiple of 8 */
+	num_grp = (cal_depth - 1) / CVMX_ILK_CAL_GRP_SZ + 1;
+	num_rest = cal_depth % CVMX_ILK_CAL_GRP_SZ;
+	if (num_rest != 0) {
+		ent_tmp = pent + cal_depth;
+		for (i = num_rest; i < 8; i++, ent_tmp++) {
+			ent_tmp->pipe_bpid = 0;
+			ent_tmp->ent_ctrl = XOFF;
+		}
+	}
+	cal_depth = num_grp * 8;
+
+	/* set the depth */
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_txx_cfg0.s.cal_depth = cal_depth;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+
+	/* set the calendar index */
+	ilk_txx_idx_cal.u64 = 0;
+	ilk_txx_idx_cal.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_TXX_IDX_CAL(interface), ilk_txx_idx_cal.u64);
+
+	/* set the calendar entries. each group has both cal0 and cal1 registers */
+	for (i = 0; i < num_grp; i++) {
+		ilk_txx_mem_cal0.u64 = 0;
+		for (j = 0; j < CVMX_ILK_CAL_GRP_SZ / 2; j++) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j;
+			ilk_txx_mem_cal0.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_txx_mem_cal0.u64 |= tmp;
+			pent++;
+		}
+		cvmx_write_csr(CVMX_ILK_TXX_MEM_CAL0(interface), ilk_txx_mem_cal0.u64);
+
+		ilk_txx_mem_cal1.u64 = 0;
+		for (j = 0; j < CVMX_ILK_CAL_GRP_SZ / 2; j++) {
+			tmp = 0;
+			tmp = pent->pipe_bpid & ~(~tmp << CVMX_ILK_PIPE_BPID_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j;
+			ilk_txx_mem_cal1.u64 |= tmp;
+
+			tmp = 0;
+			tmp = pent->ent_ctrl & ~(~tmp << CVMX_ILK_ENT_CTRL_SZ);
+			tmp <<= (CVMX_ILK_PIPE_BPID_SZ + CVMX_ILK_ENT_CTRL_SZ) * j + CVMX_ILK_PIPE_BPID_SZ;
+			ilk_txx_mem_cal1.u64 |= tmp;
+			pent++;
+		}
+		cvmx_write_csr(CVMX_ILK_TXX_MEM_CAL1(interface), ilk_txx_mem_cal1.u64);
+	}
+	cvmx_read_csr(CVMX_ILK_TXX_MEM_CAL1(interface));
+
+	return 0;
+}
+
+/**
+ * configure backpressure for tx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_depth: the number of calendar entries
+ * @pent:      pointer to calendar entries
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_bp_conf(int interface, int cal_depth, struct cvmx_ilk_cal_entry *pent)
+{
+	int res = -1, i;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+	struct cvmx_ilk_cal_entry *tmp;
+	unsigned char bpid;
+	union cvmx_ipd_bpidx_mbuf_th ipd_bpidx_mbuf_th;
+
+	/* enable bp for the interface */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.pbp_en = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	/* enable bp for each id */
+	for (i = 0, tmp = pent; i < cal_depth; i++, tmp++) {
+		bpid = tmp->pipe_bpid;
+		ipd_bpidx_mbuf_th.u64 = cvmx_read_csr(CVMX_IPD_BPIDX_MBUF_TH(bpid));
+		ipd_bpidx_mbuf_th.s.page_cnt = 1;	/* 256 buffers */
+		ipd_bpidx_mbuf_th.s.bp_enb = 1;
+		cvmx_write_csr(CVMX_IPD_BPIDX_MBUF_TH(bpid), ipd_bpidx_mbuf_th.u64);
+	}
+	res = 0;
+
+	return res;
+}
+
+/**
+ * enable calendar for tx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_ena:   enable or disable calendar
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_tx_cal_ena(int interface, unsigned char cal_ena)
+{
+	int res = -1;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	/* set the enable */
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_txx_cfg0.s.cal_ena = cal_ena;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+	cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	res = 0;
+
+	return res;
+}
+
+/**
+ * set up calendar for tx
+ *
+ * @interface: The identifier of the packet interface to configure and
+ *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and
+ *                  ilk1.
+ *
+ * @cal_depth: the number of calendar entries
+ * @pent:      pointer to calendar entries
+ * @cal_ena:   enable or disable calendar
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_cal_setup_tx(int interface, int cal_depth,
+			  struct cvmx_ilk_cal_entry *pent,
+			  unsigned char cal_ena)
+{
+	int res = -1;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	res = cvmx_ilk_tx_cal_conf(interface, cal_depth, pent);
+	if (res < 0)
+		return res;
+
+#ifdef CVMX_ILK_BP_CONF_ENA
+	res = cvmx_ilk_bp_conf(interface, cal_depth, pent);
+	if (res < 0)
+		return res;
+#endif
+
+	res = cvmx_ilk_tx_cal_ena(interface, cal_ena);
+	return res;
+}
+EXPORT_SYMBOL(cvmx_ilk_cal_setup_tx);
+
+#ifdef CVMX_ILK_STATS_ENA
+static void cvmx_ilk_reg_dump_rx(int interface)
+{
+	int i;
+	cvmx_ilk_rxx_cfg0_t ilk_rxx_cfg0;
+	cvmx_ilk_rxx_cfg1_t ilk_rxx_cfg1;
+	cvmx_ilk_rxx_int_t ilk_rxx_int;
+	cvmx_ilk_rxx_jabber_t ilk_rxx_jabber;
+	cvmx_ilk_rx_lnex_cfg_t ilk_rx_lnex_cfg;
+	cvmx_ilk_rx_lnex_int_t ilk_rx_lnex_int;
+	cvmx_ilk_gbl_cfg_t ilk_gbl_cfg;
+	cvmx_ilk_ser_cfg_t ilk_ser_cfg;
+	cvmx_ilk_rxf_idx_pmap_t ilk_rxf_idx_pmap;
+	cvmx_ilk_rxf_mem_pmap_t ilk_rxf_mem_pmap;
+	cvmx_ilk_rxx_idx_cal_t ilk_rxx_idx_cal;
+	cvmx_ilk_rxx_mem_cal0_t ilk_rxx_mem_cal0;
+	cvmx_ilk_rxx_mem_cal1_t ilk_rxx_mem_cal1;
+
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	cvmx_dprintf("ilk rxx cfg0: 0x%16lx\n", ilk_rxx_cfg0.u64);
+
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	cvmx_dprintf("ilk rxx cfg1: 0x%16lx\n", ilk_rxx_cfg1.u64);
+
+	ilk_rxx_int.u64 = cvmx_read_csr(CVMX_ILK_RXX_INT(interface));
+	cvmx_dprintf("ilk rxx int: 0x%16lx\n", ilk_rxx_int.u64);
+	cvmx_write_csr(CVMX_ILK_RXX_INT(interface), ilk_rxx_int.u64);
+
+	ilk_rxx_jabber.u64 = cvmx_read_csr(CVMX_ILK_RXX_JABBER(interface));
+	cvmx_dprintf("ilk rxx jabber: 0x%16lx\n", ilk_rxx_jabber.u64);
+
+#define LNE_NUM_DBG 4
+	for (i = 0; i < LNE_NUM_DBG; i++) {
+		ilk_rx_lnex_cfg.u64 = cvmx_read_csr(CVMX_ILK_RX_LNEX_CFG(i));
+		cvmx_dprintf("ilk rx lnex cfg lane: %d  0x%16lx\n", i, ilk_rx_lnex_cfg.u64);
+	}
+
+	for (i = 0; i < LNE_NUM_DBG; i++) {
+		ilk_rx_lnex_int.u64 = cvmx_read_csr(CVMX_ILK_RX_LNEX_INT(i));
+		cvmx_dprintf("ilk rx lnex int lane: %d  0x%16lx\n", i, ilk_rx_lnex_int.u64);
+		cvmx_write_csr(CVMX_ILK_RX_LNEX_INT(i), ilk_rx_lnex_int.u64);
+	}
+
+	ilk_gbl_cfg.u64 = cvmx_read_csr(CVMX_ILK_GBL_CFG);
+	cvmx_dprintf("ilk gbl cfg: 0x%16lx\n", ilk_gbl_cfg.u64);
+
+	ilk_ser_cfg.u64 = cvmx_read_csr(CVMX_ILK_SER_CFG);
+	cvmx_dprintf("ilk ser cfg: 0x%16lx\n", ilk_ser_cfg.u64);
+
+#define CHAN_NUM_DBG 8
+	ilk_rxf_idx_pmap.u64 = 0;
+	ilk_rxf_idx_pmap.s.index = interface * 256;
+	ilk_rxf_idx_pmap.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
+	for (i = 0; i < CHAN_NUM_DBG; i++) {
+		ilk_rxf_mem_pmap.u64 = cvmx_read_csr(CVMX_ILK_RXF_MEM_PMAP);
+		cvmx_dprintf("ilk rxf mem pmap chan: %3d  0x%16lx\n", i, ilk_rxf_mem_pmap.u64);
+	}
+
+#define CAL_NUM_DBG 2
+	ilk_rxx_idx_cal.u64 = 0;
+	ilk_rxx_idx_cal.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_RXX_IDX_CAL(interface), ilk_rxx_idx_cal.u64);
+	for (i = 0; i < CAL_NUM_DBG; i++) {
+		ilk_rxx_idx_cal.u64 = cvmx_read_csr(CVMX_ILK_RXX_IDX_CAL(interface));
+		cvmx_dprintf("ilk rxx idx cal: 0x%16lx\n", ilk_rxx_idx_cal.u64);
+
+		ilk_rxx_mem_cal0.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_CAL0(interface));
+		cvmx_dprintf("ilk rxx mem cal0: 0x%16lx\n", ilk_rxx_mem_cal0.u64);
+		ilk_rxx_mem_cal1.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_CAL1(interface));
+		cvmx_dprintf("ilk rxx mem cal1: 0x%16lx\n", ilk_rxx_mem_cal1.u64);
+	}
+}
+
+static void cvmx_ilk_reg_dump_tx(int interface)
+{
+	int i;
+	cvmx_ilk_txx_cfg0_t ilk_txx_cfg0;
+	cvmx_ilk_txx_cfg1_t ilk_txx_cfg1;
+	cvmx_ilk_txx_idx_pmap_t ilk_txx_idx_pmap;
+	cvmx_ilk_txx_mem_pmap_t ilk_txx_mem_pmap;
+	cvmx_ilk_txx_int_t ilk_txx_int;
+	cvmx_ilk_txx_pipe_t ilk_txx_pipe;
+	cvmx_ilk_txx_idx_cal_t ilk_txx_idx_cal;
+	cvmx_ilk_txx_mem_cal0_t ilk_txx_mem_cal0;
+	cvmx_ilk_txx_mem_cal1_t ilk_txx_mem_cal1;
+
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	cvmx_dprintf("ilk txx cfg0: 0x%16lx\n", ilk_txx_cfg0.u64);
+
+	ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+	cvmx_dprintf("ilk txx cfg1: 0x%16lx\n", ilk_txx_cfg1.u64);
+
+	ilk_txx_pipe.u64 = cvmx_read_csr(CVMX_ILK_TXX_PIPE(interface));
+	cvmx_dprintf("ilk txx pipe: 0x%16lx\n", ilk_txx_pipe.u64);
+
+	ilk_txx_idx_pmap.u64 = 0;
+	ilk_txx_idx_pmap.s.index = ilk_txx_pipe.s.base;
+	ilk_txx_idx_pmap.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_TXX_IDX_PMAP(interface), ilk_txx_idx_pmap.u64);
+	for (i = 0; i < CHAN_NUM_DBG; i++) {
+		ilk_txx_mem_pmap.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_PMAP(interface));
+		cvmx_dprintf("ilk txx mem pmap pipe: %3d  0x%16lx\n", ilk_txx_pipe.s.base + i, ilk_txx_mem_pmap.u64);
+	}
+
+	ilk_txx_int.u64 = cvmx_read_csr(CVMX_ILK_TXX_INT(interface));
+	cvmx_dprintf("ilk txx int: 0x%16lx\n", ilk_txx_int.u64);
+
+	ilk_txx_idx_cal.u64 = 0;
+	ilk_txx_idx_cal.s.inc = 1;
+	cvmx_write_csr(CVMX_ILK_TXX_IDX_CAL(interface), ilk_txx_idx_cal.u64);
+	for (i = 0; i < CAL_NUM_DBG; i++) {
+		ilk_txx_idx_cal.u64 = cvmx_read_csr(CVMX_ILK_TXX_IDX_CAL(interface));
+		cvmx_dprintf("ilk txx idx cal: 0x%16lx\n", ilk_txx_idx_cal.u64);
+
+		ilk_txx_mem_cal0.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_CAL0(interface));
+		cvmx_dprintf("ilk txx mem cal0: 0x%16lx\n", ilk_txx_mem_cal0.u64);
+		ilk_txx_mem_cal1.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_CAL1(interface));
+		cvmx_dprintf("ilk txx mem cal1: 0x%16lx\n", ilk_txx_mem_cal1.u64);
+	}
+}
+#endif
+
+/**
+ * show run time status
+ *
+ * @interface: The identifier of the packet interface to enable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ *
+ * Returns nothing
+ */
+#ifdef CVMX_ILK_RUNTIME_DBG
+void cvmx_ilk_runtime_status(int interface)
+{
+	cvmx_ilk_txx_cfg1_t ilk_txx_cfg1;
+	cvmx_ilk_txx_flow_ctl0_t ilk_txx_flow_ctl0;
+	cvmx_ilk_rxx_cfg1_t ilk_rxx_cfg1;
+	cvmx_ilk_rxx_int_t ilk_rxx_int;
+	cvmx_ilk_rxx_flow_ctl0_t ilk_rxx_flow_ctl0;
+	cvmx_ilk_rxx_flow_ctl1_t ilk_rxx_flow_ctl1;
+	cvmx_ilk_gbl_int_t ilk_gbl_int;
+
+	cvmx_dprintf("\nilk run-time status: interface: %d\n", interface);
+
+	ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+	cvmx_dprintf("\nilk txx cfg1: 0x%16lx\n", ilk_txx_cfg1.u64);
+	if (ilk_txx_cfg1.s.rx_link_fc)
+		cvmx_dprintf("link flow control received\n");
+	if (ilk_txx_cfg1.s.tx_link_fc)
+		cvmx_dprintf("link flow control sent\n");
+
+	ilk_txx_flow_ctl0.u64 = cvmx_read_csr(CVMX_ILK_TXX_FLOW_CTL0(interface));
+	cvmx_dprintf("\nilk txx flow ctl0: 0x%16lx\n", ilk_txx_flow_ctl0.u64);
+
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	cvmx_dprintf("\nilk rxx cfg1: 0x%16lx\n", ilk_rxx_cfg1.u64);
+	cvmx_dprintf("rx fifo count: %d\n", ilk_rxx_cfg1.s.rx_fifo_cnt);
+
+	ilk_rxx_int.u64 = cvmx_read_csr(CVMX_ILK_RXX_INT(interface));
+	cvmx_dprintf("\nilk rxx int: 0x%16lx\n", ilk_rxx_int.u64);
+	if (ilk_rxx_int.s.pkt_drop_rxf)
+		cvmx_dprintf("rx fifo packet drop\n");
+	if (ilk_rxx_int.u64)
+		cvmx_write_csr(CVMX_ILK_RXX_INT(interface), ilk_rxx_int.u64);
+
+	ilk_rxx_flow_ctl0.u64 = cvmx_read_csr(CVMX_ILK_RXX_FLOW_CTL0(interface));
+	cvmx_dprintf("\nilk rxx flow ctl0: 0x%16lx\n", ilk_rxx_flow_ctl0.u64);
+
+	ilk_rxx_flow_ctl1.u64 = cvmx_read_csr(CVMX_ILK_RXX_FLOW_CTL1(interface));
+	cvmx_dprintf("\nilk rxx flow ctl1: 0x%16lx\n", ilk_rxx_flow_ctl1.u64);
+
+	ilk_gbl_int.u64 = cvmx_read_csr(CVMX_ILK_GBL_INT);
+	cvmx_dprintf("\nilk gbl int: 0x%16lx\n", ilk_gbl_int.u64);
+	if (ilk_gbl_int.s.rxf_push_full)
+		cvmx_dprintf("rx fifo overflow\n");
+	if (ilk_gbl_int.u64)
+		cvmx_write_csr(CVMX_ILK_GBL_INT, ilk_gbl_int.u64);
+}
+#endif
+
+/**
+ * enable interface
+ *
+ * @interface: The identifier of the packet interface to enable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ *
+ * Returns Zero on success, negative of failure.
+ */
+/* #define CVMX_ILK_STATS_ENA 1 */
+int cvmx_ilk_enable(int interface)
+{
+	int res = -1;
+	int retry_count = 0;
+	cvmx_helper_link_info_t result;
+	union cvmx_ilk_txx_cfg1 ilk_txx_cfg1;
+	union cvmx_ilk_rxx_cfg1 ilk_rxx_cfg1;
+#ifdef CVMX_ILK_STATS_ENA
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+#endif
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	result.u64 = 0;
+
+#ifdef CVMX_ILK_STATS_ENA
+	cvmx_dprintf("\n");
+	cvmx_dprintf("<<<< ILK%d: Before enabling ilk\n", interface);
+	cvmx_ilk_reg_dump_rx(interface);
+	cvmx_ilk_reg_dump_tx(interface);
+#endif
+
+	/* RX packet will be enabled only if link is up */
+
+	/* TX side */
+	ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+	ilk_txx_cfg1.s.pkt_ena = 1;
+	if (cvmx_ilk_use_la_mode(interface, 0)) {
+		ilk_txx_cfg1.s.la_mode = 1;
+		ilk_txx_cfg1.s.tx_link_fc_jam = 1;
+	}
+	ilk_txx_cfg1.s.rx_link_fc_ign = 1;	/* cannot use link fc workaround */
+	cvmx_write_csr(CVMX_ILK_TXX_CFG1(interface), ilk_txx_cfg1.u64);
+	cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+
+#ifdef CVMX_ILK_STATS_ENA
+	/* RX side stats */
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	ilk_rxx_cfg0.s.lnk_stats_ena = 1;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+
+	/* TX side stats */
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_txx_cfg0.s.lnk_stats_ena = 1;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+#endif
+
+retry:
+	retry_count++;
+	if (retry_count > 10)
+		goto out;
+
+	/* Make sure the link is up, so that packets can be sent. */
+	result = __cvmx_helper_ilk_link_get(cvmx_helper_get_ipd_port(interface + CVMX_ILK_GBL_BASE, 0));
+
+	/* Small delay before another retry. */
+	udelay(100);
+
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	if (ilk_rxx_cfg1.s.pkt_ena == 0)
+		goto retry;
+
+out:
+
+#ifdef CVMX_ILK_STATS_ENA
+	cvmx_dprintf(">>>> ILK%d: After ILK is enabled\n", interface);
+	cvmx_ilk_reg_dump_rx(interface);
+	cvmx_ilk_reg_dump_tx(interface);
+#endif
+
+	if (result.s.link_up)
+		return 0;
+
+	return -1;
+}
+
+/**
+ * Disable interface
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_disable(int interface)
+{
+	int res = -1;
+	union cvmx_ilk_txx_cfg1 ilk_txx_cfg1;
+	union cvmx_ilk_rxx_cfg1 ilk_rxx_cfg1;
+#ifdef CVMX_ILK_STATS_ENA
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+#endif
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	/* TX side */
+	ilk_txx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG1(interface));
+	ilk_txx_cfg1.s.pkt_ena = 0;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG1(interface), ilk_txx_cfg1.u64);
+
+	/* RX side */
+	ilk_rxx_cfg1.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG1(interface));
+	ilk_rxx_cfg1.s.pkt_ena = 0;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG1(interface), ilk_rxx_cfg1.u64);
+
+#ifdef CVMX_ILK_STATS_ENA
+	/* RX side stats */
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	ilk_rxx_cfg0.s.lnk_stats_ena = 0;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+
+	/* RX side stats */
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_txx_cfg0.s.lnk_stats_ena = 0;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+#endif
+
+	return 0;
+}
+
+/**
+ * Provide interface enable status
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ *
+ * Returns Zero, not enabled; One, enabled.
+ */
+int cvmx_ilk_get_intf_ena(int interface)
+{
+	return cvmx_ilk_intf_cfg[interface].intf_en;
+}
+
+/**
+ * bit counter
+ *
+ * @uc: the byte to be counted
+ *
+ * Returns number of bits set
+ */
+unsigned char cvmx_ilk_bit_count(unsigned char uc)
+{
+	unsigned char count;
+
+	for (count = 0; uc > 0; uc &= uc - 1)
+		count++;
+
+	return count;
+}
+
+/**
+ * Provide interface lane mask
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ *
+ * Returns lane mask
+ */
+unsigned char cvmx_ilk_get_intf_ln_msk(int interface)
+{
+	return cvmx_ilk_intf_cfg[interface].lane_en_mask;
+}
+
+/**
+ * Provide channel info
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ * @chans:    A pointer to a channel array
+ * @num_chan: A pointer to the number of channels
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_get_chan_info(int interface, unsigned char **chans, unsigned char *num_chan)
+{
+	*chans = cvmx_ilk_chan_map[interface];
+	*num_chan = cvmx_ilk_chans[interface];
+
+	return 0;
+}
+
+/**
+ * Enable or disable LA mode in ILK header.
+ * For normal ILK mode, enable CRC and skip = 0.
+ * For ILK LA mode, disable CRC and set skip to size of ILK header.
+ *
+ * @port:   IPD port of the ILK header
+ * @mode:   If set, enable LA mode in ILK header, else disable
+ *
+ * Returns ILK header
+ */
+union cvmx_ilk_la_nsp_compact_hdr cvmx_ilk_enable_la_header(int port, int mode)
+{
+	union cvmx_ilk_la_nsp_compact_hdr ilk_header;
+	union cvmx_pip_prt_cfgx pip_config;
+	int interface = cvmx_helper_get_interface_num(port);
+	int ilk_interface = interface - CVMX_ILK_GBL_BASE;
+	int skip = 0;
+	int crc = 1;
+	int len_chk = 1;
+
+	ilk_header.u64 = 0;
+
+	if (!cvmx_ilk_use_la_mode(ilk_interface, 0))
+		return ilk_header;
+
+	if (mode) {
+		ilk_header.s.la_mode = 1;
+		ilk_header.s.ilk_channel = port & 1;
+		skip = sizeof(ilk_header);
+		crc = 0;
+	}
+	/* There is a bug in the CN68XX pass 2.x where the CRC erroneously is
+	 * computed over the ILK header when it should not be so we ignore it.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X)) {
+		crc = 0;
+		if (!mode)
+			len_chk = 0;
+		skip = sizeof(ilk_header);
+	}
+
+	/* SKIP ILK header only for first 2 ports */
+	if ((port & 0x7) < 2) {
+		int pknd = cvmx_helper_get_pknd(interface, port & 1);
+		int ipko_port;
+		union cvmx_pko_reg_read_idx pko_reg;
+		union cvmx_pko_mem_iport_ptrs pko_mem_iport;
+		union cvmx_pip_sub_pkind_fcsx pknd_fcs;
+
+		/* Enable/Disable CRC in IPD and set skip */
+		pip_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+		pip_config.s.skip = skip;
+		pip_config.s.crc_en = crc;
+		pip_config.s.lenerr_en = len_chk;
+		pip_config.s.minerr_en = (len_chk && !mode);
+		cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), pip_config.u64);
+
+		pknd_fcs.u64 = cvmx_read_csr(CVMX_PIP_SUB_PKIND_FCSX(0));
+		pknd_fcs.s.port_bit &= ~(1ull << pknd);
+		cvmx_write_csr(CVMX_PIP_SUB_PKIND_FCSX(0), pknd_fcs.u64);
+
+		/* Enable/Disable CRC in PKO */
+
+		/* Get PKO internal port */
+		ipko_port = ilk_interface + 0x1c;
+
+		pko_reg.u64 = cvmx_read_csr(CVMX_PKO_REG_READ_IDX);
+		pko_reg.s.index = cvmx_helper_get_pko_port(interface, port & 1);
+		cvmx_write_csr(CVMX_PKO_REG_READ_IDX, pko_reg.u64);
+
+		pko_mem_iport.u64 = cvmx_read_csr(CVMX_PKO_MEM_IPORT_PTRS);
+		pko_mem_iport.s.crc = crc;
+		pko_mem_iport.s.intr = ipko_port;
+		cvmx_write_csr(CVMX_PKO_MEM_IPORT_PTRS, pko_mem_iport.u64);
+	}
+
+	return ilk_header;
+}
+
+/**
+ * Show channel statistics
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ * @pstats: A pointer to cvmx_ilk_stats_ctrl_t that specifies which
+ *               logical channels to access
+ *
+ * Returns nothing
+ */
+void cvmx_ilk_show_stats(int interface, struct cvmx_ilk_stats_ctrl *pstats)
+{
+	unsigned int i;
+	union cvmx_ilk_rxx_idx_stat0 ilk_rxx_idx_stat0;
+	union cvmx_ilk_rxx_idx_stat1 ilk_rxx_idx_stat1;
+	union cvmx_ilk_rxx_mem_stat0 ilk_rxx_mem_stat0;
+	union cvmx_ilk_rxx_mem_stat1 ilk_rxx_mem_stat1;
+
+	union cvmx_ilk_txx_idx_stat0 ilk_txx_idx_stat0;
+	union cvmx_ilk_txx_idx_stat1 ilk_txx_idx_stat1;
+	union cvmx_ilk_txx_mem_stat0 ilk_txx_mem_stat0;
+	union cvmx_ilk_txx_mem_stat1 ilk_txx_mem_stat1;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return;
+
+	if (pstats == NULL)
+		return;
+
+	/* discrete channels */
+	if (pstats->chan_list != NULL) {
+		for (i = 0; i < pstats->num_chans; i++) {
+
+			/* get the number of rx packets */
+			ilk_rxx_idx_stat0.u64 = 0;
+			ilk_rxx_idx_stat0.s.index = *pstats->chan_list;
+			ilk_rxx_idx_stat0.s.clr = pstats->clr_on_rd;
+			cvmx_write_csr(CVMX_ILK_RXX_IDX_STAT0(interface), ilk_rxx_idx_stat0.u64);
+			ilk_rxx_mem_stat0.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_STAT0(interface));
+
+			/* get the number of rx bytes */
+			ilk_rxx_idx_stat1.u64 = 0;
+			ilk_rxx_idx_stat1.s.index = *pstats->chan_list;
+			ilk_rxx_idx_stat1.s.clr = pstats->clr_on_rd;
+			cvmx_write_csr(CVMX_ILK_RXX_IDX_STAT1(interface), ilk_rxx_idx_stat1.u64);
+			ilk_rxx_mem_stat1.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_STAT1(interface));
+
+			cvmx_dprintf("ILK%d Channel%d Rx: %d packets %d bytes\n", interface,
+				     *pstats->chan_list, ilk_rxx_mem_stat0.s.rx_pkt, (unsigned int)ilk_rxx_mem_stat1.s.rx_bytes);
+
+			/* get the number of tx packets */
+			ilk_txx_idx_stat0.u64 = 0;
+			ilk_txx_idx_stat0.s.index = *pstats->chan_list;
+			ilk_txx_idx_stat0.s.clr = pstats->clr_on_rd;
+			cvmx_write_csr(CVMX_ILK_TXX_IDX_STAT0(interface), ilk_txx_idx_stat0.u64);
+			ilk_txx_mem_stat0.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_STAT0(interface));
+
+			/* get the number of tx bytes */
+			ilk_txx_idx_stat1.u64 = 0;
+			ilk_txx_idx_stat1.s.index = *pstats->chan_list;
+			ilk_txx_idx_stat1.s.clr = pstats->clr_on_rd;
+			cvmx_write_csr(CVMX_ILK_TXX_IDX_STAT1(interface), ilk_txx_idx_stat1.u64);
+			ilk_txx_mem_stat1.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_STAT1(interface));
+
+			cvmx_dprintf("ILK%d Channel%d Tx: %d packets %d bytes\n", interface,
+				     *pstats->chan_list, ilk_txx_mem_stat0.s.tx_pkt,
+				     (unsigned int)ilk_txx_mem_stat1.s.tx_bytes);
+
+			pstats++;
+		}
+		return;
+	}
+
+	/* continuous channels */
+	ilk_rxx_idx_stat0.u64 = 0;
+	ilk_rxx_idx_stat0.s.index = pstats->chan_start;
+	ilk_rxx_idx_stat0.s.inc = pstats->chan_step;
+	ilk_rxx_idx_stat0.s.clr = pstats->clr_on_rd;
+	cvmx_write_csr(CVMX_ILK_RXX_IDX_STAT0(interface), ilk_rxx_idx_stat0.u64);
+
+	ilk_rxx_idx_stat1.u64 = 0;
+	ilk_rxx_idx_stat1.s.index = pstats->chan_start;
+	ilk_rxx_idx_stat1.s.inc = pstats->chan_step;
+	ilk_rxx_idx_stat1.s.clr = pstats->clr_on_rd;
+	cvmx_write_csr(CVMX_ILK_RXX_IDX_STAT1(interface), ilk_rxx_idx_stat1.u64);
+
+	ilk_txx_idx_stat0.u64 = 0;
+	ilk_txx_idx_stat0.s.index = pstats->chan_start;
+	ilk_txx_idx_stat0.s.inc = pstats->chan_step;
+	ilk_txx_idx_stat0.s.clr = pstats->clr_on_rd;
+	cvmx_write_csr(CVMX_ILK_TXX_IDX_STAT0(interface), ilk_txx_idx_stat0.u64);
+
+	ilk_txx_idx_stat1.u64 = 0;
+	ilk_txx_idx_stat1.s.index = pstats->chan_start;
+	ilk_txx_idx_stat1.s.inc = pstats->chan_step;
+	ilk_txx_idx_stat1.s.clr = pstats->clr_on_rd;
+	cvmx_write_csr(CVMX_ILK_TXX_IDX_STAT1(interface), ilk_txx_idx_stat1.u64);
+
+	for (i = pstats->chan_start; i <= pstats->chan_end; i += pstats->chan_step) {
+		ilk_rxx_mem_stat0.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_STAT0(interface));
+		ilk_rxx_mem_stat1.u64 = cvmx_read_csr(CVMX_ILK_RXX_MEM_STAT1(interface));
+		cvmx_dprintf("ILK%d Channel%d Rx: %d packets %d bytes\n", interface, i, ilk_rxx_mem_stat0.s.rx_pkt, (unsigned int)ilk_rxx_mem_stat1.s.rx_bytes);
+
+		ilk_txx_mem_stat0.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_STAT0(interface));
+		ilk_txx_mem_stat1.u64 = cvmx_read_csr(CVMX_ILK_TXX_MEM_STAT1(interface));
+		cvmx_dprintf("ILK%d Channel%d Tx: %d packets %d bytes\n", interface, i, ilk_rxx_mem_stat0.s.rx_pkt, (unsigned int)ilk_rxx_mem_stat1.s.rx_bytes);
+	}
+
+	return;
+}
+
+/**
+ * enable or disable loopbacks
+ *
+ * @interface: The identifier of the packet interface to disable. cn68xx
+ *                  has 2 interfaces: ilk0 and ilk1.
+ * @enable:    Enable or disable loopback
+ * @mode:      Internal or external loopback
+ *
+ * Returns Zero on success, negative of failure.
+ */
+int cvmx_ilk_lpbk(int interface, enum cvmx_ilk_lpbk_ena enable, enum cvmx_ilk_lpbk_mode mode)
+{
+	int res = -1;
+	union cvmx_ilk_txx_cfg0 ilk_txx_cfg0;
+	union cvmx_ilk_rxx_cfg0 ilk_rxx_cfg0;
+
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
+		return res;
+
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return res;
+
+	/* internal loopback. only 1 type of loopback can be on at 1 time */
+	if (mode == CVMX_ILK_LPBK_INT) {
+		if (enable == CVMX_ILK_LPBK_ENA) {
+			ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+			ilk_txx_cfg0.s.ext_lpbk = CVMX_ILK_LPBK_DISA;
+			ilk_txx_cfg0.s.ext_lpbk_fc = CVMX_ILK_LPBK_DISA;
+			cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+
+			ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+			ilk_rxx_cfg0.s.ext_lpbk = CVMX_ILK_LPBK_DISA;
+			ilk_rxx_cfg0.s.ext_lpbk_fc = CVMX_ILK_LPBK_DISA;
+			cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+		}
+
+		ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+		ilk_txx_cfg0.s.int_lpbk = enable;
+		cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+
+		res = 0;
+		return res;
+	}
+
+	/* external loopback. only 1 type of loopback can be on at 1 time */
+	if (enable == CVMX_ILK_LPBK_ENA) {
+		ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+		ilk_txx_cfg0.s.int_lpbk = CVMX_ILK_LPBK_DISA;
+		cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+	}
+
+	ilk_txx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_TXX_CFG0(interface));
+	ilk_txx_cfg0.s.ext_lpbk = enable;
+	ilk_txx_cfg0.s.ext_lpbk_fc = enable;
+	cvmx_write_csr(CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
+
+	ilk_rxx_cfg0.u64 = cvmx_read_csr(CVMX_ILK_RXX_CFG0(interface));
+	ilk_rxx_cfg0.s.ext_lpbk = enable;
+	ilk_rxx_cfg0.s.ext_lpbk_fc = enable;
+	cvmx_write_csr(CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
+
+	res = 0;
+	return res;
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ipd.c b/arch/mips/cavium-octeon/executive/cvmx-ipd.c
new file mode 100644
index 0000000..69f8fa3
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-ipd.c
@@ -0,0 +1,370 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * IPD Support.
+ */
+#include <linux/module.h>
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+
+#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-wqe.h>
+#include <asm/octeon/cvmx-ipd.h>
+#include <asm/octeon/cvmx-helper-errata.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+
+static void __cvmx_ipd_free_ptr_v1(void)
+{
+	unsigned wqe_pool = CVMX_FPA_WQE_POOL;
+	int i;
+	union cvmx_ipd_ptr_count ptr_count;
+	union cvmx_ipd_prc_port_ptr_fifo_ctl prc_port_fifo;
+
+	/* Only CN38XXp{1,2} cannot read pointer out of the IPD */
+	if (OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2))
+		return;
+
+	ptr_count.u64 = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
+
+	/* Handle Work Queue Entry in cn56xx and cn52xx */
+	if (octeon_has_feature(OCTEON_FEATURE_NO_WPTR)) {
+		union cvmx_ipd_ctl_status ctl_status;
+		ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+		if (ctl_status.s.no_wptr)
+			wqe_pool = CVMX_FPA_PACKET_POOL;
+	}
+
+	/* Free the prefetched WQE */
+	if (ptr_count.s.wqev_cnt) {
+		union cvmx_ipd_wqe_ptr_valid wqe_ptr_valid;
+		wqe_ptr_valid.u64 = cvmx_read_csr(CVMX_IPD_WQE_PTR_VALID);
+		cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)wqe_ptr_valid.s.ptr << 7),
+			      wqe_pool, 0);
+	}
+
+	/* Free all WQE in the fifo */
+	if (ptr_count.s.wqe_pcnt) {
+		int i;
+		union cvmx_ipd_pwp_ptr_fifo_ctl pwp_fifo;
+		pwp_fifo.u64 = cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
+		for (i = 0; i < ptr_count.s.wqe_pcnt; i++) {
+			pwp_fifo.s.cena = 0;
+			pwp_fifo.s.raddr = pwp_fifo.s.max_cnts + (pwp_fifo.s.wraddr + i) % pwp_fifo.s.max_cnts;
+			cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL, pwp_fifo.u64);
+			pwp_fifo.u64 = cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)pwp_fifo.s.ptr << 7),
+				      wqe_pool, 0);
+		}
+		pwp_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL, pwp_fifo.u64);
+	}
+
+	/* Free the prefetched packet */
+	if (ptr_count.s.pktv_cnt) {
+		union cvmx_ipd_pkt_ptr_valid pkt_ptr_valid;
+		pkt_ptr_valid.u64 = cvmx_read_csr(CVMX_IPD_PKT_PTR_VALID);
+		cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)pkt_ptr_valid.s.ptr << 7),
+			      CVMX_FPA_PACKET_POOL, 0);
+	}
+
+	/* Free the per port prefetched packets */
+	prc_port_fifo.u64 = cvmx_read_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL);
+
+	for (i = 0; i < prc_port_fifo.s.max_pkt; i++) {
+		prc_port_fifo.s.cena = 0;
+		prc_port_fifo.s.raddr = i % prc_port_fifo.s.max_pkt;
+		cvmx_write_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL,
+			       prc_port_fifo.u64);
+		prc_port_fifo.u64 = cvmx_read_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL);
+		cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)prc_port_fifo.s.ptr << 7),
+			      CVMX_FPA_PACKET_POOL, 0);
+	}
+	prc_port_fifo.s.cena = 1;
+	cvmx_write_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL, prc_port_fifo.u64);
+
+	/* Free all packets in the holding fifo */
+	if (ptr_count.s.pfif_cnt) {
+		int i;
+		union cvmx_ipd_prc_hold_ptr_fifo_ctl prc_hold_fifo;
+
+		prc_hold_fifo.u64 = cvmx_read_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL);
+
+		for (i = 0; i < ptr_count.s.pfif_cnt; i++) {
+			prc_hold_fifo.s.cena = 0;
+			prc_hold_fifo.s.raddr = (prc_hold_fifo.s.praddr + i) % prc_hold_fifo.s.max_pkt;
+			cvmx_write_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL,
+				       prc_hold_fifo.u64);
+			prc_hold_fifo.u64 = cvmx_read_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL);
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)prc_hold_fifo.s.ptr << 7),
+				      CVMX_FPA_PACKET_POOL, 0);
+		}
+		prc_hold_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL,
+			       prc_hold_fifo.u64);
+	}
+
+	/* Free all packets in the fifo */
+	if (ptr_count.s.pkt_pcnt) {
+		int i;
+		union cvmx_ipd_pwp_ptr_fifo_ctl pwp_fifo;
+		pwp_fifo.u64 = cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
+
+		for (i = 0; i < ptr_count.s.pkt_pcnt; i++) {
+			pwp_fifo.s.cena = 0;
+			pwp_fifo.s.raddr = (pwp_fifo.s.praddr + i) % pwp_fifo.s.max_cnts;
+			cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL, pwp_fifo.u64);
+			pwp_fifo.u64 = cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)pwp_fifo.s.ptr << 7),
+				      CVMX_FPA_PACKET_POOL, 0);
+		}
+		pwp_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL, pwp_fifo.u64);
+	}
+}
+
+static void __cvmx_ipd_free_ptr_v2(void)
+{
+	int no_wptr = 0;
+	int i;
+	union cvmx_ipd_port_ptr_fifo_ctl port_ptr_fifo;
+	union cvmx_ipd_ptr_count ptr_count;
+	ptr_count.u64 = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
+
+	/* Handle Work Queue Entry in cn68xx */
+	if (octeon_has_feature(OCTEON_FEATURE_NO_WPTR)) {
+		union cvmx_ipd_ctl_status ctl_status;
+		ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+		if (ctl_status.s.no_wptr)
+			no_wptr = 1;
+	}
+
+	/* Free the prefetched WQE */
+	if (ptr_count.s.wqev_cnt) {
+		union cvmx_ipd_next_wqe_ptr next_wqe_ptr;
+		next_wqe_ptr.u64 = cvmx_read_csr(CVMX_IPD_NEXT_WQE_PTR);
+		if (no_wptr)
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)next_wqe_ptr.s.ptr << 7),
+				      CVMX_FPA_PACKET_POOL, 0);
+		else
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)next_wqe_ptr.s.ptr << 7),
+				      CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* Free all WQE in the fifo */
+	if (ptr_count.s.wqe_pcnt) {
+		union cvmx_ipd_free_ptr_fifo_ctl free_fifo;
+		union cvmx_ipd_free_ptr_value free_ptr_value;
+		free_fifo.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_FIFO_CTL);
+		for (i = 0; i < ptr_count.s.wqe_pcnt; i++) {
+			free_fifo.s.cena = 0;
+			free_fifo.s.raddr = free_fifo.s.max_cnts + (free_fifo.s.wraddr + i) % free_fifo.s.max_cnts;
+			cvmx_write_csr(CVMX_IPD_FREE_PTR_FIFO_CTL,
+				       free_fifo.u64);
+			free_fifo.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_FIFO_CTL);
+			free_ptr_value.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_VALUE);
+			if (no_wptr)
+				cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)free_ptr_value.s.ptr << 7),
+					      CVMX_FPA_PACKET_POOL, 0);
+			else
+				cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)free_ptr_value.s.ptr << 7),
+					      CVMX_FPA_WQE_POOL, 0);
+		}
+		free_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_FREE_PTR_FIFO_CTL, free_fifo.u64);
+	}
+
+	/* Free the prefetched packet */
+	if (ptr_count.s.pktv_cnt) {
+		union cvmx_ipd_next_pkt_ptr next_pkt_ptr;
+		next_pkt_ptr.u64 = cvmx_read_csr(CVMX_IPD_NEXT_PKT_PTR);
+		cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)next_pkt_ptr.s.ptr << 7),
+			      CVMX_FPA_PACKET_POOL, 0);
+	}
+
+	/* Free the per port prefetched packets */
+	port_ptr_fifo.u64 = cvmx_read_csr(CVMX_IPD_PORT_PTR_FIFO_CTL);
+
+	for (i = 0; i < port_ptr_fifo.s.max_pkt; i++) {
+		port_ptr_fifo.s.cena = 0;
+		port_ptr_fifo.s.raddr = i % port_ptr_fifo.s.max_pkt;
+		cvmx_write_csr(CVMX_IPD_PORT_PTR_FIFO_CTL, port_ptr_fifo.u64);
+		port_ptr_fifo.u64 = cvmx_read_csr(CVMX_IPD_PORT_PTR_FIFO_CTL);
+		cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)port_ptr_fifo.s.ptr << 7),
+			      CVMX_FPA_PACKET_POOL, 0);
+	}
+	port_ptr_fifo.s.cena = 1;
+	cvmx_write_csr(CVMX_IPD_PORT_PTR_FIFO_CTL, port_ptr_fifo.u64);
+
+	/* Free all packets in the holding fifo */
+	if (ptr_count.s.pfif_cnt) {
+		union cvmx_ipd_hold_ptr_fifo_ctl hold_ptr_fifo;
+
+		hold_ptr_fifo.u64 = cvmx_read_csr(CVMX_IPD_HOLD_PTR_FIFO_CTL);
+
+		for (i = 0; i < ptr_count.s.pfif_cnt; i++) {
+			hold_ptr_fifo.s.cena = 0;
+			hold_ptr_fifo.s.raddr = (hold_ptr_fifo.s.praddr + i) % hold_ptr_fifo.s.max_pkt;
+			cvmx_write_csr(CVMX_IPD_HOLD_PTR_FIFO_CTL,
+				       hold_ptr_fifo.u64);
+			hold_ptr_fifo.u64 = cvmx_read_csr(CVMX_IPD_HOLD_PTR_FIFO_CTL);
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)hold_ptr_fifo.s.ptr << 7),
+				      CVMX_FPA_PACKET_POOL, 0);
+		}
+		hold_ptr_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_HOLD_PTR_FIFO_CTL, hold_ptr_fifo.u64);
+	}
+
+	/* Free all packets in the fifo */
+	if (ptr_count.s.pkt_pcnt) {
+		union cvmx_ipd_free_ptr_fifo_ctl free_fifo;
+		union cvmx_ipd_free_ptr_value free_ptr_value;
+		free_fifo.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_FIFO_CTL);
+
+		for (i = 0; i < ptr_count.s.pkt_pcnt; i++) {
+			free_fifo.s.cena = 0;
+			free_fifo.s.raddr = (free_fifo.s.praddr + i) % free_fifo.s.max_cnts;
+			cvmx_write_csr(CVMX_IPD_FREE_PTR_FIFO_CTL,
+				       free_fifo.u64);
+			free_fifo.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_FIFO_CTL);
+			free_ptr_value.u64 = cvmx_read_csr(CVMX_IPD_FREE_PTR_VALUE);
+			cvmx_fpa_free(cvmx_phys_to_ptr((uint64_t)free_ptr_value.s.ptr << 7),
+				      CVMX_FPA_PACKET_POOL, 0);
+		}
+		free_fifo.s.cena = 1;
+		cvmx_write_csr(CVMX_IPD_FREE_PTR_FIFO_CTL, free_fifo.u64);
+	}
+}
+
+/**
+ * This function is called by cvmx_helper_shutdown() to extract
+ * all FPA buffers out of the IPD and PIP. After this function
+ * completes, all FPA buffers that were prefetched by IPD and PIP
+ * wil be in the apropriate FPA pool. This functions does not reset
+ * PIP or IPD as FPA pool zero must be empty before the reset can
+ * be performed. WARNING: It is very important that IPD and PIP be
+ * reset soon after a call to this function.
+ */
+void __cvmx_ipd_free_ptr(void)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		__cvmx_ipd_free_ptr_v2();
+	else
+		__cvmx_ipd_free_ptr_v1();
+}
+
+void cvmx_ipd_config(uint64_t mbuff_size,
+		     uint64_t first_mbuff_skip,
+		     uint64_t not_first_mbuff_skip,
+		     uint64_t first_back, uint64_t second_back,
+		     uint64_t wqe_fpa_pool, uint64_t cache_mode,
+		     uint64_t back_pres_enable_flag)
+{
+	union cvmx_ipd_1st_mbuff_skip first_skip;
+	union cvmx_ipd_1st_mbuff_skip not_first_skip;
+	union cvmx_ipd_packet_mbuff_size size;
+	union cvmx_ipd_1st_next_ptr_back first_back_struct;
+	union cvmx_ipd_1st_next_ptr_back second_back_struct;
+	union cvmx_ipd_wqe_fpa_queue wqe_pool;
+	union cvmx_ipd_ctl_status ipd_ctl_reg;
+
+	first_skip.u64 = 0;
+	first_skip.s.skip_sz = first_mbuff_skip;
+	cvmx_write_csr(CVMX_IPD_1ST_MBUFF_SKIP, first_skip.u64);
+
+	not_first_skip.u64 = 0;
+	not_first_skip.s.skip_sz = not_first_mbuff_skip;
+	cvmx_write_csr(CVMX_IPD_NOT_1ST_MBUFF_SKIP, not_first_skip.u64);
+
+	size.u64 = 0;
+	size.s.mb_size = mbuff_size;
+	cvmx_write_csr(CVMX_IPD_PACKET_MBUFF_SIZE, size.u64);
+
+	first_back_struct.u64 = 0;
+	first_back_struct.s.back = first_back;
+	cvmx_write_csr(CVMX_IPD_1st_NEXT_PTR_BACK, first_back_struct.u64);
+
+	second_back_struct.u64 = 0;
+	second_back_struct.s.back = second_back;
+	cvmx_write_csr(CVMX_IPD_2nd_NEXT_PTR_BACK, second_back_struct.u64);
+
+	wqe_pool.u64 = 0;
+	wqe_pool.s.wqe_pool = wqe_fpa_pool;
+	cvmx_write_csr(CVMX_IPD_WQE_FPA_QUEUE, wqe_pool.u64);
+
+	ipd_ctl_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_reg.s.opc_mode = cache_mode;
+	ipd_ctl_reg.s.pbp_en = back_pres_enable_flag;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_reg.u64);
+
+	/* Note: the example RED code that used to be here has been moved to
+	   cvmx_helper_setup_red */
+}
+
+/**
+ * Enable IPD
+ */
+void cvmx_ipd_enable(void)
+{
+	union cvmx_ipd_ctl_status ipd_reg;
+
+	ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+
+	/*
+	 * busy-waiting for rst_done in o68
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		while (ipd_reg.s.rst_done != 0)
+			ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+
+	if (ipd_reg.s.ipd_en)
+		cvmx_dprintf("Warning: Enabling IPD when IPD already enabled.\n");
+
+	ipd_reg.s.ipd_en = 1;
+
+#if  CVMX_ENABLE_LEN_M8_FIX
+	if (!OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2))
+		ipd_reg.s.len_m8 = 1;
+#endif
+
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_reg.u64);
+}
+EXPORT_SYMBOL(cvmx_ipd_enable);
+
+/**
+ * Disable IPD
+ */
+void cvmx_ipd_disable(void)
+{
+	union cvmx_ipd_ctl_status ipd_reg;
+	ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_reg.s.ipd_en = 0;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_reg.u64);
+}
+EXPORT_SYMBOL(cvmx_ipd_disable);
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index d38246e..abf61e6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -276,7 +276,6 @@ uint64_t cvmx_l2c_read_perf(uint32_t counter)
 }
 
 /**
- * @INTERNAL
  * Helper function use to fault in cache lines for L2 cache locking
  *
  * @addr:   Address of base of memory region to read into L2 cache
@@ -562,7 +561,6 @@ union __cvmx_l2c_tag {
 
 
 /**
- * @INTERNAL
  * Function to read a L2C tag.  This code make the current core
  * the 'debug core' for the L2.  This code must only be executed by
  * 1 core at a time.
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko.c b/arch/mips/cavium-octeon/executive/cvmx-pko.c
index f557084..dd9b2fe 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,22 +22,440 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
  * Support library for the hardware Packet Output unit.
  */
+#include <linux/export.h>
 
 #include <asm/octeon/octeon.h>
-
 #include <asm/octeon/cvmx-config.h>
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+
+/* #define PKO_DEBUG */
+
+#define CVMX_PKO_NQ_PER_PORT_MAX	32
+
+/*
+ * PKO port iterator
+ */
+
+#define pko_for_each_port(__p)						\
+	for (__p = 0; __p < CVMX_HELPER_CFG_MAX_PKO_PORT; __p++)	\
+		if (__cvmx_helper_cfg_pko_queue_base(__p) != CVMX_HELPER_CFG_INVALID_VALUE)
+
+/*
+ *
+ * Get INT for a port
+ *
+ * @interface:
+ * @index:
+ * Returns the INT value on success and -1 on error
+ */
+static int __cvmx_pko_int(int interface, int index)
+{
+	switch (interface) {
+	case 0:
+		return index;
+	case 1:
+		return 4;
+	case 2:
+		return index + 8;
+	case 3:
+		return index + 0xC;
+	case 4:
+		return index + 0x10;
+	case 5:
+		return 0x1C;
+	case 6:
+		return 0x1D;
+	case 7:
+		return 0x1E;
+	case 8:
+		return 0x1F;
+	}
+
+	return -1;
+}
+
+int cvmx_pko_get_base_pko_port(int interface, int index)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pko_port_base(interface, index);
+	else
+		return cvmx_helper_get_ipd_port(interface, index);
+}
+EXPORT_SYMBOL(cvmx_pko_get_base_pko_port);
+
+int cvmx_pko_get_num_pko_ports(int interface, int index)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pko_port_num(interface, index);
+	else
+		return 1;
+}
+EXPORT_SYMBOL(cvmx_pko_get_num_pko_ports);
+
+int cvmx_pko_get_base_queue(int port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pko_queue_base(cvmx_helper_cfg_ipd2pko_port_base(port));
+	else
+		return cvmx_pko_get_base_queue_per_core(port, 0);
+}
+EXPORT_SYMBOL(cvmx_pko_get_base_queue);
+
+/**
+ * For a given PKO port number, return the base output queue
+ * for the port.
+ *
+ * @pko_port:   PKO port number
+ * Returns           Base output queue
+ */
+int cvmx_pko_get_base_queue_pkoid(int pko_port)
+{
+	return __cvmx_helper_cfg_pko_queue_base(pko_port);
+}
 
 /**
- * Internal state of packet output
+ * For a given PKO port number, return the number of output queues
+ * for the port.
+ *
+ * @pko_port:	PKO port number
+ * Returns		the number of output queues
  */
+int cvmx_pko_get_num_queues_pkoid(int pko_port)
+{
+	return __cvmx_helper_cfg_pko_queue_num(pko_port);
+}
+
+int cvmx_pko_get_num_queues(int port)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		return __cvmx_helper_cfg_pko_queue_num(cvmx_helper_cfg_ipd2pko_port_base(port));
+	} else {
+		if (port < 16)
+			return CVMX_PKO_QUEUES_PER_PORT_INTERFACE0;
+		else if (port < 32)
+			return CVMX_PKO_QUEUES_PER_PORT_INTERFACE1;
+		else if (port < 36)
+			return CVMX_PKO_QUEUES_PER_PORT_PCI;
+		else if (port < 40)
+			return CVMX_PKO_QUEUES_PER_PORT_LOOP;
+		else if (port < 42)
+			return CVMX_PKO_QUEUES_PER_PORT_SRIO0;
+		else if (port < 44)
+			return CVMX_PKO_QUEUES_PER_PORT_SRIO1;
+		else if (port < 46)
+			return CVMX_PKO_QUEUES_PER_PORT_SRIO2;
+		else if (port < 48)
+			return CVMX_PKO_QUEUES_PER_PORT_SRIO3;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_pko_get_num_queues);
+
+#ifdef PKO_DEBUG
+/**
+ * Show queues for the internal ports
+ */
+void cvmx_pko_show_queue_map(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		int port;
+		pko_for_each_port(port) {
+			cvmx_dprintf("pko_port %d (interface%d index%d) has %d queues (queue base = %d)\n",
+				     port,
+				     __cvmx_helper_cfg_pko_port_interface(port),
+				     __cvmx_helper_cfg_pko_port_index(port), __cvmx_helper_cfg_pko_queue_num(port), __cvmx_helper_cfg_pko_queue_base(port));
+		}
+	} else {
+		int core, port;
+		int pko_output_ports;
+
+		pko_output_ports = 36;
+		cvmx_dprintf("port");
+		for (port = 0; port < pko_output_ports; port++)
+			cvmx_dprintf("%3d ", port);
+		cvmx_dprintf("\n");
+
+		for (core = 0; core < CVMX_MAX_CORES; core++) {
+			cvmx_dprintf("\n%2d: ", core);
+			for (port = 0; port < pko_output_ports; port++)
+				cvmx_dprintf("%3d ", cvmx_pko_get_base_queue_per_core(port, core));
+		}
+		cvmx_dprintf("\n");
+	}
+}
+#endif /* PKO_DEBUG */
+
+/*
+ * Configure queues for an internal port.
+ * @pko_port: PKO internal port number
+ * Note: o68 only
+ */
+static void __cvmx_pko_iport_config(int pko_port)
+{
+	int queue, base_queue, num_queues;
+	int static_priority_base;
+	int static_priority_end;
+	union cvmx_pko_mem_iqueue_ptrs config;
+	uint64_t *buf_ptr = NULL;
+	uint64_t priorities[CVMX_PKO_NQ_PER_PORT_MAX] = {
+		[0 ... CVMX_PKO_NQ_PER_PORT_MAX - 1] = 8
+	};
+
+	static_priority_base = -1;
+	static_priority_end = -1;
+	base_queue = __cvmx_helper_cfg_pko_queue_base(pko_port);
+	num_queues = __cvmx_helper_cfg_pko_queue_num(pko_port);
+
+	/*
+	 * Give the user a chance to override the per queue priorities.
+	 */
+	if (cvmx_override_pko_queue_priority)
+		cvmx_override_pko_queue_priority(pko_port, &priorities[0]);
+
+	/*
+	 * static queue priority validation
+	 */
+	for (queue = 0; queue < num_queues; queue++) {
+		if (static_priority_base == -1 && priorities[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY)
+			static_priority_base = queue;
+
+		if (static_priority_base != -1 && static_priority_end == -1 && priorities[queue] != CVMX_PKO_QUEUE_STATIC_PRIORITY && queue)
+			static_priority_end = queue - 1;
+		else if (static_priority_base != -1 && static_priority_end == -1 && queue == num_queues - 1)
+			static_priority_end = queue;	/* all queues are static priority */
+
+		/*
+		 * Check to make sure all static priority queues are contiguous.
+		 * Also catches some cases of static priorites not starting from
+		 * queue 0.
+		 */
+		if (static_priority_end != -1 && (int)queue > static_priority_end && priorities[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY) {
+			cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Static priority queues aren't contiguous or don't start at base queue. q: %d, eq: %d\n",
+				     (int)queue, static_priority_end);
+		}
+		if (static_priority_base > 0) {
+			cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Static priority queues don't start at base queue. sq: %d\n",
+				     static_priority_base);
+		}
+	}
+
+	/*
+	 * main loop to set the fields of CVMX_PKO_MEM_IQUEUE_PTRS for
+	 * each queue
+	 */
+	for (queue = 0; queue < num_queues; queue++) {
+		config.u64 = 0;
+		config.s.index = queue;
+		config.s.qid = base_queue + queue;
+		config.s.ipid = pko_port;
+		config.s.tail = (queue == (num_queues - 1));
+		config.s.s_tail = (queue == static_priority_end);
+		config.s.static_p = (static_priority_base >= 0);
+		config.s.static_q = (queue <= static_priority_end);
+
+		/*
+		 * Convert the priority into an enable bit field.
+		 * Try to space the bits out evenly so the packet
+		 * don't get grouped up.
+		 */
+		switch ((int)priorities[queue]) {
+		case 0:
+			config.s.qos_mask = 0x00;
+			break;
+		case 1:
+			config.s.qos_mask = 0x01;
+			break;
+		case 2:
+			config.s.qos_mask = 0x11;
+			break;
+		case 3:
+			config.s.qos_mask = 0x49;
+			break;
+		case 4:
+			config.s.qos_mask = 0x55;
+			break;
+		case 5:
+			config.s.qos_mask = 0x57;
+			break;
+		case 6:
+			config.s.qos_mask = 0x77;
+			break;
+		case 7:
+			config.s.qos_mask = 0x7f;
+			break;
+		case 8:
+			config.s.qos_mask = 0xff;
+			break;
+		case CVMX_PKO_QUEUE_STATIC_PRIORITY:
+			config.s.qos_mask = 0xff;
+			break;
+		default:
+			cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Invalid priority %llu\n",
+				     (unsigned long long)priorities[queue]);
+			config.s.qos_mask = 0xff;
+			break;
+		}
+
+		/*
+		 * The command queues
+		 */
+		{
+			cvmx_cmd_queue_result_t cmd_res;
+
+			cmd_res = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_PKO(base_queue + queue),
+							    CVMX_PKO_MAX_QUEUE_DEPTH,
+							    CVMX_FPA_OUTPUT_BUFFER_POOL,
+							    (CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE - CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST * 8));
+
+			if (cmd_res != CVMX_CMD_QUEUE_SUCCESS) {
+				switch (cmd_res) {
+				case CVMX_CMD_QUEUE_NO_MEMORY:
+					cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Unable to allocate output buffer.");
+					break;
+				case CVMX_CMD_QUEUE_ALREADY_SETUP:
+					cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Port already setup");
+					break;
+				case CVMX_CMD_QUEUE_INVALID_PARAM:
+				default:
+					cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Command queue initialization failed.");
+					break;
+				}
+				cvmx_dprintf(" pko_port%d base_queue%d num_queues%d queue%d.\n",
+					     pko_port, base_queue, num_queues, queue);
+			}
+
+			buf_ptr = (uint64_t *) cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_PKO(base_queue + queue));
+			config.s.buf_ptr = cvmx_ptr_to_phys(buf_ptr) >> 7;
+		}
+
+		CVMX_SYNCWS;
+		cvmx_write_csr(CVMX_PKO_MEM_IQUEUE_PTRS, config.u64);
+	}
+}
+
+/*
+ * Allocate queues for the PKO internal ports.
+ *
+ */
+static void __cvmx_pko_queue_alloc_o68(void)
+{
+	int port;
+
+	pko_for_each_port(port) {
+		__cvmx_pko_iport_config(port);
+	}
+
+}
+
+/*
+ * Allocate memory for PKO engines.
+ *
+ * @engine: is the PKO engine ID.
+ * Returns # of 2KB-chunks allocated to this PKO engine.
+ */
+static int __cvmx_pko_memory_per_engine_o68(int engine)
+{
+	/* CN68XX has 40KB to devide between the engines in 2KB chunks */
+	int max_engine;
+	int size_per_engine;
+	int size;
+
+	max_engine = __cvmx_helper_cfg_pko_max_engine();
+	size_per_engine = 40 / 2 / max_engine;
+
+	if (engine >= max_engine)
+		/* Unused engines get no space */
+		size = 0;
+	else if (engine == max_engine - 1)
+		/*
+		 * The last engine gets all the space lost by rounding. This means
+		 * the ILK gets the most space
+		 */
+		size = 40 / 2 - engine * size_per_engine;
+	else
+		/* All other engines get the same space */
+		size = size_per_engine;
+
+	return size;
+}
+
+/*
+ * Setup one-to-one mapping between PKO iport and eport.
+ */
+static void __cvmx_pko_port_map_o68(void)
+{
+	int i;
+	int interface, index, port;
+	cvmx_helper_interface_mode_t mode;
+	union cvmx_pko_mem_iport_ptrs config;
+
+	/*
+	 * Initialize every iport with the invalid eid.
+	 */
+#define CVMX_O68_PKO_INVALID_EID	31
+	config.u64 = 0;
+	config.s.eid = CVMX_O68_PKO_INVALID_EID;
+	for (i = 0; i < CVMX_HELPER_CFG_MAX_PKO_PORT; i++) {
+		config.s.ipid = i;
+		cvmx_write_csr(CVMX_PKO_MEM_IPORT_PTRS, config.u64);
+	}
+
+	/*
+	 * Set up PKO_MEM_IPORT_PTRS
+	 */
+	pko_for_each_port(port) {
+		interface = __cvmx_helper_cfg_pko_port_interface(port);
+		index = __cvmx_helper_cfg_pko_port_index(port);
+		mode = cvmx_helper_interface_get_mode(interface);
+
+		if (mode == CVMX_HELPER_INTERFACE_MODE_DISABLED)
+			continue;
+
+		config.s.ipid = port;
+		config.s.qos_mask = 0xff;
+		config.s.crc = __cvmx_helper_get_has_fcs(interface);
+		config.s.min_pkt = __cvmx_helper_get_pko_padding(interface);
+		config.s.intr = __cvmx_pko_int(interface, index);
+		config.s.eid = __cvmx_helper_cfg_pko_port_eid(port);
+		config.s.pipe = (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) ? index : port;
+		cvmx_write_csr(CVMX_PKO_MEM_IPORT_PTRS, config.u64);
+	}
+}
+
+int __cvmx_pko_get_pipe(int interface, int index)
+{
+	/* The loopback ports do not have pipes */
+	if (cvmx_helper_interface_get_mode(interface) == CVMX_HELPER_INTERFACE_MODE_LOOP)
+		return -1;
+	/* We use pko_port as the pipe. See __cvmx_pko_port_map_o68(). */
+	return cvmx_helper_get_pko_port(interface, index);
+}
+
+/*
+ * chip-specific setup
+ */
+static void __cvmx_pko_chip_init(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		__cvmx_pko_port_map_o68();
+		__cvmx_pko_queue_alloc_o68();
+	} else {
+		int i;
+		uint64_t priority = 8;
+
+		/*Initialize queues. */
+		for (i = 0; i < CVMX_PKO_MAX_OUTPUT_QUEUES; i++)
+			cvmx_pko_config_port(CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID, i, 1, &priority);
+	}
+}
 
 /**
  * Call before any other calls to initialize the packet
@@ -47,48 +465,85 @@
 
 void cvmx_pko_initialize_global(void)
 {
-	int i;
-	uint64_t priority = 8;
 	union cvmx_pko_reg_cmd_buf config;
+	int i;
 
 	/*
 	 * Set the size of the PKO command buffers to an odd number of
 	 * 64bit words. This allows the normal two word send to stay
-	 * aligned and never span a comamnd word buffer.
+	 * aligned and never span a command word buffer.
 	 */
 	config.u64 = 0;
 	config.s.pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
 	config.s.size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE / 8 - 1;
-
 	cvmx_write_csr(CVMX_PKO_REG_CMD_BUF, config.u64);
 
-	for (i = 0; i < CVMX_PKO_MAX_OUTPUT_QUEUES; i++)
-		cvmx_pko_config_port(CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID, i, 1,
-				     &priority);
+	/* chip-specific setup. */
+	__cvmx_pko_chip_init();
 
 	/*
 	 * If we aren't using all of the queues optimize PKO's
 	 * internal memory.
 	 */
-	if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)
-	    || OCTEON_IS_MODEL(OCTEON_CN56XX)
-	    || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
-		int num_interfaces = cvmx_helper_get_number_of_interfaces();
-		int last_port =
-		    cvmx_helper_get_last_ipd_port(num_interfaces - 1);
-		int max_queues =
-		    cvmx_pko_get_base_queue(last_port) +
-		    cvmx_pko_get_num_queues(last_port);
+	if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
+		int num_interfaces;
+		int last_port;
+		int max_queues;
+
+		if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+			max_queues = __cvmx_helper_cfg_pko_max_queue();
+		} else {
+			num_interfaces = cvmx_helper_get_number_of_interfaces();
+			last_port = cvmx_helper_get_last_ipd_port(num_interfaces - 1);
+			max_queues = cvmx_pko_get_base_queue(last_port) + cvmx_pko_get_num_queues(last_port);
+		}
+
 		if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {
 			if (max_queues <= 32)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);
 			else if (max_queues <= 64)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);
+			else
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 0);
 		} else {
-			if (max_queues <= 64)
+			if (OCTEON_IS_MODEL(OCTEON_CN68XX) && max_queues <= 32)
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 3);
+			else if (max_queues <= 64)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);
 			else if (max_queues <= 128)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);
+			else
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 0);
+			if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+				for (i = 0; i < 2; i++) {
+					union cvmx_pko_reg_engine_storagex engine_storage;
+
+#define PKO_ASSIGN_ENGINE_STORAGE(index)				\
+	engine_storage.s.engine##index = \
+		__cvmx_pko_memory_per_engine_o68(16 * i + (index))
+
+					engine_storage.u64 = 0;
+					PKO_ASSIGN_ENGINE_STORAGE(0);
+					PKO_ASSIGN_ENGINE_STORAGE(1);
+					PKO_ASSIGN_ENGINE_STORAGE(2);
+					PKO_ASSIGN_ENGINE_STORAGE(3);
+					PKO_ASSIGN_ENGINE_STORAGE(4);
+					PKO_ASSIGN_ENGINE_STORAGE(5);
+					PKO_ASSIGN_ENGINE_STORAGE(6);
+					PKO_ASSIGN_ENGINE_STORAGE(7);
+					PKO_ASSIGN_ENGINE_STORAGE(8);
+					PKO_ASSIGN_ENGINE_STORAGE(9);
+					PKO_ASSIGN_ENGINE_STORAGE(10);
+					PKO_ASSIGN_ENGINE_STORAGE(11);
+					PKO_ASSIGN_ENGINE_STORAGE(12);
+					PKO_ASSIGN_ENGINE_STORAGE(13);
+					PKO_ASSIGN_ENGINE_STORAGE(14);
+					PKO_ASSIGN_ENGINE_STORAGE(15);
+					cvmx_write_csr(CVMX_PKO_REG_ENGINE_STORAGEX(i), engine_storage.u64);
+				}
+			}
 		}
 	}
 }
@@ -117,13 +572,12 @@ void cvmx_pko_enable(void)
 
 	flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
 	if (flags.s.ena_pko)
-		cvmx_dprintf
-		    ("Warning: Enabling PKO when PKO already enabled.\n");
+		cvmx_dprintf("Warning: Enabling PKO when PKO already enabled.\n");
 
-	flags.s.ena_dwb = 1;
+	flags.s.ena_dwb = cvmx_helper_cfg_opt_get(CVMX_HELPER_CFG_OPT_USE_DWB);
 	flags.s.ena_pko = 1;
 	/*
-	 * always enable big endian for 3-word command. Does nothing
+	 * always enable big endian for 3-word command.  Does nothing
 	 * for 2-word.
 	 */
 	flags.s.store_be = 1;
@@ -141,7 +595,6 @@ void cvmx_pko_disable(void)
 	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
 }
 
-
 /**
  * Reset the packet output.
  */
@@ -158,28 +611,39 @@ static void __cvmx_pko_reset(void)
  */
 void cvmx_pko_shutdown(void)
 {
-	union cvmx_pko_mem_queue_ptrs config;
 	int queue;
 
 	cvmx_pko_disable();
 
-	for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		union cvmx_pko_mem_iqueue_ptrs config;
 		config.u64 = 0;
-		config.s.tail = 1;
-		config.s.index = 0;
-		config.s.port = CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID;
-		config.s.queue = queue & 0x7f;
-		config.s.qos_mask = 0;
-		config.s.buf_ptr = 0;
-		if (!OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
-			union cvmx_pko_reg_queue_ptrs1 config1;
-			config1.u64 = 0;
-			config1.s.qid7 = queue >> 7;
-			cvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);
+		for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+			config.s.qid = queue;
+			cvmx_write_csr(CVMX_PKO_MEM_IQUEUE_PTRS, config.u64);
+			cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
+		}
+	} else {
+		union cvmx_pko_mem_queue_ptrs config;
+		for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+			config.u64 = 0;
+			config.s.tail = 1;
+			config.s.index = 0;
+			config.s.port = CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID;
+			config.s.queue = queue & 0x7f;
+			config.s.qos_mask = 0;
+			config.s.buf_ptr = 0;
+			if (!OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+				union cvmx_pko_reg_queue_ptrs1 config1;
+				config1.u64 = 0;
+				config1.s.qid7 = queue >> 7;
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);
+			}
+			cvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);
+			cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
 		}
-		cvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);
-		cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
 	}
+
 	__cvmx_pko_reset();
 }
 
@@ -200,28 +664,30 @@ void cvmx_pko_shutdown(void)
  *                   queues have higher priority than higher numbered queues.
  *                   There must be num_queues elements in the array.
  */
-cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
-				       uint64_t num_queues,
-				       const uint64_t priority[])
+enum cvmx_pko_status cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
+					  uint64_t num_queues,
+					  const uint64_t priority[])
 {
-	cvmx_pko_status_t result_code;
+	enum cvmx_pko_status result_code;
 	uint64_t queue;
 	union cvmx_pko_mem_queue_ptrs config;
 	union cvmx_pko_reg_queue_ptrs1 config1;
 	int static_priority_base = -1;
 	int static_priority_end = -1;
 
-	if ((port >= CVMX_PKO_NUM_OUTPUT_PORTS)
-	    && (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return CVMX_PKO_SUCCESS;
+
+	if ((port >= CVMX_PKO_NUM_OUTPUT_PORTS) &&
+	    (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID)) {
 		cvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid port %llu\n",
 			     (unsigned long long)port);
 		return CVMX_PKO_INVALID_PORT;
 	}
 
 	if (base_queue + num_queues > CVMX_PKO_MAX_OUTPUT_QUEUES) {
-		cvmx_dprintf
-		    ("ERROR: cvmx_pko_config_port: Invalid queue range %llu\n",
-		     (unsigned long long)(base_queue + num_queues));
+		cvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid queue range %llu\n",
+			     (unsigned long long)(base_queue + num_queues));
 		return CVMX_PKO_INVALID_QUEUE;
 	}
 
@@ -233,64 +699,51 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 		 */
 		for (queue = 0; queue < num_queues; queue++) {
 			/* Find first queue of static priority */
-			if (static_priority_base == -1
-			    && priority[queue] ==
-			    CVMX_PKO_QUEUE_STATIC_PRIORITY)
+			if (static_priority_base == -1 && priority[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY)
 				static_priority_base = queue;
 			/* Find last queue of static priority */
-			if (static_priority_base != -1
-			    && static_priority_end == -1
-			    && priority[queue] != CVMX_PKO_QUEUE_STATIC_PRIORITY
-			    && queue)
+			if (static_priority_base != -1 &&
+			    static_priority_end == -1 &&
+			    priority[queue] != CVMX_PKO_QUEUE_STATIC_PRIORITY &&
+			    queue)
 				static_priority_end = queue - 1;
-			else if (static_priority_base != -1
-				 && static_priority_end == -1
-				 && queue == num_queues - 1)
-				/* all queues are static priority */
+			else if (static_priority_base != -1 &&
+				 static_priority_end == -1 &&
+				 queue == num_queues - 1)
+				/* all queues're static priority */
 				static_priority_end = queue;
+
 			/*
 			 * Check to make sure all static priority
 			 * queues are contiguous.  Also catches some
 			 * cases of static priorites not starting at
 			 * queue 0.
 			 */
-			if (static_priority_end != -1
-			    && (int)queue > static_priority_end
-			    && priority[queue] ==
-			    CVMX_PKO_QUEUE_STATIC_PRIORITY) {
-				cvmx_dprintf("ERROR: cvmx_pko_config_port: "
-					     "Static priority queues aren't "
-					     "contiguous or don't start at "
-					     "base queue. q: %d, eq: %d\n",
-					(int)queue, static_priority_end);
+			if (static_priority_end != -1 &&
+			    (int)queue > static_priority_end &&
+			    priority[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY) {
+				cvmx_dprintf("ERROR: cvmx_pko_config_port: Static priority queues aren't contiguous or don't start at base queue. q: %d, eq: %d\n",
+					     (int)queue, static_priority_end);
 				return CVMX_PKO_INVALID_PRIORITY;
 			}
 		}
 		if (static_priority_base > 0) {
-			cvmx_dprintf("ERROR: cvmx_pko_config_port: Static "
-				     "priority queues don't start at base "
-				     "queue. sq: %d\n",
-				static_priority_base);
+			cvmx_dprintf("ERROR: cvmx_pko_config_port: Static priority queues don't start at base queue. sq: %d\n",
+				     static_priority_base);
 			return CVMX_PKO_INVALID_PRIORITY;
 		}
-#if 0
-		cvmx_dprintf("Port %d: Static priority queue base: %d, "
-			     "end: %d\n", port,
-			static_priority_base, static_priority_end);
-#endif
 	}
+
 	/*
 	 * At this point, static_priority_base and static_priority_end
-	 * are either both -1, or are valid start/end queue
-	 * numbers.
+	 * are either both -1, or are valid start/end queue numbers
 	 */
 
 	result_code = CVMX_PKO_SUCCESS;
 
 #ifdef PKO_DEBUG
-	cvmx_dprintf("num queues: %d (%lld,%lld)\n", num_queues,
-		     CVMX_PKO_QUEUES_PER_PORT_INTERFACE0,
-		     CVMX_PKO_QUEUES_PER_PORT_INTERFACE1);
+	cvmx_dprintf("num queues: %d (%lld,%lld)\n", (int)num_queues,
+		     (unsigned long long)CVMX_PKO_QUEUES_PER_PORT_INTERFACE0, (unsigned long long)CVMX_PKO_QUEUES_PER_PORT_INTERFACE1);
 #endif
 
 	for (queue = 0; queue < num_queues; queue++) {
@@ -306,15 +759,13 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 		config.s.port = port;
 		config.s.queue = base_queue + queue;
 
-		if (!cvmx_octeon_is_pass1()) {
-			config.s.static_p = static_priority_base >= 0;
-			config.s.static_q = (int)queue <= static_priority_end;
-			config.s.s_tail = (int)queue == static_priority_end;
-		}
+		config.s.static_p = static_priority_base >= 0;
+		config.s.static_q = (int)queue <= static_priority_end;
+		config.s.s_tail = (int)queue == static_priority_end;
 		/*
 		 * Convert the priority into an enable bit field. Try
 		 * to space the bits out evenly so the packet don't
-		 * get grouped up
+		 * get grouped up.
 		 */
 		switch ((int)priority[queue]) {
 		case 0:
@@ -345,57 +796,41 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 			config.s.qos_mask = 0xff;
 			break;
 		case CVMX_PKO_QUEUE_STATIC_PRIORITY:
-			/* Pass 1 will fall through to the error case */
-			if (!cvmx_octeon_is_pass1()) {
-				config.s.qos_mask = 0xff;
-				break;
-			}
+			config.s.qos_mask = 0xff;
+			break;
 		default:
-			cvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid "
-				     "priority %llu\n",
-				(unsigned long long)priority[queue]);
+			cvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid priority %llu\n", (unsigned long long)priority[queue]);
 			config.s.qos_mask = 0xff;
 			result_code = CVMX_PKO_INVALID_PRIORITY;
 			break;
 		}
 
 		if (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID) {
-			cvmx_cmd_queue_result_t cmd_res =
-			    cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_PKO
-						      (base_queue + queue),
-						      CVMX_PKO_MAX_QUEUE_DEPTH,
-						      CVMX_FPA_OUTPUT_BUFFER_POOL,
-						      CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
-						      -
-						      CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST
-						      * 8);
+			cvmx_cmd_queue_result_t cmd_res;
+			cmd_res = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_PKO(base_queue + queue),
+							    CVMX_PKO_MAX_QUEUE_DEPTH,
+							    CVMX_FPA_OUTPUT_BUFFER_POOL,
+							    CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE - CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST * 8);
 			if (cmd_res != CVMX_CMD_QUEUE_SUCCESS) {
 				switch (cmd_res) {
 				case CVMX_CMD_QUEUE_NO_MEMORY:
-					cvmx_dprintf("ERROR: "
-						     "cvmx_pko_config_port: "
-						     "Unable to allocate "
-						     "output buffer.\n");
+					cvmx_dprintf("ERROR: cvmx_pko_config_port: Unable to allocate output buffer.\n");
 					return CVMX_PKO_NO_MEMORY;
 				case CVMX_CMD_QUEUE_ALREADY_SETUP:
-					cvmx_dprintf
-					    ("ERROR: cvmx_pko_config_port: Port already setup.\n");
+					cvmx_dprintf("ERROR: cvmx_pko_config_port: Port already setup.\n");
 					return CVMX_PKO_PORT_ALREADY_SETUP;
 				case CVMX_CMD_QUEUE_INVALID_PARAM:
 				default:
-					cvmx_dprintf
-					    ("ERROR: cvmx_pko_config_port: Command queue initialization failed.\n");
+					cvmx_dprintf("ERROR: cvmx_pko_config_port: Command queue initialization failed.\n");
 					return CVMX_PKO_CMD_QUEUE_INIT_ERROR;
 				}
 			}
 
-			buf_ptr =
-			    (uint64_t *)
-			    cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_PKO
-						  (base_queue + queue));
+			buf_ptr = (uint64_t *)cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_PKO(base_queue + queue));
 			config.s.buf_ptr = cvmx_ptr_to_phys(buf_ptr);
-		} else
+		} else {
 			config.s.buf_ptr = 0;
+		}
 
 		CVMX_SYNCWS;
 
@@ -407,32 +842,6 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 	return result_code;
 }
 
-#ifdef PKO_DEBUG
-/**
- * Show map of ports -> queues for different cores.
- */
-void cvmx_pko_show_queue_map()
-{
-	int core, port;
-	int pko_output_ports = 36;
-
-	cvmx_dprintf("port");
-	for (port = 0; port < pko_output_ports; port++)
-		cvmx_dprintf("%3d ", port);
-	cvmx_dprintf("\n");
-
-	for (core = 0; core < CVMX_MAX_CORES; core++) {
-		cvmx_dprintf("\n%2d: ", core);
-		for (port = 0; port < pko_output_ports; port++) {
-			cvmx_dprintf("%3d ",
-				     cvmx_pko_get_base_queue_per_core(port,
-								      core));
-		}
-	}
-	cvmx_dprintf("\n");
-}
-#endif
-
 /**
  * Rate limit a PKO port to a max packets/sec. This function is only
  * supported on CN51XX and higher, excluding CN58XX.
@@ -451,15 +860,13 @@ int cvmx_pko_rate_limit_packets(int port, int packets_s, int burst)
 
 	pko_mem_port_rate0.u64 = 0;
 	pko_mem_port_rate0.s.pid = port;
-	pko_mem_port_rate0.s.rate_pkt =
-	    cvmx_sysinfo_get()->cpu_clock_hz / packets_s / 16;
+	pko_mem_port_rate0.s.rate_pkt = octeon_get_io_clock_rate() / packets_s / 16;
 	/* No cost per word since we are limited by packets/sec, not bits/sec */
 	pko_mem_port_rate0.s.rate_word = 0;
 
 	pko_mem_port_rate1.u64 = 0;
 	pko_mem_port_rate1.s.pid = port;
-	pko_mem_port_rate1.s.rate_lim =
-	    ((uint64_t) pko_mem_port_rate0.s.rate_pkt * burst) >> 8;
+	pko_mem_port_rate1.s.rate_lim = ((uint64_t) pko_mem_port_rate0.s.rate_pkt * burst) >> 8;
 
 	cvmx_write_csr(CVMX_PKO_MEM_PORT_RATE0, pko_mem_port_rate0.u64);
 	cvmx_write_csr(CVMX_PKO_MEM_PORT_RATE1, pko_mem_port_rate1.u64);
@@ -481,7 +888,7 @@ int cvmx_pko_rate_limit_bits(int port, uint64_t bits_s, int burst)
 {
 	union cvmx_pko_mem_port_rate0 pko_mem_port_rate0;
 	union cvmx_pko_mem_port_rate1 pko_mem_port_rate1;
-	uint64_t clock_rate = cvmx_sysinfo_get()->cpu_clock_hz;
+	uint64_t clock_rate = octeon_get_io_clock_rate();
 	uint64_t tokens_per_bit = clock_rate * 16 / bits_s;
 
 	pko_mem_port_rate0.u64 = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c b/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
new file mode 100644
index 0000000..3abda55
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
@@ -0,0 +1,428 @@
+
+#include <asm/octeon/cvmx-qlm.h>
+
+const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn56xx[] = {
+	{"prbs_error_count", 267, 220},
+	{"prbs_unlock_count", 219, 212},
+	{"prbs_locked", 211, 211},
+	{"reset_prbs", 210, 210},
+	{"run_prbs", 209, 209},
+	{"run_bist", 208, 208},
+	{"unknown", 207, 202},
+	{"biasdrvsel", 201, 199},
+	{"biasbuffsel", 198, 196},
+	{"tcoeff", 195, 192},
+	{"mb5000", 181, 181},
+	{"interpbw", 180, 176},
+	{"mb", 175, 172},
+	{"bwoff", 171, 160},
+	{"bg_ref_sel", 153, 153},
+	{"div2en", 152, 152},
+	{"trimen", 151, 150},
+	{"clkr", 149, 144},
+	{"clkf", 143, 132},
+	{"bwadj", 131, 120},
+	{"shlpbck", 119, 118},
+	{"serdes_pll_byp", 117, 117},
+	{"ic50dac", 116, 112},
+	{"sl_posedge_sample", 111, 111},
+	{"sl_enable", 110, 110},
+	{"rx_rout_comp_bypass", 109, 109},
+	{"ir50dac", 108, 104},
+	{"rx_res_offset", 103, 100},
+	{"rx_rout_comp_value", 99, 96},
+	{"tx_rout_comp_value", 95, 92},
+	{"tx_res_offset", 91, 88},
+	{"tx_rout_comp_bypass", 87, 87},
+	{"idle_dac", 86, 84},
+	{"hyst_en", 83, 83},
+	{"rndt", 82, 82},
+	{"cfg_tx_com", 79, 79},
+	{"cfg_cdr_errcor", 78, 78},
+	{"cfg_cdr_secord", 77, 77},
+	{"cfg_cdr_rotate", 76, 76},
+	{"cfg_cdr_rqoffs", 75, 68},
+	{"cfg_cdr_incx", 67, 64},
+	{"cfg_cdr_state", 63, 56},
+	{"cfg_cdr_bypass", 55, 55},
+	{"cfg_tx_byp", 54, 54},
+	{"cfg_tx_val", 53, 44},
+	{"cfg_rx_pol_set", 43, 43},
+	{"cfg_rx_pol_clr", 42, 42},
+	{"cfg_cdr_bw_ctl", 41, 40},
+	{"cfg_rst_n_set", 39, 39},
+	{"cfg_rst_n_clr", 38, 38},
+	{"cfg_tx_clk2", 37, 37},
+	{"cfg_tx_clk1", 36, 36},
+	{"cfg_tx_pol_set", 35, 35},
+	{"cfg_tx_pol_clr", 34, 34},
+	{"cfg_tx_one", 33, 33},
+	{"cfg_tx_zero", 32, 32},
+	{"cfg_rxd_wait", 31, 28},
+	{"cfg_rxd_short", 27, 27},
+	{"cfg_rxd_set", 26, 26},
+	{"cfg_rxd_clr", 25, 25},
+	{"cfg_loopback", 24, 24},
+	{"cfg_tx_idle_set", 23, 23},
+	{"cfg_tx_idle_clr", 22, 22},
+	{"cfg_rx_idle_set", 21, 21},
+	{"cfg_rx_idle_clr", 20, 20},
+	{"cfg_rx_idle_thr", 19, 16},
+	{"cfg_com_thr", 15, 12},
+	{"cfg_rx_offset", 11, 8},
+	{"cfg_skp_max", 7, 4},
+	{"cfg_skp_min", 3, 0},
+	{NULL, -1, -1}
+};
+
+const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn52xx[] = {
+	{"prbs_error_count", 267, 220},
+	{"prbs_unlock_count", 219, 212},
+	{"prbs_locked", 211, 211},
+	{"reset_prbs", 210, 210},
+	{"run_prbs", 209, 209},
+	{"run_bist", 208, 208},
+	{"unknown", 207, 202},
+
+	{"biasdrvsel", 201, 199},
+	{"biasbuffsel", 198, 196},
+	{"tcoeff", 195, 192},
+	{"mb5000", 181, 181},
+	{"interpbw", 180, 176},
+	{"mb", 175, 172},
+	{"bwoff", 171, 160},
+	{"bg_ref_sel", 153, 153},
+	{"div2en", 152, 152},
+	{"trimen", 151, 150},
+	{"clkr", 149, 144},
+	{"clkf", 143, 132},
+	{"bwadj", 131, 120},
+	{"shlpbck", 119, 118},
+	{"serdes_pll_byp", 117, 117},
+	{"ic50dac", 116, 112},
+	{"sl_posedge_sample", 111, 111},
+	{"sl_enable", 110, 110},
+	{"rx_rout_comp_bypass", 109, 109},
+	{"ir50dac", 108, 104},
+	{"rx_res_offset", 103, 100},
+	{"rx_rout_comp_value", 99, 96},
+	{"tx_rout_comp_value", 95, 92},
+	{"tx_res_offset", 91, 88},
+	{"tx_rout_comp_bypass", 87, 87},
+	{"idle_dac", 86, 84},
+	{"hyst_en", 83, 83},
+	{"rndt", 82, 82},
+	{"cfg_tx_com", 79, 79},
+	{"cfg_cdr_errcor", 78, 78},
+	{"cfg_cdr_secord", 77, 77},
+	{"cfg_cdr_rotate", 76, 76},
+	{"cfg_cdr_rqoffs", 75, 68},
+	{"cfg_cdr_incx", 67, 64},
+	{"cfg_cdr_state", 63, 56},
+	{"cfg_cdr_bypass", 55, 55},
+	{"cfg_tx_byp", 54, 54},
+	{"cfg_tx_val", 53, 44},
+	{"cfg_rx_pol_set", 43, 43},
+	{"cfg_rx_pol_clr", 42, 42},
+	{"cfg_cdr_bw_ctl", 41, 40},
+	{"cfg_rst_n_set", 39, 39},
+	{"cfg_rst_n_clr", 38, 38},
+	{"cfg_tx_clk2", 37, 37},
+	{"cfg_tx_clk1", 36, 36},
+	{"cfg_tx_pol_set", 35, 35},
+	{"cfg_tx_pol_clr", 34, 34},
+	{"cfg_tx_one", 33, 33},
+	{"cfg_tx_zero", 32, 32},
+	{"cfg_rxd_wait", 31, 28},
+	{"cfg_rxd_short", 27, 27},
+	{"cfg_rxd_set", 26, 26},
+	{"cfg_rxd_clr", 25, 25},
+	{"cfg_loopback", 24, 24},
+	{"cfg_tx_idle_set", 23, 23},
+	{"cfg_tx_idle_clr", 22, 22},
+	{"cfg_rx_idle_set", 21, 21},
+	{"cfg_rx_idle_clr", 20, 20},
+	{"cfg_rx_idle_thr", 19, 16},
+	{"cfg_com_thr", 15, 12},
+	{"cfg_rx_offset", 11, 8},
+	{"cfg_skp_max", 7, 4},
+	{"cfg_skp_min", 3, 0},
+	{NULL, -1, -1}
+};
+
+const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn63xx[] = {
+	{"prbs_err_cnt", 299, 252},
+	{"prbs_lock", 251, 251},
+	{"jtg_prbs_rst_n", 250, 250},
+	{"jtg_run_prbs31", 249, 249},
+	{"jtg_run_prbs7", 248, 248},
+	{"Unused1", 247, 245},
+	{"cfg_pwrup_set", 244, 244},
+	{"cfg_pwrup_clr", 243, 243},
+	{"cfg_rst_n_set", 242, 242},
+	{"cfg_rst_n_clr", 241, 241},
+	{"cfg_tx_idle_set", 240, 240},
+	{"cfg_tx_idle_clr", 239, 239},
+	{"cfg_tx_byp", 238, 238},
+	{"cfg_tx_byp_inv", 237, 237},
+	{"cfg_tx_byp_val", 236, 227},
+	{"cfg_loopback", 226, 226},
+	{"shlpbck", 225, 224},
+	{"sl_enable", 223, 223},
+	{"sl_posedge_sample", 222, 222},
+	{"trimen", 221, 220},
+	{"serdes_tx_byp", 219, 219},
+	{"serdes_pll_byp", 218, 218},
+	{"lowf_byp", 217, 217},
+	{"spdsel_byp", 216, 216},
+	{"div4_byp", 215, 215},
+	{"clkf_byp", 214, 208},
+	{"Unused2", 207, 206},
+	{"biasdrv_hs_ls_byp", 205, 201},
+	{"tcoeff_hf_ls_byp", 200, 197},
+	{"biasdrv_hf_byp", 196, 192},
+	{"tcoeff_hf_byp", 191, 188},
+	{"Unused3", 187, 186},
+	{"biasdrv_lf_ls_byp", 185, 181},
+	{"tcoeff_lf_ls_byp", 180, 177},
+	{"biasdrv_lf_byp", 176, 172},
+	{"tcoeff_lf_byp", 171, 168},
+	{"Unused4", 167, 167},
+	{"interpbw", 166, 162},
+	{"pll_cpb", 161, 159},
+	{"pll_cps", 158, 156},
+	{"pll_diffamp", 155, 152},
+	{"Unused5", 151, 150},
+	{"cfg_rx_idle_set", 149, 149},
+	{"cfg_rx_idle_clr", 148, 148},
+	{"cfg_rx_idle_thr", 147, 144},
+	{"cfg_com_thr", 143, 140},
+	{"cfg_rx_offset", 139, 136},
+	{"cfg_skp_max", 135, 132},
+	{"cfg_skp_min", 131, 128},
+	{"cfg_fast_pwrup", 127, 127},
+	{"Unused6", 126, 100},
+	{"detected_n", 99, 99},
+	{"detected_p", 98, 98},
+	{"dbg_res_rx", 97, 94},
+	{"dbg_res_tx", 93, 90},
+	{"cfg_tx_pol_set", 89, 89},
+	{"cfg_tx_pol_clr", 88, 88},
+	{"cfg_rx_pol_set", 87, 87},
+	{"cfg_rx_pol_clr", 86, 86},
+	{"cfg_rxd_set", 85, 85},
+	{"cfg_rxd_clr", 84, 84},
+	{"cfg_rxd_wait", 83, 80},
+	{"cfg_cdr_limit", 79, 79},
+	{"cfg_cdr_rotate", 78, 78},
+	{"cfg_cdr_bw_ctl", 77, 76},
+	{"cfg_cdr_trunc", 75, 74},
+	{"cfg_cdr_rqoffs", 73, 64},
+	{"cfg_cdr_inc2", 63, 58},
+	{"cfg_cdr_inc1", 57, 52},
+	{"fusopt_voter_sync", 51, 51},
+	{"rndt", 50, 50},
+	{"hcya", 49, 49},
+	{"hyst", 48, 48},
+	{"idle_dac", 47, 45},
+	{"bg_ref_sel", 44, 44},
+	{"ic50dac", 43, 39},
+	{"ir50dac", 38, 34},
+	{"tx_rout_comp_bypass", 33, 33},
+	{"tx_rout_comp_value", 32, 29},
+	{"tx_res_offset", 28, 25},
+	{"rx_rout_comp_bypass", 24, 24},
+	{"rx_rout_comp_value", 23, 20},
+	{"rx_res_offset", 19, 16},
+	{"rx_cap_gen2", 15, 12},
+	{"rx_eq_gen2", 11, 8},
+	{"rx_cap_gen1", 7, 4},
+	{"rx_eq_gen1", 3, 0},
+	{NULL, -1, -1}
+};
+
+const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn66xx[] = {
+	{"prbs_err_cnt", 303, 256},
+	{"prbs_lock", 255, 255},
+	{"jtg_prbs_rx_rst_n", 254, 254},
+	{"jtg_prbs_tx_rst_n", 253, 253},
+	{"jtg_prbs_mode", 252, 251},
+	{"jtg_prbs_rst_n", 250, 250},
+	{"jtg_run_prbs31", 249, 249},
+	{"jtg_run_prbs7", 248, 248},
+	{"Unused1", 247, 246},
+	{"div5_byp", 245, 245},
+	{"cfg_pwrup_set", 244, 244},
+	{"cfg_pwrup_clr", 243, 243},
+	{"cfg_rst_n_set", 242, 242},
+	{"cfg_rst_n_clr", 241, 241},
+	{"cfg_tx_idle_set", 240, 240},
+	{"cfg_tx_idle_clr", 239, 239},
+	{"cfg_tx_byp", 238, 238},
+	{"cfg_tx_byp_inv", 237, 237},
+	{"cfg_tx_byp_val", 236, 227},
+	{"cfg_loopback", 226, 226},
+	{"shlpbck", 225, 224},
+	{"sl_enable", 223, 223},
+	{"sl_posedge_sample", 222, 222},
+	{"trimen", 221, 220},
+	{"serdes_tx_byp", 219, 219},
+	{"serdes_pll_byp", 218, 218},
+	{"lowf_byp", 217, 217},
+	{"spdsel_byp", 216, 216},
+	{"div4_byp", 215, 215},
+	{"clkf_byp", 214, 208},
+	{"biasdrv_hs_ls_byp", 207, 203},
+	{"tcoeff_hf_ls_byp", 202, 198},
+	{"biasdrv_hf_byp", 197, 193},
+	{"tcoeff_hf_byp", 192, 188},
+	{"biasdrv_lf_ls_byp", 187, 183},
+	{"tcoeff_lf_ls_byp", 182, 178},
+	{"biasdrv_lf_byp", 177, 173},
+	{"tcoeff_lf_byp", 172, 168},
+	{"Unused4", 167, 167},
+	{"interpbw", 166, 162},
+	{"pll_cpb", 161, 159},
+	{"pll_cps", 158, 156},
+	{"pll_diffamp", 155, 152},
+	{"cfg_err_thr", 151, 150},
+	{"cfg_rx_idle_set", 149, 149},
+	{"cfg_rx_idle_clr", 148, 148},
+	{"cfg_rx_idle_thr", 147, 144},
+	{"cfg_com_thr", 143, 140},
+	{"cfg_rx_offset", 139, 136},
+	{"cfg_skp_max", 135, 132},
+	{"cfg_skp_min", 131, 128},
+	{"cfg_fast_pwrup", 127, 127},
+	{"Unused6", 126, 101},
+	{"cfg_indep_dis", 100, 100},
+	{"detected_n", 99, 99},
+	{"detected_p", 98, 98},
+	{"dbg_res_rx", 97, 94},
+	{"dbg_res_tx", 93, 90},
+	{"cfg_tx_pol_set", 89, 89},
+	{"cfg_tx_pol_clr", 88, 88},
+	{"cfg_rx_pol_set", 87, 87},
+	{"cfg_rx_pol_clr", 86, 86},
+	{"cfg_rxd_set", 85, 85},
+	{"cfg_rxd_clr", 84, 84},
+	{"cfg_rxd_wait", 83, 80},
+	{"cfg_cdr_limit", 79, 79},
+	{"cfg_cdr_rotate", 78, 78},
+	{"cfg_cdr_bw_ctl", 77, 76},
+	{"cfg_cdr_trunc", 75, 74},
+	{"cfg_cdr_rqoffs", 73, 64},
+	{"cfg_cdr_inc2", 63, 58},
+	{"cfg_cdr_inc1", 57, 52},
+	{"fusopt_voter_sync", 51, 51},
+	{"rndt", 50, 50},
+	{"hcya", 49, 49},
+	{"hyst", 48, 48},
+	{"idle_dac", 47, 45},
+	{"bg_ref_sel", 44, 44},
+	{"ic50dac", 43, 39},
+	{"ir50dac", 38, 34},
+	{"tx_rout_comp_bypass", 33, 33},
+	{"tx_rout_comp_value", 32, 29},
+	{"tx_res_offset", 28, 25},
+	{"rx_rout_comp_bypass", 24, 24},
+	{"rx_rout_comp_value", 23, 20},
+	{"rx_res_offset", 19, 16},
+	{"rx_cap_gen2", 15, 12},
+	{"rx_eq_gen2", 11, 8},
+	{"rx_cap_gen1", 7, 4},
+	{"rx_eq_gen1", 3, 0},
+	{NULL, -1, -1}
+};
+
+const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn68xx[] = {
+	{"prbs_err_cnt", 303, 256},
+	{"prbs_lock", 255, 255},
+	{"jtg_prbs_rx_rst_n", 254, 254},
+	{"jtg_prbs_tx_rst_n", 253, 253},
+	{"jtg_prbs_mode", 252, 251},
+	{"jtg_prbs_rst_n", 250, 250},
+	{"jtg_run_prbs31", 249, 249},
+	{"jtg_run_prbs7", 248, 248},
+	{"Unused1", 247, 245},
+	{"cfg_pwrup_set", 244, 244},
+	{"cfg_pwrup_clr", 243, 243},
+	{"cfg_rst_n_set", 242, 242},
+	{"cfg_rst_n_clr", 241, 241},
+	{"cfg_tx_idle_set", 240, 240},
+	{"cfg_tx_idle_clr", 239, 239},
+	{"cfg_tx_byp", 238, 238},
+	{"cfg_tx_byp_inv", 237, 237},
+	{"cfg_tx_byp_val", 236, 227},
+	{"cfg_loopback", 226, 226},
+	{"shlpbck", 225, 224},
+	{"sl_enable", 223, 223},
+	{"sl_posedge_sample", 222, 222},
+	{"trimen", 221, 220},
+	{"serdes_tx_byp", 219, 219},
+	{"serdes_pll_byp", 218, 218},
+	{"lowf_byp", 217, 217},
+	{"spdsel_byp", 216, 216},
+	{"div4_byp", 215, 215},
+	{"clkf_byp", 214, 208},
+	{"biasdrv_hs_ls_byp", 207, 203},
+	{"tcoeff_hf_ls_byp", 202, 198},
+	{"biasdrv_hf_byp", 197, 193},
+	{"tcoeff_hf_byp", 192, 188},
+	{"biasdrv_lf_ls_byp", 187, 183},
+	{"tcoeff_lf_ls_byp", 182, 178},
+	{"biasdrv_lf_byp", 177, 173},
+	{"tcoeff_lf_byp", 172, 168},
+	{"Unused4", 167, 167},
+	{"interpbw", 166, 162},
+	{"pll_cpb", 161, 159},
+	{"pll_cps", 158, 156},
+	{"pll_diffamp", 155, 152},
+	{"cfg_err_thr", 151, 150},
+	{"cfg_rx_idle_set", 149, 149},
+	{"cfg_rx_idle_clr", 148, 148},
+	{"cfg_rx_idle_thr", 147, 144},
+	{"cfg_com_thr", 143, 140},
+	{"cfg_rx_offset", 139, 136},
+	{"cfg_skp_max", 135, 132},
+	{"cfg_skp_min", 131, 128},
+	{"cfg_fast_pwrup", 127, 127},
+	{"Unused6", 126, 100},
+	{"detected_n", 99, 99},
+	{"detected_p", 98, 98},
+	{"dbg_res_rx", 97, 94},
+	{"dbg_res_tx", 93, 90},
+	{"cfg_tx_pol_set", 89, 89},
+	{"cfg_tx_pol_clr", 88, 88},
+	{"cfg_rx_pol_set", 87, 87},
+	{"cfg_rx_pol_clr", 86, 86},
+	{"cfg_rxd_set", 85, 85},
+	{"cfg_rxd_clr", 84, 84},
+	{"cfg_rxd_wait", 83, 80},
+	{"cfg_cdr_limit", 79, 79},
+	{"cfg_cdr_rotate", 78, 78},
+	{"cfg_cdr_bw_ctl", 77, 76},
+	{"cfg_cdr_trunc", 75, 74},
+	{"cfg_cdr_rqoffs", 73, 64},
+	{"cfg_cdr_inc2", 63, 58},
+	{"cfg_cdr_inc1", 57, 52},
+	{"fusopt_voter_sync", 51, 51},
+	{"rndt", 50, 50},
+	{"hcya", 49, 49},
+	{"hyst", 48, 48},
+	{"idle_dac", 47, 45},
+	{"bg_ref_sel", 44, 44},
+	{"ic50dac", 43, 39},
+	{"ir50dac", 38, 34},
+	{"tx_rout_comp_bypass", 33, 33},
+	{"tx_rout_comp_value", 32, 29},
+	{"tx_res_offset", 28, 25},
+	{"rx_rout_comp_bypass", 24, 24},
+	{"rx_rout_comp_value", 23, 20},
+	{"rx_res_offset", 19, 16},
+	{"rx_cap_gen2", 15, 12},
+	{"rx_eq_gen2", 11, 8},
+	{"rx_cap_gen1", 7, 4},
+	{"rx_eq_gen1", 3, 0},
+	{NULL, -1, -1}
+};
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
new file mode 100644
index 0000000..3fbfc16
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -0,0 +1,1089 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2011 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Helper utilities for qlm.
+ */
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-bootmem.h>
+#include <asm/octeon/cvmx-helper-jtag.h>
+#include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+#include <asm/octeon/cvmx-pciercx-defs.h>
+
+/**
+ * The JTAG chain for CN52XX and CN56XX is 4 * 268 bits long, or 1072.
+ * CN5XXX full chain shift is:
+ *     new data => lane 3 => lane 2 => lane 1 => lane 0 => data out
+ * The JTAG chain for CN63XX is 4 * 300 bits long, or 1200.
+ * The JTAG chain for CN68XX is 4 * 304 bits long, or 1216.
+ * The JTAG chain for CN66XX/CN61XX/CNF71XX is 4 * 304 bits long, or 1216.
+ * CN6XXX full chain shift is:
+ *     new data => lane 0 => lane 1 => lane 2 => lane 3 => data out
+ * Shift LSB first, get LSB out
+ */
+extern const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn52xx[];
+extern const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn56xx[];
+extern const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn63xx[];
+extern const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn66xx[];
+extern const struct __cvmx_qlm_jtag_field __cvmx_qlm_jtag_field_cn68xx[];
+
+#define CVMX_QLM_JTAG_UINT32 40
+typedef uint32_t qlm_jtag_uint32_t[CVMX_QLM_JTAG_UINT32];
+qlm_jtag_uint32_t *__cvmx_qlm_jtag_xor_ref;
+
+/**
+ * Return the number of QLMs supported by the chip
+ *
+ * Returns  Number of QLMs
+ */
+int cvmx_qlm_get_num(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 5;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN61XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		return 4;
+	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
+		return 2;
+	else if (OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		return 2;
+	/* cvmx_dprintf("Warning: cvmx_qlm_get_num: This chip does not have QLMs\n"); */
+	return 0;
+}
+
+/**
+ * Return the qlm number based on the interface
+ *
+ * @interface:  Interface to look up
+ */
+int cvmx_qlm_interface(int interface)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		return (interface == 0) ? 2 : 0;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		return 2 - interface;
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		if (interface == 0)
+			return 0;
+		else
+			cvmx_dprintf("Warning: cvmx_qlm_interface: Invalid interface %d\n", interface);
+	} else {
+		/* Must be cn68XX */
+		switch (interface) {
+		case 1:
+			return 0;
+		default:
+			return interface;
+		}
+	}
+	return -1;
+}
+
+/**
+ * Return number of lanes for a given qlm
+ *
+ * Returns  Number of lanes
+ */
+int cvmx_qlm_get_lanes(int qlm)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN61XX) && qlm == 1)
+		return 2;
+	else if (OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		return 2;
+
+	return 4;
+}
+
+/**
+ * Get the QLM JTAG fields based on Octeon model on the supported chips.
+ *
+ * Returns  qlm_jtag_field_t structure
+ */
+const struct __cvmx_qlm_jtag_field *cvmx_qlm_jtag_get_field(void)
+{
+	/* Figure out which JTAG chain description we're using */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return __cvmx_qlm_jtag_field_cn68xx;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX)
+		 || OCTEON_IS_MODEL(OCTEON_CN61XX)
+		 || OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		return __cvmx_qlm_jtag_field_cn66xx;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return __cvmx_qlm_jtag_field_cn63xx;
+	else if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		return __cvmx_qlm_jtag_field_cn56xx;
+	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
+		return __cvmx_qlm_jtag_field_cn52xx;
+	else {
+		/* cvmx_dprintf("cvmx_qlm_jtag_get_field: Needs update for this chip\n"); */
+		return NULL;
+	}
+}
+
+/**
+ * Get the QLM JTAG length by going through qlm_jtag_field for each
+ * Octeon model that is supported
+ *
+ * Returns return the length.
+ */
+int cvmx_qlm_jtag_get_length(void)
+{
+	const struct __cvmx_qlm_jtag_field *qlm_ptr = cvmx_qlm_jtag_get_field();
+	int length = 0;
+
+	/* Figure out how many bits are in the JTAG chain */
+	while (qlm_ptr != NULL && qlm_ptr->name) {
+		if (qlm_ptr->stop_bit > length)
+			length = qlm_ptr->stop_bit + 1;
+		qlm_ptr++;
+	}
+	return length;
+}
+
+/**
+ * Initialize the QLM layer
+ */
+void cvmx_qlm_init(void)
+{
+	int qlm;
+	int qlm_jtag_length;
+	char *qlm_jtag_name = "cvmx_qlm_jtag";
+	int qlm_jtag_size = CVMX_QLM_JTAG_UINT32 * 8 * 4;
+	static uint64_t qlm_base;
+	const struct cvmx_bootmem_named_block_desc *desc;
+
+	/* Skip actual JTAG accesses on simulator */
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
+		return;
+
+	qlm_jtag_length = cvmx_qlm_jtag_get_length();
+
+	if (4 * qlm_jtag_length > (int)sizeof(__cvmx_qlm_jtag_xor_ref[0]) * 8) {
+		cvmx_dprintf("ERROR: cvmx_qlm_init: JTAG chain larger than XOR ref size\n");
+		return;
+	}
+
+	/* No need to initialize the initial JTAG state if cvmx_qlm_jtag
+	   named block is already created. */
+	desc = cvmx_bootmem_find_named_block(qlm_jtag_name);
+	if (desc != NULL) {
+		__cvmx_qlm_jtag_xor_ref = cvmx_phys_to_ptr(desc->base_addr);
+		/* Initialize the internal JTAG */
+		cvmx_helper_qlm_jtag_init();
+		return;
+	}
+
+	/* Create named block to store the initial JTAG state. */
+	qlm_base = cvmx_bootmem_phy_named_block_alloc(qlm_jtag_size, 0, 0, 128, qlm_jtag_name, CVMX_BOOTMEM_FLAG_END_ALLOC);
+
+	if (qlm_base == -1ull) {
+		cvmx_dprintf("ERROR: cvmx_qlm_init: Error in creating %s named block\n", qlm_jtag_name);
+		return;
+	}
+	__cvmx_qlm_jtag_xor_ref = cvmx_phys_to_ptr(qlm_base);
+	memset(__cvmx_qlm_jtag_xor_ref, 0, qlm_jtag_size);
+
+	/* Initialize the internal JTAG */
+	cvmx_helper_qlm_jtag_init();
+
+	/* Read the XOR defaults for the JTAG chain */
+	for (qlm = 0; qlm < cvmx_qlm_get_num(); qlm++) {
+		int i;
+		int num_lanes = cvmx_qlm_get_lanes(qlm);
+		/* Shift all zeros in the chain to make sure all fields are at
+		   reset defaults */
+		cvmx_helper_qlm_jtag_shift_zeros(qlm, qlm_jtag_length * num_lanes);
+		cvmx_helper_qlm_jtag_update(qlm);
+
+		/* Capture the reset defaults */
+		cvmx_helper_qlm_jtag_capture(qlm);
+		/* Save the reset defaults. This will shift out too much data, but
+		   the extra zeros don't hurt anything */
+		for (i = 0; i < CVMX_QLM_JTAG_UINT32; i++)
+			__cvmx_qlm_jtag_xor_ref[qlm][i] = cvmx_helper_qlm_jtag_shift(qlm, 32, 0);
+	}
+
+
+	/* Apply all QLM errata workarounds. */
+	__cvmx_qlm_speed_tweak();
+	__cvmx_qlm_pcie_idle_dac_tweak();
+}
+
+/**
+ * Lookup the bit information for a JTAG field name
+ *
+ * @name:   Name to lookup
+ *
+ * Returns Field info, or NULL on failure
+ */
+static const struct __cvmx_qlm_jtag_field *__cvmx_qlm_lookup_field(const char *name)
+{
+	const struct __cvmx_qlm_jtag_field *ptr = cvmx_qlm_jtag_get_field();
+	while (ptr->name) {
+		if (strcmp(name, ptr->name) == 0)
+			return ptr;
+		ptr++;
+	}
+	cvmx_dprintf("__cvmx_qlm_lookup_field: Illegal field name %s\n", name);
+	return NULL;
+}
+
+/**
+ * Get a field in a QLM JTAG chain
+ *
+ * @qlm:    QLM to get
+ * @lane:   Lane in QLM to get
+ * @name:   String name of field
+ *
+ * Returns JTAG field value
+ */
+uint64_t cvmx_qlm_jtag_get(int qlm, int lane, const char *name)
+{
+	const struct __cvmx_qlm_jtag_field *field = __cvmx_qlm_lookup_field(name);
+	int qlm_jtag_length = cvmx_qlm_jtag_get_length();
+	int num_lanes = cvmx_qlm_get_lanes(qlm);
+
+	if (!field)
+		return 0;
+
+	/* Capture the current settings */
+	cvmx_helper_qlm_jtag_capture(qlm);
+	/* Shift past lanes we don't care about. CN6XXX/7XXX shifts lane 0 first, CN3XXX/5XXX shifts lane 3 first */
+	if (OCTEON_IS_MODEL(OCTEON_CN5XXX))
+		cvmx_helper_qlm_jtag_shift_zeros(qlm, qlm_jtag_length * (lane));	/* Shift to the start of the field */
+	else
+		cvmx_helper_qlm_jtag_shift_zeros(qlm, qlm_jtag_length * (num_lanes - 1 - lane));	/* Shift to the start of the field */
+	cvmx_helper_qlm_jtag_shift_zeros(qlm, field->start_bit);
+	/* Shift out the value and return it */
+	return cvmx_helper_qlm_jtag_shift(qlm, field->stop_bit - field->start_bit + 1, 0);
+}
+
+/**
+ * Set a field in a QLM JTAG chain
+ *
+ * @qlm:    QLM to set
+ * @lane:   Lane in QLM to set, or -1 for all lanes
+ * @name:   String name of field
+ * @value:  Value of the field
+ */
+void cvmx_qlm_jtag_set(int qlm, int lane, const char *name, uint64_t value)
+{
+	int i, l;
+	uint32_t shift_values[CVMX_QLM_JTAG_UINT32];
+	int num_lanes = cvmx_qlm_get_lanes(qlm);
+	const struct __cvmx_qlm_jtag_field *field = __cvmx_qlm_lookup_field(name);
+	int qlm_jtag_length = cvmx_qlm_jtag_get_length();
+	int total_length = qlm_jtag_length * num_lanes;
+	int bits = 0;
+
+	if (!field)
+		return;
+
+	/* Get the current state */
+	cvmx_helper_qlm_jtag_capture(qlm);
+	for (i = 0; i < CVMX_QLM_JTAG_UINT32; i++)
+		shift_values[i] = cvmx_helper_qlm_jtag_shift(qlm, 32, 0);
+
+	/* Put new data in our local array */
+	for (l = 0; l < num_lanes; l++) {
+		uint64_t new_value = value;
+		int bits;
+		int adj_lanes;
+
+		if ((l != lane) && (lane != -1))
+			continue;
+
+		if (OCTEON_IS_MODEL(OCTEON_CN5XXX))
+			adj_lanes = l * qlm_jtag_length;
+		else
+			adj_lanes = (num_lanes - 1 - l) * qlm_jtag_length;
+
+		for (bits = field->start_bit + adj_lanes; bits <= field->stop_bit + adj_lanes; bits++) {
+			if (new_value & 1)
+				shift_values[bits / 32] |= 1 << (bits & 31);
+			else
+				shift_values[bits / 32] &= ~(1 << (bits & 31));
+			new_value >>= 1;
+		}
+	}
+
+	/* Shift out data and xor with reference */
+	while (bits < total_length) {
+		uint32_t shift = shift_values[bits / 32] ^ __cvmx_qlm_jtag_xor_ref[qlm][bits / 32];
+		int width = total_length - bits;
+		if (width > 32)
+			width = 32;
+		cvmx_helper_qlm_jtag_shift(qlm, width, shift);
+		bits += 32;
+	}
+
+	/* Update the new data */
+	cvmx_helper_qlm_jtag_update(qlm);
+	/*
+	 * Always give the QLM 1ms to settle after every update. This
+	 * may not always be needed, but some of the options make
+	 * significant electrical changes.
+	 */
+	mdelay(1);
+}
+
+/**
+ * Errata G-16094: QLM Gen2 Equalizer Default Setting Change.
+ * CN68XX pass 1.x and CN66XX pass 1.x QLM tweak. This function tweaks the
+ * JTAG setting for a QLMs to run better at 5 and 6.25Ghz.
+ */
+void __cvmx_qlm_speed_tweak(void)
+{
+	union cvmx_mio_qlmx_cfg qlm_cfg;
+	int num_qlms = cvmx_qlm_get_num();
+	int qlm;
+
+	/* Workaround for Errata (G-16467) */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X)) {
+		for (qlm = 0; qlm < num_qlms; qlm++) {
+			int ir50dac;
+			/* This workaround only applies to QLMs running at 6.25Ghz */
+			if (cvmx_qlm_get_gbaud_mhz(qlm) == 6250) {
+#ifdef CVMX_QLM_DUMP_STATE
+				cvmx_dprintf("%s:%d: QLM%d: Applying workaround for Errata G-16467\n", __func__, __LINE__, qlm);
+				cvmx_qlm_display_registers(qlm);
+				cvmx_dprintf("\n");
+#endif
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_cdr_trunc", 0);
+				/* Hold the QLM in reset */
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_rst_n_set", 0);
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_rst_n_clr", 1);
+				/* Forcfe TX to be idle */
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_tx_idle_clr", 0);
+				cvmx_qlm_jtag_set(qlm, -1, "cfg_tx_idle_set", 1);
+				if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_0)) {
+					ir50dac = cvmx_qlm_jtag_get(qlm, 0, "ir50dac");
+					while (++ir50dac <= 31)
+						cvmx_qlm_jtag_set(qlm, -1, "ir50dac", ir50dac);
+				}
+				cvmx_qlm_jtag_set(qlm, -1, "div4_byp", 0);
+				cvmx_qlm_jtag_set(qlm, -1, "clkf_byp", 16);
+				cvmx_qlm_jtag_set(qlm, -1, "serdes_pll_byp", 1);
+				cvmx_qlm_jtag_set(qlm, -1, "spdsel_byp", 1);
+#ifdef CVMX_QLM_DUMP_STATE
+				cvmx_dprintf("%s:%d: QLM%d: Done applying workaround for Errata G-16467\n", __func__, __LINE__, qlm);
+				cvmx_qlm_display_registers(qlm);
+				cvmx_dprintf("\n\n");
+#endif
+				/* The QLM will be taken out of reset later when ILK/XAUI are initialized. */
+			}
+		}
+
+		/* These QLM tuning parameters are specific to EBB6800
+		   eval boards using Cavium QLM cables. These should be
+		   removed or tunned based on customer boards. */
+		if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_EBB6800) {
+			for (qlm = 0; qlm < num_qlms; qlm++) {
+#ifdef CVMX_QLM_DUMP_STATE
+				cvmx_dprintf("Setting tunning parameters for QLM%d\n", qlm);
+#endif
+				cvmx_qlm_jtag_set(qlm, -1, "biasdrv_hs_ls_byp", 12);
+				cvmx_qlm_jtag_set(qlm, -1, "biasdrv_hf_byp", 12);
+				cvmx_qlm_jtag_set(qlm, -1, "biasdrv_lf_ls_byp", 12);
+				cvmx_qlm_jtag_set(qlm, -1, "biasdrv_lf_byp", 12);
+				cvmx_qlm_jtag_set(qlm, -1, "tcoeff_hf_byp", 15);
+				cvmx_qlm_jtag_set(qlm, -1, "tcoeff_hf_ls_byp", 15);
+				cvmx_qlm_jtag_set(qlm, -1, "tcoeff_lf_ls_byp", 15);
+				cvmx_qlm_jtag_set(qlm, -1, "tcoeff_lf_byp", 15);
+				cvmx_qlm_jtag_set(qlm, -1, "rx_cap_gen2", 0);
+				cvmx_qlm_jtag_set(qlm, -1, "rx_eq_gen2", 11);
+				cvmx_qlm_jtag_set(qlm, -1, "serdes_tx_byp", 1);
+			}
+		}
+	}
+
+	/* G-16094 QLM Gen2 Equalizer Default Setting Change */
+	else if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X)
+		 || OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X)) {
+		/* Loop through the QLMs */
+		for (qlm = 0; qlm < num_qlms; qlm++) {
+			/* Read the QLM speed */
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+
+			/* If the QLM is at 6.25Ghz or 5Ghz then program JTAG */
+			if ((qlm_cfg.s.qlm_spd == 5) || (qlm_cfg.s.qlm_spd == 12) || (qlm_cfg.s.qlm_spd == 0) || (qlm_cfg.s.qlm_spd == 6) || (qlm_cfg.s.qlm_spd == 11)) {
+				cvmx_qlm_jtag_set(qlm, -1, "rx_cap_gen2", 0x1);
+				cvmx_qlm_jtag_set(qlm, -1, "rx_eq_gen2", 0x8);
+			}
+		}
+	}
+}
+
+/**
+ * Errata G-16174: QLM Gen2 PCIe IDLE DAC change.
+ * CN68XX pass 1.x, CN66XX pass 1.x and CN63XX pass 1.0-2.2 QLM tweak.
+ * This function tweaks the JTAG setting for a QLMs for PCIe to run better.
+ */
+void __cvmx_qlm_pcie_idle_dac_tweak(void)
+{
+	int num_qlms = 0;
+	int qlm;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+		num_qlms = 5;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X))
+		num_qlms = 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+		 OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X))
+		num_qlms = 3;
+	else
+		return;
+
+	/* Loop through the QLMs */
+	for (qlm = 0; qlm < num_qlms; qlm++)
+		cvmx_qlm_jtag_set(qlm, -1, "idle_dac", 0x2);
+}
+
+void __cvmx_qlm_pcie_cfg_rxd_set_tweak(int qlm, int lane)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		cvmx_qlm_jtag_set(qlm, lane, "cfg_rxd_set", 0x1);
+}
+
+/**
+ * Get the speed (Gbaud) of the QLM in Mhz.
+ *
+ * @qlm:    QLM to examine
+ *
+ * Returns Speed in Mhz
+ */
+int cvmx_qlm_get_gbaud_mhz(int qlm)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+		if (qlm == 2) {
+			union cvmx_gmxx_inf_mode inf_mode;
+			inf_mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(0));
+			switch (inf_mode.s.speed) {
+			case 0:
+				return 5000;	/* 5     Gbaud */
+			case 1:
+				return 2500;	/* 2.5   Gbaud */
+			case 2:
+				return 2500;	/* 2.5   Gbaud */
+			case 3:
+				return 1250;	/* 1.25  Gbaud */
+			case 4:
+				return 1250;	/* 1.25  Gbaud */
+			case 5:
+				return 6250;	/* 6.25  Gbaud */
+			case 6:
+				return 5000;	/* 5     Gbaud */
+			case 7:
+				return 2500;	/* 2.5   Gbaud */
+			case 8:
+				return 3125;	/* 3.125 Gbaud */
+			case 9:
+				return 2500;	/* 2.5   Gbaud */
+			case 10:
+				return 1250;	/* 1.25  Gbaud */
+			case 11:
+				return 5000;	/* 5     Gbaud */
+			case 12:
+				return 6250;	/* 6.25  Gbaud */
+			case 13:
+				return 3750;	/* 3.75  Gbaud */
+			case 14:
+				return 3125;	/* 3.125 Gbaud */
+			default:
+				return 0;	/* Disabled */
+			}
+		} else {
+			union cvmx_sriox_status_reg status_reg;
+			status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(qlm));
+			if (status_reg.s.srio) {
+				union cvmx_sriomaintx_port_0_ctl2 sriomaintx_port_0_ctl2;
+				sriomaintx_port_0_ctl2.u32 = cvmx_read_csr(CVMX_SRIOMAINTX_PORT_0_CTL2(qlm));
+				switch (sriomaintx_port_0_ctl2.s.sel_baud) {
+				case 1:
+					return 1250;	/* 1.25  Gbaud */
+				case 2:
+					return 2500;	/* 2.5   Gbaud */
+				case 3:
+					return 3125;	/* 3.125 Gbaud */
+				case 4:
+					return 5000;	/* 5     Gbaud */
+				case 5:
+					return 6250;	/* 6.250 Gbaud */
+				default:
+					return 0;	/* Disabled */
+				}
+			} else {
+				union cvmx_pciercx_cfg032 pciercx_cfg032;
+				pciercx_cfg032.u32 = cvmx_read_csr(CVMX_PCIERCX_CFG032(qlm));
+				switch (pciercx_cfg032.s.ls) {
+				case 1:
+					return 2500;
+				case 2:
+					return 5000;
+				case 4:
+					return 8000;
+				default:
+					{
+						union cvmx_mio_rst_boot mio_rst_boot;
+						mio_rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+						if ((qlm == 0) && mio_rst_boot.s.qlm0_spd == 0xf)
+							return 0;
+						if ((qlm == 1) && mio_rst_boot.s.qlm1_spd == 0xf)
+							return 0;
+						return 5000;	/* Best guess I can make */
+					}
+				}
+			}
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		union cvmx_mio_qlmx_cfg qlm_cfg;
+
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		switch (qlm_cfg.s.qlm_spd) {
+		case 0:
+			return 5000;	/* 5     Gbaud */
+		case 1:
+			return 2500;	/* 2.5   Gbaud */
+		case 2:
+			return 2500;	/* 2.5   Gbaud */
+		case 3:
+			return 1250;	/* 1.25  Gbaud */
+		case 4:
+			return 1250;	/* 1.25  Gbaud */
+		case 5:
+			return 6250;	/* 6.25  Gbaud */
+		case 6:
+			return 5000;	/* 5     Gbaud */
+		case 7:
+			return 2500;	/* 2.5   Gbaud */
+		case 8:
+			return 3125;	/* 3.125 Gbaud */
+		case 9:
+			return 2500;	/* 2.5   Gbaud */
+		case 10:
+			return 1250;	/* 1.25  Gbaud */
+		case 11:
+			return 5000;	/* 5     Gbaud */
+		case 12:
+			return 6250;	/* 6.25  Gbaud */
+		case 13:
+			return 3750;	/* 3.75  Gbaud */
+		case 14:
+			return 3125;	/* 3.125 Gbaud */
+		default:
+			return 0;	/* Disabled */
+		}
+	}
+	return 0;
+}
+
+/*
+ * Read QLM and return mode.
+ */
+enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm)
+{
+	union cvmx_mio_qlmx_cfg qlmx_cfg;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return CVMX_QLM_MODE_DISABLED;
+
+		switch (qlmx_cfg.s.qlm_cfg) {
+		case 0:	/* PCIE */
+			return CVMX_QLM_MODE_PCIE;
+		case 1:	/* ILK */
+			return CVMX_QLM_MODE_ILK;
+		case 2:	/* SGMII */
+			return CVMX_QLM_MODE_SGMII;
+		case 3:	/* XAUI */
+			return CVMX_QLM_MODE_XAUI;
+		case 7:	/* RXAUI */
+			return CVMX_QLM_MODE_RXAUI;
+		default:
+			return CVMX_QLM_MODE_DISABLED;
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return -1;
+
+		switch (qlmx_cfg.s.qlm_cfg) {
+		case 0x9:	/* SGMII */
+			return CVMX_QLM_MODE_SGMII;
+		case 0xb:	/* XAUI */
+			return CVMX_QLM_MODE_XAUI;
+		case 0x0:	/* PCIE gen2 */
+		case 0x8:	/* PCIE gen2 (alias) */
+		case 0x2:	/* PCIE gen1 */
+		case 0xa:	/* PCIE gen1 (alias) */
+			return CVMX_QLM_MODE_PCIE;
+		case 0x1:	/* SRIO 1x4 short */
+		case 0x3:	/* SRIO 1x4 long */
+			return CVMX_QLM_MODE_SRIO_1X4;
+		case 0x4:	/* SRIO 2x2 short */
+		case 0x6:	/* SRIO 2x2 long */
+			return CVMX_QLM_MODE_SRIO_2X2;
+		case 0x5:	/* SRIO 4x1 short */
+		case 0x7:	/* SRIO 4x1 long */
+			if (!OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+				return CVMX_QLM_MODE_SRIO_4X1;
+		default:
+			return CVMX_QLM_MODE_DISABLED;
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+		union cvmx_sriox_status_reg status_reg;
+		/* For now skip qlm2 */
+		if (qlm == 2) {
+			union cvmx_gmxx_inf_mode inf_mode;
+			inf_mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(0));
+			if (inf_mode.s.speed == 15)
+				return CVMX_QLM_MODE_DISABLED;
+			else if (inf_mode.s.mode == 0)
+				return CVMX_QLM_MODE_SGMII;
+			else
+				return CVMX_QLM_MODE_XAUI;
+		}
+		status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(qlm));
+		if (status_reg.s.srio)
+			return CVMX_QLM_MODE_SRIO_1X4;
+		else
+			return CVMX_QLM_MODE_PCIE;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return CVMX_QLM_MODE_DISABLED;
+
+		switch (qlm) {
+		case 0:
+			switch (qlmx_cfg.s.qlm_cfg) {
+			case 0:	/* PCIe 1x4 gen2 / gen1 */
+				return CVMX_QLM_MODE_PCIE;
+			case 2:	/* SGMII */
+				return CVMX_QLM_MODE_SGMII;
+			case 3:	/* XAUI */
+				return CVMX_QLM_MODE_XAUI;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+			break;
+		case 1:
+			switch (qlmx_cfg.s.qlm_cfg) {
+			case 0:	/* PCIe 1x2 gen2 / gen1 */
+				return CVMX_QLM_MODE_PCIE_1X2;
+			case 1:	/* PCIe 2x1 gen2 / gen1 */
+				return CVMX_QLM_MODE_PCIE_2X1;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+			break;
+		case 2:
+			switch (qlmx_cfg.s.qlm_cfg) {
+			case 2:	/* SGMII */
+				return CVMX_QLM_MODE_SGMII;
+			case 3:	/* XAUI */
+				return CVMX_QLM_MODE_XAUI;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+			break;
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return CVMX_QLM_MODE_DISABLED;
+
+		switch (qlm) {
+		case 0:
+			if (qlmx_cfg.s.qlm_cfg == 2)	/* SGMII */
+				return CVMX_QLM_MODE_SGMII;
+			break;
+		case 1:
+			switch (qlmx_cfg.s.qlm_cfg) {
+			case 0:	/* PCIe 1x2 gen2 / gen1 */
+				return CVMX_QLM_MODE_PCIE_1X2;
+			case 1:	/* PCIe 2x1 gen2 / gen1 */
+				return CVMX_QLM_MODE_PCIE_2X1;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+			break;
+		}
+	}
+	return CVMX_QLM_MODE_DISABLED;
+}
+
+/**
+ * Measure the reference clock of a QLM
+ *
+ * @qlm:    QLM to measure
+ *
+ * Returns Clock rate in Hz
+ *       */
+static int __cvmx_qlm_measure_clock(int qlm)
+{
+	union cvmx_mio_ptp_clock_cfg ptp_clock;
+	uint64_t count;
+	uint64_t start_cycle, stop_cycle;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX))
+		return -1;
+
+	/* Force the reference to 156.25Mhz when running in simulation.
+	   This supports the most speeds */
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
+		return 156250000;
+
+	/* Disable the PTP event counter while we configure it */
+	ptp_clock.u64 = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_CFG);	/* For CN63XXp1 errata */
+	ptp_clock.s.evcnt_en = 0;
+	cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock.u64);
+	/* Count on rising edge, Choose which QLM to count */
+	ptp_clock.u64 = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_CFG);	/* For CN63XXp1 errata */
+	ptp_clock.s.evcnt_edge = 0;
+	ptp_clock.s.evcnt_in = 0x10 + qlm;
+	cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock.u64);
+	/* Clear MIO_PTP_EVT_CNT */
+	cvmx_read_csr(CVMX_MIO_PTP_EVT_CNT);	/* For CN63XXp1 errata */
+	count = cvmx_read_csr(CVMX_MIO_PTP_EVT_CNT);
+	cvmx_write_csr(CVMX_MIO_PTP_EVT_CNT, -count);
+	/* Set MIO_PTP_EVT_CNT to 1 billion */
+	cvmx_write_csr(CVMX_MIO_PTP_EVT_CNT, 1000000000);
+	/* Enable the PTP event counter */
+	ptp_clock.u64 = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_CFG);	/* For CN63XXp1 errata */
+	ptp_clock.s.evcnt_en = 1;
+	cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock.u64);
+	start_cycle = read_c0_cvmcount();
+	/* Wait for 50ms */
+	mdelay(50);
+	/* Read the counter */
+	cvmx_read_csr(CVMX_MIO_PTP_EVT_CNT);	/* For CN63XXp1 errata */
+	count = cvmx_read_csr(CVMX_MIO_PTP_EVT_CNT);
+	stop_cycle = read_c0_cvmcount();
+	/* Disable the PTP event counter */
+	ptp_clock.u64 = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_CFG);	/* For CN63XXp1 errata */
+	ptp_clock.s.evcnt_en = 0;
+	cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock.u64);
+	/* Clock counted down, so reverse it */
+	count = 1000000000 - count;
+	/* Return the rate */
+	return count * octeon_get_clock_rate() / (stop_cycle - start_cycle);
+}
+
+static int __cvmx_qlm_is_ref_clock(int qlm, int reference_mhz)
+{
+	int ref_clock = __cvmx_qlm_measure_clock(qlm);
+	int mhz = ref_clock / 1000000;
+	int range = reference_mhz / 10;
+	return ((mhz >= reference_mhz - range) && (mhz <= reference_mhz + range));
+}
+
+static int __cvmx_qlm_get_qlm_spd(int qlm, int speed)
+{
+	int qlm_spd = 0xf;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX))
+		return -1;
+
+	if (__cvmx_qlm_is_ref_clock(qlm, 100)) {
+		if (speed == 1250)
+			qlm_spd = 0x3;
+		else if (speed == 2500)
+			qlm_spd = 0x2;
+		else if (speed == 5000)
+			qlm_spd = 0x0;
+		else {
+			/* cvmx_dprintf("Invalide speed(%d) for QLM(%d)\n", speed, qlm); */
+			qlm_spd = 0xf;
+		}
+	} else if (__cvmx_qlm_is_ref_clock(qlm, 125)) {
+		if (speed == 1250)
+			qlm_spd = 0xa;
+		else if (speed == 2500)
+			qlm_spd = 0x9;
+		else if (speed == 3125)
+			qlm_spd = 0x8;
+		else if (speed == 5000)
+			qlm_spd = 0x6;
+		else if (speed == 6250)
+			qlm_spd = 0x5;
+		else {
+			/* cvmx_dprintf("Invalide speed(%d) for QLM(%d)\n", speed, qlm); */
+			qlm_spd = 0xf;
+		}
+	} else if (__cvmx_qlm_is_ref_clock(qlm, 156)) {
+		if (speed == 1250)
+			qlm_spd = 0x4;
+		else if (speed == 2500)
+			qlm_spd = 0x7;
+		else if (speed == 3125)
+			qlm_spd = 0xe;
+		else if (speed == 3750)
+			qlm_spd = 0xd;
+		else if (speed == 5000)
+			qlm_spd = 0xb;
+		else if (speed == 6250)
+			qlm_spd = 0xc;
+		else {
+			/* cvmx_dprintf("Invalide speed(%d) for QLM(%d)\n", speed, qlm); */
+			qlm_spd = 0xf;
+		}
+	}
+	return qlm_spd;
+}
+
+static void __cvmx_qlm_set_qlm_pcie_mode(int pcie_port, int root_complex)
+{
+	int rc = root_complex ? 1 : 0;
+	int ep = root_complex ? 0 : 1;
+	union cvmx_ciu_soft_prst1 soft_prst1;
+	union cvmx_ciu_soft_prst soft_prst;
+	union cvmx_mio_rst_ctlx rst_ctl;
+
+	if (pcie_port) {
+		soft_prst1.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+		soft_prst1.s.soft_prst = 1;
+		cvmx_write_csr(CVMX_CIU_SOFT_PRST1, soft_prst1.u64);
+	} else {
+		soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+		soft_prst.s.soft_prst = 1;
+		cvmx_write_csr(CVMX_CIU_SOFT_PRST, soft_prst.u64);
+	}
+
+	rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(pcie_port));
+
+	rst_ctl.s.prst_link = rc;
+	rst_ctl.s.rst_link = ep;
+	rst_ctl.s.prtmode = rc;
+	rst_ctl.s.rst_drv = rc;
+	rst_ctl.s.rst_rcv = 0;
+	rst_ctl.s.rst_chip = ep;
+	cvmx_write_csr(CVMX_MIO_RST_CTLX(pcie_port), rst_ctl.u64);
+
+	if (root_complex == 0) {
+		if (pcie_port) {
+			soft_prst1.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+			soft_prst1.s.soft_prst = 0;
+			cvmx_write_csr(CVMX_CIU_SOFT_PRST1, soft_prst1.u64);
+		} else {
+			soft_prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+			soft_prst.s.soft_prst = 0;
+			cvmx_write_csr(CVMX_CIU_SOFT_PRST, soft_prst1.u64);
+		}
+	}
+}
+
+/*
+ * Configure qlm speed and mode. MIO_QLMX_CFG[speed,mode] are not set
+ * for CN61XX.
+ *
+ * @qlm:     The QLM to configure
+ * @speed:   The speed the QLM needs to be configured in Mhz.
+ * @mode:    The QLM to be configured as SGMII/XAUI/PCIe.
+ * @rc:      Only used for PCIe, rc = 1 for root complex mode, 0 for EP mode.
+ * @pcie2x1: Only used when QLM1 is in PCIE2x1 mode. The QLM_SPD has different
+ *                value on how PEMx needs to be configured:
+ *                   0x0 - both PEM0 & PEM1 are in gen1 mode.
+ *                   0x1 - PEM0 in gen2 and PEM1 in gen1 mode.
+ *                   0x2 - PEM0 in gen1 and PEM1 in gen2 mode.
+ *                   0x3 - both PEM0 & PEM1 are in gen2 mode.
+ *               SPEED value is ignored in this mode. QLM_SPD is set based on
+ *               pcie2x1 value in this mode.
+ *
+ * Returns       Return 0 on success or -1.
+ */
+int cvmx_qlm_configure_qlm(int qlm, int speed, int mode, int rc, int pcie2x1)
+{
+	union cvmx_mio_qlmx_cfg qlm_cfg;
+
+	/* The QLM speed varies for SGMII/XAUI and PCIe mode. And depends on
+	   reference clock. */
+	if (!OCTEON_IS_MODEL(OCTEON_CN61XX))
+		return -1;
+
+	if (qlm < 3)
+		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+	else {
+		cvmx_dprintf("WARNING: Invalid QLM(%d) passed\n", qlm);
+		return -1;
+	}
+
+	switch (qlm) {
+		/* SGMII/XAUI mode */
+	case 2:
+		if (mode < 2) {
+			/* cvmx_dprintf("Invalide mode(%d) for QLM(%d)\n", mode, qlm); */
+			qlm_cfg.s.qlm_spd = 0xf;
+			break;
+		}
+		qlm_cfg.s.qlm_spd = __cvmx_qlm_get_qlm_spd(qlm, speed);
+		qlm_cfg.s.qlm_cfg = mode;
+		break;
+	case 1:
+		if (mode == 1) {	/* 2x1 mode */
+			union cvmx_mio_qlmx_cfg qlm0;
+
+			/*
+			 * When QLM0 is configured as
+			 * PCIe(QLM_CFG=0x0) and enabled (QLM_SPD !=
+			 * 0xf), QLM1 cannot be configured as PCIe 2x1
+			 * mode (QLM_CFG=0x1) and enabled (QLM_SPD !=
+			 * 0xf).
+			 */
+			qlm0.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+			if (qlm0.s.qlm_spd != 0xf && qlm0.s.qlm_cfg == 0) {
+				cvmx_dprintf("Invalid mode(%d) for QLM(%d) as QLM1 is PCIe mode\n", mode, qlm);
+				qlm_cfg.s.qlm_spd = 0xf;
+				break;
+			}
+
+			/* Set QLM_SPD based on reference clock and mode */
+			if (__cvmx_qlm_is_ref_clock(qlm, 100)) {
+				if (pcie2x1 == 0x3)
+					qlm_cfg.s.qlm_spd = 0x0;
+				else if (pcie2x1 == 0x1)
+					qlm_cfg.s.qlm_spd = 0x2;
+				else if (pcie2x1 == 0x2)
+					qlm_cfg.s.qlm_spd = 0x1;
+				else if (pcie2x1 == 0x0)
+					qlm_cfg.s.qlm_spd = 0x3;
+				else
+					qlm_cfg.s.qlm_spd = 0xf;
+			} else if (__cvmx_qlm_is_ref_clock(qlm, 125)) {
+				if (pcie2x1 == 0x3)
+					qlm_cfg.s.qlm_spd = 0x4;
+				else if (pcie2x1 == 0x1)
+					qlm_cfg.s.qlm_spd = 0x6;
+				else if (pcie2x1 == 0x2)
+					qlm_cfg.s.qlm_spd = 0x9;
+				else if (pcie2x1 == 0x0)
+					qlm_cfg.s.qlm_spd = 0x7;
+				else
+					qlm_cfg.s.qlm_spd = 0xf;
+			}
+			qlm_cfg.s.qlm_cfg = mode;
+			cvmx_write_csr(CVMX_MIO_QLMX_CFG(qlm), qlm_cfg.u64);
+
+			/* Set PCIe mode bits */
+			__cvmx_qlm_set_qlm_pcie_mode(0, rc);
+			__cvmx_qlm_set_qlm_pcie_mode(1, rc);
+			return 0;
+		} else if (mode > 1) {
+			cvmx_dprintf("Invalid mode(%d) for QLM(%d).\n", mode, qlm);
+			qlm_cfg.s.qlm_spd = 0xf;
+			break;
+		}
+
+		/* Set speed and mode for PCIe 1x2 mode. */
+		if (__cvmx_qlm_is_ref_clock(qlm, 100)) {
+			if (speed == 5000)
+				qlm_cfg.s.qlm_spd = 0x1;
+			else if (speed == 2500)
+				qlm_cfg.s.qlm_spd = 0x2;
+			else
+				qlm_cfg.s.qlm_spd = 0xf;
+		} else if (__cvmx_qlm_is_ref_clock(qlm, 125)) {
+			if (speed == 5000)
+				qlm_cfg.s.qlm_spd = 0x4;
+			else if (speed == 2500)
+				qlm_cfg.s.qlm_spd = 0x6;
+			else
+				qlm_cfg.s.qlm_spd = 0xf;
+		} else
+			qlm_cfg.s.qlm_spd = 0xf;
+
+		qlm_cfg.s.qlm_cfg = mode;
+		cvmx_write_csr(CVMX_MIO_QLMX_CFG(qlm), qlm_cfg.u64);
+
+		/* Set PCIe mode bits */
+		__cvmx_qlm_set_qlm_pcie_mode(1, rc);
+		return 0;
+	case 0:
+		/* QLM_CFG = 0x1 - Reserved */
+		if (mode == 1) {
+			/* cvmx_dprintf("Invalid mode(%d) for QLM(%d)\n", mode, qlm); */
+			qlm_cfg.s.qlm_spd = 0xf;
+			break;
+		}
+		/* QLM_CFG = 0x0 - PCIe 1x4(PEM0) */
+		if (mode == 0 && speed != 5000 && speed != 2500) {
+			/* cvmx_dprintf("Invalid speed(%d) for QLM(%d) for PCIe mode.\n", speed, qlm); */
+			qlm_cfg.s.qlm_spd = 0xf;
+			break;
+		}
+
+		/* Set speed and mode */
+		qlm_cfg.s.qlm_spd = __cvmx_qlm_get_qlm_spd(qlm, speed);
+		qlm_cfg.s.qlm_cfg = mode;
+		cvmx_write_csr(CVMX_MIO_QLMX_CFG(qlm), qlm_cfg.u64);
+
+		/* Set PCIe mode bits */
+		if (mode == 0)
+			__cvmx_qlm_set_qlm_pcie_mode(0, rc);
+
+		return 0;
+	default:
+		cvmx_dprintf("WARNING: Invalid QLM(%d) passed\n", qlm);
+		qlm_cfg.s.qlm_spd = 0xf;
+	}
+	cvmx_write_csr(CVMX_MIO_QLMX_CFG(qlm), qlm_cfg.u64);
+	return 0;
+}
+
+void cvmx_qlm_display_registers(int qlm)
+{
+	int num_lanes = cvmx_qlm_get_lanes(qlm);
+	int lane;
+	const struct __cvmx_qlm_jtag_field *ptr = cvmx_qlm_jtag_get_field();
+
+	cvmx_dprintf("%29s", "Field[<stop bit>:<start bit>]");
+	for (lane = 0; lane < num_lanes; lane++)
+		cvmx_dprintf("\t      Lane %d", lane);
+	cvmx_dprintf("\n");
+
+	while (ptr != NULL && ptr->name) {
+		cvmx_dprintf("%20s[%3d:%3d]", ptr->name, ptr->stop_bit, ptr->start_bit);
+		for (lane = 0; lane < num_lanes; lane++) {
+			uint64_t val = cvmx_qlm_jtag_get(qlm, lane, ptr->name);
+			cvmx_dprintf("\t%4llu (0x%04llx)", (unsigned long long)val, (unsigned long long)val);
+		}
+		cvmx_dprintf("\n");
+		ptr++;
+	}
+}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-spi.c b/arch/mips/cavium-octeon/executive/cvmx-spi.c
index 74afb17..88b1474 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-spi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-spi.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,40 +22,39 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * Support library for the SPI
  */
-#include <asm/octeon/octeon.h>
-
-#include <asm/octeon/cvmx-config.h>
-
-#include <asm/octeon/cvmx-pko.h>
-#include <asm/octeon/cvmx-spi.h>
+#include <linux/export.h>
 
+#include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-spxx-defs.h>
 #include <asm/octeon/cvmx-stxx-defs.h>
 #include <asm/octeon/cvmx-srxx-defs.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-spi.h>
 
 #define INVOKE_CB(function_p, args...)		\
 	do {					\
 		if (function_p) {		\
-			res = function_p(args); \
+			res = function_p(args);	\
 			if (res)		\
 				return res;	\
 		}				\
 	} while (0)
 
 #if CVMX_ENABLE_DEBUG_PRINTS
-static const char *modes[] =
-    { "UNKNOWN", "TX Halfplex", "Rx Halfplex", "Duplex" };
+static const char * const modes[] = {
+	"UNKNOWN", "TX Halfplex", "Rx Halfplex", "Duplex"
+};
 #endif
 
-/* Default callbacks, can be overridden
- *  using cvmx_spi_get_callbacks/cvmx_spi_set_callbacks
+/*
+ * Default callbacks, can be overridden
+ * using cvmx_spi_get_callbacks/cvmx_spi_set_callbacks
  */
 static cvmx_spi_callbacks_t cvmx_spi_callbacks = {
 	.reset_cb = cvmx_spi_reset_cb,
@@ -154,15 +153,19 @@ int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode, int timeout)
 	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
 		return res;
 
+#if CVMX_ENABLE_DEBUG_PRINTS
 	cvmx_dprintf("SPI%d: Restart %s\n", interface, modes[mode]);
+#endif
 
 	/* Callback to perform SPI4 reset */
 	INVOKE_CB(cvmx_spi_callbacks.reset_cb, interface, mode);
 
-	/* NOTE: Calendar setup is not performed during restart */
-	/*       Refer to cvmx_spi_start_interface() for the full sequence */
-
-	/* Callback to perform clock detection */
+	/*
+	 * NOTE: Calendar setup is not performed during restart
+	 *       Refer to cvmx_spi_start_interface() for the full sequence
+	 *
+	 * Callback to perform clock detection
+	 */
 	INVOKE_CB(cvmx_spi_callbacks.clock_detect_cb, interface, mode, timeout);
 
 	/* Callback to perform SPI4 link training */
@@ -177,6 +180,7 @@ int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode, int timeout)
 
 	return res;
 }
+EXPORT_SYMBOL(cvmx_spi_restart_interface);
 
 /**
  * Callback to perform SPI4 reset
@@ -200,7 +204,6 @@ int cvmx_spi_reset_cb(int interface, cvmx_spi_mode_t mode)
 	union cvmx_stxx_int_msk stxx_int_msk;
 	union cvmx_spxx_trn4_ctl spxx_trn4_ctl;
 	int index;
-	uint64_t MS = cvmx_sysinfo_get()->cpu_clock_hz / 1000;
 
 	/* Disable SPI error events while we run BIST */
 	spxx_int_msk.u64 = cvmx_read_csr(CVMX_SPXX_INT_MSK(interface));
@@ -214,12 +217,11 @@ int cvmx_spi_reset_cb(int interface, cvmx_spi_mode_t mode)
 	spxx_clk_ctl.u64 = 0;
 	spxx_clk_ctl.s.runbist = 1;
 	cvmx_write_csr(CVMX_SPXX_CLK_CTL(interface), spxx_clk_ctl.u64);
-	cvmx_wait(10 * MS);
+	mdelay(10);
 	spxx_bist_stat.u64 = cvmx_read_csr(CVMX_SPXX_BIST_STAT(interface));
 	if (spxx_bist_stat.s.stat0)
-		cvmx_dprintf
-		    ("ERROR SPI%d: BIST failed on receive datapath FIFO\n",
-		     interface);
+		cvmx_dprintf("ERROR SPI%d: BIST failed on receive datapath FIFO\n",
+			     interface);
 	if (spxx_bist_stat.s.stat1)
 		cvmx_dprintf("ERROR SPI%d: BIST failed on RX calendar table\n",
 			     interface);
@@ -264,14 +266,14 @@ int cvmx_spi_reset_cb(int interface, cvmx_spi_mode_t mode)
 	spxx_clk_ctl.s.rcvtrn = 0;
 	spxx_clk_ctl.s.srxdlck = 0;
 	cvmx_write_csr(CVMX_SPXX_CLK_CTL(interface), spxx_clk_ctl.u64);
-	cvmx_wait(100 * MS);
+	mdelay(100);
 
 	/* Reset SRX0 DLL */
 	spxx_clk_ctl.s.srxdlck = 1;
 	cvmx_write_csr(CVMX_SPXX_CLK_CTL(interface), spxx_clk_ctl.u64);
 
 	/* Waiting for Inf0 Spi4 RX DLL to lock */
-	cvmx_wait(100 * MS);
+	mdelay(100);
 
 	/* Enable dynamic alignment */
 	spxx_trn4_ctl.s.trntest = 0;
@@ -333,8 +335,7 @@ int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode,
 			srxx_spi4_calx.s.prt1 = port++;
 			srxx_spi4_calx.s.prt2 = port++;
 			srxx_spi4_calx.s.prt3 = port++;
-			srxx_spi4_calx.s.oddpar =
-			    ~(cvmx_dpop(srxx_spi4_calx.u64) & 1);
+			srxx_spi4_calx.s.oddpar = ~(cvmx_dpop(srxx_spi4_calx.u64) & 1);
 			cvmx_write_csr(CVMX_SRXX_SPI4_CALX(index, interface),
 				       srxx_spi4_calx.u64);
 			index++;
@@ -380,9 +381,10 @@ int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode,
 
 		/* STX0 Training Control */
 		stxx_spi4_dat.u64 = 0;
-		/*Minimum needed by dynamic alignment */
+		/* Minimum needed by dynamic alignment */
 		stxx_spi4_dat.s.alpha = 32;
-		stxx_spi4_dat.s.max_t = 0xFFFF;	/*Minimum interval is 0x20 */
+		/* Minimum interval is 0x20 */
+		stxx_spi4_dat.s.max_t = 0xFFFF;
 		cvmx_write_csr(CVMX_STXX_SPI4_DAT(interface),
 			       stxx_spi4_dat.u64);
 
@@ -396,8 +398,7 @@ int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode,
 			stxx_spi4_calx.s.prt1 = port++;
 			stxx_spi4_calx.s.prt2 = port++;
 			stxx_spi4_calx.s.prt3 = port++;
-			stxx_spi4_calx.s.oddpar =
-			    ~(cvmx_dpop(stxx_spi4_calx.u64) & 1);
+			stxx_spi4_calx.s.oddpar = ~(cvmx_dpop(stxx_spi4_calx.u64) & 1);
 			cvmx_write_csr(CVMX_STXX_SPI4_CALX(index, interface),
 				       stxx_spi4_calx.u64);
 			index++;
@@ -431,7 +432,7 @@ int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 	int clock_transitions;
 	union cvmx_spxx_clk_stat stat;
 	uint64_t timeout_time;
-	uint64_t MS = cvmx_sysinfo_get()->cpu_clock_hz / 1000;
+	uint64_t MS = octeon_get_clock_rate() / 1000;
 
 	/*
 	 * Regardless of operating mode, both Tx and Rx clocks must be
@@ -465,8 +466,8 @@ int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 	cvmx_dprintf("SPI%d: Waiting to see RsClk...\n", interface);
 	timeout_time = cvmx_get_cycle() + 1000ull * MS * timeout;
 	/*
-	 * Require 100 clock transitions in order to avoid any noise in the
-	 * beginning.
+	 * Require 100 clock transitions in order to avoid any noise
+	 * in the beginning.
 	 */
 	clock_transitions = 100;
 	do {
@@ -474,7 +475,7 @@ int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 		if (stat.s.d4clk0 && stat.s.d4clk1 && clock_transitions) {
 			/*
 			 * We've seen a clock transition, so decrement
-			 * the number we still need
+			 * the number we still need.
 			 */
 			clock_transitions--;
 			cvmx_write_csr(CVMX_SPXX_CLK_STAT(interface), stat.u64);
@@ -508,12 +509,12 @@ int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 {
 	union cvmx_spxx_trn4_ctl spxx_trn4_ctl;
 	union cvmx_spxx_clk_stat stat;
-	uint64_t MS = cvmx_sysinfo_get()->cpu_clock_hz / 1000;
+	union cvmx_spxx_clk_ctl spxx_clk_ctl;
+	uint64_t MS = octeon_get_clock_rate() / 1000;
 	uint64_t timeout_time = cvmx_get_cycle() + 1000ull * MS * timeout;
 	int rx_training_needed;
 
 	/* SRX0 & STX0 Inf0 Links are configured - begin training */
-	union cvmx_spxx_clk_ctl spxx_clk_ctl;
 	spxx_clk_ctl.u64 = 0;
 	spxx_clk_ctl.s.seetrn = 0;
 	spxx_clk_ctl.s.clkdly = 0x10;
@@ -526,7 +527,7 @@ int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 	spxx_clk_ctl.s.rcvtrn = 1;
 	spxx_clk_ctl.s.srxdlck = 1;
 	cvmx_write_csr(CVMX_SPXX_CLK_CTL(interface), spxx_clk_ctl.u64);
-	cvmx_wait(1000 * MS);
+	mdelay(1000);
 
 	/* SRX0 clear the boot bit */
 	spxx_trn4_ctl.u64 = cvmx_read_csr(CVMX_SPXX_TRN4_CTL(interface));
@@ -535,12 +536,12 @@ int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 
 	/* Wait for the training sequence to complete */
 	cvmx_dprintf("SPI%d: Waiting for training\n", interface);
-	cvmx_wait(1000 * MS);
+	mdelay(1000);
 	/* Wait a really long time here */
 	timeout_time = cvmx_get_cycle() + 1000ull * MS * 600;
 	/*
-	 * The HRM says we must wait for 34 + 16 * MAXDIST training sequences.
-	 * We'll be pessimistic and wait for a lot more.
+	 * The HRM says we must wait for 34 + 16 * MAXDIST training
+	 * sequences.  We'll be pessimistic and wait for a lot more.
 	 */
 	rx_training_needed = 500;
 	do {
@@ -575,13 +576,12 @@ int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode, int timeout)
  */
 int cvmx_spi_calendar_sync_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 {
-	uint64_t MS = cvmx_sysinfo_get()->cpu_clock_hz / 1000;
+	uint64_t MS = octeon_get_clock_rate() / 1000;
 	if (mode & CVMX_SPI_MODE_RX_HALFPLEX) {
 		/* SRX0 interface should be good, send calendar data */
 		union cvmx_srxx_com_ctl srxx_com_ctl;
-		cvmx_dprintf
-		    ("SPI%d: Rx is synchronized, start sending calendar data\n",
-		     interface);
+		cvmx_dprintf("SPI%d: Rx is synchronized, start sending calendar data\n",
+			     interface);
 		srxx_com_ctl.u64 = cvmx_read_csr(CVMX_SRXX_COM_CTL(interface));
 		srxx_com_ctl.s.inf_en = 1;
 		srxx_com_ctl.s.st_en = 1;
@@ -589,12 +589,14 @@ int cvmx_spi_calendar_sync_cb(int interface, cvmx_spi_mode_t mode, int timeout)
 	}
 
 	if (mode & CVMX_SPI_MODE_TX_HALFPLEX) {
-		/* STX0 has achieved sync */
-		/* The corespondant board should be sending calendar data */
-		/* Enable the STX0 STAT receiver. */
+		/*
+		 * STX0 has achieved sync
+		 * The corespondant board should be sending calendar data
+		 * Enable the STX0 STAT receiver.
+		 */
 		union cvmx_spxx_clk_stat stat;
-		uint64_t timeout_time;
 		union cvmx_stxx_com_ctl stxx_com_ctl;
+		uint64_t timeout_time;
 		stxx_com_ctl.u64 = 0;
 		stxx_com_ctl.s.st_en = 1;
 		cvmx_write_csr(CVMX_STXX_COM_CTL(interface), stxx_com_ctl.u64);
@@ -661,7 +663,8 @@ int cvmx_spi_interface_up_cb(int interface, cvmx_spi_mode_t mode)
 		       gmxx_rxx_frm_max.u64);
 	gmxx_rxx_jabber.u64 = 0;
 	gmxx_rxx_jabber.s.cnt = 64 * 1024 - 4;
-	cvmx_write_csr(CVMX_GMXX_RXX_JABBER(0, interface), gmxx_rxx_jabber.u64);
+	cvmx_write_csr(CVMX_GMXX_RXX_JABBER(0, interface),
+		       gmxx_rxx_jabber.u64);
 
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
new file mode 100644
index 0000000..79c0ca0
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -0,0 +1,1589 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Interface to SRIO
+ */
+#include <linux/atomic.h>
+#include <linux/export.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-srio.h>
+#ifdef CONFIG_CAVIUM_DECODE_RSL
+#include <asm/octeon/cvmx-error.h>
+#endif
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-qlm.h>
+
+#define CVMX_SRIO_CONFIG_TIMEOUT        10000	/* 10ms */
+#define CVMX_SRIO_DOORBELL_TIMEOUT      10000	/* 10ms */
+#define CVMX_SRIO_CONFIG_PRIORITY       0
+#define ULL unsigned long long
+
+union cvmx_sli_address {
+	uint64_t u64;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t upper:2;		/* Normally 2 for XKPHYS */
+		uint64_t reserved_49_61:13;	/* Must be zero */
+		uint64_t io:1;			/* 1 for IO space access */
+		uint64_t did:5;			/* DID = 3 */
+		uint64_t subdid:3;		/* SubDID = 3-6 */
+		uint64_t reserved_36_39:4;	/* Must be zero */
+		uint64_t se:2;			/* SubDID extender */
+		uint64_t reserved_32_33:2;	/* Must be zero */
+		uint64_t hopcount:8;		/* Hopcount */
+		uint64_t address:24;		/* Mem address */
+#else
+		uint64_t address:24;
+		uint64_t hopcount:8;
+		uint64_t reserved_32_33:2;
+		uint64_t se:2;
+		uint64_t reserved_36_39:4;
+		uint64_t subdid:3;
+		uint64_t did:5;
+		uint64_t io:1;
+		uint64_t reserved_49_61:13;
+		uint64_t upper:2;
+#endif
+	} config;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t upper:2;	/* Normally 2 for XKPHYS */
+		uint64_t reserved_49_61:13;	/* Must be zero */
+		uint64_t io:1;	/* 1 for IO space access */
+		uint64_t did:5;	/* DID = 3 */
+		uint64_t subdid:3;	/* SubDID = 3-6 */
+		uint64_t reserved_36_39:4;	/* Must be zero */
+		uint64_t se:2;	/* SubDID extender */
+		uint64_t address:34;	/* Mem address */
+#else
+		uint64_t address:34;
+		uint64_t se:2;
+		uint64_t reserved_36_39:4;
+		uint64_t subdid:3;
+		uint64_t did:5;
+		uint64_t io:1;
+		uint64_t reserved_49_61:13;
+		uint64_t upper:2;
+#endif
+	} mem;
+};
+
+struct __cvmx_srio_state {
+	enum cvmx_srio_initialize_flags flags;
+	/* Reference count for SLI_MEM_ACCESS_SUBID[12-27]. Index=X-12 */
+	atomic_t subidx_ref_count[16];
+	/* Reference count for SRIOX_S2M_TYPE[0-15]. */
+	atomic_t s2m_ref_count[16];
+};
+
+static  struct __cvmx_srio_state __cvmx_srio_state[4];
+
+/**
+ * Allocate a SRIOX_S2M_TYPEX register for mapping a remote SRIO
+ * device's address range into Octeons SLI address space. Reference
+ * counting is used to allow sharing of duplicate setups. The current
+ * implementation treats reads and writes as paired, but this could be
+ * changed if we have trouble running out of indexes.
+ *
+ * @srio_port: SRIO port device is on
+ * @s2m:       SRIOX_S2M_TYPEX setup required
+ *
+ * Returns Index of CSR, or negative on failure
+ */
+static int __cvmx_srio_alloc_s2m(int srio_port, union cvmx_sriox_s2m_typex s2m)
+{
+	int s2m_index;
+	/*
+	 * Search through the S2M_TYPE registers looking for an unsed
+	 * one or one setup the way we need it.
+	 */
+	for (s2m_index = 0; s2m_index < 16; s2m_index++) {
+		/*
+		 * Increment ref count by 2 since we count read and
+		 * write independently. We might need a more
+		 * complicated search in the future.
+		 */
+		int ref_count = atomic_add_return(2, &__cvmx_srio_state[srio_port].s2m_ref_count[s2m_index]);
+		if (ref_count == 2) {
+			/* Unused location. Write our value */
+			cvmx_write_csr(CVMX_SRIOX_S2M_TYPEX(s2m_index, srio_port), s2m.u64);
+			/* Read back to make sure the update is complete */
+			cvmx_read_csr(CVMX_SRIOX_S2M_TYPEX(s2m_index, srio_port));
+			return s2m_index;
+		} else {
+			/* In use, see if we can use it */
+			if (cvmx_read_csr(CVMX_SRIOX_S2M_TYPEX(s2m_index, srio_port)) == s2m.u64)
+				return s2m_index;
+			else
+				atomic_add(-2, &__cvmx_srio_state[srio_port].s2m_ref_count[s2m_index]);
+		}
+	}
+	cvmx_dprintf("SRIO%d: Unable to find free SRIOX_S2M_TYPEX\n", srio_port);
+	return -1;
+}
+
+/**
+ * Free a handle allocated by __cvmx_srio_alloc_s2m
+ *
+ * @srio_port: SRIO port
+ * @index:     Index to free
+ */
+static void __cvmx_srio_free_s2m(int srio_port, int index)
+{
+	/* Read to force pending transactions to complete */
+	cvmx_read_csr(CVMX_SRIOX_S2M_TYPEX(index, srio_port));
+	atomic_add(-2, &__cvmx_srio_state[srio_port].s2m_ref_count[index]);
+}
+
+/**
+ * Allocate a SLI SubID to map a region of memory. Reference
+ * counting is used to allow sharing of duplicate setups.
+ *
+ * @subid:  SLI_MEM_ACCESS_SUBIDX we need an index for
+ *
+ * Returns Index of CSR, or negative on failure
+ */
+static int __cvmx_srio_alloc_subid(union cvmx_sli_mem_access_subidx subid)
+{
+	int mem_index;
+	/*
+	 * Search through the mem access subid registers looking for
+	 * an unsed one or one setup the way we need it. PCIe uses the
+	 * low indexes, so search backwards.
+	 */
+	for (mem_index = 27; mem_index >= 12; mem_index--) {
+		int ref_count = atomic_inc_return(&__cvmx_srio_state[0].subidx_ref_count[mem_index - 12]);
+		if (ref_count == 1) {
+			/* Unused location. Write our value */
+			cvmx_write_csr(CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(mem_index), subid.u64);
+			/* Read back the value to make sure the update is complete */
+			cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(mem_index));
+			return mem_index;
+		} else {
+			/* In use, see if we can use it */
+			if (cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(mem_index)) == subid.u64)
+				return mem_index;
+			else
+				atomic_dec(&__cvmx_srio_state[0].subidx_ref_count[mem_index - 12]);
+		}
+	}
+	cvmx_dprintf("SRIO: Unable to find free SLI_MEM_ACCESS_SUBIDX\n");
+	return -1;
+}
+
+/**
+ * Free a handle allocated by __cvmx_srio_alloc_subid
+ *
+ * @index:  Index to free
+ */
+static void __cvmx_srio_free_subid(int index)
+{
+	/* Read to force pending transactions to complete */
+	cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(index));
+	atomic_dec(&__cvmx_srio_state[0].subidx_ref_count[index - 12]);
+}
+
+/**
+ * Read 32bits from a local port
+ *
+ * @srio_port: SRIO port the device is on
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @result:    Result of the read. This will be unmodified on failure.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+static int __cvmx_srio_local_read32(int srio_port, uint32_t offset,
+				    uint32_t *result)
+{
+	union cvmx_sriox_maint_op maint_op;
+	union cvmx_sriox_maint_rd_data maint_rd_data;
+	maint_op.u64 = 0;
+	maint_op.s.op = 0;	/* Read */
+	maint_op.s.addr = offset;
+
+	/* Make sure SRIO isn't already busy */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_MAINT_OP(srio_port),
+				  union cvmx_sriox_maint_op, pending, ==, 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Pending bit stuck before config read\n", srio_port);
+		return -1;
+	}
+
+	/* Issue the read to the hardware */
+	cvmx_write_csr(CVMX_SRIOX_MAINT_OP(srio_port), maint_op.u64);
+
+	/* Wait for the hardware to complete the operation */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_MAINT_OP(srio_port),
+				  union cvmx_sriox_maint_op, pending, ==, 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config read timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Display and error and return if the operation failed to issue */
+	maint_op.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_OP(srio_port));
+	if (maint_op.s.fail) {
+		cvmx_dprintf("SRIO%d: Config read addressing error (offset=0x%x)\n", srio_port, (unsigned int)offset);
+		return -1;
+	}
+
+	/* Wait for the read data to become valid */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_MAINT_RD_DATA(srio_port),
+				  union cvmx_sriox_maint_rd_data, valid, ==, 1, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config read data timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Get the read data */
+	maint_rd_data.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_RD_DATA(srio_port));
+	*result = maint_rd_data.s.rd_data;
+	return 0;
+}
+
+/**
+ * Write 32bits to a local port
+ * @srio_port: SRIO port the device is on
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @data:      Data to write.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+static int __cvmx_srio_local_write32(int srio_port, uint32_t offset, uint32_t data)
+{
+	union cvmx_sriox_maint_op maint_op;
+	maint_op.u64 = 0;
+	maint_op.s.wr_data = data;
+	maint_op.s.op = 1;	/* Write */
+	maint_op.s.addr = offset;
+
+	/* Make sure SRIO isn't already busy */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_MAINT_OP(srio_port),
+				  union cvmx_sriox_maint_op, pending, ==, 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Pending bit stuck before config write\n", srio_port);
+		return -1;
+	}
+
+	/* Issue the write to the hardware */
+	cvmx_write_csr(CVMX_SRIOX_MAINT_OP(srio_port), maint_op.u64);
+
+	/* Wait for the hardware to complete the operation */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_MAINT_OP(srio_port),
+				  union cvmx_sriox_maint_op, pending, ==, 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config write timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Display and error and return if the operation failed to issue */
+	maint_op.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_OP(srio_port));
+	if (maint_op.s.fail) {
+		cvmx_dprintf("SRIO%d: Config write addressing error (offset=0x%x)\n", srio_port, (unsigned int)offset);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * Reset SRIO to link partner
+ *
+ * @srio_port:  SRIO port to initialize
+ *
+ * Returns Zero on success
+ */
+int cvmx_srio_link_rst(int srio_port)
+{
+	union cvmx_sriomaintx_port_0_link_resp link_resp;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+		return -1;
+
+	/* Generate a symbol reset to the link partner by writing 0x3. */
+	if (cvmx_srio_config_write32(srio_port, 0, -1, 0, 0, CVMX_SRIOMAINTX_PORT_0_LINK_REQ(srio_port), 3))
+		return -1;
+
+	if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0, CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port), &link_resp.u32))
+		return -1;
+
+	/* Poll until link partner has received the reset. */
+	while (link_resp.s.valid == 0) {
+		/* cvmx_dprintf("Waiting for Link Response\n"); */
+		if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0, CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port), &link_resp.u32))
+			return -1;
+	}
+
+	/* Valid response, Asserting MAC reset */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x1);
+
+	cvmx_wait(10);
+
+	/* De-asserting MAC Reset */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x0);
+
+	return 0;
+}
+
+/**
+ * Initialize a SRIO port for use.
+ *
+ * @srio_port: SRIO port to initialize
+ * @flags:     Optional flags
+ *
+ * Returns Zero on success
+ */
+int cvmx_srio_initialize(int srio_port, enum cvmx_srio_initialize_flags flags)
+{
+	union cvmx_sriomaintx_port_lt_ctl port_lt_ctl;
+	union cvmx_sriomaintx_port_rt_ctl port_rt_ctl;
+	union cvmx_sriomaintx_port_0_ctl port_0_ctl;
+	union cvmx_sriomaintx_core_enables core_enables;
+	union cvmx_sriomaintx_port_gen_ctl port_gen_ctl;
+	union cvmx_sriox_status_reg sriox_status_reg;
+	union cvmx_mio_rst_ctlx mio_rst_ctl;
+	union cvmx_sriox_imsg_vport_thr sriox_imsg_vport_thr;
+	union cvmx_dpi_sli_prtx_cfg prt_cfg;
+	union cvmx_sli_s2m_portx_ctl sli_s2m_portx_ctl;
+	union cvmx_sli_mem_access_ctl sli_mem_access_ctl;
+	union cvmx_sriomaintx_port_0_ctl2 port_0_ctl2;
+
+	sriox_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		/* All SRIO ports are connected to QLM0 */
+		enum cvmx_qlm_mode mode = cvmx_qlm_get_mode(0);
+		if (mode != CVMX_QLM_MODE_SRIO_1X4 &&
+		    mode != CVMX_QLM_MODE_SRIO_2X2 &&
+		    mode != CVMX_QLM_MODE_SRIO_4X1) {
+			cvmx_dprintf("SRIO%d: Initialization called on a port not in SRIO mode\n", srio_port);
+			return -1;
+		}
+	} else if (!sriox_status_reg.s.srio) {
+		cvmx_dprintf("SRIO%d: Initialization called on a port not in SRIO mode\n", srio_port);
+		return -1;
+	}
+
+	__cvmx_srio_state[srio_port].flags = flags;
+
+	/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be
+	   programmed */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_0)) {
+		if (srio_port) {
+			union cvmx_ciu_qlm1 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM1);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 5;
+			ciu_qlm.s.txmargin = 0x17;
+			cvmx_write_csr(CVMX_CIU_QLM1, ciu_qlm.u64);
+		} else {
+			union cvmx_ciu_qlm0 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM0);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 5;
+			ciu_qlm.s.txmargin = 0x17;
+			cvmx_write_csr(CVMX_CIU_QLM0, ciu_qlm.u64);
+		}
+	}
+
+	/* Don't receive or drive reset signals for the SRIO QLM */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		/* The reset signals are available only for srio_port == 0. */
+		if (srio_port == 0 || (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_2) && srio_port == 1)) {
+			union cvmx_mio_rst_cntlx mio_rst_cntl;
+			mio_rst_cntl.u64 = cvmx_read_csr(CVMX_MIO_RST_CNTLX(srio_port));
+			mio_rst_cntl.s.rst_drv = 0;
+			mio_rst_cntl.s.rst_rcv = 0;
+			mio_rst_cntl.s.rst_chip = 0;
+			cvmx_write_csr(CVMX_MIO_RST_CNTLX(srio_port), mio_rst_cntl.u64);
+		}
+		/* MIO_RST_CNTL2<prtmode> is initialized to 0 on cold reset */
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CNTLX(srio_port));
+	} else {
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
+		mio_rst_ctl.s.rst_drv = 0;
+		mio_rst_ctl.s.rst_rcv = 0;
+		mio_rst_ctl.s.rst_chip = 0;
+		cvmx_write_csr(CVMX_MIO_RST_CTLX(srio_port), mio_rst_ctl.u64);
+
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
+	}
+
+	cvmx_dprintf("SRIO%d: Port in %s mode\n", srio_port, (mio_rst_ctl.s.prtmode) ? "host" : "endpoint");
+
+	/* Bring the port out of reset if necessary */
+	switch (srio_port) {
+	case 0:
+		{
+			union cvmx_ciu_soft_prst prst;
+			prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+			if (prst.s.soft_prst) {
+				prst.s.soft_prst = 0;
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST, prst.u64);
+				/* Wait up to 250ms for the port to come out of reset */
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_STATUS_REG(srio_port),
+							  union cvmx_sriox_status_reg, access, ==, 1, 250000))
+					return -1;
+			}
+			break;
+		}
+	case 1:
+		{
+			union cvmx_ciu_soft_prst1 prst;
+			prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+			if (prst.s.soft_prst) {
+				prst.s.soft_prst = 0;
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST1, prst.u64);
+				/* Wait up to 250ms for the port to come out of reset */
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_STATUS_REG(srio_port),
+							  union cvmx_sriox_status_reg, access, ==, 1, 250000))
+					return -1;
+			}
+			break;
+		}
+	case 2:
+		{
+			union cvmx_ciu_soft_prst2 prst;
+			prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST2);
+			if (prst.s.soft_prst) {
+				prst.s.soft_prst = 0;
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST2, prst.u64);
+				/* Wait up to 250ms for the port to come out of reset */
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_STATUS_REG(srio_port),
+							  union cvmx_sriox_status_reg, access, ==, 1, 250000))
+					return -1;
+			}
+			break;
+		}
+	case 3:
+		{
+			union cvmx_ciu_soft_prst3 prst;
+			prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST3);
+			if (prst.s.soft_prst) {
+				prst.s.soft_prst = 0;
+				cvmx_write_csr(CVMX_CIU_SOFT_PRST3, prst.u64);
+				/* Wait up to 250ms for the port to come out of reset */
+				if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_STATUS_REG(srio_port),
+							  union cvmx_sriox_status_reg, access, ==, 1, 250000))
+					return -1;
+			}
+			break;
+		}
+	}
+
+	/* Disable the link while we make changes */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), &port_0_ctl.u32))
+		return -1;
+	port_0_ctl.s.o_enable = 0;
+	port_0_ctl.s.i_enable = 0;
+	port_0_ctl.s.prt_lock = 1;
+	port_0_ctl.s.disable = 0;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
+		return -1;
+
+	/* CN63XX Pass 2.x errata G-15273 requires the QLM De-emphasis be
+	   programmed when using a 156.25Mhz ref clock */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X)) {
+		union cvmx_mio_rst_boot mio_rst_boot;
+		union cvmx_sriomaintx_lane_x_status_0 lane_x_status;
+
+		/* Read the QLM config and speed pins */
+		mio_rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+		if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_LANE_X_STATUS_0(0, srio_port), &lane_x_status.u32))
+			return -1;
+
+		if (srio_port) {
+			union cvmx_ciu_qlm1 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM1);
+			switch (mio_rst_boot.cn63xx.qlm1_spd) {
+			case 0x4:	/* 1.25 Gbaud, 156.25MHz */
+				ciu_qlm.s.txbypass = 1;
+				ciu_qlm.s.txdeemph = 0x0;
+				ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0x11 : 0x1c;	/* short or med/long */
+				break;
+			case 0xb:	/* 5.0 Gbaud, 156.25MHz */
+				ciu_qlm.s.txbypass = 1;
+				ciu_qlm.s.txdeemph = (lane_x_status.s.rx_type == 0) ? 0xa : 0xf;	/* short or med/long */
+				ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0xf : 0x1a;	/* short or med/long */
+				break;
+			}
+			cvmx_write_csr(CVMX_CIU_QLM1, ciu_qlm.u64);
+		} else {
+			union cvmx_ciu_qlm0 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM0);
+			switch (mio_rst_boot.cn63xx.qlm0_spd) {
+			case 0x4:	/* 1.25 Gbaud, 156.25MHz */
+				ciu_qlm.s.txbypass = 1;
+				ciu_qlm.s.txdeemph = 0x0;
+				ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0x11 : 0x1c;	/* short or med/long */
+				break;
+			case 0xb:	/* 5.0 Gbaud, 156.25MHz */
+				ciu_qlm.s.txbypass = 1;
+				ciu_qlm.s.txdeemph = (lane_x_status.s.rx_type == 0) ? 0xa : 0xf;	/* short or med/long */
+				ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0xf : 0x1a;	/* short or med/long */
+				break;
+			}
+			cvmx_write_csr(CVMX_CIU_QLM0, ciu_qlm.u64);
+		}
+	}
+
+	/* Errata SRIO-14485: Link speed is reported incorrectly in CN63XX
+	   pass 1.x */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		union cvmx_sriomaintx_port_0_ctl2 port_0_ctl2;
+		if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), &port_0_ctl2.u32))
+			return -1;
+		if (port_0_ctl2.s.enb_500g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_625g = 1;
+		} else if (port_0_ctl2.s.enb_312g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_500g = 1;
+		} else if (port_0_ctl2.s.enb_250g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_312g = 1;
+		} else if (port_0_ctl2.s.enb_125g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_250g = 1;
+		} else {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_125g = 1;
+		}
+		if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), port_0_ctl2.u32))
+			return -1;
+	}
+
+	/* Errata SRIO-15351: Turn off SRIOMAINTX_MAC_CTRL[TYPE_MRG] as it may
+	   cause packet ACCEPT to be lost */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0) || OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_1)) {
+		union cvmx_sriomaintx_mac_ctrl mac_ctrl;
+		if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_MAC_CTRL(srio_port), &mac_ctrl.u32))
+			return -1;
+		mac_ctrl.s.type_mrg = 0;
+		if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_MAC_CTRL(srio_port), mac_ctrl.u32))
+			return -1;
+	}
+
+	/* Set the link layer timeout to 1ms. The default is too high and causes
+	   core bus errors */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), &port_lt_ctl.u32))
+		return -1;
+	port_lt_ctl.s.timeout = 1000000 / 200;	/* 1ms = 1000000ns / 200ns */
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), port_lt_ctl.u32))
+		return -1;
+
+	/* Set the logical layer timeout to 100ms. The default is too high and causes
+	   core bus errors */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), &port_rt_ctl.u32))
+		return -1;
+	port_rt_ctl.s.timeout = 100000000 / 200;	/* 100ms = 100000000ns / 200ns */
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), port_rt_ctl.u32))
+		return -1;
+
+	/* Allow memory and doorbells. Messaging is enabled later */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_CORE_ENABLES(srio_port), &core_enables.u32))
+		return -1;
+	core_enables.s.doorbell = 1;
+	core_enables.s.memory = 1;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_CORE_ENABLES(srio_port), core_enables.u32))
+		return -1;
+
+	/* Allow us to master transactions */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_GEN_CTL(srio_port), &port_gen_ctl.u32))
+		return -1;
+	port_gen_ctl.s.menable = 1;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_GEN_CTL(srio_port), port_gen_ctl.u32))
+		return -1;
+
+	/* Set the MRRS and MPS for optimal SRIO performance */
+	prt_cfg.u64 = cvmx_read_csr(CVMX_DPI_SLI_PRTX_CFG(srio_port));
+	prt_cfg.s.mps = 1;
+	prt_cfg.s.mrrs = 1;
+	prt_cfg.s.molr = 32;
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		prt_cfg.s.molr = ((prt_cfg.s.qlm_cfg == 1 || prt_cfg.s.qlm_cfg == 3) ? 32 : (prt_cfg.s.qlm_cfg == 4 || prt_cfg.s.qlm_cfg == 6) ? 16 : 8);
+	cvmx_write_csr(CVMX_DPI_SLI_PRTX_CFG(srio_port), prt_cfg.u64);
+
+	sli_s2m_portx_ctl.u64 = cvmx_read_csr(CVMX_PEXP_SLI_S2M_PORTX_CTL(srio_port));
+	sli_s2m_portx_ctl.s.mrrs = 1;
+	cvmx_write_csr(CVMX_PEXP_SLI_S2M_PORTX_CTL(srio_port), sli_s2m_portx_ctl.u64);
+
+	/* Setup RX messaging thresholds */
+	sriox_imsg_vport_thr.u64 = cvmx_read_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port));
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		sriox_imsg_vport_thr.s.max_tot = ((prt_cfg.s.qlm_cfg == 1 || prt_cfg.s.qlm_cfg == 3) ? 44 : 46);
+	else
+		sriox_imsg_vport_thr.s.max_tot = 48;
+	sriox_imsg_vport_thr.s.max_s1 = 24;
+	if (!OCTEON_IS_MODEL(OCTEON_CN66XX))
+		sriox_imsg_vport_thr.s.max_s1 = 24;
+	sriox_imsg_vport_thr.s.sp_vport = 1;
+	sriox_imsg_vport_thr.s.buf_thr = 4;
+	sriox_imsg_vport_thr.s.max_p1 = 12;
+	sriox_imsg_vport_thr.s.max_p0 = 12;
+	cvmx_write_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port), sriox_imsg_vport_thr.u64);
+
+	/* Setup RX messaging thresholds for other virtual ports. */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		union cvmx_sriox_imsg_vport_thr2 sriox_imsg_vport_thr2;
+		sriox_imsg_vport_thr2.u64 = cvmx_read_csr(CVMX_SRIOX_IMSG_VPORT_THR2(srio_port));
+		sriox_imsg_vport_thr2.s.max_s2 = 24;
+		sriox_imsg_vport_thr2.s.max_s3 = 24;
+		cvmx_write_csr(CVMX_SRIOX_IMSG_VPORT_THR2(srio_port), sriox_imsg_vport_thr2.u64);
+	}
+
+	/* Errata SRIO-X: SRIO error behavior may not be optimal in CN63XX pass 1.x */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		union cvmx_sriox_tx_ctrl sriox_tx_ctrl;
+		sriox_tx_ctrl.u64 = cvmx_read_csr(CVMX_SRIOX_TX_CTRL(srio_port));
+		sriox_tx_ctrl.s.tag_th2 = 2;
+		sriox_tx_ctrl.s.tag_th1 = 3;
+		sriox_tx_ctrl.s.tag_th0 = 4;
+		cvmx_write_csr(CVMX_SRIOX_TX_CTRL(srio_port), sriox_tx_ctrl.u64);
+	}
+
+	/* Errata SLI-15954: SLI relaxed order issues */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X)) {
+		union cvmx_sli_ctl_portx sli_ctl_portx;
+		sli_ctl_portx.u64 = cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port));
+		sli_ctl_portx.s.ptlp_ro = 1;	/* Set to same value for all MACs. */
+		sli_ctl_portx.s.ctlp_ro = 1;	/* Set to same value for all MACs. */
+		sli_ctl_portx.s.wait_com = 0;	/* So that no inbound stores wait for a commit */
+		sli_ctl_portx.s.waitl_com = 0;
+		cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port), sli_ctl_portx.u64);
+	}
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		/* Clear the ACK state */
+		if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port), 0))
+			return -1;
+	}
+
+	/* Bring the link down, then up, by writing to the SRIO port's
+	   PORT_0_CTL2 CSR. */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), &port_0_ctl2.u32))
+		return -1;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), port_0_ctl2.u32))
+		return -1;
+
+	/* Clear any pending interrupts */
+	cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port), cvmx_read_csr(CVMX_SRIOX_INT_REG(srio_port)));
+
+	/* Enable error reporting */
+#if defined(CONFIG_CAVIUM_DECODE_RSL)
+	cvmx_error_enable_group(CVMX_ERROR_GROUP_SRIO, srio_port);
+#endif
+
+	/* enable erb */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X)) {
+		union cvmx_sriomaintx_erb_lt_err_en erb_lt_err_en;
+
+		erb_lt_err_en.u32 = 0;
+		erb_lt_err_en.s.pkt_tout = 1;
+		erb_lt_err_en.s.io_err = 1;
+		if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_ERB_LT_ERR_EN(srio_port), erb_lt_err_en.u32))
+			return -1;
+	}
+
+	/* Finally enable the link */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), &port_0_ctl.u32))
+		return -1;
+	port_0_ctl.s.o_enable = 1;
+	port_0_ctl.s.i_enable = 1;
+	port_0_ctl.s.disable = 0;
+	port_0_ctl.s.prt_lock = 0;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
+		return -1;
+
+	/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
+	sli_mem_access_ctl.u64 = cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL);
+	sli_mem_access_ctl.s.max_word = 0;	/* Allow 16 words to combine */
+	sli_mem_access_ctl.s.timer = 127;	/* Wait up to 127 cycles for more data */
+	cvmx_write_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL, sli_mem_access_ctl.u64);
+
+	/* FIXME: Disable sending a link request when the SRIO link is
+	   brought up. For unknown reasons this code causes issues with some SRIO
+	   devices. As we currently don't support hotplug in software, this code
+	   should never be needed.  Without link down/up events, the ACKs should
+	   start off and stay synchronized */
+#if 0
+	/* Ask for a link and align our ACK state. CN63XXp1 didn't support this */
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		uint64_t stop_cycle;
+		union cvmx_sriomaintx_port_0_err_stat sriomaintx_port_0_err_stat;
+
+		/* Clear the SLI_CTL_PORTX[DIS_PORT[ bit to re-enable traffic-flow
+		   to the SRIO MACs. */
+		cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port), cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port)));
+
+		/* Wait a little to see if the link comes up */
+		stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 4 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+		do {
+			/* Read the port link status */
+			if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_ERR_STAT(srio_port), &sriomaintx_port_0_err_stat.u32))
+				return -1;
+		} while (!sriomaintx_port_0_err_stat.s.pt_ok && (cvmx_clock_get_count(CVMX_CLOCK_CORE) < stop_cycle));
+
+		/* Send link request if link is up */
+		if (sriomaintx_port_0_err_stat.s.pt_ok) {
+			union cvmx_sriomaintx_port_0_link_req link_req;
+			union cvmx_sriomaintx_port_0_link_resp link_resp;
+			link_req.u32 = 0;
+			link_req.s.cmd = 4;
+
+			/* Send the request */
+			if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_LINK_REQ(srio_port), link_req.u32))
+				return -1;
+
+			/* Wait for the response */
+			stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 8 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+			do {
+				if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port), &link_resp.u32))
+					return -1;
+			} while (!link_resp.s.valid && (cvmx_clock_get_count(CVMX_CLOCK_CORE) < stop_cycle));
+
+			/* Set our ACK state if we got a response */
+			if (link_resp.s.valid) {
+				union cvmx_sriomaintx_port_0_local_ackid local_ackid;
+				local_ackid.u32 = 0;
+				local_ackid.s.i_ackid = 0;
+				local_ackid.s.e_ackid = link_resp.s.ackid;
+				local_ackid.s.o_ackid = link_resp.s.ackid;
+				if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port), local_ackid.u32))
+					return -1;
+			} else
+				return -1;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+extern int _cvmx_srio_config_read32(int, int, int, int, uint8_t, uint32_t, uint32_t *);
+
+/**
+ * Read 32bits from a Device's config space
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID, or -1 for the local Octeon.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @hopcount:  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @result:    Result of the read. This will be unmodified on failure.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
+			    int is16bit, uint8_t hopcount, uint32_t offset, uint32_t *result)
+{
+	union cvmx_sriomaintx_erb_lt_err_det erb_lt_err_det;
+	int ret_val = -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X) && __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_ERB_LT_ERR_DET(srio_port), 0))
+		return ret_val;
+
+	_cvmx_srio_config_read32(srio_port, srcid_index, destid, is16bit, hopcount, offset, result);
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X) && *result == (uint32_t) ~0) {
+		__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_ERB_LT_ERR_DET(srio_port), &erb_lt_err_det.u32);
+		if (erb_lt_err_det.s.pkt_tout == 1 || erb_lt_err_det.s.io_err == 1)
+			__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_ERB_LT_ERR_DET(srio_port), 0);
+		else
+			ret_val = 0;
+	} else
+		ret_val = 0;
+
+	return ret_val;
+}
+
+int _cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
+			     int is16bit, uint8_t hopcount,
+			     uint32_t offset, uint32_t *result)
+{
+	if (destid == -1) {
+		int status = __cvmx_srio_local_read32(srio_port, offset, result);
+
+		if ((status == 0) && (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG))
+			cvmx_dprintf("SRIO%d: Local read [0x%06x] <= 0x%08x\n", srio_port, (unsigned int)offset, (unsigned int)*result);
+
+		return status;
+	} else {
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+			int return_code;
+			uint32_t pkt = 0;
+			uint32_t sourceid;
+			uint64_t stop_cycle;
+			char rx_buffer[64];
+
+			/* Tell the user */
+			if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, (unsigned int)offset);
+
+			/* Read the proper source ID */
+			if (srcid_index)
+				__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
+			else
+				__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
+
+			if (is16bit) {
+				/* Use the 16bit source ID */
+				sourceid &= 0xffff;
+
+				/* MAINT Reads are 11 bytes */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 11 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 1 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 8;	/* destID   [23:8] */
+				pkt |= sourceid >> 8;	/* sourceID [7:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= sourceid << 24;	/* sourceID [31:24] */
+				pkt |= 0 << 20;	/* transaction [23:20] */
+				pkt |= 8 << 16;	/* rdsize [19:16] */
+				pkt |= 0xc0 << 8;	/* srcTID [15:8] */
+				pkt |= hopcount;	/* hopcount [7:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 8;	/* offset [31:11, wdptr[10], reserved[9:8] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+			} else {
+				/* Use the 8bit source ID */
+				sourceid = (sourceid >> 16) & 0xff;
+
+				/* MAINT Reads are 9 bytes */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 9 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 0 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 16;	/* destID   [23:16] */
+				pkt |= sourceid << 8;	/* sourceID [15:8] */
+				pkt |= 0 << 4;	/* transaction [7:4] */
+				pkt |= 8 << 0;	/* rdsize [3:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= 0xc0 << 24;	/* srcTID [31:24] */
+				pkt |= hopcount << 16;	/* hopcount [23:16] */
+				pkt |= offset >> 8;	/* offset [15:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 24;	/* offset [31:27, wdptr[26], reserved[25:24] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+			}
+
+			stop_cycle = octeon_get_clock_rate() / 10 + read_c0_cvmcount();
+			do {
+				return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
+				if ((return_code == 0) && (read_c0_cvmcount() > stop_cycle)) {
+					if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+						cvmx_dprintf("timeout\n");
+					return_code = -1;
+				}
+			} while (return_code == 0);
+
+			if (return_code == ((is16bit) ? 23 : 19)) {
+				if (is16bit) {
+					if (offset & 4)
+						*result = *(uint32_t *) (rx_buffer + 15);
+					else
+						*result = *(uint32_t *) (rx_buffer + 11);
+				} else {
+					if (offset & 4)
+						*result = *(uint32_t *) (rx_buffer + 13);
+					else
+						*result = *(uint32_t *) (rx_buffer + 9);
+				}
+				if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+					cvmx_dprintf("0x%08x\n", (unsigned int)*result);
+				return_code = 0;
+			} else {
+				*result = 0xffffffff;
+				return_code = -1;
+			}
+
+			return return_code;
+		} else {
+			uint64_t physical;
+			physical = cvmx_srio_physical_map(srio_port,
+							  CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+							  CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY, srcid_index, destid, is16bit, offset + (hopcount << 24), 4);
+			if (!physical)
+				return -1;
+
+			if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, (unsigned int)offset);
+
+			/* Finally do the maintenance read to complete the config request */
+			*result = cvmx_read64_uint32(CVMX_ADD_IO_SEG(physical));
+			cvmx_srio_physical_unmap(physical, 4);
+
+			if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf("0x%08x\n", (unsigned int)*result);
+
+			return 0;
+		}
+	}
+}
+EXPORT_SYMBOL(cvmx_srio_config_read32);
+
+/**
+ * Write 32bits to a Device's config space
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID, or -1 for the local Octeon.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @hopcount:  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @data:      Data to write.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int _cvmx_srio_config_write32(int, int, int, int, uint8_t, uint32_t, uint32_t);
+
+int cvmx_srio_config_write32(int srio_port, int srcid_index, int destid, int is16bit, uint8_t hopcount, uint32_t offset, uint32_t data)
+{
+	int ret_val = -1;
+	uint32_t result;
+
+	result = 0;
+	_cvmx_srio_config_write32(srio_port, srcid_index, destid, is16bit, hopcount, offset, data);
+	_cvmx_srio_config_read32(srio_port, srcid_index, destid, is16bit, hopcount, offset, &result);
+	if (result == data)
+		ret_val = 0;
+
+	return ret_val;
+}
+
+int _cvmx_srio_config_write32(int srio_port, int srcid_index, int destid, int is16bit, uint8_t hopcount, uint32_t offset, uint32_t data)
+{
+	if (destid == -1) {
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf("SRIO%d: Local write[0x%06x] => 0x%08x\n", srio_port, (unsigned int)offset, (unsigned int)data);
+
+		return __cvmx_srio_local_write32(srio_port, offset, data);
+	} else {
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+			int return_code;
+			uint32_t pkt = 0;
+			uint32_t sourceid;
+			uint64_t stop_cycle;
+			char rx_buffer[64];
+
+			/* Tell the user */
+			if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, (unsigned int)offset,
+					     (unsigned int)data);
+
+			/* Read the proper source ID */
+			if (srcid_index)
+				__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
+			else
+				__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
+
+			if (is16bit) {
+				/* Use the 16bit source ID */
+				sourceid &= 0xffff;
+
+				/* MAINT Writes are 19 bytes */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 19 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 1 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 8;	/* destID   [23:8] */
+				pkt |= sourceid >> 8;	/* sourceID [7:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= sourceid << 24;	/* sourceID [31:24] */
+				pkt |= 1 << 20;	/* transaction [23:20] */
+				pkt |= 8 << 16;	/* wrsize [19:16] */
+				pkt |= 0xc0 << 8;	/* srcTID [15:8] */
+				pkt |= hopcount;	/* hopcount [7:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 8;	/* offset [31:11, wdptr[10], reserved[9:8] */
+				if ((offset & 4) == 0)
+					pkt |= 0xff & (data >> 24);	/* data [7:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				if (offset & 4) {
+					pkt = 0xff & (data >> 24);
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					pkt = data << 8;
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				} else {
+					pkt = data << 8;
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
+				}
+			} else {
+				/* Use the 8bit source ID */
+				sourceid = (sourceid >> 16) & 0xff;
+
+				/* MAINT Writes are 17 bytes */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 17 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 0 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 16;	/* destID   [23:16] */
+				pkt |= sourceid << 8;	/* sourceID [15:8] */
+				pkt |= 1 << 4;	/* transaction [7:4] */
+				pkt |= 8 << 0;	/* wrsize [3:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= 0xc0 << 24;	/* srcTID [31:24] */
+				pkt |= hopcount << 16;	/* hopcount [23:16] */
+				pkt |= offset >> 8;	/* offset [15:0] */
+				__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 24;	/* offset [31:27, wdptr[26], reserved[25:24] */
+				if (offset & 4) {
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					pkt = data >> 8;
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					pkt = data << 24;
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+				} else {
+					pkt |= data >> 8;	/* data [23:0] */
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					pkt = data << 24;	/* data [31:24] */
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+					__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
+				}
+			}
+
+			stop_cycle = octeon_get_clock_rate() / 10 + read_c0_cvmcount();
+			do {
+				return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
+				if ((return_code == 0) && (read_c0_cvmcount() > stop_cycle)) {
+					if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+						cvmx_dprintf("timeout\n");
+					return_code = -1;
+				}
+			} while (return_code == 0);
+
+			if (return_code == ((is16bit) ? 15 : 11))
+				return_code = 0;
+			else {
+				cvmx_dprintf("SRIO%d: Remote write failed\n", srio_port);
+				return_code = -1;
+			}
+
+			return return_code;
+		} else {
+			uint64_t physical = cvmx_srio_physical_map(srio_port,
+								   CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+								   CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+								   srcid_index, destid, is16bit, offset + (hopcount << 24), 4);
+			if (!physical)
+				return -1;
+
+			if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, (unsigned int)offset,
+					     (unsigned int)data);
+
+			/* Finally do the maintenance write to complete the config request */
+			cvmx_write64_uint32(CVMX_ADD_IO_SEG(physical), data);
+			return cvmx_srio_physical_unmap(physical, 4);
+		}
+	}
+}
+EXPORT_SYMBOL(cvmx_srio_config_write32);
+
+/**
+ * Send a RapidIO doorbell to a remote device
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @priority:  Doorbell priority (0-3)
+ * @data:      Data for doorbell.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_send_doorbell(int srio_port, int srcid_index, int destid,
+			    int is16bit, int priority, uint16_t data)
+{
+	union cvmx_sriox_tx_bell tx_bell;
+	tx_bell.u64 = 0;
+	tx_bell.s.data = data;
+	tx_bell.s.dest_id = destid;
+	tx_bell.s.src_id = srcid_index;
+	tx_bell.s.id16 = !!is16bit;
+	tx_bell.s.priority = priority;
+
+	/* Make sure the previous doorbell has completed */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_SRIOX_TX_BELL(srio_port),
+				  union cvmx_sriox_tx_bell, pending, ==, 0, CVMX_SRIO_DOORBELL_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Pending bit stuck before doorbell\n", srio_port);
+		return -1;
+	}
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("SRIO%d: Send doorbell destid=0x%x, priority=%d, data=0x%x\n", srio_port, destid, priority, 0xffff & data);
+
+	/*
+	 * Send the doorbell. We don't wait for it to complete. The
+	 * next doorbell may delay on the pending bit, but this gives
+	 * the caller the ability to do other stuff while the doorbell
+	 * processes.
+	 */
+	cvmx_write_csr(CVMX_SRIOX_TX_BELL(srio_port), tx_bell.u64);
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_srio_send_doorbell);
+
+/**
+ * Get the status of the last doorbell sent. If the dooorbell
+ * hardware is done, then the status is cleared to get ready for
+ * the next doorbell (or retry).
+ *
+ * @srio_port: SRIO port to check doorbell on
+ *
+ * Returns Doorbell status
+ */
+enum cvmx_srio_doorbell_status cvmx_srio_send_doorbell_status(int srio_port)
+{
+	union cvmx_sriox_tx_bell tx_bell;
+	union cvmx_sriox_tx_bell_info tx_bell_info;
+	union cvmx_sriox_int_reg int_reg;
+	union cvmx_sriox_int_reg int_reg_clear;
+
+	/* Return busy if the doorbell is still processing */
+	tx_bell.u64 = cvmx_read_csr(CVMX_SRIOX_TX_BELL(srio_port));
+	if (tx_bell.s.pending)
+		return CVMX_SRIO_DOORBELL_BUSY;
+
+	/* Read and clear the TX doorbell interrupts */
+	int_reg.u64 = cvmx_read_csr(CVMX_SRIOX_INT_REG(srio_port));
+	int_reg_clear.u64 = 0;
+	int_reg_clear.s.bell_err = int_reg.s.bell_err;
+	int_reg_clear.s.txbell = int_reg.s.txbell;
+	cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port), int_reg_clear.u64);
+
+	/* Check for errors */
+	if (int_reg.s.bell_err) {
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf("SRIO%d: Send doorbell failed\n", srio_port);
+		tx_bell_info.u64 = cvmx_read_csr(CVMX_SRIOX_TX_BELL_INFO(srio_port));
+		if (tx_bell_info.s.timeout)
+			return CVMX_SRIO_DOORBELL_TMOUT;
+		if (tx_bell_info.s.error)
+			return CVMX_SRIO_DOORBELL_ERROR;
+		if (tx_bell_info.s.retry)
+			return CVMX_SRIO_DOORBELL_RETRY;
+	}
+
+	/* Check if we're done */
+	if (int_reg.s.txbell)
+		return CVMX_SRIO_DOORBELL_DONE;
+
+	/* No doorbell found */
+	return CVMX_SRIO_DOORBELL_NONE;
+}
+
+/**
+ * Read a received doorbell and report data about it.
+ *
+ * @srio_port: SRIO port to check for the received doorbell
+ * @destid_index:
+ *                  Which Octeon destination ID was the doorbell for
+ * @sequence_num:
+ *                  Sequence number of doorbell (32bits)
+ * @srcid:     RapidIO source ID of the doorbell sender
+ * @priority:  Priority of the doorbell (0-3)
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @data:      Data in the doorbell (16 bits)
+ *
+ * Returns Doorbell status. Either DONE, NONE, or ERROR.
+ */
+enum cvmx_srio_doorbell_status cvmx_srio_receive_doorbell(int srio_port,
+							  int *destid_index,
+							  uint32_t *sequence_num,
+							  int *srcid,
+							  int *priority,
+							  int *is16bit, uint16_t *data)
+{
+	union cvmx_sriox_rx_bell_seq rx_bell_seq;
+	union cvmx_sriox_rx_bell rx_bell;
+
+	/* Check if there are any pending doorbells */
+	rx_bell_seq.u64 = cvmx_read_csr(CVMX_SRIOX_RX_BELL_SEQ(srio_port));
+	if (!rx_bell_seq.s.count)
+		return CVMX_SRIO_DOORBELL_NONE;
+
+	/* Read the doorbell and write our return parameters */
+	rx_bell.u64 = cvmx_read_csr(CVMX_SRIOX_RX_BELL(srio_port));
+	*sequence_num = rx_bell_seq.s.seq;
+	*srcid = rx_bell.s.src_id;
+	*priority = rx_bell.s.priority;
+	*is16bit = rx_bell.s.id16;
+	*data = rx_bell.s.data;
+	*destid_index = rx_bell.s.dest_id;
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("SRIO%d: Receive doorbell sequence=0x%x, srcid=0x%x, priority=%d, data=0x%x\n",
+			     srio_port, rx_bell_seq.s.seq, rx_bell.s.src_id, rx_bell.s.priority, rx_bell.s.data);
+
+	return CVMX_SRIO_DOORBELL_DONE;
+}
+
+/**
+ * transmit a packet to the Soft Packet FIFO (SPF).
+ *
+ * @srio_port: SRIO port to read the packet from.
+ * @buffer:    Buffer holding the packet.
+ * @buffer_length:
+ *                  Length of the buffer in bytes.
+ *
+ * Returns Returns the length of the packet sent. Negative on failure.
+ */
+int cvmx_srio_transmit_spf(int srio_port, void *buffer, int buffer_length)
+{
+	uint32_t *ptr = (uint32_t *)buffer;
+	union cvmx_sriomaintx_ir_sp_tx_stat sriomaintx_ir_sp_tx_stat;
+	union cvmx_sriomaintx_ir_sp_tx_ctrl sriomaintx_ir_sp_tx_ctrl;
+	uint32_t len, mod, last;
+
+	/* Read the SFP status */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_STAT(srio_port), &sriomaintx_ir_sp_tx_stat.u32))
+		return -1;
+
+	/* Return -1 if the state machine is busy */
+	if (sriomaintx_ir_sp_tx_stat.s.fifo_st != 0)
+		return -1;
+
+	/* arm the tx fifo. it allows 64kb. should be large enough */
+	sriomaintx_ir_sp_tx_ctrl.u32 = 0;
+	sriomaintx_ir_sp_tx_ctrl.s.octets = buffer_length;
+	if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), sriomaintx_ir_sp_tx_ctrl.u32))
+		return -1;
+
+	/* get the fraction at the end */
+	mod = buffer_length % 4;
+	len = buffer_length - mod;
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("SRIO%d: Soft packet FIFO sending %d bytes", srio_port, buffer_length);
+
+	/* write the packet four bytes at a time */
+	while (len > 0) {
+		__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), *ptr);
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf(" %08x", (unsigned int)*ptr);
+		ptr++;
+		len -= 4;
+	}
+
+	/* send the fraction, if any */
+	if (mod != 0) {
+		last = (*ptr >> (4 - mod) * 8) << (4 - mod) * 8;
+		__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), last);
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf(" %08x", (unsigned int)last);
+	}
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("\n");
+
+	/* Return the number of bytes in the buffer */
+	return buffer_length;
+}
+EXPORT_SYMBOL(cvmx_srio_transmit_spf);
+
+/**
+ * Receive a packet from the Soft Packet FIFO (SPF).
+ *
+ * @srio_port: SRIO port to read the packet from.
+ * @buffer:    Buffer to receive the packet.
+ * @buffer_length:
+ *                  Length of the buffer in bytes.
+ *
+ * Returns Returns the length of the packet read. Negative on failure.
+ *         Zero if no packets are available.
+ */
+int cvmx_srio_receive_spf(int srio_port, void *buffer, int buffer_length)
+{
+	uint32_t *ptr = (uint32_t *) buffer;
+	union cvmx_sriomaintx_ir_sp_rx_stat sriomaintx_ir_sp_rx_stat;
+
+	/* Read the SFP status */
+	if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_IR_SP_RX_STAT(srio_port), &sriomaintx_ir_sp_rx_stat.u32))
+		return -1;
+
+	/* Return zero if there isn't a packet available */
+	if (sriomaintx_ir_sp_rx_stat.s.buffers < 1)
+		return 0;
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("SRIO%d: Soft packet FIFO received %d bytes", srio_port, sriomaintx_ir_sp_rx_stat.s.octets);
+
+	/* Return error if the packet is larger than our buffer */
+	if (sriomaintx_ir_sp_rx_stat.s.octets > buffer_length)
+		return -1;
+
+	/* Read out the packet four bytes at a time */
+	buffer_length = sriomaintx_ir_sp_rx_stat.s.octets;
+	while (buffer_length > 0) {
+		__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_IR_SP_RX_DATA(srio_port), ptr);
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf(" %08x", (unsigned int)*ptr);
+		ptr++;
+		buffer_length -= 4;
+	}
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("\n");
+
+	/* Return the number of bytes in the buffer */
+	return sriomaintx_ir_sp_rx_stat.s.octets;
+}
+
+/**
+ * Map a remote device's memory region into Octeon's physical
+ * address area. The caller can then map this into a core using
+ * the TLB or XKPHYS.
+ *
+ * @srio_port: SRIO port to map the device on
+ * @write_op:  Type of operation to perform on a write to the device.
+ *                  Normally should be CVMX_SRIO_WRITE_MODE_AUTO.
+ * @write_priority:
+ *                  SRIO priority of writes (0-3)
+ * @read_op:   Type of operation to perform on reads to the device.
+ *                  Normally should be CVMX_SRIO_READ_MODE_NORMAL.
+ * @read_priority:
+ *                  SRIO priority of reads (0-3)
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @base:      Device base address to start the mapping
+ * @size:      Size of the mapping in bytes
+ *
+ * Returns Octeon 64bit physical address that accesses the remote device,
+ *         or zero on failure.
+ */
+uint64_t cvmx_srio_physical_map(int srio_port, enum cvmx_srio_write_mode write_op,
+				int write_priority, enum cvmx_srio_read_mode read_op,
+				int read_priority, int srcid_index, int destid,
+				int is16bit, uint64_t base, uint64_t size)
+{
+	union cvmx_sriox_s2m_typex needed_s2m_type;
+	union cvmx_sli_mem_access_subidx needed_subid;
+	int s2m_index;
+	int subdid;
+	union cvmx_sli_address sli_address;
+
+	/* We currently don't support mapping regions that span a 34 bit boundary.
+	   Keeping track of multiple regions to span 34 bits is hard and not
+	   likely to be needed */
+	if (((base + size - 1) >> 34) != (base >> 34)) {
+		cvmx_dprintf("SRIO%d: Failed to map range 0x%llx-0x%llx spanning a 34bit boundary\n", srio_port, (ULL) base, (ULL) base + size - 1);
+		return 0;
+	}
+
+	/* Build the S2M_TYPE we are going to need */
+	needed_s2m_type.u64 = 0;
+	needed_s2m_type.s.wr_op = write_op;
+	needed_s2m_type.s.rd_op = read_op;
+	needed_s2m_type.s.wr_prior = write_priority;
+	needed_s2m_type.s.rd_prior = read_priority;
+	needed_s2m_type.s.src_id = srcid_index;
+	needed_s2m_type.s.id16 = !!is16bit;
+
+	/* Build the needed SubID config */
+	needed_subid.u64 = 0;
+	needed_subid.s.port = srio_port;
+	needed_subid.s.nmerge = 0;
+
+	/* FIXME: We might want to use the device ID swapping modes so the device
+	   ID is part of the lower address bits. This would allow many more
+	   devices to share S2M_TYPE indexes. This would require "base+size-1"
+	   to fit in bits [17:0] or bits[25:0] for 8 bits of device ID */
+	if (base < (1ull << 34)) {
+		needed_subid.cn63xx.ba = destid;
+		needed_s2m_type.s.iaow_sel = 0;
+	} else if (base < (1ull << 42)) {
+		needed_subid.cn63xx.ba = (base >> 34) & 0xff;
+		needed_subid.cn63xx.ba |= ((uint64_t) destid & 0xff) << (42 - 34);
+		needed_subid.cn63xx.ba |= (((uint64_t) destid >> 8) & 0xff) << (51 - 34);
+		needed_s2m_type.s.iaow_sel = 1;
+	} else {
+		if (destid >> 8) {
+			cvmx_dprintf("SRIO%d: Attempt to map 16bit device ID 0x%x using 66bit addressing\n", srio_port, destid);
+			return 0;
+		}
+		if (base >> 50) {
+			cvmx_dprintf("SRIO%d: Attempt to map address 0x%llx using 66bit addressing\n", srio_port, (ULL) base);
+			return 0;
+		}
+		needed_subid.cn63xx.ba = (base >> 34) & 0xffff;
+		needed_subid.cn63xx.ba |= ((uint64_t) destid & 0xff) << (51 - 34);
+		needed_s2m_type.s.iaow_sel = 2;
+	}
+
+	/* Find a S2M_TYPE index to use. If this fails return 0 */
+	s2m_index = __cvmx_srio_alloc_s2m(srio_port, needed_s2m_type);
+	if (s2m_index == -1)
+		return 0;
+
+	/* Attach the SubID to the S2M_TYPE index */
+	needed_subid.s.rtype = s2m_index & 3;
+	needed_subid.s.wtype = s2m_index & 3;
+	needed_subid.cn63xx.ba |= (((uint64_t) s2m_index >> 2) & 1) << (50 - 34);
+	needed_subid.cn63xx.ba |= (((uint64_t) s2m_index >> 3) & 1) << (59 - 34);
+
+	/* Allocate a SubID for use */
+	subdid = __cvmx_srio_alloc_subid(needed_subid);
+	if (subdid == -1) {
+		/* Free the s2m_index as we aren't using it */
+		__cvmx_srio_free_s2m(srio_port, s2m_index);
+		return 0;
+	}
+
+	/* Build the final core physical address */
+	sli_address.u64 = 0;
+	sli_address.mem.io = 1;
+	sli_address.mem.did = 3;
+	sli_address.mem.subdid = subdid >> 2;
+	sli_address.mem.se = subdid & 3;
+	sli_address.mem.address = base;	/* Bits[33:0] of full address */
+	return sli_address.u64;
+}
+
+/**
+ * Unmap a physical address window created by cvmx_srio_phys_map().
+ *
+ * @physical_address:
+ *               Physical address returned by cvmx_srio_phys_map().
+ * @size:   Size used on original call.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_physical_unmap(uint64_t physical_address, uint64_t size)
+{
+	union cvmx_sli_mem_access_subidx subid;
+	int subdid = (physical_address >> 40) & 7;
+	int extender = (physical_address >> 34) & 3;
+	int mem_index = subdid * 4 + extender;
+	int read_s2m_type;
+
+	/* Get the subid setup so we can figure out where this mapping was for */
+	subid.u64 = cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(mem_index));
+	/* Type[0] is mapped to the Relaxed Ordering
+	   Type[1] is mapped to the No Snoop
+	   Type[2] is mapped directly to bit 50 of the SLI address
+	   Type[3] is mapped directly to bit 59 of the SLI address */
+	read_s2m_type = ((subid.cn63xx.ba >> (50 - 34)) & 1 << 2) | ((subid.cn63xx.ba >> (59 - 34)) & 1 << 3);
+	read_s2m_type |= subid.s.rtype;
+	__cvmx_srio_free_subid(mem_index);
+	__cvmx_srio_free_s2m(subid.s.port, read_s2m_type);
+	return 0;
+}
+
+/**
+ * fill out outbound message descriptor
+ *
+ * @port:        pip/ipd port number
+ * @buf_ptr:     pointer to a buffer pointer. the buffer pointer points
+ *                    to a chain of buffers that hold an outbound srio packet.
+ *                    the packet can take the format of (1) a pip/ipd inbound
+ *                    message or (2) an application-generated outbound message
+ * @desc_ptr:    pointer to an outbound message descriptor. should be null
+ *                    if *buf_ptr is in the format (1)
+ *
+ * Returns           0 on success; negative of failure.
+ */
+int cvmx_srio_omsg_desc(uint64_t port, union cvmx_buf_ptr *buf_ptr,
+			union cvmx_srio_tx_message_header *desc_ptr)
+{
+	int ret_val = -1;
+	int intf_num;
+	cvmx_helper_interface_mode_t imode;
+
+	uint64_t *desc_addr, *hdr_addr;
+	struct cvmx_srio_rx_message_header rx_msg_hdr;
+	union cvmx_srio_tx_message_header *tx_msg_hdr_ptr;
+
+	if (buf_ptr == NULL)
+		return ret_val;
+
+	/* check if port is an srio port */
+	intf_num = cvmx_helper_get_interface_num(port);
+	imode = cvmx_helper_interface_get_mode(intf_num);
+	if (imode != CVMX_HELPER_INTERFACE_MODE_SRIO)
+		return ret_val;
+
+	/* app-generated outbound message. descriptor space pre-allocated */
+	if (desc_ptr != NULL) {
+		desc_addr = (uint64_t *) cvmx_phys_to_ptr((*buf_ptr).s.addr);
+		*desc_addr = *(uint64_t *) desc_ptr;
+		ret_val = 0;
+		return ret_val;
+	}
+
+	/* pip/ipd inbound message. 16-byte srio message header is present */
+	hdr_addr = (uint64_t *) cvmx_phys_to_ptr((*buf_ptr).s.addr);
+	rx_msg_hdr.word0.u64 = *hdr_addr;
+
+	/* adjust buffer pointer to get rid of srio message header word 0 */
+	(*buf_ptr).s.addr += 8;
+	(*buf_ptr).s.size -= 8;	/* last buffer or not */
+	if ((*buf_ptr).s.addr >> 7 > ((*buf_ptr).s.addr - 8) >> 7)
+		(*buf_ptr).s.back++;
+	tx_msg_hdr_ptr = cvmx_phys_to_ptr((*buf_ptr).s.addr);
+
+	/* transfer values from rx to tx */
+	tx_msg_hdr_ptr->s.prio = rx_msg_hdr.word0.s.prio;
+	tx_msg_hdr_ptr->s.tt = rx_msg_hdr.word0.s.tt;	/* called id in hrm */
+	tx_msg_hdr_ptr->s.sis = rx_msg_hdr.word0.s.dis;
+	tx_msg_hdr_ptr->s.ssize = rx_msg_hdr.word0.s.ssize;
+	tx_msg_hdr_ptr->s.did = rx_msg_hdr.word0.s.sid;
+	tx_msg_hdr_ptr->s.mbox = rx_msg_hdr.word0.s.mbox;
+
+	/* other values we have to decide */
+	tx_msg_hdr_ptr->s.xmbox = 0;	/* multi-segement in general */
+	tx_msg_hdr_ptr->s.letter = 0;	/* fake like traffic gen */
+	tx_msg_hdr_ptr->s.lns = 0;	/* not use sriox_omsg_ctrly[] */
+	tx_msg_hdr_ptr->s.intr = 1;	/* get status */
+
+	ret_val = 0;
+	return ret_val;
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-fau.h b/arch/mips/include/asm/octeon/cvmx-fau.h
index a6939fc..69bc208 100644
--- a/arch/mips/include/asm/octeon/cvmx-fau.h
+++ b/arch/mips/include/asm/octeon/cvmx-fau.h
@@ -45,12 +45,12 @@
 #define CVMX_FAU_BITS_SIZE          12, 11
 #define CVMX_FAU_BITS_REGISTER      10, 0
 
-typedef enum {
+enum cvmx_fau_op_size {
 	CVMX_FAU_OP_SIZE_8 = 0,
 	CVMX_FAU_OP_SIZE_16 = 1,
 	CVMX_FAU_OP_SIZE_32 = 2,
 	CVMX_FAU_OP_SIZE_64 = 3
-} cvmx_fau_op_size_t;
+};
 
 /**
  * Tagwait return definition. If a timeout occurs, the error
@@ -320,7 +320,7 @@ cvmx_fau_tagwait_fetch_and_add8(cvmx_fau_reg_8_t reg, int8_t value)
  */
 static inline uint64_t __cvmx_fau_iobdma_data(uint64_t scraddr, int64_t value,
 					      uint64_t tagwait,
-					      cvmx_fau_op_size_t size,
+					      enum cvmx_fau_op_size size,
 					      uint64_t reg)
 {
 	return CVMX_FAU_LOAD_IO_ADDRESS |
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index 88527fa..facc7d8 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,27 +22,24 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- *
+/*
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
- *
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
 
 #include "cvmx-helper.h"
 
-typedef enum {
-	set_phy_link_flags_autoneg = 0x1,
-	set_phy_link_flags_flow_control_dont_touch = 0x0 << 1,
-	set_phy_link_flags_flow_control_enable = 0x1 << 1,
-	set_phy_link_flags_flow_control_disable = 0x2 << 1,
-	set_phy_link_flags_flow_control_mask = 0x3 << 1,	/* Mask for 2 bit wide flow control field */
-} cvmx_helper_board_set_phy_link_flags_types_t;
+enum cvmx_helper_board_usb_clock_types {
+	USB_CLOCK_TYPE_REF_12,
+	USB_CLOCK_TYPE_REF_24,
+	USB_CLOCK_TYPE_REF_48,
+	USB_CLOCK_TYPE_CRYSTAL_12,
+};
 
 /*
  * Fake IPD port, the RGMII/MII interface may use different PHY, use
@@ -51,24 +48,14 @@ typedef enum {
 #define CVMX_HELPER_BOARD_MGMT_IPD_PORT     -10
 
 /**
- * cvmx_override_board_link_get(int ipd_port) is a function
- * pointer. It is meant to allow customization of the process of
- * talking to a PHY to determine link speed. It is called every
- * time a PHY must be polled for link status. Users should set
- * this pointer to a function before calling any cvmx-helper
- * operations.
- */
-extern cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port);
-
-/**
  * Return the MII PHY address associated with the given IPD
  * port. A result of -1 means there isn't a MII capable PHY
  * connected to this port. On chips supporting multiple MII
  * busses the bus number is encoded in bits <15:8>.
  *
- * This function must be modifed for every new Octeon board.
+ * This function must be modified for every new Octeon board.
  * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relys on the
+ * data to determine board types and revisions. It relies on the
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
@@ -79,34 +66,14 @@ extern cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port);
 extern int cvmx_helper_board_get_mii_address(int ipd_port);
 
 /**
- * This function as a board specific method of changing the PHY
- * speed, duplex, and autonegotiation. This programs the PHY and
- * not Octeon. This can be used to force Octeon's links to
- * specific settings.
- *
- * @phy_addr:  The address of the PHY to program
- * @link_flags:
- *                  Flags to control autonegotiation.  Bit 0 is autonegotiation
- *                  enable/disable to maintain backware compatibility.
- * @link_info: Link speed to program. If the speed is zero and autonegotiation
- *                  is enabled, all possible negotiation speeds are advertised.
- *
- * Returns Zero on success, negative on failure
- */
-int cvmx_helper_board_link_set_phy(int phy_addr,
-				   cvmx_helper_board_set_phy_link_flags_types_t
-				   link_flags,
-				   cvmx_helper_link_info_t link_info);
-
-/**
  * This function is the board specific method of determining an
  * ethernet ports link speed. Most Octeon boards have Marvell PHYs
  * and are handled by the fall through case. This function must be
  * updated for boards that don't have the normal Marvell PHYs.
  *
- * This function must be modifed for every new Octeon board.
+ * This function must be modified for every new Octeon board.
  * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relys on the
+ * data to determine board types and revisions. It relies on the
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
@@ -126,9 +93,9 @@ extern cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port);
  * support and should return the number of actual ports on the
  * board.
  *
- * This function must be modifed for every new Octeon board.
+ * This function must be modified for every new Octeon board.
  * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relys on the
+ * data to determine board types and revisions. It relies on the
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
@@ -139,8 +106,7 @@ extern cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port);
  * Returns Number of ports the actual board supports. Many times this will
  *         simple be "support_ports".
  */
-extern int __cvmx_helper_board_interface_probe(int interface,
-					       int supported_ports);
+extern int __cvmx_helper_board_interface_probe(int interface, int supported_ports);
 
 /**
  * Enable packet input/output from the hardware. This function is
@@ -154,4 +120,25 @@ extern int __cvmx_helper_board_interface_probe(int interface,
  */
 extern int __cvmx_helper_board_hardware_enable(int interface);
 
+/**
+ * Gets the clock type used for the USB block based on board type.
+ * Used by the USB code for auto configuration of clock type.
+ *
+ * Returns USB clock type enumeration
+ */
+enum cvmx_helper_board_usb_clock_types __cvmx_helper_board_usb_get_clock_type(void);
+
+/**
+ * Adjusts the number of available USB ports on Octeon based on board
+ * specifics.
+ *
+ * @supported_ports: expected number of ports based on chip type;
+ *
+ *
+ * Returns number of available usb ports, based on board specifics.
+ *         Return value is supported_ports if function does not
+ *         override.
+ */
+int __cvmx_helper_board_usb_get_num_ports(int supported_ports);
+
 #endif /* __CVMX_HELPER_BOARD_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
new file mode 100644
index 0000000..1386a34
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -0,0 +1,232 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Helper Functions for the Configuration Framework
+ *
+ * OCTEON_CN68XX introduces a flexible hw interface configuration
+ * scheme. To cope with this change and the requirements of
+ * configurability for other system resources, e.g., IPD/PIP pknd and
+ * PKO ports and queues, a configuration framework for the SDK is
+ * designed. It has two goals: first to recognize and establish the
+ * default configuration and, second, to allow the user to define key
+ * parameters in a high-level language.
+ *
+ * The helper functions query the QLM setup to help achieving the
+ * first goal.
+ *
+ * The second goal is accomplished by generating
+ * cvmx_helper_cfg_init() from a high-level lanaguage.
+ *
+ */
+
+#ifndef __CVMX_HELPER_CFG_H__
+#define __CVMX_HELPER_CFG_H__
+
+#define CVMX_HELPER_CFG_MAX_IFACE		9
+#define CVMX_HELPER_CFG_MAX_PKO_PORT		128
+#define CVMX_HELPER_CFG_MAX_PIP_BPID		64
+#define CVMX_HELPER_CFG_MAX_PIP_PKND		64
+#define CVMX_HELPER_CFG_MAX_PKO_QUEUES		256
+#define CVMX_HELPER_CFG_MAX_PORT_PER_IFACE	256
+
+/* The default return value upon failure */
+#define CVMX_HELPER_CFG_INVALID_VALUE		-1
+
+/*
+ * Config Options
+ *
+ * These options have to be set via cvmx_helper_cfg_opt_set() before calling the
+ * routines that set up the hw. These routines process the options and set them
+ * correctly to take effect at runtime.
+ */
+enum cvmx_helper_cfg_option {
+	/*
+	 * Global option to control if the SDK configures units (DMA,
+	 * SSO, and PKO) to send don't write back (DWB) requests for
+	 * freed buffers. Set to 1/0 to enable/disable DWB.
+	 *
+	 * For programs that fit inside L2, sending DWB just causes
+	 * more L2 operations without benefit.
+	 */
+	CVMX_HELPER_CFG_OPT_USE_DWB,
+	CVMX_HELPER_CFG_OPT_MAX
+};
+
+/**
+ * Return configured pknd for the port
+ *
+ * @interface: the interface number
+ * @index: the port's index number
+ * Returns the pknd
+ */
+extern int __cvmx_helper_cfg_pknd(int interface, int index);
+
+/*
+ * Return the configured bpid for the port
+ *
+ * @interface: the interface number
+ * @index: the port's index number
+ * Returns the bpid
+ */
+extern int __cvmx_helper_cfg_bpid(int interface, int index);
+
+/*
+ * Return the configured pko_port base for the port
+ *
+ * @interface: the interface number
+ * @index: the port's index number
+ * Returns the pko_port base
+ */
+extern int __cvmx_helper_cfg_pko_port_base(int interface, int index);
+
+/*
+ * Return the configured number of pko_ports for the port
+ *
+ * @interface: the interface number
+ * @index: the port's index number
+ * Returns the number of pko_ports
+ */
+extern int __cvmx_helper_cfg_pko_port_num(int interface, int index);
+
+/*
+ * Return the configured pko_queue base for the pko_port
+ *
+ * @pko_port:
+ * Returns the pko_queue base
+ */
+extern int __cvmx_helper_cfg_pko_queue_base(int pko_port);
+
+/*
+ * Return the configured number of pko_queues for the pko_port
+ *
+ * @pko_port:
+ * Returns the number of pko_queues
+ */
+extern int __cvmx_helper_cfg_pko_queue_num(int pko_port);
+
+/*
+ * Return the interface the pko_port is configured for
+ *
+ * @pko_port:
+ * Returns the interface for the pko_port
+ */
+extern int __cvmx_helper_cfg_pko_port_interface(int pko_port);
+
+/*
+ * Return the index of the port the pko_port is configured for
+ *
+ * @pko_port:
+ * Returns the index of the port
+ */
+extern int __cvmx_helper_cfg_pko_port_index(int pko_port);
+
+/*
+ * Return the pko_eid of the pko_port
+ *
+ * @pko_port:
+ * Returns the pko_eid
+ */
+extern int __cvmx_helper_cfg_pko_port_eid(int pko_port);
+
+/*
+ * Return the max# of pko queues allocated.
+ *
+ * Returns the max# of pko queues
+ *
+ * Note: there might be holes in the queue space depending on user
+ * configuration. The function returns the highest queue's index in
+ * use.
+ */
+extern int __cvmx_helper_cfg_pko_max_queue(void);
+
+/*
+ * Return the max# of PKO DMA engines allocated.
+ *
+ * Returns the max# of DMA engines
+ *
+ * NOTE: the DMA engines are allocated contiguously and starting from
+ * 0.
+ */
+extern int __cvmx_helper_cfg_pko_max_engine(void);
+
+/*
+ * Get the value set for the config option ``opt''.
+ *
+ * @opt: is the config option.
+ * Returns the value set for the option
+ */
+extern uint64_t cvmx_helper_cfg_opt_get(enum cvmx_helper_cfg_option opt);
+
+/*
+ * Set the value for a config option.
+ *
+ * @opt: is the config option.
+ * @val: is the value to set for the opt.
+ * Returns 0 for success and -1 on error
+ *
+ * Note an option here is a config-time parameter and this means that
+ * it has to be set before calling the corresponding setup functions
+ * that actually sets the option in hw.
+ */
+extern int cvmx_helper_cfg_opt_set(enum cvmx_helper_cfg_option opt, uint64_t val);
+
+/*
+ * Retrieve the pko_port base given ipd_port.
+ *
+ * @ipd_port: is the IPD eport
+ * Returns the corresponding PKO port base for the physical port
+ * represented by the IPD eport or CVMX_HELPER_CFG_INVALID_VALUE.
+ */
+extern int cvmx_helper_cfg_ipd2pko_port_base(int ipd_port);
+
+/*
+ * Retrieve the number of pko_ports given ipd_port.
+ *
+ * @ipd_port: is the IPD eport
+ * Returns the corresponding number of PKO ports for the physical port
+ *  represented by IPD eport or CVMX_HELPER_CFG_INVALID_VALUE.
+ */
+extern int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port);
+
+/*
+ * The init function
+ *
+ * @none:
+ * Returns 0 for success.
+ *
+ * Note: this function is meant to be called to set the ``configured
+ * parameters,'' e.g., pknd, bpid, etc. and therefore should be before
+ * any of the corresponding cvmx_helper_cfg_xxxx() functions are
+ * called.
+ */
+
+extern int __cvmx_helper_cfg_init(void);
+
+#endif /* __CVMX_HELPER_CFG_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-errata.h b/arch/mips/include/asm/octeon/cvmx-helper-errata.h
index 5fc9918..86af7be 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-errata.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-errata.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,12 +22,51 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
+/*
+ * Fixes and workaround for Octeon chip errata. This file
+ * contains functions called by cvmx-helper to workaround known
+ * chip errata. For the most part, code doesn't need to call
+ * these functions directly.
+ */
 #ifndef __CVMX_HELPER_ERRATA_H__
 #define __CVMX_HELPER_ERRATA_H__
 
-extern void __cvmx_helper_errata_qlm_disable_2nd_order_cdr(int qlm);
+#include "cvmx-wqe.h"
+
+/**
+ * Function to adjust internal IPD pointer alignments
+ *
+ * Returns 0 on success
+ *         !0 on failure
+ */
+extern int __cvmx_helper_errata_fix_ipd_ptr_alignment(void);
 
+/**
+ * This function needs to be called on all Octeon chips with
+ * errata PKI-100.
+ *
+ * The Size field is 8 too large in WQE and next pointers
+ *
+ *  The Size field generated by IPD is 8 larger than it should
+ *  be. The Size field is <55:40> of both:
+ *      - WORD3 in the work queue entry, and
+ *      - the next buffer pointer (which precedes the packet data
+ *        in each buffer).
+ *
+ * @work:   Work queue entry to fix
+ * Returns Zero on success. Negative on failure
+ */
+extern int cvmx_helper_fix_ipd_packet_chain(cvmx_wqe_t *work);
+
+/**
+ * Due to errata G-720, the 2nd order CDR circuit on CN52XX pass
+ * 1 doesn't work properly. The following code disables 2nd order
+ * CDR for the specified QLM.
+ *
+ * @qlm:    QLM to disable 2nd order CDR for.
+ */
+extern void __cvmx_helper_errata_qlm_disable_2nd_order_cdr(int qlm);
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-ilk.h b/arch/mips/include/asm/octeon/cvmx-helper-ilk.h
new file mode 100644
index 0000000..5dd076e
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-helper-ilk.h
@@ -0,0 +1,86 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Functions for ILK initialization, configuration,
+ * and monitoring.
+ *
+ */
+#ifndef __CVMX_HELPER_ILK_H__
+#define __CVMX_HELPER_ILK_H__
+
+extern int __cvmx_helper_ilk_enumerate(int interface);
+
+/**
+ * Probe a ILK interface and determine the number of ports
+ * connected to it. The ILK interface should still be down after
+ * this call.
+ *
+ * @interface: Interface to probe
+ *
+ * Returns Number of ports on the interface. Zero to disable.
+ */
+extern int __cvmx_helper_ilk_probe(int interface);
+
+/**
+ * Bringup and enable a ILK interface. After this call packet
+ * I/O should be fully functional. This is called with IPD
+ * enabled but PKO disabled.
+ *
+ * @interface: Interface to bring up
+ *
+ * Returns Zero on success, negative on failure
+ */
+extern int __cvmx_helper_ilk_enable(int interface);
+
+/**
+ * Return the link state of an IPD/PKO port as returned by ILK link status.
+ *
+ * @ipd_port: IPD/PKO port to query
+ *
+ * Returns Link state
+ */
+extern cvmx_helper_link_info_t __cvmx_helper_ilk_link_get(int ipd_port);
+
+/**
+ * Configure an IPD/PKO port for the specified link state. This
+ * function does not influence auto negotiation at the PHY level.
+ * The passed link state must always match the link state returned
+ * by cvmx_helper_link_get(). It is normally best to use
+ * cvmx_helper_link_autoconf() instead.
+ *
+ * @ipd_port:  IPD/PKO port to configure
+ * @link_info: The new link state
+ *
+ * Returns Zero on success, negative on failure
+ */
+extern int __cvmx_helper_ilk_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
+
+extern void __cvmx_helper_ilk_show_stats(void);
+#endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-jtag.h b/arch/mips/include/asm/octeon/cvmx-helper-jtag.h
index 29f016d..cb8a0ad 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-jtag.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-jtag.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,7 +22,7 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /**
@@ -35,9 +35,58 @@
 #ifndef __CVMX_HELPER_JTAG_H__
 #define __CVMX_HELPER_JTAG_H__
 
+/**
+ * Initialize the internal QLM JTAG logic to allow programming
+ * of the JTAG chain by the cvmx_helper_qlm_jtag_*() functions.
+ * These functions should only be used at the direction of Cavium
+ * Networks. Programming incorrect values into the JTAG chain
+ * can cause chip damage.
+ */
 extern void cvmx_helper_qlm_jtag_init(void);
+
+/**
+ * Write up to 32bits into the QLM jtag chain. Bits are shifted
+ * into the MSB and out the LSB, so you should shift in the low
+ * order bits followed by the high order bits. The JTAG chain for
+ * CN52XX and CN56XX is 4 * 268 bits long, or 1072. The JTAG chain
+ * for CN63XX is 4 * 300 bits long, or 1200.
+ *
+ * @qlm:    QLM to shift value into
+ * @bits:   Number of bits to shift in (1-32).
+ * @data:   Data to shift in. Bit 0 enters the chain first, followed by
+ *               bit 1, etc.
+ *
+ * Returns The low order bits of the JTAG chain that shifted out of the
+ *         circle.
+ */
 extern uint32_t cvmx_helper_qlm_jtag_shift(int qlm, int bits, uint32_t data);
+
+/**
+ * Shift long sequences of zeros into the QLM JTAG chain. It is
+ * common to need to shift more than 32 bits of zeros into the
+ * chain. This function is a convience wrapper around
+ * cvmx_helper_qlm_jtag_shift() to shift more than 32 bits of
+ * zeros at a time.
+ *
+ * @qlm:    QLM to shift zeros into
+ * @bits:
+ */
 extern void cvmx_helper_qlm_jtag_shift_zeros(int qlm, int bits);
+
+/**
+ * Program the QLM JTAG chain into all lanes of the QLM. You must
+ * have already shifted in the proper number of bits into the
+ * JTAG chain. Updating invalid values can possibly cause chip damage.
+ *
+ * @qlm:    QLM to program
+ */
 extern void cvmx_helper_qlm_jtag_update(int qlm);
 
+/**
+ * Load the QLM JTAG chain with data from all lanes of the QLM.
+ *
+ * @qlm:    QLM to program
+ */
+extern void cvmx_helper_qlm_jtag_capture(int qlm);
+
 #endif /* __CVMX_HELPER_JTAG_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-loop.h b/arch/mips/include/asm/octeon/cvmx-helper-loop.h
index 077f0e9..7cbe4f6 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-loop.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-loop.h
@@ -1,19 +1,20 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as published by
- * the Free Software Foundation.
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
  *
- * This file is distributed in the hope that it will be useful,
- * but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT.
- * See the GNU General Public License for more details.
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this file; if not, write to the Free Software
@@ -21,15 +22,12 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- * @file
- *
+/*
  * Functions for LOOP initialization, configuration,
  * and monitoring.
- *
  */
 #ifndef __CVMX_HELPER_LOOP_H__
 #define __CVMX_HELPER_LOOP_H__
@@ -44,7 +42,7 @@
  * Returns Number of ports on the interface. Zero to disable.
  */
 extern int __cvmx_helper_loop_probe(int interface);
-static inline int __cvmx_helper_loop_enumerate(int interface) {return 4; }
+extern int __cvmx_helper_loop_enumerate(int interface);
 
 /**
  * Bringup and enable a LOOP interface. After this call packet
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-npi.h b/arch/mips/include/asm/octeon/cvmx-helper-npi.h
index 8df4c7f..46ee19b 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-npi.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-npi.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,15 +22,12 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- * @file
- *
+/*
  * Functions for NPI initialization, configuration,
  * and monitoring.
- *
  */
 #ifndef __CVMX_HELPER_NPI_H__
 #define __CVMX_HELPER_NPI_H__
@@ -45,7 +42,10 @@
  * Returns Number of ports on the interface. Zero to disable.
  */
 extern int __cvmx_helper_npi_probe(int interface);
-#define __cvmx_helper_npi_enumerate __cvmx_helper_npi_probe
+static inline int __cvmx_helper_npi_enumerate(int interface)
+{
+	return __cvmx_helper_npi_probe(interface);
+}
 
 /**
  * Bringup and enable a NPI interface. After this call packet
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-rgmii.h b/arch/mips/include/asm/octeon/cvmx-helper-rgmii.h
index 78295ba..e3ca44d 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-rgmii.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-rgmii.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,15 +22,12 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- * @file
- *
+/*
  * Functions for RGMII/GMII/MII initialization, configuration,
  * and monitoring.
- *
  */
 #ifndef __CVMX_HELPER_RGMII_H__
 #define __CVMX_HELPER_RGMII_H__
@@ -43,7 +40,10 @@
  * Returns Number of RGMII/GMII/MII ports (0-4).
  */
 extern int __cvmx_helper_rgmii_probe(int interface);
-#define __cvmx_helper_rgmii_enumerate __cvmx_helper_rgmii_probe
+static inline int __cvmx_helper_rgmii_enumerate(int interface)
+{
+	return __cvmx_helper_rgmii_probe(interface);
+}
 
 /**
  * Put an RGMII interface in loopback mode. Internal packets sent
@@ -88,8 +88,7 @@ extern cvmx_helper_link_info_t __cvmx_helper_rgmii_link_get(int ipd_port);
  *
  * Returns Zero on success, negative on failure
  */
-extern int __cvmx_helper_rgmii_link_set(int ipd_port,
-					cvmx_helper_link_info_t link_info);
+extern int __cvmx_helper_rgmii_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
 
 /**
  * Configure a port for internal and/or external loopback. Internal loopback
@@ -104,8 +103,6 @@ extern int __cvmx_helper_rgmii_link_set(int ipd_port,
  *
  * Returns Zero on success, negative on failure.
  */
-extern int __cvmx_helper_rgmii_configure_loopback(int ipd_port,
-						  int enable_internal,
-						  int enable_external);
+extern int __cvmx_helper_rgmii_configure_loopback(int ipd_port, int enable_internal, int enable_external);
 
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-sgmii.h b/arch/mips/include/asm/octeon/cvmx-helper-sgmii.h
index 9a9b6c1..8065a55 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-sgmii.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-sgmii.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,15 +22,12 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- * @file
- *
+/*
  * Functions for SGMII initialization, configuration,
  * and monitoring.
- *
  */
 #ifndef __CVMX_HELPER_SGMII_H__
 #define __CVMX_HELPER_SGMII_H__
@@ -82,8 +79,7 @@ extern cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port);
  *
  * Returns Zero on success, negative on failure
  */
-extern int __cvmx_helper_sgmii_link_set(int ipd_port,
-					cvmx_helper_link_info_t link_info);
+extern int __cvmx_helper_sgmii_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
 
 /**
  * Configure a port for internal and/or external loopback. Internal loopback
@@ -98,8 +94,6 @@ extern int __cvmx_helper_sgmii_link_set(int ipd_port,
  *
  * Returns Zero on success, negative on failure.
  */
-extern int __cvmx_helper_sgmii_configure_loopback(int ipd_port,
-						  int enable_internal,
-						  int enable_external);
+extern int __cvmx_helper_sgmii_configure_loopback(int ipd_port, int enable_internal, int enable_external);
 
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-spi.h b/arch/mips/include/asm/octeon/cvmx-helper-spi.h
index 9f1c6b9..787d1ee 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-spi.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-spi.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,7 +22,7 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
@@ -79,7 +79,6 @@ extern cvmx_helper_link_info_t __cvmx_helper_spi_link_get(int ipd_port);
  *
  * Returns Zero on success, negative on failure
  */
-extern int __cvmx_helper_spi_link_set(int ipd_port,
-				      cvmx_helper_link_info_t link_info);
+extern int __cvmx_helper_spi_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
 
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-srio.h b/arch/mips/include/asm/octeon/cvmx-helper-srio.h
new file mode 100644
index 0000000..07e76f5
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-helper-srio.h
@@ -0,0 +1,84 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Functions for SRIO initialization, configuration,
+ * and monitoring.
+ */
+#ifndef __CVMX_HELPER_SRIO_H__
+#define __CVMX_HELPER_SRIO_H__
+
+/**
+ * Probe a SRIO interface and determine the number of ports
+ * connected to it. The SRIO interface should still be down after
+ * this call.
+ *
+ * @interface: Interface to probe
+ *
+ * Returns Number of ports on the interface. Zero to disable.
+ */
+extern int __cvmx_helper_srio_probe(int interface);
+static inline int __cvmx_helper_srio_enumerate(int interface)
+{
+	return __cvmx_helper_srio_probe(interface);
+}
+
+/**
+ * Bringup and enable a SRIO interface. After this call packet
+ * I/O should be fully functional. This is called with IPD
+ * enabled but PKO disabled.
+ *
+ * @interface: Interface to bring up
+ *
+ * Returns Zero on success, negative on failure
+ */
+extern int __cvmx_helper_srio_enable(int interface);
+
+/**
+ * Return the link state of an IPD/PKO port as returned by SRIO link status.
+ *
+ * @ipd_port: IPD/PKO port to query
+ *
+ * Returns Link state
+ */
+extern cvmx_helper_link_info_t __cvmx_helper_srio_link_get(int ipd_port);
+
+/**
+ * Configure an IPD/PKO port for the specified link state. This
+ * function does not influence auto negotiation at the PHY level.
+ * The passed link state must always match the link state returned
+ * by cvmx_helper_link_get(). It is normally best to use
+ * cvmx_helper_link_autoconf() instead.
+ *
+ * @ipd_port:  IPD/PKO port to configure
+ * @link_info: The new link state
+ *
+ * Returns Zero on success, negative on failure
+ */
+extern int __cvmx_helper_srio_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
+
+#endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index 6a6e52f..a2ff151 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2012 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,18 +22,26 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * Small helper utilities.
- *
  */
 
 #ifndef __CVMX_HELPER_UTIL_H__
 #define __CVMX_HELPER_UTIL_H__
 
+#include "octeon.h"
+#include "cvmx-mio-defs.h"
+
+#define CVMX_INVALID_PKND	((int8_t) -1)
+#define CVMX_INVALID_BPID	((int8_t) -1)
+#define CVMX_MAX_PKND		((int8_t) 64)
+#define CVMX_MAX_BPID		((int8_t) 64)
+
+#define CVMX_HELPER_MAX_IFACE		9
+
 /**
  * Convert a interface mode into a human readable string
  *
@@ -41,8 +49,7 @@
  *
  * Returns String
  */
-extern const char
-    *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t mode);
+extern const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t mode);
 
 /**
  * Debug routine to dump the packet structure to the console
@@ -64,8 +71,7 @@ extern int cvmx_helper_dump_packet(cvmx_wqe_t *work);
  *               than this many free packet buffers in FPA 0.
  * Returns Zero on success. Negative on failure
  */
-extern int cvmx_helper_setup_red_queue(int queue, int pass_thresh,
-				       int drop_thresh);
+extern int cvmx_helper_setup_red_queue(int queue, int pass_thresh, int drop_thresh);
 
 /**
  * Setup Random Early Drop to automatically begin dropping packets.
@@ -101,17 +107,82 @@ extern const char *cvmx_helper_get_version(void);
 extern int __cvmx_helper_setup_gmx(int interface, int num_ports);
 
 /**
- * Returns the IPD/PKO port number for a port on the given
+ * Get the number of ipd_ports on an interface.
+ *
+ * @interface:
+ *
+ * Returns the number of ipd_ports on the interface and -1 for error.
+ */
+extern int __cvmx_helper_get_num_ipd_ports(int interface);
+
+/**
+ * Get the number of pko_ports on an interface.
+ *
+ * @interface:
+ *
+ * Returns the number of pko_ports on the interface.
+ */
+extern int __cvmx_helper_get_num_pko_ports(int interface);
+
+extern int __cvmx_helper_set_link_info(int interface, int port, cvmx_helper_link_info_t link_info);
+
+extern cvmx_helper_link_info_t __cvmx_helper_get_link_info(int interface, int port);
+
+enum cvmx_pko_padding {
+	CVMX_PKO_PADDING_NONE = 0,
+	CVMX_PKO_PADDING_60 = 1,
+};
+
+/**
+ * @interface:
+ * @num_ipd_ports: is the number of ipd_ports on the interface
+ * @has_fcs: indicates if PKO does FCS for the ports on this
+ * @pad: The padding that PKO should apply.
+ * interface.
+ *
+ * Returns 0 for success and -1 for failure
+ */
+extern int __cvmx_helper_init_interface(int interface, int num_ipd_ports,
+					int has_fcs, enum cvmx_pko_padding pad);
+
+extern int __cvmx_helper_get_has_fcs(int interface);
+
+extern enum cvmx_pko_padding __cvmx_helper_get_pko_padding(int interface);
+
+/**
+ * Returns the IPD port number for a port on the given
  * interface.
  *
  * @interface: Interface to use
  * @port:      Port on the interface
  *
- * Returns IPD/PKO port number
+ * Returns IPD port number
  */
 extern int cvmx_helper_get_ipd_port(int interface, int port);
 
 /**
+ * Outputs the port and interface given an IPD port number.
+ *
+ * @param[in]  ipd_port  IPD port number to convert
+ * @param[out] interface Interface IPD port belongs to
+ * @param[out] port      Port number IPD port belongs to
+ *
+ * Returns 0 if IPD port was translated, -1 if invalid port number
+ */
+extern int cvmx_helper_get_interface_and_port_from_ipd_port(int ipd_port, int *interface, int *port);
+
+/**
+ * Returns the PKO port number for a port on the given interface,
+ * This is the base pko_port for o68 and ipd_port for older models.
+ *
+ * @interface: Interface to use
+ * @port:      Port on the interface
+ *
+ * Returns PKO port number and -1 on error.
+ */
+extern int cvmx_helper_get_pko_port(int interface, int port);
+
+/**
  * Returns the IPD/PKO port number for the first port on the given
  * interface.
  *
@@ -136,8 +207,7 @@ static inline int cvmx_helper_get_last_ipd_port(int interface)
 {
 	extern int cvmx_helper_ports_on_interface(int interface);
 
-	return cvmx_helper_get_first_ipd_port(interface) +
-	       cvmx_helper_ports_on_interface(interface) - 1;
+	return cvmx_helper_get_first_ipd_port(interface) + cvmx_helper_ports_on_interface(interface) - 1;
 }
 
 /**
@@ -158,41 +228,29 @@ static inline void cvmx_helper_free_packet_data(cvmx_wqe_t *work)
 		return;
 	buffer_ptr = work->packet_ptr;
 
-	/*
-	 * Since the number of buffers is not zero, we know this is
-	 * not a dynamic short packet. We need to check if it is a
-	 * packet received with IPD_CTL_STATUS[NO_WPTR]. If this is
-	 * true, we need to free all buffers except for the first
-	 * one. The caller doesn't expect their WQE pointer to be
-	 * freed
-	 */
+	/* Since the number of buffers is not zero, we know this is not a dynamic
+	   short packet. We need to check if it is a packet received with
+	   IPD_CTL_STATUS[NO_WPTR]. If this is true, we need to free all buffers
+	   except for the first one. The caller doesn't expect their WQE pointer
+	   to be freed */
 	start_of_buffer = ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
 	if (cvmx_ptr_to_phys(work) == start_of_buffer) {
-		next_buffer_ptr =
-		    *(union cvmx_buf_ptr *) cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
+		next_buffer_ptr = *(union cvmx_buf_ptr *) cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
 		buffer_ptr = next_buffer_ptr;
 		number_buffers--;
 	}
 
 	while (number_buffers--) {
-		/*
-		 * Remember the back pointer is in cache lines, not
-		 * 64bit words
-		 */
-		start_of_buffer =
-		    ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
-		/*
-		 * Read pointer to next buffer before we free the
-		 * current buffer.
-		 */
-		next_buffer_ptr =
-		    *(union cvmx_buf_ptr *) cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
-		cvmx_fpa_free(cvmx_phys_to_ptr(start_of_buffer),
-			      buffer_ptr.s.pool, 0);
+		/* Remember the back pointer is in cache lines, not 64bit words */
+		start_of_buffer = ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
+		/* Read pointer to next buffer before we free the current buffer. */
+		next_buffer_ptr = *(union cvmx_buf_ptr *) cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
+		cvmx_fpa_free(cvmx_phys_to_ptr(start_of_buffer), buffer_ptr.s.pool, 0);
 		buffer_ptr = next_buffer_ptr;
 	}
 }
 
+
 /**
  * Returns the interface number for an IPD/PKO port number.
  *
@@ -212,4 +270,32 @@ extern int cvmx_helper_get_interface_num(int ipd_port);
  */
 extern int cvmx_helper_get_interface_index_num(int ipd_port);
 
+/**
+ * Get port kind for a given port in an interface.
+ *
+ * @interface:  Interface
+ * @port:       index of the port in the interface
+ *
+ * Returns port kind on sucicess  and -1 on failure
+ */
+extern int cvmx_helper_get_pknd(int interface, int port);
+
+/**
+ * Get bpid for a given port in an interface.
+ *
+ * @interface:  Interface
+ * @port:       index of the port in the interface
+ *
+ * Returns port kind on sucicess  and -1 on failure
+ */
+extern int cvmx_helper_get_bpid(int interface, int port);
+
+/**
+ * Internal functions.
+ */
+extern int __cvmx_helper_post_init_interfaces(void);
+extern void __cvmx_helper_shutdown_interfaces(void);
+
+extern void cvmx_helper_show_stats(int port);
+
 #endif /* __CVMX_HELPER_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-xaui.h b/arch/mips/include/asm/octeon/cvmx-helper-xaui.h
index f6fbc4f..7265791 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-xaui.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-xaui.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,15 +22,12 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- * @file
- *
+/*
  * Functions for XAUI initialization, configuration,
  * and monitoring.
- *
  */
 #ifndef __CVMX_HELPER_XAUI_H__
 #define __CVMX_HELPER_XAUI_H__
@@ -82,8 +79,7 @@ extern cvmx_helper_link_info_t __cvmx_helper_xaui_link_get(int ipd_port);
  *
  * Returns Zero on success, negative on failure
  */
-extern int __cvmx_helper_xaui_link_set(int ipd_port,
-				       cvmx_helper_link_info_t link_info);
+extern int __cvmx_helper_xaui_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
 
 /**
  * Configure a port for internal and/or external loopback. Internal loopback
@@ -98,7 +94,6 @@ extern int __cvmx_helper_xaui_link_set(int ipd_port,
  *
  * Returns Zero on success, negative on failure.
  */
-extern int __cvmx_helper_xaui_configure_loopback(int ipd_port,
-						 int enable_internal,
-						 int enable_external);
+extern int __cvmx_helper_xaui_configure_loopback(int ipd_port, int enable_internal, int enable_external);
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper.h b/arch/mips/include/asm/octeon/cvmx-helper.h
index 0ac6b9f..e1478b9 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,22 +22,71 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * Helper functions for common, but complicated tasks.
- *
  */
 
 #ifndef __CVMX_HELPER_H__
 #define __CVMX_HELPER_H__
 
-#include "cvmx-config.h"
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-config.h>
+
 #include "cvmx-fpa.h"
 #include "cvmx-wqe.h"
 
+
+/* Max number of GMXX */
+#define CVMX_HELPER_MAX_GMX             (OCTEON_IS_MODEL(OCTEON_CN68XX) ? 5 : 2)
+
+/* Do not change as CVMX_HELPER_WRITE_CSR() assumes it */
+#define CVMX_HELPER_CSR_INIT0           0
+#define CVMX_HELPER_CSR_INIT_READ       -1
+
+/*
+ * CVMX_HELPER_WRITE_CSR--set a field in a CSR with a value.
+ *
+ * @chcsr_init:    intial value of the csr (CVMX_HELPER_CSR_INIT_READ
+ *                      means to use the existing csr value as the
+ *                      initial value.)
+ * @chcsr_csr:     the name of the csr
+ * @chcsr_type:    the type of the csr (see the -defs.h)
+ * @chcsr_chip:    the chip for the csr/field
+ * @chcsr_fld:     the field in the csr
+ * @chcsr_val:     the value for field
+ */
+#define CVMX_HELPER_WRITE_CSR(chcsr_init, chcsr_csr, chcsr_type,        \
+			      chcsr_chip, chcsr_fld, chcsr_val)		\
+	do {                                                            \
+		chcsr_type csr;                                         \
+		if ((chcsr_init) == CVMX_HELPER_CSR_INIT_READ)          \
+			csr.u64 = cvmx_read_csr(chcsr_csr);             \
+		else                                                    \
+			csr.u64 = (chcsr_init);                         \
+		csr.chcsr_chip.chcsr_fld = (chcsr_val);                 \
+		cvmx_write_csr((chcsr_csr), csr.u64);                   \
+	} while (0)
+
+/*
+ * CVMX_HELPER_WRITE_CSR0--set a field in a CSR with the initial value of 0
+ */
+#define CVMX_HELPER_WRITE_CSR0(chcsr_csr, chcsr_type, chcsr_chip,       \
+			       chcsr_fld, chcsr_val)			\
+	CVMX_HELPER_WRITE_CSR(CVMX_HELPER_CSR_INIT0, chcsr_csr,         \
+			      chcsr_type, chcsr_chip, chcsr_fld, chcsr_val)
+
+/*
+ * CVMX_HELPER_WRITE_CSR1--set a field in a CSR with the initial value of
+ *                      the CSR's current value.
+ */
+#define CVMX_HELPER_WRITE_CSR1(chcsr_csr, chcsr_type, chcsr_chip,       \
+			       chcsr_fld, chcsr_val)			\
+	CVMX_HELPER_WRITE_CSR(CVMX_HELPER_CSR_INIT_READ, chcsr_csr,     \
+			      chcsr_type, chcsr_chip, chcsr_fld, chcsr_val)
+
 typedef enum {
 	CVMX_HELPER_INTERFACE_MODE_DISABLED,
 	CVMX_HELPER_INTERFACE_MODE_RGMII,
@@ -49,24 +98,30 @@ typedef enum {
 	CVMX_HELPER_INTERFACE_MODE_PICMG,
 	CVMX_HELPER_INTERFACE_MODE_NPI,
 	CVMX_HELPER_INTERFACE_MODE_LOOP,
+	CVMX_HELPER_INTERFACE_MODE_SRIO,
+	CVMX_HELPER_INTERFACE_MODE_ILK,
+	CVMX_HELPER_INTERFACE_MODE_RXAUI,
 } cvmx_helper_interface_mode_t;
 
 typedef union {
 	uint64_t u64;
 	struct {
 		uint64_t reserved_20_63:44;
-		uint64_t link_up:1;	    /**< Is the physical link up? */
-		uint64_t full_duplex:1;	    /**< 1 if the link is full duplex */
-		uint64_t speed:18;	    /**< Speed of the link in Mbps */
+		uint64_t link_up:1;	    /* Is the physical link up? */
+		uint64_t full_duplex:1;
+					    /* 1 if the link is full duplex */
+		uint64_t speed:18;	    /* Speed of the link in Mbps */
 	} s;
 } cvmx_helper_link_info_t;
 
-#include <asm/octeon/cvmx-helper-errata.h>
+#include "cvmx-helper-errata.h"
+#include "cvmx-helper-ilk.h"
 #include "cvmx-helper-loop.h"
 #include "cvmx-helper-npi.h"
 #include "cvmx-helper-rgmii.h"
 #include "cvmx-helper-sgmii.h"
 #include "cvmx-helper-spi.h"
+#include "cvmx-helper-srio.h"
 #include "cvmx-helper-util.h"
 #include "cvmx-helper-xaui.h"
 
@@ -77,12 +132,11 @@ typedef union {
  * number. Users should set this pointer to a function before
  * calling any cvmx-helper operations.
  */
-extern void (*cvmx_override_pko_queue_priority) (int pko_port,
-						 uint64_t priorities[16]);
+extern void (*cvmx_override_pko_queue_priority) (int ipd_port, uint64_t *priorities);
 
 /**
  * cvmx_override_ipd_port_setup(int ipd_port) is a function
- * pointer. It is meant to allow customization of the IPD port
+ * pointer. It is meant to allow customization of the IPD port/port kind
  * setup before packet input/output comes online. It is called
  * after cvmx-helper does the default IPD configuration, but
  * before IPD is enabled. Users should set this pointer to a
@@ -103,6 +157,26 @@ extern void (*cvmx_override_ipd_port_setup) (int ipd_port);
 extern int cvmx_helper_ipd_and_packet_input_enable(void);
 
 /**
+ * Initialize and allocate memory for the SSO.
+ *
+ * @wqe_entries: The maximum number of work queue entries to be
+ * supported.
+ *
+ * Returns Zero on success, non-zero on failure.
+ */
+extern int cvmx_helper_initialize_sso(int wqe_entries);
+
+/**
+ * Undo the effect of cvmx_helper_initialize_sso().
+ *
+ * Warning: since cvmx_bootmem_alloc() memory cannot be freed, the
+ * memory allocated by cvmx_helper_initialize_sso() will be leaked.
+ *
+ * Returns Zero on success, non-zero on failure.
+ */
+extern int cvmx_helper_uninitialize_sso(void);
+
+/**
  * Initialize the PIP, IPD, and PKO hardware to support
  * simple priority based queues for the ethernet ports. Each
  * port is configured with a number of priority queues based
@@ -121,6 +195,26 @@ extern int cvmx_helper_initialize_packet_io_global(void);
 extern int cvmx_helper_initialize_packet_io_local(void);
 
 /**
+ * Undo the initialization performed in
+ * cvmx_helper_initialize_packet_io_global(). After calling this routine and the
+ * local version on each core, packet IO for Octeon will be disabled and placed
+ * in the initial reset state. It will then be safe to call the initialize
+ * later on. Note that this routine does not empty the FPA pools. It frees all
+ * buffers used by the packet IO hardware to the FPA so a function emptying the
+ * FPA after shutdown should find all packet buffers in the FPA.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+extern int cvmx_helper_shutdown_packet_io_global(void);
+
+/**
+ * Does core local shutdown of packet io
+ *
+ * Returns Zero on success, non-zero on failure
+ */
+extern int cvmx_helper_shutdown_packet_io_local(void);
+
+/**
  * Returns the number of ports on the given interface.
  * The interface must be initialized before the port count
  * can be returned.
@@ -152,8 +246,7 @@ extern int cvmx_helper_get_number_of_interfaces(void);
  * Returns Mode of the interface. Unknown or unsupported interfaces return
  *         DISABLED.
  */
-extern cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int
-								   interface);
+extern cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface);
 
 /**
  * Auto configure an IPD/PKO port link state and speed. This
@@ -190,21 +283,29 @@ extern cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port);
  *
  * Returns Zero on success, negative on failure
  */
-extern int cvmx_helper_link_set(int ipd_port,
-				cvmx_helper_link_info_t link_info);
+extern int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info);
 
 /**
- * This function probes an interface to determine the actual
- * number of hardware ports connected to it. It doesn't setup the
- * ports or enable them. The main goal here is to set the global
- * interface_port_count[interface] correctly. Hardware setup of the
- * ports will be performed later.
+ * This function probes an interface to determine the actual number of
+ * hardware ports connected to it. It does some setup the ports but
+ * doesn't enable them. The main goal here is to set the global
+ * interface_port_count[interface] correctly. Final hardware setup of
+ * the ports will be performed later.
  *
  * @interface: Interface to probe
  *
  * Returns Zero on success, negative on failure
  */
 extern int cvmx_helper_interface_probe(int interface);
+
+/**
+ * Determine the actual number of hardware ports connected to an
+ * interface. It doesn't setup the ports or enable them.
+ *
+ * @interface: Interface to enumerate
+ *
+ * Returns Zero on success, negative on failure
+ */
 extern int cvmx_helper_interface_enumerate(int interface);
 
 /**
@@ -220,7 +321,7 @@ extern int cvmx_helper_interface_enumerate(int interface);
  *
  * Returns Zero on success, negative on failure.
  */
-extern int cvmx_helper_configure_loopback(int ipd_port, int enable_internal,
-					  int enable_external);
+extern int cvmx_helper_configure_loopback(int ipd_port, int enable_internal, int enable_external);
+
 
 #endif /* __CVMX_HELPER_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk.h b/arch/mips/include/asm/octeon/cvmx-ilk.h
new file mode 100644
index 0000000..1031348
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-ilk.h
@@ -0,0 +1,198 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+#ifndef __CVMX_ILK_H__
+#define __CVMX_ILK_H__
+
+
+/* CSR typedefs have been moved to cvmx-ilk-defs.h */
+
+#define CVMX_ILK_GBL_BASE  5
+#define CVMX_ILK_QLM_BASE  1
+
+struct cvmx_ilk_intf {
+	int intf_en:1;
+	int la_mode:1;
+	int reserved:6;		/* unused */
+	int lane_en_mask:8;
+	int lane_speed:16;
+	/* add more here */
+};
+
+#define CVMX_NUM_ILK_INTF  2
+#define CVMX_MAX_ILK_LANES 8
+extern unsigned char cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF];
+
+struct cvmx_ilk_pipe_chan {
+	unsigned int pipe;
+	unsigned int chan;
+};
+
+#define CVMX_ILK_PIPE_BASE 72
+#define CVMX_MAX_ILK_PIPES 45
+/* Max number of channels allowed */
+#define CVMX_MAX_ILK_CHANS 8
+
+/* Max number of channels configured for ILK0 */
+#define CVMX_MAX_ILK_CHANS0 8
+
+/* Max number of channels configured for ILK1 */
+#define CVMX_MAX_ILK_CHANS1 8
+
+extern unsigned char cvmx_ilk_chans[CVMX_NUM_ILK_INTF];
+extern unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_MAX_ILK_CHANS];
+
+struct cvmx_ilk_chan_pknd {
+	unsigned int chan;
+	unsigned int pknd;
+};
+
+#define CVMX_ILK_PKND_BASE 20
+#define CVMX_MAX_ILK_PKNDS 8	/* must be <45 */
+
+struct cvmx_ilk_stats_ctrl {
+	unsigned int *chan_list;	/* for discrete channels. or, must be null */
+	unsigned int num_chans;
+
+	unsigned int chan_start;	/* for continuous channels */
+	unsigned int chan_end;
+	unsigned int chan_step;
+
+	unsigned int clr_on_rd;
+};
+
+#define CVMX_ILK_MAX_CAL      288
+#define CVMX_ILK_TX_MIN_CAL   1
+#define CVMX_ILK_RX_MIN_CAL   1
+#define CVMX_ILK_CAL_GRP_SZ   8
+#define CVMX_ILK_PIPE_BPID_SZ 7
+#define CVMX_ILK_ENT_CTRL_SZ  2
+#define CVMX_ILK_RX_FIFO_WM   0x200
+
+enum cvmx_ilk_cal_ent_ctrl {
+	PIPE_BPID = 0,
+	LINK,
+	XOFF,
+	XON
+};
+
+struct cvmx_ilk_cal_entry {
+	unsigned char pipe_bpid;
+	enum cvmx_ilk_cal_ent_ctrl ent_ctrl;
+};
+
+/* Callbacks structure to customize ILK initialization sequence */
+struct cvmx_ilk_callbacks {
+    /* Called to setup rx calendar */
+	int (*calendar_setup_rx) (int interface, int cal_depth,
+				  struct cvmx_ilk_cal_entry *pent,
+				  int hi_wm, unsigned char cal_ena);
+
+    /* add more here */
+};
+
+enum cvmx_ilk_lpbk_ena {
+	CVMX_ILK_LPBK_DISA = 0,
+	CVMX_ILK_LPBK_ENA
+};
+
+enum cvmx_ilk_lpbk_mode {
+	CVMX_ILK_LPBK_INT = 0,
+	CVMX_ILK_LPBK_EXT
+};
+
+/**
+ * This header is placed in front of all received ILK look-aside mode packets
+ */
+union cvmx_ilk_la_nsp_compact_hdr {
+	uint64_t u64;
+
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_63_57:7;	/* bits 63...57 */
+		uint32_t nsp_cmd:5;		/* bits 56...52 */
+		uint32_t nsp_flags:4;		/* bits 51...48 */
+		uint32_t nsp_grp_id_upper:6;	/* bits 47...42 */
+		uint32_t reserved_41_40:2;	/* bits 41...40 */
+		uint32_t la_mode:1;		/* bit  39     Protocol type, 1 for LA mode packet */
+		uint32_t nsp_grp_id_lower:2;	/* bits 38...37 */
+		uint32_t nsp_xid_upper:4;	/* bits 36...33 */
+		uint32_t ilk_channel:1;		/* bit  32     ILK channel number, 0 or 1 */
+		uint32_t nsp_xid_lower:8;	/* bits 31...24 */
+		uint32_t reserved_23_0:24;	/* bits 23...0  Unpredictable, may be any value */
+#else
+		uint32_t reserved_23_0:24;
+		uint32_t nsp_xid_lower:8;
+		uint32_t ilk_channel:1;
+		uint32_t nsp_xid_upper:4;
+		uint32_t nsp_grp_id_lower:2;
+		uint32_t la_mode:1;
+		uint32_t reserved_41_40:2;
+		uint32_t nsp_grp_id_upper:6;
+		uint32_t nsp_flags:4;
+		uint32_t nsp_cmd:5;
+		uint32_t reserved_63_57:7;
+#endif
+	} s;
+};
+
+extern void cvmx_ilk_get_callbacks(struct cvmx_ilk_callbacks *callbacks);
+extern void cvmx_ilk_set_callbacks(struct cvmx_ilk_callbacks *new_callbacks);
+extern int cvmx_ilk_use_la_mode(int interface, int channel);
+
+extern int cvmx_ilk_start_interface(int interface, unsigned char num_lanes);
+extern int cvmx_ilk_start_interface_la(int interface, unsigned char num_lanes);
+extern int cvmx_ilk_set_pipe(int interface, int pipe_base,
+			     unsigned int pipe_len);
+extern int cvmx_ilk_tx_set_channel(int interface,
+				   struct cvmx_ilk_pipe_chan *pch,
+				   unsigned int num_chs);
+extern int cvmx_ilk_rx_set_pknd(int interface,
+				struct cvmx_ilk_chan_pknd *chpknd,
+				unsigned int num_pknd);
+extern int cvmx_ilk_calendar_setup_cb(int interface, int num_ports);
+extern int cvmx_ilk_calendar_sync_cb(int interface, int timeout);
+extern int cvmx_ilk_enable(int interface);
+extern int cvmx_ilk_disable(int interface);
+extern int cvmx_ilk_get_intf_ena(int interface);
+extern unsigned char cvmx_ilk_bit_count(unsigned char uc);
+extern unsigned char cvmx_ilk_get_intf_ln_msk(int interface);
+extern int cvmx_ilk_get_chan_info(int interface, unsigned char **chans,
+				  unsigned char *num_chan);
+extern union cvmx_ilk_la_nsp_compact_hdr cvmx_ilk_enable_la_header(int port,
+								   int mode);
+extern void cvmx_ilk_show_stats(int interface,
+				struct cvmx_ilk_stats_ctrl *pstats);
+extern int cvmx_ilk_cal_setup_rx(int interface, int cal_depth,
+				 struct cvmx_ilk_cal_entry *pent, int hi_wm,
+				 unsigned char cal_ena);
+extern int cvmx_ilk_cal_setup_tx(int interface, int cal_depth,
+				 struct cvmx_ilk_cal_entry *pent,
+				 unsigned char cal_ena);
+extern int cvmx_ilk_lpbk(int interface, enum cvmx_ilk_lpbk_ena enable,
+			 enum cvmx_ilk_lpbk_mode mode);
+extern int cvmx_ilk_la_mode_enable_rx_calendar(int interface);
+#endif /* __CVMX_ILK_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd.h b/arch/mips/include/asm/octeon/cvmx-ipd.h
index 115a552..6cec642 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,38 +22,33 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- *
+/*
  * Interface to the hardware Input Packet Data unit.
  */
 
 #ifndef __CVMX_IPD_H__
 #define __CVMX_IPD_H__
 
-#include <asm/octeon/octeon-feature.h>
-
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-config.h>
 #include <asm/octeon/cvmx-ipd-defs.h>
 
-enum cvmx_ipd_mode {
-   CVMX_IPD_OPC_MODE_STT = 0LL,   /* All blocks DRAM, not cached in L2 */
-   CVMX_IPD_OPC_MODE_STF = 1LL,   /* All bloccks into  L2 */
-   CVMX_IPD_OPC_MODE_STF1_STT = 2LL,   /* 1st block L2, rest DRAM */
-   CVMX_IPD_OPC_MODE_STF2_STT = 3LL    /* 1st, 2nd blocks L2, rest DRAM */
-};
 
 #ifndef CVMX_ENABLE_LEN_M8_FIX
 #define CVMX_ENABLE_LEN_M8_FIX 0
 #endif
 
-/* CSR typedefs have been moved to cvmx-csr-*.h */
-typedef union cvmx_ipd_1st_mbuff_skip cvmx_ipd_mbuff_first_skip_t;
-typedef union cvmx_ipd_1st_next_ptr_back cvmx_ipd_first_next_ptr_back_t;
+/* CSR typedefs have been moved to cvmx-ipd-defs.h */
 
-typedef cvmx_ipd_mbuff_first_skip_t cvmx_ipd_mbuff_not_first_skip_t;
-typedef cvmx_ipd_first_next_ptr_back_t cvmx_ipd_second_next_ptr_back_t;
+enum {
+	CVMX_IPD_OPC_MODE_STT = 0LL,	/* All blocks DRAM, not cached in L2 */
+	CVMX_IPD_OPC_MODE_STF = 1LL,	/* All blocks into L2 */
+	CVMX_IPD_OPC_MODE_STF1_STT = 2LL, /* 1st block L2, rest DRAM */
+	CVMX_IPD_OPC_MODE_STF2_STT = 3LL  /* 1st, 2nd blocks L2, rest DRAM */
+};
 
 /**
  * Configure IPD
@@ -70,269 +65,28 @@ typedef cvmx_ipd_first_next_ptr_back_t cvmx_ipd_second_next_ptr_back_t;
  *                   FPA pool to get work entries from
  * @cache_mode:
  * @back_pres_enable_flag:
- *                   Enable or disable port back pressure
+ *                   Enable or disable port back pressure at a global level.
+ *                   This should always be 1 as more accurate control can be
+ *                   found in IPD_PORTX_BP_PAGE_CNT[BP_ENB].
  */
-static inline void cvmx_ipd_config(uint64_t mbuff_size,
-				   uint64_t first_mbuff_skip,
-				   uint64_t not_first_mbuff_skip,
-				   uint64_t first_back,
-				   uint64_t second_back,
-				   uint64_t wqe_fpa_pool,
-				   enum cvmx_ipd_mode cache_mode,
-				   uint64_t back_pres_enable_flag)
-{
-	cvmx_ipd_mbuff_first_skip_t first_skip;
-	cvmx_ipd_mbuff_not_first_skip_t not_first_skip;
-	union cvmx_ipd_packet_mbuff_size size;
-	cvmx_ipd_first_next_ptr_back_t first_back_struct;
-	cvmx_ipd_second_next_ptr_back_t second_back_struct;
-	union cvmx_ipd_wqe_fpa_queue wqe_pool;
-	union cvmx_ipd_ctl_status ipd_ctl_reg;
-
-	first_skip.u64 = 0;
-	first_skip.s.skip_sz = first_mbuff_skip;
-	cvmx_write_csr(CVMX_IPD_1ST_MBUFF_SKIP, first_skip.u64);
-
-	not_first_skip.u64 = 0;
-	not_first_skip.s.skip_sz = not_first_mbuff_skip;
-	cvmx_write_csr(CVMX_IPD_NOT_1ST_MBUFF_SKIP, not_first_skip.u64);
-
-	size.u64 = 0;
-	size.s.mb_size = mbuff_size;
-	cvmx_write_csr(CVMX_IPD_PACKET_MBUFF_SIZE, size.u64);
-
-	first_back_struct.u64 = 0;
-	first_back_struct.s.back = first_back;
-	cvmx_write_csr(CVMX_IPD_1st_NEXT_PTR_BACK, first_back_struct.u64);
-
-	second_back_struct.u64 = 0;
-	second_back_struct.s.back = second_back;
-	cvmx_write_csr(CVMX_IPD_2nd_NEXT_PTR_BACK, second_back_struct.u64);
-
-	wqe_pool.u64 = 0;
-	wqe_pool.s.wqe_pool = wqe_fpa_pool;
-	cvmx_write_csr(CVMX_IPD_WQE_FPA_QUEUE, wqe_pool.u64);
-
-	ipd_ctl_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
-	ipd_ctl_reg.s.opc_mode = cache_mode;
-	ipd_ctl_reg.s.pbp_en = back_pres_enable_flag;
-	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_reg.u64);
-
-	/* Note: the example RED code that used to be here has been moved to
-	   cvmx_helper_setup_red */
-}
+void cvmx_ipd_config(uint64_t mbuff_size,
+		     uint64_t first_mbuff_skip,
+		     uint64_t not_first_mbuff_skip,
+		     uint64_t first_back, uint64_t second_back,
+		     uint64_t wqe_fpa_pool,
+		     uint64_t cache_mode,
+		     uint64_t back_pres_enable_flag);
 
 /**
  * Enable IPD
  */
-static inline void cvmx_ipd_enable(void)
-{
-	union cvmx_ipd_ctl_status ipd_reg;
-	ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
-	if (ipd_reg.s.ipd_en) {
-		cvmx_dprintf
-		    ("Warning: Enabling IPD when IPD already enabled.\n");
-	}
-	ipd_reg.s.ipd_en = 1;
-#if  CVMX_ENABLE_LEN_M8_FIX
-	if (!OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2))
-		ipd_reg.s.len_m8 = TRUE;
-#endif
-	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_reg.u64);
-}
+void cvmx_ipd_enable(void);
 
 /**
  * Disable IPD
  */
-static inline void cvmx_ipd_disable(void)
-{
-	union cvmx_ipd_ctl_status ipd_reg;
-	ipd_reg.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
-	ipd_reg.s.ipd_en = 0;
-	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_reg.u64);
-}
-
-/**
- * Supportive function for cvmx_fpa_shutdown_pool.
- */
-static inline void cvmx_ipd_free_ptr(void)
-{
-	/* Only CN38XXp{1,2} cannot read pointer out of the IPD */
-	if (!OCTEON_IS_MODEL(OCTEON_CN38XX_PASS1)
-	    && !OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2)) {
-		int no_wptr = 0;
-		union cvmx_ipd_ptr_count ipd_ptr_count;
-		ipd_ptr_count.u64 = cvmx_read_csr(CVMX_IPD_PTR_COUNT);
-
-		/* Handle Work Queue Entry in cn56xx and cn52xx */
-		if (octeon_has_feature(OCTEON_FEATURE_NO_WPTR)) {
-			union cvmx_ipd_ctl_status ipd_ctl_status;
-			ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
-			if (ipd_ctl_status.s.no_wptr)
-				no_wptr = 1;
-		}
-
-		/* Free the prefetched WQE */
-		if (ipd_ptr_count.s.wqev_cnt) {
-			union cvmx_ipd_wqe_ptr_valid ipd_wqe_ptr_valid;
-			ipd_wqe_ptr_valid.u64 =
-			    cvmx_read_csr(CVMX_IPD_WQE_PTR_VALID);
-			if (no_wptr)
-				cvmx_fpa_free(cvmx_phys_to_ptr
-					      ((uint64_t) ipd_wqe_ptr_valid.s.
-					       ptr << 7), CVMX_FPA_PACKET_POOL,
-					      0);
-			else
-				cvmx_fpa_free(cvmx_phys_to_ptr
-					      ((uint64_t) ipd_wqe_ptr_valid.s.
-					       ptr << 7), CVMX_FPA_WQE_POOL, 0);
-		}
-
-		/* Free all WQE in the fifo */
-		if (ipd_ptr_count.s.wqe_pcnt) {
-			int i;
-			union cvmx_ipd_pwp_ptr_fifo_ctl ipd_pwp_ptr_fifo_ctl;
-			ipd_pwp_ptr_fifo_ctl.u64 =
-			    cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
-			for (i = 0; i < ipd_ptr_count.s.wqe_pcnt; i++) {
-				ipd_pwp_ptr_fifo_ctl.s.cena = 0;
-				ipd_pwp_ptr_fifo_ctl.s.raddr =
-				    ipd_pwp_ptr_fifo_ctl.s.max_cnts +
-				    (ipd_pwp_ptr_fifo_ctl.s.wraddr +
-				     i) % ipd_pwp_ptr_fifo_ctl.s.max_cnts;
-				cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL,
-					       ipd_pwp_ptr_fifo_ctl.u64);
-				ipd_pwp_ptr_fifo_ctl.u64 =
-				    cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
-				if (no_wptr)
-					cvmx_fpa_free(cvmx_phys_to_ptr
-						      ((uint64_t)
-						       ipd_pwp_ptr_fifo_ctl.s.
-						       ptr << 7),
-						      CVMX_FPA_PACKET_POOL, 0);
-				else
-					cvmx_fpa_free(cvmx_phys_to_ptr
-						      ((uint64_t)
-						       ipd_pwp_ptr_fifo_ctl.s.
-						       ptr << 7),
-						      CVMX_FPA_WQE_POOL, 0);
-			}
-			ipd_pwp_ptr_fifo_ctl.s.cena = 1;
-			cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL,
-				       ipd_pwp_ptr_fifo_ctl.u64);
-		}
-
-		/* Free the prefetched packet */
-		if (ipd_ptr_count.s.pktv_cnt) {
-			union cvmx_ipd_pkt_ptr_valid ipd_pkt_ptr_valid;
-			ipd_pkt_ptr_valid.u64 =
-			    cvmx_read_csr(CVMX_IPD_PKT_PTR_VALID);
-			cvmx_fpa_free(cvmx_phys_to_ptr
-				      (ipd_pkt_ptr_valid.s.ptr << 7),
-				      CVMX_FPA_PACKET_POOL, 0);
-		}
-
-		/* Free the per port prefetched packets */
-		if (1) {
-			int i;
-			union cvmx_ipd_prc_port_ptr_fifo_ctl
-			    ipd_prc_port_ptr_fifo_ctl;
-			ipd_prc_port_ptr_fifo_ctl.u64 =
-			    cvmx_read_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL);
-
-			for (i = 0; i < ipd_prc_port_ptr_fifo_ctl.s.max_pkt;
-			     i++) {
-				ipd_prc_port_ptr_fifo_ctl.s.cena = 0;
-				ipd_prc_port_ptr_fifo_ctl.s.raddr =
-				    i % ipd_prc_port_ptr_fifo_ctl.s.max_pkt;
-				cvmx_write_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL,
-					       ipd_prc_port_ptr_fifo_ctl.u64);
-				ipd_prc_port_ptr_fifo_ctl.u64 =
-				    cvmx_read_csr
-				    (CVMX_IPD_PRC_PORT_PTR_FIFO_CTL);
-				cvmx_fpa_free(cvmx_phys_to_ptr
-					      ((uint64_t)
-					       ipd_prc_port_ptr_fifo_ctl.s.
-					       ptr << 7), CVMX_FPA_PACKET_POOL,
-					      0);
-			}
-			ipd_prc_port_ptr_fifo_ctl.s.cena = 1;
-			cvmx_write_csr(CVMX_IPD_PRC_PORT_PTR_FIFO_CTL,
-				       ipd_prc_port_ptr_fifo_ctl.u64);
-		}
-
-		/* Free all packets in the holding fifo */
-		if (ipd_ptr_count.s.pfif_cnt) {
-			int i;
-			union cvmx_ipd_prc_hold_ptr_fifo_ctl
-			    ipd_prc_hold_ptr_fifo_ctl;
-
-			ipd_prc_hold_ptr_fifo_ctl.u64 =
-			    cvmx_read_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL);
-
-			for (i = 0; i < ipd_ptr_count.s.pfif_cnt; i++) {
-				ipd_prc_hold_ptr_fifo_ctl.s.cena = 0;
-				ipd_prc_hold_ptr_fifo_ctl.s.raddr =
-				    (ipd_prc_hold_ptr_fifo_ctl.s.praddr +
-				     i) % ipd_prc_hold_ptr_fifo_ctl.s.max_pkt;
-				cvmx_write_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL,
-					       ipd_prc_hold_ptr_fifo_ctl.u64);
-				ipd_prc_hold_ptr_fifo_ctl.u64 =
-				    cvmx_read_csr
-				    (CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL);
-				cvmx_fpa_free(cvmx_phys_to_ptr
-					      ((uint64_t)
-					       ipd_prc_hold_ptr_fifo_ctl.s.
-					       ptr << 7), CVMX_FPA_PACKET_POOL,
-					      0);
-			}
-			ipd_prc_hold_ptr_fifo_ctl.s.cena = 1;
-			cvmx_write_csr(CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL,
-				       ipd_prc_hold_ptr_fifo_ctl.u64);
-		}
-
-		/* Free all packets in the fifo */
-		if (ipd_ptr_count.s.pkt_pcnt) {
-			int i;
-			union cvmx_ipd_pwp_ptr_fifo_ctl ipd_pwp_ptr_fifo_ctl;
-			ipd_pwp_ptr_fifo_ctl.u64 =
-			    cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
-
-			for (i = 0; i < ipd_ptr_count.s.pkt_pcnt; i++) {
-				ipd_pwp_ptr_fifo_ctl.s.cena = 0;
-				ipd_pwp_ptr_fifo_ctl.s.raddr =
-				    (ipd_pwp_ptr_fifo_ctl.s.praddr +
-				     i) % ipd_pwp_ptr_fifo_ctl.s.max_cnts;
-				cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL,
-					       ipd_pwp_ptr_fifo_ctl.u64);
-				ipd_pwp_ptr_fifo_ctl.u64 =
-				    cvmx_read_csr(CVMX_IPD_PWP_PTR_FIFO_CTL);
-				cvmx_fpa_free(cvmx_phys_to_ptr
-					      ((uint64_t) ipd_pwp_ptr_fifo_ctl.
-					       s.ptr << 7),
-					      CVMX_FPA_PACKET_POOL, 0);
-			}
-			ipd_pwp_ptr_fifo_ctl.s.cena = 1;
-			cvmx_write_csr(CVMX_IPD_PWP_PTR_FIFO_CTL,
-				       ipd_pwp_ptr_fifo_ctl.u64);
-		}
-
-		/* Reset the IPD to get all buffers out of it */
-		{
-			union cvmx_ipd_ctl_status ipd_ctl_status;
-			ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
-			ipd_ctl_status.s.reset = 1;
-			cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
-		}
+void cvmx_ipd_disable(void);
+void __cvmx_ipd_free_ptr(void);
 
-		/* Reset the PIP */
-		{
-			union cvmx_pip_sft_rst pip_sft_rst;
-			pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
-			pip_sft_rst.s.rst = 1;
-			cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
-		}
-	}
-}
 
 #endif /*  __CVMX_IPD_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-pko.h b/arch/mips/include/asm/octeon/cvmx-pko.h
index de3412a..57095b0 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,11 +22,10 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/**
- *
+/*
  * Interface to the hardware Packet Output unit.
  *
  * Starting with SDK 1.7.0, the PKO output functions now support
@@ -58,30 +57,40 @@
 #ifndef __CVMX_PKO_H__
 #define __CVMX_PKO_H__
 
-#include "cvmx-fpa.h"
-#include "cvmx-pow.h"
-#include "cvmx-cmd-queue.h"
+#include "cvmx-config.h"
 #include "cvmx-pko-defs.h"
+#include <asm/octeon/cvmx-fau.h>
+#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-pow.h>
+#include <asm/octeon/cvmx-cmd-queue.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
 
 /* Adjust the command buffer size by 1 word so that in the case of using only
- * two word PKO commands no command words stradle buffers.  The useful values
- * for this are 0 and 1. */
+** two word PKO commands no command words stradle buffers.  The useful values
+** for this are 0 and 1. */
 #define CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST (1)
 
+
 #define CVMX_PKO_MAX_OUTPUT_QUEUES_STATIC 256
 #define CVMX_PKO_MAX_OUTPUT_QUEUES      ((OCTEON_IS_MODEL(OCTEON_CN31XX) || \
-	OCTEON_IS_MODEL(OCTEON_CN3010) || OCTEON_IS_MODEL(OCTEON_CN3005) || \
-	OCTEON_IS_MODEL(OCTEON_CN50XX)) ? 32 : \
-		(OCTEON_IS_MODEL(OCTEON_CN58XX) || \
-		OCTEON_IS_MODEL(OCTEON_CN56XX)) ? 256 : 128)
-#define CVMX_PKO_NUM_OUTPUT_PORTS       40
-/* use this for queues that are not used */
-#define CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID 63
+					  OCTEON_IS_MODEL(OCTEON_CN3010) || \
+					  OCTEON_IS_MODEL(OCTEON_CN3005) || \
+					  OCTEON_IS_MODEL(OCTEON_CN50XX)) ? \
+					  32 :				    \
+					 (OCTEON_IS_MODEL(OCTEON_CN58XX) || \
+					  OCTEON_IS_MODEL(OCTEON_CN56XX) || \
+					  OCTEON_IS_MODEL(OCTEON_CN52XX) || \
+					  OCTEON_IS_MODEL(OCTEON_CN6XXX) || \
+					  OCTEON_IS_MODEL(OCTEON_CNF7XXX)) ? \
+					  256 : 128)
+#define CVMX_PKO_NUM_OUTPUT_PORTS       ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 44 : (OCTEON_IS_MODEL(OCTEON_CN66XX) ? 48 : 40))
+#define CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID 63	/* use this for queues that are not used */
 #define CVMX_PKO_QUEUE_STATIC_PRIORITY  9
 #define CVMX_PKO_ILLEGAL_QUEUE  0xFFFF
 #define CVMX_PKO_MAX_QUEUE_DEPTH 0
 
-typedef enum {
+enum cvmx_pko_status {
 	CVMX_PKO_SUCCESS,
 	CVMX_PKO_INVALID_PORT,
 	CVMX_PKO_INVALID_QUEUE,
@@ -89,7 +98,7 @@ typedef enum {
 	CVMX_PKO_NO_MEMORY,
 	CVMX_PKO_PORT_ALREADY_SETUP,
 	CVMX_PKO_CMD_QUEUE_INIT_ERROR
-} cvmx_pko_status_t;
+};
 
 /**
  * This enumeration represents the differnet locking modes supported by PKO.
@@ -98,15 +107,17 @@ typedef enum {
 	/*
 	 * PKO doesn't do any locking. It is the responsibility of the
 	 * application to make sure that no other core is accessing
-	 * the same queue at the same time
+	 * the same queue at the same time.
 	 */
 	CVMX_PKO_LOCK_NONE = 0,
+
 	/*
 	 * PKO performs an atomic tagswitch to insure exclusive access
 	 * to the output queue. This will maintain packet ordering on
 	 * output.
 	 */
 	CVMX_PKO_LOCK_ATOMIC_TAG = 1,
+
 	/*
 	 * PKO uses the common command queue locks to insure exclusive
 	 * access to the output queue. This is a memory based
@@ -127,30 +138,27 @@ typedef struct {
 typedef union {
 	uint64_t u64;
 	struct {
-		/* Must CVMX_IO_SEG */
-		uint64_t mem_space:2;
-		/* Must be zero */
-		uint64_t reserved:13;
-		/* Must be one */
-		uint64_t is_io:1;
-		/* The ID of the device on the non-coherent bus */
-		uint64_t did:8;
-		/* Must be zero */
-		uint64_t reserved2:4;
-		/* Must be zero */
-		uint64_t reserved3:18;
-		/*
-		 * The hardware likes to have the output port in
-		 * addition to the output queue,
-		 */
-		uint64_t port:6;
-		/*
-		 * The output queue to send the packet to (0-127 are
-		 * legal)
-		 */
-		uint64_t queue:9;
-		/* Must be zero */
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t mem_space:2;	/* Must CVMX_IO_SEG */
+		uint64_t reserved:13;	/* Must be zero */
+		uint64_t is_io:1;	/* Must be one */
+		uint64_t did:8;		/* The ID of the device on the non-coherent bus */
+		uint64_t reserved2:4;	/* Must be zero */
+		uint64_t reserved3:15;	/* Must be zero */
+		uint64_t port:9;	/* The hardware must have the output port in addition to the output queue */
+		uint64_t queue:9;	/* The output queue to send the packet to (0-127 are legal) */
+		uint64_t reserved4:3;	/* Must be zero */
+#else
 		uint64_t reserved4:3;
+		uint64_t queue:9;
+		uint64_t port:9;
+		uint64_t reserved3:15;
+		uint64_t reserved2:4;
+		uint64_t did:8;
+		uint64_t is_io:1;
+		uint64_t reserved:13;
+		uint64_t mem_space:2;
+#endif
 	} s;
 } cvmx_pko_doorbell_address_t;
 
@@ -160,25 +168,16 @@ typedef union {
 typedef union {
 	uint64_t u64;
 	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
 		/*
-		 * The size of the reg1 operation - could be 8, 16,
-		 * 32, or 64 bits.
+		 * The sizes of the reg{0,1} operation - could be 8, 16,
+		 * 32, or 64 bits
 		 */
 		uint64_t size1:2;
-		/*
-		 * The size of the reg0 operation - could be 8, 16,
-		 * 32, or 64 bits.
-		 */
 		uint64_t size0:2;
-		/*
-		 * If set, subtract 1, if clear, subtract packet
-		 * size.
-		 */
+		/* If set, subtract 1, if clear, subtract packet size */
 		uint64_t subone1:1;
-		/*
-		 * The register, subtract will be done if reg1 is
-		 * non-zero.
-		 */
+		/* The register, subtract will be done if reg1 is non-zero */
 		uint64_t reg1:11;
 		/* If set, subtract 1, if clear, subtract packet size */
 		uint64_t subone0:1;
@@ -189,10 +188,7 @@ typedef union {
 		 * bytes in little endian order.
 		 */
 		uint64_t le:1;
-		/*
-		 * When set, packet data not allocated in L2 cache by
-		 * PKO.
-		 */
+		/* When set, packet data not allocated in L2 cache by PKO */
 		uint64_t n2:1;
 		/*
 		 * If set and rsp is set, word3 contains a pointer to
@@ -203,13 +199,13 @@ typedef union {
 		uint64_t rsp:1;
 		/*
 		 * If set, the supplied pkt_ptr is really a pointer to
-		 * a list of pkt_ptr's.
+		 * a list of pkt_ptrs.
 		 */
 		uint64_t gather:1;
 		/*
 		 * If ipoffp1 is non zero, (ipoffp1-1) is the number
 		 * of bytes to IP header, and the hardware will
-		 * calculate and insert the UDP/TCP checksum.
+		 * calculate and insert the UDP/TCP checksum
 		 */
 		uint64_t ipoffp1:7;
 		/*
@@ -229,11 +225,27 @@ typedef union {
 		uint64_t segs:6;
 		/* Including L2, but no trailing CRC */
 		uint64_t total_bytes:16;
+#else
+		uint64_t total_bytes:16;
+		uint64_t segs:6;
+		uint64_t dontfree:1;
+		uint64_t ignore_i:1;
+		uint64_t ipoffp1:7;
+		uint64_t gather:1;
+		uint64_t rsp:1;
+		uint64_t wqp:1;
+		uint64_t n2:1;
+		uint64_t le:1;
+		uint64_t reg0:11;
+		uint64_t subone0:1;
+		uint64_t reg1:11;
+		uint64_t subone1:1;
+		cvmx_fau_op_size_t size0:2;
+		cvmx_fau_op_size_t size1:2;
+#endif
 	} s;
 } cvmx_pko_command_word0_t;
 
-/* CSR typedefs have been moved to cvmx-csr-*.h */
-
 /**
  * Definition of internal state for Packet output processing
  */
@@ -277,10 +289,9 @@ extern void cvmx_pko_shutdown(void);
  *                   of a value of 1. There must be num_queues elements in the
  *                   array.
  */
-extern cvmx_pko_status_t cvmx_pko_config_port(uint64_t port,
-					      uint64_t base_queue,
-					      uint64_t num_queues,
-					      const uint64_t priority[]);
+enum cvmx_pko_status cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
+					  uint64_t num_queues,
+					  const uint64_t priority[]);
 
 /**
  * Ring the packet output doorbell. This tells the packet
@@ -288,26 +299,36 @@ extern cvmx_pko_status_t cvmx_pko_config_port(uint64_t port,
  * to its pending list.  This command includes the required
  * CVMX_SYNCWS before the doorbell ring.
  *
- * @port:   Port the packet is for
+ * WARNING: This function may have to look up the proper PKO port in
+ * the IPD port to PKO port map, and is thus slower than calling
+ * cvmx_pko_doorbell_pkoid() directly if the PKO port identifier is
+ * known.
+ *
+ * @ipd_port:   The IPD port corresponding the to pko port the packet is for
  * @queue:  Queue the packet is for
  * @len:    Length of the command in 64 bit words
  */
-static inline void cvmx_pko_doorbell(uint64_t port, uint64_t queue,
+static inline void cvmx_pko_doorbell(uint64_t ipd_port, uint64_t queue,
 				     uint64_t len)
 {
 	cvmx_pko_doorbell_address_t ptr;
+	uint64_t pko_port;
+
+	pko_port = ipd_port;
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		pko_port = cvmx_helper_cfg_ipd2pko_port_base(ipd_port);
 
 	ptr.u64 = 0;
 	ptr.s.mem_space = CVMX_IO_SEG;
 	ptr.s.did = CVMX_OCT_DID_PKT_SEND;
 	ptr.s.is_io = 1;
-	ptr.s.port = port;
+	ptr.s.port = pko_port;
 	ptr.s.queue = queue;
 	/*
 	 * Need to make sure output queue data is in DRAM before
 	 * doorbell write.
 	 */
-	CVMX_SYNCWS;
+	wmb();
 	cvmx_write_io(ptr.u64, len);
 }
 
@@ -338,12 +359,12 @@ static inline void cvmx_pko_doorbell(uint64_t port, uint64_t queue,
  * NOTE: If atomic locking is used, the POW entry CANNOT be
  * descheduled, as it does not contain a valid WQE pointer.
  *
- * @port:   Port to send it on
+ * @port:   Port to send it on, this can be either IPD port or PKO port.
  * @queue:  Queue to use
- * @use_locking: CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or
+ * @use_locking:
+ *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or
  *               CVMX_PKO_LOCK_CMD_QUEUE
  */
-
 static inline void cvmx_pko_send_packet_prepare(uint64_t port, uint64_t queue,
 						cvmx_pko_lock_t use_locking)
 {
@@ -359,22 +380,28 @@ static inline void cvmx_pko_send_packet_prepare(uint64_t port, uint64_t queue,
 		 * which these fake values can be used - this is not a
 		 * general technique.
 		 */
-		uint32_t tag =
-		    CVMX_TAG_SW_BITS_INTERNAL << CVMX_TAG_SW_SHIFT |
-		    CVMX_TAG_SUBGROUP_PKO << CVMX_TAG_SUBGROUP_SHIFT |
-		    (CVMX_TAG_SUBGROUP_MASK & queue);
-		cvmx_pow_tag_sw_full((cvmx_wqe_t *) cvmx_phys_to_ptr(0x80), tag,
-				     CVMX_POW_TAG_TYPE_ATOMIC, 0);
+		uint32_t tag = CVMX_TAG_SW_BITS_INTERNAL << CVMX_TAG_SW_SHIFT |
+			CVMX_TAG_SUBGROUP_PKO << CVMX_TAG_SUBGROUP_SHIFT |
+			(CVMX_TAG_SUBGROUP_MASK & queue);
+		cvmx_pow_tag_sw_full((cvmx_wqe_t *) cvmx_phys_to_ptr(0x80),
+				     tag, CVMX_POW_TAG_TYPE_ATOMIC, 0);
 	}
 }
 
+#define cvmx_pko_send_packet_prepare_pkoid	cvmx_pko_send_packet_prepare
+
 /**
  * Complete packet output. cvmx_pko_send_packet_prepare() must be
  * called exactly once before this, and the same parameters must be
  * passed to both cvmx_pko_send_packet_prepare() and
  * cvmx_pko_send_packet_finish().
  *
- * @port:   Port to send it on
+ * WARNING: This function may have to look up the proper PKO port in
+ * the IPD port to PKO port map, and is thus slower than calling
+ * cvmx_pko_send_packet_finish_pkoid() directly if the PKO port
+ * identifier is known.
+ *
+ * @ipd_port:   The IPD port corresponding the to pko port the packet is for
  * @queue:  Queue to use
  * @pko_command:
  *               PKO HW command word
@@ -385,12 +412,11 @@ static inline void cvmx_pko_send_packet_prepare(uint64_t port, uint64_t queue,
  * Returns returns CVMX_PKO_SUCCESS on success, or error code on
  * failure of output
  */
-static inline cvmx_pko_status_t cvmx_pko_send_packet_finish(
-	uint64_t port,
-	uint64_t queue,
-	cvmx_pko_command_word0_t pko_command,
-	union cvmx_buf_ptr packet,
-	cvmx_pko_lock_t use_locking)
+static inline enum cvmx_pko_status
+cvmx_pko_send_packet_finish(uint64_t ipd_port, uint64_t queue,
+			    cvmx_pko_command_word0_t pko_command,
+			    union cvmx_buf_ptr packet,
+			    cvmx_pko_lock_t use_locking)
 {
 	cvmx_cmd_queue_result_t result;
 	if (use_locking == CVMX_PKO_LOCK_ATOMIC_TAG)
@@ -399,10 +425,10 @@ static inline cvmx_pko_status_t cvmx_pko_send_packet_finish(
 				       (use_locking == CVMX_PKO_LOCK_CMD_QUEUE),
 				       pko_command.u64, packet.u64);
 	if (likely(result == CVMX_CMD_QUEUE_SUCCESS)) {
-		cvmx_pko_doorbell(port, queue, 2);
+		cvmx_pko_doorbell(ipd_port, queue, 2);
 		return CVMX_PKO_SUCCESS;
-	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY)
-		   || (result == CVMX_CMD_QUEUE_FULL)) {
+	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY) ||
+		   (result == CVMX_CMD_QUEUE_FULL)) {
 		return CVMX_PKO_NO_MEMORY;
 	} else {
 		return CVMX_PKO_INVALID_QUEUE;
@@ -415,26 +441,27 @@ static inline cvmx_pko_status_t cvmx_pko_send_packet_finish(
  * passed to both cvmx_pko_send_packet_prepare() and
  * cvmx_pko_send_packet_finish().
  *
- * @port:   Port to send it on
+ * WARNING: This function may have to look up the proper PKO port in
+ * the IPD port to PKO port map, and is thus slower than calling
+ * cvmx_pko_send_packet_finish3_pkoid() directly if the PKO port
+ * identifier is known.
+ *
+ * @ipd_port:   The IPD port corresponding the to pko port the packet is for
  * @queue:  Queue to use
  * @pko_command:
  *               PKO HW command word
  * @packet: Packet to send
- * @addr: Plysical address of a work queue entry or physical address
- *        to zero on complete.
- * @use_locking: CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or
- *               CVMX_PKO_LOCK_CMD_QUEUE
+ * @addr:   Plysical address of a work queue entry or physical address to zero on complete.
+ * @use_locking:
+ *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE
  *
- * Returns returns CVMX_PKO_SUCCESS on success, or error code on
- * failure of output
+ * Returns returns CVMX_PKO_SUCCESS on success, or error code on failure of output
  */
-static inline cvmx_pko_status_t cvmx_pko_send_packet_finish3(
-	uint64_t port,
-	uint64_t queue,
-	cvmx_pko_command_word0_t pko_command,
-	union cvmx_buf_ptr packet,
-	uint64_t addr,
-	cvmx_pko_lock_t use_locking)
+static inline enum cvmx_pko_status
+cvmx_pko_send_packet_finish3(uint64_t ipd_port, uint64_t queue,
+			     cvmx_pko_command_word0_t pko_command,
+			     union cvmx_buf_ptr packet,
+			     uint64_t addr, cvmx_pko_lock_t use_locking)
 {
 	cvmx_cmd_queue_result_t result;
 	if (use_locking == CVMX_PKO_LOCK_ATOMIC_TAG)
@@ -443,10 +470,10 @@ static inline cvmx_pko_status_t cvmx_pko_send_packet_finish3(
 				       (use_locking == CVMX_PKO_LOCK_CMD_QUEUE),
 				       pko_command.u64, packet.u64, addr);
 	if (likely(result == CVMX_CMD_QUEUE_SUCCESS)) {
-		cvmx_pko_doorbell(port, queue, 3);
+		cvmx_pko_doorbell(ipd_port, queue, 3);
 		return CVMX_PKO_SUCCESS;
-	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY)
-		   || (result == CVMX_CMD_QUEUE_FULL)) {
+	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY) ||
+		   (result == CVMX_CMD_QUEUE_FULL)) {
 		return CVMX_PKO_NO_MEMORY;
 	} else {
 		return CVMX_PKO_INVALID_QUEUE;
@@ -454,6 +481,22 @@ static inline cvmx_pko_status_t cvmx_pko_send_packet_finish3(
 }
 
 /**
+ * Get the first pko_port for the (interface, index)
+ *
+ * @interface:
+ * @index:
+ */
+extern int cvmx_pko_get_base_pko_port(int interface, int index);
+
+/**
+ * Get the number of pko_ports for the (interface, index)
+ *
+ * @interface:
+ * @index:
+ */
+extern int cvmx_pko_get_num_pko_ports(int interface, int index);
+
+/**
  * Return the pko output queue associated with a port and a specific core.
  * In normal mode (PKO lockless operation is disabled), the value returned
  * is the base queue.
@@ -461,39 +504,68 @@ static inline cvmx_pko_status_t cvmx_pko_send_packet_finish3(
  * @port:   Port number
  * @core:   Core to get queue for
  *
- * Returns Core-specific output queue
+ * Returns Core-specific output queue and -1 on error.
+ *
+ * Note: This function is invalid for o68.
  */
 static inline int cvmx_pko_get_base_queue_per_core(int port, int core)
 {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		cvmx_dprintf("cvmx_pko_get_base_queue_per_core() not" "supported starting from o68!\n");
+		return -1;
+	}
 #ifndef CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0
 #define CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0 16
 #endif
 #ifndef CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1
 #define CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1 16
 #endif
-
+#ifndef CVMX_PKO_QUEUES_PER_PORT_SRIO0
+	/* We use two queues per port for SRIO0. Having two queues per
+	   port with two ports gives us four queues, one for each mailbox */
+#define CVMX_PKO_QUEUES_PER_PORT_SRIO0 2
+#endif
+#ifndef CVMX_PKO_QUEUES_PER_PORT_SRIO1
+	/* We use two queues per port for SRIO1. Having two queues per
+	   port with two ports gives us four queues, one for each mailbox */
+#define CVMX_PKO_QUEUES_PER_PORT_SRIO1 2
+#endif
+#ifndef CVMX_PKO_QUEUES_PER_PORT_SRIO2
+	/* We use two queues per port for SRIO2. Having two queues per
+	   port with two ports gives us four queues, one for each mailbox */
+#define CVMX_PKO_QUEUES_PER_PORT_SRIO2 2
+#endif
+#ifndef CVMX_PKO_QUEUES_PER_PORT_SRIO3
+	/* We use two queues per port for SRIO3. Having two queues per
+	   port with two ports gives us four queues, one for each mailbox */
+#define CVMX_PKO_QUEUES_PER_PORT_SRIO3 2
+#endif
 	if (port < CVMX_PKO_MAX_PORTS_INTERFACE0)
 		return port * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 + core;
 	else if (port >= 16 && port < 16 + CVMX_PKO_MAX_PORTS_INTERFACE1)
-		return CVMX_PKO_MAX_PORTS_INTERFACE0 *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 + (port -
-							   16) *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 + core;
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 + (port - 16) * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 + core;
 	else if ((port >= 32) && (port < 36))
-		return CVMX_PKO_MAX_PORTS_INTERFACE0 *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
-		    CVMX_PKO_MAX_PORTS_INTERFACE1 *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 + (port -
-							   32) *
-		    CVMX_PKO_QUEUES_PER_PORT_PCI;
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 + (port - 32) * CVMX_PKO_QUEUES_PER_PORT_PCI;
 	else if ((port >= 36) && (port < 40))
-		return CVMX_PKO_MAX_PORTS_INTERFACE0 *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
-		    CVMX_PKO_MAX_PORTS_INTERFACE1 *
-		    CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 +
-		    4 * CVMX_PKO_QUEUES_PER_PORT_PCI + (port -
-							36) *
-		    CVMX_PKO_QUEUES_PER_PORT_LOOP;
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 + 4 * CVMX_PKO_QUEUES_PER_PORT_PCI + (port - 36) * CVMX_PKO_QUEUES_PER_PORT_LOOP;
+	else if ((port >= 40) && (port < 42))
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 +
+		    4 * CVMX_PKO_QUEUES_PER_PORT_PCI + 4 * CVMX_PKO_QUEUES_PER_PORT_LOOP + (port - 40) * CVMX_PKO_QUEUES_PER_PORT_SRIO0;
+	else if ((port >= 42) && (port < 44))
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 +
+		    4 * CVMX_PKO_QUEUES_PER_PORT_PCI + 4 * CVMX_PKO_QUEUES_PER_PORT_LOOP + 2 * CVMX_PKO_QUEUES_PER_PORT_SRIO0 + (port - 42) * CVMX_PKO_QUEUES_PER_PORT_SRIO1;
+	else if ((port >= 44) && (port < 46))
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 +
+		    4 * CVMX_PKO_QUEUES_PER_PORT_PCI + 4 * CVMX_PKO_QUEUES_PER_PORT_LOOP + 4 * CVMX_PKO_QUEUES_PER_PORT_SRIO0 + (port - 44) * CVMX_PKO_QUEUES_PER_PORT_SRIO2;
+	else if ((port >= 46) && (port < 48))
+		return CVMX_PKO_MAX_PORTS_INTERFACE0 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE0 +
+		    CVMX_PKO_MAX_PORTS_INTERFACE1 * CVMX_PKO_QUEUES_PER_PORT_INTERFACE1 +
+		    4 * CVMX_PKO_QUEUES_PER_PORT_PCI + 4 * CVMX_PKO_QUEUES_PER_PORT_LOOP + 6 * CVMX_PKO_QUEUES_PER_PORT_SRIO0 + (port - 46) * CVMX_PKO_QUEUES_PER_PORT_SRIO3;
 	else
 		/* Given the limit on the number of ports we can map to
 		 * CVMX_MAX_OUTPUT_QUEUES_STATIC queues (currently 256,
@@ -506,78 +578,104 @@ static inline int cvmx_pko_get_base_queue_per_core(int port, int core)
  * For a given port number, return the base pko output queue
  * for the port.
  *
- * @port:   Port number
+ * @port:   IPD port number
  * Returns Base output queue
  */
-static inline int cvmx_pko_get_base_queue(int port)
-{
-	return cvmx_pko_get_base_queue_per_core(port, 0);
-}
+extern int cvmx_pko_get_base_queue(int port);
 
 /**
  * For a given port number, return the number of pko output queues.
  *
- * @port:   Port number
+ * @port:   IPD port number
  * Returns Number of output queues
  */
-static inline int cvmx_pko_get_num_queues(int port)
-{
-	if (port < 16)
-		return CVMX_PKO_QUEUES_PER_PORT_INTERFACE0;
-	else if (port < 32)
-		return CVMX_PKO_QUEUES_PER_PORT_INTERFACE1;
-	else if (port < 36)
-		return CVMX_PKO_QUEUES_PER_PORT_PCI;
-	else if (port < 40)
-		return CVMX_PKO_QUEUES_PER_PORT_LOOP;
-	else
-		return 0;
-}
+extern int cvmx_pko_get_num_queues(int port);
 
 /**
  * Get the status counters for a port.
  *
- * @port_num: Port number to get statistics for.
+ * @ipd_port: Port number (ipd_port) to get statistics for.
  * @clear:    Set to 1 to clear the counters after they are read
  * @status:   Where to put the results.
+ *
+ * Note:
+ *     - Only the doorbell for the base queue of the ipd_port is
+ *       collected.
+ *     - Retrieving the stats involves writing the index through
+ *       CVMX_PKO_REG_READ_IDX and reading the stat CSRs, in that
+ *       order. It is not MP-safe and caller should guarantee
+ *       atomicity.
  */
-static inline void cvmx_pko_get_port_status(uint64_t port_num, uint64_t clear,
+static inline void cvmx_pko_get_port_status(uint64_t ipd_port, uint64_t clear,
 					    cvmx_pko_port_status_t *status)
 {
 	union cvmx_pko_reg_read_idx pko_reg_read_idx;
 	union cvmx_pko_mem_count0 pko_mem_count0;
 	union cvmx_pko_mem_count1 pko_mem_count1;
+	int pko_port, port_base, port_limit;
+
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		int interface = cvmx_helper_get_interface_num(ipd_port);
+		int index = cvmx_helper_get_interface_index_num(ipd_port);
+		port_base = cvmx_helper_get_pko_port(interface, index);
+		if (port_base == -1)
+			cvmx_dprintf("Warning: Invalid port_base\n");
+		port_limit = port_base + cvmx_pko_get_num_pko_ports(interface, index);
+	} else {
+		port_base = ipd_port;
+		port_limit = port_base + 1;
+	}
 
+	/*
+	 * status->packets and status->octets
+	 */
+	status->packets = 0;
+	status->octets = 0;
 	pko_reg_read_idx.u64 = 0;
-	pko_reg_read_idx.s.index = port_num;
-	cvmx_write_csr(CVMX_PKO_REG_READ_IDX, pko_reg_read_idx.u64);
-
-	pko_mem_count0.u64 = cvmx_read_csr(CVMX_PKO_MEM_COUNT0);
-	status->packets = pko_mem_count0.s.count;
-	if (clear) {
-		pko_mem_count0.s.count = port_num;
-		cvmx_write_csr(CVMX_PKO_MEM_COUNT0, pko_mem_count0.u64);
-	}
 
-	pko_mem_count1.u64 = cvmx_read_csr(CVMX_PKO_MEM_COUNT1);
-	status->octets = pko_mem_count1.s.count;
-	if (clear) {
-		pko_mem_count1.s.count = port_num;
-		cvmx_write_csr(CVMX_PKO_MEM_COUNT1, pko_mem_count1.u64);
+	for (pko_port = port_base; pko_port < port_limit; pko_port++) {
+
+		/*
+		 * In theory, one doesn't need to write the index csr every
+		 * time as he can set pko_reg_read_idx.s.inc to increment
+		 * the index automatically. Need to find out exactly how XXX.
+		 */
+		pko_reg_read_idx.s.index = pko_port;
+		cvmx_write_csr(CVMX_PKO_REG_READ_IDX, pko_reg_read_idx.u64);
+
+		pko_mem_count0.u64 = cvmx_read_csr(CVMX_PKO_MEM_COUNT0);
+		status->packets += pko_mem_count0.s.count;
+		if (clear) {
+			pko_mem_count0.s.count = pko_port;
+			cvmx_write_csr(CVMX_PKO_MEM_COUNT0, pko_mem_count0.u64);
+		}
+
+		pko_mem_count1.u64 = cvmx_read_csr(CVMX_PKO_MEM_COUNT1);
+		status->octets += pko_mem_count1.s.count;
+		if (clear) {
+			pko_mem_count1.s.count = pko_port;
+			cvmx_write_csr(CVMX_PKO_MEM_COUNT1, pko_mem_count1.u64);
+		}
 	}
 
+	/*
+	 * status->doorbell
+	 */
 	if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
 		union cvmx_pko_mem_debug9 debug9;
-		pko_reg_read_idx.s.index = cvmx_pko_get_base_queue(port_num);
+		pko_reg_read_idx.s.index = cvmx_pko_get_base_queue(ipd_port);
 		cvmx_write_csr(CVMX_PKO_REG_READ_IDX, pko_reg_read_idx.u64);
 		debug9.u64 = cvmx_read_csr(CVMX_PKO_MEM_DEBUG9);
 		status->doorbell = debug9.cn38xx.doorbell;
 	} else {
 		union cvmx_pko_mem_debug8 debug8;
-		pko_reg_read_idx.s.index = cvmx_pko_get_base_queue(port_num);
+		pko_reg_read_idx.s.index = cvmx_pko_get_base_queue(ipd_port);
 		cvmx_write_csr(CVMX_PKO_REG_READ_IDX, pko_reg_read_idx.u64);
 		debug8.u64 = cvmx_read_csr(CVMX_PKO_MEM_DEBUG8);
-		status->doorbell = debug8.cn58xx.doorbell;
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+			status->doorbell = debug8.cn68xx.doorbell;
+		else
+			status->doorbell = debug8.cn58xx.doorbell;
 	}
 }
 
@@ -607,4 +705,138 @@ extern int cvmx_pko_rate_limit_packets(int port, int packets_s, int burst);
  */
 extern int cvmx_pko_rate_limit_bits(int port, uint64_t bits_s, int burst);
 
+/**
+ * Retrieve the PKO pipe number for a port
+ *
+ * @interface:
+ * @index:
+ *
+ * Returns negative on error.
+ *
+ * This applies only to the non-loopback interfaces.
+ *
+ */
+extern int __cvmx_pko_get_pipe(int interface, int index);
+
+/**
+ * For a given PKO port number, return the base output queue
+ * for the port.
+ *
+ * @pko_port:   PKO port number
+ * Returns           Base output queue
+ */
+extern int cvmx_pko_get_base_queue_pkoid(int pko_port);
+
+/**
+ * For a given PKO port number, return the number of output queues
+ * for the port.
+ *
+ * @pko_port:	PKO port number
+ * Returns		the number of output queues
+ */
+extern int cvmx_pko_get_num_queues_pkoid(int pko_port);
+
+/**
+ * Ring the packet output doorbell. This tells the packet
+ * output hardware that "len" command words have been added
+ * to its pending list.  This command includes the required
+ * CVMX_SYNCWS before the doorbell ring.
+ *
+ * @pko_port:   Port the packet is for
+ * @queue:  Queue the packet is for
+ * @len:    Length of the command in 64 bit words
+ */
+static inline void cvmx_pko_doorbell_pkoid(uint64_t pko_port, uint64_t queue, uint64_t len)
+{
+	cvmx_pko_doorbell_address_t ptr;
+
+	ptr.u64 = 0;
+	ptr.s.mem_space = CVMX_IO_SEG;
+	ptr.s.did = CVMX_OCT_DID_PKT_SEND;
+	ptr.s.is_io = 1;
+	ptr.s.port = pko_port;
+	ptr.s.queue = queue;
+	CVMX_SYNCWS;		/* Need to make sure output queue data is in DRAM before doorbell write */
+	cvmx_write_io(ptr.u64, len);
+}
+
+/**
+ * Complete packet output. cvmx_pko_send_packet_prepare() must be called exactly once before this,
+ * and the same parameters must be passed to both cvmx_pko_send_packet_prepare() and
+ * cvmx_pko_send_packet_finish_pkoid().
+ *
+ * @pko_port:   Port to send it on
+ * @queue:  Queue to use
+ * @pko_command:
+ *               PKO HW command word
+ * @packet: Packet to send
+ * @use_locking:
+ *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE
+ *
+ * Returns returns CVMX_PKO_SUCCESS on success, or error code on failure of output
+ */
+static inline enum cvmx_pko_status
+cvmx_pko_send_packet_finish_pkoid(int pko_port, uint64_t queue,
+				  cvmx_pko_command_word0_t pko_command,
+				  union cvmx_buf_ptr packet,
+				  cvmx_pko_lock_t use_locking)
+{
+	cvmx_cmd_queue_result_t result;
+	if (use_locking == CVMX_PKO_LOCK_ATOMIC_TAG)
+		cvmx_pow_tag_sw_wait();
+	result = cvmx_cmd_queue_write2(CVMX_CMD_QUEUE_PKO(queue),
+				       (use_locking == CVMX_PKO_LOCK_CMD_QUEUE),
+				       pko_command.u64, packet.u64);
+	if (likely(result == CVMX_CMD_QUEUE_SUCCESS)) {
+		cvmx_pko_doorbell_pkoid(pko_port, queue, 2);
+		return CVMX_PKO_SUCCESS;
+	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY) ||
+		   (result == CVMX_CMD_QUEUE_FULL)) {
+		return CVMX_PKO_NO_MEMORY;
+	} else {
+		return CVMX_PKO_INVALID_QUEUE;
+	}
+}
+
+/**
+ * Complete packet output. cvmx_pko_send_packet_prepare() must be
+ * called exactly once before this, and the same parameters must be
+ * passed to both cvmx_pko_send_packet_prepare() and
+ * cvmx_pko_send_packet_finish_pkoid().
+ *
+ * @pko_port:   The PKO port the packet is for
+ * @queue:  Queue to use
+ * @pko_command:
+ *               PKO HW command word
+ * @packet: Packet to send
+ * @addr:   Plysical address of a work queue entry or physical address to zero on complete.
+ * @use_locking:
+ *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE
+ *
+ * Returns returns CVMX_PKO_SUCCESS on success, or error code on
+ * failure of output
+ */
+static inline enum cvmx_pko_status
+cvmx_pko_send_packet_finish3_pkoid(uint64_t pko_port, uint64_t queue,
+				   cvmx_pko_command_word0_t pko_command,
+				   union cvmx_buf_ptr packet, uint64_t addr,
+				   cvmx_pko_lock_t use_locking)
+{
+	cvmx_cmd_queue_result_t result;
+	if (use_locking == CVMX_PKO_LOCK_ATOMIC_TAG)
+		cvmx_pow_tag_sw_wait();
+	result = cvmx_cmd_queue_write3(CVMX_CMD_QUEUE_PKO(queue),
+				       (use_locking == CVMX_PKO_LOCK_CMD_QUEUE),
+				       pko_command.u64, packet.u64, addr);
+	if (likely(result == CVMX_CMD_QUEUE_SUCCESS)) {
+		cvmx_pko_doorbell_pkoid(pko_port, queue, 3);
+		return CVMX_PKO_SUCCESS;
+	} else if ((result == CVMX_CMD_QUEUE_NO_MEMORY) ||
+		   (result == CVMX_CMD_QUEUE_FULL)) {
+		return CVMX_PKO_NO_MEMORY;
+	} else {
+		return CVMX_PKO_INVALID_QUEUE;
+	}
+}
+
 #endif /* __CVMX_PKO_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
new file mode 100644
index 0000000..ad60772
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -0,0 +1,158 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2011 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Helper utilities for qlm.
+ */
+
+#ifndef __CVMX_QLM_H__
+#define __CVMX_QLM_H__
+
+#include <asm/octeon/octeon.h>
+
+/* Uncomment this line to print QLM JTAG state */
+/* #define CVMX_QLM_DUMP_STATE 1 */
+
+struct __cvmx_qlm_jtag_field {
+	const char *name;
+	s16 stop_bit;
+	s16 start_bit;
+};
+
+/**
+ * Return the number of QLMs supported by the chip
+ *
+ * Returns  Number of QLMs
+ */
+extern int cvmx_qlm_get_num(void);
+
+/**
+ * Return the qlm number based on the interface
+ *
+ * @interface:  Interface to look up
+ */
+extern int cvmx_qlm_interface(int interface);
+
+/**
+ * Return number of lanes for a given qlm
+ *
+ * Returns  Number of lanes
+ */
+extern int cvmx_qlm_get_lanes(int qlm);
+
+/**
+ * Get the QLM JTAG fields based on Octeon model on the supported chips.
+ *
+ * Returns  qlm_jtag_field structure
+ */
+extern const struct __cvmx_qlm_jtag_field *cvmx_qlm_jtag_get_field(void);
+
+/**
+ * Get the QLM JTAG length by going through qlm_jtag_field for each
+ * Octeon model that is supported
+ *
+ * Returns return the length.
+ */
+extern int cvmx_qlm_jtag_get_length(void);
+
+/**
+ * Initialize the QLM layer
+ */
+extern void cvmx_qlm_init(void);
+
+/**
+ * Get a field in a QLM JTAG chain
+ *
+ * @qlm:    QLM to get
+ * @lane:   Lane in QLM to get
+ * @name:   String name of field
+ *
+ * Returns JTAG field value
+ */
+extern uint64_t cvmx_qlm_jtag_get(int qlm, int lane, const char *name);
+
+/**
+ * Set a field in a QLM JTAG chain
+ *
+ * @qlm:    QLM to set
+ * @lane:   Lane in QLM to set, or -1 for all lanes
+ * @name:   String name of field
+ * @value:  Value of the field
+ */
+extern void cvmx_qlm_jtag_set(int qlm, int lane, const char *name,
+			      uint64_t value);
+
+/**
+ * Errata G-16094: QLM Gen2 Equalizer Default Setting Change.
+ * CN68XX pass 1.x and CN66XX pass 1.x QLM tweak. This function tweaks the
+ * JTAG setting for a QLMs to run better at 5 and 6.25Ghz.
+ */
+extern void __cvmx_qlm_speed_tweak(void);
+
+/**
+ * Errata G-16174: QLM Gen2 PCIe IDLE DAC change.
+ * CN68XX pass 1.x, CN66XX pass 1.x and CN63XX pass 1.0-2.2 QLM tweak.
+ * This function tweaks the JTAG setting for a QLMs for PCIe to run better.
+ */
+extern void __cvmx_qlm_pcie_idle_dac_tweak(void);
+
+extern void __cvmx_qlm_pcie_cfg_rxd_set_tweak(int qlm, int lane);
+
+/**
+ * Get the speed (Gbaud) of the QLM in Mhz.
+ *
+ * @qlm:    QLM to examine
+ *
+ * Returns Speed in Mhz
+ */
+extern int cvmx_qlm_get_gbaud_mhz(int qlm);
+
+enum cvmx_qlm_mode {
+	CVMX_QLM_MODE_DISABLED = -1,
+	CVMX_QLM_MODE_SGMII = 1,
+	CVMX_QLM_MODE_XAUI,
+	CVMX_QLM_MODE_RXAUI,
+	CVMX_QLM_MODE_PCIE,	/* gen2 / gen1 */
+	CVMX_QLM_MODE_PCIE_1X2,	/* 1x2 gen2 / gen1 */
+	CVMX_QLM_MODE_PCIE_2X1,	/* 2x1 gen2 / gen1 */
+	CVMX_QLM_MODE_SRIO_1X4,	/* 1x4 short / long */
+	CVMX_QLM_MODE_SRIO_2X2,	/* 2x2 short / long */
+	CVMX_QLM_MODE_SRIO_4X1,	/* 4x1 short / long */
+	CVMX_QLM_MODE_ILK,
+};
+
+/*
+ * Read QLM and return mode.
+ */
+extern enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm);
+
+extern void cvmx_qlm_display_registers(int qlm);
+
+extern int cvmx_qlm_configure_qlm(int qlm, int speed, int mode,
+				  int rc, int pcie2x1);
+
+#endif /* __CVMX_QLM_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-spi.h b/arch/mips/include/asm/octeon/cvmx-spi.h
index e814648..015247ee 100644
--- a/arch/mips/include/asm/octeon/cvmx-spi.h
+++ b/arch/mips/include/asm/octeon/cvmx-spi.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,11 +22,10 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
 /*
- *
  * This file contains defines for the SPI interface
  */
 #ifndef __CVMX_SPI_H__
@@ -34,8 +33,6 @@
 
 #include "cvmx-gmxx-defs.h"
 
-/* CSR typedefs have been moved to cvmx-csr-*.h */
-
 typedef enum {
 	CVMX_SPI_MODE_UNKNOWN = 0,
 	CVMX_SPI_MODE_TX_HALFPLEX = 1,
@@ -108,11 +105,13 @@ extern int cvmx_spi_start_interface(int interface, cvmx_spi_mode_t mode,
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
  * @timeout:   Timeout to wait for clock synchronization in seconds
+ *
  * Returns Zero on success, negative of failure.
  */
 extern int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode,
 				      int timeout);
 
+
 /**
  * Return non-zero if the SPI interface has a SPI4000 attached
  *
@@ -132,7 +131,7 @@ static inline int cvmx_spi4000_is_present(int interface)
  */
 static inline int cvmx_spi4000_initialize(int interface)
 {
-	return 0;
+	return -1;
 }
 
 /**
@@ -142,9 +141,7 @@ static inline int cvmx_spi4000_initialize(int interface)
  * @port:      Port to poll (0-9)
  * Returns Status of the port. 0=down. All other values the port is up.
  */
-static inline union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(
-	int interface,
-	int port)
+static inline union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(int interface, int port)
 {
 	union cvmx_gmxx_rxx_rx_inbnd r;
 	r.u64 = 0;
diff --git a/arch/mips/include/asm/octeon/cvmx-srio.h b/arch/mips/include/asm/octeon/cvmx-srio.h
new file mode 100644
index 0000000..ac608c4
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-srio.h
@@ -0,0 +1,643 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+#ifndef __CVMX_SRIO_H__
+#define __CVMX_SRIO_H__
+
+
+/**
+ * Enumeration of the type of operations that can be performed
+ * by a mapped write operation.
+ */
+enum cvmx_srio_write_mode {
+	/* Only create NWrite operations */
+	CVMX_SRIO_WRITE_MODE_NWRITE = 0,
+	/* Create NWrite with response */
+	CVMX_SRIO_WRITE_MODE_NWRITE_RESP = 1,
+	/*
+	 * Intelligently breaks writes into multiple transactions
+	 * based on alignment.
+	 */
+	CVMX_SRIO_WRITE_MODE_AUTO = 2,
+	/* CVMX_SRIO_WRITE_MODE_WRITE followed with a response */
+	CVMX_SRIO_WRITE_MODE_AUTO_RESP = 3,
+	/* Create a MAINTENANCE transaction. Use cvmx_srio_config_write32() instead */
+	CVMX_SRIO_WRITE_MODE_MAINTENANCE = 6,
+	/* Port Write? */
+	CVMX_SRIO_WRITE_MODE_PORT = 7
+};
+
+/**
+ * Enumeration of the type of operations that can be performed
+ * by a mapped read operation.
+ */
+enum cvmx_srio_read_mode {
+	/* Perform a normal read */
+	CVMX_SRIO_READ_MODE_NORMAL = 0,
+	/* Atomically sets bits in data on remote device */
+	CVMX_SRIO_READ_MODE_ATOMIC_SET = 2,
+	/* Atomically clears bits in data on remote device */
+	CVMX_SRIO_READ_MODE_ATOMIC_CLEAR = 3,
+	/* Atomically increments data on remote device */
+	CVMX_SRIO_READ_MODE_ATOMIC_INCREMENT = 4,
+	/* Atomically decrements data on remote device */
+	CVMX_SRIO_READ_MODE_ATOMIC_DECREMENT = 5,
+	/* Create a MAINTENANCE transaction. */
+	CVMX_SRIO_READ_MODE_MAINTENANCE = 6
+};
+
+/**
+ * Initialization flags for SRIO
+ */
+enum cvmx_srio_initialize_flags {
+	CVMX_SRIO_INITIALIZE_NORMAL = 0,
+	CVMX_SRIO_INITIALIZE_DEBUG = 1,
+};
+
+/**
+ * The possible results from a doorbell operation
+ */
+enum cvmx_srio_doorbell_status {
+	/* The doorbell is complete */
+	CVMX_SRIO_DOORBELL_DONE,
+	/* There wasn't an outstanding doorbell */
+	CVMX_SRIO_DOORBELL_NONE,
+	/* The doorbell is still processing */
+	CVMX_SRIO_DOORBELL_BUSY,
+	/* The doorbell needs to be retried */
+	CVMX_SRIO_DOORBELL_RETRY,
+	/* The doorbell failed with an error */
+	CVMX_SRIO_DOORBELL_ERROR,
+	/* The doorbell failed due to timeout */
+	CVMX_SRIO_DOORBELL_TMOUT
+};
+
+/**
+ * This structure represents the SRIO header received from SRIO on
+ * the top of every received message. This header passes through
+ * IPD/PIP unmodified.
+ */
+struct cvmx_srio_rx_message_header {
+	union {
+		uint64_t u64;
+		struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+			/*
+			 * The sRIO prio (priority) field in the first
+			 * sRIO message segment received for the
+			 * message.
+			 */
+			uint64_t prio:2;
+			/*
+			 * When set, indicates that the first sRIO
+			 * message segment received for the message
+			 * had 16-bit source and destination
+			 * ID's. When clear, indicates 8-bit ID were
+			 * present.
+			 */
+			uint64_t tt:1;
+			/*
+			 * When set, indicates that the destination ID
+			 * in the first sRIO message segment received
+			 * for the message matched the 63xx's
+			 * secondary ID. When clear, indicates that
+			 * the destination ID in the first sRIO
+			 * message segment received for the message
+			 * matched the 63xx's primary ID. Note that
+			 * the full destination ID in the received
+			 * sRIO message can be determined via the
+			 * combination of WORD0[DIS] in the sRIO
+			 * inbound message header and WORD1[iprt] in
+			 * the work queue entry created by PIP/IPD.
+			 */
+			uint64_t dis:1;
+			/*
+			 * The RIO ssize (standard message packet data
+			 * size) field used for the message.
+			 */
+			uint64_t ssize:4;
+			/*
+			 * The source ID in the first sRIO message
+			 * segment received for the message. When TT
+			 * is clear, the most-significant 8 bits are
+			 * zero.
+			 */
+			uint64_t sid:16;
+			/*
+			 * The RIO xmbox (recipient mailbox extension)
+			 * field in the first sRIO message segment
+			 * received for the message. Always zero for
+			 * multi-segment messages.
+			 */
+			uint64_t xmbox:4;
+			/*
+			 * The RIO mbox (recipient mailbox) field in
+			 * the first sRIO message segment received for
+			 * the message.
+			 */
+			uint64_t mbox:2;
+			/*
+			 * The RIO letter (slot within a mailbox)
+			 * field in the first sRIO message segment
+			 * received for the message.
+			 */
+			uint64_t letter:2;
+			/*
+			 * A sequence number. Whenever the OCTEON 63xx
+			 * sRIO hardware accepts the first sRIO
+			 * segment of either a message or doorbell, it
+			 * samples the current value of a counter
+			 * register and increments the counter
+			 * register. SEQ is the value sampled for the
+			 * message. The counter increments once per
+			 * message/doorbell. SEQ can be used to
+			 * determine the relative order of
+			 * packets/doorbells. Note that the
+			 * SEQ-implied order may differ from the order
+			 * that the WQE's are received by software for
+			 * a number of reasons, including the fact
+			 * that the WQE is not created until the end
+			 * of the message, while SEQ is sampled when
+			 * the first segment.
+			 */
+			uint64_t seq:32;
+#else
+			uint64_t seq:32;
+			uint64_t letter:2;
+			uint64_t mbox:2;
+			uint64_t xmbox:4;
+			uint64_t sid:16;
+			uint64_t ssize:4;
+			uint64_t dis:1;
+			uint64_t tt:1;
+			uint64_t prio:2;
+#endif
+		} s;
+	} word0;
+	union {
+		uint64_t u64;
+		struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+			/*
+			 * When set, WORD1[R]/PKT_INST_HDR[R] selects
+			 * either RAWFULL or RAWSCHED special PIP
+			 * instruction form. WORD1[R] may commonly be
+			 * set so that WORD1[QOS,GRP] will be directly
+			 * used by the PIP hardware.
+			 */
+			uint64_t r:1;
+			uint64_t reserved_62_58:5;
+			/*
+			 * WORD1[PM]/PKT_INST_HDR[PM] selects the PIP
+			 * parse mode (uninterpreted, skip-to-L2,
+			 * skip-to-IP), and chooses between
+			 * RAWFULL/RAWSCHED when WORD1[R] is set.
+			 */
+			uint64_t pm:2;
+			uint64_t reserved_55:1;
+			/*
+			 * WORD1[SL]/PKT_INST_HDR[SL] selects the skip
+			 * II length. WORD1[SL] may typically be set
+			 * to 8 (or larger) so that PIP skips this
+			 * WORD1.
+			 */
+			uint64_t sl:7;
+			uint64_t reserved_47_46:2;
+			/*
+			 * WORD1[NQOS] must not be set when WORD1[R]
+			 * is clear and PIP interprets WORD1 as a
+			 * PKT_INST_HDR. When set,
+			 * WORD1[NQOS]/PKT_INST_HDR[NQOS] prevents PIP
+			 * from directly using
+			 * WORD1[QOS]/PKT_INST_HDR[QOS] for the QOS
+			 * value in the work queue entry created by
+			 * PIP. WORD1[NQOS] may commonly be clear so
+			 * that WORD1[QOS] will be directly used by
+			 * the PIP hardware. PKT_INST_HDR[NQOS] is new
+			 * to 63xx - this functionality did not exist
+			 * in prior OCTEON's.
+			 */
+			uint64_t nqos:1;
+			/*
+			 * WORD1[NGRP] must not be set when WORD1[R]
+			 * is clear and PIP interprets WORD1 as a
+			 * PKT_INST_HDR. When set,
+			 * WORD1[NGRP]/PKT_INST_HDR[NGRP] prevents PIP
+			 * from directly using
+			 * WORD1[GRP]/PKT_INST_HDR[GRP] for the GRP
+			 * value in the work queue entry created by
+			 * PIP. WORD1[NGRP] may commonly be clear so
+			 * that WORD1[GRP] will be directly used by
+			 * the PIP hardware. PKT_INST_HDR[NGRP] is new
+			 * to 63xx - this functionality did not exist
+			 * in prior OCTEON's.
+			 */
+			uint64_t ngrp:1;
+			/*
+			 * WORD1[NTT] must not be set when WORD1[R] is
+			 * clear and PIP interprets WORD1 as a
+			 * PKT_INST_HDR. When set,
+			 * WORD1[NTT]/PKT_INST_HDR[NTT] prevents PIP
+			 * from directly using
+			 * WORD1[TT]/PKT_INST_HDR[TT] for the TT value
+			 * in the work queue entry created by PIP.
+			 * PKT_INST_HDR[NTT] is new to 63xx - this
+			 * functionality did not exist in prior
+			 * OCTEON's.
+			 */
+			uint64_t ntt:1;
+			/*
+			 * WORD1[NTAG] must not be set when WORD1[R]
+			 * is clear and PIP interprets WORD1 as a
+			 * PKT_INST_HDR. When set,
+			 * WORD1[NTAG]/PKT_INST_HDR[NTAG] prevents PIP
+			 * from directly using
+			 * WORD1[TAG]/PKT_INST_HDR[TAG] for the TAG
+			 * value in the work queue entry created by
+			 * PIP.  PKT_INST_HDR[NTAG] is new to 63xx -
+			 * this functionality did not exist in prior
+			 * OCTEON's.
+			 */
+			uint64_t ntag:1;
+			/*
+			 * Created by the hardware from an entry in a
+			 * 256-entry table. The 8-bit value
+			 * WORD0[PRIO,TT,DIS,MBOX,LETTER] selects the
+			 * table entry. When WORD1[R] is set and
+			 * WORD1[NQOS] is clear, WORD1[QOS] becomes
+			 * the QOS value in the work queue entry
+			 * created by PIP. The QOS value in the work
+			 * queue entry determines the priority that
+			 * SSO/POW will schedule the work, and can
+			 * also control how/if the sRIO message gets
+			 * dropped by PIP/IPD. The 256-entry table is
+			 * unique to each sRIO core, but shared by the
+			 * two controllers associated with the sRIO
+			 * core.
+			 */
+			uint64_t qos:3;
+			/*
+			 * Created by the hardware from an entry in a
+			 * 256-entry table. The 8-bit value
+			 * WORD0[PRIO,TT,DIS,MBOX,LETTER] selects the
+			 * table entry. When WORD1[R] is set and
+			 * WORD1[NGRP] is clear, WORD1[GRP] becomes
+			 * the GRP value in the work queue entry
+			 * created by PIP. The GRP value in the work
+			 * queue entry can direct the work to
+			 * particular cores or particular groups of
+			 * cores. The 256-entry table is unique to
+			 * each sRIO core, but shared by the two
+			 * controllers associated with the sRIO
+			 * core.
+			 */
+			uint64_t grp:4;
+			/*
+			 * In some configurations, enables the sRIO
+			 * message to be buffered solely in the work
+			 * queue entry, and not otherwise in
+			 * L2/DRAM.
+			 */
+			uint64_t rs:1;
+			/*
+			 * When WORD1[R] is set and WORD1[NTT] is
+			 * clear, WORD1[TT]/PKT_INST_HDR[TT] becomes
+			 * the TT value in the work queue entry
+			 * created by PIP. The TT and TAG values in
+			 * the work queue entry determine the
+			 * scheduling/synchronization constraints for
+			 * the work (no constraints, tag order, atomic
+			 * tag order).
+			 */
+			uint64_t tt:2;
+			/*
+			 * Created by the hardware from a CSR
+			 * associated with the sRIO inbound message
+			 * controller. When WORD1[R] is set and
+			 * WORD1[NTAG] is clear,
+			 * WORD1[TAG]/PKT_INST_HDR[TAG] becomes the
+			 * TAG value in the work queue entry created
+			 * by PIP. The TT and TAG values in the work
+			 * queue entry determine the
+			 * scheduling/synchronization constraints for
+			 * the work (no constraints, tag order, atomic
+			 * tag order).
+			 */
+			uint64_t tag:32;
+#else
+			uint64_t tag:32;
+			uint64_t tt:2;
+			uint64_t rs:1;
+			uint64_t grp:4;
+			uint64_t qos:3;
+			uint64_t ntag:1;
+			uint64_t ntt:1;
+			uint64_t ngrp:1;
+			uint64_t nqos:1;
+			uint64_t reserved_47_46:2;
+			uint64_t sl:7;
+			uint64_t reserved_55:1;
+			uint64_t pm:2;
+			uint64_t reserved_62_58:5;
+			uint64_t r:1;
+#endif
+		} s;
+	} word1;
+};
+
+/**
+ * This structure represents the SRIO header required on the front
+ * of PKO packets destine for SRIO message queues.
+ */
+union cvmx_srio_tx_message_header {
+	uint64_t u64;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		/*
+		 * The sRIO prio (priority) field for all segments in
+		 * the message.
+		 */
+		uint64_t prio:2;
+		/*
+		 * When set, the sRIO message segments use a 16-bit
+		 * source and destination ID for all the segments in
+		 * the message. When clear, the message segments use
+		 * an 8-bit ID.
+		 */
+		uint64_t tt:1;
+		/*
+		 * When set, the sRIO message segments use the 63xx's
+		 * secondary ID as the source ID. When clear, the sRIO
+		 * message segments use the primary ID as the source
+		 * ID.
+		 */
+		uint64_t sis:1;
+		/*
+		 * The RIO ssize (standard message segment data size)
+		 * field used for the message.
+		 */
+		uint64_t ssize:4;
+		/*
+		 * The destination ID in the sRIO message segments of
+		 * the message. When TT is clear, the most-significant
+		 * 8 bits must be zero.
+		 */
+		uint64_t did:16;
+		/*
+		 * The RIO xmbox (recipient mailbox extension) field
+		 * in the sRIO message segment for a single-segment
+		 * message. Must be zero for multi-segment
+		 * messages.
+		 */
+		uint64_t xmbox:4;
+		/*
+		 * The RIO mbox (recipient mailbox) field in the sRIO
+		 * message segments of the message.
+		 */
+		uint64_t mbox:2;
+		/*
+		 * The RIO letter (slot within mailbox) field in the
+		 * sRIO message segments of the message when LNS is
+		 * clear. When LNS is set, this LETTER field is not
+		 * used and must be zero.
+		 */
+		uint64_t letter:2;
+		uint64_t reserved_31_2:30;
+		/*
+		 * When set, the outbound message controller will
+		 * dynamically selects an sRIO letter field for the
+		 * message (based on LETTER_SP or LETTER_MP - see
+		 * appendix A), and the LETTER field in this sRIO
+		 * outbound message descriptor is unused. When clear,
+		 * the LETTER field in this sRIO outbound message
+		 * descriptor selects the sRIO letter used for the
+		 * message.
+		 */
+		uint64_t lns:1;
+		/*
+		 * When set, the outbound message controller will set
+		 * an interrupt bit after all sRIO segments of the
+		 * message receive a message DONE response. If the
+		 * message transfer has errors, the interrupt bit is
+		 * not set (but others are).
+		 */
+		uint64_t intr:1;
+#else
+		uint64_t intr:1;
+		uint64_t lns:1;
+		uint64_t reserved_31_2:30;
+		uint64_t letter:2;
+		uint64_t mbox:2;
+		uint64_t xmbox:4;
+		uint64_t did:16;
+		uint64_t ssize:4;
+		uint64_t sis:1;
+		uint64_t tt:1;
+		uint64_t prio:2;
+#endif
+	} s;
+};
+
+/**
+ * Reset SRIO to link partner
+ *
+ * @srio_port:  SRIO port to initialize
+ *
+ * Returns Zero on success
+ */
+int cvmx_srio_link_rst(int srio_port);
+
+/**
+ * Initialize a SRIO port for use.
+ *
+ * @srio_port: SRIO port to initialize
+ * @flags:     Optional flags
+ *
+ * Returns Zero on success
+ */
+int cvmx_srio_initialize(int srio_port, enum cvmx_srio_initialize_flags flags);
+
+/**
+ * Read 32bits from a Device's config space
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID, or -1 for the local Octeon.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @hopcount:  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @result:    Result of the read. This will be unmodified on failure.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
+			    int is16bit, uint8_t hopcount, uint32_t offset,
+			    uint32_t *result);
+
+/**
+ * Write 32bits to a Device's config space
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID, or -1 for the local Octeon.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @hopcount:  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @offset:    Offset in config space. This must be a multiple of 32 bits.
+ * @data:      Data to write.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_config_write32(int srio_port, int srcid_index, int destid,
+			     int is16bit, uint8_t hopcount, uint32_t offset,
+			     uint32_t data);
+
+/**
+ * Send a RapidIO doorbell to a remote device
+ *
+ * @srio_port: SRIO port the device is on
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @priority:  Doorbell priority (0-3)
+ * @data:      Data for doorbell.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_send_doorbell(int srio_port, int srcid_index, int destid,
+			    int is16bit, int priority, uint16_t data);
+
+/**
+ * Get the status of the last doorbell sent. If the dooorbell
+ * hardware is done, then the status is cleared to get ready for
+ * the next doorbell (or retry).
+ *
+ * @srio_port: SRIO port to check doorbell on
+ *
+ * Returns Doorbell status
+ */
+enum cvmx_srio_doorbell_status cvmx_srio_send_doorbell_status(int srio_port);
+
+/**
+ * Read a received doorbell and report data about it.
+ *
+ * @srio_port: SRIO port to check for the received doorbell
+ * @destid_index:
+ *                  Which Octeon destination ID was the doorbell for
+ * @sequence_num:
+ *                  Sequence number of doorbell (32bits)
+ * @srcid:     RapidIO source ID of the doorbell sender
+ * @priority:  Priority of the doorbell (0-3)
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @data:      Data in the doorbell (16 bits)
+ *
+ * Returns Doorbell status. Either DONE, NONE, or ERROR.
+ */
+enum cvmx_srio_doorbell_status cvmx_srio_receive_doorbell(int srio_port,
+							  int *destid_index,
+							  uint32_t *sequence_num,
+							  int *srcid,
+							  int *priority,
+							  int *is16bit,
+							  uint16_t *data);
+
+/**
+ * Receive a packet from the Soft Packet FIFO (SPF).
+ *
+ * @srio_port: SRIO port to read the packet from.
+ * @buffer:    Buffer to receive the packet.
+ * @buffer_length:
+ *                  Length of the buffer in bytes.
+ *
+ * Returns Returns the length of the packet read. Negative on failure.
+ *         Zero if no packets are available.
+ */
+int cvmx_srio_receive_spf(int srio_port, void *buffer, int buffer_length);
+
+/**
+ * Map a remote device's memory region into Octeon's physical
+ * address area. The caller can then map this into a core using
+ * the TLB or XKPHYS.
+ *
+ * @srio_port: SRIO port to map the device on
+ * @write_op:  Type of operation to perform on a write to the device.
+ *                  Normally should be CVMX_SRIO_WRITE_MODE_AUTO.
+ * @write_priority:
+ *                  SRIO priority of writes (0-3)
+ * @read_op:   Type of operation to perform on reads to the device.
+ *                  Normally should be CVMX_SRIO_READ_MODE_NORMAL.
+ * @read_priority:
+ *                  SRIO priority of reads (0-3)
+ * @srcid_index:
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @destid:    RapidIO device ID.
+ * @is16bit:   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @base:      Device base address to start the mapping
+ * @size:      Size of the mapping in bytes
+ *
+ * Returns Octeon 64bit physical address that accesses the remote device,
+ *         or zero on failure.
+ */
+uint64_t cvmx_srio_physical_map(int srio_port, enum cvmx_srio_write_mode write_op,
+				int write_priority, enum cvmx_srio_read_mode read_op,
+				int read_priority, int srcid_index, int destid,
+				int is16bit, uint64_t base, uint64_t size);
+
+/**
+ * Unmap a physical address window created by cvmx_srio_phys_map().
+ *
+ * @physical_address:
+ *               Physical address returned by cvmx_srio_phys_map().
+ * @size:   Size used on original call.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvmx_srio_physical_unmap(uint64_t physical_address, uint64_t size);
+
+/**
+ * fill out outbound message descriptor
+ *
+ * @buf_ptr:     pointer to a buffer pointer. the buffer pointer points
+ *                    to a chain of buffers that hold an outbound srio packet.
+ *                    the packet can take the format of (1) a pip/ipd inbound
+ *                    message or (2) an application-generated outbound message
+ * @desc_ptr:    pointer to an outbound message descriptor. should be null
+ *                    if *buf_ptr is in the format (1)
+ *
+ * Returns           0 on success; negative of failure.
+ */
+int cvmx_srio_omsg_desc(uint64_t port, union cvmx_buf_ptr *buf_ptr,
+			union cvmx_srio_tx_message_header *desc_ptr);
+
+#endif
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 59d9426..0339c9b 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -217,6 +217,13 @@
 #define OCTEON_CN3XXX           (OCTEON_CN58XX_PASS1_0 | OM_MATCH_PREVIOUS_MODELS | OM_IGNORE_REVISION)
 #define OCTEON_CN5XXX           (OCTEON_CN58XX_PASS1_0 | OM_MATCH_5XXX_FAMILY_MODELS)
 #define OCTEON_CN6XXX           (OCTEON_CN63XX_PASS1_0 | OM_MATCH_6XXX_FAMILY_MODELS)
+#define OCTEON_CNF7XXX          (OCTEON_CNF71XX_PASS1_0 | OM_MATCH_F7XXX_FAMILY_MODELS)
+
+/* These are used to cover entire families of OCTEON processors */
+#define OCTEON_FAM_1		(OCTEON_CN3XXX)
+#define OCTEON_FAM_PLUS		(OCTEON_CN5XXX)
+#define OCTEON_FAM_1_PLUS	(OCTEON_FAM_PLUS | OM_MATCH_PREVIOUS_MODELS)
+#define OCTEON_FAM_2		(OCTEON_CN6XXX | OCTEON_CNF71XX)
 
 /* The revision byte (low byte) has two different encodings.
  * CN3XXX:
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index 0c7225d..567fd07 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -847,11 +847,9 @@ static int __devexit cvm_oct_remove(struct platform_device *pdev)
 		}
 	}
 
-	destroy_workqueue(cvm_oct_poll_queue);
-
-	cvmx_pko_shutdown();
+	cvmx_helper_shutdown_packet_io_global();
 
-	cvmx_ipd_free_ptr();
+	destroy_workqueue(cvm_oct_poll_queue);
 
 	/* Free the HW pools */
 	cvm_oct_mem_empty_fpa(CVMX_FPA_PACKET_POOL, CVMX_FPA_PACKET_POOL_SIZE,
-- 
1.7.5.4

