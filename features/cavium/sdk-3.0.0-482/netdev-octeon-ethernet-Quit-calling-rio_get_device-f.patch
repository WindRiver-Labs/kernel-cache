From 8b7110de108a8cbd6dba5bd1b546a8592d4fa234 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 6 Dec 2012 13:13:10 -0800
Subject: [PATCH 261/337] netdev/octeon-ethernet: Quit calling
 rio_get_device() from interrupt context.

Based On SDK 3.0.0-482

rio_get_device() was emitting nasty warnings when called from
interrupt context.  Since the set of connected devices never changes,
get a list of interesting devices at driver init time and cache it for
later use.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-srio.c   |   56 ++++++++++++++++++------
 drivers/net/ethernet/octeon/ethernet.c        |    2 +
 drivers/net/ethernet/octeon/octeon-ethernet.h |    8 ++++
 3 files changed, 52 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-srio.c b/drivers/net/ethernet/octeon/ethernet-srio.c
index fcf4eef..fea6bb4 100644
--- a/drivers/net/ethernet/octeon/ethernet-srio.c
+++ b/drivers/net/ethernet/octeon/ethernet-srio.c
@@ -120,25 +120,17 @@ int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
 
 	/* If this is a broadcast/multicast we must manually send to everyone */
 	if (dest_mac>>40) {
-		struct rio_dev *rdev;
+		struct list_head *pos;
 		struct sk_buff *new_skb;
-		int srio_port = (priv->ipd_port - 40) >> 1;
 
-		rdev = NULL;
-		for (;;) {
-			rdev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, rdev);
-			if (!rdev)
-				break;
-			/* Skip devices not on my rio port */
-			if (rdev->net->hport->id != srio_port)
-				continue;
-			/* Skip switches */
-			if (rdev->destid == 0xffff)
-				continue;
+		list_for_each(pos, &priv->srio_bcast) {
+			struct octeon_ethernet_srio_bcast_target *t;
+
+			t = container_of(pos, struct octeon_ethernet_srio_bcast_target, list);
 			/* Create a new SKB since each packet will have different data */
 			new_skb = skb_copy(skb, GFP_ATOMIC);
 			if (new_skb) {
-				tx_header.s.did = rdev->destid;
+				tx_header.s.did = t->destid;
 				*(u64 *)__skb_push(new_skb, 8) = tx_header.u64;
 				cvm_oct_xmit(new_skb, dev);
 			} else {
@@ -181,6 +173,7 @@ int cvm_oct_srio_init(struct net_device *dev)
 	u32 devid;
 	struct sockaddr sa;
 	union cvmx_sriox_status_reg srio_status_reg;
+	struct rio_dev *rdev;
 
 	dev->features |= NETIF_F_LLTX; /* We do our own locking, Linux doesn't need to */
 
@@ -210,5 +203,40 @@ int cvm_oct_srio_init(struct net_device *dev)
 	dev->netdev_ops->ndo_set_mac_address(dev, &sa);
 	dev->netdev_ops->ndo_change_mtu(dev, dev->mtu);
 
+	rdev = NULL;
+	for (;;) {
+		struct octeon_ethernet_srio_bcast_target *target;
+		rdev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, rdev);
+		if (!rdev)
+			break;
+		/* Skip devices not on my rio port */
+		if (rdev->net->hport->id != srio_port)
+			continue;
+		/* Skip switches */
+		if (rdev->destid == 0xffff)
+			continue;
+		target = kmalloc(sizeof(*target), GFP_KERNEL);
+		if (!target) {
+			WARN(1, "No memory");
+			return -ENOMEM;
+		}
+		target->destid = rdev->destid;
+		list_add(&target->list, &priv->srio_bcast);
+	}
 	return 0;
 }
+
+void cvm_oct_srio_uninit(struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	struct list_head *pos;
+	struct list_head *n;
+
+	list_for_each_safe(pos, n, &priv->srio_bcast) {
+		struct octeon_ethernet_srio_bcast_target *t;
+		list_del(pos);
+		t = container_of(pos, struct octeon_ethernet_srio_bcast_target,
+				 list);
+		kfree(t);
+	}
+}
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index d6bf83f..0f9f74f 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -600,6 +600,7 @@ static const struct net_device_ops cvm_oct_rgmii_netdev_ops = {
 #ifdef CONFIG_RAPIDIO
 static const struct net_device_ops cvm_oct_srio_netdev_ops = {
 	.ndo_init		= cvm_oct_srio_init,
+	.ndo_uninit		= cvm_oct_srio_uninit,
 	.ndo_start_xmit		= cvm_oct_xmit_srio,
 	.ndo_set_mac_address	= cvm_oct_srio_set_mac_address,
 	.ndo_do_ioctl		= cvm_oct_ioctl,
@@ -763,6 +764,7 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 
 			/* Initialize the device private structure. */
 			priv = netdev_priv(dev);
+			INIT_LIST_HEAD(&priv->srio_bcast);
 			priv->of_node = cvm_oct_node_for_port(pip, interface, interface_port);
 			priv->netdev = dev;
 			priv->interface = interface;
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index 568789e..7f964d2 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -88,7 +88,14 @@ struct octeon_ethernet {
 	struct device_node	*of_node;
 	u64 last_tx_octets;
 	u32 last_tx_packets;
+	struct list_head srio_bcast;
 };
+
+struct octeon_ethernet_srio_bcast_target {
+	struct list_head list;
+	u16 destid;
+};
+
 struct octeon_ethernet *cvm_oct_dev_for_port(int);
 
 int cvm_oct_free_work(void *work_queue_entry);
@@ -109,6 +116,7 @@ int cvm_oct_xaui_open(struct net_device *dev);
 int cvm_oct_xaui_stop(struct net_device *dev);
 
 int cvm_oct_srio_init(struct net_device *dev);
+void cvm_oct_srio_uninit(struct net_device *dev);
 int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev);
 int cvm_oct_srio_set_mac_address(struct net_device *dev, void *addr);
 int cvm_oct_srio_change_mtu(struct net_device *dev, int new_mtu);
-- 
1.7.5.4

