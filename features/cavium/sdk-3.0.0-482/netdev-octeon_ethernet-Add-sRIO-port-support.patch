From 1c896d5507e5fdd041d188dcd2efd9b6949eb7f3 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 22 Oct 2012 11:17:32 -0700
Subject: [PATCH 208/337] netdev: octeon_ethernet: Add sRIO port support.

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/net/ethernet/octeon/Makefile          |    3 +
 drivers/net/ethernet/octeon/ethernet-napi.c   |   20 +++-
 drivers/net/ethernet/octeon/ethernet-rx.c     |    1 +
 drivers/net/ethernet/octeon/ethernet-srio.c   |  214 +++++++++++++++++++++++++
 drivers/net/ethernet/octeon/ethernet.c        |   57 ++++++-
 drivers/net/ethernet/octeon/octeon-ethernet.h |   10 ++
 6 files changed, 299 insertions(+), 6 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/ethernet-srio.c

diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 4565364..d9b7b08 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -14,3 +14,6 @@ octeon-ethernet-objs += ethernet-rx.o
 octeon-ethernet-objs += ethernet-sgmii.o
 octeon-ethernet-objs += ethernet-spi.o
 octeon-ethernet-objs += ethernet-tx.o
+ifdef CONFIG_RAPIDIO
+octeon-ethernet-objs += ethernet-srio.o
+endif
diff --git a/drivers/net/ethernet/octeon/ethernet-napi.c b/drivers/net/ethernet/octeon/ethernet-napi.c
index 62ec472..165f30d 100644
--- a/drivers/net/ethernet/octeon/ethernet-napi.c
+++ b/drivers/net/ethernet/octeon/ethernet-napi.c
@@ -203,7 +203,11 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 			else
 				priv = cvm_oct_by_pkind[port];
 		} else {
-			priv = cvm_oct_by_pkind[port];
+			/* srio priv is based on mbox, not port */
+			if (port >= 40 && port <= 47)
+				priv = NULL;
+			else
+				priv = cvm_oct_by_pkind[port];
 		}
 
 		packet_len = work->word1.len;
@@ -325,8 +329,22 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 			}
 			packet_copied = true;
 		}
+		/* srio priv is based on mbox, not port */
+		if (!CVM_OCT_NAPI_HAS_CN68XX_SSO && unlikely(priv == NULL)) {
+			const struct cvmx_srio_rx_message_header *rx_header =
+				(const struct cvmx_srio_rx_message_header *)skb->data;
+			priv = cvm_oct_by_srio_mbox[(port - 40) >> 1][rx_header->word0.s.mbox];
+		}
 
 		if (likely(priv)) {
+#ifdef CONFIG_RAPIDIO
+			if (unlikely(priv->imode == CVMX_HELPER_INTERFACE_MODE_SRIO)) {
+				__skb_pull(skb, sizeof(struct cvmx_srio_rx_message_header));
+
+				atomic64_add(1, (atomic64_t *)&priv->netdev->stats.rx_packets);
+				atomic64_add(skb->len, (atomic64_t *)&priv->netdev->stats.rx_bytes);
+			}
+#endif
 			/* Only accept packets for devices that are
 			 * currently up.
 			 */
diff --git a/drivers/net/ethernet/octeon/ethernet-rx.c b/drivers/net/ethernet/octeon/ethernet-rx.c
index 11cafe0..bc836f4 100644
--- a/drivers/net/ethernet/octeon/ethernet-rx.c
+++ b/drivers/net/ethernet/octeon/ethernet-rx.c
@@ -53,6 +53,7 @@
 #include <asm/octeon/cvmx-fau.h>
 #include <asm/octeon/cvmx-pow.h>
 #include <asm/octeon/cvmx-pip.h>
+#include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-scratch.h>
 
 #include <asm/octeon/cvmx-gmxx-defs.h>
diff --git a/drivers/net/ethernet/octeon/ethernet-srio.c b/drivers/net/ethernet/octeon/ethernet-srio.c
new file mode 100644
index 0000000..fcf4eef
--- /dev/null
+++ b/drivers/net/ethernet/octeon/ethernet-srio.c
@@ -0,0 +1,214 @@
+/*************************************************************************
+ *
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2010 - 2012 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ *************************************************************************/
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <net/dst.h>
+#include <net/sock.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/rio_ids.h>
+#include <linux/if_vlan.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-srio.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+
+#include "ethernet-defines.h"
+#include "octeon-ethernet.h"
+
+struct net_device_stats *cvm_oct_srio_get_stats(struct net_device *dev)
+{
+	return &dev->stats;
+}
+
+int cvm_oct_srio_set_mac_address(struct net_device *dev, void *addr)
+{
+	/* FIXME: Should this be allowed? Should it change our device ID? */
+	memcpy(dev->dev_addr, addr + 2, 6);
+	return 0;
+}
+
+int cvm_oct_srio_change_mtu(struct net_device *dev, int new_mtu)
+{
+	union cvmx_pip_frm_len_chkx pip_frm_len_chkx;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	int vlan_bytes = VLAN_HLEN;
+#else
+	int vlan_bytes = 0;
+#endif
+	unsigned int max_mtu;
+
+	/*
+	 * Limit the MTU to make sure the ethernet packets are between
+	 * 68 bytes and 4096 - ethernet header, fcs and optional VLAN bytes.
+	 */
+	max_mtu = RIO_MAX_MSG_SIZE - ETH_HLEN - vlan_bytes - ETH_FCS_LEN;
+	if ((new_mtu < 68) || (new_mtu > max_mtu)) {
+		netdev_warn(dev, "MTU must be between %d and %d.\n",
+			    68, max_mtu);
+		return -EINVAL;
+	}
+	dev->mtu = new_mtu;
+
+	/* set up pip. other interfaces prefer to disable the pip check. */
+	pip_frm_len_chkx.u64 = cvmx_read_csr(CVMX_PIP_FRM_LEN_CHKX(0));
+	pip_frm_len_chkx.s.maxlen = (new_mtu + 256) & ~0xff;
+	cvmx_write_csr(CVMX_PIP_FRM_LEN_CHKX(0), pip_frm_len_chkx.u64);
+
+	return 0;
+}
+
+int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	union cvmx_srio_tx_message_header tx_header;
+	u64 dest_mac;
+
+	if (unlikely(skb->len > 4096)) {
+		dev_kfree_skb(skb);
+		netdev_dbg(dev, "TX packet larger than 4096 bytes. Dropped.\n");
+		return 0;
+	}
+
+	/* srio message length needs to be a multiple of 8 */
+	if (unlikely(skb_tailroom(skb) < 8))
+		/* can optionally allocate a larger sk_buff and do a copy */
+		skb->len = skb->len;
+	else
+		skb->len = ((skb->len >> 3) + 1) << 3;
+
+	tx_header.u64 = priv->srio_tx_header;
+	/* Use the socket priority if it is available */
+	if (skb->sk) {
+		if (skb->sk->sk_priority < 0)
+			tx_header.s.prio = 0;
+		else if (skb->sk->sk_priority > 3)
+			tx_header.s.prio = 3;
+		else
+			tx_header.s.prio = skb->sk->sk_priority;
+	}
+
+	/* Extract the destination MAC address from the packet */
+	dest_mac = *(u64 *)skb->data >> 16;
+
+	/* If this is a broadcast/multicast we must manually send to everyone */
+	if (dest_mac>>40) {
+		struct rio_dev *rdev;
+		struct sk_buff *new_skb;
+		int srio_port = (priv->ipd_port - 40) >> 1;
+
+		rdev = NULL;
+		for (;;) {
+			rdev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, rdev);
+			if (!rdev)
+				break;
+			/* Skip devices not on my rio port */
+			if (rdev->net->hport->id != srio_port)
+				continue;
+			/* Skip switches */
+			if (rdev->destid == 0xffff)
+				continue;
+			/* Create a new SKB since each packet will have different data */
+			new_skb = skb_copy(skb, GFP_ATOMIC);
+			if (new_skb) {
+				tx_header.s.did = rdev->destid;
+				*(u64 *)__skb_push(new_skb, 8) = tx_header.u64;
+				cvm_oct_xmit(new_skb, dev);
+			} else {
+				netdev_dbg(dev, "SKB allocation failed\n");
+				break;
+			}
+		}
+
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	} else {
+		/* Use the low two bytes of the destination MAC as the SRIO
+		 * destination */
+		/* tx_header.s.did = *(u16 *)(skb->data + 4); */
+		tx_header.s.did = *(u8 *)(skb->data + 5);
+		if (unlikely(skb_headroom(skb) < 8)) {
+			struct sk_buff *new_skb = skb_copy(skb, GFP_ATOMIC);
+			dev_kfree_skb(skb);
+			if (!new_skb) {
+				netdev_dbg(dev,
+					   "SKB didn't have room for SRIO header and allocation failed\n");
+				return NETDEV_TX_OK;
+			}
+			skb = new_skb;
+		}
+
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
+		*(u64 *)__skb_push(skb, 8) = tx_header.u64;
+		return cvm_oct_xmit(skb, dev);
+	}
+}
+
+int cvm_oct_srio_init(struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	int srio_port = (priv->ipd_port - 40) >> 1;
+	u32 devid;
+	struct sockaddr sa;
+	union cvmx_sriox_status_reg srio_status_reg;
+
+	dev->features |= NETIF_F_LLTX; /* We do our own locking, Linux doesn't need to */
+
+	SET_ETHTOOL_OPS(dev, &cvm_oct_ethtool_ops);
+
+	/* Make sure register access is allowed */
+	srio_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (!srio_status_reg.s.access)
+		return 0;
+
+	netif_carrier_on(dev);
+
+	cvmx_srio_config_read32(srio_port, 0, -1, 1, 0, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &devid);
+
+	sa.sa_data[0] = 0;
+	sa.sa_data[1] = 0;
+	sa.sa_data[2] = 0;
+	sa.sa_data[3] = 0;
+	if (devid >> 16) {
+		sa.sa_data[4] = 0;
+		sa.sa_data[5] = (devid >> 16) & 0xff;
+	} else {
+		sa.sa_data[4] = (devid >> 8) & 0xff;
+		sa.sa_data[5] = devid & 0xff;
+	}
+
+	dev->netdev_ops->ndo_set_mac_address(dev, &sa);
+	dev->netdev_ops->ndo_change_mtu(dev, dev->mtu);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 79199731..15cefc5 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -46,6 +46,7 @@
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-fau.h>
 #include <asm/octeon/cvmx-ipd.h>
+#include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-helper.h>
 
 #include <asm/octeon/cvmx-gmxx-defs.h>
@@ -101,6 +102,11 @@ atomic_t cvm_oct_poll_queue_stopping = ATOMIC_INIT(0);
  */
 struct octeon_ethernet *cvm_oct_by_pkind[64] __cacheline_aligned;
 
+/*
+ * cvm_oct_by_srio_mbox is indexed by the SRIO mailbox.
+ */
+struct octeon_ethernet *cvm_oct_by_srio_mbox[4][4];
+
 /* cvm_oct_list is a list of all cvm_oct_private_t created by this driver. */
 LIST_HEAD(cvm_oct_list);
 
@@ -552,6 +558,19 @@ static const struct net_device_ops cvm_oct_rgmii_netdev_ops = {
 	.ndo_poll_controller	= cvm_oct_poll_controller,
 #endif
 };
+#ifdef CONFIG_RAPIDIO
+static const struct net_device_ops cvm_oct_srio_netdev_ops = {
+	.ndo_init		= cvm_oct_srio_init,
+	.ndo_start_xmit		= cvm_oct_xmit_srio,
+	.ndo_set_mac_address	= cvm_oct_srio_set_mac_address,
+	.ndo_do_ioctl		= cvm_oct_ioctl,
+	.ndo_change_mtu		= cvm_oct_srio_change_mtu,
+	.ndo_get_stats		= cvm_oct_srio_get_stats,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= cvm_oct_poll_controller,
+#endif
+};
+#endif
 
 extern void octeon_mdiobus_force_mod_depencency(void);
 
@@ -687,6 +706,9 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 		int num_ports = cvmx_helper_ports_on_interface(interface);
 		int interface_port;
 
+		if (imode == CVMX_HELPER_INTERFACE_MODE_SRIO)
+			num_ports = 2; /* consistent with se apps. could be 4 */
+
 		for (interface_port = 0; interface_port < num_ports;
 		     interface_port++) {
 			struct octeon_ethernet *priv;
@@ -710,11 +732,30 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 			INIT_DELAYED_WORK(&priv->port_periodic_work,
 					  cvm_oct_periodic_worker);
 			priv->imode = imode;
-			priv->ipd_port = cvmx_helper_get_ipd_port(interface, interface_port);
-			priv->key = priv->ipd_port;
-			priv->pko_port = cvmx_helper_get_pko_port(interface, interface_port);
-			base_queue = cvmx_pko_get_base_queue(priv->ipd_port);
-			priv->num_tx_queues = cvmx_pko_get_num_queues(priv->ipd_port);
+
+			if (imode == CVMX_HELPER_INTERFACE_MODE_SRIO) {
+				int mbox = cvmx_helper_get_ipd_port(interface, interface_port) - cvmx_helper_get_ipd_port(interface, 0);
+				union cvmx_srio_tx_message_header tx_header;
+				tx_header.u64 = 0;
+				tx_header.s.tt = 0;
+				tx_header.s.ssize = 0xe;
+				tx_header.s.mbox = mbox;
+				tx_header.s.lns = 1;
+				tx_header.s.intr = 1;
+				priv->srio_tx_header = tx_header.u64;
+				priv->ipd_port = cvmx_helper_get_ipd_port(interface, mbox >> 1);
+				priv->pko_port = priv->ipd_port;
+				priv->key = priv->ipd_port + (0x10000 * mbox);
+				base_queue = cvmx_pko_get_base_queue(priv->ipd_port) + (mbox & 1);
+				priv->num_tx_queues = 1;
+				cvm_oct_by_srio_mbox[interface - 4][mbox] = priv;
+			} else {
+				priv->ipd_port = cvmx_helper_get_ipd_port(interface, interface_port);
+				priv->key = priv->ipd_port;
+				priv->pko_port = cvmx_helper_get_pko_port(interface, interface_port);
+				base_queue = cvmx_pko_get_base_queue(priv->ipd_port);
+				priv->num_tx_queues = cvmx_pko_get_num_queues(priv->ipd_port);
+			}
 
 			BUG_ON(priv->num_tx_queues < 1);
 			BUG_ON(priv->num_tx_queues > 32);
@@ -773,6 +814,12 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 				dev->netdev_ops = &cvm_oct_rgmii_netdev_ops;
 				strcpy(dev->name, "eth%d");
 				break;
+#ifdef CONFIG_RAPIDIO
+			case CVMX_HELPER_INTERFACE_MODE_SRIO:
+				dev->netdev_ops = &cvm_oct_srio_netdev_ops;
+				strcpy(dev->name, "rio%d");
+				break;
+#endif
 			}
 
 			netif_carrier_off(dev);
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index a02f79c..39d2503 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -66,6 +66,9 @@ struct octeon_ethernet {
 	/* Number of elements in tx_queue below */
 	int                     num_tx_queues;
 
+	/* SRIO ports add this header for the SRIO block */
+	u64 srio_tx_header;
+
 	struct {
 		/* PKO hardware queue for the port */
 		int	queue;
@@ -105,6 +108,12 @@ int cvm_oct_xaui_init(struct net_device *dev);
 int cvm_oct_xaui_open(struct net_device *dev);
 int cvm_oct_xaui_stop(struct net_device *dev);
 
+int cvm_oct_srio_init(struct net_device *dev);
+int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev);
+int cvm_oct_srio_set_mac_address(struct net_device *dev, void *addr);
+int cvm_oct_srio_change_mtu(struct net_device *dev, int new_mtu);
+struct net_device_stats *cvm_oct_srio_get_stats(struct net_device *dev);
+
 int cvm_oct_common_init(struct net_device *dev);
 
 void cvm_oct_set_carrier(struct octeon_ethernet *priv,
@@ -135,6 +144,7 @@ extern int pow_receive_group;
 extern char pow_send_list[];
 extern struct list_head cvm_oct_list;
 extern struct octeon_ethernet *cvm_oct_by_pkind[];
+extern struct octeon_ethernet *cvm_oct_by_srio_mbox[4][4];
 
 extern struct workqueue_struct *cvm_oct_poll_queue;
 extern atomic_t cvm_oct_poll_queue_stopping;
-- 
1.7.5.4

