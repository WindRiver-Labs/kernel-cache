From 00462e63c1b8349f77fd7727bbd77190d59187b5 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 12 Nov 2012 17:25:01 -0800
Subject: [PATCH 295/337] netdev/MIPS: Convert OCTEON Ethernet driver to use
 octeon_hw_status infrastructure.

Based On SDK 3.0.0-482

Verbose error condition reporting is removed.  This will we done in a
separate module that reports errors for chip-wide errors.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c           |    1 -
 arch/mips/include/asm/mach-cavium-octeon/irq.h |    1 -
 drivers/net/ethernet/octeon/ethernet-rgmii.c   |  202 ++++++---------
 drivers/net/ethernet/octeon/ethernet-spi.c     |  320 ++++++++++--------------
 drivers/net/ethernet/octeon/octeon-ethernet.h  |    1 +
 5 files changed, 220 insertions(+), 305 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 0650657..95b9d75 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -1271,7 +1271,6 @@ static void __init octeon_irq_init_ciu(void)
 	for (i = 0; i < 4; i++)
 		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_PCI_MSI0, 0, i + 40, 0, chip, handle_level_irq);
 
-	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RML, 0, 46, 0, chip, handle_level_irq);
 	for (i = 0; i < 4; i++)
 		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_TIMER0, 0, i + 52, 0, chip_edge, handle_edge_irq);
 
diff --git a/arch/mips/include/asm/mach-cavium-octeon/irq.h b/arch/mips/include/asm/mach-cavium-octeon/irq.h
index 23b86f7..907cb8f 100644
--- a/arch/mips/include/asm/mach-cavium-octeon/irq.h
+++ b/arch/mips/include/asm/mach-cavium-octeon/irq.h
@@ -35,7 +35,6 @@ enum octeon_irq {
 	OCTEON_IRQ_PCI_MSI2,
 	OCTEON_IRQ_PCI_MSI3,
 
-	OCTEON_IRQ_RML,
 	OCTEON_IRQ_TIMER0,
 	OCTEON_IRQ_TIMER1,
 	OCTEON_IRQ_TIMER2,
diff --git a/drivers/net/ethernet/octeon/ethernet-rgmii.c b/drivers/net/ethernet/octeon/ethernet-rgmii.c
index c418969..4bc892d 100644
--- a/drivers/net/ethernet/octeon/ethernet-rgmii.c
+++ b/drivers/net/ethernet/octeon/ethernet-rgmii.c
@@ -31,6 +31,7 @@
 #include <linux/ratelimit.h>
 #include <net/dst.h>
 
+#include <asm/octeon/octeon-hw-status.h>
 #include <asm/octeon/octeon.h>
 
 #include "ethernet-defines.h"
@@ -42,7 +43,11 @@
 #include <asm/octeon/cvmx-npi-defs.h>
 #include <asm/octeon/cvmx-gmxx-defs.h>
 
-static int number_rgmii_ports;
+#define INT_BIT_PHY_LINK 16
+#define INT_BIT_PHY_SPD 17
+#define INT_BIT_PHY_DUPX 18
+
+DEFINE_SPINLOCK(global_register_lock);
 
 static void cvm_oct_rgmii_poll(struct net_device *dev)
 {
@@ -137,78 +142,22 @@ static void cvm_oct_rgmii_poll(struct net_device *dev)
 		cvm_oct_set_carrier(priv, link_info);
 }
 
-static irqreturn_t cvm_oct_rgmii_rml_interrupt(int cpl, void *dev_id)
+static int cvm_oct_rgmii_hw_status(struct notifier_block *nb, unsigned long val, void *v)
 {
-	union cvmx_npi_rsl_int_blocks rsl_int_blocks;
-	int index;
-	irqreturn_t return_status = IRQ_NONE;
-
-	rsl_int_blocks.u64 = cvmx_read_csr(CVMX_NPI_RSL_INT_BLOCKS);
-
-	/* Check and see if this interrupt was caused by the GMX0 block */
-	if (rsl_int_blocks.s.gmx0) {
-		int interface = 0;
-		/* Loop through every port of this interface */
-		for (index = 0;
-		     index < cvmx_helper_ports_on_interface(interface);
-		     index++) {
-			/* Read the GMX interrupt status bits */
-			union cvmx_gmxx_rxx_int_reg gmx_rx_int_reg;
-			gmx_rx_int_reg.u64 = cvmx_read_csr(CVMX_GMXX_RXX_INT_REG(index, interface));
-			gmx_rx_int_reg.u64 &= cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(index, interface));
-			/* Poll the port if inband status changed */
-			if (gmx_rx_int_reg.s.phy_dupx
-			    || gmx_rx_int_reg.s.phy_link
-			    || gmx_rx_int_reg.s.phy_spd) {
-				struct octeon_ethernet *priv = cvm_oct_dev_for_port(cvmx_helper_get_ipd_port(interface, index));
-
-				if (priv && !atomic_read(&cvm_oct_poll_queue_stopping))
-					queue_work(cvm_oct_poll_queue, &priv->port_work);
-
-				gmx_rx_int_reg.u64 = 0;
-				gmx_rx_int_reg.s.phy_dupx = 1;
-				gmx_rx_int_reg.s.phy_link = 1;
-				gmx_rx_int_reg.s.phy_spd = 1;
-				cvmx_write_csr(CVMX_GMXX_RXX_INT_REG(index, interface),
-					       gmx_rx_int_reg.u64);
-				return_status = IRQ_HANDLED;
-			}
+	struct octeon_ethernet *priv = container_of(nb, struct octeon_ethernet, hw_status_notifier);
+
+	if (val == OCTEON_HW_STATUS_SOURCE_ASSERTED) {
+		struct octeon_hw_status_data *d = v;
+		if (d->reg == CVMX_GMXX_RXX_INT_REG(priv->interface_port, priv->interface) &&
+		    (d->bit == INT_BIT_PHY_LINK ||
+		     d->bit == INT_BIT_PHY_SPD ||
+		     d->bit == INT_BIT_PHY_DUPX)) {
+			if (!atomic_read(&cvm_oct_poll_queue_stopping))
+				queue_work(cvm_oct_poll_queue, &priv->port_work);
+			return NOTIFY_STOP;
 		}
 	}
-
-	/* Check and see if this interrupt was caused by the GMX1 block */
-	if (rsl_int_blocks.s.gmx1) {
-		int interface = 1;
-		/* Loop through every port of this interface */
-		for (index = 0;
-		     index < cvmx_helper_ports_on_interface(interface);
-		     index++) {
-			/* Read the GMX interrupt status bits */
-			union cvmx_gmxx_rxx_int_reg gmx_rx_int_reg;
-			gmx_rx_int_reg.u64 =
-				cvmx_read_csr(CVMX_GMXX_RXX_INT_REG(index, interface));
-			gmx_rx_int_reg.u64 &=
-				cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(index, interface));
-			/* Poll the port if inband status changed */
-			if (gmx_rx_int_reg.s.phy_dupx
-			    || gmx_rx_int_reg.s.phy_link
-			    || gmx_rx_int_reg.s.phy_spd) {
-				struct octeon_ethernet *priv = cvm_oct_dev_for_port(cvmx_helper_get_ipd_port(interface, index));
-
-				if (priv && !atomic_read(&cvm_oct_poll_queue_stopping))
-					queue_work(cvm_oct_poll_queue, &priv->port_work);
-
-				gmx_rx_int_reg.u64 = 0;
-				gmx_rx_int_reg.s.phy_dupx = 1;
-				gmx_rx_int_reg.s.phy_link = 1;
-				gmx_rx_int_reg.s.phy_spd = 1;
-				cvmx_write_csr(CVMX_GMXX_RXX_INT_REG(index, interface),
-					       gmx_rx_int_reg.u64);
-				return_status = IRQ_HANDLED;
-			}
-		}
-	}
-	return return_status;
+	return NOTIFY_DONE;
 }
 
 static void cvm_oct_rgmii_immediate_poll(struct work_struct *work)
@@ -220,6 +169,8 @@ static void cvm_oct_rgmii_immediate_poll(struct work_struct *work)
 int cvm_oct_rgmii_open(struct net_device *dev)
 {
 	union cvmx_ipd_sub_port_fcs ipd_sub_port_fcs;
+	struct octeon_hw_status_reg sr[3];
+	u64 en_mask;
 	union cvmx_gmxx_prtx_cfg gmx_cfg;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	cvmx_helper_link_info_t link_info;
@@ -251,6 +202,15 @@ int cvm_oct_rgmii_open(struct net_device *dev)
 	}
 
 	INIT_WORK(&priv->port_work, cvm_oct_rgmii_immediate_poll);
+
+
+	/* Only true RGMII ports need to be polled. In GMII mode, port
+	 * 0 is really a RGMII port.
+	 */
+	if ((priv->imode == CVMX_HELPER_INTERFACE_MODE_GMII && priv->ipd_port != 0) ||
+	    octeon_is_simulation())
+		return 0;
+
 	/* Due to GMX errata in CN3XXX series chips, it is necessary
 	 * to take the link down immediately when the PHY changes
 	 * state. In order to do this we call the poll function every
@@ -258,34 +218,35 @@ int cvm_oct_rgmii_open(struct net_device *dev)
 	 * problems if the PHY doesn't implement inband status
 	 * properly.
 	 */
-	if (number_rgmii_ports == 0) {
-		rv = request_irq(OCTEON_IRQ_RML, cvm_oct_rgmii_rml_interrupt,
-				 IRQF_SHARED, "RGMII", &number_rgmii_ports);
-		if (rv != 0)
-			return rv;
-	}
-	number_rgmii_ports++;
+	priv->hw_status_notifier.priority = 1;
+	priv->hw_status_notifier.notifier_call = cvm_oct_rgmii_hw_status;
+	octeon_hw_status_notifier_register(&priv->hw_status_notifier);
 
-	/* Only true RGMII ports need to be polled. In GMII mode, port
-	 * 0 is really a RGMII port.
-	 */
-	if (((priv->imode == CVMX_HELPER_INTERFACE_MODE_GMII)
-	     && (priv->ipd_port == 0))
-	    || (priv->imode == CVMX_HELPER_INTERFACE_MODE_RGMII)) {
-		if (!octeon_is_simulation()) {
-			union cvmx_gmxx_rxx_int_en gmx_rx_int_en;
-			/* Enable interrupts on inband status changes
-			 * for this port.
-			 */
-			gmx_rx_int_en.u64 =
-				cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface));
-			gmx_rx_int_en.s.phy_dupx = 1;
-			gmx_rx_int_en.s.phy_link = 1;
-			gmx_rx_int_en.s.phy_spd = 1;
-			cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface),
-				       gmx_rx_int_en.u64);
-		}
-	}
+	en_mask = 0;
+	memset(sr, 0, sizeof(sr));
+	sr[0].reg = 46; /* RML */
+	sr[0].reg_is_hwint = 1;
+	sr[0].has_child = 1;
+	sr[1].reg = CVMX_NPI_RSL_INT_BLOCKS;
+	sr[1].bit = priv->interface + 1;
+	sr[1].has_child = 1;
+	sr[2].reg = CVMX_GMXX_RXX_INT_REG(priv->interface_port, priv->interface);
+	sr[2].mask_reg = CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface);
+	sr[2].ack_w1c = 1;
+
+	sr[2].bit = INT_BIT_PHY_LINK;
+	en_mask |= 1ull << sr[2].bit;
+	octeon_hw_status_add_source(sr);
+
+	sr[2].bit = INT_BIT_PHY_SPD;
+	en_mask |= 1ull << sr[2].bit;
+	octeon_hw_status_add_source(sr);
+
+	sr[2].bit = INT_BIT_PHY_DUPX;
+	en_mask |= 1ull << sr[2].bit;
+	octeon_hw_status_add_source(sr);
+
+	octeon_hw_status_enable(sr[2].reg, en_mask);
 
 
 	/* Disable FCS stripping for PKI-602*/
@@ -307,31 +268,24 @@ int cvm_oct_rgmii_stop(struct net_device *dev)
 	gmx_cfg.s.en = 0;
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface), gmx_cfg.u64);
 
-	/* Only true RGMII ports need to be polled. In GMII mode, port
-	 * 0 is really a RGMII port.
-	 */
-	if (((priv->imode == CVMX_HELPER_INTERFACE_MODE_GMII)
-	     && (priv->ipd_port == 0))
-	    || (priv->imode == CVMX_HELPER_INTERFACE_MODE_RGMII)) {
-		if (!octeon_is_simulation()) {
-			union cvmx_gmxx_rxx_int_en gmx_rx_int_en;
-			/* Disable interrupts on inband status changes
-			 * for this port.
-			 */
-			gmx_rx_int_en.u64 =
-				cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface));
-			gmx_rx_int_en.s.phy_dupx = 0;
-			gmx_rx_int_en.s.phy_link = 0;
-			gmx_rx_int_en.s.phy_spd = 0;
-			cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface),
-				       gmx_rx_int_en.u64);
-		}
+
+	if (priv->hw_status_notifier.notifier_call) {
+		struct octeon_hw_status_reg sr;
+		memset(&sr, 0, sizeof(sr));
+
+		sr.reg = CVMX_GMXX_RXX_INT_REG(priv->interface_port, priv->interface);
+		sr.mask_reg = CVMX_GMXX_RXX_INT_EN(priv->interface_port, priv->interface);
+		sr.ack_w1c = 1;
+		sr.bit = INT_BIT_PHY_LINK;
+		octeon_hw_status_remove_source(&sr);
+		sr.bit = INT_BIT_PHY_SPD;
+		octeon_hw_status_remove_source(&sr);
+		sr.bit = INT_BIT_PHY_DUPX;
+		octeon_hw_status_remove_source(&sr);
+		octeon_hw_status_notifier_unregister(&priv->hw_status_notifier);
+		priv->hw_status_notifier.notifier_call = NULL;
 	}
 
-	/* Remove the interrupt handler when the last port is removed. */
-	number_rgmii_ports--;
-	if (number_rgmii_ports == 0)
-		free_irq(OCTEON_IRQ_RML, &number_rgmii_ports);
 	cancel_work_sync(&priv->port_work);
 
 	/* re-Enable FCS stripping */
@@ -345,8 +299,14 @@ int cvm_oct_rgmii_stop(struct net_device *dev)
 
 int cvm_oct_rgmii_init(struct net_device *dev)
 {
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	union cvmx_gmxx_prtx_cfg gmx_cfg;
+
+	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface));
+	gmx_cfg.s.en = 0;
+	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(priv->interface_port, priv->interface), gmx_cfg.u64);
+
 	cvm_oct_common_init(dev);
-	dev->netdev_ops->ndo_stop(dev);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/octeon/ethernet-spi.c b/drivers/net/ethernet/octeon/ethernet-spi.c
index d37e53f..f603f7f 100644
--- a/drivers/net/ethernet/octeon/ethernet-spi.c
+++ b/drivers/net/ethernet/octeon/ethernet-spi.c
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <net/dst.h>
 
+#include <asm/octeon/octeon-hw-status.h>
 #include <asm/octeon/octeon.h>
 
 #include "ethernet-defines.h"
@@ -40,173 +41,71 @@
 #include <asm/octeon/cvmx-spxx-defs.h>
 #include <asm/octeon/cvmx-stxx-defs.h>
 
-static int number_spi_ports;
+#define MASK_FOR_BIT(_X) (1ull << (_X))
+
+#define INT_BIT_SPX_PRTNXA 0
+#define INT_BIT_SPX_ABNORM 1
+#define INT_BIT_SPX_SPIOVR 4
+#define INT_BIT_SPX_CLSERR 5
+#define INT_BIT_SPX_DRWNNG 6
+#define INT_BIT_SPX_RSVERR 7
+#define INT_BIT_SPX_TPAOVR 8
+#define INT_BIT_SPX_DIPERR 9
+#define INT_BIT_SPX_SYNCERR 10
+#define INT_BIT_SPX_CALERR 11
+
+#define SPX_MASK (				\
+	MASK_FOR_BIT(INT_BIT_SPX_PRTNXA) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_ABNORM) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_SPIOVR) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_CLSERR) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_DRWNNG) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_RSVERR) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_TPAOVR) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_DIPERR) |	\
+	MASK_FOR_BIT(INT_BIT_SPX_CALERR))
+
+#define INT_BIT_SPX_SPF 31
+
+#define INT_BIT_STX_CALPAR0 0
+#define INT_BIT_STX_CALPAR1 1
+#define INT_BIT_STX_OVRBST 2
+#define INT_BIT_STX_DATOVR 3
+#define INT_BIT_STX_DIPERR 4
+#define INT_BIT_STX_NOSYNC 5
+#define INT_BIT_STX_UNXFRM 6
+#define INT_BIT_STX_FRMERR 7
+#define INT_BIT_STX_SYNCERR 8
+#define STX_MASK (					\
+		MASK_FOR_BIT(INT_BIT_STX_CALPAR0) |	\
+		MASK_FOR_BIT(INT_BIT_STX_CALPAR1) |	\
+		MASK_FOR_BIT(INT_BIT_STX_OVRBST) |	\
+		MASK_FOR_BIT(INT_BIT_STX_DATOVR) |	\
+		MASK_FOR_BIT(INT_BIT_STX_DIPERR) |	\
+		MASK_FOR_BIT(INT_BIT_STX_NOSYNC) |	\
+		MASK_FOR_BIT(INT_BIT_STX_UNXFRM) |	\
+		MASK_FOR_BIT(INT_BIT_STX_FRMERR) |	\
+		MASK_FOR_BIT(INT_BIT_STX_SYNCERR))
+
 static int need_retrain[2] = { 0, 0 };
 
-static irqreturn_t cvm_oct_spi_rml_interrupt(int cpl, void *dev_id)
+static int cvm_oct_spi_hw_status(struct notifier_block *nb, unsigned long val, void *v)
 {
-	irqreturn_t return_status = IRQ_NONE;
-	union cvmx_npi_rsl_int_blocks rsl_int_blocks;
-
-	/* Check and see if this interrupt was caused by the GMX block */
-	rsl_int_blocks.u64 = cvmx_read_csr(CVMX_NPI_RSL_INT_BLOCKS);
-	if (rsl_int_blocks.s.spx1) {	/* 19 - SPX1_INT_REG & STX1_INT_REG */
-		union cvmx_spxx_int_reg spx_int_reg;
-		union cvmx_stxx_int_reg stx_int_reg;
-
-		spx_int_reg.u64 = cvmx_read_csr(CVMX_SPXX_INT_REG(1));
-		cvmx_write_csr(CVMX_SPXX_INT_REG(1), spx_int_reg.u64);
-		if (!need_retrain[1]) {
-			spx_int_reg.u64 &= cvmx_read_csr(CVMX_SPXX_INT_MSK(1));
-			if (spx_int_reg.s.spf)
-				pr_err("SPI1: SRX Spi4 interface down\n");
-			if (spx_int_reg.s.calerr)
-				pr_err("SPI1: SRX Spi4 Calendar table parity error\n");
-			if (spx_int_reg.s.syncerr)
-				pr_err("SPI1: SRX Consecutive Spi4 DIP4 errors have exceeded SPX_ERR_CTL[ERRCNT]\n");
-			if (spx_int_reg.s.diperr)
-				pr_err("SPI1: SRX Spi4 DIP4 error\n");
-			if (spx_int_reg.s.tpaovr)
-				pr_err("SPI1: SRX Selected port has hit TPA overflow\n");
-			if (spx_int_reg.s.rsverr)
-				pr_err("SPI1: SRX Spi4 reserved control word detected\n");
-			if (spx_int_reg.s.drwnng)
-				pr_err("SPI1: SRX Spi4 receive FIFO drowning/overflow\n");
-			if (spx_int_reg.s.clserr)
-				pr_err("SPI1: SRX Spi4 packet closed on non-16B alignment without EOP\n");
-			if (spx_int_reg.s.spiovr)
-				pr_err("SPI1: SRX Spi4 async FIFO overflow\n");
-			if (spx_int_reg.s.abnorm)
-				pr_err("SPI1: SRX Abnormal packet termination (ERR bit)\n");
-			if (spx_int_reg.s.prtnxa)
-				pr_err("SPI1: SRX Port out of range\n");
+	struct octeon_ethernet *priv = container_of(nb, struct octeon_ethernet, hw_status_notifier);
+
+	if (val == OCTEON_HW_STATUS_SOURCE_ASSERTED) {
+		struct octeon_hw_status_data *d = v;
+		if (d->reg == CVMX_SPXX_INT_REG(priv->interface) ||
+		    d->reg == CVMX_STXX_INT_REG(priv->interface)) {
+			if (need_retrain[priv->interface])
+				return NOTIFY_STOP;
+			need_retrain[priv->interface] = 1;
+			octeon_hw_status_disable(CVMX_SPXX_INT_REG(priv->interface), SPX_MASK);
+			octeon_hw_status_disable(CVMX_STXX_INT_REG(priv->interface), STX_MASK);
 		}
-
-		stx_int_reg.u64 = cvmx_read_csr(CVMX_STXX_INT_REG(1));
-		cvmx_write_csr(CVMX_STXX_INT_REG(1), stx_int_reg.u64);
-		if (!need_retrain[1]) {
-			stx_int_reg.u64 &= cvmx_read_csr(CVMX_STXX_INT_MSK(1));
-			if (stx_int_reg.s.syncerr)
-				pr_err("SPI1: STX Interface encountered a fatal error\n");
-			if (stx_int_reg.s.frmerr)
-				pr_err("SPI1: STX FRMCNT has exceeded STX_DIP_CNT[MAXFRM]\n");
-			if (stx_int_reg.s.unxfrm)
-				pr_err("SPI1: STX Unexpected framing sequence\n");
-			if (stx_int_reg.s.nosync)
-				pr_err("SPI1: STX ERRCNT has exceeded STX_DIP_CNT[MAXDIP]\n");
-			if (stx_int_reg.s.diperr)
-				pr_err("SPI1: STX DIP2 error on the Spi4 Status channel\n");
-			if (stx_int_reg.s.datovr)
-				pr_err("SPI1: STX Spi4 FIFO overflow error\n");
-			if (stx_int_reg.s.ovrbst)
-				pr_err("SPI1: STX Transmit packet burst too big\n");
-			if (stx_int_reg.s.calpar1)
-				pr_err("SPI1: STX Calendar Table Parity Error Bank1\n");
-			if (stx_int_reg.s.calpar0)
-				pr_err("SPI1: STX Calendar Table Parity Error Bank0\n");
-		}
-
-		cvmx_write_csr(CVMX_SPXX_INT_MSK(1), 0);
-		cvmx_write_csr(CVMX_STXX_INT_MSK(1), 0);
-		need_retrain[1] = 1;
-		return_status = IRQ_HANDLED;
 	}
-
-	if (rsl_int_blocks.s.spx0) {	/* 18 - SPX0_INT_REG & STX0_INT_REG */
-		union cvmx_spxx_int_reg spx_int_reg;
-		union cvmx_stxx_int_reg stx_int_reg;
-
-		spx_int_reg.u64 = cvmx_read_csr(CVMX_SPXX_INT_REG(0));
-		cvmx_write_csr(CVMX_SPXX_INT_REG(0), spx_int_reg.u64);
-		if (!need_retrain[0]) {
-			spx_int_reg.u64 &= cvmx_read_csr(CVMX_SPXX_INT_MSK(0));
-			if (spx_int_reg.s.spf)
-				pr_err("SPI0: SRX Spi4 interface down\n");
-			if (spx_int_reg.s.calerr)
-				pr_err("SPI0: SRX Spi4 Calendar table parity error\n");
-			if (spx_int_reg.s.syncerr)
-				pr_err("SPI0: SRX Consecutive Spi4 DIP4 errors have exceeded SPX_ERR_CTL[ERRCNT]\n");
-			if (spx_int_reg.s.diperr)
-				pr_err("SPI0: SRX Spi4 DIP4 error\n");
-			if (spx_int_reg.s.tpaovr)
-				pr_err("SPI0: SRX Selected port has hit TPA overflow\n");
-			if (spx_int_reg.s.rsverr)
-				pr_err("SPI0: SRX Spi4 reserved control word detected\n");
-			if (spx_int_reg.s.drwnng)
-				pr_err("SPI0: SRX Spi4 receive FIFO drowning/overflow\n");
-			if (spx_int_reg.s.clserr)
-				pr_err("SPI0: SRX Spi4 packet closed on non-16B alignment without EOP\n");
-			if (spx_int_reg.s.spiovr)
-				pr_err("SPI0: SRX Spi4 async FIFO overflow\n");
-			if (spx_int_reg.s.abnorm)
-				pr_err("SPI0: SRX Abnormal packet termination (ERR bit)\n");
-			if (spx_int_reg.s.prtnxa)
-				pr_err("SPI0: SRX Port out of range\n");
-		}
-
-		stx_int_reg.u64 = cvmx_read_csr(CVMX_STXX_INT_REG(0));
-		cvmx_write_csr(CVMX_STXX_INT_REG(0), stx_int_reg.u64);
-		if (!need_retrain[0]) {
-			stx_int_reg.u64 &= cvmx_read_csr(CVMX_STXX_INT_MSK(0));
-			if (stx_int_reg.s.syncerr)
-				pr_err("SPI0: STX Interface encountered a fatal error\n");
-			if (stx_int_reg.s.frmerr)
-				pr_err("SPI0: STX FRMCNT has exceeded STX_DIP_CNT[MAXFRM]\n");
-			if (stx_int_reg.s.unxfrm)
-				pr_err("SPI0: STX Unexpected framing sequence\n");
-			if (stx_int_reg.s.nosync)
-				pr_err("SPI0: STX ERRCNT has exceeded STX_DIP_CNT[MAXDIP]\n");
-			if (stx_int_reg.s.diperr)
-				pr_err("SPI0: STX DIP2 error on the Spi4 Status channel\n");
-			if (stx_int_reg.s.datovr)
-				pr_err("SPI0: STX Spi4 FIFO overflow error\n");
-			if (stx_int_reg.s.ovrbst)
-				pr_err("SPI0: STX Transmit packet burst too big\n");
-			if (stx_int_reg.s.calpar1)
-				pr_err("SPI0: STX Calendar Table Parity Error Bank1\n");
-			if (stx_int_reg.s.calpar0)
-				pr_err("SPI0: STX Calendar Table Parity Error Bank0\n");
-		}
-
-		cvmx_write_csr(CVMX_SPXX_INT_MSK(0), 0);
-		cvmx_write_csr(CVMX_STXX_INT_MSK(0), 0);
-		need_retrain[0] = 1;
-		return_status = IRQ_HANDLED;
-	}
-
-	return return_status;
-}
-
-static void cvm_oct_spi_enable_error_reporting(int interface)
-{
-	union cvmx_spxx_int_msk spxx_int_msk;
-	union cvmx_stxx_int_msk stxx_int_msk;
-
-	spxx_int_msk.u64 = cvmx_read_csr(CVMX_SPXX_INT_MSK(interface));
-	spxx_int_msk.s.calerr = 1;
-	spxx_int_msk.s.syncerr = 1;
-	spxx_int_msk.s.diperr = 1;
-	spxx_int_msk.s.tpaovr = 1;
-	spxx_int_msk.s.rsverr = 1;
-	spxx_int_msk.s.drwnng = 1;
-	spxx_int_msk.s.clserr = 1;
-	spxx_int_msk.s.spiovr = 1;
-	spxx_int_msk.s.abnorm = 1;
-	spxx_int_msk.s.prtnxa = 1;
-	cvmx_write_csr(CVMX_SPXX_INT_MSK(interface), spxx_int_msk.u64);
-
-	stxx_int_msk.u64 = cvmx_read_csr(CVMX_STXX_INT_MSK(interface));
-	stxx_int_msk.s.frmerr = 1;
-	stxx_int_msk.s.unxfrm = 1;
-	stxx_int_msk.s.nosync = 1;
-	stxx_int_msk.s.diperr = 1;
-	stxx_int_msk.s.datovr = 1;
-	stxx_int_msk.s.ovrbst = 1;
-	stxx_int_msk.s.calpar1 = 1;
-	stxx_int_msk.s.calpar0 = 1;
-	cvmx_write_csr(CVMX_STXX_INT_MSK(interface), stxx_int_msk.u64);
+	return NOTIFY_DONE;
 }
-
 static void cvm_oct_spi_poll(struct net_device *dev)
 {
 	static int spi4000_port;
@@ -215,10 +114,10 @@ static void cvm_oct_spi_poll(struct net_device *dev)
 
 	for (interface = 0; interface < 2; interface++) {
 		if ((priv->ipd_port == interface * 16) && need_retrain[interface]) {
-			if (cvmx_spi_restart_interface
-			    (interface, CVMX_SPI_MODE_DUPLEX, 10) == 0) {
+			if (cvmx_spi_restart_interface(interface, CVMX_SPI_MODE_DUPLEX, 10) == 0) {
 				need_retrain[interface] = 0;
-				cvm_oct_spi_enable_error_reporting(interface);
+				octeon_hw_status_enable(CVMX_SPXX_INT_REG(priv->interface), SPX_MASK);
+				octeon_hw_status_enable(CVMX_STXX_INT_REG(priv->interface), STX_MASK);
 			}
 		}
 
@@ -246,22 +145,55 @@ static void cvm_oct_spi_poll(struct net_device *dev)
 
 int cvm_oct_spi_init(struct net_device *dev)
 {
-	int r;
+	int r, i;
+	struct octeon_hw_status_reg sr[3];
 	struct octeon_ethernet *priv = netdev_priv(dev);
 
-	if (number_spi_ports == 0) {
-		r = request_irq(OCTEON_IRQ_RML, cvm_oct_spi_rml_interrupt,
-				IRQF_SHARED, "SPI", &number_spi_ports);
-		if (r) {
-			netdev_err(dev, "request_irq(%d) failed\n",
-				   OCTEON_IRQ_RML);
+	if ((priv->ipd_port == 0) || (priv->ipd_port == 16)) {
+
+		priv->hw_status_notifier.priority = 1;
+		priv->hw_status_notifier.notifier_call = cvm_oct_spi_hw_status;
+		r = octeon_hw_status_notifier_register(&priv->hw_status_notifier);
+		if (r)
 			return r;
+
+		memset(sr, 0, sizeof(sr));
+		sr[0].reg = 46; /* RML */
+		sr[0].reg_is_hwint = 1;
+		sr[0].has_child = 1;
+
+		sr[1].reg = CVMX_NPI_RSL_INT_BLOCKS;
+		sr[1].bit = priv->interface + 18;
+		sr[1].has_child = 1;
+
+		sr[2].reg = CVMX_SPXX_INT_REG(priv->interface);
+		sr[2].mask_reg = CVMX_SPXX_INT_MSK(priv->interface);
+		sr[2].ack_w1c = 1;
+
+		for (i = 0; i < 32; i++) {
+			if ((1ull << i) & SPX_MASK) {
+				sr[2].bit = i;
+				octeon_hw_status_add_source(sr);
+			}
 		}
-	}
-	number_spi_ports++;
 
-	if ((priv->ipd_port == 0) || (priv->ipd_port == 16)) {
-		cvm_oct_spi_enable_error_reporting(priv->interface);
+		sr[2].bit = INT_BIT_SPX_SPF;
+		sr[2].ack_w1c = 0;
+		octeon_hw_status_add_source(sr);
+		octeon_hw_status_enable(sr[2].reg, SPX_MASK);
+
+		sr[2].reg = CVMX_STXX_INT_REG(priv->interface);
+		sr[2].mask_reg = CVMX_STXX_INT_MSK(priv->interface);
+		sr[2].ack_w1c = 1;
+
+		for (i = 0; i < 32; i++) {
+			if ((1ull << i) & STX_MASK) {
+				sr[2].bit = i;
+				octeon_hw_status_add_source(sr);
+			}
+		}
+		octeon_hw_status_enable(sr[2].reg, STX_MASK);
+
 		priv->poll = cvm_oct_spi_poll;
 	}
 	cvm_oct_common_init(dev);
@@ -270,14 +202,38 @@ int cvm_oct_spi_init(struct net_device *dev)
 
 void cvm_oct_spi_uninit(struct net_device *dev)
 {
-	int interface;
+	int i;
+	struct octeon_ethernet *priv = netdev_priv(dev);
+
+	if (priv->hw_status_notifier.notifier_call) {
+		struct octeon_hw_status_reg sr;
+		memset(&sr, 0, sizeof(sr));
 
-	number_spi_ports--;
-	if (number_spi_ports == 0) {
-		for (interface = 0; interface < 2; interface++) {
-			cvmx_write_csr(CVMX_SPXX_INT_MSK(interface), 0);
-			cvmx_write_csr(CVMX_STXX_INT_MSK(interface), 0);
+		sr.reg = CVMX_SPXX_INT_REG(priv->interface);
+		sr.mask_reg = CVMX_SPXX_INT_MSK(priv->interface);
+		sr.ack_w1c = 1;
+
+		for (i = 0; i < 32; i++) {
+			if ((1ull << i) & SPX_MASK) {
+				sr.bit = i;
+				octeon_hw_status_remove_source(&sr);
+			}
 		}
-		free_irq(OCTEON_IRQ_RML, &number_spi_ports);
+		sr.bit = INT_BIT_SPX_SPF;
+		sr.ack_w1c = 0;
+		octeon_hw_status_remove_source(&sr);
+
+		sr.reg = CVMX_STXX_INT_REG(priv->interface);
+		sr.mask_reg = CVMX_STXX_INT_MSK(priv->interface);
+		sr.ack_w1c = 1;
+		for (i = 0; i < 32; i++) {
+			if ((1ull << i) & STX_MASK) {
+				sr.bit = i;
+				octeon_hw_status_remove_source(&sr);
+			}
+		}
+
+		octeon_hw_status_notifier_unregister(&priv->hw_status_notifier);
+		priv->hw_status_notifier.notifier_call = NULL;
 	}
 }
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index 4eb5c27..a1f0f97 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -96,6 +96,7 @@ struct octeon_ethernet {
 	u64 last_tx_octets;
 	u32 last_tx_packets;
 	struct list_head srio_bcast;
+	struct notifier_block	hw_status_notifier;
 };
 
 struct octeon_ethernet_srio_bcast_target {
-- 
1.7.5.4

