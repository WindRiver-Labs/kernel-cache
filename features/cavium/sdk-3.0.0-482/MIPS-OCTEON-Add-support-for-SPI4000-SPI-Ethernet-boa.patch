From 8134f94ae58f7eb165e819e701e3d31dcac0e057 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 26 Nov 2012 13:58:43 -0800
Subject: [PATCH 236/337] MIPS: OCTEON: Add support for SPI4000
 SPI<-->Ethernet board.

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile         |    5 +-
 .../mips/cavium-octeon/executive/cvmx-helper-spi.c |   22 +-
 arch/mips/cavium-octeon/executive/cvmx-spi4000.c   |  476 ++++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-spi.h            |   89 ++---
 4 files changed, 521 insertions(+), 71 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-spi4000.c

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index ad5d542..06dcd92 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -10,8 +10,8 @@
 #
 
 obj-y += cvmx-bootmem.o cvmx-l2c.o cvmx-sysinfo.o octeon-model.o
-obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-ipd.o \
-	cvmx-ilk.o cvmx-srio.o cvmx-qlm.o cvmx-qlm-tables.o
+obj-y += cvmx-pko.o cvmx-spi.o cvmx-spi4000.o cvmx-cmd-queue.o cvmx-ipd.o \
+	cvmx-ilk.o cvmx-srio.o cvmx-qlm.o cvmx-qlm-tables.o cvmx-twsi.o
 
 
 obj-y += cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
@@ -27,4 +27,3 @@ obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 obj-$(CONFIG_USB_OCTEON_HCD) += cvmx-usb.o
 obj-$(CONFIG_CAVIUM_OCTEON_RAPIDIO) += cvmx-dma-engine.o
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)	+= cvmx-nand.o
-obj-$(CONFIG_CAVIUM_OCTEON_EXECUTIVE_TWSI) += cvmx-twsi.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
index 16c9bc2..ecc19a4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
@@ -29,22 +29,14 @@
  * Functions for SPI initialization, configuration,
  * and monitoring.
  */
+#include <linux/export.h>
+
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-spi.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-pko-defs.h>
 #include <asm/octeon/cvmx-pip-defs.h>
 
-
-/*
- * CVMX_HELPER_SPI_TIMEOUT is used to determine how long the SPI
- * initialization routines wait for SPI training. You can override the
- * value using executive-config.h if necessary.
- */
-#ifndef CVMX_HELPER_SPI_TIMEOUT
-#define CVMX_HELPER_SPI_TIMEOUT 10
-#endif
-
 int __cvmx_helper_spi_enumerate(int interface)
 {
 	if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
@@ -83,6 +75,13 @@ int __cvmx_helper_spi_probe(int interface)
 	return num_ports;
 }
 
+static int cvmx_spi_timeout = 10;
+void cvmx_spi_config_set_timeout(int timeout)
+{
+	cvmx_spi_timeout = timeout;
+}
+EXPORT_SYMBOL(cvmx_spi_config_set_timeout);
+
 /**
  * Bringup and enable a SPI interface. After this call packet I/O
  * should be fully functional. This is called with IPD enabled but
@@ -111,7 +110,7 @@ int __cvmx_helper_spi_enable(int interface)
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		cvmx_spi_start_interface(interface, CVMX_SPI_MODE_DUPLEX,
-					 CVMX_HELPER_SPI_TIMEOUT, num_ports);
+					 cvmx_spi_timeout, num_ports);
 		if (cvmx_spi4000_is_present(interface))
 			cvmx_spi4000_initialize(interface);
 	}
@@ -119,6 +118,7 @@ int __cvmx_helper_spi_enable(int interface)
 }
 
 /**
+ * @INTERNAL
  * Return the link state of an IPD/PKO port as returned by
  * auto negotiation. The result of this function may not match
  * Octeon's link config if auto negotiation has changed since
diff --git a/arch/mips/cavium-octeon/executive/cvmx-spi4000.c b/arch/mips/cavium-octeon/executive/cvmx-spi4000.c
new file mode 100644
index 0000000..07c47e3
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-spi4000.c
@@ -0,0 +1,476 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/*
+ * Support library for the SPI4000 card
+ */
+#include <linux/export.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-spi.h>
+#include <asm/octeon/cvmx-twsi.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+
+/* If someone is using an old config, make the SPI4000 act like RGMII for backpressure */
+#ifndef CVMX_HELPER_DISABLE_SPI4000_BACKPRESSURE
+#ifndef CVMX_HELPER_DISABLE_RGMII_BACKPRESSURE
+#define CVMX_HELPER_DISABLE_RGMII_BACKPRESSURE 0
+#endif
+#define CVMX_HELPER_DISABLE_SPI4000_BACKPRESSURE CVMX_HELPER_DISABLE_RGMII_BACKPRESSURE
+#endif
+
+#define SPI4000_READ_ADDRESS_HIGH   0xf0
+#define SPI4000_READ_ADDRESS_LOW    0xf1
+#define SPI4000_WRITE_ADDRESS_HIGH  0xf2
+#define SPI4000_WRITE_ADDRESS_LOW   0xf3
+#define SPI4000_READ_DATA0          0xf4	/* High byte */
+#define SPI4000_READ_DATA1          0xf5
+#define SPI4000_READ_DATA2          0xf6
+#define SPI4000_READ_DATA3          0xf7	/* Low byte */
+#define SPI4000_WRITE_DATA0         0xf8	/* High byte */
+#define SPI4000_WRITE_DATA1         0xf9
+#define SPI4000_WRITE_DATA2         0xfa
+#define SPI4000_WRITE_DATA3         0xfb	/* Low byte */
+#define SPI4000_DO_READ             0xfc	/* Issue a read, returns read status */
+#define SPI4000_GET_READ_STATUS     0xfd	/* 0xff: initial state, 2: Read failed, 1: Read pending, 0: Read success */
+#define SPI4000_DO_WRITE            0xfe	/* Issue a write, returns write status */
+#define SPI4000_GET_WRITE_STATUS    0xff	/* 0xff: initial state, 6: Write failed, 5: Write pending, 4: Write success */
+#define SPI4000_TWSI_ID(interface)  (0x66 + interface)
+
+/* MDI Single Command (register 0x680) */
+typedef union {
+	uint32_t u32;
+	struct {
+		uint32_t reserved_21_31:11;
+		uint32_t mdi_command:1;	 /**< Performs an MDIO access. When set, this bit
+                                            self clears upon completion of the access. */
+		uint32_t reserved_18_19:2;
+		uint32_t op_code:2;	 /**< MDIO Op Code
+                                            00 = Reserved
+                                            01 = Write Access
+                                            10 = Read Access
+                                            11 = Reserved */
+		uint32_t reserved_13_15:3;
+		uint32_t phy_address:5;	 /**< Address of external PHY device */
+		uint32_t reserved_5_7:3;
+		uint32_t reg_address:5;	 /**< Address of register within external PHY */
+	} s;
+} mdio_single_command_t;
+
+static int interface_is_spi4000[2] = { 0, 0 };
+
+/**
+ * @INTERNAL
+ * Write data to the specified SPI4000 address
+ *
+ * @interface: Interface the SPI4000 is on. (0 or 1)
+ * @address:   Address to write to
+ * @data:      Data to write
+ */
+static void __cvmx_spi4000_write(int interface, int address, uint32_t data)
+{
+	int status;
+	cvmx_twsix_write_ia(0, SPI4000_TWSI_ID(interface), SPI4000_WRITE_ADDRESS_HIGH, 2, 1, address);
+	cvmx_twsix_write_ia(0, SPI4000_TWSI_ID(interface), SPI4000_WRITE_DATA0, 4, 1, data);
+
+	status = cvmx_twsi_read8(SPI4000_TWSI_ID(interface), SPI4000_DO_WRITE);
+	while ((status == 5) || (status == 0xff))
+		status = cvmx_twsi_read8(SPI4000_TWSI_ID(interface), SPI4000_GET_WRITE_STATUS);
+
+	if (status != 4)
+		cvmx_dprintf("SPI4000: write failed with status=0x%x\n", status);
+}
+
+/**
+ * @INTERNAL
+ * Read data from the SPI4000.
+ *
+ * @interface: Interface the SPI4000 is on. (0 or 1)
+ * @address:   Address to read from
+ *
+ * Returns Value at the specified address
+ */
+static uint32_t __cvmx_spi4000_read(int interface, int address)
+{
+	int status;
+	uint64_t data;
+
+	cvmx_twsix_write_ia(0, SPI4000_TWSI_ID(interface), SPI4000_READ_ADDRESS_HIGH, 2, 1, address);
+
+	status = cvmx_twsi_read8(SPI4000_TWSI_ID(interface), SPI4000_DO_READ);
+	while ((status == 1) || (status == 0xff))
+		status = cvmx_twsi_read8(SPI4000_TWSI_ID(interface), SPI4000_GET_READ_STATUS);
+
+	if (status) {
+		cvmx_dprintf("SPI4000: read failed with %d\n", status);
+		return 0;
+	}
+
+	status = cvmx_twsix_read_ia(0, SPI4000_TWSI_ID(interface), SPI4000_READ_DATA0, 4, 1, &data);
+	if (status != 4) {
+		cvmx_dprintf("SPI4000: read failed with %d\n", status);
+		return 0;
+	}
+
+	return data;
+}
+
+/**
+ * @INTERNAL
+ * Write to a PHY using MDIO on the SPI4000
+ *
+ * @interface: Interface the SPI4000 is on. (0 or 1)
+ * @port:      SPI4000 RGMII port to write to. (0-9)
+ * @location:  MDIO register to write
+ * @val:       Value to write
+ */
+static void __cvmx_spi4000_mdio_write(int interface, int port, int location, int val)
+{
+	static int last_value = -1;
+	mdio_single_command_t mdio;
+
+	mdio.u32 = 0;
+	mdio.s.mdi_command = 1;
+	mdio.s.op_code = 1;
+	mdio.s.phy_address = port;
+	mdio.s.reg_address = location;
+
+	/* Since the TWSI accesses are very slow, don't update the write value
+	   if it is the same as the last value */
+	if (val != last_value) {
+		last_value = val;
+		__cvmx_spi4000_write(interface, 0x0681, val);
+	}
+
+	__cvmx_spi4000_write(interface, 0x0680, mdio.u32);
+}
+
+/**
+ * @INTERNAL
+ * Read from a PHY using MDIO on the SPI4000
+ *
+ * @interface: Interface the SPI4000 is on. (0 or 1)
+ * @port:      SPI4000 RGMII port to read from. (0-9)
+ * @location:  MDIO register to read
+ * Returns The MDI read result
+ */
+static int __cvmx_spi4000_mdio_read(int interface, int port, int location)
+{
+	mdio_single_command_t mdio;
+
+	mdio.u32 = 0;
+	mdio.s.mdi_command = 1;
+	mdio.s.op_code = 2;
+	mdio.s.phy_address = port;
+	mdio.s.reg_address = location;
+	__cvmx_spi4000_write(interface, 0x0680, mdio.u32);
+
+	do {
+		mdio.u32 = __cvmx_spi4000_read(interface, 0x0680);
+	} while (mdio.s.mdi_command);
+
+	return __cvmx_spi4000_read(interface, 0x0681) >> 16;
+}
+
+/**
+ * @INTERNAL
+ * Configure the SPI4000 MACs
+ */
+static void __cvmx_spi4000_configure_mac(int interface)
+{
+	int port;
+	// IXF1010 configuration
+	// ---------------------
+	//
+	// Step 1: Apply soft reset to TxFIFO and MAC
+	//         MAC soft reset register. address=0x505
+	//         TxFIFO soft reset. address=0x620
+	__cvmx_spi4000_write(interface, 0x0505, 0x3ff);	// reset all the MACs
+	__cvmx_spi4000_write(interface, 0x0620, 0x3ff);	// reset the TX FIFOs
+
+	//         Global address and Configuration Register. address=0x500
+	//
+	// Step 2: Apply soft reset to RxFIFO and SPI.
+	__cvmx_spi4000_write(interface, 0x059e, 0x3ff);	// reset the RX FIFOs
+
+	// Step 3a: Take the MAC out of softreset
+	//          MAC soft reset register. address=0x505
+	__cvmx_spi4000_write(interface, 0x0505, 0x0);	// reset all the MACs
+
+	// Step 3b: De-assert port enables.
+	//          Global address and Configuration Register. address=0x500
+	__cvmx_spi4000_write(interface, 0x0500, 0x0);	// disable all ports
+
+	// Step 4: Assert Clock mode change En.
+	//         Clock and interface mode Change En. address=Serdes base + 0x14
+	//         Serdes (Serializer/de-serializer). address=0x780
+	//         [Can't find this one]
+
+	for (port = 0; port < 10; port++) {
+		int port_offset = port << 7;
+
+		// Step 5: Set MAC interface mode GMII speed.
+		//         MAC interface mode and RGMII speed register.
+		//             address=port_index+0x10
+		//
+		//         OUT port_index+0x10, 0x07     //RGMII 1000 Mbps operation.
+		__cvmx_spi4000_write(interface, port_offset | 0x0010, 0x3);
+
+		// Set the max packet size to 16383 bytes, including the CRC
+		__cvmx_spi4000_write(interface, port_offset | 0x000f, 0x3fff);
+
+		// Step 6: Change Interface to Copper mode
+		//         Interface mode register. address=0x501
+		//         [Can't find this]
+
+		// Step 7: MAC configuration
+		//         Station address configuration.
+		//         Source MAC address low register. Source MAC address 31-0.
+		//             address=port_index+0x00
+		//         Source MAC address high register. Source MAC address 47-32.
+		//             address=port_index+0x01
+		//         where Port index is 0x0 to 0x5.
+		//         This address is inserted in the source address filed when
+		//         transmitting pause frames, and is also used to compare against
+		//         unicast pause frames at the receiving side.
+		//
+		//         OUT port_index+0x00, source MAC address low.
+		__cvmx_spi4000_write(interface, port_offset | 0x0000, 0x0000);
+		//         OUT port_index+0x01, source MAC address high.
+		__cvmx_spi4000_write(interface, port_offset | 0x0001, 0x0000);
+
+		// Step 8: Set desired duplex mode
+		//         Desired duplex register. address=port_index+0x02
+		//         [Reserved]
+
+		// Step 9: Other configuration.
+		//         FC Enable Register.             address=port_index+0x12
+		//         Discard Unknown Control Frame.  address=port_index+0x15
+		//         Diverse config write register.  address=port_index+0x18
+		//         RX Packet Filter register.      address=port_index+0x19
+		//
+		// Step 9a: Tx FD FC Enabled / Rx FD FC Enabled
+		if (CVMX_HELPER_DISABLE_SPI4000_BACKPRESSURE)
+			__cvmx_spi4000_write(interface, port_offset | 0x0012, 0);
+		else
+			__cvmx_spi4000_write(interface, port_offset | 0x0012, 0x7);
+
+		// Step 9b: Discard unknown control frames
+		__cvmx_spi4000_write(interface, port_offset | 0x0015, 0x1);
+
+		// Step 9c: Enable auto-CRC and auto-padding
+		__cvmx_spi4000_write(interface, port_offset | 0x0018, 0x11cd);	//??
+
+		// Step 9d: Drop bad CRC / Drop Pause / No DAF
+		__cvmx_spi4000_write(interface, port_offset | 0x0019, 0x00);
+	}
+
+	// Step 9d: Drop frames
+	__cvmx_spi4000_write(interface, 0x059f, 0x03ff);
+
+	for (port = 0; port < 10; port++) {
+		// Step 9e: Set the TX FIFO marks
+		__cvmx_spi4000_write(interface, port + 0x0600, 0x0900);	// TXFIFO High watermark
+		__cvmx_spi4000_write(interface, port + 0x060a, 0x0800);	// TXFIFO Low watermark
+		__cvmx_spi4000_write(interface, port + 0x0614, 0x0380);	// TXFIFO threshold
+	}
+
+	// Step 12: De-assert RxFIFO and SPI Rx/Tx reset
+	__cvmx_spi4000_write(interface, 0x059e, 0x0);	// reset the RX FIFOs
+
+	// Step 13: De-assert TxFIFO and MAC reset
+	__cvmx_spi4000_write(interface, 0x0620, 0x0);	// reset the TX FIFOs
+
+	// Step 14: Assert port enable
+	//          Global address and Configuration Register. address=0x500
+	__cvmx_spi4000_write(interface, 0x0500, 0x03ff);	// enable all ports
+
+	// Step 15: Disable loopback
+	//          [Can't find this one]
+}
+
+/**
+ * @INTERNAL
+ * Configure the SPI4000 PHYs
+ */
+static void __cvmx_spi4000_configure_phy(int interface)
+{
+	int port;
+
+	/* We use separate loops below since it allows us to save a write
+	   to the SPI4000 for each repeated value. This adds up to a couple
+	   of seconds */
+
+	/* Update the link state before resets. It takes a while for the links to
+	   come back after the resets. Most likely they'll come back the same as
+	   they are now */
+	for (port = 0; port < 10; port++)
+		cvmx_spi4000_check_speed(interface, port);
+	/* Enable RGMII DELAYS for TX_CLK and RX_CLK (see spec) */
+	for (port = 0; port < 10; port++)
+		__cvmx_spi4000_mdio_write(interface, port, 0x14, 0x00e2);
+	/* Advertise pause and 100 Full Duplex. Don't advertise half duplex or 10Mbpa */
+	for (port = 0; port < 10; port++)
+		__cvmx_spi4000_mdio_write(interface, port, 0x4, 0x0d01);
+	/* Enable PHY reset */
+	for (port = 0; port < 10; port++)
+		__cvmx_spi4000_mdio_write(interface, port, 0x0, 0x9140);
+}
+
+/**
+ * Poll all the SPI4000 port and check its speed
+ *
+ * @interface: Interface the SPI4000 is on
+ * @port:      Port to poll (0-9)
+ * Returns Status of the port. 0=down. All other values the port is up.
+ */
+union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(int interface, int port)
+{
+	static int phy_status[10] = { 0, };
+	union cvmx_gmxx_rxx_rx_inbnd link;
+	int read_status;
+
+	link.u64 = 0;
+
+	if (!interface_is_spi4000[interface])
+		return link;
+	if (port >= 10)
+		return link;
+
+	/* Register 0x11: PHY Specific Status Register
+	   Register   Function         Setting                     Mode   HW Rst SW Rst Notes
+	   RO     00     Retain note
+	   17.15:14   Speed            11 = Reserved
+	   17.a
+	   10 = 1000 Mbps
+	   01 = 100 Mbps
+	   00 = 10 Mbps
+	   17.13      Duplex           1 = Full-duplex             RO     0      Retain note
+	   0 = Half-duplex                                  17.a
+	   17.12      Page Received    1 = Page received           RO, LH 0      0
+	   0 = Page not received
+	   1 = Resolved                RO     0      0      note
+	   17.11      Speed and
+	   0 = Not resolved                                 17.a
+	   Duplex
+	   Resolved
+	   17.10      Link (real time) 1 = Link up                 RO     0      0
+	   0 = Link down
+	   RO     000    000    note
+	   000 = < 50m
+	   17.9:7     Cable Length
+	   001 = 50 - 80m                                   17.b
+	   (100/1000
+	   010 = 80 - 110m
+	   modes only)
+	   011 = 110 - 140m
+	   100 = >140m
+	   17.6       MDI Crossover    1 = MDIX                    RO     0      0      note
+	   Status           0 = MDI                                          17.a
+	   17.5       Downshift Sta-   1 = Downshift               RO     0      0
+	   tus              0 = No Downshift
+	   17.4       Energy Detect    1 = Sleep                   RO     0      0
+	   Status           0 = Active
+	   17.3       Transmit Pause   1 = Transmit pause enabled  RO     0      0      note17.
+	   Enabled          0 = Transmit pause disabled                      a, 17.c
+	   17.2       Receive Pause    1 = Receive pause enabled   RO     0      0      note17.
+	   Enabled          0 = Receive pause disabled                       a, 17.c
+	   17.1       Polarity (real   1 = Reversed                RO     0      0
+	   time)            0 = Normal
+	   17.0       Jabber (real     1 = Jabber                  RO     0      Retain
+	   time)            0 = No jabber
+	 */
+	read_status = __cvmx_spi4000_mdio_read(interface, port, 0x11);
+	if ((read_status & (1 << 10)) == 0)
+		read_status = 0;	/* If the link is down, force zero */
+	else
+		read_status &= 0xe400;	/* Strip off all the don't care bits */
+	if (read_status != phy_status[port]) {
+		phy_status[port] = read_status;
+		if (read_status & (1 << 10)) {
+			/* If the link is up, we need to set the speed based on the PHY status */
+			if (read_status & (1 << 15))
+				__cvmx_spi4000_write(interface, (port << 7) | 0x0010, 0x3);	/* 1Gbps */
+			else
+				__cvmx_spi4000_write(interface, (port << 7) | 0x0010, 0x1);	/* 100Mbps */
+		} else {
+			/* If the link is down, force 1Gbps so TX traffic dumps fast */
+			__cvmx_spi4000_write(interface, (port << 7) | 0x0010, 0x3);	/* 1Gbps */
+		}
+	}
+
+	if (read_status & (1 << 10)) {
+		link.s.status = 1;	/* Link up */
+		if (read_status & (1 << 15))
+			link.s.speed = 2;
+		else
+			link.s.speed = 1;
+	} else {
+		link.s.speed = 2;	/* Use 1Gbps when down */
+		link.s.status = 0;	/* Link Down */
+	}
+	link.s.duplex = ((read_status & (1 << 13)) != 0);
+
+	return link;
+}
+EXPORT_SYMBOL(cvmx_spi4000_check_speed);
+
+/**
+ * Return non-zero if the SPI interface has a SPI4000 attached
+ *
+ * @interface: SPI interface the SPI4000 is connected to
+ *
+ * Returns
+ */
+int cvmx_spi4000_is_present(int interface)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		return 0;
+	// Check for the presence of a SPI4000. If it isn't there,
+	// these writes will timeout.
+	if (cvmx_twsi_write8(SPI4000_TWSI_ID(interface), SPI4000_WRITE_ADDRESS_HIGH, 0))
+		return 0;
+	if (cvmx_twsi_write8(SPI4000_TWSI_ID(interface), SPI4000_WRITE_ADDRESS_LOW, 0))
+		return 0;
+	interface_is_spi4000[interface] = 1;
+	return 1;
+}
+
+/**
+ * Initialize the SPI4000 for use
+ *
+ * @interface: SPI interface the SPI4000 is connected to
+ */
+int cvmx_spi4000_initialize(int interface)
+{
+	if (!cvmx_spi4000_is_present(interface))
+		return -1;
+
+	__cvmx_spi4000_configure_mac(interface);
+	__cvmx_spi4000_configure_phy(interface);
+	return 0;
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-spi.h b/arch/mips/include/asm/octeon/cvmx-spi.h
index 015247ee..b7e557c 100644
--- a/arch/mips/include/asm/octeon/cvmx-spi.h
+++ b/arch/mips/include/asm/octeon/cvmx-spi.h
@@ -33,6 +33,9 @@
 
 #include "cvmx-gmxx-defs.h"
 
+
+/* CSR typedefs have been moved to cvmx-spi-defs.h */
+
 typedef enum {
 	CVMX_SPI_MODE_UNKNOWN = 0,
 	CVMX_SPI_MODE_TX_HALFPLEX = 1,
@@ -46,19 +49,16 @@ typedef struct {
 	int (*reset_cb) (int interface, cvmx_spi_mode_t mode);
 
     /** Called to setup calendar */
-	int (*calendar_setup_cb) (int interface, cvmx_spi_mode_t mode,
-				  int num_ports);
+	int (*calendar_setup_cb) (int interface, cvmx_spi_mode_t mode, int num_ports);
 
     /** Called for Tx and Rx clock detection */
-	int (*clock_detect_cb) (int interface, cvmx_spi_mode_t mode,
-				int timeout);
+	int (*clock_detect_cb) (int interface, cvmx_spi_mode_t mode, int timeout);
 
     /** Called to perform link training */
 	int (*training_cb) (int interface, cvmx_spi_mode_t mode, int timeout);
 
     /** Called for calendar data synchronization */
-	int (*calendar_sync_cb) (int interface, cvmx_spi_mode_t mode,
-				 int timeout);
+	int (*calendar_sync_cb) (int interface, cvmx_spi_mode_t mode, int timeout);
 
     /** Called when interface is up */
 	int (*interface_up_cb) (int interface, cvmx_spi_mode_t mode);
@@ -74,7 +74,7 @@ typedef struct {
 static inline int cvmx_spi_is_spi_interface(int interface)
 {
 	uint64_t gmxState = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
-	return (gmxState & 0x2) && (gmxState & 0x1);
+	return ((gmxState & 0x2) && (gmxState & 0x1));
 }
 
 /**
@@ -90,9 +90,7 @@ static inline int cvmx_spi_is_spi_interface(int interface)
  * @num_ports: Number of SPI ports to configure
  *
  * Returns Zero on success, negative of failure.
- */
-extern int cvmx_spi_start_interface(int interface, cvmx_spi_mode_t mode,
-				    int timeout, int num_ports);
+ */ extern int cvmx_spi_start_interface(int interface, cvmx_spi_mode_t mode, int timeout, int num_ports);
 
 /**
  * This routine restarts the SPI interface after it has lost synchronization
@@ -105,12 +103,9 @@ extern int cvmx_spi_start_interface(int interface, cvmx_spi_mode_t mode,
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
  * @timeout:   Timeout to wait for clock synchronization in seconds
- *
  * Returns Zero on success, negative of failure.
  */
-extern int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode,
-				      int timeout);
-
+extern int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode, int timeout);
 
 /**
  * Return non-zero if the SPI interface has a SPI4000 attached
@@ -119,20 +114,14 @@ extern int cvmx_spi_restart_interface(int interface, cvmx_spi_mode_t mode,
  *
  * Returns
  */
-static inline int cvmx_spi4000_is_present(int interface)
-{
-	return 0;
-}
+extern int cvmx_spi4000_is_present(int interface);
 
 /**
  * Initialize the SPI4000 for use
  *
  * @interface: SPI interface the SPI4000 is connected to
  */
-static inline int cvmx_spi4000_initialize(int interface)
-{
-	return -1;
-}
+extern int cvmx_spi4000_initialize(int interface);
 
 /**
  * Poll all the SPI4000 port and check its speed
@@ -141,12 +130,7 @@ static inline int cvmx_spi4000_initialize(int interface)
  * @port:      Port to poll (0-9)
  * Returns Status of the port. 0=down. All other values the port is up.
  */
-static inline union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(int interface, int port)
-{
-	union cvmx_gmxx_rxx_rx_inbnd r;
-	r.u64 = 0;
-	return r;
-}
+extern union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(int interface, int port);
 
 /**
  * Get current SPI4 initialization callbacks
@@ -155,14 +139,14 @@ static inline union cvmx_gmxx_rxx_rx_inbnd cvmx_spi4000_check_speed(int interfac
  *
  * Returns Pointer to cvmx_spi_callbacks_t structure.
  */
-extern void cvmx_spi_get_callbacks(cvmx_spi_callbacks_t *callbacks);
+extern void cvmx_spi_get_callbacks(cvmx_spi_callbacks_t * callbacks);
 
 /**
  * Set new SPI4 initialization callbacks
  *
  * @new_callbacks:  Pointer to an updated callbacks structure.
  */
-extern void cvmx_spi_set_callbacks(cvmx_spi_callbacks_t *new_callbacks);
+extern void cvmx_spi_set_callbacks(cvmx_spi_callbacks_t * new_callbacks);
 
 /**
  * Callback to perform SPI4 reset
@@ -173,15 +157,12 @@ extern void cvmx_spi_set_callbacks(cvmx_spi_callbacks_t *new_callbacks);
  *                  can operate as a full duplex (both Tx and Rx data paths
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
- *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
 extern int cvmx_spi_reset_cb(int interface, cvmx_spi_mode_t mode);
 
 /**
- * Callback to setup calendar and miscellaneous settings before clock
- * detection
+ * Callback to setup calendar and miscellaneous settings before clock detection
  *
  * @interface: The identifier of the packet interface to configure and
  *                  use as a SPI interface.
@@ -191,11 +172,9 @@ extern int cvmx_spi_reset_cb(int interface, cvmx_spi_mode_t mode);
  *                  active or the Rx data path is active, but not both).
  * @num_ports: Number of ports to configure on SPI
  *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
-extern int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode,
-				      int num_ports);
+extern int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode, int num_ports);
 
 /**
  * Callback to perform clock detection
@@ -207,12 +186,9 @@ extern int cvmx_spi_calendar_setup_cb(int interface, cvmx_spi_mode_t mode,
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
  * @timeout:   Timeout to wait for clock synchronization in seconds
- *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
-extern int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode,
-				    int timeout);
+extern int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode, int timeout);
 
 /**
  * Callback to perform link training
@@ -224,12 +200,9 @@ extern int cvmx_spi_clock_detect_cb(int interface, cvmx_spi_mode_t mode,
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
  * @timeout:   Timeout to wait for link to be trained (in seconds)
- *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
-extern int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode,
-				int timeout);
+extern int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode, int timeout);
 
 /**
  * Callback to perform calendar data synchronization
@@ -241,12 +214,9 @@ extern int cvmx_spi_training_cb(int interface, cvmx_spi_mode_t mode,
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
  * @timeout:   Timeout to wait for calendar data in seconds
- *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
-extern int cvmx_spi_calendar_sync_cb(int interface, cvmx_spi_mode_t mode,
-				     int timeout);
+extern int cvmx_spi_calendar_sync_cb(int interface, cvmx_spi_mode_t mode, int timeout);
 
 /**
  * Callback to handle interface up
@@ -257,10 +227,15 @@ extern int cvmx_spi_calendar_sync_cb(int interface, cvmx_spi_mode_t mode,
  *                  can operate as a full duplex (both Tx and Rx data paths
  *                  active) or as a halfplex (either the Tx data path is
  *                  active or the Rx data path is active, but not both).
- *
- * Returns Zero on success, non-zero error code on failure (will cause
- * SPI initialization to abort)
+ * Returns Zero on success, non-zero error code on failure (will cause SPI initialization to abort)
  */
 extern int cvmx_spi_interface_up_cb(int interface, cvmx_spi_mode_t mode);
 
+/**
+ * Sets the spi timeout in config data
+ * @timeout: value
+ */
+void cvmx_spi_config_set_timeout(int timeout);
+
+
 #endif /* __CVMX_SPI_H__ */
-- 
1.7.5.4

