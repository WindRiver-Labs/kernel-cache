From 27501bbdb4b4aae2283f60d2ed2163708b3404d8 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 12 Nov 2012 17:17:11 -0800
Subject: [PATCH 294/337] MIPS: OCTEON: Add framework for managing and
 reporting hardware status bit assertions.

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Makefile                |    2 +-
 arch/mips/cavium-octeon/octeon-hw-status.c      |  389 +++++++++++++++++++++++
 arch/mips/include/asm/octeon/octeon-hw-status.h |   36 ++
 3 files changed, 426 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/octeon-hw-status.c
 create mode 100644 arch/mips/include/asm/octeon/octeon-hw-status.h

diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index be530b9..3531f7f 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -14,7 +14,7 @@ CFLAGS_setup.o = -I$(src)/../../../scripts/dtc/libfdt
 
 obj-y := cpu.o setup.o serial.o octeon-platform.o octeon-irq.o csrc-octeon.o
 obj-y += dma-octeon.o csrc-octeon-ptp.o octeon-pci-console.o
-obj-y += octeon_info.o perf_counters.o
+obj-y += octeon_info.o perf_counters.o octeon-hw-status.o
 obj-$(CONFIG_MTD) += flash_setup.o
 obj-y += octeon-memcpy.o
 obj-y += executive/
diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
new file mode 100644
index 0000000..63224cb
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -0,0 +1,389 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2012 Cavium, Inc.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/notifier.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+
+#include <asm/octeon/octeon-hw-status.h>
+#include <asm/octeon/octeon.h>
+
+static RAW_NOTIFIER_HEAD(octeon_hw_status_notifiers);
+
+int octeon_hw_status_notifier_register(struct notifier_block *nb)
+{
+	return raw_notifier_chain_register(&octeon_hw_status_notifiers, nb);
+}
+EXPORT_SYMBOL(octeon_hw_status_notifier_register);
+
+int octeon_hw_status_notifier_unregister(struct notifier_block *nb)
+{
+	return raw_notifier_chain_unregister(&octeon_hw_status_notifiers, nb);
+}
+EXPORT_SYMBOL(octeon_hw_status_notifier_unregister);
+
+struct octeon_hw_status_node {
+	struct octeon_hw_status_node *next; /* Child list */
+	struct octeon_hw_status_node *child;
+	struct octeon_hw_status_node *parent;
+	union {
+		struct {
+			u64 reg;
+			u64 mask_reg;
+		};
+		struct {
+			u32 hwint;
+			int irq;
+		};
+	};
+	u8 bit;
+	u8 users;  /* Reference count. */
+	u8 is_hwint:1;
+	u8 ack_w1c:1;
+};
+
+/* Protects octeon_hw_status_roots */
+static DEFINE_RWLOCK(octeon_hw_status_lock);
+static struct octeon_hw_status_node *octeon_hw_status_roots;
+
+/* call cb on each node.  stop if cb returns true. */
+static int visit_leaves(struct octeon_hw_status_node *s,
+			  int (*cb)(struct octeon_hw_status_node *, void *),
+			  void *arg)
+{
+	struct octeon_hw_status_node *w = s;
+	int r;
+
+	while (w) {
+		if (w->child) {
+			/* Go out to the leaves */
+			w = w->child;
+			continue;
+		}
+
+		/* At a leaf, make the callback. */
+		r = cb(w, arg);
+		if (r)
+			return r;
+
+		if (w->next) {
+			/* Go to next leaf */
+			w = w->next;
+			continue;
+		}
+		/* back toward the root*/
+		for (;;) {
+			if (!w->parent || w->parent == s)
+				return 0;
+			if (w->parent->next) {
+				w = w->parent->next;
+				break;
+			}
+			w = w->parent;
+		}
+	}
+	return 0;
+}
+
+struct find_node_cb_data {
+	struct octeon_hw_status_node *r;
+	struct octeon_hw_status_reg *sr;
+};
+
+static int find_node_cb(struct octeon_hw_status_node *n, void *arg)
+{
+	struct find_node_cb_data *d = arg;
+	struct octeon_hw_status_reg *sr = d->sr;
+
+	if (n->is_hwint == sr->reg_is_hwint) {
+		if (n->is_hwint) {
+			if (n->hwint == sr->reg)
+				goto found;
+		} else {
+			if (n->reg == sr->reg && n->bit == sr->bit)
+				goto found;
+		}
+	}
+	return 0;
+found:
+	WARN((n->child != NULL) != sr->has_child ||
+	     n->ack_w1c != sr->ack_w1c, "Mismatched properties");
+	d->r = n;
+	return 1;
+}
+
+static struct octeon_hw_status_node *find_node(struct octeon_hw_status_node *r,
+					       struct octeon_hw_status_reg *sr)
+{
+	struct find_node_cb_data d;
+	d.r = NULL;
+	d.sr = sr;
+
+	visit_leaves(r, find_node_cb, &d);
+
+	return d.r;
+}
+
+struct irq_cb_data {
+	bool handled_one;
+};
+
+static int irq_cb(struct octeon_hw_status_node *n, void *arg)
+{
+	u64 csr, en, bit_mask;
+	struct octeon_hw_status_data ohsd;
+	struct irq_cb_data *d = arg;
+
+	bit_mask = 1ull << n->bit;
+	csr = cvmx_read_csr(n->reg);
+	if (!(csr & bit_mask))
+		return 0;
+
+	if (n->mask_reg) {
+		en = cvmx_read_csr(n->mask_reg);
+		if (!(en & bit_mask))
+			return 0;
+	}
+	/* Found an enabled source. */
+
+	if (n->ack_w1c)
+		cvmx_write_csr(n->reg, bit_mask);
+
+	ohsd.reg = n->reg;
+	ohsd.bit = n->bit;
+	raw_notifier_call_chain(&octeon_hw_status_notifiers,
+				OCTEON_HW_STATUS_SOURCE_ASSERTED, &ohsd);
+	d->handled_one = true;
+	return 0;
+}
+
+static irqreturn_t octeon_hw_status_irq(int irq, void *dev)
+{
+	struct irq_cb_data d;
+	struct octeon_hw_status_node *root = dev;
+
+	d.handled_one = false;
+	read_lock(&octeon_hw_status_lock);
+	visit_leaves(root, irq_cb, &d);
+	read_unlock(&octeon_hw_status_lock);
+	return d.handled_one ? IRQ_HANDLED : IRQ_NONE;
+}
+
+int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
+{
+	struct octeon_hw_status_data ohsd;
+	struct octeon_hw_status_node *root;
+	struct octeon_hw_status_node *n;
+	struct octeon_hw_status_node *w;
+	bool root_created = false;
+	int rv = 0;
+
+	if (!chain->reg_is_hwint)
+		return -EINVAL;
+
+	write_lock(&octeon_hw_status_lock);
+	/* Find the root */
+	root = octeon_hw_status_roots;
+	while (root && root->hwint != chain->reg)
+		root = root->next;
+
+	if (!root) {
+		root = kzalloc(sizeof(struct octeon_hw_status_node),
+			       GFP_KERNEL);
+		if (!root) {
+			rv = -ENOMEM;
+			goto out;
+		}
+		root->hwint = chain->reg;
+		root->is_hwint = 1;
+		root->ack_w1c = chain->ack_w1c;
+		root->next = octeon_hw_status_roots;
+		octeon_hw_status_roots = root;
+		root_created = true;
+	}
+	w = root;
+	while (chain->has_child) {
+		chain++;
+		n = find_node(w->child, chain);
+		if (!n) {
+			n = kzalloc(sizeof(struct octeon_hw_status_node),
+				    GFP_KERNEL);
+			if (!n) {
+				rv = -ENOMEM;
+				goto out;
+			}
+			n->is_hwint = chain->reg_is_hwint;
+			n->ack_w1c = chain->ack_w1c;
+			if (n->is_hwint) {
+				n->hwint = chain->reg;
+			} else {
+				n->reg = chain->reg;
+				n->mask_reg = chain->mask_reg;
+				n->bit = chain->bit;
+			}
+			n->next = w->child;
+			w->child = n;
+			n->parent = w;
+		}
+		w = n;
+	}
+	w->users++;
+	WARN(w->users == 0, "Reference count overflowed!");
+
+	if (root_created) {
+		/* register an interrupt handler */
+		root->irq = irq_create_mapping(NULL, root->hwint);
+		if (!root->irq) {
+			rv = -ENXIO;
+			goto out;
+		}
+		rv = request_threaded_irq(root->irq, NULL, octeon_hw_status_irq,
+					  0, "octeon-hw-status", root);
+		WARN(rv, "request_threaded_irq failed: %d", rv);
+	}
+
+	write_unlock(&octeon_hw_status_lock);
+	ohsd.reg = w->reg;
+	ohsd.bit = w->bit;
+	raw_notifier_call_chain(&octeon_hw_status_notifiers,
+				OCTEON_HW_STATUS_SOURCE_ADDED, &ohsd);
+	return 0;
+out:
+	write_unlock(&octeon_hw_status_lock);
+	return rv;
+}
+EXPORT_SYMBOL(octeon_hw_status_add_source);
+
+static int dispose_of_node(struct octeon_hw_status_node *n)
+{
+	struct octeon_hw_status_node *parent;
+	struct octeon_hw_status_node **pw;
+
+	for (;;) {
+		parent = n->parent;
+		if (parent)
+			pw = &n->parent->child;
+		else
+			pw = &octeon_hw_status_roots;
+
+		while (*pw) {
+			if (*pw == n) {
+				*pw = n->next;
+				if (n->is_hwint)
+					free_irq(n->irq, n);
+				kfree(n);
+				break;
+			} else {
+				pw = &(*pw)->next;
+			}
+		}
+		/* Stop at the root or if there are more children. */
+		if (!parent || parent->child)
+			break;
+		n = parent;
+	}
+	return 0;
+}
+
+int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
+{
+	int rv = 0;
+	struct octeon_hw_status_node *n;
+
+	write_lock(&octeon_hw_status_lock);
+
+	n = find_node(octeon_hw_status_roots, leaf);
+	if (!n) {
+		rv = -ENODEV;
+		goto out;
+	}
+
+	n->users--;
+	if (n->users == 0) {
+		if (!n->is_hwint && n->mask_reg) {
+			u64 mask = 1ull << n->bit;
+			u64 csr = cvmx_read_csr(n->mask_reg);
+			csr &= ~mask;
+			cvmx_write_csr(n->mask_reg, csr);
+		}
+		dispose_of_node(n);
+	}
+out:
+	write_unlock(&octeon_hw_status_lock);
+	return rv;
+}
+EXPORT_SYMBOL(octeon_hw_status_remove_source);
+
+
+struct enable_cb_data {
+	u64 reg;
+	u64 requested_mask;
+	u64 mask_reg;
+	u64 valid_mask;
+};
+
+static int enable_cb(struct octeon_hw_status_node *n, void *arg)
+{
+	struct enable_cb_data *d = arg;
+
+	if (n->reg == d->reg && (d->requested_mask & (1ul << n->bit))) {
+		d->valid_mask |= (1ul << n->bit);
+		WARN(d->mask_reg && d->mask_reg != n->mask_reg,
+		     "mask reg mismatch %llu", n->reg);
+		d->mask_reg = n->mask_reg;
+	}
+	return 0;
+}
+
+int octeon_hw_status_enable(u64 reg, u64 bit_mask)
+{
+	struct enable_cb_data cbd;
+
+	memset(&cbd, 0, sizeof(cbd));
+	cbd.reg = reg;
+	cbd.requested_mask = bit_mask;
+
+	read_lock(&octeon_hw_status_lock);
+
+	visit_leaves(octeon_hw_status_roots, enable_cb, &cbd);
+
+	if (cbd.valid_mask && cbd.mask_reg) {
+		u64 csr = cvmx_read_csr(cbd.mask_reg);
+		csr |= cbd.valid_mask;
+		cvmx_write_csr(cbd.mask_reg, csr);
+	}
+
+	read_unlock(&octeon_hw_status_lock);
+	return 0;
+}
+EXPORT_SYMBOL(octeon_hw_status_enable);
+
+int octeon_hw_status_disable(u64 reg, u64 bit_mask)
+{
+	struct enable_cb_data cbd;
+
+	memset(&cbd, 0, sizeof(cbd));
+	cbd.reg = reg;
+	cbd.requested_mask = bit_mask;
+
+	read_lock(&octeon_hw_status_lock);
+
+	visit_leaves(octeon_hw_status_roots, enable_cb, &cbd);
+
+	if (cbd.valid_mask && cbd.mask_reg) {
+		u64 csr = cvmx_read_csr(cbd.mask_reg);
+		csr &= ~cbd.valid_mask;
+		cvmx_write_csr(cbd.mask_reg, csr);
+	}
+
+	read_unlock(&octeon_hw_status_lock);
+	return 0;
+}
+EXPORT_SYMBOL(octeon_hw_status_disable);
diff --git a/arch/mips/include/asm/octeon/octeon-hw-status.h b/arch/mips/include/asm/octeon/octeon-hw-status.h
new file mode 100644
index 0000000..7626cea
--- /dev/null
+++ b/arch/mips/include/asm/octeon/octeon-hw-status.h
@@ -0,0 +1,36 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2012 Cavium, Inc.
+ */
+
+struct notifier_block;
+
+#define OCTEON_HW_STATUS_SOURCE_ADDED 1
+#define OCTEON_HW_STATUS_SOURCE_ASSERTED 2
+
+struct octeon_hw_status_reg {
+	u64 reg;
+	u64 mask_reg;
+	u8 bit;
+	u8 reg_is_hwint:1;
+	u8 ack_w1c:1;
+	u8 has_child:1;
+};
+
+/* Passed to notifier callbacks. */
+struct octeon_hw_status_data {
+	u64 reg;
+	u32 bit;
+};
+
+int octeon_hw_status_notifier_register(struct notifier_block *nb);
+int octeon_hw_status_notifier_unregister(struct notifier_block *nb);
+
+int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain);
+int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf);
+
+int octeon_hw_status_enable(u64 reg, u64 bit_mask);
+int octeon_hw_status_disable(u64 reg, u64 bit_mask);
-- 
1.7.5.4

