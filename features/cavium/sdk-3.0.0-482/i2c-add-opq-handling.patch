From c5589636364cace2e12193fd5febdb6e40bea443 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Mon, 19 Mar 2012 16:00:55 -0500
Subject: [PATCH 150/337] i2c: add opq handling

Based On SDK 3.0.0-482

This patch adds handling of the op q to the I2C main code
in preparation for the non-blocking changes.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/i2c-core.c |   80 ++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/i2c.h    |   46 +++++++++++++++++++++++++++
 2 files changed, 126 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index e54aed7..c6b0e4c 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -840,6 +840,8 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 	rt_mutex_init(&adap->bus_lock);
 	mutex_init(&adap->userspace_clients_lock);
 	INIT_LIST_HEAD(&adap->userspace_clients);
+	spin_lock_init(&adap->q_lock);
+	INIT_LIST_HEAD(&adap->q);
 
 	/* Set default timeout to 1 second if not already set */
 	if (adap->timeout == 0)
@@ -1319,6 +1321,7 @@ static void i2c_transfer_entry(struct i2c_adapter *adap,
 	 */
 
 	entry->xfer_type = I2C_OP_I2C;
+	kref_init(&entry->usecount);
 	if (algo->master_xfer) {
 #ifdef DEBUG
 		int ret;
@@ -2164,6 +2167,7 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
+	kref_init(&entry->usecount);
 
 	entry->xfer_type = I2C_OP_SMBUS;
 	entry->smbus.addr = addr;
@@ -2216,6 +2220,82 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 }
 EXPORT_SYMBOL(i2c_smbus_xfer);
 
+/* ----------------------------------------------------
+ * Entry handling
+ * ----------------------------------------------------
+ */
+
+/*
+ * Get the first entry off the head of the queue and lock it there.
+ * The entry is guaranteed to remain first in the list and the handler
+ * not be called until i2c_entry_put() is called.
+ */
+static struct i2c_op_q_entry *_i2c_entry_get(struct i2c_adapter *adap)
+{
+	struct i2c_op_q_entry *entry = NULL;
+
+	if (!list_empty(&adap->q)) {
+		struct list_head *link = adap->q.next;
+		entry = list_entry(link, struct i2c_op_q_entry, link);
+		kref_get(&entry->usecount);
+	}
+	pr_debug("_i2c_entry_get %p %p\n", adap, entry);
+	return entry;
+}
+
+struct i2c_op_q_entry *i2c_entry_get(struct i2c_adapter *adap)
+{
+	unsigned long flags;
+	struct i2c_op_q_entry *entry;
+
+	spin_lock_irqsave(&adap->q_lock, flags);
+	entry = _i2c_entry_get(adap);
+	spin_unlock_irqrestore(&adap->q_lock, flags);
+	return entry;
+}
+
+static void i2c_op_release(struct kref *ref)
+{
+	/*
+	 * Nothing to do here, all handling is from the kref_put
+	 * return code.
+	 */
+}
+
+void i2c_entry_put(struct i2c_adapter *adap,
+		   struct i2c_op_q_entry *entry)
+{
+	unsigned long flags;
+
+	pr_debug("i2c_put %p %p\n", adap, entry);
+
+	spin_lock_irqsave(&adap->q_lock, flags);
+	while (kref_put(&entry->usecount, i2c_op_release)) {
+		list_del(&entry->link);
+		spin_unlock_irqrestore(&adap->q_lock, flags);
+
+		if (entry->complete)
+			entry->complete(adap, entry);
+
+		entry->handler(entry);
+
+		spin_lock_irqsave(&adap->q_lock, flags);
+		entry = _i2c_entry_get(adap);
+		if (!entry)
+			break;
+		if (entry->start)
+			complete(entry->start);
+	}
+	spin_unlock_irqrestore(&adap->q_lock, flags);
+}
+
+void i2c_op_done(struct i2c_adapter *adap, struct i2c_op_q_entry *entry)
+{
+	pr_debug("i2c_op_done: %p %p\n", adap, entry);
+	i2c_entry_put(adap, entry);
+}
+EXPORT_SYMBOL(i2c_op_done);
+
 MODULE_AUTHOR("Simon G. Vogl <simon@tk.uni-linz.ac.at>");
 MODULE_DESCRIPTION("I2C-Bus main module");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 555a8a9..7280621 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -345,6 +345,37 @@ i2c_register_board_info(int busnum, struct i2c_board_info const *info,
 #endif /* I2C_BOARDINFO */
 
 /*
+ * About locking and the non-blocking interface.
+ *
+ * The poll operations are called single-threaded (along with the
+ * xxx_start operations), so if the driver is only polled then there
+ * is no need to do any locking.  If you are using interrupts, then
+ * the timer operations and interrupts can race and you need to lock
+ * appropriately.
+ *
+ * i2c_op_done() can be called multiple times on the same entry (as
+ * long as each one has a get operation).  This handles poll and
+ * interrupt races calling i2c_op_done().  It will do the right thing.
+ */
+
+/*
+ * Called from an non-blocking interface to get the current working
+ * entry.  Returns NULL if there is none.  This is primarily for
+ * interrupt handlers to determine what they should be working on.
+ * Note that if you call i2c_entry_get() and get a non-null entry, you
+ * must call i2c_entry_put() on it.
+ */
+struct i2c_op_q_entry *i2c_entry_get(struct i2c_adapter *adap);
+void i2c_entry_put(struct i2c_adapter *adap,
+		   struct i2c_op_q_entry *entry);
+
+/*
+ * Called from an non-blocking interface to report that an operation
+ * has completed.  Can be called from interrupt context.
+ */
+void i2c_op_done(struct i2c_adapter *adap, struct i2c_op_q_entry *entry);
+
+/*
  * The following structs are for those who like to implement new bus drivers:
  * i2c_algorithm is the interface to a class of hardware solutions which can
  * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
@@ -380,6 +411,9 @@ struct i2c_adapter {
 	/* data fields that are valid for all devices	*/
 	struct rt_mutex bus_lock;
 
+	struct list_head q;
+	spinlock_t q_lock;
+
 	int timeout;			/* in jiffies */
 	int retries;
 	struct device dev;		/* the adapter device */
@@ -624,6 +658,7 @@ union i2c_smbus_data {
  */
 #define I2C_OP_I2C	0
 #define I2C_OP_SMBUS	1
+typedef void (*i2c_op_done_cb)(struct i2c_op_q_entry *entry);
 struct i2c_op_q_entry {
 	/*
 	 * The result will be set to the result of the operation when
@@ -643,6 +678,13 @@ struct i2c_op_q_entry {
 	int            xfer_type;
 
 	/*
+	 * Handler may be called from interrupt context, so be
+	 * careful.
+	 */
+	i2c_op_done_cb handler;
+	void           *handler_data;
+
+	/*
 	 * Set up the i2c or smbus structure, depending on the transfer
 	 * type.
 	 *
@@ -680,11 +722,15 @@ struct i2c_op_q_entry {
 
 	/**************************************************************/
 	/* Internals */
+	struct completion *start;
 	u8                pec;
 	u8                partial_pec;
 	void (*complete)(struct i2c_adapter    *adap,
 			 struct i2c_op_q_entry *entry);
 
+	struct list_head link;
+	struct kref usecount;
+
 	/*
 	 * These are here for SMBus emulation over I2C.  I don't like
 	 * them taking this much room in the data structure, but they
-- 
1.7.5.4

