From 8d44bf404273edf112589c5cebd5519238be06f6 Mon Sep 17 00:00:00 2001
From: Aaron Williams <aaron.williams@cavium.com>
Date: Fri, 11 Jan 2013 16:48:36 -0800
Subject: [PATCH 305/337] Fixed pr_err warnings and replaced pr_err with
 dev_err Fixed cleanup of GPIO code

Based On SDK 3.0.0-482

Signed-off-by: Aaron Williams <aaron.williams@cavium.com>
Reported-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   48 ++++++++++++++++++++++++----------------
 1 files changed, 29 insertions(+), 19 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index 2048b27..52d2af5 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -26,6 +26,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/sd.h>
+#include <net/irda/parameters.h>
 
 #include <asm/byteorder.h>
 #include <asm/octeon/octeon.h>
@@ -280,7 +281,8 @@ static irqreturn_t octeon_mmc_dma_interrupt(int irq, void *dev_id)
 	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT, 1);
 
 	if (!host->current_req || !host->current_req->data) {
-		pr_err("ERROR: no current_req for octeon_mmc_dma_interrupt\n");
+		dev_err(&host->pdev->dev,
+			"ERROR: no current_req for octeon_mmc_dma_interrupt\n");
 		goto out;
 	}
 
@@ -424,7 +426,8 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	cmd = mrq->cmd;
 	if (mrq->data == NULL || mrq->data->sg == NULL || !mrq->data->sg_len ||
 	    mrq->stop == NULL || mrq->stop->opcode != MMC_STOP_TRANSMISSION) {
-		pr_err("Error: octeon_mmc_dma_request no data\n");
+		dev_err(&mmc->card->dev,
+			"Error: octeon_mmc_dma_request no data\n");
 		cmd->error = -EINVAL;
 		if (mrq->done)
 			mrq->done(mrq);
@@ -840,8 +843,9 @@ static int __devinit octeon_init_slot(struct octeon_mmc_host *host, int id,
 	if (slot->ro_gpio >= 0) {
 		ret = gpio_request(slot->ro_gpio, "mmc_ro");
 		if (ret) {
-			pr_err("%s: Could not request mmc_ro GPIO %d\n",
-			       DRV_NAME);
+			dev_err(&host->pdev->dev,
+				"Could not request mmc_ro GPIO %d\n",
+				slot->ro_gpio);
 			return ret;
 		}
 		gpio_direction_input(slot->ro_gpio);
@@ -851,8 +855,8 @@ static int __devinit octeon_init_slot(struct octeon_mmc_host *host, int id,
 		if (ret) {
 			if (slot->ro_gpio >= 0)
 				gpio_free(slot->ro_gpio);
-			pr_err("%s: Could not request mmc_card_detect GPIO %d\n",
-			       DRV_NAME);
+			dev_err(&host->pdev->dev, "Could not request mmc_card_detect GPIO %d\n",
+				slot->cd_gpio);
 			return ret;
 		}
 		gpio_direction_input(slot->cd_gpio);
@@ -860,8 +864,9 @@ static int __devinit octeon_init_slot(struct octeon_mmc_host *host, int id,
 	if (slot->power_gpio >= 0) {
 		ret = gpio_request(slot->power_gpio, "mmc_power");
 		if (ret) {
-			pr_err("%s: Could not request mmc_power GPIO %d\n",
-			       DRV_NAME);
+			dev_err(&host->pdev->dev,
+				"Could not request mmc_power GPIO %d\n",
+				slot->power_gpio);
 			if (slot->ro_gpio >= 0)
 				gpio_free(slot->ro_gpio);
 			if (slot->cd_gpio)
@@ -1069,10 +1074,9 @@ static int __devexit octeon_mmc_remove(struct platform_device *pdev)
 	union cvmx_mio_ndf_dma_int ndf_dma_int;
 	union cvmx_mio_ndf_dma_cfg ndf_dma_cfg;
 	struct octeon_mmc_host *host = platform_get_drvdata(pdev);
-	struct octeon_mmc_slot *slot;
 
 	if (host) {
-		slot = mmc_priv(host);
+		int i;
 		/* Reset bus_id */
 		ndf_dma_cfg.u64 = cvmx_read_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG);
 		ndf_dma_cfg.s.en = 0;
@@ -1084,15 +1088,21 @@ static int __devexit octeon_mmc_remove(struct platform_device *pdev)
 		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT,
 			       ndf_dma_int.u64);
 
-		/* Free the GPIOs */
-		if (slot->ro_gpio >= 0)
-			gpio_free(slot->ro_gpio);
-		if (slot->cd_gpio >= 0)
-			gpio_free(slot->cd_gpio);
-		if (slot->power_gpio >= 0) {
-			gpio_set_value_cansleep(slot->power_gpio,
-						slot->power_gpio_active_low);
-			gpio_free(slot->power_gpio);
+		for (i = 0; i < OCTEON_MAX_MMC; i++) {
+			struct octeon_mmc_slot *slot;
+			slot = host->slot[i];
+			if (!slot)
+				continue;
+			/* Free the GPIOs */
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			if (slot->cd_gpio >= 0)
+				gpio_free(slot->cd_gpio);
+			if (slot->power_gpio >= 0) {
+				gpio_set_value_cansleep(slot->power_gpio,
+							slot->power_gpio_active_low);
+				gpio_free(slot->power_gpio);
+			}
 		}
 	}
 
-- 
1.7.5.4

