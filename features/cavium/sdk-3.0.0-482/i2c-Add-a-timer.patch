From 9042e171d081c921f6af734d518fc9b047863a77 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Mon, 19 Mar 2012 16:00:55 -0500
Subject: [PATCH 151/337] i2c: Add a timer

Based On SDK 3.0.0-482

Add a timer to the I2C layer.  This doesn't do much until the
non-blocking code shows up.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/i2c-core.c |   78 ++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/i2c.h    |   39 ++++++++++++++++++++++++
 2 files changed, 117 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index c6b0e4c..4d1c9cc 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -43,6 +43,7 @@
 
 #include "i2c-core.h"
 
+#define USEC_PER_JIFFIE (1000000 / HZ)
 
 /* core_lock protects i2c_adapter_idr, and guarantees
    that device detection, deletion of detected devices, and attach_adapter
@@ -842,6 +843,18 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 	INIT_LIST_HEAD(&adap->userspace_clients);
 	spin_lock_init(&adap->q_lock);
 	INIT_LIST_HEAD(&adap->q);
+	adap->timer = kmalloc(sizeof(*adap->timer), GFP_KERNEL);
+	if (!adap->timer) {
+		res = -ENOMEM;
+		goto out_list;
+	}
+
+	init_timer(&adap->timer->timer);
+	spin_lock_init(&adap->timer->lock);
+	adap->timer->deleted = 0;
+	adap->timer->running = 0;
+	adap->timer->next_call_time = 0;
+	adap->timer->adapter = adap;
 
 	/* Set default timeout to 1 second if not already set */
 	if (adap->timeout == 0)
@@ -1084,6 +1097,13 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 	/* device name is gone after device_unregister */
 	dev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);
 
+	/* Stop the timer and free its memory. */
+	adap->timer->deleted = 1;
+	/* Timer can no longer be started now. */
+	del_timer_sync(&adap->timer->timer);
+	kfree(adap->timer);
+	adap->timer = NULL;
+
 	/* clean up the sysfs representation */
 	init_completion(&adap->dev_released);
 	device_unregister(&adap->dev);
@@ -1292,6 +1312,64 @@ postcore_initcall(i2c_init);
 module_exit(i2c_exit);
 
 /* ----------------------------------------------------
+ * Timer operations
+ * ----------------------------------------------------
+ */
+static void i2c_handle_timer(unsigned long data);
+
+static void i2c_start_timer(struct i2c_adapter *adap,
+			    struct i2c_op_q_entry *entry)
+{
+	unsigned int wait_jiffies;
+	struct i2c_timer *t = adap->timer;
+	unsigned long flags;
+
+	wait_jiffies = ((entry->call_again_us + USEC_PER_JIFFIE - 1)
+			/ USEC_PER_JIFFIE);
+	if (wait_jiffies == 0)
+		wait_jiffies = 1;
+	/*
+	 * This won't be polled from the user code, so
+	 * start a timer to poll it.
+	 */
+	spin_lock_irqsave(&t->lock, flags);
+	if (!t->deleted && !t->running) {
+		t->timer.expires = jiffies + wait_jiffies;
+		t->timer.data = (unsigned long) t;
+		t->timer.function = i2c_handle_timer;
+		t->running = 1;
+		t->next_call_time = wait_jiffies * USEC_PER_JIFFIE;
+		add_timer(&t->timer);
+	}
+	spin_unlock_irqrestore(&t->lock, flags);
+}
+
+static void i2c_handle_timer(unsigned long data)
+{
+	struct i2c_timer      *t = (void *) data;
+	struct i2c_adapter    *adap;
+	unsigned long         flags;
+	struct i2c_op_q_entry *entry;
+
+	spin_lock_irqsave(&t->lock, flags);
+	adap = t->adapter;
+	t->running = 0;
+	spin_unlock_irqrestore(&t->lock, flags);
+
+	entry = i2c_entry_get(adap);
+	pr_debug("i2c_handle_timer: %p %p\n", adap, entry);
+	if (entry) {
+		/* Add poll here. */
+
+		spin_lock_irqsave(&adap->q_lock, flags);
+		if (entry->use_timer)
+			i2c_start_timer(adap, entry);
+		spin_unlock_irqrestore(&adap->q_lock, flags);
+		i2c_entry_put(adap, entry);
+	}
+}
+
+/* ----------------------------------------------------
  * the functional interface to the i2c busses.
  * ----------------------------------------------------
  */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 7280621..08662fb 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -35,6 +35,7 @@
 #include <linux/mutex.h>
 #include <linux/of.h>		/* for struct device_node */
 #include <linux/swab.h>		/* for swab16 */
+#include <linux/timer.h>
 
 extern struct bus_type i2c_bus_type;
 extern struct device_type i2c_adapter_type;
@@ -399,6 +400,20 @@ struct i2c_algorithm {
 };
 
 /*
+ * The timer has it's own separately allocated data structure because
+ * it needs to be able to exist even if the adapter is deleted (due to
+ * timer cancellation races).
+ */
+struct i2c_timer {
+	spinlock_t lock;
+	char deleted;
+	char running;
+	struct timer_list timer;
+	unsigned int next_call_time;
+	struct i2c_adapter *adapter;
+};
+
+/*
  * i2c_adapter is the structure used to identify a physical i2c bus along
  * with the access algorithms necessary to access it.
  */
@@ -414,6 +429,11 @@ struct i2c_adapter {
 	struct list_head q;
 	spinlock_t q_lock;
 
+	/*
+	 * Used to time non-blocking operations.
+	 */
+	struct i2c_timer *timer;
+
 	int timeout;			/* in jiffies */
 	int retries;
 	struct device dev;		/* the adapter device */
@@ -721,8 +741,27 @@ struct i2c_op_q_entry {
 	} smbus;
 
 	/**************************************************************/
+	/* Bus Interface */
+	/*
+	 * The bus interface must set call_again_us to the time in
+	 * microseconds until the next poll operation should be
+	 * called.  This *must* be set in the start operation
+	 * function.  The value may be changed in poll calls if the
+	 * bus interface needs different timeouts at different times.
+	 * The time_left and data can be used for anything the bus
+	 * interface likes.  data will be set to NULL before being
+	 * started; the bus interface must use that to tell if the
+	 * entry has been set up.  It should ignore poll operations on
+	 * entries that are not yet set up.
+	 */
+	unsigned int  call_again_us;
+	long          time_left;
+	void	      *data;
+
+	/**************************************************************/
 	/* Internals */
 	struct completion *start;
+	unsigned char     use_timer;
 	u8                pec;
 	u8                partial_pec;
 	void (*complete)(struct i2c_adapter    *adap,
-- 
1.7.5.4

