From 1e8d3b7d34d39e3e83b90d3f4d186f5f9e3f9a71 Mon Sep 17 00:00:00 2001
From: Aaron Williams <aaron.williams@cavium.com>
Date: Thu, 10 Jan 2013 16:22:24 -0800
Subject: [PATCH 303/337] mmc: OCTEON: Improve GPIO support.

Based On SDK 3.0.0-482

Warnings were being displayed if any of the GPIO controls for
card detect, write protect or power were defined because the
GPIO lines were not requested before use.

This change requests the GPIO lines before use and frees them
when the card is removed.

Signed-off-by: Aaron Williams <aaron.williams@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   55 +++++++++++++++++++++++++++++++++++-----
 1 files changed, 48 insertions(+), 7 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index bc9f86f..2048b27 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -663,11 +663,11 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		octeon_mmc_reset_bus(slot, 1);
 		if (slot->power_gpio >= 0)
 			gpio_set_value_cansleep(slot->power_gpio,
-						slot->power_gpio_active_low ? 1 : 0);
+						slot->power_gpio_active_low);
 	} else {
 		if (slot->power_gpio >= 0)
 			gpio_set_value_cansleep(slot->power_gpio,
-						slot->power_gpio_active_low ? 0 : 1);
+						!slot->power_gpio_active_low);
 	}
 
 	switch (ios->bus_width) {
@@ -837,14 +837,42 @@ static int __devinit octeon_init_slot(struct octeon_mmc_host *host, int id,
 	slot->cd_gpio_active_low = cd_low;
 	slot->power_gpio_active_low = power_low;
 
-	if (slot->ro_gpio >= 0)
+	if (slot->ro_gpio >= 0) {
+		ret = gpio_request(slot->ro_gpio, "mmc_ro");
+		if (ret) {
+			pr_err("%s: Could not request mmc_ro GPIO %d\n",
+			       DRV_NAME);
+			return ret;
+		}
 		gpio_direction_input(slot->ro_gpio);
-	if (slot->cd_gpio >= 0)
+	}
+	if (slot->cd_gpio >= 0) {
+		ret = gpio_request(slot->cd_gpio, "mmc_card_detect");
+		if (ret) {
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			pr_err("%s: Could not request mmc_card_detect GPIO %d\n",
+			       DRV_NAME);
+			return ret;
+		}
 		gpio_direction_input(slot->cd_gpio);
-	if (slot->power_gpio >= 0)
+	}
+	if (slot->power_gpio >= 0) {
+		ret = gpio_request(slot->power_gpio, "mmc_power");
+		if (ret) {
+			pr_err("%s: Could not request mmc_power GPIO %d\n",
+			       DRV_NAME);
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			if (slot->cd_gpio)
+				gpio_free(slot->cd_gpio);
+			return ret;
+		}
+		pr_debug("%s: Shutting off power to slot %d via gpio %d\n",
+			 DRV_NAME, slot->bus_id, slot->power_gpio);
 		gpio_direction_output(slot->power_gpio,
-				      slot->power_gpio_active_low ? 1 : 0);
-
+				      slot->power_gpio_active_low);
+	}
 	/*
 	 * Set up host parameters.
 	 */
@@ -1041,8 +1069,10 @@ static int __devexit octeon_mmc_remove(struct platform_device *pdev)
 	union cvmx_mio_ndf_dma_int ndf_dma_int;
 	union cvmx_mio_ndf_dma_cfg ndf_dma_cfg;
 	struct octeon_mmc_host *host = platform_get_drvdata(pdev);
+	struct octeon_mmc_slot *slot;
 
 	if (host) {
+		slot = mmc_priv(host);
 		/* Reset bus_id */
 		ndf_dma_cfg.u64 = cvmx_read_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG);
 		ndf_dma_cfg.s.en = 0;
@@ -1053,6 +1083,17 @@ static int __devexit octeon_mmc_remove(struct platform_device *pdev)
 		ndf_dma_int.u64 = 0;
 		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT,
 			       ndf_dma_int.u64);
+
+		/* Free the GPIOs */
+		if (slot->ro_gpio >= 0)
+			gpio_free(slot->ro_gpio);
+		if (slot->cd_gpio >= 0)
+			gpio_free(slot->cd_gpio);
+		if (slot->power_gpio >= 0) {
+			gpio_set_value_cansleep(slot->power_gpio,
+						slot->power_gpio_active_low);
+			gpio_free(slot->power_gpio);
+		}
 	}
 
 	platform_set_drvdata(pdev, NULL);
-- 
1.7.5.4

