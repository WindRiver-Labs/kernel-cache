From 71a6c78f452d393116ad7500ec3f6ea206cf20fe Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Fri, 14 May 2010 14:21:59 -0700
Subject: [PATCH 069/337] i2c: i2c-octeon: Add workaround for chips with
 broken irqs.

Based On SDK 3.0.0-482

CN3860 does not interrupt the CPU when the i2c status changes.  If we
get a timeout, and see the status has in fact changed, we know we have
this problem, and drop back to polling.

Convert the timeout to mS instead of a fixed number of jiffies.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c |   46 +++++++++++++++++++++++++++++++-------
 1 files changed, 37 insertions(+), 9 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index f44c835..cf93084 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -72,6 +72,7 @@ struct octeon_i2c {
 	void __iomem *twsi_base;
 	resource_size_t regsize;
 	struct device *dev;
+	int broken_irq_mode;
 };
 
 /**
@@ -204,6 +205,20 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 {
 	int result;
 
+	if (i2c->broken_irq_mode) {
+		/*
+		 * Some chip revisions seem to not assert the irq in
+		 * the interrupt controller.  So we must poll for the
+		 * IFLG change.
+		 */
+		u64 end = get_jiffies_64() + i2c->adap.timeout;
+
+		while (!octeon_i2c_test_iflg(i2c) && get_jiffies_64() <= end)
+			udelay(50);
+
+		return octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;
+	}
+
 	octeon_i2c_int_enable(i2c);
 
 	result = wait_event_interruptible_timeout(i2c->queue,
@@ -212,6 +227,13 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 
 	octeon_i2c_int_disable(i2c);
 
+
+	if (result <= 0 && octeon_i2c_test_iflg(i2c)) {
+		dev_err(i2c->dev, "broken irq connection detected, switching to polling mode.\n");
+		i2c->broken_irq_mode = 1;
+		return 0;
+	}
+
 	if (result < 0) {
 		dev_dbg(i2c->dev, "%s: wait interrupted\n", __func__);
 		return result;
@@ -440,7 +462,6 @@ static struct i2c_adapter octeon_i2c_ops = {
 	.owner = THIS_MODULE,
 	.name = "OCTEON adapter",
 	.algo = &octeon_i2c_algo,
-	.timeout = 2,
 };
 
 /**
@@ -494,20 +515,26 @@ static int __devinit octeon_i2c_initlowlevel(struct octeon_i2c *i2c)
 	u8 status;
 	int tries;
 
-	/* disable high level controller, enable bus access */
-	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);
-
 	/* reset controller */
 	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_RST, 0);
 
-	for (tries = 10; tries; tries--) {
+	status = 0;
+	for (tries = 10; tries && status != STAT_IDLE; tries--) {
 		udelay(1);
 		status = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);
-		if (status == STAT_IDLE)
-			return 0;
 	}
-	dev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n", __func__, status);
-	return -EIO;
+
+	if (status != STAT_IDLE) {
+		dev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n",
+			__func__, status);
+		return -EIO;
+	}
+
+
+	/* disable high level controller, enable bus access */
+	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);
+
+	return 0;
 }
 
 static int __devinit octeon_i2c_probe(struct platform_device *pdev)
@@ -587,6 +614,7 @@ static int __devinit octeon_i2c_probe(struct platform_device *pdev)
 	}
 
 	i2c->adap = octeon_i2c_ops;
+	i2c->adap.timeout = msecs_to_jiffies(50);
 	i2c->adap.dev.parent = &pdev->dev;
 	i2c->adap.dev.of_node = pdev->dev.of_node;
 	i2c_set_adapdata(&i2c->adap, i2c);
-- 
1.7.5.4

