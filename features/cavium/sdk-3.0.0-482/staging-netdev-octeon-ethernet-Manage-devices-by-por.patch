From 3c1d4b9e4a83e0fd381aa5367610e982abbd02b4 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 5 Jul 2012 18:25:35 -0700
Subject: [PATCH 118/337] staging/ netdev: octeon-ethernet: Manage devices by
 port rather than netdev

Based On SDK 3.0.0-482

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/staging/octeon/ethernet-rgmii.c  |   12 +++------
 drivers/staging/octeon/ethernet-rx.c     |   37 ++++++++++++++++-------------
 drivers/staging/octeon/ethernet.c        |   37 +++++++++++++----------------
 drivers/staging/octeon/octeon-ethernet.h |    6 ++++-
 4 files changed, 46 insertions(+), 46 deletions(-)

diff --git a/drivers/staging/octeon/ethernet-rgmii.c b/drivers/staging/octeon/ethernet-rgmii.c
index bf74113..b3ab05d 100644
--- a/drivers/staging/octeon/ethernet-rgmii.c
+++ b/drivers/staging/octeon/ethernet-rgmii.c
@@ -178,11 +178,9 @@ static irqreturn_t cvm_oct_rgmii_rml_interrupt(int cpl, void *dev_id)
 			if (gmx_rx_int_reg.s.phy_dupx
 			    || gmx_rx_int_reg.s.phy_link
 			    || gmx_rx_int_reg.s.phy_spd) {
-				struct net_device *dev =
-					cvm_oct_device[cvmx_helper_get_ipd_port(interface, index)];
-				struct octeon_ethernet *priv = netdev_priv(dev);
+				struct octeon_ethernet *priv = cvm_oct_by_port[cvmx_helper_get_ipd_port(interface, index)];
 
-				if (dev && !atomic_read(&cvm_oct_poll_queue_stopping))
+				if (priv && !atomic_read(&cvm_oct_poll_queue_stopping))
 					queue_work(cvm_oct_poll_queue, &priv->port_work);
 
 				gmx_rx_int_reg.u64 = 0;
@@ -213,11 +211,9 @@ static irqreturn_t cvm_oct_rgmii_rml_interrupt(int cpl, void *dev_id)
 			if (gmx_rx_int_reg.s.phy_dupx
 			    || gmx_rx_int_reg.s.phy_link
 			    || gmx_rx_int_reg.s.phy_spd) {
-				struct net_device *dev =
-					cvm_oct_device[cvmx_helper_get_ipd_port(interface, index)];
-				struct octeon_ethernet *priv = netdev_priv(dev);
+				struct octeon_ethernet *priv = cvm_oct_by_port[cvmx_helper_get_ipd_port(interface, index)];
 
-				if (dev && !atomic_read(&cvm_oct_poll_queue_stopping))
+				if (priv && !atomic_read(&cvm_oct_poll_queue_stopping))
 					queue_work(cvm_oct_poll_queue, &priv->port_work);
 
 				gmx_rx_int_reg.u64 = 0;
diff --git a/drivers/staging/octeon/ethernet-rx.c b/drivers/staging/octeon/ethernet-rx.c
index 649161b..ac10617 100644
--- a/drivers/staging/octeon/ethernet-rx.c
+++ b/drivers/staging/octeon/ethernet-rx.c
@@ -272,8 +272,11 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 	int		did_work_request = 0;
 	bool		packet_copied;
 
+	char		*p = (char *)cvm_oct_by_port;
 	/* Prefetch cvm_oct_device since we know we need it soon */
-	prefetch(cvm_oct_device);
+	prefetch(&p[0]);
+	prefetch(&p[SMP_CACHE_BYTES]);
+	prefetch(&p[2 * SMP_CACHE_BYTES]);
 
 	if (USE_ASYNC_IOBDMA) {
 		/* Save scratch in case userspace is using it */
@@ -367,7 +370,7 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 			prefetch(&skb->head);
 			prefetch(&skb->len);
 		}
-		prefetch(cvm_oct_device[work->word1.cn38xx.ipprt]);
+		prefetch(cvm_oct_by_port[work->word1.cn38xx.ipprt]);
 
 		/* Immediately throw away all packets with receive errors */
 		if (unlikely(work->word2.snoip.rcv_error)) {
@@ -496,16 +499,15 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 		}
 
 		if (likely((work->word1.cn38xx.ipprt < TOTAL_NUMBER_OF_PORTS) &&
-			   cvm_oct_device[work->word1.cn38xx.ipprt])) {
-			struct net_device *dev = cvm_oct_device[work->word1.cn38xx.ipprt];
-			struct octeon_ethernet *priv = netdev_priv(dev);
+			   cvm_oct_by_port[work->word1.cn38xx.ipprt])) {
+			struct octeon_ethernet *priv = cvm_oct_by_port[work->word1.cn38xx.ipprt];
 
 			/* Only accept packets for devices that are
 			 * currently up.
 			 */
-			if (likely(dev->flags & IFF_UP)) {
-				skb->protocol = eth_type_trans(skb, dev);
-				skb->dev = dev;
+			if (likely(priv->netdev->flags & IFF_UP)) {
+				skb->protocol = eth_type_trans(skb, priv->netdev);
+				skb->dev = priv->netdev;
 
 				if (unlikely(work->word2.s.not_IP || work->word2.s.IP_exc ||
 					work->word2.s.L4_error || !work->word2.s.tcp_or_udp))
@@ -593,16 +595,13 @@ void cvm_oct_rx_initialize(void)
 	int i;
 	struct net_device *dev_for_napi = NULL;
 
-	for (i = 0; i < TOTAL_NUMBER_OF_PORTS; i++) {
-		if (cvm_oct_device[i]) {
-			dev_for_napi = cvm_oct_device[i];
-			break;
-		}
-	}
-
-	if (NULL == dev_for_napi)
+	if (list_empty(&cvm_oct_list))
 		panic("No net_devices were allocated.");
 
+	dev_for_napi = list_first_entry(&cvm_oct_list,
+					struct octeon_ethernet,
+					list)->netdev;
+
 	if (max_rx_cpus >= 1  && max_rx_cpus < num_online_cpus())
 		core_state.baseline_cores = max_rx_cpus;
 	else
@@ -622,7 +621,7 @@ void cvm_oct_rx_initialize(void)
 
 	/* Register an IRQ hander for to receive POW interrupts */
 	i = request_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group,
-			cvm_oct_do_interrupt, 0, "Ethernet", cvm_oct_device);
+			cvm_oct_do_interrupt, 0, dev_for_napi->name, &cvm_oct_list);
 
 	if (i)
 		panic("Could not acquire Ethernet IRQ %d\n",
@@ -640,4 +639,8 @@ void cvm_oct_rx_shutdown(void)
 	/* Shutdown all of the NAPIs */
 	for_each_possible_cpu(i)
 		netif_napi_del(&cvm_oct_napi[i].napi);
+
+	/* Free the interrupt handler */
+	free_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group, &cvm_oct_list);
+
 }
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index c941932..0fe1d73 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -93,11 +93,13 @@ struct workqueue_struct *cvm_oct_poll_queue;
  */
 atomic_t cvm_oct_poll_queue_stopping = ATOMIC_INIT(0);
 
-/**
- * Array of every ethernet device owned by this driver indexed by
- * the ipd input port number.
+/* cvm_oct_by_port is an array of every ethernet device owned by this
+ * driver indexed by the ipd input port number.
  */
-struct net_device *cvm_oct_device[TOTAL_NUMBER_OF_PORTS];
+struct octeon_ethernet *cvm_oct_by_port[TOTAL_NUMBER_OF_PORTS] __cacheline_aligned;
+
+/* cvm_oct_list is a list of all cvm_oct_private_t created by this driver. */
+LIST_HEAD(cvm_oct_list);
 
 u64 cvm_oct_tx_poll_interval;
 
@@ -709,7 +711,8 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 					 interface, priv->ipd_port);
 				free_netdev(dev);
 			} else {
-				cvm_oct_device[priv->ipd_port] = dev;
+				list_add_tail(&priv->list, &cvm_oct_list);
+				cvm_oct_by_port[priv->ipd_port] = priv;
 				/*
 				 * Each transmit queue will need its
 				 * own MAX_OUT_QUEUE_DEPTH worth of
@@ -739,16 +742,14 @@ static int __devinit cvm_oct_probe(struct platform_device *pdev)
 
 static int __devexit cvm_oct_remove(struct platform_device *pdev)
 {
-	int port;
+	struct octeon_ethernet *priv;
+	struct octeon_ethernet *tmp;
 
 	/* Disable POW interrupt */
 	cvmx_write_csr(CVMX_POW_WQ_INT_THRX(pow_receive_group), 0);
 
 	cvmx_ipd_disable();
 
-	/* Free the interrupt handler */
-	free_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group, cvm_oct_device);
-
 	atomic_inc_return(&cvm_oct_poll_queue_stopping);
 	cancel_delayed_work_sync(&cvm_oct_rx_refill_work);
 
@@ -758,17 +759,13 @@ static int __devexit cvm_oct_remove(struct platform_device *pdev)
 	cvmx_pko_disable();
 
 	/* Free the ethernet devices */
-	for (port = 0; port < TOTAL_NUMBER_OF_PORTS; port++) {
-		if (cvm_oct_device[port]) {
-			struct net_device *dev = cvm_oct_device[port];
-			struct octeon_ethernet *priv = netdev_priv(dev);
-			cancel_delayed_work_sync(&priv->port_periodic_work);
-
-			cvm_oct_tx_shutdown_dev(dev);
-			unregister_netdev(dev);
-			free_netdev(dev);
-			cvm_oct_device[port] = NULL;
-		}
+	list_for_each_entry_safe_reverse(priv, tmp, &cvm_oct_list, list) {
+		list_del(&priv->list);
+		cancel_delayed_work_sync(&priv->port_periodic_work);
+		cvm_oct_tx_shutdown_dev(priv->netdev);
+		unregister_netdev(priv->netdev);
+		cvm_oct_by_port[priv->ipd_port] = NULL;
+		free_netdev(priv->netdev);
 	}
 
 	cvmx_helper_shutdown_packet_io_global();
diff --git a/drivers/staging/octeon/octeon-ethernet.h b/drivers/staging/octeon/octeon-ethernet.h
index 8b34e82..02de192 100644
--- a/drivers/staging/octeon/octeon-ethernet.h
+++ b/drivers/staging/octeon/octeon-ethernet.h
@@ -48,6 +48,8 @@ struct octeon_ethernet {
 
 	/* My netdev. */
 	struct net_device *netdev;
+	/* My location in the cvm_oct_list */
+	struct list_head list;
 
 	/*
 	 * Type of port. This is one of the enums in
@@ -130,7 +132,9 @@ extern int always_use_pow;
 extern int pow_send_group;
 extern int pow_receive_group;
 extern char pow_send_list[];
-extern struct net_device *cvm_oct_device[];
+extern struct list_head cvm_oct_list;
+extern struct octeon_ethernet *cvm_oct_by_port[];
+
 extern struct workqueue_struct *cvm_oct_poll_queue;
 extern atomic_t cvm_oct_poll_queue_stopping;
 extern u64 cvm_oct_tx_poll_interval;
-- 
1.7.5.4

