From dfa4b470d95defa3d2689c9d986f4a28b2304133 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 11 Jul 2012 14:12:01 -0700
Subject: [PATCH 124/337] staging/netdev: octeon-ethernet: Add timestamping
 support.

Based On SDK 3.0.0-482

On hardware that supports it, hook up support for adding and reporting
packet timestamps.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/staging/octeon/ethernet-mdio.c   |  122 +++++++++++++++++++++++++++++-
 drivers/staging/octeon/ethernet-rx.c     |   49 ++++++++++++-
 drivers/staging/octeon/ethernet-tx.c     |   10 +++
 drivers/staging/octeon/octeon-ethernet.h |    2 +
 4 files changed, 179 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/octeon/ethernet-mdio.c b/drivers/staging/octeon/ethernet-mdio.c
index fa8b97c..4446c7b 100644
--- a/drivers/staging/octeon/ethernet-mdio.c
+++ b/drivers/staging/octeon/ethernet-mdio.c
@@ -29,6 +29,7 @@
 #include <linux/phy.h>
 #include <linux/ratelimit.h>
 #include <linux/of_mdio.h>
+#include <linux/net_tstamp.h>
 
 #include <net/dst.h>
 
@@ -40,6 +41,9 @@
 #include <asm/octeon/cvmx-helper-board.h>
 
 #include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
 
 static void cvm_oct_get_drvinfo(struct net_device *dev,
 				struct ethtool_drvinfo *info)
@@ -94,6 +98,113 @@ const struct ethtool_ops cvm_oct_ethtool_ops = {
 };
 
 /**
+ * cvm_oct_ioctl_hwtstamp - IOCTL support for timestamping
+ * @dev:    Device to change
+ * @rq:     the request
+ * @cmd:    the command
+ *
+ * Returns Zero on success
+ */
+static int cvm_oct_ioctl_hwtstamp(struct net_device *dev,
+				  struct ifreq *rq, int cmd)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	struct hwtstamp_config config;
+	union cvmx_mio_ptp_clock_cfg ptp;
+	union cvmx_gmxx_rxx_frm_ctl frm_ctl;
+	union cvmx_pip_prt_cfgx prt_cfg;
+
+	if (copy_from_user(&config, rq->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	if (config.flags) /* reserved for future extensions */
+		return -EINVAL;
+
+	/* Check the status of hardware for tiemstamps */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
+		/* Write TX timestamp into word 4 */
+		cvmx_write_csr(CVMX_PKO_REG_TIMESTAMP, 4);
+
+		switch (priv->imode) {
+		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		case CVMX_HELPER_INTERFACE_MODE_SGMII:
+			break;
+		default:
+			/* No timestamp support*/
+			return -EOPNOTSUPP;
+		}
+
+		ptp.u64 = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_CFG);
+		if (!ptp.s.ptp_en) {
+			/* It should have been enabled by csrc-octeon-ptp */
+			pr_err("Error: PTP clock not enabled\n");
+			/* No timestamp support*/
+			return -EOPNOTSUPP;
+		}
+	} else {
+			/* No timestamp support*/
+			return -EOPNOTSUPP;
+	}
+
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		priv->tx_timestamp_hw = 0;
+		break;
+	case HWTSTAMP_TX_ON:
+		priv->tx_timestamp_hw = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		priv->rx_timestamp_hw = 0;
+
+		frm_ctl.u64 = cvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL(priv->interface_port, priv->interface));
+		frm_ctl.s.ptp_mode = 0;
+		cvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(priv->interface_port, priv->interface), frm_ctl.u64);
+
+		prt_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(priv->ipd_port));
+		prt_cfg.s.skip = 0;
+		cvmx_write_csr(CVMX_PIP_PRT_CFGX(priv->ipd_port), prt_cfg.u64);
+		break;
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_SOME:
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		priv->rx_timestamp_hw = 1;
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		frm_ctl.u64 = cvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL(priv->interface_port, priv->interface));
+		frm_ctl.s.ptp_mode = 1;
+		cvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(priv->interface_port, priv->interface), frm_ctl.u64);
+
+		prt_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(priv->ipd_port));
+		prt_cfg.s.skip = 8;
+		cvmx_write_csr(CVMX_PIP_PRT_CFGX(priv->ipd_port), prt_cfg.u64);
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	if (copy_to_user(rq->ifr_data, &config, sizeof(config)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/**
  * cvm_oct_ioctl - IOCTL support for PHY control
  * @dev:    Device to change
  * @rq:     the request
@@ -108,10 +219,15 @@ int cvm_oct_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	if (!netif_running(dev))
 		return -EINVAL;
 
-	if (!priv->phydev)
-		return -EINVAL;
+	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		return cvm_oct_ioctl_hwtstamp(dev, rq, cmd);
 
-	return phy_mii_ioctl(priv->phydev, rq, cmd);
+	default:
+		if (priv->phydev)
+			return phy_mii_ioctl(priv->phydev, rq, cmd);
+	}
+	return -EOPNOTSUPP;
 }
 
 static void cvm_oct_note_carrier(struct octeon_ethernet *priv,
diff --git a/drivers/staging/octeon/ethernet-rx.c b/drivers/staging/octeon/ethernet-rx.c
index 216e1d2..5ee59b8 100644
--- a/drivers/staging/octeon/ethernet-rx.c
+++ b/drivers/staging/octeon/ethernet-rx.c
@@ -257,6 +257,36 @@ static inline int cvm_oct_check_rcv_error(cvmx_wqe_t *work)
 }
 
 /**
+ * cvm_oct_ptp_to_ktime - Convert a hardware PTP timestamp into a
+ * kernel timestamp.
+ *
+ * @ptptime: 64 bit PTP timestamp, normally in nanoseconds
+ *
+ * Return ktime_t
+ */
+static ktime_t cvm_oct_ptp_to_ktime(u64 ptptime)
+{
+	ktime_t ktimebase;
+	u64 ptpbase;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	/* Fill the icache with the code */
+	ktime_get_real();
+	/* Flush all pending operations */
+	mb();
+	/* Read the time and PTP clock as close together as
+	 * possible. It is important that this sequence take the same
+	 * amount of time to reduce jitter
+	 */
+	ktimebase = ktime_get_real();
+	ptpbase = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_HI);
+	local_irq_restore(flags);
+
+	return ktime_sub_ns(ktimebase, ptpbase - ptptime);
+}
+
+/**
  * cvm_oct_napi_poll - the NAPI poll function.
  * @napi: The NAPI instance, or null if called from cvm_oct_poll_controller
  * @budget: Maximum number of packets to receive.
@@ -348,11 +378,19 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 		if (work->word2.s.software) {
 			struct octeon_ethernet *priv;
 			int packet_qos = work->word0.raw.unused;
+
 			skb = (struct sk_buff *)packet_ptr.u64;
 			priv = netdev_priv(skb->dev);
 			if (!netif_running(skb->dev))
 				netif_wake_queue(skb->dev);
-
+			if (unlikely((skb_shinfo(skb)->tx_flags | SKBTX_IN_PROGRESS) != 0 &&
+				     priv->tx_timestamp_hw)) {
+					u64 ns = *(u64 *)work->packet_data;
+					struct skb_shared_hwtstamps ts;
+					ts.syststamp = cvm_oct_ptp_to_ktime(ns);
+					ts.hwtstamp = ns_to_ktime(ns);
+					skb_tstamp_tx(skb, &ts);
+			}
 			dev_kfree_skb_any(skb);
 
 			cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, DONT_WRITEBACK(1));
@@ -506,6 +544,15 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 			 * currently up.
 			 */
 			if (likely(priv->netdev->flags & IFF_UP)) {
+				if (priv->rx_timestamp_hw) {
+					/* The first 8 bytes are the timestamp */
+					u64 ns = *(u64 *)skb->data;
+					struct skb_shared_hwtstamps *ts;
+					ts = skb_hwtstamps(skb);
+					ts->hwtstamp = ns_to_ktime(ns);
+					ts->syststamp = cvm_oct_ptp_to_ktime(ns);
+					__skb_pull(skb, 8);
+				}
 				skb->protocol = eth_type_trans(skb, priv->netdev);
 				skb->dev = priv->netdev;
 
diff --git a/drivers/staging/octeon/ethernet-tx.c b/drivers/staging/octeon/ethernet-tx.c
index 0a84cf8..ef60e43 100644
--- a/drivers/staging/octeon/ethernet-tx.c
+++ b/drivers/staging/octeon/ethernet-tx.c
@@ -152,6 +152,7 @@ int cvm_oct_xmit(struct sk_buff *skb, struct net_device *dev)
 	s32 buffers_being_recycled;
 	unsigned long flags;
 	cvmx_wqe_t *work = NULL;
+	bool timestamp_this_skb = false;
 
 	/* Prefetch the private data structure.  It is larger than one
 	 * cache line.
@@ -299,6 +300,12 @@ int cvm_oct_xmit(struct sk_buff *skb, struct net_device *dev)
 			goto dont_put_skbuff_in_hw;
 	}
 
+	if (unlikely(priv->tx_timestamp_hw &&
+		     (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))) {
+		timestamp_this_skb = true;
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+		goto dont_put_skbuff_in_hw;
+	}
 	/* See if we can put this skb in the FPA pool. Any strange
 	 * behavior from the Linux networking stack will most likely
 	 * be caused by a bug in the following code. If some field is
@@ -423,6 +430,9 @@ dont_put_skbuff_in_hw:
 	/* Send the packet to the output queue */
 	if (queue_type == QUEUE_WQE) {
 		u64 word2 = virt_to_phys(work);
+		if (timestamp_this_skb)
+			word2 |= 1ull << 40; /* Bit 40 controls timestamps */
+
 		if (unlikely(cvmx_pko_send_packet_finish3_pkoid(priv->pko_port,
 							  priv->tx_queue[qos].queue, pko_command, hw_buffer,
 							  word2, CVMX_PKO_LOCK_CMD_QUEUE))) {
diff --git a/drivers/staging/octeon/octeon-ethernet.h b/drivers/staging/octeon/octeon-ethernet.h
index e361927..5e32509 100644
--- a/drivers/staging/octeon/octeon-ethernet.h
+++ b/drivers/staging/octeon/octeon-ethernet.h
@@ -57,6 +57,8 @@ struct octeon_ethernet {
 	 */
 	int imode;
 
+	unsigned int tx_timestamp_hw:1;
+	unsigned int rx_timestamp_hw:1;
 	unsigned int tx_multiple_queues:1;
 
 	/* Number of elements in tx_queue below */
-- 
1.7.5.4

