From d3ccee07f7d2d10f7a47a817d5199db3455bb6f0 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 26 Nov 2012 17:33:00 -0800
Subject: [PATCH 240/337] MIPS: OCTEON: Use virt_to_phys() and phys_to_virt()

Based On SDK 3.0.0-482

Replace various instances of cvmx_ptr_to_phys() and cvmx_phys_to_ptr()
with the proper Linux counterparts.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/setup.c     |    8 +++-----
 arch/mips/include/asm/octeon/cvmx.h |   29 +++--------------------------
 2 files changed, 6 insertions(+), 31 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 5416229..be85971 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -584,9 +584,8 @@ void __init prom_init(void)
 	 * $a3, this is available as fw_arg3.
 	 */
 	octeon_boot_desc_ptr = (struct octeon_boot_descriptor *)fw_arg3;
-	octeon_bootinfo =
-		cvmx_phys_to_ptr(octeon_boot_desc_ptr->cvmx_desc_vaddr);
-	cvmx_bootmem_init(octeon_bootinfo->phy_mem_desc_addr);
+	octeon_bootinfo = phys_to_virt(octeon_boot_desc_ptr->cvmx_desc_vaddr);
+	cvmx_bootmem_init(phys_to_virt(octeon_bootinfo->phy_mem_desc_addr));
 
 	sysinfo = cvmx_sysinfo_get();
 	memset(sysinfo, 0, sizeof(*sysinfo));
@@ -727,8 +726,7 @@ void __init prom_init(void)
 	arcs_cmdline[0] = 0;
 	argc = octeon_boot_desc_ptr->argc;
 	for (i = 0; i < argc; i++) {
-		const char *arg =
-			cvmx_phys_to_ptr(octeon_boot_desc_ptr->argv[i]);
+		const char *arg = phys_to_virt(octeon_boot_desc_ptr->argv[i]);
 		if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
 			sscanf(arg + 4, "%llu", &MAX_MEMORY);
diff --git a/arch/mips/include/asm/octeon/cvmx.h b/arch/mips/include/asm/octeon/cvmx.h
index e3d1875..0c04d2c 100644
--- a/arch/mips/include/asm/octeon/cvmx.h
+++ b/arch/mips/include/asm/octeon/cvmx.h
@@ -31,6 +31,7 @@
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 
 enum cvmx_mips_space {
 	CVMX_MIPS_SPACE_XKSEG = 3LL,
@@ -161,22 +162,7 @@ static inline uint64_t cvmx_build_bits(uint64_t high_bit,
  */
 static inline uint64_t cvmx_ptr_to_phys(void *ptr)
 {
-	if (sizeof(void *) == 8) {
-		/*
-		 * We're running in 64 bit mode. Normally this means
-		 * that we can use 40 bits of address space (the
-		 * hardware limit). Unfortunately there is one case
-		 * were we need to limit this to 30 bits, sign
-		 * extended 32 bit. Although these are 64 bits wide,
-		 * only 30 bits can be used.
-		 */
-		if ((CAST64(ptr) >> 62) == 3)
-			return CAST64(ptr) & cvmx_build_mask(30);
-		else
-			return CAST64(ptr) & cvmx_build_mask(40);
-	} else {
-		return (long)(ptr) & 0x1fffffff;
-	}
+	return virt_to_phys(ptr);
 }
 
 /**
@@ -189,16 +175,7 @@ static inline uint64_t cvmx_ptr_to_phys(void *ptr)
  */
 static inline void *cvmx_phys_to_ptr(uint64_t physical_address)
 {
-	if (sizeof(void *) == 8) {
-		/* Just set the top bit, avoiding any TLB uglyness */
-		return CASTPTR(void,
-			       CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
-					    physical_address));
-	} else {
-		return CASTPTR(void,
-			       CVMX_ADD_SEG32(CVMX_MIPS32_SPACE_KSEG0,
-					      physical_address));
-	}
+	return phys_to_virt(physical_address);
 }
 
 /* The following #if controls the definition of the macro
-- 
1.7.5.4

