From ce78c175903c0336b787a4d5e21f9bcb7341cd5d Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 11 Jul 2012 13:59:15 -0700
Subject: [PATCH 123/337] MIPS: OCTEON: Add PTP clocksource.

Based On SDK 3.0.0-482

Ethernet packet time stamping uses the PTP clock, this makes the same
clock available as a clocksource.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Makefile          |    2 +-
 arch/mips/cavium-octeon/csrc-octeon-ptp.c |   71 +++++++++++++++++++++++++++++
 2 files changed, 72 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/csrc-octeon-ptp.c

diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index 6d95f20..b6d6b3f 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -13,7 +13,7 @@ CFLAGS_octeon-platform.o = -I$(src)/../../../scripts/dtc/libfdt
 CFLAGS_setup.o = -I$(src)/../../../scripts/dtc/libfdt
 
 obj-y := cpu.o setup.o serial.o octeon-platform.o octeon-irq.o csrc-octeon.o
-obj-y += dma-octeon.o
+obj-y += dma-octeon.o csrc-octeon-ptp.o
 obj-y += octeon_info.o
 obj-$(CONFIG_MTD) += flash_setup.o
 obj-y += octeon-memcpy.o
diff --git a/arch/mips/cavium-octeon/csrc-octeon-ptp.c b/arch/mips/cavium-octeon/csrc-octeon-ptp.c
new file mode 100644
index 0000000..4af62fb
--- /dev/null
+++ b/arch/mips/cavium-octeon/csrc-octeon-ptp.c
@@ -0,0 +1,71 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 - 2012 Cavium, Inc.
+ */
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <linux/time.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-mio-defs.h>
+
+static cycle_t octeon_ptp_clock_read(struct clocksource *cs)
+{
+	return octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_HI);
+}
+
+static struct clocksource clocksource_ptp_clock = {
+	.name		= "OCTEON_PTP_CLOCK",
+	.read		= octeon_ptp_clock_read,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+int __init ptp_clock_init(void)
+{
+	u64 clock_comp;
+	union cvmx_mio_ptp_clock_cfg ptp_clock_cfg;
+
+	/* Chips prior to CN6XXX don't support the PTP clock source */
+	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX) && !OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		return 0;
+
+	/* FIXME: Remove this when PTP is implemented in the simulator */
+	if (octeon_is_simulation())
+		return 0;
+
+	/* Get the current state of the PTP clock */
+	ptp_clock_cfg.u64 = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_CFG);
+	if (!ptp_clock_cfg.s.ext_clk_en) {
+		/*
+		 * The clock has not been configured to use an
+		 * external source.  Program it to use the main clock
+		 * reference.
+		 */
+		clock_comp = (NSEC_PER_SEC << 32) / octeon_get_io_clock_rate();
+		cvmx_write_csr(CVMX_MIO_PTP_CLOCK_COMP, clock_comp);
+		pr_info("PTP Clock: Using sclk reference at %lld Hz\n",
+			(NSEC_PER_SEC << 32) / clock_comp);
+	} else {
+		/* The clock is already programmed to use an external GPIO */
+		clock_comp = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_COMP);
+		pr_info("PTP Clock: Using GPIO %d at %lld Hz\n",
+			ptp_clock_cfg.s.ext_clk_in,
+			(NSEC_PER_SEC << 32) / clock_comp);
+	}
+
+	/* Enable the clock if it wasn't done already */
+	if (!ptp_clock_cfg.s.ptp_en) {
+		ptp_clock_cfg.s.ptp_en = 1;
+		cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock_cfg.u64);
+	}
+
+	/* Add PTP as a high quality clocksource with nano second granularity */
+	clocksource_ptp_clock.rating = 400;
+	clocksource_register_hz(&clocksource_ptp_clock, NSEC_PER_SEC);
+	return 0;
+}
+arch_initcall(ptp_clock_init);
-- 
1.7.5.4

