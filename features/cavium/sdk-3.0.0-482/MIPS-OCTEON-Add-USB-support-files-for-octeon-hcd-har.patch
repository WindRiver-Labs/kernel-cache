From cc914514d811160824562c53a4160aa2ee7b3d22 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 29 Aug 2012 16:22:05 -0700
Subject: [PATCH 156/337] MIPS: OCTEON: Add USB support files for octeon-hcd
 hardware.

Based On SDK 3.0.0-482

These are needed by the following driver glue patch.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile     |    2 +
 arch/mips/cavium-octeon/executive/cvmx-usb.c   | 3035 ++++++++++++++++++++++++
 arch/mips/cavium-octeon/octeon-irq.c           |    8 +-
 arch/mips/cavium-octeon/octeon-platform.c      |    1 +
 arch/mips/include/asm/octeon/cvmx-usb.h        | 1076 +++++++++
 arch/mips/include/asm/octeon/cvmx-usbcx-defs.h | 1693 +++++++++++++
 arch/mips/include/asm/octeon/cvmx-usbnx-defs.h | 1205 ++++++++++
 drivers/usb/host/Kconfig                       |    8 +
 drivers/usb/host/Makefile                      |    1 +
 drivers/usb/host/octeon-hcd.c                  |  883 +++++++
 10 files changed, 7910 insertions(+), 2 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-usb.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-usb.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
 create mode 100644 drivers/usb/host/octeon-hcd.c

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index b22929c..1a49a79 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -23,3 +23,5 @@ obj-y += cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 obj-y += cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
+
+obj-$(CONFIG_USB_OCTEON_HCD) += cvmx-usb.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-usb.c b/arch/mips/cavium-octeon/executive/cvmx-usb.c
new file mode 100644
index 0000000..dc05e9d
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-usb.c
@@ -0,0 +1,3035 @@
+/***********************license start***************
+ * Author: Cavium, Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * "cvmx-usb.c" defines a set of low level USB functions to help
+ * developers create Octeon USB drivers for various operating
+ * systems. These functions provide a generic API to the Octeon
+ * USB blocks, hiding the internal hardware specific
+ * operations.
+ *
+ */
+#include <linux/export.h>
+#include <linux/prefetch.h>
+
+#include <asm/octeon/octeon.h>
+//#include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-sysinfo.h>
+#include <asm/octeon/cvmx-usbnx-defs.h>
+#include <asm/octeon/cvmx-usbcx-defs.h>
+#include <asm/octeon/cvmx-usb.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-board.h>
+//#include <asm/octeon/cvmx-swap.h>
+#if 0
+   /* Do not use cvmx-error.h for now. When the cvmx-error.h is properly
+    * ported, remove the above #if 0, and all #ifdef __CVMX_ERROR_H__ within
+    * this file */
+#include <asm/octeon/cvmx-error.h>
+#endif
+
+#define cvmx_unlikely unlikely
+#define cvmx_likely likely
+#define cvmx_wait_usec udelay
+#define cvmx_le16_to_cpu le16_to_cpu
+
+#define CVMX_PREFETCH(_A,_B) prefetch(((u8*)(_A)) + _B)
+#define CVMX_PREFETCH0  prefetch
+
+#define MAX_RETRIES         3	/* Maximum number of times to retry failed transactions */
+#define MAX_PIPES           32	/* Maximum number of pipes that can be open at once */
+#define MAX_TRANSACTIONS    256	/* Maximum number of outstanding transactions across all pipes */
+#define MAX_CHANNELS        8	/* Maximum number of hardware channels supported by the USB block */
+#define MAX_USB_ADDRESS     127	/* The highest valid USB device address */
+#define MAX_USB_ENDPOINT    15	/* The highest valid USB endpoint number */
+#define MAX_USB_HUB_PORT    15	/* The highest valid port number on a hub */
+#define MAX_TRANSFER_BYTES  ((1<<19)-1)	/* The low level hardware can transfer a maximum of this number of bytes in each transfer. The field is 19 bits wide */
+#define MAX_TRANSFER_PACKETS ((1<<10)-1)	/* The low level hardware can transfer a maximum of this number of packets in each transfer. The field is 10 bits wide */
+#define ALLOW_CSR_DECODES   0	/* CSR decoding when CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS is set
+				   enlarges the code a lot. This define overrides the ability to do CSR
+				   decoding since it isn't necessary 99% of the time. Change this to a
+				   one if you need CSR decoding */
+
+/* These defines disable the normal read and write csr. This is so I can add
+    extra debug stuff to the usb specific version and I won't use the normal
+    version by mistake */
+#define cvmx_read_csr use_cvmx_usb_read_csr64_instead_of_cvmx_read_csr
+#define cvmx_write_csr use_cvmx_usb_write_csr64_instead_of_cvmx_write_csr
+
+typedef enum {
+	__CVMX_USB_TRANSACTION_FLAGS_IN_USE = 1 << 16,
+} cvmx_usb_transaction_flags_t;
+
+/**
+ * Logical transactions may take numerous low level
+ * transactions, especially when splits are concerned. This
+ * enum represents all of the possible stages a transaction can
+ * be in. Note that split completes are always even. This is so
+ * the NAK handler can backup to the previous low level
+ * transaction with a simple clearing of bit 0.
+ */
+typedef enum {
+	CVMX_USB_STAGE_NON_CONTROL,
+	CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_SETUP,
+	CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_DATA,
+	CVMX_USB_STAGE_DATA_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_STATUS,
+	CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE,
+} cvmx_usb_stage_t;
+
+/**
+ * This structure describes each pending USB transaction
+ * regardless of type. These are linked together to form a list
+ * of pending requests for a pipe.
+ */
+typedef struct cvmx_usb_transaction {
+	struct cvmx_usb_transaction *prev;
+					/**< Transaction before this one in the pipe */
+	struct cvmx_usb_transaction *next;
+					/**< Transaction after this one in the pipe */
+	cvmx_usb_transfer_t type;	/**< Type of transaction, duplicated of the pipe */
+	cvmx_usb_transaction_flags_t flags;
+					/**< State flags for this transaction */
+	uint64_t buffer;		/**< User's physical buffer address to read/write */
+	int buffer_length;		/**< Size of the user's buffer in bytes */
+	uint64_t control_header;	/**< For control transactions, physical address of the 8 byte standard header */
+	int iso_start_frame;		/**< For ISO transactions, the starting frame number */
+	int iso_number_packets;		/**< For ISO transactions, the number of packets in the request */
+	cvmx_usb_iso_packet_t *iso_packets;
+					/**< For ISO transactions, the sub packets in the request */
+	int xfersize;
+	int pktcnt;
+	int retries;
+	int actual_bytes;		/**< Actual bytes transfer for this transaction */
+	cvmx_usb_stage_t stage;		/**< For control transactions, the current stage */
+	cvmx_usb_callback_func_t callback;
+					/**< User's callback function when complete */
+	void *callback_data;		/**< User's data */
+} cvmx_usb_transaction_t;
+
+/**
+ * A pipe represents a virtual connection between Octeon and some
+ * USB device. It contains a list of pending request to the device.
+ */
+typedef struct cvmx_usb_pipe {
+	struct cvmx_usb_pipe *prev;	/**< Pipe before this one in the list */
+	struct cvmx_usb_pipe *next;	/**< Pipe after this one in the list */
+	cvmx_usb_transaction_t *head;	/**< The first pending transaction */
+	cvmx_usb_transaction_t *tail;	/**< The last pending transaction */
+	uint64_t interval;		/**< For periodic pipes, the interval between packets in frames */
+	uint64_t next_tx_frame;		/**< The next frame this pipe is allowed to transmit on */
+	cvmx_usb_pipe_flags_t flags;	/**< State flags for this pipe */
+	cvmx_usb_speed_t device_speed;	/**< Speed of device connected to this pipe */
+	cvmx_usb_transfer_t transfer_type;
+					/**< Type of transaction supported by this pipe */
+	cvmx_usb_direction_t transfer_dir;
+					/**< IN or OUT. Ignored for Control */
+	int multi_count;		/**< Max packet in a row for the device */
+	uint16_t max_packet;		/**< The device's maximum packet size in bytes */
+	uint8_t device_addr;		/**< USB device address at other end of pipe */
+	uint8_t endpoint_num;		/**< USB endpoint number at other end of pipe */
+	uint8_t hub_device_addr;	/**< Hub address this device is connected to */
+	uint8_t hub_port;		/**< Hub port this device is connected to */
+	uint8_t pid_toggle;		/**< This toggles between 0/1 on every packet send to track the data pid needed */
+	uint8_t channel;		/**< Hardware DMA channel for this pipe */
+	int8_t split_sc_frame;		/**< The low order bits of the frame number the split complete should be sent on */
+} cvmx_usb_pipe_t;
+
+typedef struct {
+	cvmx_usb_pipe_t *head;		/**< Head of the list, or NULL if empty */
+	cvmx_usb_pipe_t *tail;		/**< Tail if the list, or NULL if empty */
+} cvmx_usb_pipe_list_t;
+
+typedef struct {
+	struct {
+		int channel;
+		int size;
+		uint64_t address;
+	} entry[MAX_CHANNELS + 1];
+	int head;
+	int tail;
+} cvmx_usb_tx_fifo_t;
+
+/**
+ * The state of the USB block is stored in this structure
+ */
+typedef struct {
+	int init_flags;			/**< Flags passed to initialize */
+	int index;			/**< Which USB block this is for */
+	int idle_hardware_channels;	/**< Bit set for every idle hardware channel */
+	union cvmx_usbcx_hprt usbcx_hprt;	/**< Stored port status so we don't need to read a CSR to determine splits */
+	cvmx_usb_pipe_t *pipe_for_channel[MAX_CHANNELS];/**< Map channels to pipes */
+	cvmx_usb_transaction_t *free_transaction_head;	/**< List of free transactions head */
+	cvmx_usb_transaction_t *free_transaction_tail;	/**< List of free transactions tail */
+	cvmx_usb_pipe_t pipe[MAX_PIPES];		/**< Storage for pipes */
+	cvmx_usb_transaction_t transaction[MAX_TRANSACTIONS];	/**< Storage for transactions */
+	cvmx_usb_callback_func_t callback[__CVMX_USB_CALLBACK_END];
+								/**< User global callbacks */
+	void *callback_data[__CVMX_USB_CALLBACK_END];		/**< User data for each callback */
+	int indent;			/**< Used by debug output to indent functions */
+	cvmx_usb_port_status_t port_status;
+					/**< Last port status used for change notification */
+	cvmx_usb_pipe_list_t free_pipes;/**< List of all pipes that are currently closed */
+	cvmx_usb_pipe_list_t idle_pipes;/**< List of open pipes that have no transactions */
+	cvmx_usb_pipe_list_t active_pipes[4];
+					  /**< Active pipes indexed by transfer type */
+	uint64_t frame_number;		/**< Increments every SOF interrupt for time keeping */
+	cvmx_usb_transaction_t *active_split;
+					  /**< Points to the current active split, or NULL */
+	cvmx_usb_tx_fifo_t periodic;
+	cvmx_usb_tx_fifo_t nonperiodic;
+} cvmx_usb_internal_state_t;
+
+/* This macro logs out whenever a function is called if debugging is on */
+#define CVMX_USB_LOG_CALLED() \
+    if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \
+        cvmx_dprintf("%*s%s: called\n", 2*usb->indent++, "", __func__);
+
+/* This macro logs out each function parameter if debugging is on */
+#define CVMX_USB_LOG_PARAM(format, param) \
+    if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \
+        cvmx_dprintf("%*s%s: param %s = " format "\n", 2*usb->indent, "", __func__, #param, param);
+
+/* This macro logs out when a function returns a value */
+#define CVMX_USB_RETURN(v)                                              \
+    do {                                                                \
+        typeof(v) r = v;                                                \
+        if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \
+            cvmx_dprintf("%*s%s: returned %s(%d)\n", 2*--usb->indent, "", __func__, #v, r); \
+        return r;                                                       \
+    } while (0);
+
+/* This macro logs out when a function doesn't return a value */
+#define CVMX_USB_RETURN_NOTHING()                                       \
+    do {                                                                \
+        if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \
+            cvmx_dprintf("%*s%s: returned\n", 2*--usb->indent, "", __func__); \
+        return;                                                         \
+    } while (0);
+
+/* This macro spins on a field waiting for it to reach a value */
+#define CVMX_WAIT_FOR_FIELD32(address, type, field, op, value, timeout_usec)\
+    ({int result;                                                       \
+    do {                                                                \
+        uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec *     \
+                            octeon_get_clock_rate() / 1000000;  \
+        type c;                                                         \
+        while (1)                                                       \
+        {                                                               \
+            c.u32 = __cvmx_usb_read_csr32(usb, address);                \
+            if (c.s.field op (value)) {                                 \
+                result = 0;                                             \
+                break;                                                  \
+            } else if (cvmx_get_cycle() > done) {                       \
+                result = -1;                                            \
+                break;                                                  \
+            } else                                                      \
+                cvmx_wait(100);                                         \
+        }                                                               \
+    } while (0);                                                        \
+    result;})
+
+/* This macro logically sets a single field in a CSR. It does the sequence
+    read, modify, and write */
+#define USB_SET_FIELD32(address, type, field, value)\
+    do {                                            \
+        type c;                                     \
+        c.u32 = __cvmx_usb_read_csr32(usb, address);\
+        c.s.field = value;                          \
+        __cvmx_usb_write_csr32(usb, address, c.u32);\
+    } while (0)
+
+/* Returns the IO address to push/pop stuff data from the FIFOs */
+#define USB_FIFO_ADDRESS(channel, usb_index) (CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
+
+/**
+ * @INTERNAL
+ * Read a USB 32bit CSR. It performs the necessary address swizzle
+ * for 32bit CSRs and logs the value in a readable format if
+ * debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to read
+ *
+ * Returns Result of the read
+ */
+static inline uint32_t __cvmx_usb_read_csr32(cvmx_usb_internal_state_t * usb, uint64_t address)
+{
+	uint32_t result = cvmx_read64_uint32(address ^ 4);
+	return result;
+}
+
+/**
+ * @INTERNAL
+ * Write a USB 32bit CSR. It performs the necessary address
+ * swizzle for 32bit CSRs and logs the value in a readable format
+ * if debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to write
+ * @value:   Value to write
+ */
+static inline void __cvmx_usb_write_csr32(cvmx_usb_internal_state_t * usb, uint64_t address, uint32_t value)
+{
+	cvmx_write64_uint32(address ^ 4, value);
+	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+}
+
+/**
+ * @INTERNAL
+ * Read a USB 64bit CSR. It logs the value in a readable format if
+ * debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to read
+ *
+ * Returns Result of the read
+ */
+static inline uint64_t __cvmx_usb_read_csr64(cvmx_usb_internal_state_t * usb, uint64_t address)
+{
+	uint64_t result = cvmx_read64_uint64(address);
+	return result;
+}
+
+/**
+ * @INTERNAL
+ * Write a USB 64bit CSR. It logs the value in a readable format
+ * if debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to write
+ * @value:   Value to write
+ */
+static inline void __cvmx_usb_write_csr64(cvmx_usb_internal_state_t * usb, uint64_t address, uint64_t value)
+{
+	cvmx_write64_uint64(address, value);
+}
+
+/**
+ * @INTERNAL
+ * Utility function to convert complete codes into strings
+ *
+ * @complete_code:
+ *               Code to convert
+ *
+ * Returns Human readable string
+ */
+static const char *__cvmx_usb_complete_to_string(cvmx_usb_complete_t complete_code)
+{
+	switch (complete_code) {
+	case CVMX_USB_COMPLETE_SUCCESS:
+		return "SUCCESS";
+	case CVMX_USB_COMPLETE_SHORT:
+		return "SHORT";
+	case CVMX_USB_COMPLETE_CANCEL:
+		return "CANCEL";
+	case CVMX_USB_COMPLETE_ERROR:
+		return "ERROR";
+	case CVMX_USB_COMPLETE_STALL:
+		return "STALL";
+	case CVMX_USB_COMPLETE_XACTERR:
+		return "XACTERR";
+	case CVMX_USB_COMPLETE_DATATGLERR:
+		return "DATATGLERR";
+	case CVMX_USB_COMPLETE_BABBLEERR:
+		return "BABBLEERR";
+	case CVMX_USB_COMPLETE_FRAMEERR:
+		return "FRAMEERR";
+	}
+	return "Update __cvmx_usb_complete_to_string";
+}
+
+/**
+ * @INTERNAL
+ * Return non zero if this pipe connects to a non HIGH speed
+ * device through a high speed hub.
+ *
+ * @usb:    USB block this access is for
+ * @pipe:   Pipe to check
+ *
+ * Returns Non zero if we need to do split transactions
+ */
+static inline int __cvmx_usb_pipe_needs_split(cvmx_usb_internal_state_t * usb, cvmx_usb_pipe_t * pipe)
+{
+	return ((pipe->device_speed != CVMX_USB_SPEED_HIGH) && (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH));
+}
+
+/**
+ * @INTERNAL
+ * Trivial utility function to return the correct PID for a pipe
+ *
+ * @pipe:   pipe to check
+ *
+ * Returns PID for pipe
+ */
+static inline int __cvmx_usb_get_data_pid(cvmx_usb_pipe_t * pipe)
+{
+	if (pipe->pid_toggle)
+		return 2;	/* Data1 */
+	else
+		return 0;	/* Data0 */
+}
+
+#if 0
+/**
+ * Return the number of USB ports supported by this Octeon
+ * chip. If the chip doesn't support USB, or is not supported
+ * by this API, a zero will be returned. Most Octeon chips
+ * support one usb port, but some support two ports.
+ * cvmx_usb_initialize() must be called on independent
+ * cvmx_usb_state_t structures.
+ *
+ * This utilizes cvmx_helper_board_usb_get_num_ports()
+ * to get any board specific variations.
+ *
+ * Returns Number of port, zero if usb isn't supported
+ */
+int cvmx_usb_get_num_ports(void)
+{
+	int arch_ports = 0;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
+		arch_ports = 2;
+	else if (OCTEON_IS_MODEL(OCTEON_CN50XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN31XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
+		arch_ports = 1;
+	else
+		arch_ports = 0;
+
+	return __cvmx_helper_board_usb_get_num_ports(arch_ports);
+}
+
+EXPORT_SYMBOL(cvmx_usb_get_num_ports);
+#endif
+
+/**
+ * @INTERNAL
+ * Allocate a usb transaction for use
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns Transaction or NULL
+ */
+static inline cvmx_usb_transaction_t *__cvmx_usb_alloc_transaction(cvmx_usb_internal_state_t * usb)
+{
+	cvmx_usb_transaction_t *t;
+	t = usb->free_transaction_head;
+	if (t) {
+		usb->free_transaction_head = t->next;
+		if (!usb->free_transaction_head)
+			usb->free_transaction_tail = NULL;
+	} else if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+		cvmx_dprintf("%s: Failed to allocate a transaction\n", __func__);
+	if (t) {
+		memset(t, 0, sizeof(*t));
+		t->flags = __CVMX_USB_TRANSACTION_FLAGS_IN_USE;
+	}
+	return t;
+}
+
+/**
+ * @INTERNAL
+ * Free a usb transaction
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @transaction:
+ *               Transaction to free
+ */
+static inline void __cvmx_usb_free_transaction(cvmx_usb_internal_state_t * usb, cvmx_usb_transaction_t * transaction)
+{
+	transaction->flags = 0;
+	transaction->prev = NULL;
+	transaction->next = NULL;
+	if (usb->free_transaction_tail)
+		usb->free_transaction_tail->next = transaction;
+	else
+		usb->free_transaction_head = transaction;
+	usb->free_transaction_tail = transaction;
+}
+
+/**
+ * @INTERNAL
+ * Add a pipe to the tail of a list
+ * @list:   List to add pipe to
+ * @pipe:   Pipe to add
+ */
+static inline void __cvmx_usb_append_pipe(cvmx_usb_pipe_list_t * list, cvmx_usb_pipe_t * pipe)
+{
+	pipe->next = NULL;
+	pipe->prev = list->tail;
+	if (list->tail)
+		list->tail->next = pipe;
+	else
+		list->head = pipe;
+	list->tail = pipe;
+}
+
+/**
+ * @INTERNAL
+ * Remove a pipe from a list
+ * @list:   List to remove pipe from
+ * @pipe:   Pipe to remove
+ */
+static inline void __cvmx_usb_remove_pipe(cvmx_usb_pipe_list_t * list, cvmx_usb_pipe_t * pipe)
+{
+	if (list->head == pipe) {
+		list->head = pipe->next;
+		pipe->next = NULL;
+		if (list->head)
+			list->head->prev = NULL;
+		else
+			list->tail = NULL;
+	} else if (list->tail == pipe) {
+		list->tail = pipe->prev;
+		list->tail->next = NULL;
+		pipe->prev = NULL;
+	} else {
+		pipe->prev->next = pipe->next;
+		pipe->next->prev = pipe->prev;
+		pipe->prev = NULL;
+		pipe->next = NULL;
+	}
+}
+
+/**
+ * Initialize a USB port for use. This must be called before any
+ * other access to the Octeon USB port is made. The port starts
+ * off in the disabled state.
+ *
+ * @state:  Pointer to an empty cvmx_usb_state_t structure
+ *               that will be populated by the initialize call.
+ *               This structure is then passed to all other USB
+ *               functions.
+ * @usb_port_number:
+ *               Which Octeon USB port to initialize.
+ * @flags:  Flags to control hardware initialization. See
+ *               cvmx_usb_initialize_flags_t for the flag
+ *               definitions. Some flags are mandatory.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_initialize(cvmx_usb_state_t * state, int usb_port_number, cvmx_usb_initialize_flags_t flags)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	usb->init_flags = flags;
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", usb_port_number);
+	CVMX_USB_LOG_PARAM("0x%x", flags);
+
+	/* Make sure that state is large enough to store the internal state */
+	if (sizeof(*state) < sizeof(*usb))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	/* At first allow 0-1 for the usb port number */
+	if ((usb_port_number < 0) || (usb_port_number > 1))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	/* For all chips except 52XX there is only one port */
+	if (!OCTEON_IS_MODEL(OCTEON_CN52XX) && (usb_port_number > 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	/* Try to determine clock type automatically */
+	if ((flags & (CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI | CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND)) == 0) {
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	}
+
+	memset(usb, 0, sizeof(*usb));
+	usb->init_flags = flags;
+
+	/* Initialize the USB state structure */
+	{
+		int i;
+		usb->index = usb_port_number;
+
+		/* Initialize the transaction double linked list */
+		usb->free_transaction_head = NULL;
+		usb->free_transaction_tail = NULL;
+		for (i = 0; i < MAX_TRANSACTIONS; i++)
+			__cvmx_usb_free_transaction(usb, usb->transaction + i);
+		for (i = 0; i < MAX_PIPES; i++)
+			__cvmx_usb_append_pipe(&usb->free_pipes, usb->pipe + i);
+	}
+
+	/* Power On Reset and PHY Initialization */
+
+	/* 1. Wait for DCOK to assert (nothing to do) */
+	/* 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
+	   USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0 */
+	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hrst = 0;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hclk_rst = 0;
+	usbn_clk_ctl.s.enable = 0;
+	/* 2b. Select the USB reference clock/crystal parameters by writing
+	   appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON] */
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {
+		/* The USB port uses 12/24/48MHz 2.5V board clock
+		   source at USB_XO. USB_XI should be tied to GND.
+		   Most Octeon evaluation boards require this setting */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+			usbn_clk_ctl.cn31xx.p_rclk = 1;	/* From CN31XX,CN30XX manual */
+			usbn_clk_ctl.cn31xx.p_xenbn = 0;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
+			usbn_clk_ctl.cn56xx.p_rtype = 2;	/* From CN56XX,CN50XX manual */
+		else
+			usbn_clk_ctl.cn52xx.p_rtype = 1;	/* From CN52XX manual */
+
+		switch (flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
+			usbn_clk_ctl.s.p_c_sel = 0;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:
+			usbn_clk_ctl.s.p_c_sel = 1;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:
+			usbn_clk_ctl.s.p_c_sel = 2;
+			break;
+		}
+	} else {
+		/* The USB port uses a 12MHz crystal as clock source
+		   at USB_XO and USB_XI */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+			usbn_clk_ctl.cn31xx.p_rclk = 1;	/* From CN31XX,CN30XX manual */
+			usbn_clk_ctl.cn31xx.p_xenbn = 1;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
+			usbn_clk_ctl.cn56xx.p_rtype = 0;	/* From CN56XX,CN50XX manual */
+		else
+			usbn_clk_ctl.cn52xx.p_rtype = 0;	/* From CN52XX manual */
+
+		usbn_clk_ctl.s.p_c_sel = 0;
+	}
+	/* 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and
+	   setting USBN0/1_CLK_CTL[ENABLE] = 1.  Divide the core clock down such
+	   that USB is as close as possible to 125Mhz */
+	{
+		int divisor = (octeon_get_io_clock_rate() + 125000000 - 1) / 125000000;
+		if (divisor < 4)	/* Lower than 4 doesn't seem to work properly */
+			divisor = 4;
+		usbn_clk_ctl.s.divide = divisor;
+		usbn_clk_ctl.s.divide2 = 0;
+	}
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
+	usbn_clk_ctl.s.hclk_rst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
+	cvmx_wait(64);
+	/* 3. Program the power-on reset field in the USBN clock-control register:
+	   USBN_CLK_CTL[POR] = 0 */
+	usbn_clk_ctl.s.por = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 4. Wait 1 ms for PHY clock to start */
+	cvmx_wait_usec(1000);
+	/* 5. Program the Reset input from automatic test equipment field in the
+	   USBP control and status register: USBN_USBP_CTL_STATUS[ATE_RESET] = 1 */
+	usbn_usbp_ctl_status.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index));
+	usbn_usbp_ctl_status.s.ate_reset = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index), usbn_usbp_ctl_status.u64);
+	/* 6. Wait 10 cycles */
+	cvmx_wait(10);
+	/* 7. Clear ATE_RESET field in the USBN clock-control register:
+	   USBN_USBP_CTL_STATUS[ATE_RESET] = 0 */
+	usbn_usbp_ctl_status.s.ate_reset = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index), usbn_usbp_ctl_status.u64);
+	/* 8. Program the PHY reset field in the USBN clock-control register:
+	   USBN_CLK_CTL[PRST] = 1 */
+	usbn_clk_ctl.s.prst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 9. Program the USBP control and status register to select host or
+	   device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
+	   device */
+	usbn_usbp_ctl_status.s.hst_mode = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index), usbn_usbp_ctl_status.u64);
+	/* 10. Wait 1 µs */
+	cvmx_wait_usec(1);
+	/* 11. Program the hreset_n field in the USBN clock-control register:
+	   USBN_CLK_CTL[HRST] = 1 */
+	usbn_clk_ctl.s.hrst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 12. Proceed to USB core initialization */
+	usbn_clk_ctl.s.enable = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	cvmx_wait_usec(1);
+
+	/* USB Core Initialization */
+
+	/* 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to
+	   determine USB core configuration parameters. */
+	/* Nothing needed */
+	/* 2. Program the following fields in the global AHB configuration
+	   register (USBC_GAHBCFG)
+	   DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode
+	   Burst length, USBC_GAHBCFG[HBSTLEN] = 0
+	   Nonperiodic TxFIFO empty level (slave mode only),
+	   USBC_GAHBCFG[NPTXFEMPLVL]
+	   Periodic TxFIFO empty level (slave mode only),
+	   USBC_GAHBCFG[PTXFEMPLVL]
+	   Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1 */
+	{
+		union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
+		/* Due to an errata, CN31XX doesn't support DMA */
+		if (OCTEON_IS_MODEL(OCTEON_CN31XX))
+			usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
+		usbcx_gahbcfg.u32 = 0;
+		usbcx_gahbcfg.s.dmaen = !(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			usb->idle_hardware_channels = 0x1;	/* Only use one channel with non DMA */
+		else if (OCTEON_IS_MODEL(OCTEON_CN5XXX))
+			usb->idle_hardware_channels = 0xf7;	/* CN5XXX have an errata with channel 3 */
+		else
+			usb->idle_hardware_channels = 0xff;
+		usbcx_gahbcfg.s.hbstlen = 0;
+		usbcx_gahbcfg.s.nptxfemplvl = 1;
+		usbcx_gahbcfg.s.ptxfemplvl = 1;
+		usbcx_gahbcfg.s.glblintrmsk = 1;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index), usbcx_gahbcfg.u32);
+	}
+	/* 3. Program the following fields in USBC_GUSBCFG register.
+	   HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
+	   ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0
+	   USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
+	   PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0 */
+	{
+		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
+		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index));
+		usbcx_gusbcfg.s.toutcal = 0;
+		usbcx_gusbcfg.s.ddrsel = 0;
+		usbcx_gusbcfg.s.usbtrdtim = 0x5;
+		usbcx_gusbcfg.s.phylpwrclksel = 0;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index), usbcx_gusbcfg.u32);
+	}
+	/* 4. The software must unmask the following bits in the USBC_GINTMSK
+	   register.
+	   OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
+	   Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1 */
+	{
+		union cvmx_usbcx_gintmsk usbcx_gintmsk;
+		int channel;
+
+		usbcx_gintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTMSK(usb->index));
+		usbcx_gintmsk.s.otgintmsk = 1;
+		usbcx_gintmsk.s.modemismsk = 1;
+		usbcx_gintmsk.s.hchintmsk = 1;
+		usbcx_gintmsk.s.sofmsk = 0;
+		/* We need RX FIFO interrupts if we don't have DMA */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			usbcx_gintmsk.s.rxflvlmsk = 1;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index), usbcx_gintmsk.u32);
+
+		/* Disable all channel interrupts. We'll enable them per channel later */
+		for (channel = 0; channel < 8; channel++)
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	}
+
+	{
+		/* Host Port Initialization */
+		if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+			cvmx_dprintf("%s: USB%d is in host mode\n", __func__, usb->index);
+
+		/* 1. Program the host-port interrupt-mask field to unmask,
+		   USBC_GINTMSK[PRTINT] = 1 */
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, prtintmsk, 1);
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, disconnintmsk, 1);
+		/* 2. Program the USBC_HCFG register to select full-speed host or
+		   high-speed host. */
+		{
+			union cvmx_usbcx_hcfg usbcx_hcfg;
+			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
+			usbcx_hcfg.s.fslssupp = 0;
+			usbcx_hcfg.s.fslspclksel = 0;
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
+		}
+		/* 3. Program the port power bit to drive VBUS on the USB,
+		   USBC_HPRT[PRTPWR] = 1 */
+		USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtpwr, 1);
+
+		/* Steps 4-15 from the manual are done later in the port enable */
+	}
+
+#ifdef __CVMX_ERROR_H__
+	cvmx_error_enable_group(CVMX_ERROR_GROUP_USB, usb->index);
+#endif
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+EXPORT_SYMBOL(cvmx_usb_initialize);
+
+/**
+ * Shutdown a USB port after a call to cvmx_usb_initialize().
+ * The port should be disabled with all pipes closed when this
+ * function is called.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_shutdown(cvmx_usb_state_t * state)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	/* Make sure all pipes are closed */
+	if (usb->idle_pipes.head ||
+	    usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS].head ||
+	    usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT].head || usb->active_pipes[CVMX_USB_TRANSFER_CONTROL].head || usb->active_pipes[CVMX_USB_TRANSFER_BULK].head)
+		CVMX_USB_RETURN(CVMX_USB_BUSY);
+
+#ifdef __CVMX_ERROR_H__
+	cvmx_error_disable_group(CVMX_ERROR_GROUP_USB, usb->index);
+#endif
+
+	/* Disable the clocks and put them in power on reset */
+	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.enable = 1;
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hclk_rst = 1;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hrst = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_shutdown);
+
+/**
+ * Enable a USB port. After this call succeeds, the USB port is
+ * online and servicing requests.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_enable(cvmx_usb_state_t * state)
+{
+	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+
+	/* If the port is already enabled the just return. We don't need to do
+	   anything */
+	if (usb->usbcx_hprt.s.prtena)
+		CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+
+	/* If there is nothing plugged into the port then fail immediately */
+	if (!usb->usbcx_hprt.s.prtconnsts) {
+		if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+			cvmx_dprintf("%s: USB%d Nothing plugged into the port\n", __func__, usb->index);
+		CVMX_USB_RETURN(CVMX_USB_TIMEOUT);
+	}
+
+	/* Program the port reset bit to start the reset process */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 1);
+
+	/* Wait at least 50ms (high speed), or 10ms (full speed) for the reset
+	   process to complete. */
+	cvmx_wait_usec(50000);
+
+	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 0);
+
+	/* Wait for the USBC_HPRT[PRTENA]. */
+	if (CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtena, ==, 1, 100000)) {
+		if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+			cvmx_dprintf("%s: Timeout waiting for the port to finish reset\n", __func__);
+		CVMX_USB_RETURN(CVMX_USB_TIMEOUT);
+	}
+
+	/* Read the port speed field to get the enumerated speed, USBC_HPRT[PRTSPD]. */
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+		cvmx_dprintf("%s: USB%d is in %s speed mode\n", __func__, usb->index,
+			     (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH) ? "high" : (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_FULL) ? "full" : "low");
+
+	usbcx_ghwcfg3.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GHWCFG3(usb->index));
+
+	/* 13. Program the USBC_GRXFSIZ register to select the size of the receive
+	   FIFO (25%). */
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), union cvmx_usbcx_grxfsiz, rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
+	/* 14. Program the USBC_GNPTXFSIZ register to select the size and the
+	   start address of the non- periodic transmit FIFO for nonperiodic
+	   transactions (50%). */
+	{
+		union cvmx_usbcx_gnptxfsiz siz;
+		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
+		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
+		siz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), siz.u32);
+	}
+	/* 15. Program the USBC_HPTXFSIZ register to select the size and start
+	   address of the periodic transmit FIFO for periodic transactions (25%). */
+	{
+		union cvmx_usbcx_hptxfsiz siz;
+		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
+		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
+		siz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), siz.u32);
+	}
+	/* Flush all FIFOs */
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfnum, 0x10);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfflsh, ==, 0, 100);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, rxfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, rxfflsh, ==, 0, 100);
+
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_enable);
+
+/**
+ * Disable a USB port. After this call the USB port will not
+ * generate data transfers and will not generate events.
+ * Transactions in process will fail and call their
+ * associated callbacks.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_disable(cvmx_usb_state_t * state)
+{
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	/* Disable the port */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtena, 1);
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_disable);
+
+/**
+ * Get the current state of the USB port. Use this call to
+ * determine if the usb port has anything connected, is enabled,
+ * or has some sort of error condition. The return value of this
+ * call has "changed" bits to signal of the value of some fields
+ * have changed between calls. These "changed" fields are based
+ * on the last call to cvmx_usb_set_status(). In order to clear
+ * them, you must update the status through cvmx_usb_set_status().
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns Port status information
+ */
+cvmx_usb_port_status_t cvmx_usb_get_status(cvmx_usb_state_t * state)
+{
+	union cvmx_usbcx_hprt usbc_hprt;
+	cvmx_usb_port_status_t result;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	memset(&result, 0, sizeof(result));
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	result.port_enabled = usbc_hprt.s.prtena;
+	result.port_over_current = usbc_hprt.s.prtovrcurract;
+	result.port_powered = usbc_hprt.s.prtpwr;
+	result.port_speed = usbc_hprt.s.prtspd;
+	result.connected = usbc_hprt.s.prtconnsts;
+	result.connect_change = (result.connected != usb->port_status.connected);
+
+	if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))
+		cvmx_dprintf("%*s%s: returned port enabled=%d, over_current=%d, powered=%d, speed=%d, connected=%d, connect_change=%d\n",
+			     2 * (--usb->indent), "", __func__,
+			     result.port_enabled, result.port_over_current, result.port_powered, result.port_speed, result.connected, result.connect_change);
+	return result;
+}
+
+EXPORT_SYMBOL(cvmx_usb_get_status);
+
+/**
+ * Set the current state of the USB port. The status is used as
+ * a reference for the "changed" bits returned by
+ * cvmx_usb_get_status(). Other than serving as a reference, the
+ * status passed to this function is not used. No fields can be
+ * changed through this call.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @port_status:
+ *               Port status to set, most like returned by cvmx_usb_get_status()
+ */
+void cvmx_usb_set_status(cvmx_usb_state_t * state, cvmx_usb_port_status_t port_status)
+{
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	usb->port_status = port_status;
+	CVMX_USB_RETURN_NOTHING();
+}
+
+EXPORT_SYMBOL(cvmx_usb_set_status);
+
+/**
+ * @INTERNAL
+ * Convert a USB transaction into a handle
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @transaction:
+ *               Transaction to get handle for
+ *
+ * Returns Handle
+ */
+static inline int __cvmx_usb_get_submit_handle(cvmx_usb_internal_state_t * usb, cvmx_usb_transaction_t * transaction)
+{
+	return ((unsigned long)transaction - (unsigned long)usb->transaction) / sizeof(*transaction);
+}
+
+/**
+ * @INTERNAL
+ * Convert a USB pipe into a handle
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe:   Pipe to get handle for
+ *
+ * Returns Handle
+ */
+static inline int __cvmx_usb_get_pipe_handle(cvmx_usb_internal_state_t * usb, cvmx_usb_pipe_t * pipe)
+{
+	return ((unsigned long)pipe - (unsigned long)usb->pipe) / sizeof(*pipe);
+}
+
+/**
+ * Open a virtual pipe between the host and a USB device. A pipe
+ * must be opened before data can be transferred between a device
+ * and Octeon.
+ *
+ * @state:      USB device state populated by
+ *                   cvmx_usb_initialize().
+ * @flags:      Optional pipe flags defined in
+ *                   cvmx_usb_pipe_flags_t.
+ * @device_addr:
+ *                   USB device address to open the pipe to
+ *                   (0-127).
+ * @endpoint_num:
+ *                   USB endpoint number to open the pipe to
+ *                   (0-15).
+ * @device_speed:
+ *                   The speed of the device the pipe is going
+ *                   to. This must match the device's speed,
+ *                   which may be different than the port speed.
+ * @max_packet: The maximum packet length the device can
+ *                   transmit/receive (low speed=0-8, full
+ *                   speed=0-1023, high speed=0-1024). This value
+ *                   comes from the standard endpoint descriptor
+ *                   field wMaxPacketSize bits <10:0>.
+ * @transfer_type:
+ *                   The type of transfer this pipe is for.
+ * @transfer_dir:
+ *                   The direction the pipe is in. This is not
+ *                   used for control pipes.
+ * @interval:   For ISOCHRONOUS and INTERRUPT transfers,
+ *                   this is how often the transfer is scheduled
+ *                   for. All other transfers should specify
+ *                   zero. The units are in frames (8000/sec at
+ *                   high speed, 1000/sec for full speed).
+ * @multi_count:
+ *                   For high speed devices, this is the maximum
+ *                   allowed number of packet per microframe.
+ *                   Specify zero for non high speed devices. This
+ *                   value comes from the standard endpoint descriptor
+ *                   field wMaxPacketSize bits <12:11>.
+ * @hub_device_addr:
+ *                   Hub device address this device is connected
+ *                   to. Devices connected directly to Octeon
+ *                   use zero. This is only used when the device
+ *                   is full/low speed behind a high speed hub.
+ *                   The address will be of the high speed hub,
+ *                   not and full speed hubs after it.
+ * @hub_port:   Which port on the hub the device is
+ *                   connected. Use zero for devices connected
+ *                   directly to Octeon. Like hub_device_addr,
+ *                   this is only used for full/low speed
+ *                   devices behind a high speed hub.
+ *
+ * Returns A non negative value is a pipe handle. Negative
+ *         values are failure codes from cvmx_usb_status_t.
+ */
+int cvmx_usb_open_pipe(cvmx_usb_state_t * state, cvmx_usb_pipe_flags_t flags,
+		       int device_addr, int endpoint_num,
+		       cvmx_usb_speed_t device_speed, int max_packet,
+		       cvmx_usb_transfer_t transfer_type, cvmx_usb_direction_t transfer_dir, int interval, int multi_count, int hub_device_addr, int hub_port)
+{
+	cvmx_usb_pipe_t *pipe;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("0x%x", flags);
+	CVMX_USB_LOG_PARAM("%d", device_addr);
+	CVMX_USB_LOG_PARAM("%d", endpoint_num);
+	CVMX_USB_LOG_PARAM("%d", device_speed);
+	CVMX_USB_LOG_PARAM("%d", max_packet);
+	CVMX_USB_LOG_PARAM("%d", transfer_type);
+	CVMX_USB_LOG_PARAM("%d", transfer_dir);
+	CVMX_USB_LOG_PARAM("%d", interval);
+	CVMX_USB_LOG_PARAM("%d", multi_count);
+	CVMX_USB_LOG_PARAM("%d", hub_device_addr);
+	CVMX_USB_LOG_PARAM("%d", hub_port);
+
+	if (cvmx_unlikely((device_addr < 0) || (device_addr > MAX_USB_ADDRESS)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((endpoint_num < 0) || (endpoint_num > MAX_USB_ENDPOINT)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(device_speed > CVMX_USB_SPEED_LOW))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((max_packet <= 0) || (max_packet > 1024)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(transfer_type > CVMX_USB_TRANSFER_INTERRUPT))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((transfer_dir != CVMX_USB_DIRECTION_OUT) && (transfer_dir != CVMX_USB_DIRECTION_IN)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(interval < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((transfer_type == CVMX_USB_TRANSFER_CONTROL) && interval))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(multi_count < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((device_speed != CVMX_USB_SPEED_HIGH) && (multi_count != 0)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((hub_device_addr < 0) || (hub_device_addr > MAX_USB_ADDRESS)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Find a free pipe */
+	pipe = usb->free_pipes.head;
+	if (!pipe)
+		CVMX_USB_RETURN(CVMX_USB_NO_MEMORY);
+	__cvmx_usb_remove_pipe(&usb->free_pipes, pipe);
+	pipe->flags = flags | __CVMX_USB_PIPE_FLAGS_OPEN;
+	if ((device_speed == CVMX_USB_SPEED_HIGH) && (transfer_dir == CVMX_USB_DIRECTION_OUT) && (transfer_type == CVMX_USB_TRANSFER_BULK))
+		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+	pipe->device_addr = device_addr;
+	pipe->endpoint_num = endpoint_num;
+	pipe->device_speed = device_speed;
+	pipe->max_packet = max_packet;
+	pipe->transfer_type = transfer_type;
+	pipe->transfer_dir = transfer_dir;
+	/* All pipes use interval to rate limit NAK processing. Force an interval
+	   if one wasn't supplied */
+	if (!interval)
+		interval = 1;
+	if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		pipe->interval = interval * 8;
+		/* Force start splits to be schedule on uFrame 0 */
+		pipe->next_tx_frame = ((usb->frame_number + 7) & ~7) + pipe->interval;
+	} else {
+		pipe->interval = interval;
+		pipe->next_tx_frame = usb->frame_number + pipe->interval;
+	}
+	pipe->multi_count = multi_count;
+	pipe->hub_device_addr = hub_device_addr;
+	pipe->hub_port = hub_port;
+	pipe->pid_toggle = 0;
+	pipe->split_sc_frame = -1;
+	__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
+
+	/* We don't need to tell the hardware about this pipe yet since
+	   it doesn't have any submitted requests */
+
+	CVMX_USB_RETURN(__cvmx_usb_get_pipe_handle(usb, pipe));
+}
+
+EXPORT_SYMBOL(cvmx_usb_open_pipe);
+
+/**
+ * @INTERNAL
+ * Poll the RX FIFOs and remove data as needed. This function is only used
+ * in non DMA mode. It is very important that this function be called quickly
+ * enough to prevent FIFO overflow.
+ *
+ * @usb:     USB device state populated by
+ *                cvmx_usb_initialize().
+ */
+static void __cvmx_usb_poll_rx_fifo(cvmx_usb_internal_state_t * usb)
+{
+	union cvmx_usbcx_grxstsph rx_status;
+	int channel;
+	int bytes;
+	uint64_t address;
+	uint32_t *ptr;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+
+	rx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GRXSTSPH(usb->index));
+	/* Only read data if IN data is there */
+	if (rx_status.s.pktsts != 2)
+		CVMX_USB_RETURN_NOTHING();
+	/* Check if no data is available */
+	if (!rx_status.s.bcnt)
+		CVMX_USB_RETURN_NOTHING();
+
+	channel = rx_status.s.chnum;
+	bytes = rx_status.s.bcnt;
+	if (!bytes)
+		CVMX_USB_RETURN_NOTHING();
+
+	/* Get where the DMA engine would have written this data */
+	address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8);
+	ptr = cvmx_phys_to_ptr(address);
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8, address + bytes);
+
+	/* Loop writing the FIFO data for this packet into memory */
+	while (bytes > 0) {
+		*ptr++ = __cvmx_usb_read_csr32(usb, USB_FIFO_ADDRESS(channel, usb->index));
+		bytes -= 4;
+	}
+	CVMX_SYNCW;
+
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * Fill the TX hardware fifo with data out of the software
+ * fifos
+ *
+ * @usb:       USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @fifo:      Software fifo to use
+ * @available: Amount of space in the hardware fifo
+ *
+ * Returns Non zero if the hardware fifo was too small and needs
+ *         to be serviced again.
+ */
+static int __cvmx_usb_fill_tx_hw(cvmx_usb_internal_state_t * usb, cvmx_usb_tx_fifo_t * fifo, int available)
+{
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%p", fifo);
+	CVMX_USB_LOG_PARAM("%d", available);
+
+	/* We're done either when there isn't anymore space or the software FIFO
+	   is empty */
+	while (available && (fifo->head != fifo->tail)) {
+		int i = fifo->tail;
+		const uint32_t *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
+		uint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel, usb->index) ^ 4;
+		int words = available;
+
+		/* Limit the amount of data to waht the SW fifo has */
+		if (fifo->entry[i].size <= available) {
+			words = fifo->entry[i].size;
+			fifo->tail++;
+			if (fifo->tail > MAX_CHANNELS)
+				fifo->tail = 0;
+		}
+
+		/* Update the next locations and counts */
+		available -= words;
+		fifo->entry[i].address += words * 4;
+		fifo->entry[i].size -= words;
+
+		/* Write the HW fifo data. The read every three writes is due
+		   to an errata on CN3XXX chips */
+		while (words > 3) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+			words -= 3;
+		}
+		cvmx_write64_uint32(csr_address, *ptr++);
+		if (--words) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			if (--words)
+				cvmx_write64_uint32(csr_address, *ptr++);
+		}
+		cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+	}
+	CVMX_USB_RETURN(fifo->head != fifo->tail);
+}
+
+/**
+ * Check the hardware FIFOs and fill them as needed
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ */
+static void __cvmx_usb_poll_tx_fifo(cvmx_usb_internal_state_t * usb)
+{
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+
+	if (usb->periodic.head != usb->periodic.tail) {
+		union cvmx_usbcx_hptxsts tx_status;
+		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic, tx_status.s.ptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 0);
+	}
+
+	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
+		union cvmx_usbcx_gnptxsts tx_status;
+		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic, tx_status.s.nptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 0);
+	}
+
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Fill the TX FIFO with an outgoing packet
+ *
+ * @usb:     USB device state populated by
+ *                cvmx_usb_initialize().
+ * @channel: Channel number to get packet from
+ */
+static void __cvmx_usb_fill_tx_fifo(cvmx_usb_internal_state_t * usb, int channel)
+{
+	union cvmx_usbcx_hccharx hcchar;
+	union cvmx_usbcx_hcspltx usbc_hcsplt;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	cvmx_usb_tx_fifo_t *fifo;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%d", channel);
+
+	/* We only need to fill data on outbound channels */
+	hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
+		CVMX_USB_RETURN_NOTHING();
+
+	/* OUT Splits only have data on the start and not the complete */
+	usbc_hcsplt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index));
+	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
+		CVMX_USB_RETURN_NOTHING();
+
+	/* Find out how many bytes we need to fill and convert it into 32bit words */
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+	if (!usbc_hctsiz.s.xfersize)
+		CVMX_USB_RETURN_NOTHING();
+
+	if ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) || (hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
+		fifo = &usb->periodic;
+	else
+		fifo = &usb->nonperiodic;
+
+	fifo->entry[fifo->head].channel = channel;
+	fifo->entry[fifo->head].address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel * 8);
+	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize + 3) >> 2;
+	fifo->head++;
+	if (fifo->head > MAX_CHANNELS)
+		fifo->head = 0;
+
+	__cvmx_usb_poll_tx_fifo(usb);
+
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Perform channel specific setup for Control transactions. All
+ * the generic stuff will already have been done in
+ * __cvmx_usb_start_channel()
+ *
+ * @usb:     USB device state populated by
+ *                cvmx_usb_initialize().
+ * @channel: Channel to setup
+ * @pipe:    Pipe for control transaction
+ */
+static void __cvmx_usb_start_channel_control(cvmx_usb_internal_state_t * usb, int channel, cvmx_usb_pipe_t * pipe)
+{
+	cvmx_usb_transaction_t *transaction = pipe->head;
+	cvmx_usb_control_header_t *header = cvmx_phys_to_ptr(transaction->control_header);
+	int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+	int packets_to_transfer;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%d", channel);
+	CVMX_USB_LOG_PARAM("%p", pipe);
+
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	switch (transaction->stage) {
+	case CVMX_USB_STAGE_NON_CONTROL:
+	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+		cvmx_dprintf("%s: ERROR - Non control stage\n", __func__);
+		break;
+	case CVMX_USB_STAGE_SETUP:
+		usbc_hctsiz.s.pid = 3;	/* Setup */
+		bytes_to_transfer = sizeof(*header);
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
+		/* Setup send the control header instead of the buffer data. The
+		   buffer data will be used in the next stage */
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel * 8, transaction->control_header);
+		break;
+	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = 3;	/* Setup */
+		bytes_to_transfer = 0;
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_DATA:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (header->s.request_type & 0x80)
+				bytes_to_transfer = 0;
+			else if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+		}
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir, ((header->s.request_type & 0x80) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT));
+		break;
+	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		if (!(header->s.request_type & 0x80))
+			bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir, ((header->s.request_type & 0x80) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_STATUS:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ? CVMX_USB_DIRECTION_OUT : CVMX_USB_DIRECTION_IN));
+		break;
+	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ? CVMX_USB_DIRECTION_OUT : CVMX_USB_DIRECTION_IN));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	}
+
+	/* Make sure the transfer never exceeds the byte limit of the hardware.
+	   Further bytes will be sent as continued transactions */
+	if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+		/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
+		bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+		bytes_to_transfer *= pipe->max_packet;
+	}
+
+	/* Calculate the number of packets to transfer. If the length is zero
+	   we still need to transfer one packet */
+	packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+	if (packets_to_transfer == 0)
+		packets_to_transfer = 1;
+	else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+		/* Limit to one packet when not using DMA. Channels must be restarted
+		   between every packet for IN transactions, so there is no reason to
+		   do multiple packets in a row */
+		packets_to_transfer = 1;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+		/* Limit the number of packet and data transferred to what the
+		   hardware can handle */
+		packets_to_transfer = MAX_TRANSFER_PACKETS;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	}
+
+	usbc_hctsiz.s.xfersize = bytes_to_transfer;
+	usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Start a channel to perform the pipe's head transaction
+ *
+ * @usb:     USB device state populated by
+ *                cvmx_usb_initialize().
+ * @channel: Channel to setup
+ * @pipe:    Pipe to start
+ */
+static void __cvmx_usb_start_channel(cvmx_usb_internal_state_t * usb, int channel, cvmx_usb_pipe_t * pipe)
+{
+	cvmx_usb_transaction_t *transaction = pipe->head;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%d", channel);
+	CVMX_USB_LOG_PARAM("%p", pipe);
+
+	if (cvmx_unlikely((usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS) || (pipe->flags & CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS)))
+		cvmx_dprintf("%s: Channel %d started. Pipe %d transaction %d stage %d\n",
+			     __func__, channel, __cvmx_usb_get_pipe_handle(usb, pipe), __cvmx_usb_get_submit_handle(usb, transaction), transaction->stage);
+
+	/* Make sure all writes to the DMA region get flushed */
+	CVMX_SYNCW;
+
+	/* Attach the channel to the pipe */
+	usb->pipe_for_channel[channel] = pipe;
+	pipe->channel = channel;
+	pipe->flags |= __CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/* Mark this channel as in use */
+	usb->idle_hardware_channels &= ~(1 << channel);
+
+	/* Enable the channel interrupt bits */
+	{
+		union cvmx_usbcx_hcintx usbc_hcint;
+		union cvmx_usbcx_hcintmskx usbc_hcintmsk;
+		union cvmx_usbcx_haintmsk usbc_haintmsk;
+
+		/* Clear all channel status bits */
+		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index), usbc_hcint.u32);
+
+		usbc_hcintmsk.u32 = 0;
+		usbc_hcintmsk.s.chhltdmsk = 1;
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+			/* Channels need these extra interrupts when we aren't in DMA mode */
+			usbc_hcintmsk.s.datatglerrmsk = 1;
+			usbc_hcintmsk.s.frmovrunmsk = 1;
+			usbc_hcintmsk.s.bblerrmsk = 1;
+			usbc_hcintmsk.s.xacterrmsk = 1;
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				/* Splits don't generate xfercompl, so we need ACK and NYET */
+				usbc_hcintmsk.s.nyetmsk = 1;
+				usbc_hcintmsk.s.ackmsk = 1;
+			}
+			usbc_hcintmsk.s.nakmsk = 1;
+			usbc_hcintmsk.s.stallmsk = 1;
+			usbc_hcintmsk.s.xfercomplmsk = 1;
+		}
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), usbc_hcintmsk.u32);
+
+		/* Enable the channel interrupt to propagate */
+		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index));
+		usbc_haintmsk.s.haintmsk |= 1 << channel;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index), usbc_haintmsk.u32);
+	}
+
+	/* Setup the locations the DMA engines use  */
+	{
+		uint64_t dma_address = transaction->buffer + transaction->actual_bytes;
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			dma_address = transaction->buffer + transaction->iso_packets[0].offset + transaction->actual_bytes;
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel * 8, dma_address);
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8, dma_address);
+	}
+
+	/* Setup both the size of the transfer and the SPLIT characteristics */
+	{
+		union cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0 };
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0 };
+		int packets_to_transfer;
+		int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+
+		/* ISOCHRONOUS transactions store each individual transfer size in the
+		   packet structure, not the global buffer_length */
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			bytes_to_transfer = transaction->iso_packets[0].length - transaction->actual_bytes;
+
+		/* We need to do split transactions when we are talking to non high
+		   speed devices that are behind a high speed hub */
+		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/* On the start split phase (stage is even) record the frame number we
+			   will need to send the split complete. We only store the lower two bits
+			   since the time ahead can only be two frames */
+			if ((transaction->stage & 1) == 0) {
+				if (transaction->type == CVMX_USB_TRANSFER_BULK)
+					pipe->split_sc_frame = (usb->frame_number + 1) & 0x7f;
+				else
+					pipe->split_sc_frame = (usb->frame_number + 2) & 0x7f;
+			} else
+				pipe->split_sc_frame = -1;
+
+			usbc_hcsplt.s.spltena = 1;
+			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
+			usbc_hcsplt.s.prtaddr = pipe->hub_port;
+			usbc_hcsplt.s.compsplt = (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
+
+			/* SPLIT transactions can only ever transmit one data packet so
+			   limit the transfer size to the max packet size */
+			if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+
+			/* ISOCHRONOUS OUT splits are unique in that they limit
+			   data transfers to 188 byte chunks representing the
+			   begin/middle/end of the data or all */
+			if (!usbc_hcsplt.s.compsplt && (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) && (pipe->transfer_type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+				/* Clear the split complete frame number as there isn't going
+				   to be a split complete */
+				pipe->split_sc_frame = -1;
+				/* See if we've started this transfer and sent data */
+				if (transaction->actual_bytes == 0) {
+					/* Nothing sent yet, this is either a begin or the
+					   entire payload */
+					if (bytes_to_transfer <= 188)
+						usbc_hcsplt.s.xactpos = 3;	/* Entire payload in one go */
+					else
+						usbc_hcsplt.s.xactpos = 2;	/* First part of payload */
+				} else {
+					/* Continuing the previous data, we must either be
+					   in the middle or at the end */
+					if (bytes_to_transfer <= 188)
+						usbc_hcsplt.s.xactpos = 1;	/* End of payload */
+					else
+						usbc_hcsplt.s.xactpos = 0;	/* Middle of payload */
+				}
+				/* Again, the transfer size is limited to 188 bytes */
+				if (bytes_to_transfer > 188)
+					bytes_to_transfer = 188;
+			}
+		}
+
+		/* Make sure the transfer never exceeds the byte limit of the hardware.
+		   Further bytes will be sent as continued transactions */
+		if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+			/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
+			bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+			bytes_to_transfer *= pipe->max_packet;
+		}
+
+		/* Calculate the number of packets to transfer. If the length is zero
+		   we still need to transfer one packet */
+		packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+		if (packets_to_transfer == 0)
+			packets_to_transfer = 1;
+		else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+			/* Limit to one packet when not using DMA. Channels must be restarted
+			   between every packet for IN transactions, so there is no reason to
+			   do multiple packets in a row */
+			packets_to_transfer = 1;
+			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+		} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+			/* Limit the number of packet and data transferred to what the
+			   hardware can handle */
+			packets_to_transfer = MAX_TRANSFER_PACKETS;
+			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+		}
+
+		usbc_hctsiz.s.xfersize = bytes_to_transfer;
+		usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+		/* Update the DATA0/DATA1 toggle */
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		/* High speed pipes may need a hardware ping before they start */
+		if (pipe->flags & __CVMX_USB_PIPE_FLAGS_NEED_PING)
+			usbc_hctsiz.s.dopng = 1;
+
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index), usbc_hcsplt.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+	}
+
+	/* Setup the Host Channel Characteristics Register */
+	{
+		union cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0 };
+
+		/* Set the startframe odd/even properly. This is only used for periodic */
+		usbc_hcchar.s.oddfrm = usb->frame_number & 1;
+
+		/* Set the number of back to back packets allowed by this endpoint.
+		   Split transactions interpret "ec" as the number of immediate
+		   retries of failure. These retries happen too quickly, so we
+		   disable these entirely for splits */
+		if (__cvmx_usb_pipe_needs_split(usb, pipe))
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count < 1)
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count > 3)
+			usbc_hcchar.s.ec = 3;
+		else
+			usbc_hcchar.s.ec = pipe->multi_count;
+
+		/* Set the rest of the endpoint specific settings */
+		usbc_hcchar.s.devaddr = pipe->device_addr;
+		usbc_hcchar.s.eptype = transaction->type;
+		usbc_hcchar.s.lspddev = (pipe->device_speed == CVMX_USB_SPEED_LOW);
+		usbc_hcchar.s.epdir = pipe->transfer_dir;
+		usbc_hcchar.s.epnum = pipe->endpoint_num;
+		usbc_hcchar.s.mps = pipe->max_packet;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+	}
+
+	/* Do transaction type specific fixups as needed */
+	switch (transaction->type) {
+	case CVMX_USB_TRANSFER_CONTROL:
+		__cvmx_usb_start_channel_control(usb, channel, pipe);
+		break;
+	case CVMX_USB_TRANSFER_BULK:
+	case CVMX_USB_TRANSFER_INTERRUPT:
+		break;
+	case CVMX_USB_TRANSFER_ISOCHRONOUS:
+		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/* ISO transactions require different PIDs depending on direction
+			   and how many packets are needed */
+			if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+				if (pipe->multi_count < 2)	/* Need DATA0 */
+					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 0);
+				else	/* Need MDATA */
+					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 3);
+			}
+		}
+		break;
+	}
+	{
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index)) };
+		transaction->xfersize = usbc_hctsiz.s.xfersize;
+		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
+	}
+	/* Remeber when we start a split transaction */
+	if (__cvmx_usb_pipe_needs_split(usb, pipe))
+		usb->active_split = transaction;
+	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, chena, 1);
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+		__cvmx_usb_fill_tx_fifo(usb, channel);
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Find a pipe that is ready to be scheduled to hardware.
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @list:   Pipe list to search
+ * @current_frame:
+ *               Frame counter to use as a time reference.
+ *
+ * Returns Pipe or NULL if none are ready
+ */
+static cvmx_usb_pipe_t *__cvmx_usb_find_ready_pipe(cvmx_usb_internal_state_t * usb, cvmx_usb_pipe_list_t * list, uint64_t current_frame)
+{
+	cvmx_usb_pipe_t *pipe = list->head;
+	while (pipe) {
+		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && pipe->head &&
+		    (pipe->next_tx_frame <= current_frame) &&
+		    ((pipe->split_sc_frame == -1) || ((((int)current_frame - (int)pipe->split_sc_frame) & 0x7f) < 0x40)) &&
+		    (!usb->active_split || (usb->active_split == pipe->head))) {
+			CVMX_PREFETCH(pipe, 128);
+			CVMX_PREFETCH(pipe->head, 0);
+			return pipe;
+		}
+		pipe = pipe->next;
+	}
+	return NULL;
+}
+
+/**
+ * @INTERNAL
+ * Called whenever a pipe might need to be scheduled to the
+ * hardware.
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @is_sof: True if this schedule was called on a SOF interrupt.
+ */
+static void __cvmx_usb_schedule(cvmx_usb_internal_state_t * usb, int is_sof)
+{
+	int channel;
+	cvmx_usb_pipe_t *pipe;
+	int need_sof;
+	cvmx_usb_transfer_t ttype;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		/* Without DMA we need to be careful to not schedule something at the end of a frame and cause an overrun */
+		union cvmx_usbcx_hfnum hfnum = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index)) };
+		union cvmx_usbcx_hfir hfir = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFIR(usb->index)) };
+		if (hfnum.s.frrem < hfir.s.frint / 4)
+			goto done;
+	}
+
+	while (usb->idle_hardware_channels) {
+		/* Find an idle channel */
+		channel = fls(usb->idle_hardware_channels) - 1;
+		if (cvmx_unlikely(channel > 7)) {
+			if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO))
+				cvmx_dprintf("%s: Idle hardware channels has a channel higher than 7. This is wrong\n", __func__);
+			break;
+		}
+
+		/* Find a pipe needing service */
+		pipe = NULL;
+		if (is_sof) {
+			/* Only process periodic pipes on SOF interrupts. This way we are
+			   sure that the periodic data is sent in the beginning of the
+			   frame */
+			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS, usb->frame_number);
+			if (cvmx_likely(!pipe))
+				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT, usb->frame_number);
+		}
+		if (cvmx_likely(!pipe)) {
+			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_CONTROL, usb->frame_number);
+			if (cvmx_likely(!pipe))
+				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_BULK, usb->frame_number);
+		}
+		if (!pipe)
+			break;
+
+		CVMX_USB_LOG_PARAM("%d", channel);
+		CVMX_USB_LOG_PARAM("%p", pipe);
+
+		if (cvmx_unlikely((usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS) || (pipe->flags & CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS))) {
+			cvmx_usb_transaction_t *transaction = pipe->head;
+			const cvmx_usb_control_header_t *header = (transaction->control_header) ? cvmx_phys_to_ptr(transaction->control_header) : NULL;
+			const char *dir = (pipe->transfer_dir == CVMX_USB_DIRECTION_IN) ? "IN" : "OUT";
+			const char *type;
+			switch (pipe->transfer_type) {
+			case CVMX_USB_TRANSFER_CONTROL:
+				type = "SETUP";
+				if (!header) {
+					cvmx_dprintf("%s: fatal error (header == NULL)\n", __func__);
+					dir = "INVALID";
+				} else
+					dir = (header->s.request_type & 0x80) ? "IN" : "OUT";
+				break;
+			case CVMX_USB_TRANSFER_ISOCHRONOUS:
+				type = "ISOCHRONOUS";
+				break;
+			case CVMX_USB_TRANSFER_BULK:
+				type = "BULK";
+				break;
+			default:	/* CVMX_USB_TRANSFER_INTERRUPT */
+				type = "INTERRUPT";
+				break;
+			}
+			cvmx_dprintf("%s: Starting pipe %d, transaction %d on channel %d. %s %s len=%d header=0x%llx\n",
+				     __func__, __cvmx_usb_get_pipe_handle(usb, pipe),
+				     __cvmx_usb_get_submit_handle(usb, transaction),
+				     channel, type, dir, transaction->buffer_length, (header) ? (unsigned long long)header->u64 : 0ull);
+		}
+		__cvmx_usb_start_channel(usb, channel, pipe);
+	}
+
+done:
+	/* Only enable SOF interrupts when we have transactions pending in the
+	   future that might need to be scheduled */
+	need_sof = 0;
+	for (ttype = CVMX_USB_TRANSFER_CONTROL; ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
+		pipe = usb->active_pipes[ttype].head;
+		while (pipe) {
+			if (pipe->next_tx_frame > usb->frame_number) {
+				need_sof = 1;
+				break;
+			}
+			pipe = pipe->next;
+		}
+	}
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, sofmsk, need_sof);
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Call a user's callback for a specific reason.
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe:   Pipe the callback is for or NULL
+ * @transaction:
+ *               Transaction the callback is for or NULL
+ * @reason: Reason this callback is being called
+ * @complete_code:
+ *               Completion code for the transaction, if any
+ */
+static void __cvmx_usb_perform_callback(cvmx_usb_internal_state_t * usb,
+					cvmx_usb_pipe_t * pipe, cvmx_usb_transaction_t * transaction, cvmx_usb_callback_t reason, cvmx_usb_complete_t complete_code)
+{
+	cvmx_usb_callback_func_t callback = usb->callback[reason];
+	void *user_data = usb->callback_data[reason];
+	int submit_handle = -1;
+	int pipe_handle = -1;
+	int bytes_transferred = 0;
+
+	if (pipe)
+		pipe_handle = __cvmx_usb_get_pipe_handle(usb, pipe);
+
+	if (transaction) {
+		submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
+		bytes_transferred = transaction->actual_bytes;
+		/* Transactions are allowed to override the default callback */
+		if ((reason == CVMX_USB_CALLBACK_TRANSFER_COMPLETE) && transaction->callback) {
+			callback = transaction->callback;
+			user_data = transaction->callback_data;
+		}
+	}
+
+	if (!callback)
+		return;
+
+	if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS))
+		cvmx_dprintf("%*s%s: calling callback %p(usb=%p, complete_code=%s, "
+			     "pipe_handle=%d, submit_handle=%d, bytes_transferred=%d, user_data=%p);\n",
+			     2 * usb->indent, "", __func__, callback, usb, __cvmx_usb_complete_to_string(complete_code), pipe_handle, submit_handle, bytes_transferred, user_data);
+
+	callback((cvmx_usb_state_t *) usb, reason, complete_code, pipe_handle, submit_handle, bytes_transferred, user_data);
+
+	if (cvmx_unlikely(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS))
+		cvmx_dprintf("%*s%s: callback %p complete\n", 2 * usb->indent, "", __func__, callback);
+}
+
+/**
+ * @INTERNAL
+ * Signal the completion of a transaction and free it. The
+ * transaction will be removed from the pipe transaction list.
+ *
+ * @usb:    USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe:   Pipe the transaction is on
+ * @transaction:
+ *               Transaction that completed
+ * @complete_code:
+ *               Completion code
+ */
+static void __cvmx_usb_perform_complete(cvmx_usb_internal_state_t * usb, cvmx_usb_pipe_t * pipe, cvmx_usb_transaction_t * transaction, cvmx_usb_complete_t complete_code)
+{
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%p", pipe);
+	CVMX_USB_LOG_PARAM("%p", transaction);
+	CVMX_USB_LOG_PARAM("%d", complete_code);
+
+	/* If this was a split then clear our split in progress marker */
+	if (usb->active_split == transaction)
+		usb->active_split = NULL;
+
+	/* Isochronous transactions need extra processing as they might not be done
+	   after a single data transfer */
+	if (cvmx_unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+		/* Update the number of bytes transferred in this ISO packet */
+		transaction->iso_packets[0].length = transaction->actual_bytes;
+		transaction->iso_packets[0].status = complete_code;
+
+		/* If there are more ISOs pending and we succeeded, schedule the next
+		   one */
+		if ((transaction->iso_number_packets > 1) && (complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
+			transaction->actual_bytes = 0;	/* No bytes transferred for this packet as of yet */
+			transaction->iso_number_packets--;	/* One less ISO waiting to transfer */
+			transaction->iso_packets++;	/* Increment to the next location in our packet array */
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+			goto done;
+		}
+	}
+
+	/* Remove the transaction from the pipe list */
+	if (transaction->next)
+		transaction->next->prev = transaction->prev;
+	else
+		pipe->tail = transaction->prev;
+	if (transaction->prev)
+		transaction->prev->next = transaction->next;
+	else
+		pipe->head = transaction->next;
+	if (!pipe->head) {
+		__cvmx_usb_remove_pipe(usb->active_pipes + pipe->transfer_type, pipe);
+		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
+
+	}
+	__cvmx_usb_perform_callback(usb, pipe, transaction, CVMX_USB_CALLBACK_TRANSFER_COMPLETE, complete_code);
+	__cvmx_usb_free_transaction(usb, transaction);
+done:
+	CVMX_USB_RETURN_NOTHING();
+}
+
+/**
+ * @INTERNAL
+ * Submit a usb transaction to a pipe. Called for all types
+ * of transactions.
+ *
+ * @usb:
+ * @pipe_handle:
+ *                  Which pipe to submit to. Will be validated in this function.
+ * @type:      Transaction type
+ * @flags:     Flags for the transaction
+ * @buffer:    User buffer for the transaction
+ * @buffer_length:
+ *                  User buffer's length in bytes
+ * @control_header:
+ *                  For control transactions, the 8 byte standard header
+ * @iso_start_frame:
+ *                  For ISO transactions, the start frame
+ * @iso_number_packets:
+ *                  For ISO, the number of packet in the transaction.
+ * @iso_packets:
+ *                  A description of each ISO packet
+ * @callback:  User callback to call when the transaction completes
+ * @user_data: User's data for the callback
+ *
+ * Returns Submit handle or negative on failure. Matches the result
+ *         in the external API.
+ */
+static int __cvmx_usb_submit_transaction(cvmx_usb_internal_state_t * usb,
+					 int pipe_handle,
+					 cvmx_usb_transfer_t type,
+					 int flags,
+					 uint64_t buffer,
+					 int buffer_length,
+					 uint64_t control_header,
+					 int iso_start_frame, int iso_number_packets, cvmx_usb_iso_packet_t * iso_packets, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	int submit_handle;
+	cvmx_usb_transaction_t *transaction;
+	cvmx_usb_pipe_t *pipe = usb->pipe + pipe_handle;
+
+	CVMX_USB_LOG_CALLED();
+	if (cvmx_unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	/* Fail if the pipe isn't open */
+	if (cvmx_unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(pipe->transfer_type != type))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	transaction = __cvmx_usb_alloc_transaction(usb);
+	if (cvmx_unlikely(!transaction))
+		CVMX_USB_RETURN(CVMX_USB_NO_MEMORY);
+
+	transaction->type = type;
+	transaction->flags |= flags;
+	transaction->buffer = buffer;
+	transaction->buffer_length = buffer_length;
+	transaction->control_header = control_header;
+	transaction->iso_start_frame = iso_start_frame;	// FIXME: This is not used, implement it
+	transaction->iso_number_packets = iso_number_packets;
+	transaction->iso_packets = iso_packets;
+	transaction->callback = callback;
+	transaction->callback_data = user_data;
+	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
+		transaction->stage = CVMX_USB_STAGE_SETUP;
+	else
+		transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+
+	transaction->next = NULL;
+	if (pipe->tail) {
+		transaction->prev = pipe->tail;
+		transaction->prev->next = transaction;
+	} else {
+		if (pipe->next_tx_frame < usb->frame_number)
+			pipe->next_tx_frame = usb->frame_number + pipe->interval - (usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+		transaction->prev = NULL;
+		pipe->head = transaction;
+		__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
+		__cvmx_usb_append_pipe(usb->active_pipes + pipe->transfer_type, pipe);
+	}
+	pipe->tail = transaction;
+
+	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
+
+	/* We may need to schedule the pipe if this was the head of the pipe */
+	if (!transaction->prev)
+		__cvmx_usb_schedule(usb, 0);
+
+	CVMX_USB_RETURN(submit_handle);
+}
+
+/**
+ * Call to submit a USB Bulk transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+int cvmx_usb_submit_bulk(cvmx_usb_state_t * state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	int submit_handle;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	CVMX_USB_LOG_PARAM("0x%llx", (unsigned long long)buffer);
+	CVMX_USB_LOG_PARAM("%d", buffer_length);
+
+	/* Pipe handle checking is done later in a common place */
+	if (cvmx_unlikely(!buffer))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(buffer_length < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle, CVMX_USB_TRANSFER_BULK, 0,	/* flags */
+						      buffer, buffer_length, 0,	/* control_header */
+						      0,	/* iso_start_frame */
+						      0,	/* iso_number_packets */
+						      NULL,	/* iso_packets */
+						      callback, user_data);
+	CVMX_USB_RETURN(submit_handle);
+}
+
+EXPORT_SYMBOL(cvmx_usb_submit_bulk);
+
+/**
+ * Call to submit a USB Interrupt transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+int cvmx_usb_submit_interrupt(cvmx_usb_state_t * state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	int submit_handle;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	CVMX_USB_LOG_PARAM("0x%llx", (unsigned long long)buffer);
+	CVMX_USB_LOG_PARAM("%d", buffer_length);
+
+	/* Pipe handle checking is done later in a common place */
+	if (cvmx_unlikely(!buffer))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(buffer_length < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle, CVMX_USB_TRANSFER_INTERRUPT, 0,	/* flags */
+						      buffer, buffer_length, 0,	/* control_header */
+						      0,	/* iso_start_frame */
+						      0,	/* iso_number_packets */
+						      NULL,	/* iso_packets */
+						      callback, user_data);
+	CVMX_USB_RETURN(submit_handle);
+}
+
+EXPORT_SYMBOL(cvmx_usb_submit_interrupt);
+
+/**
+ * Call to submit a USB Control transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @control_header:
+ *                  USB 8 byte control header physical address.
+ *                  Note that this is NOT A POINTER, but the
+ *                  full 64bit physical address of the buffer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+int cvmx_usb_submit_control(cvmx_usb_state_t * state, int pipe_handle,
+			    uint64_t control_header, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	int submit_handle;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	cvmx_usb_control_header_t *header = cvmx_phys_to_ptr(control_header);
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	CVMX_USB_LOG_PARAM("0x%llx", (unsigned long long)control_header);
+	CVMX_USB_LOG_PARAM("0x%llx", (unsigned long long)buffer);
+	CVMX_USB_LOG_PARAM("%d", buffer_length);
+
+	/* Pipe handle checking is done later in a common place */
+	if (cvmx_unlikely(!control_header))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	/* Some drivers send a buffer with a zero length. God only knows why */
+	if (cvmx_unlikely(buffer && (buffer_length < 0)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(!buffer && (buffer_length != 0)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if ((header->s.request_type & 0x80) == 0)
+		buffer_length = cvmx_le16_to_cpu(header->s.length);
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle, CVMX_USB_TRANSFER_CONTROL, 0,	/* flags */
+						      buffer, buffer_length, control_header, 0,	/* iso_start_frame */
+						      0,	/* iso_number_packets */
+						      NULL,	/* iso_packets */
+						      callback, user_data);
+	CVMX_USB_RETURN(submit_handle);
+}
+
+EXPORT_SYMBOL(cvmx_usb_submit_control);
+
+/**
+ * Call to submit a USB Isochronous transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @start_frame:
+ *                  Number of frames into the future to schedule
+ *                  this transaction.
+ * @flags:     Flags to control the transfer. See
+ *                  cvmx_usb_isochronous_flags_t for the flag
+ *                  definitions.
+ * @number_packets:
+ *                  Number of sequential packets to transfer.
+ *                  "packets" is a pointer to an array of this
+ *                  many packet structures.
+ * @packets:   Description of each transfer packet as
+ *                  defined by cvmx_usb_iso_packet_t. The array
+ *                  pointed to here must stay valid until the
+ *                  complete callback is called.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+int cvmx_usb_submit_isochronous(cvmx_usb_state_t * state, int pipe_handle,
+				int start_frame, int flags,
+				int number_packets, cvmx_usb_iso_packet_t packets[], uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	int submit_handle;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	CVMX_USB_LOG_PARAM("%d", start_frame);
+	CVMX_USB_LOG_PARAM("0x%x", flags);
+	CVMX_USB_LOG_PARAM("%d", number_packets);
+	CVMX_USB_LOG_PARAM("%p", packets);
+	CVMX_USB_LOG_PARAM("0x%llx", (unsigned long long)buffer);
+	CVMX_USB_LOG_PARAM("%d", buffer_length);
+
+	/* Pipe handle checking is done later in a common place */
+	if (cvmx_unlikely(start_frame < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(flags & ~(CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT | CVMX_USB_ISOCHRONOUS_FLAGS_ASAP)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(number_packets < 1))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(!packets))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(!buffer))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(buffer_length < 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle, CVMX_USB_TRANSFER_ISOCHRONOUS, flags, buffer, buffer_length, 0,	/* control_header */
+						      start_frame, number_packets, packets, callback, user_data);
+	CVMX_USB_RETURN(submit_handle);
+}
+
+EXPORT_SYMBOL(cvmx_usb_submit_isochronous);
+
+/**
+ * Cancel one outstanding request in a pipe. Canceling a request
+ * can fail if the transaction has already completed before cancel
+ * is called. Even after a successful cancel call, it may take
+ * a frame or two for the cvmx_usb_poll() function to call the
+ * associated callback.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to cancel requests in.
+ * @submit_handle:
+ *               Handle to transaction to cancel, returned by the submit function.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_cancel(cvmx_usb_state_t * state, int pipe_handle, int submit_handle)
+{
+	cvmx_usb_transaction_t *transaction;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	cvmx_usb_pipe_t *pipe = usb->pipe + pipe_handle;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	CVMX_USB_LOG_PARAM("%d", submit_handle);
+
+	if (cvmx_unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely((submit_handle < 0) || (submit_handle >= MAX_TRANSACTIONS)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Fail if the pipe isn't open */
+	if (cvmx_unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	transaction = usb->transaction + submit_handle;
+
+	/* Fail if this transaction already completed */
+	if (cvmx_unlikely((transaction->flags & __CVMX_USB_TRANSACTION_FLAGS_IN_USE) == 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* If the transaction is the HEAD of the queue and scheduled. We need to
+	   treat it special */
+	if ((pipe->head == transaction) && (pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
+		union cvmx_usbcx_hccharx usbc_hcchar;
+
+		usb->pipe_for_channel[pipe->channel] = NULL;
+		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+		CVMX_SYNCW;
+
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
+		/* If the channel isn't enabled then the transaction already completed */
+		if (usbc_hcchar.s.chena) {
+			usbc_hcchar.s.chdis = 1;
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index), usbc_hcchar.u32);
+		}
+	}
+	__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_CANCEL);
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_cancel);
+
+/**
+ * Cancel all outstanding requests in a pipe. Logically all this
+ * does is call cvmx_usb_cancel() in a loop.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to cancel requests in.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_cancel_all(cvmx_usb_state_t * state, int pipe_handle)
+{
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	cvmx_usb_pipe_t *pipe = usb->pipe + pipe_handle;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	if (cvmx_unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Fail if the pipe isn't open */
+	if (cvmx_unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Simply loop through and attempt to cancel each transaction */
+	while (pipe->head) {
+		cvmx_usb_status_t result = cvmx_usb_cancel(state, pipe_handle,
+							   __cvmx_usb_get_submit_handle(usb, pipe->head));
+		if (cvmx_unlikely(result != CVMX_USB_SUCCESS))
+			CVMX_USB_RETURN(result);
+	}
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_cancel_all);
+
+/**
+ * Close a pipe created with cvmx_usb_open_pipe().
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to close.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t. CVMX_USB_BUSY is returned if the
+ *         pipe has outstanding transfers.
+ */
+cvmx_usb_status_t cvmx_usb_close_pipe(cvmx_usb_state_t * state, int pipe_handle)
+{
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	cvmx_usb_pipe_t *pipe = usb->pipe + pipe_handle;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", pipe_handle);
+	if (cvmx_unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Fail if the pipe isn't open */
+	if (cvmx_unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	/* Fail if the pipe has pending transactions */
+	if (cvmx_unlikely(pipe->head))
+		CVMX_USB_RETURN(CVMX_USB_BUSY);
+
+	pipe->flags = 0;
+	__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
+	__cvmx_usb_append_pipe(&usb->free_pipes, pipe);
+
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_close_pipe);
+
+/**
+ * Register a function to be called when various USB events occur.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @reason:    Which event to register for.
+ * @callback:  Function to call when the event occurs.
+ * @user_data: User data parameter to the function.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_register_callback(cvmx_usb_state_t * state, cvmx_usb_callback_t reason, cvmx_usb_callback_func_t callback, void *user_data)
+{
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+	CVMX_USB_LOG_PARAM("%d", reason);
+	CVMX_USB_LOG_PARAM("%p", callback);
+	CVMX_USB_LOG_PARAM("%p", user_data);
+	if (cvmx_unlikely(reason >= __CVMX_USB_CALLBACK_END))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+	if (cvmx_unlikely(!callback))
+		CVMX_USB_RETURN(CVMX_USB_INVALID_PARAM);
+
+	usb->callback[reason] = callback;
+	usb->callback_data[reason] = user_data;
+
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_register_callback);
+
+/**
+ * Get the current USB protocol level frame number. The frame
+ * number is always in the range of 0-0x7ff.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns USB frame number
+ */
+int cvmx_usb_get_frame_number(cvmx_usb_state_t * state)
+{
+	int frame_number;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+	union cvmx_usbcx_hfnum usbc_hfnum;
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	frame_number = usbc_hfnum.s.frnum;
+
+	CVMX_USB_RETURN(frame_number);
+}
+
+EXPORT_SYMBOL(cvmx_usb_get_frame_number);
+
+/**
+ * @INTERNAL
+ * Poll a channel for status
+ *
+ * @usb:     USB device
+ * @channel: Channel to poll
+ *
+ * Returns Zero on success
+ */
+static int __cvmx_usb_poll_channel(cvmx_usb_internal_state_t * usb, int channel)
+{
+	union cvmx_usbcx_hcintx usbc_hcint;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	union cvmx_usbcx_hccharx usbc_hcchar;
+	cvmx_usb_pipe_t *pipe;
+	cvmx_usb_transaction_t *transaction;
+	int bytes_this_transfer;
+	int bytes_in_last_packet;
+	int packets_processed;
+	int buffer_space_left;
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", usb);
+	CVMX_USB_LOG_PARAM("%d", channel);
+
+	/* Read the interrupt status bits for the channel */
+	usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
+
+#if 0
+	cvmx_dprintf("Channel %d%s%s%s%s%s%s%s%s%s%s%s\n", channel,
+		     (usbc_hcint.s.datatglerr) ? " DATATGLERR" : "",
+		     (usbc_hcint.s.frmovrun) ? " FRMOVRUN" : "",
+		     (usbc_hcint.s.bblerr) ? " BBLERR" : "",
+		     (usbc_hcint.s.xacterr) ? " XACTERR" : "",
+		     (usbc_hcint.s.nyet) ? " NYET" : "",
+		     (usbc_hcint.s.ack) ? " ACK" : "",
+		     (usbc_hcint.s.nak) ? " NAK" : "",
+		     (usbc_hcint.s.stall) ? " STALL" : "",
+		     (usbc_hcint.s.ahberr) ? " AHBERR" : "", (usbc_hcint.s.chhltd) ? " CHHLTD" : "", (usbc_hcint.s.xfercompl) ? " XFERCOMPL" : "");
+#endif
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+
+		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
+			/* There seems to be a bug in CN31XX which can cause interrupt
+			   IN transfers to get stuck until we do a write of HCCHARX
+			   without changing things */
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+			CVMX_USB_RETURN(0);
+		}
+
+		/* In non DMA mode the channels don't halt themselves. We need to
+		   manually disable channels that are left running */
+		if (!usbc_hcint.s.chhltd) {
+			if (usbc_hcchar.s.chena) {
+				union cvmx_usbcx_hcintmskx hcintmsk;
+				/* Disable all interrupts except CHHLTD */
+				hcintmsk.u32 = 0;
+				hcintmsk.s.chhltdmsk = 1;
+				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), hcintmsk.u32);
+				usbc_hcchar.s.chdis = 1;
+				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+				CVMX_USB_RETURN(0);
+			} else if (usbc_hcint.s.xfercompl) {
+				/* Successful IN/OUT with transfer complete. Channel halt isn't needed */
+			} else {
+				cvmx_dprintf("USB%d: Channel %d interrupt without halt\n", usb->index, channel);
+				CVMX_USB_RETURN(0);
+			}
+		}
+	} else {
+		/* There is are no interrupts that we need to process when the channel is
+		   still running */
+		if (!usbc_hcint.s.chhltd)
+			CVMX_USB_RETURN(0);
+	}
+
+	/* Disable the channel interrupts now that it is done */
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	usb->idle_hardware_channels |= (1 << channel);
+
+	/* Make sure this channel is tied to a valid pipe */
+	pipe = usb->pipe_for_channel[channel];
+	CVMX_PREFETCH(pipe, 0);
+	CVMX_PREFETCH(pipe, 128);
+	if (!pipe)
+		CVMX_USB_RETURN(0);
+	transaction = pipe->head;
+	CVMX_PREFETCH0(transaction);
+
+	/* Disconnect this pipe from the HW channel. Later the schedule function will
+	   figure out which pipe needs to go */
+	usb->pipe_for_channel[channel] = NULL;
+	pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/* Read the channel config info so we can figure out how much data
+	   transfered */
+	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	/* Calculating the number of bytes successfully transferred is dependent on
+	   the transfer direction */
+	packets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;
+	if (usbc_hcchar.s.epdir) {
+		/* IN transactions are easy. For every byte received the hardware
+		   decrements xfersize. All we need to do is subtract the current
+		   value of xfersize from its starting value and we know how many
+		   bytes were written to the buffer */
+		bytes_this_transfer = transaction->xfersize - usbc_hctsiz.s.xfersize;
+	} else {
+		/* OUT transaction don't decrement xfersize. Instead pktcnt is
+		   decremented on every successful packet send. The hardware does
+		   this when it receives an ACK, or NYET. If it doesn't
+		   receive one of these responses pktcnt doesn't change */
+		bytes_this_transfer = packets_processed * usbc_hcchar.s.mps;
+		/* The last packet may not be a full transfer if we didn't have
+		   enough data */
+		if (bytes_this_transfer > transaction->xfersize)
+			bytes_this_transfer = transaction->xfersize;
+	}
+	/* Figure out how many bytes were in the last packet of the transfer */
+	if (packets_processed)
+		bytes_in_last_packet = bytes_this_transfer - (packets_processed - 1) * usbc_hcchar.s.mps;
+	else
+		bytes_in_last_packet = bytes_this_transfer;
+
+	/* As a special case, setup transactions output the setup header, not
+	   the user's data. For this reason we don't count setup data as bytes
+	   transferred */
+	if ((transaction->stage == CVMX_USB_STAGE_SETUP) || (transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
+		bytes_this_transfer = 0;
+
+	/* Optional debug output */
+	if (cvmx_unlikely((usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS) || (pipe->flags & CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS)))
+		cvmx_dprintf("%s: Channel %d halted. Pipe %d transaction %d stage %d bytes=%d\n",
+			     __func__, channel, __cvmx_usb_get_pipe_handle(usb, pipe), __cvmx_usb_get_submit_handle(usb, transaction), transaction->stage, bytes_this_transfer);
+
+	/* Add the bytes transferred to the running total. It is important that
+	   bytes_this_transfer doesn't count any data that needs to be
+	   retransmitted */
+	transaction->actual_bytes += bytes_this_transfer;
+	if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+		buffer_space_left = transaction->iso_packets[0].length - transaction->actual_bytes;
+	else
+		buffer_space_left = transaction->buffer_length - transaction->actual_bytes;
+
+	/* We need to remember the PID toggle state for the next transaction. The
+	   hardware already updated it for the next transaction */
+	pipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);
+
+	/* For high speed bulk out, assume the next transaction will need to do a
+	   ping before proceeding. If this isn't true the ACK processing below
+	   will clear this flag */
+	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) && (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) && (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
+		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+	if (usbc_hcint.s.stall) {
+		/* STALL as a response means this transaction cannot be completed
+		   because the device can't process transactions. Tell the user. Any
+		   data that was transferred will be counted on the actual bytes
+		   transferred */
+		pipe->pid_toggle = 0;
+		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_STALL);
+	} else if (usbc_hcint.s.xacterr) {
+		/* We know at least one packet worked if we get a ACK or NAK. Reset the retry counter */
+		if (usbc_hcint.s.nak || usbc_hcint.s.ack)
+			transaction->retries = 0;
+		transaction->retries++;
+		if (transaction->retries > MAX_RETRIES) {
+			/* XactErr as a response means the device signaled something wrong with
+			   the transfer. For example, PID toggle errors cause these */
+			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_XACTERR);
+		} else {
+			/* If this was a split then clear our split in progress marker */
+			if (usb->active_split == transaction)
+				usb->active_split = NULL;
+			/* Rewind to the beginning of the transaction by anding off the
+			   split complete bit */
+			transaction->stage &= ~1;
+			pipe->split_sc_frame = -1;
+			pipe->next_tx_frame += pipe->interval;
+			if (pipe->next_tx_frame < usb->frame_number)
+				pipe->next_tx_frame = usb->frame_number + pipe->interval - (usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+		}
+	} else if (usbc_hcint.s.bblerr) {
+		/* Babble Error (BblErr) */
+		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_BABBLEERR);
+	} else if (usbc_hcint.s.datatglerr) {
+		/* We'll retry the exact same transaction again */
+		transaction->retries++;
+	} else if (usbc_hcint.s.nyet) {
+		/* NYET as a response is only allowed in three cases: as a response to
+		   a ping, as a response to a split transaction, and as a response to
+		   a bulk out. The ping case is handled by hardware, so we only have
+		   splits and bulk out */
+		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->retries = 0;
+			/* If there is more data to go then we need to try again. Otherwise
+			   this transaction is complete */
+			if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet))
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+		} else {
+			/* Split transactions retry the split complete 4 times then rewind
+			   to the start split and do the entire transactions again */
+			transaction->retries++;
+			if ((transaction->retries & 0x3) == 0) {
+				/* Rewind to the beginning of the transaction by anding off the
+				   split complete bit */
+				transaction->stage &= ~1;
+				pipe->split_sc_frame = -1;
+			}
+		}
+	} else if (usbc_hcint.s.ack) {
+		transaction->retries = 0;
+		/* The ACK bit can only be checked after the other error bits. This is
+		   because a multi packet transfer may succeed in a number of packets
+		   and then get a different response on the last packet. In this case
+		   both ACK and the last response bit will be set. If none of the
+		   other response bits is set, then the last packet must have been an
+		   ACK */
+
+		/* Since we got an ACK, we know we don't need to do a ping on this
+		   pipe */
+		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+		switch (transaction->type) {
+		case CVMX_USB_TRANSFER_CONTROL:
+			switch (transaction->stage) {
+			case CVMX_USB_STAGE_NON_CONTROL:
+			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+				/* This should be impossible */
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+				break;
+			case CVMX_USB_STAGE_SETUP:
+				pipe->pid_toggle = 1;
+				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+					transaction->stage = CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
+				else {
+					cvmx_usb_control_header_t *header = cvmx_phys_to_ptr(transaction->control_header);
+					if (header->s.length)
+						transaction->stage = CVMX_USB_STAGE_DATA;
+					else
+						transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+				{
+					cvmx_usb_control_header_t *header = cvmx_phys_to_ptr(transaction->control_header);
+					if (header->s.length)
+						transaction->stage = CVMX_USB_STAGE_DATA;
+					else
+						transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_DATA:
+				if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+					transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
+					/* For setup OUT data that are splits, the hardware
+					   doesn't appear to count transferred data. Here
+					   we manually update the data transferred */
+					if (!usbc_hcchar.s.epdir) {
+						if (buffer_space_left < pipe->max_packet)
+							transaction->actual_bytes += buffer_space_left;
+						else
+							transaction->actual_bytes += pipe->max_packet;
+					}
+				} else if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+					pipe->pid_toggle = 1;
+					transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+				if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+					pipe->pid_toggle = 1;
+					transaction->stage = CVMX_USB_STAGE_STATUS;
+				} else {
+					transaction->stage = CVMX_USB_STAGE_DATA;
+				}
+				break;
+			case CVMX_USB_STAGE_STATUS:
+				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+					transaction->stage = CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
+				else
+					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				break;
+			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				break;
+			}
+			break;
+		case CVMX_USB_TRANSFER_BULK:
+		case CVMX_USB_TRANSFER_INTERRUPT:
+			/* The only time a bulk transfer isn't complete when
+			   it finishes with an ACK is during a split transaction. For
+			   splits we need to continue the transfer if more data is
+			   needed */
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
+					transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+				else {
+					if (buffer_space_left && (bytes_in_last_packet == pipe->max_packet))
+						transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+					else {
+						if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
+							pipe->next_tx_frame += pipe->interval;
+						__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					}
+				}
+			} else {
+				if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+				    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) && (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) && (usbc_hcint.s.nak))
+					pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+				if (!buffer_space_left || (bytes_in_last_packet < pipe->max_packet)) {
+					if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
+						pipe->next_tx_frame += pipe->interval;
+					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				}
+			}
+			break;
+		case CVMX_USB_TRANSFER_ISOCHRONOUS:
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				/* ISOCHRONOUS OUT splits don't require a complete split stage.
+				   Instead they use a sequence of begin OUT splits to transfer
+				   the data 188 bytes at a time. Once the transfer is complete,
+				   the pipe sleeps until the next schedule interval */
+				if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+					/* If no space left or this wasn't a max size packet then
+					   this transfer is complete. Otherwise start it again
+					   to send the next 188 bytes */
+					if (!buffer_space_left || (bytes_this_transfer < 188)) {
+						pipe->next_tx_frame += pipe->interval;
+						__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					}
+				} else {
+					if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+						/* We are in the incoming data phase. Keep getting
+						   data until we run out of space or get a small
+						   packet */
+						if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+							pipe->next_tx_frame += pipe->interval;
+							__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+						}
+					} else
+						transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+				}
+			} else {
+				pipe->next_tx_frame += pipe->interval;
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+			}
+			break;
+		}
+	} else if (usbc_hcint.s.nak) {
+		/* If this was a split then clear our split in progress marker */
+		if (usb->active_split == transaction)
+			usb->active_split = NULL;
+		/* NAK as a response means the device couldn't accept the transaction,
+		   but it should be retried in the future. Rewind to the beginning of
+		   the transaction by anding off the split complete bit. Retry in the
+		   next interval */
+		transaction->retries = 0;
+		transaction->stage &= ~1;
+		pipe->next_tx_frame += pipe->interval;
+		if (pipe->next_tx_frame < usb->frame_number)
+			pipe->next_tx_frame = usb->frame_number + pipe->interval - (usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+	} else {
+		cvmx_usb_port_status_t port;
+		port = cvmx_usb_get_status((cvmx_usb_state_t *) usb);
+		if (port.port_enabled) {
+			/* We'll retry the exact same transaction again */
+			transaction->retries++;
+		} else {
+			/* We get channel halted interrupts with no result bits sets when the
+			   cable is unplugged */
+			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+		}
+	}
+	CVMX_USB_RETURN(0);
+}
+
+/**
+ * Poll the USB block for status and call all needed callback
+ * handlers. This function is meant to be called in the interrupt
+ * handler for the USB controller. It can also be called
+ * periodically in a loop for non-interrupt based operation.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+cvmx_usb_status_t cvmx_usb_poll(cvmx_usb_state_t * state)
+{
+	union cvmx_usbcx_hfnum usbc_hfnum;
+	union cvmx_usbcx_gintsts usbc_gintsts;
+	cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t *) state;
+
+	CVMX_PREFETCH(usb, 0);
+	CVMX_PREFETCH(usb, 1 * 128);
+	CVMX_PREFETCH(usb, 2 * 128);
+	CVMX_PREFETCH(usb, 3 * 128);
+	CVMX_PREFETCH(usb, 4 * 128);
+
+	CVMX_USB_LOG_CALLED();
+	CVMX_USB_LOG_PARAM("%p", state);
+
+	/* Update the frame counter */
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	if ((usb->frame_number & 0x3fff) > usbc_hfnum.s.frnum)
+		usb->frame_number += 0x4000;
+	usb->frame_number &= ~0x3fffull;
+	usb->frame_number |= usbc_hfnum.s.frnum;
+
+	/* Read the pending interrupts */
+	usbc_gintsts.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTSTS(usb->index));
+
+	/* Clear the interrupts now that we know about them */
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index), usbc_gintsts.u32);
+
+	if (usbc_gintsts.s.rxflvl) {
+		/* RxFIFO Non-Empty (RxFLvl)
+		   Indicates that there is at least one packet pending to be read
+		   from the RxFIFO. */
+		/* In DMA mode this is handled by hardware */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			__cvmx_usb_poll_rx_fifo(usb);
+	}
+	if (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {
+		/* Fill the Tx FIFOs when not in DMA mode */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			__cvmx_usb_poll_tx_fifo(usb);
+	}
+	if (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {
+		union cvmx_usbcx_hprt usbc_hprt;
+		/* Disconnect Detected Interrupt (DisconnInt)
+		   Asserted when a device disconnect is detected. */
+
+		/* Host Port Interrupt (PrtInt)
+		   The core sets this bit to indicate a change in port status of one
+		   of the O2P USB core ports in Host mode. The application must
+		   read the Host Port Control and Status (HPRT) register to
+		   determine the exact event that caused this interrupt. The
+		   application must clear the appropriate status bit in the Host Port
+		   Control and Status register to clear this bit. */
+
+		/* Call the user's port callback */
+		__cvmx_usb_perform_callback(usb, NULL, NULL, CVMX_USB_CALLBACK_PORT_CHANGED, CVMX_USB_COMPLETE_SUCCESS);
+		/* Clear the port change bits */
+		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.s.prtena = 0;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index), usbc_hprt.u32);
+	}
+	if (usbc_gintsts.s.hchint) {
+		/* Host Channels Interrupt (HChInt)
+		   The core sets this bit to indicate that an interrupt is pending on
+		   one of the channels of the core (in Host mode). The application
+		   must read the Host All Channels Interrupt (HAINT) register to
+		   determine the exact number of the channel on which the
+		   interrupt occurred, and then read the corresponding Host
+		   Channel-n Interrupt (HCINTn) register to determine the exact
+		   cause of the interrupt. The application must clear the
+		   appropriate status bit in the HCINTn register to clear this bit. */
+		union cvmx_usbcx_haint usbc_haint;
+		usbc_haint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINT(usb->index));
+		while (usbc_haint.u32) {
+			int channel;
+			channel = fls(usbc_haint.u32) - 1;
+			__cvmx_usb_poll_channel(usb, channel);
+			usbc_haint.u32 ^= 1 << channel;
+		}
+	}
+
+	__cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
+
+	CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+
+EXPORT_SYMBOL(cvmx_usb_poll);
diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index d3ad4c1..7cf01f2 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -1267,7 +1267,9 @@ static void __init octeon_irq_init_ciu(void)
 
 	ciu_node = of_find_compatible_node(NULL, NULL, "cavium,octeon-3860-ciu");
 	if (ciu_node) {
-		irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu_ops, NULL);
+		struct irq_domain *d;
+		d = irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu_ops, NULL);
+		irq_set_default_host(d);
 		of_node_put(ciu_node);
 	} else
 		pr_warning("Cannot find device node for cavium,octeon-3860-ciu.\n");
@@ -1727,7 +1729,9 @@ static void __init octeon_irq_init_ciu2(void)
 
 	ciu_node = of_find_compatible_node(NULL, NULL, "cavium,octeon-6880-ciu2");
 	if (ciu_node) {
-		irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu2_ops, NULL);
+		struct irq_domain *d;
+		d = irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu2_ops, NULL);
+		irq_set_default_host(d);
 		of_node_put(ciu_node);
 	} else
 		pr_warning("Cannot find device node for cavium,octeon-6880-ciu2.\n");
diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index ca10a72..bbe823b 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -69,6 +69,7 @@ device_initcall(octeon_rng_device_init);
 static struct of_device_id __initdata octeon_ids[] = {
 	{ .compatible = "simple-bus", },
 	{ .compatible = "cavium,octeon-6335-uctl", },
+	{ .compatible = "cavium,octeon-5750-usbn", },
 	{ .compatible = "cavium,octeon-3860-bootbus", },
 	{ .compatible = "cavium,mdio-mux", },
 	{ .compatible = "gpio-leds", },
diff --git a/arch/mips/include/asm/octeon/cvmx-usb.h b/arch/mips/include/asm/octeon/cvmx-usb.h
new file mode 100644
index 0000000..cf1edeb
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-usb.h
@@ -0,0 +1,1076 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * "cvmx-usb.h" defines a set of low level USB functions to help
+ * developers create Octeon USB drivers for various operating
+ * systems. These functions provide a generic API to the Octeon
+ * USB blocks, hiding the internal hardware specific
+ * operations.
+ *
+ * At a high level the device driver needs to:
+ *
+ * -# Call cvmx_usb_get_num_ports() to get the number of
+ *  supported ports.
+ * -# Call cvmx_usb_initialize() for each Octeon USB port.
+ * -# Enable the port using cvmx_usb_enable().
+ * -# Either periodically, or in an interrupt handler, call
+ *  cvmx_usb_poll() to service USB events.
+ * -# Manage pipes using cvmx_usb_open_pipe() and
+ *  cvmx_usb_close_pipe().
+ * -# Manage transfers using cvmx_usb_submit_*() and
+ *  cvmx_usb_cancel*().
+ * -# Shutdown USB on unload using cvmx_usb_shutdown().
+ *
+ * To monitor USB status changes, the device driver must use
+ * cvmx_usb_register_callback() to register for events that it
+ * is interested in. Below are a few hints on successfully
+ * implementing a driver on top of this API.
+ *
+ * <h2>Initialization</h2>
+ *
+ * When a driver is first loaded, it is normally not necessary
+ * to bring up the USB port completely. Most operating systems
+ * expect to initialize and enable the port in two independent
+ * steps. Normally an operating system will probe hardware,
+ * initialize anything found, and then enable the hardware.
+ *
+ * In the probe phase you should:
+ * -# Use cvmx_usb_get_num_ports() to determine the number of
+ *  USB port to be supported.
+ * -# Allocate space for a cvmx_usb_state_t structure for each
+ *  port.
+ * -# Tell the operating system about each port
+ *
+ * In the initialization phase you should:
+ * -# Use cvmx_usb_initialize() on each port.
+ * -# Do not call cvmx_usb_enable(). This leaves the USB port in
+ *  the disabled state until the operating system is ready.
+ *
+ * Finally, in the enable phase you should:
+ * -# Call cvmx_usb_enable() on the appropriate port.
+ * -# Note that some operating system use a RESET instead of an
+ *  enable call. To implement RESET, you should call
+ *  cvmx_usb_disable() followed by cvmx_usb_enable().
+ *
+ * <h2>Locking</h2>
+ *
+ * All of the functions in the cvmx-usb API assume exclusive
+ * access to the USB hardware and internal data structures. This
+ * means that the driver must provide locking as necessary.
+ *
+ * In the single CPU state it is normally enough to disable
+ * interrupts before every call to cvmx_usb*() and enable them
+ * again after the call is complete. Keep in mind that it is
+ * very common for the callback handlers to make additional
+ * calls into cvmx-usb, so the disable/enable must be protected
+ * against recursion. As an example, the Linux kernel
+ * local_irq_save() and local_irq_restore() are perfect for this
+ * in the non SMP case.
+ *
+ * In the SMP case, locking is more complicated. For SMP you not
+ * only need to disable interrupts on the local core, but also
+ * take a lock to make sure that another core cannot call
+ * cvmx-usb.
+ *
+ * <h2>Port callback</h2>
+ *
+ * The port callback prototype needs to look as follows:
+ *
+ * void port_callback(cvmx_usb_state_t *usb,
+ *                    cvmx_usb_callback_t reason,
+ *                    cvmx_usb_complete_t status,
+ *                    int pipe_handle,
+ *                    int submit_handle,
+ *                    int bytes_transferred,
+ *                    void *user_data);
+ * - @b usb is the cvmx_usb_state_t for the port.
+ * - @b reason will always be
+ *   CVMX_USB_CALLBACK_PORT_CHANGED.
+ * - @b status will always be CVMX_USB_COMPLETE_SUCCESS.
+ * - @b pipe_handle will always be -1.
+ * - @b submit_handle will always be -1.
+ * - @b bytes_transferred will always be 0.
+ * - @b user_data is the void pointer originally passed along
+ *   with the callback. Use this for any state information you
+ *   need.
+ *
+ * The port callback will be called whenever the user plugs /
+ * unplugs a device from the port. It will not be called when a
+ * device is plugged / unplugged from a hub connected to the
+ * root port. Normally all the callback needs to do is tell the
+ * operating system to poll the root hub for status. Under
+ * Linux, this is performed by calling usb_hcd_poll_rh_status().
+ * In the Linux driver we use @b user_data. to pass around the
+ * Linux "hcd" structure. Once the port callback completes,
+ * Linux automatically calls octeon_usb_hub_status_data() which
+ * uses cvmx_usb_get_status() to determine the root port status.
+ *
+ * <h2>Complete callback</h2>
+ *
+ * The completion callback prototype needs to look as follows:
+ *
+ * void complete_callback(cvmx_usb_state_t *usb,
+ *                        cvmx_usb_callback_t reason,
+ *                        cvmx_usb_complete_t status,
+ *                        int pipe_handle,
+ *                        int submit_handle,
+ *                        int bytes_transferred,
+ *                        void *user_data);
+ * - @b usb is the cvmx_usb_state_t for the port.
+ * - @b reason will always be
+ *   CVMX_USB_CALLBACK_TRANSFER_COMPLETE.
+ * - @b status will be one of the cvmx_usb_complete_t
+ *   enumerations.
+ * - @b pipe_handle is the handle to the pipe the transaction
+ *   was originally submitted on.
+ * - @b submit_handle is the handle returned by the original
+ *   cvmx_usb_submit_* call.
+ * - @b bytes_transferred is the number of bytes successfully
+ *   transferred in the transaction. This will be zero on most
+ *   error conditions.
+ * - @b user_data is the void pointer originally passed along
+ *   with the callback. Use this for any state information you
+ *   need. For example, the Linux "urb" is stored in here in the
+ *   Linux driver.
+ *
+ * In general your callback handler should use @b status and @b
+ * bytes_transferred to tell the operating system the how the
+ * transaction completed. Normally the pipe is not changed in
+ * this callback.
+ *
+ * <h2>Canceling transactions</h2>
+ *
+ * When a transaction is cancelled using cvmx_usb_cancel*(), the
+ * actual length of time until the complete callback is called
+ * can vary greatly. It may be called before cvmx_usb_cancel*()
+ * returns, or it may be called a number of usb frames in the
+ * future once the hardware frees the transaction. In either of
+ * these cases, the complete handler will receive
+ * CVMX_USB_COMPLETE_CANCEL.
+ *
+ * <h2>Handling pipes</h2>
+ *
+ * USB "pipes" is a software construct created by this API to
+ * enable the ordering of usb transactions to a device endpoint.
+ * Octeon's underlying hardware doesn't have any concept
+ * equivalent to "pipes". The hardware instead has eight
+ * channels that can be used simultaneously to have up to eight
+ * transaction in process at the same time. In order to maintain
+ * ordering in a pipe, the transactions for a pipe will only be
+ * active in one hardware channel at a time. From an API user's
+ * perspective, this doesn't matter but it can be helpful to
+ * keep this in mind when you are probing hardware while
+ * debugging.
+ *
+ * Also keep in mind that usb transactions contain state
+ * information about the previous transaction to the same
+ * endpoint. Each transaction has a PID toggle that changes 0/1
+ * between each sub packet. This is maintained in the pipe data
+ * structures. For this reason, you generally cannot create and
+ * destroy a pipe for every transaction. A sequence of
+ * transaction to the same endpoint must use the same pipe.
+ *
+ * <h2>Root Hub</h2>
+ *
+ * Some operating systems view the usb root port as a normal usb
+ * hub. These systems attempt to control the root hub with
+ * messages similar to the usb 2.0 spec for hub control and
+ * status. For these systems it may be necessary to write
+ * function to decode standard usb control messages into
+ * equivalent cvmx-usb API calls. As an example, the following
+ * code is used under Linux for some of the basic hub control
+ * messages.
+ *
+ * @code
+ * static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
+ * {
+ *     cvmx_usb_state_t *usb = (cvmx_usb_state_t *)hcd->hcd_priv;
+ *     cvmx_usb_port_status_t usb_port_status;
+ *     int port_status;
+ *     struct usb_hub_descriptor *desc;
+ *     unsigned long flags;
+ *
+ *     switch (typeReq)
+ *     {
+ *         case ClearHubFeature:
+ *             DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+ *             switch (wValue)
+ *             {
+ *                 case C_HUB_LOCAL_POWER:
+ *                 case C_HUB_OVER_CURRENT:
+ *                     // Nothing required here
+ *                     break;
+ *                 default:
+ *                     return -EINVAL;
+ *             }
+ *             break;
+ *         case ClearPortFeature:
+ *             DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+ *             if (wIndex != 1)
+ *             {
+ *                 DEBUG_ROOT_HUB(" INVALID\n");
+ *                 return -EINVAL;
+ *             }
+ *
+ *             switch (wValue)
+ *             {
+ *                 case USB_PORT_FEAT_ENABLE:
+ *                     DEBUG_ROOT_HUB(" ENABLE");
+ *                     local_irq_save(flags);
+ *                     cvmx_usb_disable(usb);
+ *                     local_irq_restore(flags);
+ *                     break;
+ *                 case USB_PORT_FEAT_SUSPEND:
+ *                     DEBUG_ROOT_HUB(" SUSPEND");
+ *                     // Not supported on Octeon
+ *                     break;
+ *                 case USB_PORT_FEAT_POWER:
+ *                     DEBUG_ROOT_HUB(" POWER");
+ *                     // Not supported on Octeon
+ *                     break;
+ *                 case USB_PORT_FEAT_INDICATOR:
+ *                     DEBUG_ROOT_HUB(" INDICATOR");
+ *                     // Port inidicator not supported
+ *                     break;
+ *                 case USB_PORT_FEAT_C_CONNECTION:
+ *                     DEBUG_ROOT_HUB(" C_CONNECTION");
+ *                     // Clears drivers internal connect status change flag
+ *                     cvmx_usb_set_status(usb, cvmx_usb_get_status(usb));
+ *                     break;
+ *                 case USB_PORT_FEAT_C_RESET:
+ *                     DEBUG_ROOT_HUB(" C_RESET");
+ *                     // Clears the driver's internal Port Reset Change flag
+ *                     cvmx_usb_set_status(usb, cvmx_usb_get_status(usb));
+ *                     break;
+ *                 case USB_PORT_FEAT_C_ENABLE:
+ *                     DEBUG_ROOT_HUB(" C_ENABLE");
+ *                     // Clears the driver's internal Port Enable/Disable Change flag
+ *                     cvmx_usb_set_status(usb, cvmx_usb_get_status(usb));
+ *                     break;
+ *                 case USB_PORT_FEAT_C_SUSPEND:
+ *                     DEBUG_ROOT_HUB(" C_SUSPEND");
+ *                     // Clears the driver's internal Port Suspend Change flag,
+ *                         which is set when resume signaling on the host port is
+ *                         complete
+ *                     break;
+ *                 case USB_PORT_FEAT_C_OVER_CURRENT:
+ *                     DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+ *                     // Clears the driver's overcurrent Change flag
+ *                     cvmx_usb_set_status(usb, cvmx_usb_get_status(usb));
+ *                     break;
+ *                 default:
+ *                     DEBUG_ROOT_HUB(" UNKNOWN\n");
+ *                     return -EINVAL;
+ *             }
+ *             DEBUG_ROOT_HUB("\n");
+ *             break;
+ *         case GetHubDescriptor:
+ *             DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+ *             desc = (struct usb_hub_descriptor *)buf;
+ *             desc->bDescLength = 9;
+ *             desc->bDescriptorType = 0x29;
+ *             desc->bNbrPorts = 1;
+ *             desc->wHubCharacteristics = 0x08;
+ *             desc->bPwrOn2PwrGood = 1;
+ *             desc->bHubContrCurrent = 0;
+ *             desc->bitmap[0] = 0;
+ *             desc->bitmap[1] = 0xff;
+ *             break;
+ *         case GetHubStatus:
+ *             DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+ *             *(__le32 *)buf = 0;
+ *             break;
+ *         case GetPortStatus:
+ *             DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+ *             if (wIndex != 1)
+ *             {
+ *                 DEBUG_ROOT_HUB(" INVALID\n");
+ *                 return -EINVAL;
+ *             }
+ *
+ *             usb_port_status = cvmx_usb_get_status(usb);
+ *             port_status = 0;
+ *
+ *             if (usb_port_status.connect_change)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+ *                 DEBUG_ROOT_HUB(" C_CONNECTION");
+ *             }
+ *
+ *             if (usb_port_status.port_enabled)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+ *                 DEBUG_ROOT_HUB(" C_ENABLE");
+ *             }
+ *
+ *             if (usb_port_status.connected)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+ *                 DEBUG_ROOT_HUB(" CONNECTION");
+ *             }
+ *
+ *             if (usb_port_status.port_enabled)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_ENABLE);
+ *                 DEBUG_ROOT_HUB(" ENABLE");
+ *             }
+ *
+ *             if (usb_port_status.port_over_current)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+ *                 DEBUG_ROOT_HUB(" OVER_CURRENT");
+ *             }
+ *
+ *             if (usb_port_status.port_powered)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_POWER);
+ *                 DEBUG_ROOT_HUB(" POWER");
+ *             }
+ *
+ *             if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_HIGHSPEED);
+ *                 DEBUG_ROOT_HUB(" HIGHSPEED");
+ *             }
+ *             else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW)
+ *             {
+ *                 port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+ *                 DEBUG_ROOT_HUB(" LOWSPEED");
+ *             }
+ *
+ *             *((__le32 *)buf) = cpu_to_le32(port_status);
+ *             DEBUG_ROOT_HUB("\n");
+ *             break;
+ *         case SetHubFeature:
+ *             DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+ *             // No HUB features supported
+ *             break;
+ *         case SetPortFeature:
+ *             DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+ *             if (wIndex != 1)
+ *             {
+ *                 DEBUG_ROOT_HUB(" INVALID\n");
+ *                 return -EINVAL;
+ *             }
+ *
+ *             switch (wValue)
+ *             {
+ *                 case USB_PORT_FEAT_SUSPEND:
+ *                     DEBUG_ROOT_HUB(" SUSPEND\n");
+ *                     return -EINVAL;
+ *                 case USB_PORT_FEAT_POWER:
+ *                     DEBUG_ROOT_HUB(" POWER\n");
+ *                     return -EINVAL;
+ *                 case USB_PORT_FEAT_RESET:
+ *                     DEBUG_ROOT_HUB(" RESET\n");
+ *                     local_irq_save(flags);
+ *                     cvmx_usb_disable(usb);
+ *                     if (cvmx_usb_enable(usb))
+ *                         DEBUG_ERROR("Failed to enable the port\n");
+ *                     local_irq_restore(flags);
+ *                     return 0;
+ *                 case USB_PORT_FEAT_INDICATOR:
+ *                     DEBUG_ROOT_HUB(" INDICATOR\n");
+ *                     // Not supported
+ *                     break;
+ *                 default:
+ *                     DEBUG_ROOT_HUB(" UNKNOWN\n");
+ *                     return -EINVAL;
+ *             }
+ *             break;
+ *         default:
+ *             DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+ *             return -EINVAL;
+ *     }
+ *     return 0;
+ * }
+ * @endcode
+ *
+ * <h2>Interrupts</h2>
+ *
+ * If you plan on using usb interrupts, cvmx_usb_poll() must be
+ * called on every usb interrupt. It will read the usb state,
+ * call any needed callbacks, and schedule transactions as
+ * needed. Your device driver needs only to hookup an interrupt
+ * handler and call cvmx_usb_poll(). Octeon's usb port 0 causes
+ * CIU bit CIU_INT*_SUM0[USB] to be set (bit 56). For port 1,
+ * CIU bit CIU_INT_SUM1[USB1] is set (bit 17). How these bits
+ * are turned into interrupt numbers is operating system
+ * specific. For Linux, there are the convenient defines
+ * OCTEON_IRQ_USB0 and OCTEON_IRQ_USB1 for the IRQ numbers.
+ *
+ * If you aren't using interrupts, simple call cvmx_usb_poll()
+ * in your main processing loop.
+ *
+ */
+
+#ifndef __CVMX_USB_H__
+#define __CVMX_USB_H__
+
+/**
+ * Enumerations representing the status of function calls.
+ */
+typedef enum {
+	CVMX_USB_SUCCESS = 0,
+				    /**< There were no errors */
+	CVMX_USB_INVALID_PARAM = -1,
+				    /**< A parameter to the function was invalid */
+	CVMX_USB_NO_MEMORY = -2,
+				    /**< Insufficient resources were available for the request */
+	CVMX_USB_BUSY = -3,	    /**< The resource is busy and cannot service the request */
+	CVMX_USB_TIMEOUT = -4,
+				    /**< Waiting for an action timed out */
+	CVMX_USB_INCORRECT_MODE = -5,
+				    /**< The function call doesn't work in the current USB
+                                         mode. This happens when host only functions are
+                                         called in device mode or vice versa */
+} cvmx_usb_status_t;
+
+/**
+ * Enumerations representing the possible USB device speeds
+ */
+typedef enum {
+	CVMX_USB_SPEED_HIGH = 0,
+				    /**< Device is operation at 480Mbps */
+	CVMX_USB_SPEED_FULL = 1,
+				    /**< Device is operation at 12Mbps */
+	CVMX_USB_SPEED_LOW = 2,
+				    /**< Device is operation at 1.5Mbps */
+} cvmx_usb_speed_t;
+
+/**
+ * Enumeration representing the possible USB transfer types.
+ */
+typedef enum {
+	CVMX_USB_TRANSFER_CONTROL = 0,
+					/**< USB transfer type control for hub and status transfers */
+	CVMX_USB_TRANSFER_ISOCHRONOUS = 1,
+					/**< USB transfer type isochronous for low priority periodic transfers */
+	CVMX_USB_TRANSFER_BULK = 2,
+					/**< USB transfer type bulk for large low priority transfers */
+	CVMX_USB_TRANSFER_INTERRUPT = 3,
+					/**< USB transfer type interrupt for high priority periodic transfers */
+} cvmx_usb_transfer_t;
+
+/**
+ * Enumeration of the transfer directions
+ */
+typedef enum {
+	CVMX_USB_DIRECTION_OUT,
+				    /**< Data is transferring from Octeon to the device/host */
+	CVMX_USB_DIRECTION_IN,
+				    /**< Data is transferring from the device/host to Octeon */
+} cvmx_usb_direction_t;
+
+/**
+ * Enumeration of all possible status codes passed to callback
+ * functions.
+ */
+typedef enum {
+	CVMX_USB_COMPLETE_SUCCESS,
+				    /**< The transaction / operation finished without any errors */
+	CVMX_USB_COMPLETE_SHORT,
+				    /**< FIXME: This is currently not implemented */
+	CVMX_USB_COMPLETE_CANCEL,
+				    /**< The transaction was canceled while in flight by a user call to cvmx_usb_cancel* */
+	CVMX_USB_COMPLETE_ERROR,
+				    /**< The transaction aborted with an unexpected error status */
+	CVMX_USB_COMPLETE_STALL,
+				    /**< The transaction received a USB STALL response from the device */
+	CVMX_USB_COMPLETE_XACTERR,
+				    /**< The transaction failed with an error from the device even after a number of retries */
+	CVMX_USB_COMPLETE_DATATGLERR,
+				    /**< The transaction failed with a data toggle error even after a number of retries */
+	CVMX_USB_COMPLETE_BABBLEERR,
+				    /**< The transaction failed with a babble error */
+	CVMX_USB_COMPLETE_FRAMEERR,
+				    /**< The transaction failed with a frame error even after a number of retries */
+} cvmx_usb_complete_t;
+
+/**
+ * Structure returned containing the USB port status information.
+ */
+typedef struct {
+	uint32_t reserved:25;
+	uint32_t port_enabled:1;
+				     /**< 1 = Usb port is enabled, 0 = disabled */
+	uint32_t port_over_current:1;
+				     /**< 1 = Over current detected, 0 = Over current not detected. Octeon doesn't support over current detection */
+	uint32_t port_powered:1;
+				     /**< 1 = Port power is being supplied to the device, 0 = power is off. Octeon doesn't support turning port power off */
+	cvmx_usb_speed_t port_speed:2;
+				     /**< Current port speed */
+	uint32_t connected:1;	     /**< 1 = A device is connected to the port, 0 = No device is connected */
+	uint32_t connect_change:1;
+				     /**< 1 = Device connected state changed since the last set status call */
+} cvmx_usb_port_status_t;
+
+/**
+ * This is the structure of a Control packet header
+ */
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t request_type:8;
+				      /**< Bit 7 tells the direction: 1=IN, 0=OUT */
+		uint64_t request:8;
+				      /**< The standard usb request to make */
+		uint64_t value:16;
+				      /**< Value parameter for the request in little endian format */
+		uint64_t index:16;
+				      /**< Index for the request in little endian format */
+		uint64_t length:16;
+				      /**< Length of the data associated with this request in little endian format */
+	} s;
+} cvmx_usb_control_header_t;
+
+/**
+ * Descriptor for Isochronous packets
+ */
+typedef struct {
+	int offset;		    /**< This is the offset in bytes into the main buffer where this data is stored */
+	int length;		    /**< This is the length in bytes of the data */
+	cvmx_usb_complete_t status;
+				    /**< This is the status of this individual packet transfer */
+} cvmx_usb_iso_packet_t;
+
+/**
+ * Possible callback reasons for the USB API.
+ */
+typedef enum {
+	CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
+				    /**< A callback of this type is called when a submitted transfer
+                                        completes. The completion callback will be called even if the
+                                        transfer fails or is canceled. The status parameter will
+                                        contain details of why he callback was called. */
+	CVMX_USB_CALLBACK_PORT_CHANGED,
+				    /**< The status of the port changed. For example, someone may have
+                                        plugged a device in. The status parameter contains
+                                        CVMX_USB_COMPLETE_SUCCESS. Use cvmx_usb_get_status() to get
+                                        the new port status. */
+	__CVMX_USB_CALLBACK_END
+				    /**< Do not use. Used internally for array bounds */
+} cvmx_usb_callback_t;
+
+/**
+ * USB state internal data. The contents of this structure
+ * may change in future SDKs. No data in it should be referenced
+ * by user's of this API.
+ */
+typedef struct {
+	char data[65536];
+} cvmx_usb_state_t;
+
+/**
+ * USB callback functions are always of the following type.
+ * The parameters are as follows:
+ *      - state = USB device state populated by
+ *        cvmx_usb_initialize().
+ *      - reason = The cvmx_usb_callback_t used to register
+ *        the callback.
+ *      - status = The cvmx_usb_complete_t representing the
+ *        status code of a transaction.
+ *      - pipe_handle = The Pipe that caused this callback, or
+ *        -1 if this callback wasn't associated with a pipe.
+ *      - submit_handle = Transfer submit handle causing this
+ *        callback, or -1 if this callback wasn't associated
+ *        with a transfer.
+ *      - Actual number of bytes transfer.
+ *      - user_data = The user pointer supplied to the
+ *        function cvmx_usb_submit() or
+ *        cvmx_usb_register_callback() */
+typedef void (*cvmx_usb_callback_func_t) (cvmx_usb_state_t * state,
+					  cvmx_usb_callback_t reason, cvmx_usb_complete_t status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data);
+
+/**
+ * Flags to pass the initialization function.
+ */
+typedef enum {
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI = 1 << 0,
+							/**< The USB port uses a 12MHz crystal as clock source
+                                                            at USB_XO and USB_XI. */
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND = 1 << 1,
+							/**< The USB port uses 12/24/48MHz 2.5V board clock
+                                                            source at USB_XO. USB_XI should be tied to GND.*/
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO = 0,
+							/**< Automatically determine clock type based on function
+                                                             in cvmx-helper-board.c. */
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK = 3 << 3,
+							    /**< Mask for clock speed field */
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ = 1 << 3,
+							/**< Speed of reference clock or crystal */
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ = 2 << 3,
+							/**< Speed of reference clock */
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ = 3 << 3,
+							/**< Speed of reference clock */
+	/* Bits 3-4 used to encode the clock frequency */
+	CVMX_USB_INITIALIZE_FLAGS_NO_DMA = 1 << 5,
+							/**< Disable DMA and used polled IO for data transfer use for the USB  */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS = 1 << 16,
+							/**< Enable extra console output for debugging USB transfers */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS = 1 << 17,
+							/**< Enable extra console output for debugging USB callbacks */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO = 1 << 18,
+							/**< Enable extra console output for USB informational data */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS = 1 << 19,
+							/**< Enable extra console output for every function call */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS = 1 << 20,
+							/**< Enable extra console output for every CSR access */
+	CVMX_USB_INITIALIZE_FLAGS_DEBUG_ALL = ((CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS << 1) - 1) - (CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS - 1),
+} cvmx_usb_initialize_flags_t;
+
+/**
+ * Flags for passing when a pipe is created. Currently no flags
+ * need to be passed.
+ */
+typedef enum {
+	CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS = 1 << 15,
+						/**< Used to display CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS for a specific pipe only */
+	__CVMX_USB_PIPE_FLAGS_OPEN = 1 << 16,
+						/**< Used internally to determine if a pipe is open. Do not use */
+	__CVMX_USB_PIPE_FLAGS_SCHEDULED = 1 << 17,
+						/**< Used internally to determine if a pipe is actively using hardware. Do not use */
+	__CVMX_USB_PIPE_FLAGS_NEED_PING = 1 << 18,
+						/**< Used internally to determine if a high speed pipe is in the ping state. Do not use */
+} cvmx_usb_pipe_flags_t;
+
+/**
+ * Return the number of USB ports supported by this Octeon
+ * chip. If the chip doesn't support USB, or is not supported
+ * by this API, a zero will be returned. Most Octeon chips
+ * support one usb port, but some support two ports.
+ * cvmx_usb_initialize() must be called on independent
+ * cvmx_usb_state_t structures.
+ *
+ * Returns Number of port, zero if usb isn't supported
+ */
+extern int cvmx_usb_get_num_ports(void);
+
+/**
+ * Initialize a USB port for use. This must be called before any
+ * other access to the Octeon USB port is made. The port starts
+ * off in the disabled state.
+ *
+ * @state:  Pointer to an empty cvmx_usb_state_t structure
+ *               that will be populated by the initialize call.
+ *               This structure is then passed to all other USB
+ *               functions.
+ * @usb_port_number:
+ *               Which Octeon USB port to initialize.
+ * @flags:  Flags to control hardware initialization. See
+ *               cvmx_usb_initialize_flags_t for the flag
+ *               definitions. Some flags are mandatory.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_initialize(cvmx_usb_state_t * state, int usb_port_number, cvmx_usb_initialize_flags_t flags);
+
+/**
+ * Shutdown a USB port after a call to cvmx_usb_initialize().
+ * The port should be disabled with all pipes closed when this
+ * function is called.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_shutdown(cvmx_usb_state_t * state);
+
+/**
+ * Enable a USB port. After this call succeeds, the USB port is
+ * online and servicing requests.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_enable(cvmx_usb_state_t * state);
+
+/**
+ * Disable a USB port. After this call the USB port will not
+ * generate data transfers and will not generate events.
+ * Transactions in process will fail and call their
+ * associated callbacks.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_disable(cvmx_usb_state_t * state);
+
+/**
+ * Get the current state of the USB port. Use this call to
+ * determine if the usb port has anything connected, is enabled,
+ * or has some sort of error condition. The return value of this
+ * call has "changed" bits to signal of the value of some fields
+ * have changed between calls. These "changed" fields are based
+ * on the last call to cvmx_usb_set_status(). In order to clear
+ * them, you must update the status through cvmx_usb_set_status().
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns Port status information
+ */
+extern cvmx_usb_port_status_t cvmx_usb_get_status(cvmx_usb_state_t * state);
+
+/**
+ * Set the current state of the USB port. The status is used as
+ * a reference for the "changed" bits returned by
+ * cvmx_usb_get_status(). Other than serving as a reference, the
+ * status passed to this function is not used. No fields can be
+ * changed through this call.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @port_status:
+ *               Port status to set, most like returned by cvmx_usb_get_status()
+ */
+extern void cvmx_usb_set_status(cvmx_usb_state_t * state, cvmx_usb_port_status_t port_status);
+
+/**
+ * Open a virtual pipe between the host and a USB device. A pipe
+ * must be opened before data can be transferred between a device
+ * and Octeon.
+ *
+ * @state:      USB device state populated by
+ *                   cvmx_usb_initialize().
+ * @flags:      Optional pipe flags defined in
+ *                   cvmx_usb_pipe_flags_t.
+ * @device_addr:
+ *                   USB device address to open the pipe to
+ *                   (0-127).
+ * @endpoint_num:
+ *                   USB endpoint number to open the pipe to
+ *                   (0-15).
+ * @device_speed:
+ *                   The speed of the device the pipe is going
+ *                   to. This must match the device's speed,
+ *                   which may be different than the port speed.
+ * @max_packet: The maximum packet length the device can
+ *                   transmit/receive (low speed=0-8, full
+ *                   speed=0-1023, high speed=0-1024). This value
+ *                   comes from the standard endpoint descriptor
+ *                   field wMaxPacketSize bits <10:0>.
+ * @transfer_type:
+ *                   The type of transfer this pipe is for.
+ * @transfer_dir:
+ *                   The direction the pipe is in. This is not
+ *                   used for control pipes.
+ * @interval:   For ISOCHRONOUS and INTERRUPT transfers,
+ *                   this is how often the transfer is scheduled
+ *                   for. All other transfers should specify
+ *                   zero. The units are in frames (8000/sec at
+ *                   high speed, 1000/sec for full speed).
+ * @multi_count:
+ *                   For high speed devices, this is the maximum
+ *                   allowed number of packet per microframe.
+ *                   Specify zero for non high speed devices. This
+ *                   value comes from the standard endpoint descriptor
+ *                   field wMaxPacketSize bits <12:11>.
+ * @hub_device_addr:
+ *                   Hub device address this device is connected
+ *                   to. Devices connected directly to Octeon
+ *                   use zero. This is only used when the device
+ *                   is full/low speed behind a high speed hub.
+ *                   The address will be of the high speed hub,
+ *                   not and full speed hubs after it.
+ * @hub_port:   Which port on the hub the device is
+ *                   connected. Use zero for devices connected
+ *                   directly to Octeon. Like hub_device_addr,
+ *                   this is only used for full/low speed
+ *                   devices behind a high speed hub.
+ *
+ * Returns A non negative value is a pipe handle. Negative
+ *         values are failure codes from cvmx_usb_status_t.
+ */
+extern int cvmx_usb_open_pipe(cvmx_usb_state_t * state,
+			      cvmx_usb_pipe_flags_t flags,
+			      int device_addr, int endpoint_num,
+			      cvmx_usb_speed_t device_speed, int max_packet,
+			      cvmx_usb_transfer_t transfer_type, cvmx_usb_direction_t transfer_dir, int interval, int multi_count, int hub_device_addr, int hub_port);
+
+/**
+ * Call to submit a USB Bulk transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+extern int cvmx_usb_submit_bulk(cvmx_usb_state_t * state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data);
+
+/**
+ * Call to submit a USB Interrupt transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+extern int cvmx_usb_submit_interrupt(cvmx_usb_state_t * state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data);
+
+/**
+ * Call to submit a USB Control transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @control_header:
+ *                  USB 8 byte control header physical address.
+ *                  Note that this is NOT A POINTER, but the
+ *                  full 64bit physical address of the buffer.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+extern int cvmx_usb_submit_control(cvmx_usb_state_t * state, int pipe_handle,
+				   uint64_t control_header, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data);
+
+/**
+ * Flags to pass the cvmx_usb_submit_isochronous() function.
+ */
+typedef enum {
+	CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT = 1 << 0,
+						    /**< Do not return an error if a transfer is less than the maximum packet size of the device */
+	CVMX_USB_ISOCHRONOUS_FLAGS_ASAP = 1 << 1,
+						    /**< Schedule the transaction as soon as possible */
+} cvmx_usb_isochronous_flags_t;
+
+/**
+ * Call to submit a USB Isochronous transfer to a pipe.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @pipe_handle:
+ *                  Handle to the pipe for the transfer.
+ * @start_frame:
+ *                  Number of frames into the future to schedule
+ *                  this transaction.
+ * @flags:     Flags to control the transfer. See
+ *                  cvmx_usb_isochronous_flags_t for the flag
+ *                  definitions.
+ * @number_packets:
+ *                  Number of sequential packets to transfer.
+ *                  "packets" is a pointer to an array of this
+ *                  many packet structures.
+ * @packets:   Description of each transfer packet as
+ *                  defined by cvmx_usb_iso_packet_t. The array
+ *                  pointed to here must stay valid until the
+ *                  complete callback is called.
+ * @buffer:    Physical address of the data buffer in
+ *                  memory. Note that this is NOT A POINTER, but
+ *                  the full 64bit physical address of the
+ *                  buffer. This may be zero if buffer_length is
+ *                  zero.
+ * @buffer_length:
+ *                  Length of buffer in bytes.
+ * @callback:  Function to call when this transaction
+ *                  completes. If the return value of this
+ *                  function isn't an error, then this function
+ *                  is guaranteed to be called when the
+ *                  transaction completes. If this parameter is
+ *                  NULL, then the generic callback registered
+ *                  through cvmx_usb_register_callback is
+ *                  called. If both are NULL, then there is no
+ *                  way to know when a transaction completes.
+ * @user_data: User supplied data returned when the
+ *                  callback is called. This is only used if
+ *                  callback in not NULL.
+ *
+ * Returns A submitted transaction handle or negative on
+ *         failure. Negative values are failure codes from
+ *         cvmx_usb_status_t.
+ */
+extern int cvmx_usb_submit_isochronous(cvmx_usb_state_t * state, int pipe_handle,
+				       int start_frame, int flags,
+				       int number_packets, cvmx_usb_iso_packet_t packets[], uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data);
+
+/**
+ * Cancel one outstanding request in a pipe. Canceling a request
+ * can fail if the transaction has already completed before cancel
+ * is called. Even after a successful cancel call, it may take
+ * a frame or two for the cvmx_usb_poll() function to call the
+ * associated callback.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to cancel requests in.
+ * @submit_handle:
+ *               Handle to transaction to cancel, returned by the submit function.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_cancel(cvmx_usb_state_t * state, int pipe_handle, int submit_handle);
+
+/**
+ * Cancel all outstanding requests in a pipe. Logically all this
+ * does is call cvmx_usb_cancel() in a loop.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to cancel requests in.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_cancel_all(cvmx_usb_state_t * state, int pipe_handle);
+
+/**
+ * Close a pipe created with cvmx_usb_open_pipe().
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ * @pipe_handle:
+ *               Pipe handle to close.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t. CVMX_USB_BUSY is returned if the
+ *         pipe has outstanding transfers.
+ */
+extern cvmx_usb_status_t cvmx_usb_close_pipe(cvmx_usb_state_t * state, int pipe_handle);
+
+/**
+ * Register a function to be called when various USB events occur.
+ *
+ * @state:     USB device state populated by
+ *                  cvmx_usb_initialize().
+ * @reason:    Which event to register for.
+ * @callback:  Function to call when the event occurs.
+ * @user_data: User data parameter to the function.
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_register_callback(cvmx_usb_state_t * state, cvmx_usb_callback_t reason, cvmx_usb_callback_func_t callback, void *user_data);
+
+/**
+ * Get the current USB protocol level frame number. The frame
+ * number is always in the range of 0-0x7ff.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns USB frame number
+ */
+extern int cvmx_usb_get_frame_number(cvmx_usb_state_t * state);
+
+/**
+ * Poll the USB block for status and call all needed callback
+ * handlers. This function is meant to be called in the interrupt
+ * handler for the USB controller. It can also be called
+ * periodically in a loop for non-interrupt based operation.
+ *
+ * @state:  USB device state populated by
+ *               cvmx_usb_initialize().
+ *
+ * Returns CVMX_USB_SUCCESS or a negative error code defined in
+ *         cvmx_usb_status_t.
+ */
+extern cvmx_usb_status_t cvmx_usb_poll(cvmx_usb_state_t * state);
+
+#endif /* __CVMX_USB_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
new file mode 100644
index 0000000..80c6607
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
@@ -0,0 +1,1693 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2012 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+#ifndef __CVMX_USBCX_DEFS_H__
+#define __CVMX_USBCX_DEFS_H__
+
+#define CVMX_USBCX_DAINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DAINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DIEPCTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000900ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DIEPINTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000908ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DIEPMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DIEPTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000910ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DOEPCTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000B00ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DOEPINTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000B08ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DOEPMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DOEPTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000B10ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_DPTXFSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000100ull) + (((offset) & 7) + ((block_id) & 1) * 0x40000000000ull) * 4)
+#define CVMX_USBCX_DSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR1(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR2(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR3(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR4(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GAHBCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG1(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG2(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG3(block_id) (CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG4(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GINTSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GNPTXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GNPTXSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GOTGCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GOTGINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRSTCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSPD(block_id) (CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSPH(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSRD(block_id) (CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSRH(block_id) (CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GSNPSID(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GUSBCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HAINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HAINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HCCHARX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000500ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_HCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HCINTMSKX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F001000050Cull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_HCINTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000508ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_HCSPLTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000504ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_HCTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000510ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
+#define CVMX_USBCX_HFIR(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HFNUM(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPRT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPTXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPTXSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_NPTXDFIFOX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010001000ull) + (((offset) & 7) + ((block_id) & 1) * 0x100000000ull) * 4096)
+#define CVMX_USBCX_PCGCCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((block_id) & 1) * 0x100000000000ull)
+
+union cvmx_usbcx_daint {
+	uint32_t u32;
+	struct cvmx_usbcx_daint_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t outepint:16;
+		uint32_t inepint:16;
+#else
+		uint32_t inepint:16;
+		uint32_t outepint:16;
+#endif
+	} s;
+	struct cvmx_usbcx_daint_s cn30xx;
+	struct cvmx_usbcx_daint_s cn31xx;
+	struct cvmx_usbcx_daint_s cn50xx;
+	struct cvmx_usbcx_daint_s cn52xx;
+	struct cvmx_usbcx_daint_s cn52xxp1;
+	struct cvmx_usbcx_daint_s cn56xx;
+	struct cvmx_usbcx_daint_s cn56xxp1;
+};
+
+union cvmx_usbcx_daintmsk {
+	uint32_t u32;
+	struct cvmx_usbcx_daintmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t outepmsk:16;
+		uint32_t inepmsk:16;
+#else
+		uint32_t inepmsk:16;
+		uint32_t outepmsk:16;
+#endif
+	} s;
+	struct cvmx_usbcx_daintmsk_s cn30xx;
+	struct cvmx_usbcx_daintmsk_s cn31xx;
+	struct cvmx_usbcx_daintmsk_s cn50xx;
+	struct cvmx_usbcx_daintmsk_s cn52xx;
+	struct cvmx_usbcx_daintmsk_s cn52xxp1;
+	struct cvmx_usbcx_daintmsk_s cn56xx;
+	struct cvmx_usbcx_daintmsk_s cn56xxp1;
+};
+
+union cvmx_usbcx_dcfg {
+	uint32_t u32;
+	struct cvmx_usbcx_dcfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_23_31:9;
+		uint32_t epmiscnt:5;
+		uint32_t reserved_13_17:5;
+		uint32_t perfrint:2;
+		uint32_t devaddr:7;
+		uint32_t reserved_3_3:1;
+		uint32_t nzstsouthshk:1;
+		uint32_t devspd:2;
+#else
+		uint32_t devspd:2;
+		uint32_t nzstsouthshk:1;
+		uint32_t reserved_3_3:1;
+		uint32_t devaddr:7;
+		uint32_t perfrint:2;
+		uint32_t reserved_13_17:5;
+		uint32_t epmiscnt:5;
+		uint32_t reserved_23_31:9;
+#endif
+	} s;
+	struct cvmx_usbcx_dcfg_s cn30xx;
+	struct cvmx_usbcx_dcfg_s cn31xx;
+	struct cvmx_usbcx_dcfg_s cn50xx;
+	struct cvmx_usbcx_dcfg_s cn52xx;
+	struct cvmx_usbcx_dcfg_s cn52xxp1;
+	struct cvmx_usbcx_dcfg_s cn56xx;
+	struct cvmx_usbcx_dcfg_s cn56xxp1;
+};
+
+union cvmx_usbcx_dctl {
+	uint32_t u32;
+	struct cvmx_usbcx_dctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_12_31:20;
+		uint32_t pwronprgdone:1;
+		uint32_t cgoutnak:1;
+		uint32_t sgoutnak:1;
+		uint32_t cgnpinnak:1;
+		uint32_t sgnpinnak:1;
+		uint32_t tstctl:3;
+		uint32_t goutnaksts:1;
+		uint32_t gnpinnaksts:1;
+		uint32_t sftdiscon:1;
+		uint32_t rmtwkupsig:1;
+#else
+		uint32_t rmtwkupsig:1;
+		uint32_t sftdiscon:1;
+		uint32_t gnpinnaksts:1;
+		uint32_t goutnaksts:1;
+		uint32_t tstctl:3;
+		uint32_t sgnpinnak:1;
+		uint32_t cgnpinnak:1;
+		uint32_t sgoutnak:1;
+		uint32_t cgoutnak:1;
+		uint32_t pwronprgdone:1;
+		uint32_t reserved_12_31:20;
+#endif
+	} s;
+	struct cvmx_usbcx_dctl_s cn30xx;
+	struct cvmx_usbcx_dctl_s cn31xx;
+	struct cvmx_usbcx_dctl_s cn50xx;
+	struct cvmx_usbcx_dctl_s cn52xx;
+	struct cvmx_usbcx_dctl_s cn52xxp1;
+	struct cvmx_usbcx_dctl_s cn56xx;
+	struct cvmx_usbcx_dctl_s cn56xxp1;
+};
+
+union cvmx_usbcx_diepctlx {
+	uint32_t u32;
+	struct cvmx_usbcx_diepctlx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t epena:1;
+		uint32_t epdis:1;
+		uint32_t setd1pid:1;
+		uint32_t setd0pid:1;
+		uint32_t snak:1;
+		uint32_t cnak:1;
+		uint32_t txfnum:4;
+		uint32_t stall:1;
+		uint32_t reserved_20_20:1;
+		uint32_t eptype:2;
+		uint32_t naksts:1;
+		uint32_t dpid:1;
+		uint32_t usbactep:1;
+		uint32_t nextep:4;
+		uint32_t mps:11;
+#else
+		uint32_t mps:11;
+		uint32_t nextep:4;
+		uint32_t usbactep:1;
+		uint32_t dpid:1;
+		uint32_t naksts:1;
+		uint32_t eptype:2;
+		uint32_t reserved_20_20:1;
+		uint32_t stall:1;
+		uint32_t txfnum:4;
+		uint32_t cnak:1;
+		uint32_t snak:1;
+		uint32_t setd0pid:1;
+		uint32_t setd1pid:1;
+		uint32_t epdis:1;
+		uint32_t epena:1;
+#endif
+	} s;
+	struct cvmx_usbcx_diepctlx_s cn30xx;
+	struct cvmx_usbcx_diepctlx_s cn31xx;
+	struct cvmx_usbcx_diepctlx_s cn50xx;
+	struct cvmx_usbcx_diepctlx_s cn52xx;
+	struct cvmx_usbcx_diepctlx_s cn52xxp1;
+	struct cvmx_usbcx_diepctlx_s cn56xx;
+	struct cvmx_usbcx_diepctlx_s cn56xxp1;
+};
+
+union cvmx_usbcx_diepintx {
+	uint32_t u32;
+	struct cvmx_usbcx_diepintx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_7_31:25;
+		uint32_t inepnakeff:1;
+		uint32_t intknepmis:1;
+		uint32_t intkntxfemp:1;
+		uint32_t timeout:1;
+		uint32_t ahberr:1;
+		uint32_t epdisbld:1;
+		uint32_t xfercompl:1;
+#else
+		uint32_t xfercompl:1;
+		uint32_t epdisbld:1;
+		uint32_t ahberr:1;
+		uint32_t timeout:1;
+		uint32_t intkntxfemp:1;
+		uint32_t intknepmis:1;
+		uint32_t inepnakeff:1;
+		uint32_t reserved_7_31:25;
+#endif
+	} s;
+	struct cvmx_usbcx_diepintx_s cn30xx;
+	struct cvmx_usbcx_diepintx_s cn31xx;
+	struct cvmx_usbcx_diepintx_s cn50xx;
+	struct cvmx_usbcx_diepintx_s cn52xx;
+	struct cvmx_usbcx_diepintx_s cn52xxp1;
+	struct cvmx_usbcx_diepintx_s cn56xx;
+	struct cvmx_usbcx_diepintx_s cn56xxp1;
+};
+
+union cvmx_usbcx_diepmsk {
+	uint32_t u32;
+	struct cvmx_usbcx_diepmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_7_31:25;
+		uint32_t inepnakeffmsk:1;
+		uint32_t intknepmismsk:1;
+		uint32_t intkntxfempmsk:1;
+		uint32_t timeoutmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t epdisbldmsk:1;
+		uint32_t xfercomplmsk:1;
+#else
+		uint32_t xfercomplmsk:1;
+		uint32_t epdisbldmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t timeoutmsk:1;
+		uint32_t intkntxfempmsk:1;
+		uint32_t intknepmismsk:1;
+		uint32_t inepnakeffmsk:1;
+		uint32_t reserved_7_31:25;
+#endif
+	} s;
+	struct cvmx_usbcx_diepmsk_s cn30xx;
+	struct cvmx_usbcx_diepmsk_s cn31xx;
+	struct cvmx_usbcx_diepmsk_s cn50xx;
+	struct cvmx_usbcx_diepmsk_s cn52xx;
+	struct cvmx_usbcx_diepmsk_s cn52xxp1;
+	struct cvmx_usbcx_diepmsk_s cn56xx;
+	struct cvmx_usbcx_diepmsk_s cn56xxp1;
+};
+
+union cvmx_usbcx_dieptsizx {
+	uint32_t u32;
+	struct cvmx_usbcx_dieptsizx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_31_31:1;
+		uint32_t mc:2;
+		uint32_t pktcnt:10;
+		uint32_t xfersize:19;
+#else
+		uint32_t xfersize:19;
+		uint32_t pktcnt:10;
+		uint32_t mc:2;
+		uint32_t reserved_31_31:1;
+#endif
+	} s;
+	struct cvmx_usbcx_dieptsizx_s cn30xx;
+	struct cvmx_usbcx_dieptsizx_s cn31xx;
+	struct cvmx_usbcx_dieptsizx_s cn50xx;
+	struct cvmx_usbcx_dieptsizx_s cn52xx;
+	struct cvmx_usbcx_dieptsizx_s cn52xxp1;
+	struct cvmx_usbcx_dieptsizx_s cn56xx;
+	struct cvmx_usbcx_dieptsizx_s cn56xxp1;
+};
+
+union cvmx_usbcx_doepctlx {
+	uint32_t u32;
+	struct cvmx_usbcx_doepctlx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t epena:1;
+		uint32_t epdis:1;
+		uint32_t setd1pid:1;
+		uint32_t setd0pid:1;
+		uint32_t snak:1;
+		uint32_t cnak:1;
+		uint32_t reserved_22_25:4;
+		uint32_t stall:1;
+		uint32_t snp:1;
+		uint32_t eptype:2;
+		uint32_t naksts:1;
+		uint32_t dpid:1;
+		uint32_t usbactep:1;
+		uint32_t reserved_11_14:4;
+		uint32_t mps:11;
+#else
+		uint32_t mps:11;
+		uint32_t reserved_11_14:4;
+		uint32_t usbactep:1;
+		uint32_t dpid:1;
+		uint32_t naksts:1;
+		uint32_t eptype:2;
+		uint32_t snp:1;
+		uint32_t stall:1;
+		uint32_t reserved_22_25:4;
+		uint32_t cnak:1;
+		uint32_t snak:1;
+		uint32_t setd0pid:1;
+		uint32_t setd1pid:1;
+		uint32_t epdis:1;
+		uint32_t epena:1;
+#endif
+	} s;
+	struct cvmx_usbcx_doepctlx_s cn30xx;
+	struct cvmx_usbcx_doepctlx_s cn31xx;
+	struct cvmx_usbcx_doepctlx_s cn50xx;
+	struct cvmx_usbcx_doepctlx_s cn52xx;
+	struct cvmx_usbcx_doepctlx_s cn52xxp1;
+	struct cvmx_usbcx_doepctlx_s cn56xx;
+	struct cvmx_usbcx_doepctlx_s cn56xxp1;
+};
+
+union cvmx_usbcx_doepintx {
+	uint32_t u32;
+	struct cvmx_usbcx_doepintx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_5_31:27;
+		uint32_t outtknepdis:1;
+		uint32_t setup:1;
+		uint32_t ahberr:1;
+		uint32_t epdisbld:1;
+		uint32_t xfercompl:1;
+#else
+		uint32_t xfercompl:1;
+		uint32_t epdisbld:1;
+		uint32_t ahberr:1;
+		uint32_t setup:1;
+		uint32_t outtknepdis:1;
+		uint32_t reserved_5_31:27;
+#endif
+	} s;
+	struct cvmx_usbcx_doepintx_s cn30xx;
+	struct cvmx_usbcx_doepintx_s cn31xx;
+	struct cvmx_usbcx_doepintx_s cn50xx;
+	struct cvmx_usbcx_doepintx_s cn52xx;
+	struct cvmx_usbcx_doepintx_s cn52xxp1;
+	struct cvmx_usbcx_doepintx_s cn56xx;
+	struct cvmx_usbcx_doepintx_s cn56xxp1;
+};
+
+union cvmx_usbcx_doepmsk {
+	uint32_t u32;
+	struct cvmx_usbcx_doepmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_5_31:27;
+		uint32_t outtknepdismsk:1;
+		uint32_t setupmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t epdisbldmsk:1;
+		uint32_t xfercomplmsk:1;
+#else
+		uint32_t xfercomplmsk:1;
+		uint32_t epdisbldmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t setupmsk:1;
+		uint32_t outtknepdismsk:1;
+		uint32_t reserved_5_31:27;
+#endif
+	} s;
+	struct cvmx_usbcx_doepmsk_s cn30xx;
+	struct cvmx_usbcx_doepmsk_s cn31xx;
+	struct cvmx_usbcx_doepmsk_s cn50xx;
+	struct cvmx_usbcx_doepmsk_s cn52xx;
+	struct cvmx_usbcx_doepmsk_s cn52xxp1;
+	struct cvmx_usbcx_doepmsk_s cn56xx;
+	struct cvmx_usbcx_doepmsk_s cn56xxp1;
+};
+
+union cvmx_usbcx_doeptsizx {
+	uint32_t u32;
+	struct cvmx_usbcx_doeptsizx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_31_31:1;
+		uint32_t mc:2;
+		uint32_t pktcnt:10;
+		uint32_t xfersize:19;
+#else
+		uint32_t xfersize:19;
+		uint32_t pktcnt:10;
+		uint32_t mc:2;
+		uint32_t reserved_31_31:1;
+#endif
+	} s;
+	struct cvmx_usbcx_doeptsizx_s cn30xx;
+	struct cvmx_usbcx_doeptsizx_s cn31xx;
+	struct cvmx_usbcx_doeptsizx_s cn50xx;
+	struct cvmx_usbcx_doeptsizx_s cn52xx;
+	struct cvmx_usbcx_doeptsizx_s cn52xxp1;
+	struct cvmx_usbcx_doeptsizx_s cn56xx;
+	struct cvmx_usbcx_doeptsizx_s cn56xxp1;
+};
+
+union cvmx_usbcx_dptxfsizx {
+	uint32_t u32;
+	struct cvmx_usbcx_dptxfsizx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t dptxfsize:16;
+		uint32_t dptxfstaddr:16;
+#else
+		uint32_t dptxfstaddr:16;
+		uint32_t dptxfsize:16;
+#endif
+	} s;
+	struct cvmx_usbcx_dptxfsizx_s cn30xx;
+	struct cvmx_usbcx_dptxfsizx_s cn31xx;
+	struct cvmx_usbcx_dptxfsizx_s cn50xx;
+	struct cvmx_usbcx_dptxfsizx_s cn52xx;
+	struct cvmx_usbcx_dptxfsizx_s cn52xxp1;
+	struct cvmx_usbcx_dptxfsizx_s cn56xx;
+	struct cvmx_usbcx_dptxfsizx_s cn56xxp1;
+};
+
+union cvmx_usbcx_dsts {
+	uint32_t u32;
+	struct cvmx_usbcx_dsts_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_22_31:10;
+		uint32_t soffn:14;
+		uint32_t reserved_4_7:4;
+		uint32_t errticerr:1;
+		uint32_t enumspd:2;
+		uint32_t suspsts:1;
+#else
+		uint32_t suspsts:1;
+		uint32_t enumspd:2;
+		uint32_t errticerr:1;
+		uint32_t reserved_4_7:4;
+		uint32_t soffn:14;
+		uint32_t reserved_22_31:10;
+#endif
+	} s;
+	struct cvmx_usbcx_dsts_s cn30xx;
+	struct cvmx_usbcx_dsts_s cn31xx;
+	struct cvmx_usbcx_dsts_s cn50xx;
+	struct cvmx_usbcx_dsts_s cn52xx;
+	struct cvmx_usbcx_dsts_s cn52xxp1;
+	struct cvmx_usbcx_dsts_s cn56xx;
+	struct cvmx_usbcx_dsts_s cn56xxp1;
+};
+
+union cvmx_usbcx_dtknqr1 {
+	uint32_t u32;
+	struct cvmx_usbcx_dtknqr1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t eptkn:24;
+		uint32_t wrapbit:1;
+		uint32_t reserved_5_6:2;
+		uint32_t intknwptr:5;
+#else
+		uint32_t intknwptr:5;
+		uint32_t reserved_5_6:2;
+		uint32_t wrapbit:1;
+		uint32_t eptkn:24;
+#endif
+	} s;
+	struct cvmx_usbcx_dtknqr1_s cn30xx;
+	struct cvmx_usbcx_dtknqr1_s cn31xx;
+	struct cvmx_usbcx_dtknqr1_s cn50xx;
+	struct cvmx_usbcx_dtknqr1_s cn52xx;
+	struct cvmx_usbcx_dtknqr1_s cn52xxp1;
+	struct cvmx_usbcx_dtknqr1_s cn56xx;
+	struct cvmx_usbcx_dtknqr1_s cn56xxp1;
+};
+
+union cvmx_usbcx_dtknqr2 {
+	uint32_t u32;
+	struct cvmx_usbcx_dtknqr2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t eptkn:32;
+#else
+		uint32_t eptkn:32;
+#endif
+	} s;
+	struct cvmx_usbcx_dtknqr2_s cn30xx;
+	struct cvmx_usbcx_dtknqr2_s cn31xx;
+	struct cvmx_usbcx_dtknqr2_s cn50xx;
+	struct cvmx_usbcx_dtknqr2_s cn52xx;
+	struct cvmx_usbcx_dtknqr2_s cn52xxp1;
+	struct cvmx_usbcx_dtknqr2_s cn56xx;
+	struct cvmx_usbcx_dtknqr2_s cn56xxp1;
+};
+
+union cvmx_usbcx_dtknqr3 {
+	uint32_t u32;
+	struct cvmx_usbcx_dtknqr3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t eptkn:32;
+#else
+		uint32_t eptkn:32;
+#endif
+	} s;
+	struct cvmx_usbcx_dtknqr3_s cn30xx;
+	struct cvmx_usbcx_dtknqr3_s cn31xx;
+	struct cvmx_usbcx_dtknqr3_s cn50xx;
+	struct cvmx_usbcx_dtknqr3_s cn52xx;
+	struct cvmx_usbcx_dtknqr3_s cn52xxp1;
+	struct cvmx_usbcx_dtknqr3_s cn56xx;
+	struct cvmx_usbcx_dtknqr3_s cn56xxp1;
+};
+
+union cvmx_usbcx_dtknqr4 {
+	uint32_t u32;
+	struct cvmx_usbcx_dtknqr4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t eptkn:32;
+#else
+		uint32_t eptkn:32;
+#endif
+	} s;
+	struct cvmx_usbcx_dtknqr4_s cn30xx;
+	struct cvmx_usbcx_dtknqr4_s cn31xx;
+	struct cvmx_usbcx_dtknqr4_s cn50xx;
+	struct cvmx_usbcx_dtknqr4_s cn52xx;
+	struct cvmx_usbcx_dtknqr4_s cn52xxp1;
+	struct cvmx_usbcx_dtknqr4_s cn56xx;
+	struct cvmx_usbcx_dtknqr4_s cn56xxp1;
+};
+
+union cvmx_usbcx_gahbcfg {
+	uint32_t u32;
+	struct cvmx_usbcx_gahbcfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_9_31:23;
+		uint32_t ptxfemplvl:1;
+		uint32_t nptxfemplvl:1;
+		uint32_t reserved_6_6:1;
+		uint32_t dmaen:1;
+		uint32_t hbstlen:4;
+		uint32_t glblintrmsk:1;
+#else
+		uint32_t glblintrmsk:1;
+		uint32_t hbstlen:4;
+		uint32_t dmaen:1;
+		uint32_t reserved_6_6:1;
+		uint32_t nptxfemplvl:1;
+		uint32_t ptxfemplvl:1;
+		uint32_t reserved_9_31:23;
+#endif
+	} s;
+	struct cvmx_usbcx_gahbcfg_s cn30xx;
+	struct cvmx_usbcx_gahbcfg_s cn31xx;
+	struct cvmx_usbcx_gahbcfg_s cn50xx;
+	struct cvmx_usbcx_gahbcfg_s cn52xx;
+	struct cvmx_usbcx_gahbcfg_s cn52xxp1;
+	struct cvmx_usbcx_gahbcfg_s cn56xx;
+	struct cvmx_usbcx_gahbcfg_s cn56xxp1;
+};
+
+union cvmx_usbcx_ghwcfg1 {
+	uint32_t u32;
+	struct cvmx_usbcx_ghwcfg1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t epdir:32;
+#else
+		uint32_t epdir:32;
+#endif
+	} s;
+	struct cvmx_usbcx_ghwcfg1_s cn30xx;
+	struct cvmx_usbcx_ghwcfg1_s cn31xx;
+	struct cvmx_usbcx_ghwcfg1_s cn50xx;
+	struct cvmx_usbcx_ghwcfg1_s cn52xx;
+	struct cvmx_usbcx_ghwcfg1_s cn52xxp1;
+	struct cvmx_usbcx_ghwcfg1_s cn56xx;
+	struct cvmx_usbcx_ghwcfg1_s cn56xxp1;
+};
+
+union cvmx_usbcx_ghwcfg2 {
+	uint32_t u32;
+	struct cvmx_usbcx_ghwcfg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_31_31:1;
+		uint32_t tknqdepth:5;
+		uint32_t ptxqdepth:2;
+		uint32_t nptxqdepth:2;
+		uint32_t reserved_20_21:2;
+		uint32_t dynfifosizing:1;
+		uint32_t periosupport:1;
+		uint32_t numhstchnl:4;
+		uint32_t numdeveps:4;
+		uint32_t fsphytype:2;
+		uint32_t hsphytype:2;
+		uint32_t singpnt:1;
+		uint32_t otgarch:2;
+		uint32_t otgmode:3;
+#else
+		uint32_t otgmode:3;
+		uint32_t otgarch:2;
+		uint32_t singpnt:1;
+		uint32_t hsphytype:2;
+		uint32_t fsphytype:2;
+		uint32_t numdeveps:4;
+		uint32_t numhstchnl:4;
+		uint32_t periosupport:1;
+		uint32_t dynfifosizing:1;
+		uint32_t reserved_20_21:2;
+		uint32_t nptxqdepth:2;
+		uint32_t ptxqdepth:2;
+		uint32_t tknqdepth:5;
+		uint32_t reserved_31_31:1;
+#endif
+	} s;
+	struct cvmx_usbcx_ghwcfg2_s cn30xx;
+	struct cvmx_usbcx_ghwcfg2_s cn31xx;
+	struct cvmx_usbcx_ghwcfg2_s cn50xx;
+	struct cvmx_usbcx_ghwcfg2_s cn52xx;
+	struct cvmx_usbcx_ghwcfg2_s cn52xxp1;
+	struct cvmx_usbcx_ghwcfg2_s cn56xx;
+	struct cvmx_usbcx_ghwcfg2_s cn56xxp1;
+};
+
+union cvmx_usbcx_ghwcfg3 {
+	uint32_t u32;
+	struct cvmx_usbcx_ghwcfg3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t dfifodepth:16;
+		uint32_t reserved_13_15:3;
+		uint32_t ahbphysync:1;
+		uint32_t rsttype:1;
+		uint32_t optfeature:1;
+		uint32_t vendor_control_interface_support:1;
+
+		uint32_t i2c_selection:1;
+		uint32_t otgen:1;
+		uint32_t pktsizewidth:3;
+		uint32_t xfersizewidth:4;
+#else
+		uint32_t xfersizewidth:4;
+		uint32_t pktsizewidth:3;
+		uint32_t otgen:1;
+		uint32_t i2c_selection:1;
+		uint32_t vendor_control_interface_support:1;
+		uint32_t optfeature:1;
+		uint32_t rsttype:1;
+		uint32_t ahbphysync:1;
+		uint32_t reserved_13_15:3;
+		uint32_t dfifodepth:16;
+#endif
+	} s;
+	struct cvmx_usbcx_ghwcfg3_s cn30xx;
+	struct cvmx_usbcx_ghwcfg3_s cn31xx;
+	struct cvmx_usbcx_ghwcfg3_s cn50xx;
+	struct cvmx_usbcx_ghwcfg3_s cn52xx;
+	struct cvmx_usbcx_ghwcfg3_s cn52xxp1;
+	struct cvmx_usbcx_ghwcfg3_s cn56xx;
+	struct cvmx_usbcx_ghwcfg3_s cn56xxp1;
+};
+
+union cvmx_usbcx_ghwcfg4 {
+	uint32_t u32;
+	struct cvmx_usbcx_ghwcfg4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_30_31:2;
+		uint32_t numdevmodinend:4;
+		uint32_t endedtrfifo:1;
+		uint32_t sessendfltr:1;
+		uint32_t bvalidfltr:1;
+		uint32_t avalidfltr:1;
+		uint32_t vbusvalidfltr:1;
+		uint32_t iddgfltr:1;
+		uint32_t numctleps:4;
+		uint32_t phydatawidth:2;
+		uint32_t reserved_6_13:8;
+		uint32_t ahbfreq:1;
+		uint32_t enablepwropt:1;
+		uint32_t numdevperioeps:4;
+#else
+		uint32_t numdevperioeps:4;
+		uint32_t enablepwropt:1;
+		uint32_t ahbfreq:1;
+		uint32_t reserved_6_13:8;
+		uint32_t phydatawidth:2;
+		uint32_t numctleps:4;
+		uint32_t iddgfltr:1;
+		uint32_t vbusvalidfltr:1;
+		uint32_t avalidfltr:1;
+		uint32_t bvalidfltr:1;
+		uint32_t sessendfltr:1;
+		uint32_t endedtrfifo:1;
+		uint32_t numdevmodinend:4;
+		uint32_t reserved_30_31:2;
+#endif
+	} s;
+	struct cvmx_usbcx_ghwcfg4_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_25_31:7;
+		uint32_t sessendfltr:1;
+		uint32_t bvalidfltr:1;
+		uint32_t avalidfltr:1;
+		uint32_t vbusvalidfltr:1;
+		uint32_t iddgfltr:1;
+		uint32_t numctleps:4;
+		uint32_t phydatawidth:2;
+		uint32_t reserved_6_13:8;
+		uint32_t ahbfreq:1;
+		uint32_t enablepwropt:1;
+		uint32_t numdevperioeps:4;
+#else
+		uint32_t numdevperioeps:4;
+		uint32_t enablepwropt:1;
+		uint32_t ahbfreq:1;
+		uint32_t reserved_6_13:8;
+		uint32_t phydatawidth:2;
+		uint32_t numctleps:4;
+		uint32_t iddgfltr:1;
+		uint32_t vbusvalidfltr:1;
+		uint32_t avalidfltr:1;
+		uint32_t bvalidfltr:1;
+		uint32_t sessendfltr:1;
+		uint32_t reserved_25_31:7;
+#endif
+	} cn30xx;
+	struct cvmx_usbcx_ghwcfg4_cn30xx cn31xx;
+	struct cvmx_usbcx_ghwcfg4_s cn50xx;
+	struct cvmx_usbcx_ghwcfg4_s cn52xx;
+	struct cvmx_usbcx_ghwcfg4_s cn52xxp1;
+	struct cvmx_usbcx_ghwcfg4_s cn56xx;
+	struct cvmx_usbcx_ghwcfg4_s cn56xxp1;
+};
+
+union cvmx_usbcx_gintmsk {
+	uint32_t u32;
+	struct cvmx_usbcx_gintmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t wkupintmsk:1;
+		uint32_t sessreqintmsk:1;
+		uint32_t disconnintmsk:1;
+		uint32_t conidstschngmsk:1;
+		uint32_t reserved_27_27:1;
+		uint32_t ptxfempmsk:1;
+		uint32_t hchintmsk:1;
+		uint32_t prtintmsk:1;
+		uint32_t reserved_23_23:1;
+		uint32_t fetsuspmsk:1;
+		uint32_t incomplpmsk:1;
+		uint32_t incompisoinmsk:1;
+		uint32_t oepintmsk:1;
+		uint32_t inepintmsk:1;
+		uint32_t epmismsk:1;
+		uint32_t reserved_16_16:1;
+		uint32_t eopfmsk:1;
+		uint32_t isooutdropmsk:1;
+		uint32_t enumdonemsk:1;
+		uint32_t usbrstmsk:1;
+		uint32_t usbsuspmsk:1;
+		uint32_t erlysuspmsk:1;
+		uint32_t i2cint:1;
+		uint32_t ulpickintmsk:1;
+		uint32_t goutnakeffmsk:1;
+		uint32_t ginnakeffmsk:1;
+		uint32_t nptxfempmsk:1;
+		uint32_t rxflvlmsk:1;
+		uint32_t sofmsk:1;
+		uint32_t otgintmsk:1;
+		uint32_t modemismsk:1;
+		uint32_t reserved_0_0:1;
+#else
+		uint32_t reserved_0_0:1;
+		uint32_t modemismsk:1;
+		uint32_t otgintmsk:1;
+		uint32_t sofmsk:1;
+		uint32_t rxflvlmsk:1;
+		uint32_t nptxfempmsk:1;
+		uint32_t ginnakeffmsk:1;
+		uint32_t goutnakeffmsk:1;
+		uint32_t ulpickintmsk:1;
+		uint32_t i2cint:1;
+		uint32_t erlysuspmsk:1;
+		uint32_t usbsuspmsk:1;
+		uint32_t usbrstmsk:1;
+		uint32_t enumdonemsk:1;
+		uint32_t isooutdropmsk:1;
+		uint32_t eopfmsk:1;
+		uint32_t reserved_16_16:1;
+		uint32_t epmismsk:1;
+		uint32_t inepintmsk:1;
+		uint32_t oepintmsk:1;
+		uint32_t incompisoinmsk:1;
+		uint32_t incomplpmsk:1;
+		uint32_t fetsuspmsk:1;
+		uint32_t reserved_23_23:1;
+		uint32_t prtintmsk:1;
+		uint32_t hchintmsk:1;
+		uint32_t ptxfempmsk:1;
+		uint32_t reserved_27_27:1;
+		uint32_t conidstschngmsk:1;
+		uint32_t disconnintmsk:1;
+		uint32_t sessreqintmsk:1;
+		uint32_t wkupintmsk:1;
+#endif
+	} s;
+	struct cvmx_usbcx_gintmsk_s cn30xx;
+	struct cvmx_usbcx_gintmsk_s cn31xx;
+	struct cvmx_usbcx_gintmsk_s cn50xx;
+	struct cvmx_usbcx_gintmsk_s cn52xx;
+	struct cvmx_usbcx_gintmsk_s cn52xxp1;
+	struct cvmx_usbcx_gintmsk_s cn56xx;
+	struct cvmx_usbcx_gintmsk_s cn56xxp1;
+};
+
+union cvmx_usbcx_gintsts {
+	uint32_t u32;
+	struct cvmx_usbcx_gintsts_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t wkupint:1;
+		uint32_t sessreqint:1;
+		uint32_t disconnint:1;
+		uint32_t conidstschng:1;
+		uint32_t reserved_27_27:1;
+		uint32_t ptxfemp:1;
+		uint32_t hchint:1;
+		uint32_t prtint:1;
+		uint32_t reserved_23_23:1;
+		uint32_t fetsusp:1;
+		uint32_t incomplp:1;
+		uint32_t incompisoin:1;
+		uint32_t oepint:1;
+		uint32_t iepint:1;
+		uint32_t epmis:1;
+		uint32_t reserved_16_16:1;
+		uint32_t eopf:1;
+		uint32_t isooutdrop:1;
+		uint32_t enumdone:1;
+		uint32_t usbrst:1;
+		uint32_t usbsusp:1;
+		uint32_t erlysusp:1;
+		uint32_t i2cint:1;
+		uint32_t ulpickint:1;
+		uint32_t goutnakeff:1;
+		uint32_t ginnakeff:1;
+		uint32_t nptxfemp:1;
+		uint32_t rxflvl:1;
+		uint32_t sof:1;
+		uint32_t otgint:1;
+		uint32_t modemis:1;
+		uint32_t curmod:1;
+#else
+		uint32_t curmod:1;
+		uint32_t modemis:1;
+		uint32_t otgint:1;
+		uint32_t sof:1;
+		uint32_t rxflvl:1;
+		uint32_t nptxfemp:1;
+		uint32_t ginnakeff:1;
+		uint32_t goutnakeff:1;
+		uint32_t ulpickint:1;
+		uint32_t i2cint:1;
+		uint32_t erlysusp:1;
+		uint32_t usbsusp:1;
+		uint32_t usbrst:1;
+		uint32_t enumdone:1;
+		uint32_t isooutdrop:1;
+		uint32_t eopf:1;
+		uint32_t reserved_16_16:1;
+		uint32_t epmis:1;
+		uint32_t iepint:1;
+		uint32_t oepint:1;
+		uint32_t incompisoin:1;
+		uint32_t incomplp:1;
+		uint32_t fetsusp:1;
+		uint32_t reserved_23_23:1;
+		uint32_t prtint:1;
+		uint32_t hchint:1;
+		uint32_t ptxfemp:1;
+		uint32_t reserved_27_27:1;
+		uint32_t conidstschng:1;
+		uint32_t disconnint:1;
+		uint32_t sessreqint:1;
+		uint32_t wkupint:1;
+#endif
+	} s;
+	struct cvmx_usbcx_gintsts_s cn30xx;
+	struct cvmx_usbcx_gintsts_s cn31xx;
+	struct cvmx_usbcx_gintsts_s cn50xx;
+	struct cvmx_usbcx_gintsts_s cn52xx;
+	struct cvmx_usbcx_gintsts_s cn52xxp1;
+	struct cvmx_usbcx_gintsts_s cn56xx;
+	struct cvmx_usbcx_gintsts_s cn56xxp1;
+};
+
+union cvmx_usbcx_gnptxfsiz {
+	uint32_t u32;
+	struct cvmx_usbcx_gnptxfsiz_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t nptxfdep:16;
+		uint32_t nptxfstaddr:16;
+#else
+		uint32_t nptxfstaddr:16;
+		uint32_t nptxfdep:16;
+#endif
+	} s;
+	struct cvmx_usbcx_gnptxfsiz_s cn30xx;
+	struct cvmx_usbcx_gnptxfsiz_s cn31xx;
+	struct cvmx_usbcx_gnptxfsiz_s cn50xx;
+	struct cvmx_usbcx_gnptxfsiz_s cn52xx;
+	struct cvmx_usbcx_gnptxfsiz_s cn52xxp1;
+	struct cvmx_usbcx_gnptxfsiz_s cn56xx;
+	struct cvmx_usbcx_gnptxfsiz_s cn56xxp1;
+};
+
+union cvmx_usbcx_gnptxsts {
+	uint32_t u32;
+	struct cvmx_usbcx_gnptxsts_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_31_31:1;
+		uint32_t nptxqtop:7;
+		uint32_t nptxqspcavail:8;
+		uint32_t nptxfspcavail:16;
+#else
+		uint32_t nptxfspcavail:16;
+		uint32_t nptxqspcavail:8;
+		uint32_t nptxqtop:7;
+		uint32_t reserved_31_31:1;
+#endif
+	} s;
+	struct cvmx_usbcx_gnptxsts_s cn30xx;
+	struct cvmx_usbcx_gnptxsts_s cn31xx;
+	struct cvmx_usbcx_gnptxsts_s cn50xx;
+	struct cvmx_usbcx_gnptxsts_s cn52xx;
+	struct cvmx_usbcx_gnptxsts_s cn52xxp1;
+	struct cvmx_usbcx_gnptxsts_s cn56xx;
+	struct cvmx_usbcx_gnptxsts_s cn56xxp1;
+};
+
+union cvmx_usbcx_gotgctl {
+	uint32_t u32;
+	struct cvmx_usbcx_gotgctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_20_31:12;
+		uint32_t bsesvld:1;
+		uint32_t asesvld:1;
+		uint32_t dbnctime:1;
+		uint32_t conidsts:1;
+		uint32_t reserved_12_15:4;
+		uint32_t devhnpen:1;
+		uint32_t hstsethnpen:1;
+		uint32_t hnpreq:1;
+		uint32_t hstnegscs:1;
+		uint32_t reserved_2_7:6;
+		uint32_t sesreq:1;
+		uint32_t sesreqscs:1;
+#else
+		uint32_t sesreqscs:1;
+		uint32_t sesreq:1;
+		uint32_t reserved_2_7:6;
+		uint32_t hstnegscs:1;
+		uint32_t hnpreq:1;
+		uint32_t hstsethnpen:1;
+		uint32_t devhnpen:1;
+		uint32_t reserved_12_15:4;
+		uint32_t conidsts:1;
+		uint32_t dbnctime:1;
+		uint32_t asesvld:1;
+		uint32_t bsesvld:1;
+		uint32_t reserved_20_31:12;
+#endif
+	} s;
+	struct cvmx_usbcx_gotgctl_s cn30xx;
+	struct cvmx_usbcx_gotgctl_s cn31xx;
+	struct cvmx_usbcx_gotgctl_s cn50xx;
+	struct cvmx_usbcx_gotgctl_s cn52xx;
+	struct cvmx_usbcx_gotgctl_s cn52xxp1;
+	struct cvmx_usbcx_gotgctl_s cn56xx;
+	struct cvmx_usbcx_gotgctl_s cn56xxp1;
+};
+
+union cvmx_usbcx_gotgint {
+	uint32_t u32;
+	struct cvmx_usbcx_gotgint_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_20_31:12;
+		uint32_t dbncedone:1;
+		uint32_t adevtoutchg:1;
+		uint32_t hstnegdet:1;
+		uint32_t reserved_10_16:7;
+		uint32_t hstnegsucstschng:1;
+		uint32_t sesreqsucstschng:1;
+		uint32_t reserved_3_7:5;
+		uint32_t sesenddet:1;
+		uint32_t reserved_0_1:2;
+#else
+		uint32_t reserved_0_1:2;
+		uint32_t sesenddet:1;
+		uint32_t reserved_3_7:5;
+		uint32_t sesreqsucstschng:1;
+		uint32_t hstnegsucstschng:1;
+		uint32_t reserved_10_16:7;
+		uint32_t hstnegdet:1;
+		uint32_t adevtoutchg:1;
+		uint32_t dbncedone:1;
+		uint32_t reserved_20_31:12;
+#endif
+	} s;
+	struct cvmx_usbcx_gotgint_s cn30xx;
+	struct cvmx_usbcx_gotgint_s cn31xx;
+	struct cvmx_usbcx_gotgint_s cn50xx;
+	struct cvmx_usbcx_gotgint_s cn52xx;
+	struct cvmx_usbcx_gotgint_s cn52xxp1;
+	struct cvmx_usbcx_gotgint_s cn56xx;
+	struct cvmx_usbcx_gotgint_s cn56xxp1;
+};
+
+union cvmx_usbcx_grstctl {
+	uint32_t u32;
+	struct cvmx_usbcx_grstctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t ahbidle:1;
+		uint32_t dmareq:1;
+		uint32_t reserved_11_29:19;
+		uint32_t txfnum:5;
+		uint32_t txfflsh:1;
+		uint32_t rxfflsh:1;
+		uint32_t intknqflsh:1;
+		uint32_t frmcntrrst:1;
+		uint32_t hsftrst:1;
+		uint32_t csftrst:1;
+#else
+		uint32_t csftrst:1;
+		uint32_t hsftrst:1;
+		uint32_t frmcntrrst:1;
+		uint32_t intknqflsh:1;
+		uint32_t rxfflsh:1;
+		uint32_t txfflsh:1;
+		uint32_t txfnum:5;
+		uint32_t reserved_11_29:19;
+		uint32_t dmareq:1;
+		uint32_t ahbidle:1;
+#endif
+	} s;
+	struct cvmx_usbcx_grstctl_s cn30xx;
+	struct cvmx_usbcx_grstctl_s cn31xx;
+	struct cvmx_usbcx_grstctl_s cn50xx;
+	struct cvmx_usbcx_grstctl_s cn52xx;
+	struct cvmx_usbcx_grstctl_s cn52xxp1;
+	struct cvmx_usbcx_grstctl_s cn56xx;
+	struct cvmx_usbcx_grstctl_s cn56xxp1;
+};
+
+union cvmx_usbcx_grxfsiz {
+	uint32_t u32;
+	struct cvmx_usbcx_grxfsiz_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_16_31:16;
+		uint32_t rxfdep:16;
+#else
+		uint32_t rxfdep:16;
+		uint32_t reserved_16_31:16;
+#endif
+	} s;
+	struct cvmx_usbcx_grxfsiz_s cn30xx;
+	struct cvmx_usbcx_grxfsiz_s cn31xx;
+	struct cvmx_usbcx_grxfsiz_s cn50xx;
+	struct cvmx_usbcx_grxfsiz_s cn52xx;
+	struct cvmx_usbcx_grxfsiz_s cn52xxp1;
+	struct cvmx_usbcx_grxfsiz_s cn56xx;
+	struct cvmx_usbcx_grxfsiz_s cn56xxp1;
+};
+
+union cvmx_usbcx_grxstspd {
+	uint32_t u32;
+	struct cvmx_usbcx_grxstspd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_25_31:7;
+		uint32_t fn:4;
+		uint32_t pktsts:4;
+		uint32_t dpid:2;
+		uint32_t bcnt:11;
+		uint32_t epnum:4;
+#else
+		uint32_t epnum:4;
+		uint32_t bcnt:11;
+		uint32_t dpid:2;
+		uint32_t pktsts:4;
+		uint32_t fn:4;
+		uint32_t reserved_25_31:7;
+#endif
+	} s;
+	struct cvmx_usbcx_grxstspd_s cn30xx;
+	struct cvmx_usbcx_grxstspd_s cn31xx;
+	struct cvmx_usbcx_grxstspd_s cn50xx;
+	struct cvmx_usbcx_grxstspd_s cn52xx;
+	struct cvmx_usbcx_grxstspd_s cn52xxp1;
+	struct cvmx_usbcx_grxstspd_s cn56xx;
+	struct cvmx_usbcx_grxstspd_s cn56xxp1;
+};
+
+union cvmx_usbcx_grxstsph {
+	uint32_t u32;
+	struct cvmx_usbcx_grxstsph_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_21_31:11;
+		uint32_t pktsts:4;
+		uint32_t dpid:2;
+		uint32_t bcnt:11;
+		uint32_t chnum:4;
+#else
+		uint32_t chnum:4;
+		uint32_t bcnt:11;
+		uint32_t dpid:2;
+		uint32_t pktsts:4;
+		uint32_t reserved_21_31:11;
+#endif
+	} s;
+	struct cvmx_usbcx_grxstsph_s cn30xx;
+	struct cvmx_usbcx_grxstsph_s cn31xx;
+	struct cvmx_usbcx_grxstsph_s cn50xx;
+	struct cvmx_usbcx_grxstsph_s cn52xx;
+	struct cvmx_usbcx_grxstsph_s cn52xxp1;
+	struct cvmx_usbcx_grxstsph_s cn56xx;
+	struct cvmx_usbcx_grxstsph_s cn56xxp1;
+};
+
+union cvmx_usbcx_grxstsrd {
+	uint32_t u32;
+	struct cvmx_usbcx_grxstsrd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_25_31:7;
+		uint32_t fn:4;
+		uint32_t pktsts:4;
+		uint32_t dpid:2;
+		uint32_t bcnt:11;
+		uint32_t epnum:4;
+#else
+		uint32_t epnum:4;
+		uint32_t bcnt:11;
+		uint32_t dpid:2;
+		uint32_t pktsts:4;
+		uint32_t fn:4;
+		uint32_t reserved_25_31:7;
+#endif
+	} s;
+	struct cvmx_usbcx_grxstsrd_s cn30xx;
+	struct cvmx_usbcx_grxstsrd_s cn31xx;
+	struct cvmx_usbcx_grxstsrd_s cn50xx;
+	struct cvmx_usbcx_grxstsrd_s cn52xx;
+	struct cvmx_usbcx_grxstsrd_s cn52xxp1;
+	struct cvmx_usbcx_grxstsrd_s cn56xx;
+	struct cvmx_usbcx_grxstsrd_s cn56xxp1;
+};
+
+union cvmx_usbcx_grxstsrh {
+	uint32_t u32;
+	struct cvmx_usbcx_grxstsrh_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_21_31:11;
+		uint32_t pktsts:4;
+		uint32_t dpid:2;
+		uint32_t bcnt:11;
+		uint32_t chnum:4;
+#else
+		uint32_t chnum:4;
+		uint32_t bcnt:11;
+		uint32_t dpid:2;
+		uint32_t pktsts:4;
+		uint32_t reserved_21_31:11;
+#endif
+	} s;
+	struct cvmx_usbcx_grxstsrh_s cn30xx;
+	struct cvmx_usbcx_grxstsrh_s cn31xx;
+	struct cvmx_usbcx_grxstsrh_s cn50xx;
+	struct cvmx_usbcx_grxstsrh_s cn52xx;
+	struct cvmx_usbcx_grxstsrh_s cn52xxp1;
+	struct cvmx_usbcx_grxstsrh_s cn56xx;
+	struct cvmx_usbcx_grxstsrh_s cn56xxp1;
+};
+
+union cvmx_usbcx_gsnpsid {
+	uint32_t u32;
+	struct cvmx_usbcx_gsnpsid_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t synopsysid:32;
+#else
+		uint32_t synopsysid:32;
+#endif
+	} s;
+	struct cvmx_usbcx_gsnpsid_s cn30xx;
+	struct cvmx_usbcx_gsnpsid_s cn31xx;
+	struct cvmx_usbcx_gsnpsid_s cn50xx;
+	struct cvmx_usbcx_gsnpsid_s cn52xx;
+	struct cvmx_usbcx_gsnpsid_s cn52xxp1;
+	struct cvmx_usbcx_gsnpsid_s cn56xx;
+	struct cvmx_usbcx_gsnpsid_s cn56xxp1;
+};
+
+union cvmx_usbcx_gusbcfg {
+	uint32_t u32;
+	struct cvmx_usbcx_gusbcfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_17_31:15;
+		uint32_t otgi2csel:1;
+		uint32_t phylpwrclksel:1;
+		uint32_t reserved_14_14:1;
+		uint32_t usbtrdtim:4;
+		uint32_t hnpcap:1;
+		uint32_t srpcap:1;
+		uint32_t ddrsel:1;
+		uint32_t physel:1;
+		uint32_t fsintf:1;
+		uint32_t ulpi_utmi_sel:1;
+		uint32_t phyif:1;
+		uint32_t toutcal:3;
+#else
+		uint32_t toutcal:3;
+		uint32_t phyif:1;
+		uint32_t ulpi_utmi_sel:1;
+		uint32_t fsintf:1;
+		uint32_t physel:1;
+		uint32_t ddrsel:1;
+		uint32_t srpcap:1;
+		uint32_t hnpcap:1;
+		uint32_t usbtrdtim:4;
+		uint32_t reserved_14_14:1;
+		uint32_t phylpwrclksel:1;
+		uint32_t otgi2csel:1;
+		uint32_t reserved_17_31:15;
+#endif
+	} s;
+	struct cvmx_usbcx_gusbcfg_s cn30xx;
+	struct cvmx_usbcx_gusbcfg_s cn31xx;
+	struct cvmx_usbcx_gusbcfg_s cn50xx;
+	struct cvmx_usbcx_gusbcfg_s cn52xx;
+	struct cvmx_usbcx_gusbcfg_s cn52xxp1;
+	struct cvmx_usbcx_gusbcfg_s cn56xx;
+	struct cvmx_usbcx_gusbcfg_s cn56xxp1;
+};
+
+union cvmx_usbcx_haint {
+	uint32_t u32;
+	struct cvmx_usbcx_haint_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_16_31:16;
+		uint32_t haint:16;
+#else
+		uint32_t haint:16;
+		uint32_t reserved_16_31:16;
+#endif
+	} s;
+	struct cvmx_usbcx_haint_s cn30xx;
+	struct cvmx_usbcx_haint_s cn31xx;
+	struct cvmx_usbcx_haint_s cn50xx;
+	struct cvmx_usbcx_haint_s cn52xx;
+	struct cvmx_usbcx_haint_s cn52xxp1;
+	struct cvmx_usbcx_haint_s cn56xx;
+	struct cvmx_usbcx_haint_s cn56xxp1;
+};
+
+union cvmx_usbcx_haintmsk {
+	uint32_t u32;
+	struct cvmx_usbcx_haintmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_16_31:16;
+		uint32_t haintmsk:16;
+#else
+		uint32_t haintmsk:16;
+		uint32_t reserved_16_31:16;
+#endif
+	} s;
+	struct cvmx_usbcx_haintmsk_s cn30xx;
+	struct cvmx_usbcx_haintmsk_s cn31xx;
+	struct cvmx_usbcx_haintmsk_s cn50xx;
+	struct cvmx_usbcx_haintmsk_s cn52xx;
+	struct cvmx_usbcx_haintmsk_s cn52xxp1;
+	struct cvmx_usbcx_haintmsk_s cn56xx;
+	struct cvmx_usbcx_haintmsk_s cn56xxp1;
+};
+
+union cvmx_usbcx_hccharx {
+	uint32_t u32;
+	struct cvmx_usbcx_hccharx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t chena:1;
+		uint32_t chdis:1;
+		uint32_t oddfrm:1;
+		uint32_t devaddr:7;
+		uint32_t ec:2;
+		uint32_t eptype:2;
+		uint32_t lspddev:1;
+		uint32_t reserved_16_16:1;
+		uint32_t epdir:1;
+		uint32_t epnum:4;
+		uint32_t mps:11;
+#else
+		uint32_t mps:11;
+		uint32_t epnum:4;
+		uint32_t epdir:1;
+		uint32_t reserved_16_16:1;
+		uint32_t lspddev:1;
+		uint32_t eptype:2;
+		uint32_t ec:2;
+		uint32_t devaddr:7;
+		uint32_t oddfrm:1;
+		uint32_t chdis:1;
+		uint32_t chena:1;
+#endif
+	} s;
+	struct cvmx_usbcx_hccharx_s cn30xx;
+	struct cvmx_usbcx_hccharx_s cn31xx;
+	struct cvmx_usbcx_hccharx_s cn50xx;
+	struct cvmx_usbcx_hccharx_s cn52xx;
+	struct cvmx_usbcx_hccharx_s cn52xxp1;
+	struct cvmx_usbcx_hccharx_s cn56xx;
+	struct cvmx_usbcx_hccharx_s cn56xxp1;
+};
+
+union cvmx_usbcx_hcfg {
+	uint32_t u32;
+	struct cvmx_usbcx_hcfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_3_31:29;
+		uint32_t fslssupp:1;
+		uint32_t fslspclksel:2;
+#else
+		uint32_t fslspclksel:2;
+		uint32_t fslssupp:1;
+		uint32_t reserved_3_31:29;
+#endif
+	} s;
+	struct cvmx_usbcx_hcfg_s cn30xx;
+	struct cvmx_usbcx_hcfg_s cn31xx;
+	struct cvmx_usbcx_hcfg_s cn50xx;
+	struct cvmx_usbcx_hcfg_s cn52xx;
+	struct cvmx_usbcx_hcfg_s cn52xxp1;
+	struct cvmx_usbcx_hcfg_s cn56xx;
+	struct cvmx_usbcx_hcfg_s cn56xxp1;
+};
+
+union cvmx_usbcx_hcintx {
+	uint32_t u32;
+	struct cvmx_usbcx_hcintx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_11_31:21;
+		uint32_t datatglerr:1;
+		uint32_t frmovrun:1;
+		uint32_t bblerr:1;
+		uint32_t xacterr:1;
+		uint32_t nyet:1;
+		uint32_t ack:1;
+		uint32_t nak:1;
+		uint32_t stall:1;
+		uint32_t ahberr:1;
+		uint32_t chhltd:1;
+		uint32_t xfercompl:1;
+#else
+		uint32_t xfercompl:1;
+		uint32_t chhltd:1;
+		uint32_t ahberr:1;
+		uint32_t stall:1;
+		uint32_t nak:1;
+		uint32_t ack:1;
+		uint32_t nyet:1;
+		uint32_t xacterr:1;
+		uint32_t bblerr:1;
+		uint32_t frmovrun:1;
+		uint32_t datatglerr:1;
+		uint32_t reserved_11_31:21;
+#endif
+	} s;
+	struct cvmx_usbcx_hcintx_s cn30xx;
+	struct cvmx_usbcx_hcintx_s cn31xx;
+	struct cvmx_usbcx_hcintx_s cn50xx;
+	struct cvmx_usbcx_hcintx_s cn52xx;
+	struct cvmx_usbcx_hcintx_s cn52xxp1;
+	struct cvmx_usbcx_hcintx_s cn56xx;
+	struct cvmx_usbcx_hcintx_s cn56xxp1;
+};
+
+union cvmx_usbcx_hcintmskx {
+	uint32_t u32;
+	struct cvmx_usbcx_hcintmskx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_11_31:21;
+		uint32_t datatglerrmsk:1;
+		uint32_t frmovrunmsk:1;
+		uint32_t bblerrmsk:1;
+		uint32_t xacterrmsk:1;
+		uint32_t nyetmsk:1;
+		uint32_t ackmsk:1;
+		uint32_t nakmsk:1;
+		uint32_t stallmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t chhltdmsk:1;
+		uint32_t xfercomplmsk:1;
+#else
+		uint32_t xfercomplmsk:1;
+		uint32_t chhltdmsk:1;
+		uint32_t ahberrmsk:1;
+		uint32_t stallmsk:1;
+		uint32_t nakmsk:1;
+		uint32_t ackmsk:1;
+		uint32_t nyetmsk:1;
+		uint32_t xacterrmsk:1;
+		uint32_t bblerrmsk:1;
+		uint32_t frmovrunmsk:1;
+		uint32_t datatglerrmsk:1;
+		uint32_t reserved_11_31:21;
+#endif
+	} s;
+	struct cvmx_usbcx_hcintmskx_s cn30xx;
+	struct cvmx_usbcx_hcintmskx_s cn31xx;
+	struct cvmx_usbcx_hcintmskx_s cn50xx;
+	struct cvmx_usbcx_hcintmskx_s cn52xx;
+	struct cvmx_usbcx_hcintmskx_s cn52xxp1;
+	struct cvmx_usbcx_hcintmskx_s cn56xx;
+	struct cvmx_usbcx_hcintmskx_s cn56xxp1;
+};
+
+union cvmx_usbcx_hcspltx {
+	uint32_t u32;
+	struct cvmx_usbcx_hcspltx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t spltena:1;
+		uint32_t reserved_17_30:14;
+		uint32_t compsplt:1;
+		uint32_t xactpos:2;
+		uint32_t hubaddr:7;
+		uint32_t prtaddr:7;
+#else
+		uint32_t prtaddr:7;
+		uint32_t hubaddr:7;
+		uint32_t xactpos:2;
+		uint32_t compsplt:1;
+		uint32_t reserved_17_30:14;
+		uint32_t spltena:1;
+#endif
+	} s;
+	struct cvmx_usbcx_hcspltx_s cn30xx;
+	struct cvmx_usbcx_hcspltx_s cn31xx;
+	struct cvmx_usbcx_hcspltx_s cn50xx;
+	struct cvmx_usbcx_hcspltx_s cn52xx;
+	struct cvmx_usbcx_hcspltx_s cn52xxp1;
+	struct cvmx_usbcx_hcspltx_s cn56xx;
+	struct cvmx_usbcx_hcspltx_s cn56xxp1;
+};
+
+union cvmx_usbcx_hctsizx {
+	uint32_t u32;
+	struct cvmx_usbcx_hctsizx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t dopng:1;
+		uint32_t pid:2;
+		uint32_t pktcnt:10;
+		uint32_t xfersize:19;
+#else
+		uint32_t xfersize:19;
+		uint32_t pktcnt:10;
+		uint32_t pid:2;
+		uint32_t dopng:1;
+#endif
+	} s;
+	struct cvmx_usbcx_hctsizx_s cn30xx;
+	struct cvmx_usbcx_hctsizx_s cn31xx;
+	struct cvmx_usbcx_hctsizx_s cn50xx;
+	struct cvmx_usbcx_hctsizx_s cn52xx;
+	struct cvmx_usbcx_hctsizx_s cn52xxp1;
+	struct cvmx_usbcx_hctsizx_s cn56xx;
+	struct cvmx_usbcx_hctsizx_s cn56xxp1;
+};
+
+union cvmx_usbcx_hfir {
+	uint32_t u32;
+	struct cvmx_usbcx_hfir_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_16_31:16;
+		uint32_t frint:16;
+#else
+		uint32_t frint:16;
+		uint32_t reserved_16_31:16;
+#endif
+	} s;
+	struct cvmx_usbcx_hfir_s cn30xx;
+	struct cvmx_usbcx_hfir_s cn31xx;
+	struct cvmx_usbcx_hfir_s cn50xx;
+	struct cvmx_usbcx_hfir_s cn52xx;
+	struct cvmx_usbcx_hfir_s cn52xxp1;
+	struct cvmx_usbcx_hfir_s cn56xx;
+	struct cvmx_usbcx_hfir_s cn56xxp1;
+};
+
+union cvmx_usbcx_hfnum {
+	uint32_t u32;
+	struct cvmx_usbcx_hfnum_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t frrem:16;
+		uint32_t frnum:16;
+#else
+		uint32_t frnum:16;
+		uint32_t frrem:16;
+#endif
+	} s;
+	struct cvmx_usbcx_hfnum_s cn30xx;
+	struct cvmx_usbcx_hfnum_s cn31xx;
+	struct cvmx_usbcx_hfnum_s cn50xx;
+	struct cvmx_usbcx_hfnum_s cn52xx;
+	struct cvmx_usbcx_hfnum_s cn52xxp1;
+	struct cvmx_usbcx_hfnum_s cn56xx;
+	struct cvmx_usbcx_hfnum_s cn56xxp1;
+};
+
+union cvmx_usbcx_hprt {
+	uint32_t u32;
+	struct cvmx_usbcx_hprt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_19_31:13;
+		uint32_t prtspd:2;
+		uint32_t prttstctl:4;
+		uint32_t prtpwr:1;
+		uint32_t prtlnsts:2;
+		uint32_t reserved_9_9:1;
+		uint32_t prtrst:1;
+		uint32_t prtsusp:1;
+		uint32_t prtres:1;
+		uint32_t prtovrcurrchng:1;
+		uint32_t prtovrcurract:1;
+		uint32_t prtenchng:1;
+		uint32_t prtena:1;
+		uint32_t prtconndet:1;
+		uint32_t prtconnsts:1;
+#else
+		uint32_t prtconnsts:1;
+		uint32_t prtconndet:1;
+		uint32_t prtena:1;
+		uint32_t prtenchng:1;
+		uint32_t prtovrcurract:1;
+		uint32_t prtovrcurrchng:1;
+		uint32_t prtres:1;
+		uint32_t prtsusp:1;
+		uint32_t prtrst:1;
+		uint32_t reserved_9_9:1;
+		uint32_t prtlnsts:2;
+		uint32_t prtpwr:1;
+		uint32_t prttstctl:4;
+		uint32_t prtspd:2;
+		uint32_t reserved_19_31:13;
+#endif
+	} s;
+	struct cvmx_usbcx_hprt_s cn30xx;
+	struct cvmx_usbcx_hprt_s cn31xx;
+	struct cvmx_usbcx_hprt_s cn50xx;
+	struct cvmx_usbcx_hprt_s cn52xx;
+	struct cvmx_usbcx_hprt_s cn52xxp1;
+	struct cvmx_usbcx_hprt_s cn56xx;
+	struct cvmx_usbcx_hprt_s cn56xxp1;
+};
+
+union cvmx_usbcx_hptxfsiz {
+	uint32_t u32;
+	struct cvmx_usbcx_hptxfsiz_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t ptxfsize:16;
+		uint32_t ptxfstaddr:16;
+#else
+		uint32_t ptxfstaddr:16;
+		uint32_t ptxfsize:16;
+#endif
+	} s;
+	struct cvmx_usbcx_hptxfsiz_s cn30xx;
+	struct cvmx_usbcx_hptxfsiz_s cn31xx;
+	struct cvmx_usbcx_hptxfsiz_s cn50xx;
+	struct cvmx_usbcx_hptxfsiz_s cn52xx;
+	struct cvmx_usbcx_hptxfsiz_s cn52xxp1;
+	struct cvmx_usbcx_hptxfsiz_s cn56xx;
+	struct cvmx_usbcx_hptxfsiz_s cn56xxp1;
+};
+
+union cvmx_usbcx_hptxsts {
+	uint32_t u32;
+	struct cvmx_usbcx_hptxsts_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t ptxqtop:8;
+		uint32_t ptxqspcavail:8;
+		uint32_t ptxfspcavail:16;
+#else
+		uint32_t ptxfspcavail:16;
+		uint32_t ptxqspcavail:8;
+		uint32_t ptxqtop:8;
+#endif
+	} s;
+	struct cvmx_usbcx_hptxsts_s cn30xx;
+	struct cvmx_usbcx_hptxsts_s cn31xx;
+	struct cvmx_usbcx_hptxsts_s cn50xx;
+	struct cvmx_usbcx_hptxsts_s cn52xx;
+	struct cvmx_usbcx_hptxsts_s cn52xxp1;
+	struct cvmx_usbcx_hptxsts_s cn56xx;
+	struct cvmx_usbcx_hptxsts_s cn56xxp1;
+};
+
+union cvmx_usbcx_nptxdfifox {
+	uint32_t u32;
+	struct cvmx_usbcx_nptxdfifox_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t data:32;
+#else
+		uint32_t data:32;
+#endif
+	} s;
+	struct cvmx_usbcx_nptxdfifox_s cn30xx;
+	struct cvmx_usbcx_nptxdfifox_s cn31xx;
+	struct cvmx_usbcx_nptxdfifox_s cn50xx;
+	struct cvmx_usbcx_nptxdfifox_s cn52xx;
+	struct cvmx_usbcx_nptxdfifox_s cn52xxp1;
+	struct cvmx_usbcx_nptxdfifox_s cn56xx;
+	struct cvmx_usbcx_nptxdfifox_s cn56xxp1;
+};
+
+union cvmx_usbcx_pcgcctl {
+	uint32_t u32;
+	struct cvmx_usbcx_pcgcctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_5_31:27;
+		uint32_t physuspended:1;
+		uint32_t rstpdwnmodule:1;
+		uint32_t pwrclmp:1;
+		uint32_t gatehclk:1;
+		uint32_t stoppclk:1;
+#else
+		uint32_t stoppclk:1;
+		uint32_t gatehclk:1;
+		uint32_t pwrclmp:1;
+		uint32_t rstpdwnmodule:1;
+		uint32_t physuspended:1;
+		uint32_t reserved_5_31:27;
+#endif
+	} s;
+	struct cvmx_usbcx_pcgcctl_s cn30xx;
+	struct cvmx_usbcx_pcgcctl_s cn31xx;
+	struct cvmx_usbcx_pcgcctl_s cn50xx;
+	struct cvmx_usbcx_pcgcctl_s cn52xx;
+	struct cvmx_usbcx_pcgcctl_s cn52xxp1;
+	struct cvmx_usbcx_pcgcctl_s cn56xx;
+	struct cvmx_usbcx_pcgcctl_s cn56xxp1;
+};
+
+#endif
diff --git a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
new file mode 100644
index 0000000..789b2bf
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
@@ -0,0 +1,1205 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2012 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+#ifndef __CVMX_USBNX_DEFS_H__
+#define __CVMX_USBNX_DEFS_H__
+
+#define CVMX_USBNX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_CLK_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN0(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN1(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN2(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN3(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN4(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN5(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN6(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN7(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN0(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN1(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN2(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN3(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN4(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN5(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN6(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN7(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA_TEST(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_INT_ENB(block_id) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_INT_SUM(block_id) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_USBP_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((block_id) & 1) * 0x10000000ull)
+
+union cvmx_usbnx_bist_status {
+	uint64_t u64;
+	struct cvmx_usbnx_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_7_63:57;
+		uint64_t u2nc_bis:1;
+		uint64_t u2nf_bis:1;
+		uint64_t e2hc_bis:1;
+		uint64_t n2uf_bis:1;
+		uint64_t usbc_bis:1;
+		uint64_t nif_bis:1;
+		uint64_t nof_bis:1;
+#else
+		uint64_t nof_bis:1;
+		uint64_t nif_bis:1;
+		uint64_t usbc_bis:1;
+		uint64_t n2uf_bis:1;
+		uint64_t e2hc_bis:1;
+		uint64_t u2nf_bis:1;
+		uint64_t u2nc_bis:1;
+		uint64_t reserved_7_63:57;
+#endif
+	} s;
+	struct cvmx_usbnx_bist_status_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_3_63:61;
+		uint64_t usbc_bis:1;
+		uint64_t nif_bis:1;
+		uint64_t nof_bis:1;
+#else
+		uint64_t nof_bis:1;
+		uint64_t nif_bis:1;
+		uint64_t usbc_bis:1;
+		uint64_t reserved_3_63:61;
+#endif
+	} cn30xx;
+	struct cvmx_usbnx_bist_status_cn30xx cn31xx;
+	struct cvmx_usbnx_bist_status_s cn50xx;
+	struct cvmx_usbnx_bist_status_s cn52xx;
+	struct cvmx_usbnx_bist_status_s cn52xxp1;
+	struct cvmx_usbnx_bist_status_s cn56xx;
+	struct cvmx_usbnx_bist_status_s cn56xxp1;
+};
+
+union cvmx_usbnx_clk_ctl {
+	uint64_t u64;
+	struct cvmx_usbnx_clk_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_20_63:44;
+		uint64_t divide2:2;
+		uint64_t hclk_rst:1;
+		uint64_t p_x_on:1;
+		uint64_t reserved_14_15:2;
+		uint64_t p_com_on:1;
+		uint64_t p_c_sel:2;
+		uint64_t cdiv_byp:1;
+		uint64_t sd_mode:2;
+		uint64_t s_bist:1;
+		uint64_t por:1;
+		uint64_t enable:1;
+		uint64_t prst:1;
+		uint64_t hrst:1;
+		uint64_t divide:3;
+#else
+		uint64_t divide:3;
+		uint64_t hrst:1;
+		uint64_t prst:1;
+		uint64_t enable:1;
+		uint64_t por:1;
+		uint64_t s_bist:1;
+		uint64_t sd_mode:2;
+		uint64_t cdiv_byp:1;
+		uint64_t p_c_sel:2;
+		uint64_t p_com_on:1;
+		uint64_t reserved_14_15:2;
+		uint64_t p_x_on:1;
+		uint64_t hclk_rst:1;
+		uint64_t divide2:2;
+		uint64_t reserved_20_63:44;
+#endif
+	} s;
+	struct cvmx_usbnx_clk_ctl_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_18_63:46;
+		uint64_t hclk_rst:1;
+		uint64_t p_x_on:1;
+		uint64_t p_rclk:1;
+		uint64_t p_xenbn:1;
+		uint64_t p_com_on:1;
+		uint64_t p_c_sel:2;
+		uint64_t cdiv_byp:1;
+		uint64_t sd_mode:2;
+		uint64_t s_bist:1;
+		uint64_t por:1;
+		uint64_t enable:1;
+		uint64_t prst:1;
+		uint64_t hrst:1;
+		uint64_t divide:3;
+#else
+		uint64_t divide:3;
+		uint64_t hrst:1;
+		uint64_t prst:1;
+		uint64_t enable:1;
+		uint64_t por:1;
+		uint64_t s_bist:1;
+		uint64_t sd_mode:2;
+		uint64_t cdiv_byp:1;
+		uint64_t p_c_sel:2;
+		uint64_t p_com_on:1;
+		uint64_t p_xenbn:1;
+		uint64_t p_rclk:1;
+		uint64_t p_x_on:1;
+		uint64_t hclk_rst:1;
+		uint64_t reserved_18_63:46;
+#endif
+	} cn30xx;
+	struct cvmx_usbnx_clk_ctl_cn30xx cn31xx;
+	struct cvmx_usbnx_clk_ctl_cn50xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_20_63:44;
+		uint64_t divide2:2;
+		uint64_t hclk_rst:1;
+		uint64_t reserved_16_16:1;
+		uint64_t p_rtype:2;
+		uint64_t p_com_on:1;
+		uint64_t p_c_sel:2;
+		uint64_t cdiv_byp:1;
+		uint64_t sd_mode:2;
+		uint64_t s_bist:1;
+		uint64_t por:1;
+		uint64_t enable:1;
+		uint64_t prst:1;
+		uint64_t hrst:1;
+		uint64_t divide:3;
+#else
+		uint64_t divide:3;
+		uint64_t hrst:1;
+		uint64_t prst:1;
+		uint64_t enable:1;
+		uint64_t por:1;
+		uint64_t s_bist:1;
+		uint64_t sd_mode:2;
+		uint64_t cdiv_byp:1;
+		uint64_t p_c_sel:2;
+		uint64_t p_com_on:1;
+		uint64_t p_rtype:2;
+		uint64_t reserved_16_16:1;
+		uint64_t hclk_rst:1;
+		uint64_t divide2:2;
+		uint64_t reserved_20_63:44;
+#endif
+	} cn50xx;
+	struct cvmx_usbnx_clk_ctl_cn50xx cn52xx;
+	struct cvmx_usbnx_clk_ctl_cn50xx cn52xxp1;
+	struct cvmx_usbnx_clk_ctl_cn50xx cn56xx;
+	struct cvmx_usbnx_clk_ctl_cn50xx cn56xxp1;
+};
+
+union cvmx_usbnx_ctl_status {
+	uint64_t u64;
+	struct cvmx_usbnx_ctl_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_6_63:58;
+		uint64_t dma_0pag:1;
+		uint64_t dma_stt:1;
+		uint64_t dma_test:1;
+		uint64_t inv_a2:1;
+		uint64_t l2c_emod:2;
+#else
+		uint64_t l2c_emod:2;
+		uint64_t inv_a2:1;
+		uint64_t dma_test:1;
+		uint64_t dma_stt:1;
+		uint64_t dma_0pag:1;
+		uint64_t reserved_6_63:58;
+#endif
+	} s;
+	struct cvmx_usbnx_ctl_status_s cn30xx;
+	struct cvmx_usbnx_ctl_status_s cn31xx;
+	struct cvmx_usbnx_ctl_status_s cn50xx;
+	struct cvmx_usbnx_ctl_status_s cn52xx;
+	struct cvmx_usbnx_ctl_status_s cn52xxp1;
+	struct cvmx_usbnx_ctl_status_s cn56xx;
+	struct cvmx_usbnx_ctl_status_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn0 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn0_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn1 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn1_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn2 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn2_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn3 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn3_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn4 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn4_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn5 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn5_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn5_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn6 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn6_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn6_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_inb_chn7 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_inb_chn7_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn30xx;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn31xx;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn50xx;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn52xx;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn52xxp1;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn56xx;
+	struct cvmx_usbnx_dma0_inb_chn7_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn0 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn0_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn1 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn1_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn2 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn2_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn3 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn3_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn4 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn4_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn5 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn5_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn5_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn6 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn6_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn6_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma0_outb_chn7 {
+	uint64_t u64;
+	struct cvmx_usbnx_dma0_outb_chn7_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_36_63:28;
+		uint64_t addr:36;
+#else
+		uint64_t addr:36;
+		uint64_t reserved_36_63:28;
+#endif
+	} s;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn30xx;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn31xx;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn50xx;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn52xx;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn52xxp1;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn56xx;
+	struct cvmx_usbnx_dma0_outb_chn7_s cn56xxp1;
+};
+
+union cvmx_usbnx_dma_test {
+	uint64_t u64;
+	struct cvmx_usbnx_dma_test_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_40_63:24;
+		uint64_t done:1;
+		uint64_t req:1;
+		uint64_t f_addr:18;
+		uint64_t count:11;
+		uint64_t channel:5;
+		uint64_t burst:4;
+#else
+		uint64_t burst:4;
+		uint64_t channel:5;
+		uint64_t count:11;
+		uint64_t f_addr:18;
+		uint64_t req:1;
+		uint64_t done:1;
+		uint64_t reserved_40_63:24;
+#endif
+	} s;
+	struct cvmx_usbnx_dma_test_s cn30xx;
+	struct cvmx_usbnx_dma_test_s cn31xx;
+	struct cvmx_usbnx_dma_test_s cn50xx;
+	struct cvmx_usbnx_dma_test_s cn52xx;
+	struct cvmx_usbnx_dma_test_s cn52xxp1;
+	struct cvmx_usbnx_dma_test_s cn56xx;
+	struct cvmx_usbnx_dma_test_s cn56xxp1;
+};
+
+union cvmx_usbnx_int_enb {
+	uint64_t u64;
+	struct cvmx_usbnx_int_enb_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_38_63:26;
+		uint64_t nd4o_dpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t u2n_c_pe:1;
+		uint64_t u2n_c_pf:1;
+		uint64_t u2n_d_pf:1;
+		uint64_t u2n_d_pe:1;
+		uint64_t n2u_pe:1;
+		uint64_t n2u_pf:1;
+		uint64_t uod_pf:1;
+		uint64_t uod_pe:1;
+		uint64_t rq_q3_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t l2_fi_f:1;
+		uint64_t l2_fi_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t dcred_f:1;
+		uint64_t dcred_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t pr_po_e:1;
+#else
+		uint64_t pr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t dcred_e:1;
+		uint64_t dcred_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2_fi_e:1;
+		uint64_t l2_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q3_e:1;
+		uint64_t uod_pe:1;
+		uint64_t uod_pf:1;
+		uint64_t n2u_pf:1;
+		uint64_t n2u_pe:1;
+		uint64_t u2n_d_pe:1;
+		uint64_t u2n_d_pf:1;
+		uint64_t u2n_c_pf:1;
+		uint64_t u2n_c_pe:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_dpf:1;
+		uint64_t reserved_38_63:26;
+#endif
+	} s;
+	struct cvmx_usbnx_int_enb_s cn30xx;
+	struct cvmx_usbnx_int_enb_s cn31xx;
+	struct cvmx_usbnx_int_enb_cn50xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_38_63:26;
+		uint64_t nd4o_dpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t reserved_26_31:6;
+		uint64_t uod_pf:1;
+		uint64_t uod_pe:1;
+		uint64_t rq_q3_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t l2_fi_f:1;
+		uint64_t l2_fi_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t dcred_f:1;
+		uint64_t dcred_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t pr_po_e:1;
+#else
+		uint64_t pr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t dcred_e:1;
+		uint64_t dcred_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2_fi_e:1;
+		uint64_t l2_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q3_e:1;
+		uint64_t uod_pe:1;
+		uint64_t uod_pf:1;
+		uint64_t reserved_26_31:6;
+		uint64_t ltl_f_pe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_dpf:1;
+		uint64_t reserved_38_63:26;
+#endif
+	} cn50xx;
+	struct cvmx_usbnx_int_enb_cn50xx cn52xx;
+	struct cvmx_usbnx_int_enb_cn50xx cn52xxp1;
+	struct cvmx_usbnx_int_enb_cn50xx cn56xx;
+	struct cvmx_usbnx_int_enb_cn50xx cn56xxp1;
+};
+
+union cvmx_usbnx_int_sum {
+	uint64_t u64;
+	struct cvmx_usbnx_int_sum_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_38_63:26;
+		uint64_t nd4o_dpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t u2n_c_pe:1;
+		uint64_t u2n_c_pf:1;
+		uint64_t u2n_d_pf:1;
+		uint64_t u2n_d_pe:1;
+		uint64_t n2u_pe:1;
+		uint64_t n2u_pf:1;
+		uint64_t uod_pf:1;
+		uint64_t uod_pe:1;
+		uint64_t rq_q3_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t lt_fi_f:1;
+		uint64_t lt_fi_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t dcred_f:1;
+		uint64_t dcred_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t pr_po_e:1;
+#else
+		uint64_t pr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t dcred_e:1;
+		uint64_t dcred_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t lt_fi_e:1;
+		uint64_t lt_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q3_e:1;
+		uint64_t uod_pe:1;
+		uint64_t uod_pf:1;
+		uint64_t n2u_pf:1;
+		uint64_t n2u_pe:1;
+		uint64_t u2n_d_pe:1;
+		uint64_t u2n_d_pf:1;
+		uint64_t u2n_c_pf:1;
+		uint64_t u2n_c_pe:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_dpf:1;
+		uint64_t reserved_38_63:26;
+#endif
+	} s;
+	struct cvmx_usbnx_int_sum_s cn30xx;
+	struct cvmx_usbnx_int_sum_s cn31xx;
+	struct cvmx_usbnx_int_sum_cn50xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_38_63:26;
+		uint64_t nd4o_dpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t ltl_f_pe:1;
+		uint64_t reserved_26_31:6;
+		uint64_t uod_pf:1;
+		uint64_t uod_pe:1;
+		uint64_t rq_q3_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t lt_fi_f:1;
+		uint64_t lt_fi_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t dcred_f:1;
+		uint64_t dcred_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t pr_po_e:1;
+#else
+		uint64_t pr_po_e:1;
+		uint64_t pr_pu_f:1;
+		uint64_t nr_po_e:1;
+		uint64_t nr_pu_f:1;
+		uint64_t lr_po_e:1;
+		uint64_t lr_pu_f:1;
+		uint64_t pt_po_e:1;
+		uint64_t pt_pu_f:1;
+		uint64_t nt_po_e:1;
+		uint64_t nt_pu_f:1;
+		uint64_t lt_po_e:1;
+		uint64_t lt_pu_f:1;
+		uint64_t dcred_e:1;
+		uint64_t dcred_f:1;
+		uint64_t l2c_s_e:1;
+		uint64_t l2c_a_f:1;
+		uint64_t lt_fi_e:1;
+		uint64_t lt_fi_f:1;
+		uint64_t rg_fi_e:1;
+		uint64_t rg_fi_f:1;
+		uint64_t rq_q2_f:1;
+		uint64_t rq_q2_e:1;
+		uint64_t rq_q3_f:1;
+		uint64_t rq_q3_e:1;
+		uint64_t uod_pe:1;
+		uint64_t uod_pf:1;
+		uint64_t reserved_26_31:6;
+		uint64_t ltl_f_pe:1;
+		uint64_t ltl_f_pf:1;
+		uint64_t nd4o_rpe:1;
+		uint64_t nd4o_rpf:1;
+		uint64_t nd4o_dpe:1;
+		uint64_t nd4o_dpf:1;
+		uint64_t reserved_38_63:26;
+#endif
+	} cn50xx;
+	struct cvmx_usbnx_int_sum_cn50xx cn52xx;
+	struct cvmx_usbnx_int_sum_cn50xx cn52xxp1;
+	struct cvmx_usbnx_int_sum_cn50xx cn56xx;
+	struct cvmx_usbnx_int_sum_cn50xx cn56xxp1;
+};
+
+union cvmx_usbnx_usbp_ctl_status {
+	uint64_t u64;
+	struct cvmx_usbnx_usbp_ctl_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t txrisetune:1;
+		uint64_t txvreftune:4;
+		uint64_t txfslstune:4;
+		uint64_t txhsxvtune:2;
+		uint64_t sqrxtune:3;
+		uint64_t compdistune:3;
+		uint64_t otgtune:3;
+		uint64_t otgdisable:1;
+		uint64_t portreset:1;
+		uint64_t drvvbus:1;
+		uint64_t lsbist:1;
+		uint64_t fsbist:1;
+		uint64_t hsbist:1;
+		uint64_t bist_done:1;
+		uint64_t bist_err:1;
+		uint64_t tdata_out:4;
+		uint64_t siddq:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t dma_bmode:1;
+		uint64_t usbc_end:1;
+		uint64_t usbp_bist:1;
+		uint64_t tclk:1;
+		uint64_t dp_pulld:1;
+		uint64_t dm_pulld:1;
+		uint64_t hst_mode:1;
+		uint64_t tuning:4;
+		uint64_t tx_bs_enh:1;
+		uint64_t tx_bs_en:1;
+		uint64_t loop_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t bist_enb:1;
+		uint64_t tdata_sel:1;
+		uint64_t taddr_in:4;
+		uint64_t tdata_in:8;
+		uint64_t ate_reset:1;
+#else
+		uint64_t ate_reset:1;
+		uint64_t tdata_in:8;
+		uint64_t taddr_in:4;
+		uint64_t tdata_sel:1;
+		uint64_t bist_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t loop_enb:1;
+		uint64_t tx_bs_en:1;
+		uint64_t tx_bs_enh:1;
+		uint64_t tuning:4;
+		uint64_t hst_mode:1;
+		uint64_t dm_pulld:1;
+		uint64_t dp_pulld:1;
+		uint64_t tclk:1;
+		uint64_t usbp_bist:1;
+		uint64_t usbc_end:1;
+		uint64_t dma_bmode:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t siddq:1;
+		uint64_t tdata_out:4;
+		uint64_t bist_err:1;
+		uint64_t bist_done:1;
+		uint64_t hsbist:1;
+		uint64_t fsbist:1;
+		uint64_t lsbist:1;
+		uint64_t drvvbus:1;
+		uint64_t portreset:1;
+		uint64_t otgdisable:1;
+		uint64_t otgtune:3;
+		uint64_t compdistune:3;
+		uint64_t sqrxtune:3;
+		uint64_t txhsxvtune:2;
+		uint64_t txfslstune:4;
+		uint64_t txvreftune:4;
+		uint64_t txrisetune:1;
+#endif
+	} s;
+	struct cvmx_usbnx_usbp_ctl_status_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t reserved_38_63:26;
+		uint64_t bist_done:1;
+		uint64_t bist_err:1;
+		uint64_t tdata_out:4;
+		uint64_t reserved_30_31:2;
+		uint64_t dma_bmode:1;
+		uint64_t usbc_end:1;
+		uint64_t usbp_bist:1;
+		uint64_t tclk:1;
+		uint64_t dp_pulld:1;
+		uint64_t dm_pulld:1;
+		uint64_t hst_mode:1;
+		uint64_t tuning:4;
+		uint64_t tx_bs_enh:1;
+		uint64_t tx_bs_en:1;
+		uint64_t loop_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t bist_enb:1;
+		uint64_t tdata_sel:1;
+		uint64_t taddr_in:4;
+		uint64_t tdata_in:8;
+		uint64_t ate_reset:1;
+#else
+		uint64_t ate_reset:1;
+		uint64_t tdata_in:8;
+		uint64_t taddr_in:4;
+		uint64_t tdata_sel:1;
+		uint64_t bist_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t loop_enb:1;
+		uint64_t tx_bs_en:1;
+		uint64_t tx_bs_enh:1;
+		uint64_t tuning:4;
+		uint64_t hst_mode:1;
+		uint64_t dm_pulld:1;
+		uint64_t dp_pulld:1;
+		uint64_t tclk:1;
+		uint64_t usbp_bist:1;
+		uint64_t usbc_end:1;
+		uint64_t dma_bmode:1;
+		uint64_t reserved_30_31:2;
+		uint64_t tdata_out:4;
+		uint64_t bist_err:1;
+		uint64_t bist_done:1;
+		uint64_t reserved_38_63:26;
+#endif
+	} cn30xx;
+	struct cvmx_usbnx_usbp_ctl_status_cn30xx cn31xx;
+	struct cvmx_usbnx_usbp_ctl_status_cn50xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t txrisetune:1;
+		uint64_t txvreftune:4;
+		uint64_t txfslstune:4;
+		uint64_t txhsxvtune:2;
+		uint64_t sqrxtune:3;
+		uint64_t compdistune:3;
+		uint64_t otgtune:3;
+		uint64_t otgdisable:1;
+		uint64_t portreset:1;
+		uint64_t drvvbus:1;
+		uint64_t lsbist:1;
+		uint64_t fsbist:1;
+		uint64_t hsbist:1;
+		uint64_t bist_done:1;
+		uint64_t bist_err:1;
+		uint64_t tdata_out:4;
+		uint64_t reserved_31_31:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t dma_bmode:1;
+		uint64_t usbc_end:1;
+		uint64_t usbp_bist:1;
+		uint64_t tclk:1;
+		uint64_t dp_pulld:1;
+		uint64_t dm_pulld:1;
+		uint64_t hst_mode:1;
+		uint64_t reserved_19_22:4;
+		uint64_t tx_bs_enh:1;
+		uint64_t tx_bs_en:1;
+		uint64_t loop_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t bist_enb:1;
+		uint64_t tdata_sel:1;
+		uint64_t taddr_in:4;
+		uint64_t tdata_in:8;
+		uint64_t ate_reset:1;
+#else
+		uint64_t ate_reset:1;
+		uint64_t tdata_in:8;
+		uint64_t taddr_in:4;
+		uint64_t tdata_sel:1;
+		uint64_t bist_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t loop_enb:1;
+		uint64_t tx_bs_en:1;
+		uint64_t tx_bs_enh:1;
+		uint64_t reserved_19_22:4;
+		uint64_t hst_mode:1;
+		uint64_t dm_pulld:1;
+		uint64_t dp_pulld:1;
+		uint64_t tclk:1;
+		uint64_t usbp_bist:1;
+		uint64_t usbc_end:1;
+		uint64_t dma_bmode:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t reserved_31_31:1;
+		uint64_t tdata_out:4;
+		uint64_t bist_err:1;
+		uint64_t bist_done:1;
+		uint64_t hsbist:1;
+		uint64_t fsbist:1;
+		uint64_t lsbist:1;
+		uint64_t drvvbus:1;
+		uint64_t portreset:1;
+		uint64_t otgdisable:1;
+		uint64_t otgtune:3;
+		uint64_t compdistune:3;
+		uint64_t sqrxtune:3;
+		uint64_t txhsxvtune:2;
+		uint64_t txfslstune:4;
+		uint64_t txvreftune:4;
+		uint64_t txrisetune:1;
+#endif
+	} cn50xx;
+	struct cvmx_usbnx_usbp_ctl_status_cn52xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t txrisetune:1;
+		uint64_t txvreftune:4;
+		uint64_t txfslstune:4;
+		uint64_t txhsxvtune:2;
+		uint64_t sqrxtune:3;
+		uint64_t compdistune:3;
+		uint64_t otgtune:3;
+		uint64_t otgdisable:1;
+		uint64_t portreset:1;
+		uint64_t drvvbus:1;
+		uint64_t lsbist:1;
+		uint64_t fsbist:1;
+		uint64_t hsbist:1;
+		uint64_t bist_done:1;
+		uint64_t bist_err:1;
+		uint64_t tdata_out:4;
+		uint64_t siddq:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t dma_bmode:1;
+		uint64_t usbc_end:1;
+		uint64_t usbp_bist:1;
+		uint64_t tclk:1;
+		uint64_t dp_pulld:1;
+		uint64_t dm_pulld:1;
+		uint64_t hst_mode:1;
+		uint64_t reserved_19_22:4;
+		uint64_t tx_bs_enh:1;
+		uint64_t tx_bs_en:1;
+		uint64_t loop_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t bist_enb:1;
+		uint64_t tdata_sel:1;
+		uint64_t taddr_in:4;
+		uint64_t tdata_in:8;
+		uint64_t ate_reset:1;
+#else
+		uint64_t ate_reset:1;
+		uint64_t tdata_in:8;
+		uint64_t taddr_in:4;
+		uint64_t tdata_sel:1;
+		uint64_t bist_enb:1;
+		uint64_t vtest_enb:1;
+		uint64_t loop_enb:1;
+		uint64_t tx_bs_en:1;
+		uint64_t tx_bs_enh:1;
+		uint64_t reserved_19_22:4;
+		uint64_t hst_mode:1;
+		uint64_t dm_pulld:1;
+		uint64_t dp_pulld:1;
+		uint64_t tclk:1;
+		uint64_t usbp_bist:1;
+		uint64_t usbc_end:1;
+		uint64_t dma_bmode:1;
+		uint64_t txpreemphasistune:1;
+		uint64_t siddq:1;
+		uint64_t tdata_out:4;
+		uint64_t bist_err:1;
+		uint64_t bist_done:1;
+		uint64_t hsbist:1;
+		uint64_t fsbist:1;
+		uint64_t lsbist:1;
+		uint64_t drvvbus:1;
+		uint64_t portreset:1;
+		uint64_t otgdisable:1;
+		uint64_t otgtune:3;
+		uint64_t compdistune:3;
+		uint64_t sqrxtune:3;
+		uint64_t txhsxvtune:2;
+		uint64_t txfslstune:4;
+		uint64_t txvreftune:4;
+		uint64_t txrisetune:1;
+#endif
+	} cn52xx;
+	struct cvmx_usbnx_usbp_ctl_status_cn50xx cn52xxp1;
+	struct cvmx_usbnx_usbp_ctl_status_cn52xx cn56xx;
+	struct cvmx_usbnx_usbp_ctl_status_cn50xx cn56xxp1;
+};
+
+#endif
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c532b6e..3301c20 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -667,6 +667,14 @@ config USB_IMX21_HCD
          To compile this driver as a module, choose M here: the
          module will be called "imx21-hcd".
 
+config USB_OCTEON_HCD
+	tristate "Octeon usb host driver" 
+	depends on USB && CPU_CAVIUM_OCTEON && !CAVIUM_OCTEON_2ND_KERNEL
+ 	default n
+        help
+          The Octeon DWC_OTG USB host controller.  All CN3XXX and
+          CN5XXX based chips with USB are supported.
+
 config USB_OCTEON_EHCI
 	bool "Octeon on-chip EHCI support"
 	depends on USB && USB_EHCI_HCD && CPU_CAVIUM_OCTEON
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 0982bcc..1720766 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -39,5 +39,6 @@ obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
+obj-$(CONFIG_USB_OCTEON_HCD)	+= octeon-hcd.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_MIPS_ALCHEMY)	+= alchemy-common.o
diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
new file mode 100644
index 0000000..2f30fe5
--- /dev/null
+++ b/drivers/usb/host/octeon-hcd.c
@@ -0,0 +1,883 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008-2012 Cavium, Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/of.h>
+
+#include <asm/time.h>
+#include <asm/delay.h>
+
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-usb.h>
+#include <asm/octeon/cvmx-iob-defs.h>
+
+
+#undef OCTEON_HCD_DEBUG
+
+#ifdef OCTEON_HCD_DEBUG
+
+#define DEBUG_CALL()			pr_info("OcteonUSB: %s called\n", __func__)
+#define DEBUG_SUBMIT(format, ...)       pr_info("OcteonUSB: %s " format, __func__, ##__VA_ARGS__)
+#define DEBUG_ROOT_HUB(format, ...)	pr_info(format, ##__VA_ARGS__)
+#define DEBUG_ERROR(format, ...)	pr_err("OcteonUSB: %s " format, __func__, ##__VA_ARGS__)
+
+#else
+
+#define DEBUG_CALL()			do {} while (0)
+#define DEBUG_SUBMIT(format, ...)	do {} while (0)
+#define DEBUG_ROOT_HUB(format, ...)	do {} while (0)
+#define DEBUG_ERROR(format, ...)	do {} while (0)
+
+#endif
+
+#define DEBUG_FATAL(format, ...)        pr_crit(format, ##__VA_ARGS__)
+
+struct octeon_hcd {
+	spinlock_t lock;
+	cvmx_usb_state_t usb;
+	struct tasklet_struct dequeue_tasklet;
+	struct list_head dequeue_list;
+};
+
+/* convert between an HCD pointer and the corresponding struct octeon_hcd */
+static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
+{
+	return (struct octeon_hcd *)(hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+static inline struct octeon_hcd *cvmx_usb_to_octeon(cvmx_usb_state_t *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
+
+static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL();
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
+				     cvmx_usb_callback_t reason,
+				     cvmx_usb_complete_t status,
+				     int pipe_handle,
+				     int submit_handle,
+				     int bytes_transferred,
+				     void *user_data)
+{
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	DEBUG_CALL();
+	spin_unlock(&priv->lock);
+	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
+	spin_lock(&priv->lock);
+}
+
+static int octeon_usb_start(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL();
+	hcd->state = HC_STATE_RUNNING;
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   octeon_usb_port_callback, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static void octeon_usb_stop(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL();
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   NULL, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	hcd->state = HC_STATE_HALT;
+}
+
+static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	DEBUG_CALL();
+	return cvmx_usb_get_frame_number(&priv->usb);
+}
+
+static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
+					     cvmx_usb_callback_t reason,
+					     cvmx_usb_complete_t status,
+					     int pipe_handle,
+					     int submit_handle,
+					     int bytes_transferred,
+					     void *user_data)
+{
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct urb *urb = user_data;
+	DEBUG_CALL();
+	urb->actual_length = bytes_transferred;
+	urb->hcpriv = NULL;
+
+	if (!list_empty(&urb->urb_list)) {
+		/*
+		 * It is on the dequeue_list, but we are going to call
+		 * usb_hcd_giveback_urb(), so we must clear it from
+		 * the list.  We got to it before the
+		 * octeon_usb_urb_dequeue_work() tasklet did.
+		 */
+		list_del(&urb->urb_list);
+		/* No longer on the dequeue_list. */
+		INIT_LIST_HEAD(&urb->urb_list);
+	}
+
+	/*
+	 * For Isochronous transactions we need to update the URB
+	 * packet status list from data in our private copy.
+	 */
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		/*
+		 * The pointer to the private list is stored in the
+		 * setup_packet field.
+		 */
+		cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *)urb->setup_packet;
+		/* Recalculate the transfer size by adding up each packet */
+		urb->actual_length = 0;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
+				urb->actual_length += urb->iso_frame_desc[i].actual_length;
+			} else {
+				DEBUG_ERROR("ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+					    i, urb->number_of_packets,
+					iso_packet[i].status, pipe_handle,
+					submit_handle, iso_packet[i].length);
+				urb->iso_frame_desc[i].status = -EREMOTEIO;
+			}
+		}
+		/* Free the private list now that we don't need it anymore */
+		kfree(iso_packet);
+		urb->setup_packet = NULL;
+	}
+
+	switch (status) {
+	case CVMX_USB_COMPLETE_SUCCESS:
+		urb->status = 0;
+		break;
+	case CVMX_USB_COMPLETE_CANCEL:
+		if (urb->status == 0)
+			urb->status = -ENOENT;
+		break;
+	case CVMX_USB_COMPLETE_STALL:
+		DEBUG_ERROR("status=stall pipe=%d submit=%d size=%d\n", pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_BABBLEERR:
+		DEBUG_ERROR("status=babble pipe=%d submit=%d size=%d\n", pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_SHORT:
+		DEBUG_ERROR("status=short pipe=%d submit=%d size=%d\n", pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EREMOTEIO;
+		break;
+	case CVMX_USB_COMPLETE_ERROR:
+	case CVMX_USB_COMPLETE_XACTERR:
+	case CVMX_USB_COMPLETE_DATATGLERR:
+	case CVMX_USB_COMPLETE_FRAMEERR:
+		DEBUG_ERROR("status=%d pipe=%d submit=%d size=%d\n", status, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPROTO;
+		break;
+	}
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
+	spin_lock(&priv->lock);
+}
+
+static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
+				  struct urb *urb,
+				  gfp_t mem_flags)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	int submit_handle = -1;
+	int pipe_handle;
+	unsigned long flags;
+	cvmx_usb_iso_packet_t *iso_packet;
+	struct usb_host_endpoint *ep = urb->ep;
+
+	DEBUG_CALL();
+
+	urb->status = 0;
+	INIT_LIST_HEAD(&urb->urb_list); /* not enqueued on dequeue_list */
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!ep->hcpriv) {
+		cvmx_usb_transfer_t transfer_type;
+		cvmx_usb_speed_t speed;
+		int split_device = 0;
+		int split_port = 0;
+		switch (usb_pipetype(urb->pipe)) {
+		case PIPE_ISOCHRONOUS:
+			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
+			break;
+		case PIPE_INTERRUPT:
+			transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
+			break;
+		case PIPE_CONTROL:
+			transfer_type = CVMX_USB_TRANSFER_CONTROL;
+			break;
+		default:
+			transfer_type = CVMX_USB_TRANSFER_BULK;
+			break;
+		}
+		switch (urb->dev->speed) {
+		case USB_SPEED_LOW:
+			speed = CVMX_USB_SPEED_LOW;
+			break;
+		case USB_SPEED_FULL:
+			speed = CVMX_USB_SPEED_FULL;
+			break;
+		default:
+			speed = CVMX_USB_SPEED_HIGH;
+			break;
+		}
+		/*
+		 * For slow devices on high speed ports we need to
+		 * find the hub that does the speed translation so we
+		 * know where to send the split transactions
+		 */
+		if (speed != CVMX_USB_SPEED_HIGH) {
+			/* Start at this device and work our way up the usb tree */
+			struct usb_device *dev = urb->dev;
+			while (dev->parent) {
+				/* If our parent is high speed then he'll receive the splits */
+				if (dev->parent->speed == USB_SPEED_HIGH) {
+					split_device = dev->parent->devnum;
+					split_port = dev->portnum;
+					break;
+				}
+				/*
+				 * Move up the tree one level. If we
+				 * make it all the way up the tree,
+				 * then the port must not be in high
+				 * speed mode and we don't need a
+				 * split.
+				 */
+				dev = dev->parent;
+			}
+		}
+		pipe_handle = cvmx_usb_open_pipe(&priv->usb,
+						0,
+						usb_pipedevice(urb->pipe),
+						usb_pipeendpoint(urb->pipe),
+						speed,
+						le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+						transfer_type,
+						usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
+						urb->interval,
+						(le16_to_cpu(ep->desc.wMaxPacketSize)>>11) & 0x3,
+						split_device,
+						split_port);
+		if (pipe_handle < 0) {
+			spin_unlock_irqrestore(&priv->lock, flags);
+			DEBUG_ERROR("failed to create pipe\n");
+			return -ENOMEM;
+		}
+		ep->hcpriv = (void *)(0x10000L + pipe_handle);
+	} else {
+		pipe_handle = 0xffff & (long)ep->hcpriv;
+	}
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		DEBUG_SUBMIT("submit isochronous to %d.%d\n", usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		/*
+		 * Allocate a structure to use for our private list of
+		 * isochronous packets.
+		 */
+		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
+		if (iso_packet) {
+			int i;
+			/* Fill the list with the data from the URB */
+			for (i = 0; i < urb->number_of_packets; i++) {
+				iso_packet[i].offset = urb->iso_frame_desc[i].offset;
+				iso_packet[i].length = urb->iso_frame_desc[i].length;
+				iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
+			}
+			/*
+			 * Store a pointer to the list in uthe URB
+			 * setup_pakcet field.  We know this currently
+			 * isn't being used and this saves us a bunch
+			 * of logic.
+			 */
+			urb->setup_packet = (char *)iso_packet;
+			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
+								urb->start_frame,
+								0 /* flags */,
+								urb->number_of_packets,
+								iso_packet,
+								urb->transfer_dma,
+								urb->transfer_buffer_length,
+								octeon_usb_urb_complete_callback,
+								urb);
+			/* If submit failed we need to free our private packet list */
+			if (submit_handle < 0) {
+				urb->setup_packet = NULL;
+				kfree(iso_packet);
+			}
+		}
+		break;
+	case PIPE_INTERRUPT:
+		DEBUG_SUBMIT("submit interrupt to %d.%d\n", usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
+							  urb->transfer_dma,
+							  urb->transfer_buffer_length,
+							  octeon_usb_urb_complete_callback,
+							  urb);
+		break;
+	case PIPE_CONTROL:
+		DEBUG_SUBMIT("submit control to %d.%d\n", usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
+							urb->setup_dma,
+							urb->transfer_dma,
+							urb->transfer_buffer_length,
+							octeon_usb_urb_complete_callback,
+							urb);
+		break;
+	case PIPE_BULK:
+		DEBUG_SUBMIT("submit bulk to %d.%d\n", usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
+						     urb->transfer_dma,
+						     urb->transfer_buffer_length,
+						     octeon_usb_urb_complete_callback,
+						     urb);
+		break;
+	}
+	if (submit_handle < 0) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		DEBUG_ERROR("failed to submit\n");
+		return -ENOMEM;
+	}
+	urb->hcpriv = (void *)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static void octeon_usb_urb_dequeue_work(unsigned long arg)
+{
+	unsigned long flags;
+	struct octeon_hcd *priv = (struct octeon_hcd *)arg;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	while (!list_empty(&priv->dequeue_list)) {
+		int pipe_handle;
+		int submit_handle;
+		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
+		list_del(&urb->urb_list);
+		/* not enqueued on dequeue_list */
+		INIT_LIST_HEAD(&urb->urb_list);
+		pipe_handle = 0xffff & (long)urb->hcpriv;
+		submit_handle = ((long)urb->hcpriv) >> 16;
+		cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+
+	DEBUG_CALL();
+
+	if (!urb->dev)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	urb->status = status;
+	list_add_tail(&urb->urb_list, &priv->dequeue_list);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	tasklet_schedule(&priv->dequeue_tasklet);
+
+	return 0;
+}
+
+static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	DEBUG_CALL();
+	if (ep->hcpriv) {
+		struct octeon_hcd *priv = hcd_to_octeon(hcd);
+		int pipe_handle = 0xffff & (long)ep->hcpriv;
+		unsigned long flags;
+		spin_lock_irqsave(&priv->lock, flags);
+		cvmx_usb_cancel_all(&priv->usb, pipe_handle);
+		if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
+			DEBUG_ERROR("Closing pipe %d failed\n", pipe_handle);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		ep->hcpriv = NULL;
+	}
+}
+
+static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	cvmx_usb_port_status_t port_status;
+	unsigned long flags;
+
+	DEBUG_CALL();
+
+	spin_lock_irqsave(&priv->lock, flags);
+	port_status = cvmx_usb_get_status(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	buf[0] = 0;
+	buf[0] = port_status.connect_change << 1;
+
+	return buf[0] != 0;
+}
+
+static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq,
+				  u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	cvmx_usb_port_status_t usb_port_status;
+	int port_status;
+	struct usb_hub_descriptor *desc;
+	unsigned long flags;
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* Nothing required here */
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case ClearPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			DEBUG_ROOT_HUB(" ENABLE");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR");
+			/* Port inidicator not supported */
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+			/* Clears drivers internal connect status change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			DEBUG_ROOT_HUB(" C_RESET");
+			/* Clears the driver's internal Port Reset Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			DEBUG_ROOT_HUB(" C_ENABLE");
+			/* Clears the driver's internal Port Enable/Disable Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			DEBUG_ROOT_HUB(" C_SUSPEND");
+			/*
+			 * Clears the driver's internal Port Suspend
+			 * Change flag, which is set when resume
+			 * signaling on the host port is complete.
+			 */
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+			/* Clears the driver's overcurrent Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case GetHubDescriptor:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+		desc = (struct usb_hub_descriptor *)buf;
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = 0x08;
+		desc->bPwrOn2PwrGood = 1;
+		desc->bHubContrCurrent = 0;
+		desc->u.hs.DeviceRemovable[0] = 0;
+		desc->u.hs.DeviceRemovable[1] = 0xff;
+		break;
+	case GetHubStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+		*(__le32 *)buf = 0;
+		break;
+	case GetPortStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&priv->lock, flags);
+		usb_port_status = cvmx_usb_get_status(&priv->usb);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		port_status = 0;
+
+		if (usb_port_status.connect_change) {
+			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+			DEBUG_ROOT_HUB(" C_ENABLE");
+		}
+
+		if (usb_port_status.connected) {
+			port_status |= USB_PORT_STAT_CONNECTION;
+			DEBUG_ROOT_HUB(" CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= USB_PORT_STAT_ENABLE;
+			DEBUG_ROOT_HUB(" ENABLE");
+		}
+
+		if (usb_port_status.port_over_current) {
+			port_status |= USB_PORT_STAT_OVERCURRENT;
+			DEBUG_ROOT_HUB(" OVER_CURRENT");
+		}
+
+		if (usb_port_status.port_powered) {
+			port_status |= USB_PORT_STAT_POWER;
+			DEBUG_ROOT_HUB(" POWER");
+		}
+
+		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
+			port_status |= USB_PORT_STAT_HIGH_SPEED;
+			DEBUG_ROOT_HUB(" HIGHSPEED");
+		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
+			port_status |= USB_PORT_STAT_LOW_SPEED;
+			DEBUG_ROOT_HUB(" LOWSPEED");
+		}
+
+		*((__le32 *)buf) = cpu_to_le32(port_status);
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case SetHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+		/* No HUB features supported */
+		break;
+	case SetPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_RESET:
+			DEBUG_ROOT_HUB(" RESET\n");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			if (cvmx_usb_enable(&priv->usb))
+				DEBUG_ERROR("Failed to enable the port\n");
+			spin_unlock_irqrestore(&priv->lock, flags);
+			return 0;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR\n");
+			/* Not supported */
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static const struct hc_driver octeon_hc_driver = {
+	.description =      "Octeon USB",
+	.product_desc =     "Octeon Host Controller",
+	.hcd_priv_size =    sizeof(struct octeon_hcd),
+	.irq =              octeon_usb_irq,
+	.flags =            HCD_MEMORY | HCD_USB2,
+	.start =            octeon_usb_start,
+	.stop =             octeon_usb_stop,
+	.urb_enqueue =      octeon_usb_urb_enqueue,
+	.urb_dequeue =      octeon_usb_urb_dequeue,
+	.endpoint_disable = octeon_usb_endpoint_disable,
+	.get_frame_number = octeon_usb_get_frame_number,
+	.hub_status_data =  octeon_usb_hub_status_data,
+	.hub_control =      octeon_usb_hub_control,
+};
+
+
+static int octeon_usb_probe(struct platform_device *pdev)
+{
+	int status;
+	int initialize_flags;
+	int usb_num;
+	struct resource *res_mem;
+	struct device_node *usbn_node;
+	int irq = platform_get_irq(pdev, 0);
+	struct device *dev = &pdev->dev;
+	struct octeon_hcd *priv;
+	struct usb_hcd *hcd;
+	unsigned long flags;
+	u32 clock_rate = 48000000;
+	bool is_crystal_clock = false;
+	const char *clock_type;
+	int i;
+
+	DEBUG_CALL();
+
+	if (dev->of_node == NULL) {
+		dev_err(dev, "Error: empty of_node\n");
+		return -ENXIO;
+	}
+	usbn_node = dev->of_node->parent;
+
+	i = of_property_read_u32(usbn_node,
+				 "refclk-frequency", &clock_rate);
+	if (i) {
+		dev_err(dev, "No USBN \"refclk-frequency\"\n");
+		return -ENXIO;
+	}
+	switch (clock_rate) {
+	case 12000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
+		break;
+	case 24000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
+		break;
+	case 48000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
+		break;
+	default:
+		dev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n", clock_rate);
+		return -ENXIO;
+
+	}
+
+	i = of_property_read_string(usbn_node,
+				    "refclk-type", &clock_type);
+
+	if (!i && strcmp("crystal", clock_type) == 0)
+		is_crystal_clock = true;
+
+	if (is_crystal_clock)
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
+	else
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(dev, "found no memory resource\n");
+		return -ENXIO;
+	}
+	usb_num = (res_mem->start >> 44) & 1;
+
+	if (irq < 0) {
+		/* Defective device tree, but we know how to fix it. */
+		irq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;
+		irq = irq_create_mapping(NULL, hwirq);
+	}
+	/*
+	 * Set the DMA mask to 64bits so we get buffers already
+	 * translated for DMA
+	 */
+	dev->coherent_dma_mask = ~0;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	/*
+	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
+	 * IOB priority registers.  Under heavy network load USB
+	 * hardware can be starved by the IOB causing a crash.  Give
+	 * it a priority boost if it has been waiting more than 400
+	 * cycles to avoid this situation.
+	 *
+	 * Testing indicates that a cnt_val of 8192 is not sufficient,
+	 * but no failures are seen with 4096.  We choose a value of
+	 * 400 to give a safety factor of 10.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
+
+		pri_cnt.u64 = 0;
+		pri_cnt.s.cnt_enb = 1;
+		pri_cnt.s.cnt_val = 400;
+		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
+	}
+
+	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
+	if (!hcd) {
+		DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
+		return -1;
+	}
+	hcd->uses_new_polling = 1;
+	priv = (struct octeon_hcd *)hcd->hcd_priv;
+
+	spin_lock_init(&priv->lock);
+
+	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
+	INIT_LIST_HEAD(&priv->dequeue_list);
+
+#ifdef OCTEON_HCD_DEBUG
+	initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS;
+	initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS;
+	initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS;
+#endif
+	status = cvmx_usb_initialize(&priv->usb, usb_num, initialize_flags);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	/* This delay is needed for CN3010, but I don't know why... */
+	mdelay(10);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	status = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	pr_info("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
+
+	return 0;
+}
+
+static int octeon_usb_remove(struct platform_device *pdev)
+{
+	int status;
+	struct device *dev = &pdev->dev;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+
+	DEBUG_CALL();
+
+	usb_remove_hcd(hcd);
+	tasklet_kill(&priv->dequeue_tasklet);
+	spin_lock_irqsave(&priv->lock, flags);
+	status = cvmx_usb_shutdown(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (status)
+		DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+
+	kfree(hcd);
+
+	return 0;
+}
+
+
+static struct of_device_id octeon_usb_match[] = {
+	{
+		.compatible = "cavium,octeon-5750-usbc",
+	},
+	{},
+};
+
+static struct platform_driver octeon_usb_driver = {
+	.driver = {
+		.name       = "OcteonUSB",
+		.owner		= THIS_MODULE,
+		.of_match_table = octeon_usb_match,
+	},
+	.probe      = octeon_usb_probe,
+	.remove     = octeon_usb_remove,
+};
+
+static int __init octeon_usb_driver_init(void)
+{
+	if (usb_disabled())
+		return 0;
+
+	return platform_driver_register(&octeon_usb_driver);
+}
+module_init(octeon_usb_driver_init);
+
+static void __exit octeon_usb_driver_exit(void)
+{
+	if (usb_disabled())
+		return 0;
+
+	return platform_driver_unregister(&octeon_usb_driver);
+}
+module_exit(octeon_usb_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium, Inc. <support@cavium.com>");
+MODULE_DESCRIPTION("Cavium Inc. OCTEON USB Host driver.");
-- 
1.7.5.4

