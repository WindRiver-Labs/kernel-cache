From 474de0e24671347e7a7192279691d31f9ee8cc5f Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 26 Nov 2012 13:08:40 -0800
Subject: [PATCH 235/337] MIPS: OCTEON: Add cvmx-twsi API files.

Based On SDK 3.0.0-482

Needed by SPI4000.  These are just an adaptor to the Linux I2C core.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig               |    2 +
 arch/mips/cavium-octeon/executive/Kconfig     |    4 +
 arch/mips/cavium-octeon/executive/Makefile    |    1 +
 arch/mips/cavium-octeon/executive/cvmx-twsi.c |  279 +++++++++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-twsi.h      |  276 ++++++++++++++++++++++++
 5 files changed, 562 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/Kconfig
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-twsi.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-twsi.h

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index c2ed759..70b6cf9e 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -225,4 +225,6 @@ config OCTEON_ILM
 	  To compile this driver as a module, choose M here.  The module
 	  will be called octeon-ilm
 
+source "arch/mips/cavium-octeon/executive/Kconfig"
+
 endif # CPU_CAVIUM_OCTEON
diff --git a/arch/mips/cavium-octeon/executive/Kconfig b/arch/mips/cavium-octeon/executive/Kconfig
new file mode 100644
index 0000000..75b3a9d
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/Kconfig
@@ -0,0 +1,4 @@
+
+config CAVIUM_OCTEON_EXECUTIVE_TWSI
+	def_bool y
+	depends on I2C_OCTEON && OCTEON_ETHERNET
diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index c19cbdb..ad5d542 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -27,3 +27,4 @@ obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 obj-$(CONFIG_USB_OCTEON_HCD) += cvmx-usb.o
 obj-$(CONFIG_CAVIUM_OCTEON_RAPIDIO) += cvmx-dma-engine.o
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)	+= cvmx-nand.o
+obj-$(CONFIG_CAVIUM_OCTEON_EXECUTIVE_TWSI) += cvmx-twsi.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-twsi.c b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
new file mode 100644
index 0000000..89a4a59
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
@@ -0,0 +1,279 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+#include <linux/export.h>
+#include <linux/i2c.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-twsi.h>
+
+struct i2c_adapter *__cvmx_twsix_get_adapter(int twsi_id)
+{
+	struct i2c_adapter *adapter;
+	int i2c_id;
+
+	i2c_id = octeon_i2c_cvmx2i2c(twsi_id);
+	if (i2c_id < 0)
+		return NULL;
+
+	adapter = i2c_get_adapter(i2c_id);
+
+	return adapter;
+}
+EXPORT_SYMBOL(__cvmx_twsix_get_adapter);
+
+
+/**
+ * Do a twsi read from a 7 bit device address using an (optional) internal address.
+ * Up to 8 bytes can be read at a time.
+ *
+ * @twsi_id:   which Octeon TWSI bus to use
+ * @dev_addr:  Device address (7 bit)
+ * @internal_addr:
+ *                  Internal address.  Can be 0, 1 or 2 bytes in width
+ * @num_bytes: Number of data bytes to read
+ * @ia_width_bytes:
+ *                  Internal address size in bytes (0, 1, or 2)
+ * @data:      Pointer argument where the read data is returned.
+ *
+ * Returns read data returned in 'data' argument
+ *         Number of bytes read on success
+ *         -1 on failure
+ */
+int cvmx_twsix_read_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, int num_bytes, int ia_width_bytes, uint64_t * data)
+{
+	struct i2c_adapter *adapter;
+	u8 data_buf[8];
+	u8 addr_buf[8];
+	struct i2c_msg msg[2];
+	uint64_t r;
+	int i, j;
+
+	if (ia_width_bytes == 0)
+		return cvmx_twsix_read(twsi_id, dev_addr, num_bytes, data);
+
+	BUG_ON(ia_width_bytes > 2);
+	BUG_ON(num_bytes > 8 || num_bytes < 1);
+
+	adapter = __cvmx_twsix_get_adapter(twsi_id);
+	if (adapter == NULL)
+		return -1;
+
+	for (j = 0, i = ia_width_bytes - 1; i >= 0; i--, j++)
+		addr_buf[j] = (u8) (internal_addr >> (i * 8));
+
+	msg[0].addr = dev_addr;
+	msg[0].flags = 0;
+	msg[0].len = ia_width_bytes;
+	msg[0].buf = addr_buf;
+
+	msg[1].addr = dev_addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = num_bytes;
+	msg[1].buf = data_buf;
+
+	i = i2c_transfer(adapter, msg, 2);
+
+	i2c_put_adapter(adapter);
+
+	if (i == 2) {
+		r = 0;
+		for (i = 0; i < num_bytes; i++)
+			r = (r << 8) | data_buf[i];
+		*data = r;
+		return num_bytes;
+	} else {
+		return -1;
+	}
+}
+
+EXPORT_SYMBOL(cvmx_twsix_read_ia);
+
+/**
+ * Read from a TWSI device (7 bit device address only) without generating any
+ * internal addresses.
+ * Read from 1-8 bytes and returns them in the data pointer.
+ *
+ * @twsi_id:   TWSI interface on Octeon to use
+ * @dev_addr:  TWSI device address (7 bit only)
+ * @num_bytes: number of bytes to read
+ * @data:      Pointer to data read from TWSI device
+ *
+ * Returns Number of bytes read on success
+ *         -1 on error
+ */
+int cvmx_twsix_read(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t * data)
+{
+	struct i2c_adapter *adapter;
+	u8 data_buf[8];
+	struct i2c_msg msg[1];
+	uint64_t r;
+	int i;
+
+	BUG_ON(num_bytes > 8 || num_bytes < 1);
+
+	adapter = __cvmx_twsix_get_adapter(twsi_id);
+	if (adapter == NULL)
+		return -1;
+
+	msg[0].addr = dev_addr;
+	msg[0].flags = I2C_M_RD;
+	msg[0].len = num_bytes;
+	msg[0].buf = data_buf;
+
+	i = i2c_transfer(adapter, msg, 1);
+
+	i2c_put_adapter(adapter);
+
+	if (i == 1) {
+		r = 0;
+		for (i = 0; i < num_bytes; i++)
+			r = (r << 8) | data_buf[i];
+		*data = r;
+		return num_bytes;
+	} else {
+		return -1;
+	}
+}
+
+/**
+ * Perform a twsi write operation to a 7 bit device address.
+ *
+ * Note that many eeprom devices have page restrictions regarding address boundaries
+ * that can be crossed in one write operation.  This is device dependent, and this routine
+ * does nothing in this regard.
+ * This command does not generate any internal addressess.
+ *
+ * @twsi_id:   Octeon TWSI interface to use
+ * @dev_addr:  TWSI device address
+ * @num_bytes: Number of bytes to write (between 1 and 8 inclusive)
+ * @data:      Data to write
+ *
+ * Returns 0 on success
+ *         -1 on failure
+ */
+int cvmx_twsix_write(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t data)
+{
+	struct i2c_adapter *adapter;
+	u8 data_buf[8];
+	struct i2c_msg msg[1];
+	int i, j;
+
+	BUG_ON(num_bytes > 8 || num_bytes < 1);
+
+	adapter = __cvmx_twsix_get_adapter(twsi_id);
+	if (adapter == NULL)
+		return -1;
+
+	for (j = 0, i = num_bytes - 1; i >= 0; i--, j++)
+		data_buf[j] = (u8) (data >> (i * 8));
+
+	msg[0].addr = dev_addr;
+	msg[0].flags = 0;
+	msg[0].len = num_bytes;
+	msg[0].buf = data_buf;
+
+	i = i2c_transfer(adapter, msg, 1);
+
+	i2c_put_adapter(adapter);
+
+	if (i == 1)
+		return num_bytes;
+	else
+		return -1;
+}
+
+/**
+ * Write 1-8 bytes to a TWSI device using an internal address.
+ *
+ * @twsi_id:   which TWSI interface on Octeon to use
+ * @dev_addr:  TWSI device address (7 bit only)
+ * @internal_addr:
+ *                  TWSI internal address (0, 8, or 16 bits)
+ * @num_bytes: Number of bytes to write (1-8)
+ * @ia_width_bytes:
+ *                  internal address width, in bytes (0, 1, 2)
+ * @data:      Data to write.  Data is written MSB first on the twsi bus, and only the lower
+ *                  num_bytes bytes of the argument are valid.  (If a 2 byte write is done, only
+ *                  the low 2 bytes of the argument is used.
+ *
+ * Returns Number of bytes read on success,
+ *         -1 on error
+ */
+int cvmx_twsix_write_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, int num_bytes, int ia_width_bytes, uint64_t data)
+{
+	struct i2c_adapter *adapter;
+	u8 data_buf[8];
+	u8 addr_buf[8];
+	struct i2c_msg msg[2];
+	int i, j;
+
+	if (ia_width_bytes == 0)
+		return cvmx_twsix_write(twsi_id, dev_addr, num_bytes, data);
+
+	BUG_ON(ia_width_bytes > 2);
+	BUG_ON(num_bytes > 8 || num_bytes < 1);
+
+	adapter = __cvmx_twsix_get_adapter(twsi_id);
+	if (adapter == NULL)
+		return -1;
+
+	for (j = 0, i = ia_width_bytes - 1; i >= 0; i--, j++)
+		addr_buf[j] = (u8) (internal_addr >> (i * 8));
+
+	for (j = 0, i = num_bytes - 1; i >= 0; i--, j++)
+		data_buf[j] = (u8) (data >> (i * 8));
+
+	msg[0].addr = dev_addr;
+	msg[0].flags = 0;
+	msg[0].len = ia_width_bytes;
+	msg[0].buf = addr_buf;
+
+	msg[1].addr = dev_addr;
+	msg[1].flags = 0;
+	msg[1].len = num_bytes;
+	msg[1].buf = data_buf;
+
+	i = i2c_transfer(adapter, msg, 2);
+
+	i2c_put_adapter(adapter);
+
+	if (i == 2) {
+		/* Poll until reads succeed, or polling times out */
+		int to = 100;
+		while (to-- > 0) {
+			uint64_t data;
+			if (cvmx_twsix_read(twsi_id, dev_addr, 1, &data) >= 0)
+				break;
+		}
+	}
+
+	if (i == 2)
+		return num_bytes;
+	else
+		return -1;
+}
+
diff --git a/arch/mips/include/asm/octeon/cvmx-twsi.h b/arch/mips/include/asm/octeon/cvmx-twsi.h
new file mode 100644
index 0000000..20be276
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-twsi.h
@@ -0,0 +1,276 @@
+/***********************license start***************
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2010 Cavium Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Inc. for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Interface to the TWSI / I2C bus
+ *
+ * Note: Currently on 7 bit device addresses are supported
+ *
+ *
+ */
+
+#ifndef __CVMX_TWSI_H__
+#define __CVMX_TWSI_H__
+
+
+
+/**
+ * Do a twsi read from a 7 bit device address using an (optional) internal address.
+ * Up to 8 bytes can be read at a time.
+ *
+ * @twsi_id:   which Octeon TWSI bus to use
+ * @dev_addr:  Device address (7 bit)
+ * @internal_addr:
+ *                  Internal address.  Can be 0, 1 or 2 bytes in width
+ * @num_bytes: Number of data bytes to read
+ * @ia_width_bytes:
+ *                  Internal address size in bytes (0, 1, or 2)
+ * @data:      Pointer argument where the read data is returned.
+ *
+ * Returns read data returned in 'data' argument
+ *         Number of bytes read on success
+ *         -1 on failure
+ */
+int cvmx_twsix_read_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, int num_bytes, int ia_width_bytes, uint64_t * data);
+
+/**
+ * A convenience wrapper function around cvmx_twsix_read_ia() that
+ * only supports 8 bit internal addresses.
+ * Reads up to 7 bytes, and returns both the value read or error
+ * value in the return value
+ *
+ * @twsi_id:   which Octeon TWSI bus to use
+ * @dev_addr:  Device address (7 bit only)
+ * @internal_addr:
+ *                  Internal address (8 bit only)
+ * @num_bytes: Number of bytes to read (0-7)
+ *
+ * Returns Value read from TWSI on success
+ *         -1 on error
+ */
+static inline int64_t cvmx_twsix_read_ia8(int twsi_id, uint8_t dev_addr, uint8_t internal_addr, int num_bytes)
+{
+	uint64_t data;
+	if (num_bytes < 1 || num_bytes > 7)
+		return -1;
+	if (cvmx_twsix_read_ia(twsi_id, dev_addr, internal_addr, num_bytes, 1, &data) < 0)
+		return -1;
+	return data;
+}
+
+/**
+ * A convenience wrapper function around cvmx_twsix_read_ia() that
+ * only supports 16 bit internal addresses.
+ * Reads up to 7 bytes, and returns both the value read or error
+ * value in the return value
+ *
+ * @twsi_id:   which Octeon TWSI bus to use
+ * @dev_addr:  Device address (7 bit only)
+ * @internal_addr:
+ *                  Internal address (16 bit only)
+ * @num_bytes: Number of bytes to read (0-7)
+ *
+ * Returns Value read from TWSI on success
+ *         -1 on error
+ */ static inline int64_t cvmx_twsix_read_ia16(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, int num_bytes)
+{
+	uint64_t data;
+	if (num_bytes < 1 || num_bytes > 7)
+		return -1;
+	if (cvmx_twsix_read_ia(twsi_id, dev_addr, internal_addr, num_bytes, 2, &data) < 0)
+		return -1;
+	return data;
+}
+
+/**
+ * Read from a TWSI device (7 bit device address only) without generating any
+ * internal addresses.
+ * Read from 1-8 bytes and returns them in the data pointer.
+ *
+ * @twsi_id:   TWSI interface on Octeon to use
+ * @dev_addr:  TWSI device address (7 bit only)
+ * @num_bytes: number of bytes to read
+ * @data:      Pointer to data read from TWSI device
+ *
+ * Returns Number of bytes read on success
+ *         -1 on error
+ */
+int cvmx_twsix_read(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t * data);
+
+/**
+ * Perform a twsi write operation to a 7 bit device address.
+ *
+ * Note that many eeprom devices have page restrictions regarding address boundaries
+ * that can be crossed in one write operation.  This is device dependent, and this routine
+ * does nothing in this regard.
+ * This command does not generate any internal addressess.
+ *
+ * @twsi_id:   Octeon TWSI interface to use
+ * @dev_addr:  TWSI device address
+ * @num_bytes: Number of bytes to write (between 1 and 8 inclusive)
+ * @data:      Data to write
+ *
+ * Returns 0 on success
+ *         -1 on failure
+ */
+int cvmx_twsix_write(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t data);
+
+/**
+ * Write 1-8 bytes to a TWSI device using an internal address.
+ *
+ * @twsi_id:   which TWSI interface on Octeon to use
+ * @dev_addr:  TWSI device address (7 bit only)
+ * @internal_addr:
+ *                  TWSI internal address (0, 8, or 16 bits)
+ * @num_bytes: Number of bytes to write (1-8)
+ * @ia_width_bytes:
+ *                  internal address width, in bytes (0, 1, 2)
+ * @data:      Data to write.  Data is written MSB first on the twsi bus, and only the lower
+ *                  num_bytes bytes of the argument are valid.  (If a 2 byte write is done, only
+ *                  the low 2 bytes of the argument is used.
+ *
+ * Returns Number of bytes read on success,
+ *         -1 on error
+ */
+int cvmx_twsix_write_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, int num_bytes, int ia_width_bytes, uint64_t data);
+
+/***********************************************************************
+** Functions below are deprecated, and not recomended for use.
+** They have been superceded by more flexible functions that are
+** now provided.
+************************************************************************/
+
+/**
+ * Read 8-bit from a device on the TWSI / I2C bus
+ *
+ * @twsi_id:  Which TWSI bus to use. CN3XXX, CN58XX, and CN50XX only
+ *                 support 0. CN56XX and CN57XX support 0-1.
+ * @dev_addr: I2C device address (7 bit)
+ * @internal_addr:
+ *                 Internal device address
+ *
+ * Returns 8-bit data or < 0 in case of error
+ */
+static inline int cvmx_twsix_read8(int twsi_id, uint8_t dev_addr, uint8_t internal_addr)
+{
+	return cvmx_twsix_read_ia8(twsi_id, dev_addr, internal_addr, 1);
+}
+
+/**
+ * Read 8-bit from a device on the TWSI / I2C bus
+ *
+ * Uses current internal address
+ *
+ * @twsi_id:  Which TWSI bus to use. CN3XXX, CN58XX, and CN50XX only
+ *                 support 0. CN56XX and CN57XX support 0-1.
+ * @dev_addr: I2C device address (7 bit)
+ *
+ * Returns 8-bit value or < 0 in case of error
+ */
+static inline int cvmx_twsix_read8_cur_addr(int twsi_id, uint8_t dev_addr)
+{
+	uint64_t data;
+
+	if (cvmx_twsix_read(twsi_id, dev_addr, 1, &data) < 0)
+		return -1;
+	return (data & 0xff);
+}
+
+/**
+ * Write 8-bit to a device on the TWSI / I2C bus
+ *
+ * @twsi_id:  Which TWSI bus to use. CN3XXX, CN58XX, and CN50XX only
+ *                 support 0. CN56XX and CN57XX support 0-1.
+ * @dev_addr: I2C device address (7 bit)
+ * @internal_addr:
+ *                 Internal device address
+ * @data:     Data to be written
+ *
+ * Returns 0 on success and < 0 in case of error
+ */
+static inline int cvmx_twsix_write8(int twsi_id, uint8_t dev_addr, uint8_t internal_addr, uint8_t data)
+{
+	if (cvmx_twsix_write_ia(twsi_id, dev_addr, internal_addr, 1, 1, data) < 0)
+		return -1;
+	return 0;
+}
+
+/**
+ * Read 8-bit from a device on the TWSI / I2C bus zero.
+ *
+ * This function is for compatibility with SDK 1.6.0 and
+ * before which only supported a single TWSI bus.
+ *
+ * @dev_addr: I2C device address (7 bit)
+ * @internal_addr:
+ *                 Internal device address
+ *
+ * Returns 8-bit data or < 0 in case of error
+ */
+static inline int cvmx_twsi_read8(uint8_t dev_addr, uint8_t internal_addr)
+{
+	return cvmx_twsix_read8(0, dev_addr, internal_addr);
+}
+
+/**
+ * Read 8-bit from a device on the TWSI / I2C bus zero.
+ *
+ * Uses current internal address
+ *
+ * This function is for compatibility with SDK 1.6.0 and
+ * before which only supported a single TWSI bus.
+ *
+ * @dev_addr: I2C device address (7 bit)
+ *
+ * Returns 8-bit value or < 0 in case of error
+ */
+static inline int cvmx_twsi_read8_cur_addr(uint8_t dev_addr)
+{
+	return cvmx_twsix_read8_cur_addr(0, dev_addr);
+}
+
+/**
+ * Write 8-bit to a device on the TWSI / I2C bus zero.
+ * This function is for compatibility with SDK 1.6.0 and
+ * before which only supported a single TWSI bus.
+ *
+ * @dev_addr: I2C device address (7 bit)
+ * @internal_addr:
+ *                 Internal device address
+ * @data:     Data to be written
+ *
+ * Returns 0 on success and < 0 in case of error
+ */
+static inline int cvmx_twsi_write8(uint8_t dev_addr, uint8_t internal_addr, uint8_t data)
+{
+	return cvmx_twsix_write8(0, dev_addr, internal_addr, data);
+}
+
+
+#endif /*  __CVMX_TWSI_H__ */
-- 
1.7.5.4

