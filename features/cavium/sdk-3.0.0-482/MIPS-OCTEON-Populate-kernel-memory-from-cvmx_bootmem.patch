From c6af4928a04c3ab2e02d75ed9165526f70db1ee3 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 28 Nov 2012 16:22:45 -0800
Subject: [PATCH 245/337] MIPS: OCTEON: Populate kernel memory from
 cvmx_bootmem named blocks.

Based On SDK 3.0.0-482

Command line syntax is:

  mem=block:block_name1,block_name2,...

A maximum of 4 blocks are currently supported

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |   66 +++++++++++++++++++++++++++++++++------
 1 files changed, 56 insertions(+), 10 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index d395778..d234cd5 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -75,6 +75,9 @@ EXPORT_SYMBOL(octeon_bootloader_entry_addr);
 /* If an initrd named block is specified, its name goes here. */
 static char __initdata rd_name[64];
 
+/* Up to four blocks may be specified. */
+static char __initdata named_memory_blocks[4][CVMX_BOOTMEM_NAME_LEN];
+
 /**
  * Return non zero if we are currently running in the Octeon simulator
  *
@@ -727,8 +730,26 @@ void __init prom_init(void)
 	argc = octeon_boot_desc_ptr->argc;
 	for (i = 0; i < argc; i++) {
 		const char *arg = phys_to_virt(octeon_boot_desc_ptr->argv[i]);
-		if ((strncmp(arg, "MEM=", 4) == 0) ||
-		    (strncmp(arg, "mem=", 4) == 0)) {
+		if (strncmp(arg, "mem=block:", 10) == 0) {
+			const char *pos = arg + 10;
+			i = 0;
+			for (i = 0; pos[0] && i < ARRAY_SIZE(named_memory_blocks); i++) {
+				int len;
+				char *comma = strchr(pos, ',');
+				if (comma)
+					len = comma - pos;
+				else
+					len = max(strlen(pos), ARRAY_SIZE(named_memory_blocks[0]));
+				strncpy(named_memory_blocks[i], pos, len);
+				if (comma)
+					pos = comma + 1;
+				else
+					break;
+			}
+			for (i = 0; i < ARRAY_SIZE(named_memory_blocks); i++)
+				pr_err("Named Block[%d] = \"%s\"\n", i, named_memory_blocks[i]);
+		} else if ((strncmp(arg, "MEM=", 4) == 0) ||
+			   (strncmp(arg, "mem=", 4) == 0)) {
 			sscanf(arg + 4, "%llu", &MAX_MEMORY);
 			MAX_MEMORY <<= 20;
 			if (MAX_MEMORY == 0)
@@ -809,23 +830,46 @@ void __init plat_mem_setup(void)
 	uint64_t mem_alloc_size;
 	uint64_t total = 0;
 	int64_t memory;
+	const struct cvmx_bootmem_named_block_desc *named_block;
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	const struct cvmx_bootmem_named_block_desc *initrd_block;
-
 	if (rd_name[0]) {
-		initrd_block = cvmx_bootmem_find_named_block(rd_name);
-		if (initrd_block != NULL) {
-			initrd_start = initrd_block->base_addr + PAGE_OFFSET;
-			initrd_end = initrd_start + initrd_block->size;
-			add_memory_region(initrd_block->base_addr, initrd_block->size,
+		named_block = cvmx_bootmem_find_named_block(rd_name);
+		if (named_block != NULL) {
+			initrd_start = named_block->base_addr + PAGE_OFFSET;
+			initrd_end = initrd_start + named_block->size;
+			add_memory_region(named_block->base_addr, named_block->size,
 					  BOOT_MEM_INIT_RAM);
 			initrd_in_reserved = 1;
-			total += initrd_block->size;
+			total += named_block->size;
 		}
 	}
 #endif
 
+	if (named_memory_blocks[0][0]) {
+		/* Memory from named blocks only */
+		int i;
+
+		for (i = 0;
+		     named_memory_blocks[i][0] && i < ARRAY_SIZE(named_memory_blocks);
+		     i++) {
+			named_block = cvmx_bootmem_find_named_block(named_memory_blocks[i]);
+			if (!named_block) {
+				pr_err("Error: Couldn't find cvmx_bootmem block \"%s\"",
+				       named_memory_blocks[i]);
+				return;
+			}
+			pr_info("Adding memory from \"%s\": %016lx @ %016lx\n",
+				named_memory_blocks[i],
+				(unsigned long)named_block->size,
+				(unsigned long)named_block->base_addr);
+			add_memory_region(named_block->base_addr, named_block->size,
+					  BOOT_MEM_RAM);
+			total += named_block->size;
+		}
+		goto mem_alloc_done;
+	}
+
 	/*
 	 * The Mips memory init uses the first memory location for
 	 * some memory vectors. When SPARSEMEM is in use, it doesn't
@@ -888,6 +932,8 @@ void __init plat_mem_setup(void)
 	}
 	cvmx_bootmem_unlock();
 
+mem_alloc_done:
+
 #if CONFIG_CAVIUM_RESERVE32 > 0
 	/*
 	 * Now that we've allocated the kernel memory it is safe to
-- 
1.7.5.4

