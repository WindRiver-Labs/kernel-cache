From 690daadfde7f925e4847630475a80341efb37b85 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 5 Oct 2012 14:46:34 -0700
Subject: [PATCH 184/337] MIPS: OCTEON: Remove
 CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER

Based On SDK 3.0.0-482

Nobody uses it, and it isn't bulletproof.  Also there is no benefit
with OCTEON II or later CPUs.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig |   26 --------------------
 arch/mips/kernel/traps.c        |   49 ---------------------------------------
 2 files changed, 0 insertions(+), 75 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index c88b391..26cc832 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -59,32 +59,6 @@ config FAST_ACCESS_TO_THREAD_POINTER
 	  the TLB fault handlers. This CVMSEG address isn't available to user
 	  applications.
 
-config REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-	bool "Support dynamically replacing emulated thread pointer accesses"
-	default "y"
-	help
-	  When this option is set, the kernel can dynamically replace slower
-	  references to the thread pointer with fast accesses. This involves
-	  replacing userspace instructions at runtime, so it may not work with
-	  all programs. It is advised to use a toolchain that creates code for
-	  FAST_ACCESS_TO_THREAD_POINTER instead of this option. If you have
-	  code compiled with a Cavium compiler prior to release 1.5, or are
-	  using a non Cavium compiler, this option may allow you to receive
-	  most of the benefit of direct access to the thread pointer. It may
-	  also cause programs to fail.
-
-	  Instruction replacement is disabled on boot. It can be controlled by
-	  writing a mode to /sys/module/traps/parameters/thread_pointer_mode.
-	  The supported modes are:
-
-	  0 - Use the normal kernel emulation without any changes.
-	  1 - Replace emulated instructions with direct accesses to the thread
-		register.
-	  2 - Replace emulated instructions and log the replacement PC.
-	  3 - Replace emulated instructions with break instructions. This will
-		cause programs to fail, but makes it easy to stop gdb on the
-		instruction.
-
 config CAVIUM_OCTEON_LOCK_L2
 	bool "Lock often used kernel code in the L2"
 	default "y"
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 5896c31..e54d347 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -92,20 +92,6 @@ extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 				    struct mips_fpu_struct *ctx, int has_fpu,
 				    void *__user *fault_addr);
 
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-/*
- *	0 - Use the normal kernel emulation without any changes.
- *	1 - Replace emulated instructions with direct accesses to the thread
- *	    register.
- *	2 - Replace emulated instructions and log the replacement PC.
- *	3 - Replace emulated instructions with break instructions. This will
- *	    cause programs to fail, but makes it easy to stop gdb on the
- *	    instruction.
- */
-static int thread_pointer_mode;
-module_param(thread_pointer_mode, int, 0644);
-#endif
-
 void (*board_be_init)(void);
 int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
 void (*board_nmi_handler_setup)(void);
@@ -625,9 +611,6 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 {
 	struct thread_info *ti = task_thread_info(current);
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-	unsigned int __user *epc = (unsigned int __user *)regs->cp0_epc + ((regs->cp0_cause & CAUSEF_BD) != 0);
-#endif
 
 	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
 		int rd = (opcode & RD) >> 11;
@@ -657,43 +640,11 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-			if (thread_pointer_mode) {
-				/* move [rt], k0 */
-				unsigned int new_instruction = 0x00000025 | (26 << 21) | (rt << 11);
-				if (thread_pointer_mode == 3)
-					new_instruction = 0x0000000d; /* break */
-				if (access_process_vm(current,
-						      (unsigned long)epc,
-						      &new_instruction,
-						      sizeof(new_instruction), 1) != sizeof(new_instruction))
-					pr_err("Failed to replaced emulated RDHWR at PC=%p\n", epc);
-				if (thread_pointer_mode == 2)
-					pr_info("Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n", epc, rt);
-				else if (thread_pointer_mode == 3)
-					pr_info("Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
-			}
-#endif
 			return 0;
 		default:
 			return -1;
 		}
 	}
-
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-	else if (opcode == (0x00000025 | (26 << 21) | (3 << 11))) {
-		/*
-		 * opcode is: move v1, k0
-		 *
-		 * We need to flush the icache, not emulate an
-		 * instruction. The EPC is wrong, so we need to put it
-		 * back to the old instruction.
-		 */
-		regs->cp0_epc = (unsigned long)epc;
-		flush_cache_sigtramp((unsigned long)epc);
-		return 0;
-	}
-#endif
 	/* Not ours.  */
 	return -1;
 }
-- 
1.7.5.4

