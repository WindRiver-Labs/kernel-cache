From 850ad206e360c4bdf3612418ba2356cebfea96cc Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Wed, 26 Feb 2014 17:56:51 -0800
Subject: [PATCH 102/122] MIPS/OCTEON: Allow each interrupt major block to use
 its own domain.

Source: Cavium Networks, Inc.
MR: 9354
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 287d4903ce6811f631c12da409b43216f5c447a7
Description:

Allow each interrupt major block to use its own domain.

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 118 ++++++++++++++++++++++++-----------
 1 file changed, 80 insertions(+), 38 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index f8df711..344993f 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -27,16 +27,25 @@ static DEFINE_PER_CPU(raw_spinlock_t, octeon_irq_ciu_spinlock);
 
 static DEFINE_PER_CPU(unsigned int, octeon_irq_ciu3_idt_ip2);
 static DEFINE_PER_CPU(unsigned int, octeon_irq_ciu3_idt_ip3);
-static DEFINE_PER_CPU(struct irq_domain *, octeon_irq_ciu3_domain);
-static DEFINE_PER_CPU(u64, octeon_irq_ciu3_addr);
+static DEFINE_PER_CPU(struct octeon_ciu3_info *, octeon_ciu3_info);
 #define CIU3_MBOX_PER_CORE 10
 
-static struct irq_domain *octeon_irq_ciu_domain_per_node[4];
+/*
+ * The 8 most significant bits of the intsn identify the interrupt major block.
+ * Each major block might use its own interrupt domain. Thus 256 domains are
+ * needed.
+ */
+#define MAX_CIU3_DOMAINS		256
 
-struct octeon_irq_ciu3_domain_data {
-	u64 ciu3_addr;
+/* Information for each ciu3 in the system */
+struct octeon_ciu3_info {
+	u64			ciu3_addr;
+	struct irq_domain	*domain[MAX_CIU3_DOMAINS];
 };
 
+/* Each ciu3 in the system uses its own data (one ciu3 per node) */
+static struct octeon_ciu3_info	*octeon_ciu3_info_per_node[4];
+
 struct octeon_irq_ciu_domain_data {
 	int num_sum;  /* number of sum registers (2 or 3). */
 };
@@ -2196,7 +2205,7 @@ static int octeon_irq_ciu3_xlat(struct irq_domain *d,
 				unsigned long *out_hwirq,
 				unsigned int *out_type)
 {
-	struct octeon_irq_ciu3_domain_data *dd;
+	struct octeon_ciu3_info *ciu3_info = d->host_data;
 	unsigned int hwirq, type, intsn_major;
 	union cvmx_ciu3_iscx_ctl isc;
 	hwirq = intspec[0];
@@ -2213,8 +2222,7 @@ static int octeon_irq_ciu3_xlat(struct irq_domain *d,
 		break;
 	}
 
-	dd = d->host_data;
-	isc.u64 =  cvmx_read_csr(dd->ciu3_addr + CIU3_ISC_CTL(hwirq));
+	isc.u64 =  cvmx_read_csr(ciu3_info->ciu3_addr + CIU3_ISC_CTL(hwirq));
 	if (!isc.s.imp)
 		return -EINVAL;
 
@@ -2238,14 +2246,14 @@ static int octeon_irq_ciu3_xlat(struct irq_domain *d,
 static int octeon_irq_ciu3_map(struct irq_domain *d,
 			       unsigned int virq, irq_hw_number_t hw)
 {
-	struct octeon_irq_ciu3_domain_data *dd = d->host_data;
+	struct octeon_ciu3_info *ciu3_info = d->host_data;
 	struct octeon_ciu_chip_data *cd = kzalloc_node(sizeof(*cd), GFP_KERNEL,
 						       of_node_to_nid(d->of_node));
 	if (!cd)
 		return -ENOMEM;
 	cd->intsn = hw;
 	cd->current_cpu = -1;
-	cd->ciu3_addr = dd->ciu3_addr;
+	cd->ciu3_addr = ciu3_info->ciu3_addr;
 
 	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3,
 				 octeon_irq_handle_trigger);
@@ -2254,7 +2262,7 @@ static int octeon_irq_ciu3_map(struct irq_domain *d,
 	return 0;
 }
 
-static struct irq_domain_ops octeon_irq_domain_ciu3_ops = {
+static struct irq_domain_ops octeon_dflt_domain_ciu3_ops = {
 	.map = octeon_irq_ciu3_map,
 	.unmap = octeon_irq_free_cd,
 	.xlate = octeon_irq_ciu3_xlat,
@@ -2269,21 +2277,30 @@ static int octeon_irq_get_local_core_num(void)
 static void octeon_irq_ciu3_ip2(void)
 {
 	union cvmx_ciu3_destx_pp_int dest_pp_int;
-	struct irq_domain *d = __this_cpu_read(octeon_irq_ciu3_domain);
-	u64 ciu3_addr =  __this_cpu_read(octeon_irq_ciu3_addr);
+	struct octeon_ciu3_info *ciu3_info;
+	u64 ciu3_addr;
+
+	ciu3_info = __this_cpu_read(octeon_ciu3_info);
+	ciu3_addr = ciu3_info->ciu3_addr;
 
 	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(3 * octeon_irq_get_local_core_num()));
 
 	if (likely(dest_pp_int.s.intr)) {
 		irq_hw_number_t intsn = dest_pp_int.s.intsn;
-		int irq = irq_find_mapping(d, intsn);
+		/* Get the domain to use from the major block */
+		int block = intsn >> 12;
+		int irq = irq_find_mapping(ciu3_info->domain[block], intsn);
 
 		if (likely(irq)) {
 			do_IRQ(irq);
 		} else {
-			u64 isc_ctl_addr = ciu3_addr + CIU3_ISC_CTL(intsn);
-			cvmx_write_csr(isc_ctl_addr, 0);
-			cvmx_read_csr(isc_ctl_addr);
+			union cvmx_ciu3_iscx_w1c isc_w1c;
+			u64 isc_w1c_addr = ciu3_addr + CIU3_ISC_W1C(intsn);
+
+			isc_w1c.u64 = 0;
+			isc_w1c.s.en = 1;
+			cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+			cvmx_read_csr(isc_w1c_addr);
 			spurious_interrupt();
 		}
 	} else {
@@ -2314,9 +2331,13 @@ static unsigned int octeon_irq_ciu3_mbox_intsn_for_cpu(int cpu, unsigned int mbo
 static void octeon_irq_ciu3_mbox(void)
 {
 	union cvmx_ciu3_destx_pp_int dest_pp_int;
-	u64 ciu3_addr = __this_cpu_read(octeon_irq_ciu3_addr);
+	struct octeon_ciu3_info *ciu3_info;
+	u64 ciu3_addr;
 	int core = octeon_irq_get_local_core_num();
 
+	ciu3_info = __this_cpu_read(octeon_ciu3_info);
+	ciu3_addr = ciu3_info->ciu3_addr;
+
 	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(1 + 3 * core));
 
 	if (likely(dest_pp_int.s.intr)) {
@@ -2326,9 +2347,13 @@ static void octeon_irq_ciu3_mbox(void)
 		if (likely(mbox >= 0 && mbox < CIU3_MBOX_PER_CORE)) {
 			do_IRQ(mbox + OCTEON_IRQ_MBOX0);
 		} else {
-			u64 isc_ctl_addr = ciu3_addr + CIU3_ISC_CTL(intsn);
-			cvmx_write_csr(isc_ctl_addr, 0);
-			cvmx_read_csr(isc_ctl_addr);
+			union cvmx_ciu3_iscx_w1c isc_w1c;
+			u64 isc_w1c_addr = ciu3_addr + CIU3_ISC_W1C(intsn);
+
+			isc_w1c.u64 = 0;
+			isc_w1c.s.en = 1;
+			cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+			cvmx_read_csr(isc_w1c_addr);
 			spurious_interrupt();
 		}
 	} else {
@@ -2338,6 +2363,7 @@ static void octeon_irq_ciu3_mbox(void)
 
 void octeon_ciu3_mbox_send(int cpu, unsigned int mbox)
 {
+	struct octeon_ciu3_info *ciu3_info;
 	unsigned int intsn;
 	union cvmx_ciu3_iscx_w1s isc_w1s;
 	u64 isc_w1s_addr;
@@ -2346,7 +2372,8 @@ void octeon_ciu3_mbox_send(int cpu, unsigned int mbox)
 		return;
 
 	intsn = octeon_irq_ciu3_mbox_intsn_for_cpu(cpu, mbox);
-	isc_w1s_addr = per_cpu(octeon_irq_ciu3_addr, cpu) + CIU3_ISC_W1S(intsn);
+	ciu3_info = per_cpu(octeon_ciu3_info, cpu);
+	isc_w1s_addr = ciu3_info->ciu3_addr + CIU3_ISC_W1S(intsn);
 
 	isc_w1s.u64 = 0;
 	isc_w1s.s.raw = 1;
@@ -2358,13 +2385,15 @@ EXPORT_SYMBOL(octeon_ciu3_mbox_send);
 
 static void octeon_irq_ciu3_mbox_set_enable(struct irq_data *data, int cpu, bool en)
 {
+	struct octeon_ciu3_info *ciu3_info;
 	unsigned int intsn;
 	unsigned int idt;
 	u64 isc_ctl_addr;
 	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
 
 	intsn = octeon_irq_ciu3_mbox_intsn_for_cpu(cpu, mbox);
-	isc_ctl_addr = per_cpu(octeon_irq_ciu3_addr, cpu) + CIU3_ISC_CTL(intsn);
+	ciu3_info = per_cpu(octeon_ciu3_info, cpu);
+	isc_ctl_addr = ciu3_info->ciu3_addr + CIU3_ISC_CTL(intsn);
 
 	idt = per_cpu(octeon_irq_ciu3_idt_ip3, cpu);
 
@@ -2403,6 +2432,7 @@ static void octeon_irq_ciu3_mbox_disable(struct irq_data *data)
 
 static void octeon_irq_ciu3_mbox_ack(struct irq_data *data)
 {
+	struct octeon_ciu3_info *ciu3_info;
 	unsigned int intsn;
 	u64 isc_w1c_addr;
 	union cvmx_ciu3_iscx_w1c isc_w1c;
@@ -2413,7 +2443,8 @@ static void octeon_irq_ciu3_mbox_ack(struct irq_data *data)
 	isc_w1c.u64 = 0;
 	isc_w1c.s.raw = 1;
 
-	isc_w1c_addr = __this_cpu_read(octeon_irq_ciu3_addr) + CIU3_ISC_W1C(intsn);
+	ciu3_info = __this_cpu_read(octeon_ciu3_info);
+	isc_w1c_addr = ciu3_info->ciu3_addr + CIU3_ISC_W1C(intsn);
 	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
 	cvmx_read_csr(isc_w1c_addr);
 }
@@ -2428,17 +2459,15 @@ static void octeon_irq_ciu3_mbox_cpu_offline(struct irq_data *data)
 	octeon_irq_ciu3_mbox_set_enable(data, smp_processor_id(), false);
 }
 
-static int octeon_irq_ciu3_alloc_resources(struct irq_domain *domain)
+static int octeon_irq_ciu3_alloc_resources(struct octeon_ciu3_info *ciu3_info)
 {
-	struct octeon_irq_ciu3_domain_data *dd = domain->host_data;
-	u64 b = dd->ciu3_addr;
+	u64 b = ciu3_info->ciu3_addr;
 	int idt_ip2, idt_ip3;
 	int unused_idt1, unused_idt2;
 	int core = octeon_irq_get_local_core_num();
 	int i;
 
-	__this_cpu_write(octeon_irq_ciu3_domain, domain);
-	__this_cpu_write(octeon_irq_ciu3_addr, dd->ciu3_addr);
+	__this_cpu_write(octeon_ciu3_info, ciu3_info);
 
 	/*
 	 * 4 idt per core starting from 1 because zero is reserved.
@@ -2480,8 +2509,10 @@ static int octeon_irq_ciu3_alloc_resources(struct irq_domain *domain)
 
 static void octeon_irq_setup_secondary_ciu3(void)
 {
-	struct irq_domain *d = octeon_irq_ciu_domain_per_node[cvmx_get_node_num()];
-	octeon_irq_ciu3_alloc_resources(d);
+	struct octeon_ciu3_info *ciu3_info;
+
+	ciu3_info = octeon_ciu3_info_per_node[cvmx_get_node_num()];
+	octeon_irq_ciu3_alloc_resources(ciu3_info);
 	irq_cpu_online();
 
 	/* Enable the CIU lines */
@@ -2508,13 +2539,15 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 {
 	int i;
 	int node;
-	struct octeon_irq_ciu3_domain_data *dd;
+	struct irq_domain *domain;
+	struct octeon_ciu3_info *ciu3_info;
 	const __be32 *zero_addr;
 	u64 base_addr;
 	union cvmx_ciu3_const consts;
 
-	dd = kzalloc_node(sizeof(*dd), GFP_KERNEL, of_node_to_nid(ciu_node));
-	if (!dd)
+	ciu3_info = kzalloc_node(sizeof(*ciu3_info), GFP_KERNEL,
+				 of_node_to_nid(ciu_node));
+	if (!ciu3_info)
 		return -ENOMEM;
 
 	zero_addr = of_get_address(ciu_node, 0, NULL, NULL);
@@ -2525,7 +2558,7 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 	base_addr = (u64)phys_to_virt(base_addr);
 	node = (base_addr >> 36) & 3;
 
-	dd->ciu3_addr = base_addr;
+	ciu3_info->ciu3_addr = base_addr;
 
 	consts.u64 = cvmx_read_csr(base_addr + CIU3_CONST);
 
@@ -2541,10 +2574,19 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 	for (i = 0; i < 8; i++)
 		irq_set_chip_and_handler(i + OCTEON_IRQ_MBOX0, &octeon_irq_chip_ciu3_mbox, handle_percpu_irq);
 
-	octeon_irq_ciu_domain_per_node[node] = irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu3_ops, dd);
-	octeon_irq_ciu3_alloc_resources(octeon_irq_ciu_domain_per_node[node]);
+	/*
+	 * Initialize all domains to use the default domain. Specific major
+	 * blocks will overwrite the default domain as needed.
+	 */
+	domain = irq_domain_add_tree(ciu_node, &octeon_dflt_domain_ciu3_ops,
+				     ciu3_info);
+	for (i = 0; i < MAX_CIU3_DOMAINS; i++)
+		ciu3_info->domain[i] = domain;
+
+	octeon_ciu3_info_per_node[node] = ciu3_info;
+	octeon_irq_ciu3_alloc_resources(ciu3_info);
 	if (node == 0)
-		irq_set_default_host(octeon_irq_ciu_domain_per_node[node]);
+		irq_set_default_host(domain);
 
 	/* Enable the CIU lines */
 	set_c0_status(STATUSF_IP2 | STATUSF_IP3);
-- 
1.8.2.1

