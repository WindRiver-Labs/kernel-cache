From 0bc6f6b9524a8aa765913750be4eaefed62f4cfc Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Thu, 13 Mar 2014 10:37:29 -0700
Subject: [PATCH 119/122] watchdog: Octeon: Add 78xx support.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 89b7b0a3b0ae024b5812b7ef46d089eed2629f59
Description:

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c          |  3 +
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h  |  4 ++
 arch/mips/include/asm/octeon/octeon-feature.h |  4 ++
 drivers/watchdog/octeon-wdt-main.c            | 87 +++++++++++++++++++++------
 4 files changed, 81 insertions(+), 17 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 6fecd8a..aa14866 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -2793,6 +2793,7 @@ void *octeon_irq_get_ciu3_info(int node)
 {
 	return octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 }
+EXPORT_SYMBOL(octeon_irq_get_ciu3_info);
 
 void octeon_irq_add_block_domain(int node, uint8_t block,
 				 struct irq_domain *domain)
@@ -2802,6 +2803,7 @@ void octeon_irq_add_block_domain(int node, uint8_t block,
 	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 	ciu3_info->domain[block] = domain;
 }
+EXPORT_SYMBOL(octeon_irq_add_block_domain);
 
 struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block)
 {
@@ -2810,3 +2812,4 @@ struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block)
 	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 	return ciu3_info->domain[block];
 }
+EXPORT_SYMBOL(octeon_irq_get_block_domain);
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 16838d4..6d72539 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -165,6 +165,8 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 		return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 		return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
+	case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 }
@@ -217,6 +219,8 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 		return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 		return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
+	case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 }
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index 90e05a8..3ccc236 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -83,6 +83,7 @@ enum octeon_feature {
 	OCTEON_FEATURE_HFA,
 	OCTEON_FEATURE_DFM,
 	OCTEON_FEATURE_CIU2,
+	OCTEON_FEATURE_CIU3,
 	OCTEON_MAX_FEATURE
 };
 
@@ -229,6 +230,9 @@ static inline int octeon_has_feature(enum octeon_feature feature)
 	case OCTEON_FEATURE_CIU2:
 		return OCTEON_IS_MODEL(OCTEON_CN68XX);
 
+	case OCTEON_FEATURE_CIU3:
+		return OCTEON_IS_MODEL(OCTEON_CN78XX);
+
 	default:
 		break;
 	}
diff --git a/drivers/watchdog/octeon-wdt-main.c b/drivers/watchdog/octeon-wdt-main.c
index 0d6f1d3..5308a0d 100644
--- a/drivers/watchdog/octeon-wdt-main.c
+++ b/drivers/watchdog/octeon-wdt-main.c
@@ -74,6 +74,9 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
 
+/* Watchdog interrupt major block number (8 MSBs of intsn) */
+#define WD_BLOCK_NUMBER		0x01
+
 /* The count needed to achieve timeout_sec. */
 static unsigned int timeout_cnt;
 
@@ -254,11 +257,12 @@ static irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)
 {
 	unsigned int core = cvmx_get_core_num();
 	int cpu = core2cpu(core);
+	int node = cvmx_get_node_num();
 
 	if (do_coundown) {
 		if (per_cpu_countdown[cpu] > 0) {
 			/* We're alive, poke the watchdog */
-			cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+			cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 			per_cpu_countdown[cpu]--;
 		} else {
 			/* Bad news, you are about to reboot. */
@@ -267,7 +271,7 @@ static irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)
 		}
 	} else {
 		/* Not open, just ping away... */
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 	}
 	return IRQ_HANDLED;
 }
@@ -368,7 +372,7 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 	octeon_wdt_write_hex(cp0_cause, 16);
 	octeon_wdt_write_string("\r\n");
 
-	/* The CIU register are different in cn68xx compared to other models. */
+	/* The CIU register are different on the different octeon models */
 	if (is_ciu2) {
 		octeon_wdt_write_string("\tsrc_wd\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SRC_PPX_IP2_WDOG(coreid)), 16);
@@ -383,7 +387,7 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 		octeon_wdt_write_string("\tsum\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP2(coreid)), 16);
 		octeon_wdt_write_string("\r\n");
-	} else {
+	} else if (!octeon_has_feature(OCTEON_FEATURE_CIU3)) {
 		octeon_wdt_write_string("\tsum0\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_SUM0(coreid * 2)), 16);
 		octeon_wdt_write_string("\ten0\t0x");
@@ -398,18 +402,20 @@ static void octeon_wdt_disable_interrupt(int cpu)
 {
 	unsigned int core;
 	unsigned int irq;
+	int node;
 	union cvmx_ciu_wdogx ciu_wdog;
 
 	core = cpu2core(cpu);
+	node = cpu_to_node(cpu);
 
 	irq = OCTEON_IRQ_WDOG0 + core;
 
 	/* Poke the watchdog to clear out its state */
-	cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+	cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 
 	/* Disable the hardware. */
 	ciu_wdog.u64 = 0;
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 
 	free_irq(irq, octeon_wdt_poke_irq);
 }
@@ -419,31 +425,52 @@ static void octeon_wdt_setup_interrupt(int cpu)
 	unsigned int core;
 	unsigned int irq;
 	union cvmx_ciu_wdogx ciu_wdog;
+	int node;
+	struct irq_domain *domain;
+	int hwirq;
 
 	core = cpu2core(cpu);
+	node = cpu_to_node(cpu);
 
 	/* Disable it before doing anything with the interrupts. */
 	ciu_wdog.u64 = 0;
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 
 	per_cpu_countdown[cpu] = countdown_reset;
 
-	irq = OCTEON_IRQ_WDOG0 + core;
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		/* Must get the domain for the watchdog block */
+		domain = octeon_irq_get_block_domain(node, WD_BLOCK_NUMBER);
+
+		/* Get a irq for the wd intsn (hardware interrupt) */
+		hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | core;
+		irq = irq_create_mapping(domain, hwirq);
+	} else
+		irq = OCTEON_IRQ_WDOG0 + core;
 
 	if (request_irq(irq, octeon_wdt_poke_irq,
 			IRQF_NO_THREAD, "octeon_wdt", octeon_wdt_poke_irq))
 		panic("octeon_wdt: Couldn't obtain irq %d", irq);
 
+	/* Must set the irq affinity here */
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		cpumask_t mask;
+
+		cpumask_clear(&mask);
+		cpumask_set_cpu(cpu, &mask);
+		irq_set_affinity(irq, &mask);
+	}
+
 	cpumask_set_cpu(cpu, &irq_enabled_cpus);
 
 	/* Poke the watchdog to clear out its state */
-	cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+	cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 
 	/* Finally enable the watchdog now that all handlers are installed */
 	ciu_wdog.u64 = 0;
 	ciu_wdog.s.len = timeout_cnt;
 	ciu_wdog.s.mode = 3;	/* 3 = Interrupt + NMI + Soft-Reset */
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 }
 
 static int octeon_wdt_cpu_callback(struct notifier_block *nfb,
@@ -469,18 +496,29 @@ static void octeon_wdt_ping(void)
 {
 	int cpu;
 	int coreid;
+	int node;
+	int irq;
+	struct irq_domain *domain;
+	int hwirq;
 
 	if (disable)
 		return;
 
 	for_each_online_cpu(cpu) {
 		coreid = cpu2core(cpu);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		node = cpu_to_node(cpu);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 		per_cpu_countdown[cpu] = countdown_reset;
 		if ((countdown_reset || !do_coundown) &&
 		    !cpumask_test_cpu(cpu, &irq_enabled_cpus)) {
 			/* We have to enable the irq */
-			int irq = OCTEON_IRQ_WDOG0 + coreid;
+			if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+				domain = octeon_irq_get_block_domain(node,
+								      WD_BLOCK_NUMBER);
+				hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | coreid;
+				irq = irq_find_mapping(domain, hwirq);
+			} else
+				irq = OCTEON_IRQ_WDOG0 + coreid;
 			enable_irq(irq);
 			cpumask_set_cpu(cpu, &irq_enabled_cpus);
 		}
@@ -521,6 +559,7 @@ static int octeon_wdt_set_heartbeat(int t)
 	int cpu;
 	int coreid;
 	union cvmx_ciu_wdogx ciu_wdog;
+	int node;
 
 	if (t <= 0)
 		return -1;
@@ -532,12 +571,13 @@ static int octeon_wdt_set_heartbeat(int t)
 
 	for_each_online_cpu(cpu) {
 		coreid = cpu2core(cpu);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		node = cpu_to_node(cpu);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 		ciu_wdog.u64 = 0;
 		ciu_wdog.s.len = timeout_cnt;
 		ciu_wdog.s.mode = 3;	/* 3 = Interrupt + NMI + Soft-Reset */
-		cvmx_write_csr(CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		cvmx_write_csr_node(node, CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 	}
 	octeon_wdt_ping(); /* Get the irqs back on. */
 	return 0;
@@ -763,6 +803,10 @@ out:
 static void __exit octeon_wdt_cleanup(void)
 {
 	int cpu;
+	int node;
+	unsigned int irq;
+	struct irq_domain *domain;
+	int hwirq;
 
 	misc_deregister(&octeon_wdt_miscdev);
 
@@ -773,10 +817,19 @@ static void __exit octeon_wdt_cleanup(void)
 
 	for_each_online_cpu(cpu) {
 		int core = cpu2core(cpu);
+		node = cpu_to_node(cpu);
 		/* Disable the watchdog */
-		cvmx_write_csr(CVMX_CIU_WDOGX(core), 0);
+		cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), 0);
+
 		/* Free the interrupt handler */
-		free_irq(OCTEON_IRQ_WDOG0 + core, octeon_wdt_poke_irq);
+		if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+			domain = octeon_irq_get_block_domain(node,
+							     WD_BLOCK_NUMBER);
+			hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | core;
+			irq = irq_find_mapping(domain, hwirq);
+		} else
+			irq = OCTEON_IRQ_WDOG0 + core;
+		free_irq(irq, octeon_wdt_poke_irq);
 	}
 	/*
 	 * Disable the boot-bus memory, the code it points to is soon
-- 
1.8.2.1

