From cb24c567476e21b0d90bf039f02e2634dd1e1557 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Mon, 17 Jun 2013 18:57:43 -0700
Subject: [PATCH 052/122] MIPS: Octeon: Merge and cleanup for
 cavemum-octeon/setup.c

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: b01c30c392f453f6a9d14fa65b2a1e64b66302e6
Description:

Compare current setup.c with 3.X branch and apply
Remove obsolete crashkernel= argument handling
Cleanup RESERVE32 memory allocation
Re-apply user-level direct physical memory and I/O access configuration

Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig |  3 --
 arch/mips/cavium-octeon/setup.c | 72 +++++++++++++++++------------------------
 2 files changed, 30 insertions(+), 45 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index f36f9b3..2177a02 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -234,7 +234,4 @@ config OCTEON_ERROR_INJECTOR
 	  Used to test hardware error reporting.  Should never be used
 	  in a normal running system.
 
-# To be enabled later
-# source "arch/mips/cavium-octeon/executive/Kconfig"
-
 endif # CPU_CAVIUM_OCTEON
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 97dbdde..ed07ec4 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -151,16 +151,12 @@ static void octeon_crash_shutdown(struct pt_regs *regs)
 
 #endif /* CONFIG_KEXEC */
 
-#ifdef CONFIG_CAVIUM_RESERVE32
-uint64_t octeon_reserve32_memory;
-EXPORT_SYMBOL(octeon_reserve32_memory);
+#ifndef CONFIG_CAVIUM_RESERVE32
+#define	 CONFIG_CAVIUM_RESERVE32	0ULL
 #endif
 
-#ifdef CONFIG_KEXEC
-/* crashkernel cmdline parameter is parsed _after_ memory setup
- * we also parse it here (workaround for EHB5200) */
-static uint64_t crashk_size, crashk_base;
-#endif
+uint64_t octeon_reserve32_memory;
+EXPORT_SYMBOL(octeon_reserve32_memory);
 
 static int octeon_uart;
 
@@ -336,9 +332,12 @@ static void octeon_restart(char *command)
  */
 static void octeon_kill_core(void *arg)
 {
-	if (octeon_is_simulation())
+	if (octeon_is_simulation()) {
+		/* The simulator needs the watchdog to stop for dead cores */
+		cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
 		/* A break instruction causes the simulator stop a core */
 		asm volatile ("break" ::: "memory");
+	}
 
 	local_irq_disable();
 	/* Disable watchdog on this core. */
@@ -432,7 +431,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==0 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	cvmmemctl.s.xkmemenau = 1;
+#else
 	cvmmemctl.s.xkmemenau = 0;
+#endif
 
 	/* R/W If set (and SX set), supervisor-level loads/stores can
 	 * use XKPHYS addresses with VA<48>==1 */
@@ -440,7 +443,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==1 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO
+	cvmmemctl.s.xkioenau = 1;
+#else
 	cvmmemctl.s.xkioenau = 0;
+#endif
 
 	/* R/W If set, all stores act as SYNCW (NOMERGE must be set
 	 * when this is set) RW, reset to 0. */
@@ -529,9 +536,6 @@ void __init prom_init(void)
 	int i;
 	u64 t;
 	int argc;
-#ifdef CONFIG_CAVIUM_RESERVE32
-	int64_t addr = -1;
-#endif
 	/*
 	 * The bootloader passes a pointer to the boot descriptor in
 	 * $a3, this is available as fw_arg3.
@@ -633,7 +637,6 @@ void __init prom_init(void)
 		cvmx_write_csr(CVMX_LED_UDD_DATX(1), 0);
 		cvmx_write_csr(CVMX_LED_EN, 1);
 	}
-#ifdef CONFIG_CAVIUM_RESERVE32
 	/*
 	 * We need to temporarily allocate all memory in the reserve32
 	 * region. This makes sure the kernel doesn't allocate this
@@ -641,17 +644,21 @@ void __init prom_init(void)
 	 * bootloader. Later, after the memory allocations are
 	 * complete, the reserve32 will be freed.
 	 *
-	 * Allocate memory for RESERVED32 aligned on 2MB boundary. This
+	 * Allocate memory for RESERVE32 aligned on 2MB boundary. This
 	 * is in case we later use hugetlb entries with it.
 	 */
-	addr = cvmx_bootmem_phy_named_block_alloc(CONFIG_CAVIUM_RESERVE32 << 20,
-						0, 0, 2 << 20,
-						"CAVIUM_RESERVE32", 0);
-	if (addr < 0)
-		pr_err("Failed to allocate CAVIUM_RESERVE32 memory area\n");
-	else
-		octeon_reserve32_memory = addr;
-#endif
+	if ( CONFIG_CAVIUM_RESERVE32 > 0 ) {
+		int64_t addr = -1;
+		addr = cvmx_bootmem_phy_named_block_alloc(
+				CONFIG_CAVIUM_RESERVE32 << 20,
+				0, 0, 2 << 20,
+				"CAVIUM_RESERVE32", 0);
+		if (addr < 0)
+			pr_err("Failed to allocate "
+				"CAVIUM_RESERVE32 memory area\n");
+		else
+			octeon_reserve32_memory = addr;
+	}
 
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2
 	if (cvmx_read_csr(CVMX_L2D_FUS3) & (3ull << 34)) {
@@ -765,19 +772,6 @@ void __init prom_init(void)
 			pr_notice("Reporting of single bit ECC errors is "
 				  "turned on\n");
 #endif
-#ifdef CONFIG_KEXEC
-		} else if (strncmp(arg, "crashkernel=", 12) == 0) {
-			crashk_size = memparse(arg+12, &p);
-			if (*p == '@')
-				crashk_base = memparse(p+1, &p);
-			strcat(arcs_cmdline, " ");
-			strcat(arcs_cmdline, arg);
-			/*
-			 * To do: switch parsing to new style, something like:
-			 * parse_crashkernel(arg, sysinfo->system_dram_size,
-			 *		  &crashk_size, &crashk_base);
-			 */
-#endif
 		} else if (strlen(arcs_cmdline) + strlen(arg) + 1 <
 			   sizeof(arcs_cmdline) - 1) {
 			strcat(arcs_cmdline, " ");
@@ -849,14 +843,10 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 void __init plat_mem_setup(void)
 {
 	uint64_t mem_alloc_size;
-	uint64_t total;
-	uint64_t crashk_end;
+	uint64_t total = 0;
 	int64_t memory;
 	const struct cvmx_bootmem_named_block_desc *named_block;
 
-	total = 0;
-	crashk_end = 0;
-
 	if (named_memory_blocks[0][0]) {
 		/* Memory from named blocks only */
 		int i;
@@ -940,7 +930,6 @@ void __init plat_mem_setup(void)
 
 mem_alloc_done:
 
-#ifdef CONFIG_CAVIUM_RESERVE32
 	/*
 	 * Now that we've allocated the kernel memory it is safe to
 	 * free the reserved region. We free it here so that builtin
@@ -948,7 +937,6 @@ mem_alloc_done:
 	 */
 	if (octeon_reserve32_memory)
 		cvmx_bootmem_free_named("CAVIUM_RESERVE32");
-#endif /* CONFIG_CAVIUM_RESERVE32 */
 
 	if (total == 0)
 		panic("Unable to allocate memory from "
-- 
1.8.2.1

