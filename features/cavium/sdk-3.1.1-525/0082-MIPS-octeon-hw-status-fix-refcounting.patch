From 306c1cab9a76b3ca9478334efd4d363cae27b980 Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Fri, 1 Nov 2013 19:42:56 -0700
Subject: [PATCH 082/122] MIPS: octeon-hw-status: fix refcounting

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: b28893dcd0ab70ed7e0110a17265a48f48b44261
Description:

Increment parent.users on creation, not child.users!
Mark parent with .has_child when child created, avoiding "Mismatch" warning.
Added param octeon_hw_status.count_debug for noisy add/remove.
Unified printk()/WARN() style to use common prefix.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-hw-status.c | 99 ++++++++++++++++++++++++++----
 1 file changed, 88 insertions(+), 11 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index 1b9e5dc..c704e64 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -11,10 +11,13 @@
 #include <linux/notifier.h>
 #include <linux/export.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 
 #include <asm/octeon/octeon-hw-status.h>
 #include <asm/octeon/octeon.h>
 
+#define DRV_NAME "octeon-hw-status"
+
 static RAW_NOTIFIER_HEAD(octeon_hw_status_notifiers);
 
 int octeon_hw_status_notifier_register(struct notifier_block *nb)
@@ -29,6 +32,10 @@ int octeon_hw_status_notifier_unregister(struct notifier_block *nb)
 }
 EXPORT_SYMBOL(octeon_hw_status_notifier_unregister);
 
+enum { ref_max_users = 0xff, };
+static bool count_debug;
+module_param(count_debug, bool, 0644);
+
 struct octeon_hw_status_node {
 	struct octeon_hw_status_node *next; /* Child list */
 	struct octeon_hw_status_node *child;
@@ -207,9 +214,14 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 {
 	struct octeon_hw_status_data ohsd;
 	struct octeon_hw_status_node *root;
-	struct octeon_hw_status_node *n;
 	struct octeon_hw_status_node *w;
+	struct octeon_hw_status_node *new_root;
+	struct octeon_hw_status_node *new_child;
+	struct find_node_cb_data match = { .warn = false, };
+	bool oflow = false;
 	bool root_created = false;
+	bool created = false;
+	int siblings = 0;
 	int rv = 0;
 
 	if (!chain->reg_is_hwint)
@@ -237,6 +249,7 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 	}
 	w = root;
 	while (chain->has_child) {
+		struct octeon_hw_status_node *n;
 		chain++;
 		n = find_child(w, chain);
 		if (!n) {
@@ -246,8 +259,12 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 				rv = -ENOMEM;
 				goto out;
 			}
+			n = new_child;
+			new_child = NULL;
+			match.r = n;
 			n->is_hwint = chain->reg_is_hwint;
 			n->ack_w1c = chain->ack_w1c;
+			n->users = 1;
 			if (n->is_hwint) {
 				n->hwint = chain->reg;
 			} else {
@@ -255,17 +272,39 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 				n->mask_reg = chain->mask_reg;
 				n->bit = chain->bit;
 			}
+
+			/* attach to parent */
+			n->parent = w;
 			n->next = w->child;
 			w->child = n;
-			n->parent = w;
+			chain->has_child = 1;
+
+			/* parent ref-count */
+			oflow = (w->users == ref_max_users);
+			if (!oflow)
+				w->users++;
+			siblings = w->users;
+			created = true;
+			break;
 		}
 		w = n;
 	}
-	w->users++;
-	WARN(w->users == 0, "Reference count overflowed!");
 
 	write_unlock(&octeon_hw_status_lock);
 
+	if (count_debug) {
+		if (root_created)
+			printk(DRV_NAME " %llx/%llx:%d created root\n",
+				chain->reg, chain->mask_reg, chain->bit);
+		printk(DRV_NAME " %llx/%llx:%d refcount %s%d\n",
+			match.r->reg, match.r->mask_reg, match.r->bit,
+			created ? "++" : "", siblings);
+	}
+	WARN(oflow, DRV_NAME " Reference count overflowed!\n");
+	WARN(match.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
+		 match.r->child, match.sr->has_child,
+		 match.r->ack_w1c, match.sr->ack_w1c);
+
 	if (root_created) {
 		/* register an interrupt handler */
 		root->irq = irq_create_mapping(NULL, root->hwint);
@@ -273,16 +312,25 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 			return -ENXIO;
 
 		rv = request_threaded_irq(root->irq, NULL, octeon_hw_status_irq,
-					  IRQF_ONESHOT, "octeon-hw-status", root);
-		WARN(rv, "request_threaded_irq failed: %d", rv);
+					  IRQF_ONESHOT, DRV_NAME, root);
+		WARN(rv, DRV_NAME " request_threaded_irq failed: %d\n", rv);
 	}
 
 	ohsd.reg = w->reg;
 	ohsd.bit = w->bit;
 	raw_notifier_call_chain(&octeon_hw_status_notifiers,
 				OCTEON_HW_STATUS_SOURCE_ADDED, &ohsd);
-	return 0;
-out:
+	rv = 0;
+bye:
+	if (new_root)
+		kfree(new_root);
+	if (new_child)
+		kfree(new_child);
+	if (rv && count_debug)
+		printk(DRV_NAME " %llx/%llx:%d err %d\n",
+			chain->reg, chain->mask_reg, chain->bit, rv);
+	return rv;
+unlock:
 	write_unlock(&octeon_hw_status_lock);
 	return rv;
 }
@@ -339,6 +387,9 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 	int rv = 0;
 	bool already_unlocked = false;
 	struct octeon_hw_status_node *n;
+	struct find_node_cb_data d = { .warn  = false, };
+	bool oflow = false;
+	bool gone = false;
 
 	write_lock(&octeon_hw_status_lock);
 
@@ -348,12 +399,30 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 		goto out;
 	}
 
-	n->users--;
-	if (n->users == 0)
-		already_unlocked = dispose_of_node(n);
+	/* Can't Happen: count overflowed, so decrement unsafe */
+	oflow = (n->users == ref_max_users);
+	if (!oflow) {
+		n->users--;
+		if (n->users == 0) {
+			gone = true;
+			/* should clear parent->has_child if was last, free parent */
+			already_unlocked = dispose_of_node(n);
+		}
+	}
 out:
 	if (!already_unlocked)
 		write_unlock(&octeon_hw_status_lock);
+
+	WARN(d.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
+	     d.r->child, d.sr->has_child, d.r->ack_w1c, d.sr->ack_w1c);
+
+	if (count_debug && gone)
+		printk(DRV_NAME " %llx:%d gone\n",
+			d.r->reg, d.r->bit);
+	else if (count_debug)
+		printk(DRV_NAME " %llx:%d refcount --%d@%p\n",
+			d.r->reg, d.r->bit, n->users, n);
+
 	return rv;
 }
 EXPORT_SYMBOL(octeon_hw_status_remove_source);
@@ -398,6 +467,10 @@ int octeon_hw_status_enable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
+
+	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
+		cbd.reg, cbd.warn_mask);
+
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_enable);
@@ -421,6 +494,10 @@ int octeon_hw_status_disable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
+
+	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
+		cbd.reg, cbd.warn_mask);
+
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_disable);
-- 
1.8.2.1

