From 3305b934ca239f79982a125b0a58e7d63c3bf4e3 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Wed, 22 Oct 2014 18:00:23 +0800
Subject: [PATCH 116/122] octeon: Add cpu model for cn78xx

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: ed57d99d34f87b08ba3e3e42929e20bea14614af
Description:

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/executive/octeon-model.c | 121 +++++++++++++++++------
 arch/mips/include/asm/cpu-type.h                 |   1 +
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h     |  24 ++++-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h     |  54 ++++++++++
 arch/mips/include/asm/octeon/octeon-model.h      |  55 ++++++++---
 5 files changed, 212 insertions(+), 43 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index f4c1b36..fc7875d 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -63,7 +63,8 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 	union cvmx_mio_fus_dat2 fus_dat2;
 	union cvmx_mio_fus_dat3 fus_dat3;
 	char fuse_model[10];
-	uint32_t fuse_data = 0;
+	char fuse_suffix[4] = {0};
+	uint64_t fuse_data = 0;
 
 	fus3.u64 = 0;
 	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX))
@@ -113,6 +114,9 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 	 * later.
 	 */
 	switch (num_cores) {
+	case 48:
+		core_model = "90";
+		break;
 	case 32:
 		core_model = "80";
 		break;
@@ -361,6 +365,17 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 		else
 			suffix = "AAP";
 		break;
+	case 0x95:              /* CN78XX */
+		family = "78";
+		if (fus_dat3.cn78xx.l2c_crip == 2)
+			family = "77";
+		if (fus_dat3.cn78xx.nozip
+		      && fus_dat3.cn78xx.nodfa_dte
+		      && fus_dat3.cn78xx.nohna_dte)
+			suffix = "SCP";
+		else
+			suffix = "AAP";
+		break;
 	default:
 		family = "XX";
 		core_model = "XX";
@@ -371,36 +386,82 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 
 	clock_mhz = octeon_get_clock_rate() / 1000000;
 	if (family[0] != '3') {
-		int fuse_base = 384 / 8;
-		if (family[0] == '6')
-			fuse_base = 832 / 8;
+		if (OCTEON_IS_OCTEON1PLUS() || OCTEON_IS_OCTEON2()) {
+			int fuse_base = 384 / 8;
+			if (family[0] == '6')
+				fuse_base = 832 / 8;
+			/* Check for model in fuses, overrides normal decode */
+			/* This is _not_ valid for Octeon CN3XXX models */
+			fuse_data |= cvmx_fuse_read_byte(fuse_base + 5);
+			fuse_data = fuse_data << 8;
+			fuse_data |= cvmx_fuse_read_byte(fuse_base + 4);
+			fuse_data = fuse_data << 8;
+			fuse_data |= cvmx_fuse_read_byte(fuse_base + 3);
+			fuse_data = fuse_data << 8;
+			fuse_data |= cvmx_fuse_read_byte(fuse_base + 2);
+			fuse_data = fuse_data << 8;
+			fuse_data |= cvmx_fuse_read_byte(fuse_base + 1);
+			fuse_data = fuse_data << 8;
+			fuse_data |= cvmx_fuse_read_byte(fuse_base);
+			if (fuse_data & 0x7ffff) {
+				int model = fuse_data & 0x3fff;
+				int suffix = (fuse_data >> 14) & 0x1f;
+				if (suffix && model) {      /* Have both number and suffix in fuses, so both */
+					sprintf(fuse_model, "%d%c", model, 'A' + suffix - 1);
+					core_model = "";
+					family = fuse_model;
+				} else if (suffix && !model) {      /* Only have suffix, so add suffix to 'normal' model number */
+					sprintf(fuse_model, "%s%c", core_model, 'A' + suffix - 1);
+					core_model = fuse_model;
+				} else {    /* Don't have suffix, so just use model from fuses */
+
+					sprintf(fuse_model, "%d", model);
+					core_model = "";
+					family = fuse_model;
+				}
+			}
+		} else {
+			/* Format for Octeon 3. */
+			fuse_data = cvmx_read_csr(CVMX_MIO_FUS_PDF);
+			if (fuse_data & ((1ULL << 48) - 1)) {
+				char suffix_str[4] = {0};
+				int i;
+				int model = fuse_data & ((1ULL << 17) - 1);
+				int suf_bits = (fuse_data >> 17) & ((1ULL << 15) - 1);
+				for (i = 0; i < 3; i++) {
+					/* A-Z are encoded 1-26, 27-31 are
+					   reserved values. */
+					if ((suf_bits & 0x1f) && (suf_bits & 0x1f) <= 26)
+						suffix_str[i] = 'A' + (suf_bits & 0x1f) - 1;
+					suf_bits = suf_bits >> 5;
+				}
+				if (strlen(suffix_str) && model) {      /* Have both number and suffix in fuses, so both */
+					sprintf(fuse_model, "%d%s", model, suffix_str);
+					core_model = "";
+					family = fuse_model;
+				} else if (strlen(suffix_str) && !model) {      /* Only have suffix, so add suffix to 'normal' model number */
+					sprintf(fuse_model, "%s%s", core_model, suffix_str);
+					core_model = fuse_model;
+				} else if (model) {    /* Don't have suffix, so just use model from fuses */
+					sprintf(fuse_model, "%d", model);
+					core_model = "";
+					family = fuse_model;
+				}
+				/* in case of invalid model suffix bits
+				   only set, we do nothing. */
 
-		/* Check for model in fuses, overrides normal decode */
-		/* This is _not_ valid for Octeon CN3XXX models */
-		fuse_data |= cvmx_fuse_read_byte(fuse_base + 3);
-		fuse_data = fuse_data << 8;
-		fuse_data |= cvmx_fuse_read_byte(fuse_base + 2);
-		fuse_data = fuse_data << 8;
-		fuse_data |= cvmx_fuse_read_byte(fuse_base + 1);
-		fuse_data = fuse_data << 8;
-		fuse_data |= cvmx_fuse_read_byte(fuse_base);
-		if (fuse_data & 0x7ffff) {
-			int model = fuse_data & 0x3fff;
-			int suffix = (fuse_data >> 14) & 0x1f;
-			if (suffix && model) {
-				/* Have both number and suffix in fuses, so both */
-				sprintf(fuse_model, "%d%c", model, 'A' + suffix - 1);
-				core_model = "";
-				family = fuse_model;
-			} else if (suffix && !model) {
-				/* Only have suffix, so add suffix to 'normal' model number */
-				sprintf(fuse_model, "%s%c", core_model, 'A' + suffix - 1);
-				core_model = fuse_model;
-			} else {
-				/* Don't have suffix, so just use model from fuses */
-				sprintf(fuse_model, "%d", model);
-				core_model = "";
-				family = fuse_model;
+				/* Check to see if we have a custom type
+				   suffix. */
+				suf_bits = (fuse_data >> 33) & ((1ULL << 15) - 1);
+				for (i = 0; i < 3; i++) {
+					/* A-Z are encoded 1-26, 27-31 are
+					   reserved values. */
+					if ((suf_bits & 0x1f) && (suf_bits & 0x1f) <= 26)
+						fuse_suffix[i] = 'A' + (suf_bits & 0x1f) - 1;
+					suf_bits = suf_bits >> 5;
+				}
+				if (strlen(fuse_suffix))
+					suffix = fuse_suffix;
 			}
 		}
 	}
diff --git a/arch/mips/include/asm/cpu-type.h b/arch/mips/include/asm/cpu-type.h
index 02f591b..19557ca 100644
--- a/arch/mips/include/asm/cpu-type.h
+++ b/arch/mips/include/asm/cpu-type.h
@@ -160,6 +160,7 @@ static inline int __pure __get_cpu_type(const int cpu_type)
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
+	case CPU_CAVIUM_OCTEON3:
 #endif
 
 #if defined(CONFIG_SYS_HAS_CPU_BMIPS32_3300) || \
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 0dd0e40..16838d4 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -43,7 +43,29 @@
 #define CVMX_CIU_EN2_PPX_IP4(offset) (CVMX_ADD_IO_SEG(0x000107000000A400ull) + ((offset) & 15) * 8)
 #define CVMX_CIU_EN2_PPX_IP4_W1C(offset) (CVMX_ADD_IO_SEG(0x000107000000CC00ull) + ((offset) & 15) * 8)
 #define CVMX_CIU_EN2_PPX_IP4_W1S(offset) (CVMX_ADD_IO_SEG(0x000107000000AC00ull) + ((offset) & 15) * 8)
-#define CVMX_CIU_FUSE (CVMX_ADD_IO_SEG(0x0001070000000728ull))
+#define CVMX_CIU_FUSE CVMX_CIU_FUSE_FUNC()
+static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x0001070000000728ull);
+}
 #define CVMX_CIU_GSTOP (CVMX_ADD_IO_SEG(0x0001070000000710ull))
 #define CVMX_CIU_INT33_SUM0 (CVMX_ADD_IO_SEG(0x0001070000000110ull))
 #define CVMX_CIU_INTX_EN0(offset) (CVMX_ADD_IO_SEG(0x0001070000000200ull) + ((offset) & 63) * 16)
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index bb0ae33..ea1086c 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -2023,6 +2023,60 @@ union cvmx_mio_fus_dat3 {
 	struct cvmx_mio_fus_dat3_cn61xx cn68xx;
 	struct cvmx_mio_fus_dat3_cn61xx cn68xxp1;
 	struct cvmx_mio_fus_dat3_cn61xx cnf71xx;
+	struct cvmx_mio_fus_dat3_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
+	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
+	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
+	uint64_t reserved_38_40               : 3;
+	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
+	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
+                                                         0x0 = Full cache (16-way, 16 MB).
+                                                         0x1 = 3/4 ways (12-way, 12 MB).
+                                                         0x2 = 1/2 ways (8-way, 8 MB).
+                                                         0x3 = 1/4 ways (4-way, 4MB).
+                                                         0x4-0x7 = Reserved. */
+	uint64_t reserved_31_31               : 1;
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
+	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x11. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
+	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
+	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t hna_info_clm                 : 4;
+	uint64_t hna_info_dte                 : 3;
+	uint64_t nohna_dte                    : 1;
+	uint64_t ema1                         : 6;
+	uint64_t nodfa_dte                    : 1;
+	uint64_t nozip                        : 1;
+	uint64_t efus_ign                     : 1;
+	uint64_t efus_lck                     : 1;
+	uint64_t bar2_sz_conf                 : 1;
+	uint64_t zip_info                     : 2;
+	uint64_t reserved_31_31               : 1;
+	uint64_t l2c_crip                     : 3;
+	uint64_t pll_half_dis                 : 1;
+	uint64_t efus_lck_man                 : 1;
+	uint64_t efus_lck_rsv                 : 1;
+	uint64_t reserved_38_40               : 3;
+	uint64_t dfa_info_clm                 : 4;
+	uint64_t dfa_info_dte                 : 3;
+	uint64_t pll_ctl                      : 10;
+	uint64_t ema0                         : 6;
+#endif
+	} cn78xx;
 };
 
 union cvmx_mio_fus_ema {
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 478e077..370e480 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -45,6 +45,7 @@
  */
 
 #define OCTEON_FAMILY_MASK	0x00ffff00
+#define OCTEON_PRID_MASK        0x00ffffff
 
 /* Flag bits in top byte */
 /* Ignores revision in model checks */
@@ -63,11 +64,35 @@
 #define OM_MATCH_6XXX_FAMILY_MODELS	0x40000000
 /* Match all cnf7XXX Octeon models. */
 #define OM_MATCH_F7XXX_FAMILY_MODELS	0x80000000
+/* Match all cn7XXX Octeon models. */
+#define OM_MATCH_7XXX_FAMILY_MODELS     0x10000000
+
+/*
+ * CNF7XXX models with new revision encoding
+ */
+#define OCTEON_CN70XX_PASS1_0	0x000d9600
+#define OCTEON_CN70XX_PASS1_1	0x000d9601
+
+#define OCTEON_CN70XX_PASS2_0	0x000d9608
+
+#define OCTEON_CN70XX		(OCTEON_CN70XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CN70XX_PASS1_X	(OCTEON_CN70XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
+#define OCTEON_CN70XX_PASS2_X	(OCTEON_CN70XX_PASS2_0 | OM_IGNORE_MINOR_REVISION)
+
+#define OCTEON_CN71XX		OCTEON_CN70XX
+
+#define OCTEON_CN78XX_PASS1_0	0x000d9500
+#define OCTEON_CN78XX_PASS2_0	0x000d9508
+
+#define OCTEON_CN78XX		(OCTEON_CN78XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CN78XX_PASS1_X	(OCTEON_CN78XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
+#define OCTEON_CN78XX_PASS2_X	(OCTEON_CN78XX_PASS2_0 | OM_IGNORE_MINOR_REVISION)
 
 /*
  * CNF7XXX models with new revision encoding
  */
 #define OCTEON_CNF71XX_PASS1_0	0x000d9400
+#define OCTEON_CNF71XX_PASS1_1	0x000d9401
 
 #define OCTEON_CNF71XX		(OCTEON_CNF71XX_PASS1_0 | OM_IGNORE_REVISION)
 #define OCTEON_CNF71XX_PASS1_X	(OCTEON_CNF71XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
@@ -217,6 +242,7 @@
 #define OCTEON_CN3XXX		(OCTEON_CN58XX_PASS1_0 | OM_MATCH_PREVIOUS_MODELS | OM_IGNORE_REVISION)
 #define OCTEON_CN5XXX		(OCTEON_CN58XX_PASS1_0 | OM_MATCH_5XXX_FAMILY_MODELS)
 #define OCTEON_CN6XXX		(OCTEON_CN63XX_PASS1_0 | OM_MATCH_6XXX_FAMILY_MODELS)
+#define OCTEON_CN7XXX		(OCTEON_CN78XX_PASS1_0 | OM_MATCH_7XXX_FAMILY_MODELS)
 
 /* These are used to cover entire families of OCTEON processors */
 #define OCTEON_FAM_1		(OCTEON_CN3XXX)
@@ -290,26 +316,31 @@ static inline uint64_t cvmx_read_csr(uint64_t csr_addr);
 		((((arg_model) & (OM_MATCH_5XXX_FAMILY_MODELS)) == OM_MATCH_5XXX_FAMILY_MODELS) \
 			&& ((chip_model) >= OCTEON_CN58XX_PASS1_0) && ((chip_model) < OCTEON_CN63XX_PASS1_0)) || \
 		((((arg_model) & (OM_MATCH_6XXX_FAMILY_MODELS)) == OM_MATCH_6XXX_FAMILY_MODELS) \
-			&& ((chip_model) >= OCTEON_CN63XX_PASS1_0)) ||	\
+			& ((chip_model & OCTEON_PRID_MASK) >= OCTEON_CN63XX_PASS1_0) && ((chip_model & OCTEON_PRID_MASK) < OCTEON_CNF71XX_PASS1_0)) || \
+		((((arg_model) & (OM_MATCH_F7XXX_FAMILY_MODELS)) == OM_MATCH_F7XXX_FAMILY_MODELS) \
+			&& ((chip_model & OCTEON_PRID_MASK) >= OCTEON_CNF71XX_PASS1_0) && ((chip_model & OCTEON_PRID_MASK) < OCTEON_CN78XX_PASS1_0)) || \
+		((((arg_model) & (OM_MATCH_7XXX_FAMILY_MODELS)) == OM_MATCH_7XXX_FAMILY_MODELS) \
+			&& ((chip_model & OCTEON_PRID_MASK) >= OCTEON_CN78XX_PASS1_0)) || \
 		((((arg_model) & (OM_MATCH_PREVIOUS_MODELS)) == OM_MATCH_PREVIOUS_MODELS) \
 			&& (((chip_model) & OCTEON_58XX_MODEL_MASK) < ((arg_model) & OCTEON_58XX_MODEL_MASK))) \
 		)))
 
 /* NOTE: This for internal use only!!!!! */
-static inline int __octeon_is_model_runtime__(uint32_t model)
+static inline int __octeon_is_model_runtime_internal__(uint32_t model)
 {
 	uint32_t cpuid = cvmx_get_proc_id();
 
-	/*
-	 * Check for special case of mismarked 3005 samples. We only
-	 * need to check if the sub model isn't being ignored
-	 */
-	if ((model & OM_CHECK_SUBMODEL) == OM_CHECK_SUBMODEL) {
-		if (cpuid == OCTEON_CN3010_PASS1 && (cvmx_read_csr(0x80011800800007B8ull) & (1ull << 34)))
-			cpuid |= 0x10;
-	}
-	return __OCTEON_IS_MODEL_COMPILE__(model, cpuid);
+	return (__OCTEON_IS_MODEL_COMPILE__(model, cpuid));
+}
+
+#if defined(CVMX_BUILD_FOR_LINUX_KERNEL) || !defined(__OPTIMIZE_SIZE__)
+/* NOTE: This for internal use only!!!!! */ static inline int __octeon_is_model_runtime__(uint32_t model)
+{
+	return __octeon_is_model_runtime_internal__(model);
 }
+#else
+int __octeon_is_model_runtime__(uint32_t model);
+#endif
 
 /*
  * The OCTEON_IS_MODEL macro should be used for all Octeon model checking done
@@ -330,7 +361,7 @@ static inline int __octeon_is_model_runtime__(uint32_t model)
 #define OCTEON_IS_OCTEONPLUS()	OCTEON_IS_MODEL(OCTEON_CN5XXX)
 #define OCTEON_IS_OCTEON2()	\
 	(OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF71XX))
-
+#define OCTEON_IS_OCTEON3()	OCTEON_IS_MODEL(OCTEON_CN7XXX)
 #define OCTEON_IS_OCTEON1PLUS()	(OCTEON_IS_OCTEON1() || OCTEON_IS_OCTEONPLUS())
 
 const char *octeon_model_get_string(uint32_t chip_id);
-- 
1.8.2.1

