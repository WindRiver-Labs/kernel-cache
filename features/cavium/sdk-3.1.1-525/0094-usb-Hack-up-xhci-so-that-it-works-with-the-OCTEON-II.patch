From b7601aa9f3fd1f76c42af17a395194af9e120cd5 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 7 Oct 2013 13:32:32 -0700
Subject: [PATCH 094/122] usb: Hack up xhci, so that it works with the OCTEON
 III xHCI controller.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 4b8dd9ac169aa3c25dd9dc52ec6526f7d88aa314
Description:

Work in progress, we will keep cleaning this up.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from Cavium SDK 3.1.1 525]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/usb/dwc3/core.c        |  61 +++++--------
 drivers/usb/host/Kconfig       |   6 ++
 drivers/usb/host/Makefile      |   1 +
 drivers/usb/host/xhci-octeon.c | 196 +++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/xhci.c        |   2 +-
 5 files changed, 228 insertions(+), 38 deletions(-)
 create mode 100644 drivers/usb/host/xhci-octeon.c

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index f074755..ea52f0c 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -44,6 +44,8 @@
 #include "io.h"
 
 #include "debug.h"
+extern void octeon3_usb_phy_reset(int index);
+static u64 xhci_octeon_dma_mask = DMA_BIT_MASK(64);
 
 /* -------------------------------------------------------------------------- */
 
@@ -64,6 +66,7 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
 static void dwc3_core_soft_reset(struct dwc3 *dwc)
 {
 	u32		reg;
+	int 		index;
 
 	/* Before Resetting PHY, put Core in Reset */
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
@@ -80,8 +83,10 @@ static void dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg |= DWC3_GUSB2PHYCFG_PHYSOFTRST;
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 
-	usb_phy_init(dwc->usb2_phy);
-	usb_phy_init(dwc->usb3_phy);
+	index = (((uint64_t)(dwc->regs) & 0x10000000000ull) ? 1:0);
+	octeon3_usb_phy_reset(index);
+	//usb_phy_init(dwc->usb2_phy);
+	//usb_phy_init(dwc->usb3_phy);
 	mdelay(100);
 
 	/* Clear USB3 PHY reset */
@@ -341,8 +346,8 @@ err0:
 
 static void dwc3_core_exit(struct dwc3 *dwc)
 {
-	usb_phy_shutdown(dwc->usb2_phy);
-	usb_phy_shutdown(dwc->usb3_phy);
+	//usb_phy_shutdown(dwc->usb2_phy);
+	//usb_phy_shutdown(dwc->usb3_phy);
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -387,8 +392,20 @@ static int dwc3_probe(struct platform_device *pdev)
 	if (node) {
 		dwc->maximum_speed = of_usb_get_maximum_speed(node);
 
-		dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 0);
-		dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
+                dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 0);
+                dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
+                if (of_property_read_bool(node, "usb-phy")) {
+                        dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev,"usb-phy", 0);
+                        if (IS_ERR(dwc->usb2_phy))
+                                return PTR_ERR(dwc->usb2_phy);
+                        dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
+                        if (IS_ERR(dwc->usb3_phy))
+                                return PTR_ERR(dwc->usb3_phy);
+                }
+                else {
+                        dwc->usb2_phy = NULL;
+                        dwc->usb3_phy = NULL;
+                }
 
 		dwc->needs_fifo_resize = of_property_read_bool(node, "tx-fifo-resize");
 		dwc->dr_mode = of_usb_get_dr_mode(node);
@@ -409,36 +426,6 @@ static int dwc3_probe(struct platform_device *pdev)
 	if (dwc->maximum_speed == USB_SPEED_UNKNOWN)
 		dwc->maximum_speed = USB_SPEED_SUPER;
 
-	if (IS_ERR(dwc->usb2_phy)) {
-		ret = PTR_ERR(dwc->usb2_phy);
-
-		/*
-		 * if -ENXIO is returned, it means PHY layer wasn't
-		 * enabled, so it makes no sense to return -EPROBE_DEFER
-		 * in that case, since no PHY driver will ever probe.
-		 */
-		if (ret == -ENXIO)
-			return ret;
-
-		dev_err(dev, "no usb2 phy configured\n");
-		return -EPROBE_DEFER;
-	}
-
-	if (IS_ERR(dwc->usb3_phy)) {
-		ret = PTR_ERR(dwc->usb3_phy);
-
-		/*
-		 * if -ENXIO is returned, it means PHY layer wasn't
-		 * enabled, so it makes no sense to return -EPROBE_DEFER
-		 * in that case, since no PHY driver will ever probe.
-		 */
-		if (ret == -ENXIO)
-			return ret;
-
-		dev_err(dev, "no usb3 phy configured\n");
-		return -EPROBE_DEFER;
-	}
-
 	dwc->xhci_resources[0].start = res->start;
 	dwc->xhci_resources[0].end = dwc->xhci_resources[0].start +
 					DWC3_XHCI_REGS_END;
@@ -462,7 +449,7 @@ static int dwc3_probe(struct platform_device *pdev)
 	dwc->regs_size	= resource_size(res);
 	dwc->dev	= dev;
 
-	dev->dma_mask	= dev->parent->dma_mask;
+	dev->dma_mask	= &xhci_octeon_dma_mask;
 	dev->dma_parms	= dev->parent->dma_parms;
 	dma_set_coherent_mask(dev, dev->parent->coherent_dma_mask);
 
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index a9707da..ec67359 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -24,6 +24,12 @@ config USB_XHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called xhci-hcd.
 
+
+config USB_XHCI_HCD_OCTEON
+	tristate
+	depends on USB_XHCI_HCD && CAVIUM_OCTEON_SOC
+	default y
+
 if USB_XHCI_HCD
 
 config USB_XHCI_PLATFORM
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 7530468..691f5ec 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
+obj-$(CONFIG_USB_XHCI_HCD_OCTEON) += xhci-octeon.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FUSBH200_HCD)	+= fusbh200-hcd.o
diff --git a/drivers/usb/host/xhci-octeon.c b/drivers/usb/host/xhci-octeon.c
new file mode 100644
index 0000000..e35e9fb
--- /dev/null
+++ b/drivers/usb/host/xhci-octeon.c
@@ -0,0 +1,196 @@
+/*
+ * XHCI HCD glue for Cavium Octeon III SOCs.
+ *
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Cavium Networks
+ *
+ */
+
+
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-usbdrdx-defs.h>
+
+/* Common clock init code.  */
+void octeon3_usb_clocks_start(int node);
+void octeon3_usb_clocks_stop(int node);
+void octeon3_usb_set_endian_mode(int node);
+
+static int __init xhci_octeon_init(void)
+{
+	octeon3_usb_clocks_start(0);
+	octeon3_usb_clocks_start(1);
+	octeon3_usb_set_endian_mode(0);
+	octeon3_usb_set_endian_mode(1);
+	return 0;
+}
+
+static void __exit xhci_octeon_exit(void)
+{
+	octeon3_usb_clocks_stop(0);
+	octeon3_usb_clocks_stop(1);
+}
+
+arch_initcall(xhci_octeon_init);
+module_exit(xhci_octeon_exit);
+
+
+static DEFINE_MUTEX(octeon3_usb1_clocks_mutex);
+static DEFINE_MUTEX(octeon3_usb2_clocks_mutex);
+static int octeon3_usb1_clock_start_cnt;
+static int octeon3_usb2_clock_start_cnt;
+
+void octeon3_usb_clocks_start(int index)
+{
+	u64 div;
+	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
+	int ref_clk_sel = 2; //to_do, get from device tree
+
+	if (index == 0) {
+		mutex_lock(&octeon3_usb1_clocks_mutex);
+		octeon3_usb1_clock_start_cnt++;
+		if (octeon3_usb1_clock_start_cnt != 1)
+			goto exit;
+	}
+	else {
+		mutex_lock(&octeon3_usb2_clocks_mutex);
+		octeon3_usb2_clock_start_cnt++;
+		if (octeon3_usb2_clock_start_cnt != 1)
+			goto exit;
+	}
+	printk("Initializing USB clocks !!!!!!\n");
+	/*
+	* Step 1: Wait for voltages stable.  That surely happened
+	* before starting the kernel.
+	* Ensure the reference clock is up and stable ??
+	*/
+
+	/* Step 2: Wait for IOI reset to deassert  ?? */
+
+	/* Step 3: program over current indication if desired, later */
+
+	/* Step 3: program the port power control feature if desired, later */
+
+	/* Step 4: Assert all resets */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uphy_rst = 1;
+	uctl_ctl.s.uahc_rst = 1;
+	uctl_ctl.s.uctl_rst = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 5a: Reset the clock dividers */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_rst = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* 5b */
+	/* Step 5b: Select controller clock frequency */
+	div = 2; //vinita_to_to uncomment later
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_sel = div;
+	uctl_ctl.s.h_clk_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	if(div != uctl_ctl.s.h_clkdiv_sel || !uctl_ctl.s.h_clk_en) {
+		printk("ERROR: usb controller clock init\n");
+			goto exit;
+	}
+
+	/* Step 5c: Deassert the controller clock divider reset */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step ??*/
+	cvmx_wait(2000);
+
+	/* Step 6a-6d & 7: Reference clock configuration */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.ssc_en =0;
+	uctl_ctl.s.ref_ssp_en = 1;
+	uctl_ctl.s.ref_clk_sel = ref_clk_sel;
+	uctl_ctl.s.ref_clk_fsel = 0x07;
+	uctl_ctl.s.ref_clk_div2 = 0;
+	uctl_ctl.s.mpll_multiplier = 0x19;
+	uctl_ctl.s.ss_power_en = 1;
+	uctl_ctl.s.hs_power_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 9 */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uctl_rst = 0;
+	uctl_ctl.s.uahc_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 8*/
+	cvmx_wait(10);
+
+	/* Step 10*/
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.csclk_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/*Step 11*/
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	printk("Enabling host mode\n");
+	uctl_ctl.s.drd_mode = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	octeon_error_tree_enable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+exit:
+	if (index == 0)
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	else
+		mutex_unlock(&octeon3_usb2_clocks_mutex);
+
+}
+EXPORT_SYMBOL(octeon3_usb_clocks_start);
+
+void octeon3_usb_clocks_stop(int index)
+{
+	if (index == 0) {
+		mutex_lock(&octeon3_usb1_clocks_mutex);
+		octeon3_usb1_clock_start_cnt--;
+		if (octeon3_usb1_clock_start_cnt == 0)
+			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	} else {
+		mutex_lock(&octeon3_usb2_clocks_mutex);
+		octeon3_usb2_clock_start_cnt--;
+		if (octeon3_usb2_clock_start_cnt == 0 )
+			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	}
+}
+EXPORT_SYMBOL(octeon3_usb_clocks_stop);
+
+void octeon3_usb_set_endian_mode(int index)
+{
+	union cvmx_usbdrdx_uctl_shim_cfg shim_cfg;
+	shim_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index));
+	shim_cfg.s.dma_endian_mode = 1;
+	shim_cfg.s.csr_endian_mode = 1; //to_do, check for little big endian
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index), shim_cfg.u64);
+}
+EXPORT_SYMBOL(octeon3_usb_set_endian_mode);
+
+void octeon3_usb_phy_reset(int index)
+{
+	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
+
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uphy_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+}
+EXPORT_SYMBOL(octeon3_usb_phy_reset);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 32a1021..a822cda 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -196,7 +196,7 @@ int xhci_reset(struct xhci_hcd *xhci)
 	return ret;
 }
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_DWC3_PCI
 static int xhci_free_msi(struct xhci_hcd *xhci)
 {
 	int i;
-- 
1.8.2.1

