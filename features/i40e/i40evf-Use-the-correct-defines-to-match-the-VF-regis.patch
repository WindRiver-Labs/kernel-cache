From 8c0424d69f746a28640e04aa230cad20e663bb68 Mon Sep 17 00:00:00 2001
Message-Id: <8c0424d69f746a28640e04aa230cad20e663bb68.1446666317.git.Jim.Somerville@windriver.com>
In-Reply-To: <600cfea62095b98641701c9824963b5ec85f9153.1446666317.git.Jim.Somerville@windriver.com>
References: <600cfea62095b98641701c9824963b5ec85f9153.1446666317.git.Jim.Somerville@windriver.com>
From: Anjali Singhai Jain <anjali.singhai@intel.com>
Date: Fri, 10 Jul 2015 19:36:05 -0400
Subject: [PATCH 29/41] i40evf: Use the correct defines to match the VF
 registers

Use CTLN1 instead of CTLN for the VF relative register space.

Change-ID: Iefba63faf0307af55fec8dbb64f26059f7d91318
Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit b1f3366b86a9e99f4d4d557b02e0f53fa7ccd72c)
Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 drivers/net/ethernet/intel/i40evf/i40e_txrx.c   | 28 +++++++++---------
 drivers/net/ethernet/intel/i40evf/i40evf_main.c | 38 ++++++++++++-------------
 2 files changed, 33 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 53513179..fdf7752 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@ -1288,17 +1288,17 @@ static inline void i40e_update_enable_itr(struct i40e_vsi *vsi,
 		old_itr = q_vector->rx.itr;
 		i40e_set_new_dynamic_itr(&q_vector->rx);
 		if (old_itr != q_vector->rx.itr) {
-			val = I40E_VFINT_DYN_CTLN_INTENA_MASK |
-			I40E_VFINT_DYN_CTLN_CLEARPBA_MASK |
+			val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
+			I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK |
 			(I40E_RX_ITR <<
-				I40E_VFINT_DYN_CTLN_ITR_INDX_SHIFT) |
+				I40E_VFINT_DYN_CTLN1_ITR_INDX_SHIFT) |
 			(q_vector->rx.itr <<
-				I40E_VFINT_DYN_CTLN_INTERVAL_SHIFT);
+				I40E_VFINT_DYN_CTLN1_INTERVAL_SHIFT);
 		} else {
-			val = I40E_VFINT_DYN_CTLN_INTENA_MASK |
-			I40E_VFINT_DYN_CTLN_CLEARPBA_MASK |
+			val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
+			I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK |
 			(I40E_ITR_NONE <<
-				I40E_VFINT_DYN_CTLN_ITR_INDX_SHIFT);
+				I40E_VFINT_DYN_CTLN1_ITR_INDX_SHIFT);
 		}
 		if (!test_bit(__I40E_DOWN, &vsi->state))
 			wr32(hw, I40E_VFINT_DYN_CTLN1(vector - 1), val);
@@ -1310,18 +1310,18 @@ static inline void i40e_update_enable_itr(struct i40e_vsi *vsi,
 		old_itr = q_vector->tx.itr;
 		i40e_set_new_dynamic_itr(&q_vector->tx);
 		if (old_itr != q_vector->tx.itr) {
-			val = I40E_VFINT_DYN_CTLN_INTENA_MASK |
-				I40E_VFINT_DYN_CTLN_CLEARPBA_MASK |
+			val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
+				I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK |
 				(I40E_TX_ITR <<
-				   I40E_VFINT_DYN_CTLN_ITR_INDX_SHIFT) |
+				   I40E_VFINT_DYN_CTLN1_ITR_INDX_SHIFT) |
 				(q_vector->tx.itr <<
-				   I40E_VFINT_DYN_CTLN_INTERVAL_SHIFT);
+				   I40E_VFINT_DYN_CTLN1_INTERVAL_SHIFT);
 
 		} else {
-			val = I40E_VFINT_DYN_CTLN_INTENA_MASK |
-				I40E_VFINT_DYN_CTLN_CLEARPBA_MASK |
+			val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
+				I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK |
 				(I40E_ITR_NONE <<
-				   I40E_VFINT_DYN_CTLN_ITR_INDX_SHIFT);
+				   I40E_VFINT_DYN_CTLN1_ITR_INDX_SHIFT);
 		}
 		if (!test_bit(__I40E_DOWN, &vsi->state))
 			wr32(hw, I40E_VFINT_DYN_CTLN1(vector - 1), val);
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_main.c b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 1dc79d9..291e3fb 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@ -204,7 +204,7 @@ static void i40evf_misc_irq_enable(struct i40evf_adapter *adapter)
 
 	wr32(hw, I40E_VFINT_DYN_CTL01, I40E_VFINT_DYN_CTL01_INTENA_MASK |
 				       I40E_VFINT_DYN_CTL01_ITR_INDX_MASK);
-	wr32(hw, I40E_VFINT_ICR0_ENA1, I40E_VFINT_ICR0_ENA_ADMINQ_MASK);
+	wr32(hw, I40E_VFINT_ICR0_ENA1, I40E_VFINT_ICR0_ENA1_ADMINQ_MASK);
 
 	/* read flush */
 	rd32(hw, I40E_VFGEN_RSTAT);
@@ -245,7 +245,7 @@ void i40evf_irq_enable_queues(struct i40evf_adapter *adapter, u32 mask)
 			wr32(hw, I40E_VFINT_DYN_CTLN1(i - 1),
 			     I40E_VFINT_DYN_CTLN1_INTENA_MASK |
 			     I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK |
-			     I40E_VFINT_DYN_CTLN_CLEARPBA_MASK);
+			     I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK);
 		}
 	}
 }
@@ -263,17 +263,17 @@ static void i40evf_fire_sw_int(struct i40evf_adapter *adapter, u32 mask)
 
 	if (mask & 1) {
 		dyn_ctl = rd32(hw, I40E_VFINT_DYN_CTL01);
-		dyn_ctl |= I40E_VFINT_DYN_CTLN_SWINT_TRIG_MASK |
+		dyn_ctl |= I40E_VFINT_DYN_CTLN1_SWINT_TRIG_MASK |
 			   I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK |
-			   I40E_VFINT_DYN_CTLN_CLEARPBA_MASK;
+			   I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK;
 		wr32(hw, I40E_VFINT_DYN_CTL01, dyn_ctl);
 	}
 	for (i = 1; i < adapter->num_msix_vectors; i++) {
 		if (mask & BIT(i)) {
 			dyn_ctl = rd32(hw, I40E_VFINT_DYN_CTLN1(i - 1));
-			dyn_ctl |= I40E_VFINT_DYN_CTLN_SWINT_TRIG_MASK |
+			dyn_ctl |= I40E_VFINT_DYN_CTLN1_SWINT_TRIG_MASK |
 				   I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK |
-				   I40E_VFINT_DYN_CTLN_CLEARPBA_MASK;
+				   I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK;
 			wr32(hw, I40E_VFINT_DYN_CTLN1(i - 1), dyn_ctl);
 		}
 	}
@@ -313,7 +313,7 @@ static irqreturn_t i40evf_msix_aq(int irq, void *data)
 
 
 	val = rd32(hw, I40E_VFINT_DYN_CTL01);
-	val = val | I40E_PFINT_DYN_CTL0_CLEARPBA_MASK;
+	val = val | I40E_VFINT_DYN_CTL01_CLEARPBA_MASK;
 	wr32(hw, I40E_VFINT_DYN_CTL01, val);
 
 	/* schedule work on the private workqueue */
@@ -1779,34 +1779,34 @@ static void i40evf_adminq_task(struct work_struct *work)
 	/* check for error indications */
 	val = rd32(hw, hw->aq.arq.len);
 	oldval = val;
-	if (val & I40E_VF_ARQLEN_ARQVFE_MASK) {
+	if (val & I40E_VF_ARQLEN1_ARQVFE_MASK) {
 		dev_info(&adapter->pdev->dev, "ARQ VF Error detected\n");
-		val &= ~I40E_VF_ARQLEN_ARQVFE_MASK;
+		val &= ~I40E_VF_ARQLEN1_ARQVFE_MASK;
 	}
-	if (val & I40E_VF_ARQLEN_ARQOVFL_MASK) {
+	if (val & I40E_VF_ARQLEN1_ARQOVFL_MASK) {
 		dev_info(&adapter->pdev->dev, "ARQ Overflow Error detected\n");
-		val &= ~I40E_VF_ARQLEN_ARQOVFL_MASK;
+		val &= ~I40E_VF_ARQLEN1_ARQOVFL_MASK;
 	}
-	if (val & I40E_VF_ARQLEN_ARQCRIT_MASK) {
+	if (val & I40E_VF_ARQLEN1_ARQCRIT_MASK) {
 		dev_info(&adapter->pdev->dev, "ARQ Critical Error detected\n");
-		val &= ~I40E_VF_ARQLEN_ARQCRIT_MASK;
+		val &= ~I40E_VF_ARQLEN1_ARQCRIT_MASK;
 	}
 	if (oldval != val)
 		wr32(hw, hw->aq.arq.len, val);
 
 	val = rd32(hw, hw->aq.asq.len);
 	oldval = val;
-	if (val & I40E_VF_ATQLEN_ATQVFE_MASK) {
+	if (val & I40E_VF_ATQLEN1_ATQVFE_MASK) {
 		dev_info(&adapter->pdev->dev, "ASQ VF Error detected\n");
-		val &= ~I40E_VF_ATQLEN_ATQVFE_MASK;
+		val &= ~I40E_VF_ATQLEN1_ATQVFE_MASK;
 	}
-	if (val & I40E_VF_ATQLEN_ATQOVFL_MASK) {
+	if (val & I40E_VF_ATQLEN1_ATQOVFL_MASK) {
 		dev_info(&adapter->pdev->dev, "ASQ Overflow Error detected\n");
-		val &= ~I40E_VF_ATQLEN_ATQOVFL_MASK;
+		val &= ~I40E_VF_ATQLEN1_ATQOVFL_MASK;
 	}
-	if (val & I40E_VF_ATQLEN_ATQCRIT_MASK) {
+	if (val & I40E_VF_ATQLEN1_ATQCRIT_MASK) {
 		dev_info(&adapter->pdev->dev, "ASQ Critical Error detected\n");
-		val &= ~I40E_VF_ATQLEN_ATQCRIT_MASK;
+		val &= ~I40E_VF_ATQLEN1_ATQCRIT_MASK;
 	}
 	if (oldval != val)
 		wr32(hw, hw->aq.asq.len, val);
-- 
1.8.3.2

