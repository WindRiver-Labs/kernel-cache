From 2fee1e758b262c827a9f06f494cb660cb049cd5c Mon Sep 17 00:00:00 2001
From: Anjali Singhai Jain <anjali.singhai@intel.com>
Date: Wed, 4 Jun 2014 01:23:26 +0000
Subject: [PATCH 214/291] i40e: Bypass timeout recovery level 0 so as to not
 cause MDD

commit 327fe04bfb32642eee237e1cc1eaef16d6a4a0f5 upstream

When a Tx hang happens, usually the Tx queue disable fails. At
this point if we try to recover by a VSI reinit the HW gets
unhappy and we get a Malicious Driver Detect (MDD) event.
HW expects a PF reset if a queue disable fails, if we don't do a PF
reset and restart the queue we get an MDD.  This patch makes sure we
do a PF reset on Tx hang and that way we avoid any MDD because of Tx
queue disable failure.

Change-ID: I665ab6223577c788da857ee2132e733dc9a451e4
Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/net/ethernet/intel/i40e/i40e_main.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 4656e66..aa1a3c6 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -278,7 +278,7 @@ static void i40e_tx_timeout(struct net_device *netdev)
 	pf->tx_timeout_count++;
 
 	if (time_after(jiffies, (pf->tx_timeout_last_recovery + HZ*20)))
-		pf->tx_timeout_recovery_level = 0;
+		pf->tx_timeout_recovery_level = 1;
 	pf->tx_timeout_last_recovery = jiffies;
 	netdev_info(netdev, "tx_timeout recovery level %d\n",
 		    pf->tx_timeout_recovery_level);
@@ -6813,6 +6813,8 @@ static int i40e_sw_init(struct i40e_pf *pf)
 	pf->irq_pile->num_entries = pf->hw.func_caps.num_msix_vectors;
 	pf->irq_pile->search_hint = 0;
 
+	pf->tx_timeout_recovery_level = 1;
+
 	mutex_init(&pf->switch_mutex);
 
 sw_init_done:
-- 
1.7.5.4

