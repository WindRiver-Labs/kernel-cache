From 7d991333d0d4bd7ec49ee73b138ab811e589bacf Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Thu, 6 May 2010 23:31:23 -0700
Subject: [PATCH 5/5] EDAC: add vMC support for EDAC

vMC API wrapper functions for vMC sensor creation and fault reporting
from EDAC was added.

Extended EDAC vMC wrappers to allow the registration and triggering
of vMC containment handlers was also added.  Containment handlers
are callbacks triggered by the assertion of appropriately configured
vMC sensors. This framework allows for the creation of custom
containment handlers.

EDAC vMC wrapper calls and a vMC sensor mappings for e7xxx chipsets
was added, which can be enabled by the CONFIG_EDAC_VMC kernel
configuration.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/edac/Kconfig                |    9 +
 drivers/edac/Makefile               |    4 +
 drivers/edac/e7xxx_edac.c           |  257 ++++++++++++++++++++++++++++++
 drivers/edac/e7xxx_edac_vmc.h       |  108 +++++++++++++
 drivers/edac/edac_module.c          |   14 ++
 drivers/edac/edac_vmc.c             |  298 +++++++++++++++++++++++++++++++++++
 drivers/edac/edac_vmc.h             |  183 +++++++++++++++++++++
 drivers/edac/edac_vmc_containment.c |   62 +++++++
 8 files changed, 935 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/e7xxx_edac_vmc.h
 create mode 100644 drivers/edac/edac_vmc.c
 create mode 100644 drivers/edac/edac_vmc.h
 create mode 100644 drivers/edac/edac_vmc_containment.c

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 9f89bd5..c8f2384 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -31,6 +31,15 @@ if EDAC
 
 comment "Reporting subsystems"
 
+config EDAC_VMC
+	bool "vMC Integration"
+	default n
+	depends on IPMI_VMC
+	help
+	  This enables vMC API calls within EDAC drivers to report fault
+	  events to the IPMI vMC (Virtual Management Controller).
+	  If unsure, select 'N'.
+
 config EDAC_DEBUG
 	bool "Debugging"
 	help
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index bc5dc23..1ab0b44 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -16,6 +16,10 @@ ifdef CONFIG_PCI
 edac_core-objs	+= edac_pci.o edac_pci_sysfs.o
 endif
 
+ifdef CONFIG_EDAC_VMC
+edac_core-objs	+= edac_vmc.o edac_vmc_containment.o
+endif
+
 obj-$(CONFIG_EDAC_DECODE_MCE)		+= edac_mce_amd.o
 
 obj-$(CONFIG_EDAC_AMD76X)		+= amd76x_edac.o
diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index 67ffa39..03ba5c2 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -40,6 +40,12 @@
 #include <linux/sched.h>
 #endif
 
+#ifdef CONFIG_EDAC_VMC
+#include <linux/string.h>
+#include "edac_vmc.h"
+#include "e7xxx_edac_vmc.h"
+#endif
+
 #define	E7XXX_REVISION " Ver: 2.0.2 " __DATE__
 #define	EDAC_MOD_STR	"e7xxx_edac"
 
@@ -336,6 +342,10 @@ static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 	struct e7xxx_dev_info *dev_info = edac_dev->pvt_info;
 	u8 ferr = 0, nerr = 0;
 
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id = -1;
+#endif
+
 	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &ferr);
 	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &nerr);
 	ferr &= E7501_HI_FERR_MASK;
@@ -343,6 +353,31 @@ static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 	if (!ferr && !nerr ) 
 		return;
 
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	switch (dev_info->err_dev) {
+	case PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT:
+		sensor_id = HIB_FLT;
+		break;
+	case PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT:
+		sensor_id = HIC_FLT;
+		break;
+	case PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT:
+		sensor_id = HID_FLT;
+		break;
+	default:
+		break;
+	}
+
+	if (sensor_id >= 0) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun,
+				SENSOR_ACTION_INC, 1, 2,
+				"FERR", ferr,
+				"NERR", nerr);
+	}
+#endif
+
 	/* only reset the bits we are interested in */
 	if (ferr)
 		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, ferr);
@@ -359,6 +394,7 @@ static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 	}
 #endif
 }
+
 static struct e7xxx_dev_info e7501_devs[] = {
 	/* The first element must be the memory controller device */
 	{
@@ -444,6 +480,14 @@ static void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 	int channel;
 
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(CECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_INC, 1, 2,
+			 "DRAM_CELOG_ADDRESS", info->dram_celog_add,
+			 "DRAM_CELOG_SYNDROME", info->dram_celog_syndrome);
+#endif
+
 	/* read the error address */
 	error_1b = info->dram_celog_add;
 	/* FIXME - should use PAGE_SHIFT */
@@ -460,6 +504,11 @@ static void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 static void process_ce_no_info(struct mem_ctl_info *mci)
 {
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(CECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_INC, 1, 0);
+#endif
+
 	edac_mc_handle_ce_no_info(mci, "e7xxx CE log register overflow");
 }
 
@@ -469,6 +518,15 @@ static void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 	int row;
 
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(UECC_FLT, e7xxx_vmc_lun,
+			 SENSOR_ACTION_SET,
+			 TH_GEN_UPPER_NON_RECOVERABLE, 1,
+			 "DRAM_UELOG_ADDRESS", info->dram_uelog_add);
+#endif
+
 	/* read the error address */
 	error_2b = info->dram_uelog_add;
 	/* FIXME - should use PAGE_SHIFT */
@@ -480,8 +538,16 @@ static void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 static void process_ue_no_info(struct mem_ctl_info *mci)
 {
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(UECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+			 TH_GEN_UPPER_NON_RECOVERABLE, 0);
+#endif
+
 	edac_mc_handle_ue_no_info(mci, "e7xxx UE log register overflow");
 }
+
 #define HUB_ERR_MSG_NUM		7
 static char *hub_message[HUB_ERR_MSG_NUM] = {
 	[0] = "Address or Command Parity", 
@@ -498,6 +564,9 @@ static void process_hub_error(struct mem_ctl_info *mci,
 {
 	int i;
 	u8 error = info->hia_ferr | info->hia_nerr;
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id = -1;
+#endif
 
 	for (i = 0; i < HUB_ERR_MSG_NUM; i++) {
 		if (!hub_message[i])
@@ -508,6 +577,25 @@ static void process_hub_error(struct mem_ctl_info *mci,
 				hub_message[i]);
 	}
 
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	if (error & (1 << 0))
+		sensor_id = HUB_ADDR_CMD_PAR_FLT;
+	else if (error & (1 << 4))
+		sensor_id = HUB_DATA_PAR_FLT;
+	else if (error & (1 << 6))
+		sensor_id = HUB_TARGET_ABORT_FLT;
+
+	if (sensor_id >= 0) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+				 TH_GEN_UPPER_NON_RECOVERABLE, 2,
+				 "HIA_FERR",
+				 info->hia_ferr & E7501_HIA_FERR_MASK,
+				 "HIA_NERR",
+				 info->hia_nerr & E7501_HIA_FERR_MASK);
+	}
+#endif
 
 }
 
@@ -528,6 +616,9 @@ static void process_sysbus_error(struct mem_ctl_info *mci,
 {
 	int i;
 	u8 error = info->sysbus_ferr | info->sysbus_nerr;
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id = -1;
+#endif
 
 	mci->sysbus_err_count++;
 
@@ -537,6 +628,33 @@ static void process_sysbus_error(struct mem_ctl_info *mci,
 				       sysbus_message[i]);
 	}
 
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	if (error & (1 << 0))
+		sensor_id = SYSBUS_ADD_REQ_PAR_FLT;
+	else if (error & (1 << 1))
+		sensor_id = SYSBUS_DSTROBE_FLT;
+	else if (error & (1 << 2))
+		sensor_id = SYSBUS_ASTROBE_FLT;
+	else if (error & (1 << 3))
+		sensor_id = SYSBUS_DATA_PAR_FLT;
+	else if (error & (1 << 4))
+		sensor_id = SYSBUS_ADDR_TOM_FLT;
+	else if (error & (1 << 5))
+		sensor_id = SYSBUS_NONDRAM_LOCK_FLT;
+	else if (error & (1 << 6))
+		sensor_id = SYSBUS_MCERR_FLT;
+	else if (error & (1 << 7))
+		sensor_id = SYSBUS_BINIT_FLT;
+
+	if (sensor_id >= 0) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+				 TH_GEN_UPPER_NON_RECOVERABLE, 2,
+				 "SYSBUS_FERR", info->sysbus_ferr,
+				 "SYSBUS_NERR", info->sysbus_nerr);
+	}
+#endif
 }
 
 static void e7xxx_get_error_info(struct mem_ctl_info *mci,
@@ -925,6 +1043,133 @@ static void e7501_D0F1_exit(struct pci_dev *dev)
 	        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, byte);
 	}
 }
+
+#ifdef CONFIG_EDAC_VMC
+/*
+ * Meaning of vmc_intf_num:
+ * -1, vMC has not been loaded yet;
+ * >=0, vMC's interface number.
+ */
+static int vmc_intf_num = -1;
+
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	struct vmc_sensor_params_s uecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	struct vmc_sensor_params_s cecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = CECC_THRESHOLD_TBL,
+		.threshold_mask = READ_THRES_MASK_UPPER_CRITICAL,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/*
+	 * Assign a vMC LUN to this chipset.
+	 * Preserve the valid LUN number previously assigned.
+	 */
+	if (e7xxx_vmc_lun == -1)
+		e7xxx_vmc_lun = vmc_assign_lun();
+
+	/* Sensors with non-default parameters */
+	rc  = vmc_sensor_init(UECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
+			      e7xxx_vmc_lun, &uecc_flt_params);
+	rc |= vmc_sensor_init(CECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
+			      e7xxx_vmc_lun, &cecc_flt_params);
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), e7xxx_sensor_map,	\
+						e7xxx_sensor_names,	\
+						e7xxx_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADD_REQ_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_DSTROBE_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ASTROBE_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_DATA_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADDR_TOM_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_NONDRAM_LOCK_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_MCERR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_BINIT_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_ADDR_CMD_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_DATA_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_TARGET_ABORT_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HIB_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HIC_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HID_FLT);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	if (vmc_intf_num == -1)
+		return;
+
+	vmc_sensor_uninit(UECC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(CECC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ADD_REQ_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_DSTROBE_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ASTROBE_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_DATA_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ADDR_TOM_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_NONDRAM_LOCK_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_MCERR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_BINIT_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_ADDR_CMD_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_DATA_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_TARGET_ABORT_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HIB_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HIC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HID_FLT, e7xxx_vmc_lun);
+
+	vmc_release_lun(e7xxx_vmc_lun);
+}
+
+/* Add sensors to vMC */
+static void edac_new_smi(int intf_num, struct device *device)
+{
+	/* Bypass BMC interface */
+	if (strcmp(device->driver->name, VMC_DEVICE_NAME) == 0) {
+		vmc_intf_num = intf_num;
+		e7xxx_printk(KERN_INFO, "found vMC available at intf_num %d\n",
+			intf_num);
+		if (init_vmc_sensors())
+			e7xxx_printk(KERN_ERR, "failed to initialize "
+					" one or more vMC sensors\n");
+	}
+}
+
+/*
+ * Note, vMC's SDR/SEL repositories would have been destroyed
+ * before this smi_gone() is called, so there is nothing left to do.
+ */
+static void edac_smi_gone(int intf_num)
+{
+	if (vmc_intf_num == intf_num)
+		vmc_intf_num = -1;
+
+	return;
+}
+
+static struct ipmi_smi_watcher vmc_watcher = {
+	.owner = THIS_MODULE,
+	.new_smi = edac_new_smi,
+	.smi_gone = edac_smi_gone
+};
+
+#endif /* CONFIG_EDAC_VMC */
+
+
 static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 {
 	u16 pci_data;
@@ -936,6 +1181,12 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 
 	debugf0("%s(): mci\n", __func__);
 
+#ifdef CONFIG_EDAC_VMC
+	int ret = ipmi_smi_watcher_register(&vmc_watcher);
+	if (ret)
+		e7xxx_printk(KERN_ERR, "can't register vMC's smi watcher!\n");
+#endif
+
 	pci_read_config_dword(pdev, E7XXX_DRC, &drc);
 
 	drc_chan = dual_channel_active(drc, dev_idx);
@@ -1076,6 +1327,12 @@ static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 
 	debugf0("%s()\n", __func__);
 
+#ifdef CONFIG_EDAC_VMC
+	/* Unregister vMC's smi_watcher and cleanup vMC sensors */
+	ipmi_smi_watcher_unregister(&vmc_watcher);
+	uninit_vmc_sensors();
+#endif
+
 	if (e7xxx_pci)
 		edac_pci_release_generic_ctl(e7xxx_pci);
 
diff --git a/drivers/edac/e7xxx_edac_vmc.h b/drivers/edac/e7xxx_edac_vmc.h
new file mode 100644
index 0000000..a96498a
--- /dev/null
+++ b/drivers/edac/e7xxx_edac_vmc.h
@@ -0,0 +1,108 @@
+/*
+ * e7xxx_edac_vmc.h, vMC sensor maps for e7xxx EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _E7XXX_EDAC_VMC_H_
+#define _E7XXX_EDAC_VMC_H_
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum e7xxx_sensors {
+	/* Gerneral sensors: */
+	UECC_FLT = 0,
+	CECC_FLT,
+
+	SYSBUS_ADD_REQ_PAR_FLT,
+	SYSBUS_DSTROBE_FLT,
+	SYSBUS_ASTROBE_FLT,
+	SYSBUS_DATA_PAR_FLT,
+	SYSBUS_ADDR_TOM_FLT,
+	SYSBUS_NONDRAM_LOCK_FLT,
+	SYSBUS_MCERR_FLT,
+	SYSBUS_BINIT_FLT,
+
+	HUB_ADDR_CMD_PAR_FLT,
+	HUB_DATA_PAR_FLT,
+	HUB_TARGET_ABORT_FLT,
+
+	HIB_FLT,
+	HIC_FLT,
+	HID_FLT
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *e7xxx_sensor_names[] = {
+	name_sensor(UECC_FLT),
+	name_sensor(CECC_FLT),
+
+	name_sensor(SYSBUS_ADD_REQ_PAR_FLT),
+	name_sensor(SYSBUS_DSTROBE_FLT),
+	name_sensor(SYSBUS_ASTROBE_FLT),
+	name_sensor(SYSBUS_DATA_PAR_FLT),
+	name_sensor(SYSBUS_ADDR_TOM_FLT),
+	name_sensor(SYSBUS_NONDRAM_LOCK_FLT),
+	name_sensor(SYSBUS_MCERR_FLT),
+	name_sensor(SYSBUS_BINIT_FLT),
+
+	name_sensor(HUB_ADDR_CMD_PAR_FLT),
+	name_sensor(HUB_DATA_PAR_FLT),
+	name_sensor(HUB_TARGET_ABORT_FLT),
+
+	name_sensor(HIB_FLT),
+	name_sensor(HIC_FLT),
+	name_sensor(HID_FLT)
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(x, y, z) [(x)] = (((y) << 8) | (z))
+static const int e7xxx_sensor_map[] = {
+	/* General sensors: */
+	map_sensor(UECC_FLT,		IPMI_ENTITY_ID_MEMORY_DEVICE,	0x00),
+	map_sensor(CECC_FLT,		IPMI_ENTITY_ID_MEMORY_DEVICE,	0x00),
+
+	map_sensor(SYSBUS_ADD_REQ_PAR_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_DSTROBE_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_ASTROBE_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_DATA_PAR_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_ADDR_TOM_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_NONDRAM_LOCK_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_MCERR_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_BINIT_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+
+	map_sensor(HUB_ADDR_CMD_PAR_FLT, IPMI_ENTITY_ID_PCI_BUS,	0x00),
+	map_sensor(HUB_DATA_PAR_FLT,	IPMI_ENTITY_ID_PCI_BUS,		0x00),
+	map_sensor(HUB_TARGET_ABORT_FLT, IPMI_ENTITY_ID_PCI_BUS,	0x00),
+
+	map_sensor(HIB_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x01),
+	map_sensor(HIC_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x02),
+	map_sensor(HID_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x03),
+
+
+};
+
+/* e7xxx vMC IPMI LUN number */
+static int e7xxx_vmc_lun = -1;
+
+#endif	/* _E7XXX_EDAC_VMC_H_ */
diff --git a/drivers/edac/edac_module.c b/drivers/edac/edac_module.c
index 7e1374a..9146e39 100644
--- a/drivers/edac/edac_module.c
+++ b/drivers/edac/edac_module.c
@@ -12,6 +12,10 @@
  */
 #include <linux/edac.h>
 
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#endif
+
 #include "edac_core.h"
 #include "edac_module.h"
 
@@ -177,6 +181,11 @@ static int __init edac_init(void)
 		goto workq_fail;
 	}
 
+#ifdef CONFIG_EDAC_VMC
+	/* register vMC containment handlers */
+	vmc_register_containment();
+#endif
+
 	return 0;
 
 	/* Error teardown stack */
@@ -198,6 +207,11 @@ static void __exit edac_exit(void)
 {
 	debugf0("%s()\n", __func__);
 
+#ifdef CONFIG_EDAC_VMC
+	/* unregister vMC containment handlers */
+	vmc_unregister_containment();
+#endif
+
 	/* tear down the various subsystems */
 	edac_workqueue_teardown();
 	edac_sysfs_teardown_mc_kset();
diff --git a/drivers/edac/edac_vmc.c b/drivers/edac/edac_vmc.c
new file mode 100644
index 0000000..2d291ca
--- /dev/null
+++ b/drivers/edac/edac_vmc.c
@@ -0,0 +1,298 @@
+/*
+ * edac_vmc.c, EDAC wrapper routines for the vMC API
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include <linux/vmc.h>
+#include "edac_vmc.h"
+
+/* Number of vMC LUNs.  Each chipset registers sensors on a different LUN */
+DEFINE_SPINLOCK(num_luns_lock);
+static int vmc_luns[MAX_LUNS_SUPPORTED];
+
+/*
+ * Return a vMC LUN number for all sensors introduced by one EDAC module.
+ * There could be more than just one EDAC module, we prefer sensors
+ * have different LUN number on different EDAC module.
+ *
+ * We always try to return the first "empty" LUN number, so that if one
+ * of EDAC modules removed and then installed later, it could have a chance
+ * to reuse its previous LUN number.
+ *
+ * LUN number used by vMC sensors won't make much difference, they could
+ * be shared among EDAC modules, if the number of EDAC modules were greater
+ * than maximun supported LUN number, LUN = 0 would be shared. However,
+ * please note that if a same LUN number is shared among EDAC modules they
+ * should register each of their sensors with different IDs.
+ */
+unsigned char vmc_assign_lun(void)
+{
+	unsigned char i;
+
+	spin_lock(&num_luns_lock);
+
+	/* Find the first LUN number that has not been used */
+	for (i = 0; i < MAX_LUNS_SUPPORTED; i++)
+		if (vmc_luns[i] == 0)
+			break;
+
+	/* If all LUN numbers have been used, then overlap LUN = 0 */
+	if (i == MAX_LUNS_SUPPORTED)
+		i = 0;
+	/* Mark this LUN number as been used */
+	vmc_luns[i]++;
+
+	spin_unlock(&num_luns_lock);
+
+	return i;
+}
+EXPORT_SYMBOL(vmc_assign_lun);
+
+/* When an EDAC module removed, release the LUN number used */
+void vmc_release_lun(int lun)
+{
+	spin_lock(&num_luns_lock);
+	vmc_luns[lun]--;
+	spin_unlock(&num_luns_lock);
+}
+EXPORT_SYMBOL(vmc_release_lun);
+
+/* Initialize a single fault detection vMC Sensor Data Records (SDR).
+ * See edac_vmc.h for usage */
+int vmc_sensor_init(int sensor_id, const int *sensor_map,
+		     const char *sensor_names[], int sensor_lun,
+		     struct vmc_sensor_params_s *sensor_params)
+{
+	int rc = -1;
+	vMC_ipmi_sensor_ident_t sensor_ident;
+	vMC_ipmi_sdr_t *vmc_sdr;
+	struct vmc_sensor_params_s default_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_CRITICAL_INTERRUPT,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	/* use default paramaters if none are specified */
+	if (!sensor_params)
+		sensor_params = &default_params;
+
+	vmc_sdr = (*vMC_alloc_sdr_record)(EDAC_VMC_MC, IPMI_SDR_FULL_TYPE, &rc);
+	if (rc != VMC_NO_ERROR) {
+		fprintk("edac_init_vmc_sdr could not allocate vMC SDR (%d)\n",
+			rc);
+		rc = vMC_device_sdr_delete(&sensor_ident);
+		return rc;
+	}
+	if (vmc_sdr == NULL) {
+		fprintk("edac_init_vmc_sdr failed\n");
+		return rc;
+	}
+
+
+	/* Populate IPMI SDR Header (see IPMI 1.5 specification) */
+	vmc_sdr->sdr_hdr.record_length = sizeof(struct vMC_ipmi_sdr_full_s);
+	vmc_sdr->sdr_hdr.record_type = 0x1;
+
+	/* Populate IPMI SDR Body (see IPMI 1.5 specification) */
+	vmc_sdr->sdr_body.sdr_full.id_type = 0;
+	vmc_sdr->sdr_body.sdr_full.id = (EDAC_VMC_MC & 0xfe) >> 1;
+	vmc_sdr->sdr_body.sdr_full.sensor_owner_lun = sensor_lun;
+	vmc_sdr->sdr_body.sdr_full.lun_channel = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_number = sensor_id;
+	vmc_sdr->sdr_body.sdr_full.entity_ID =
+		get_sensor_entity(sensor_map, sensor_id);
+	vmc_sdr->sdr_body.sdr_full.entity_instance_num =
+		get_sensor_entity_instance(sensor_map, sensor_id);
+	vmc_sdr->sdr_body.sdr_full.entity_instance_type = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_scanning_enabled = 1;
+	vmc_sdr->sdr_body.sdr_full.event_generation_enabled = 1;
+	vmc_sdr->sdr_body.sdr_full.type_init_required = 1;
+	vmc_sdr->sdr_body.sdr_full.init_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.threshold_init_required = 1;
+	vmc_sdr->sdr_body.sdr_full.init_event_messages = 1;
+	vmc_sdr->sdr_body.sdr_full.init_scanning = 1;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_event_msg_control =
+		ENTIRE_SENSOR_ONLY;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_threshold_access =
+		THRESHOLDS_READABLE_SETTABLE;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_hysteresis_support =
+		NO_HYSTERESIS;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_auto_rearm = 0;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_ignore = 0;
+	vmc_sdr->sdr_body.sdr_full.event_reading_type_code =
+		sensor_params->event_reading_type;
+	vmc_sdr->sdr_body.sdr_full.assertion_event_mask =
+		DEFAULT_ASSERTION_EVENT_MASK;
+	vmc_sdr->sdr_body.sdr_full.deassertion_event_mask =
+		DEFAULT_DEASSERTION_EVENT_MASK;
+	vmc_sdr->sdr_body.sdr_full.read_thres_mask =
+		sensor_params->threshold_mask;
+	vmc_sdr->sdr_body.sdr_full.set_thres_mask =
+		sensor_params->threshold_mask;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_rate_unit =
+		sensor_params->leak_rate;
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_NON_RECOVERABLE] =
+		sensor_params->thresholds[UPPER_NON_RECOVERABLE];
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_CRITICAL] =
+		sensor_params->thresholds[UPPER_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_NON_CRITICAL] =
+		sensor_params->thresholds[UPPER_NON_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_NON_RECOVERABLE] =
+		sensor_params->thresholds[LOWER_NON_RECOVERABLE];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_CRITICAL] =
+		sensor_params->thresholds[LOWER_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_NON_CRITICAL] =
+		sensor_params->thresholds[LOWER_NON_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.sensor_type = sensor_params->sensor_type;
+	strcpy(vmc_sdr->sdr_body.sdr_full.id_string, sensor_names[sensor_id]);
+	vmc_sdr->sdr_body.sdr_full.M_ls8bits = 1;
+	vmc_sdr->sdr_body.sdr_full.id_string_num_bytes =
+		strlen(vmc_sdr->sdr_body.sdr_full.id_string);
+	vmc_sdr->sdr_body.sdr_full.id_string_type_code = 0x3;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_percentage = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_modifier_unit =
+			MODIFIER_NONE;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_raw_data_format =
+			FORMAT_UNSIGNED;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_2_base_unit = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_3_modifier_unit = 0;
+	vmc_sdr->sdr_body.sdr_full.positive_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.negative_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.M_ms2bits = 0;
+	vmc_sdr->sdr_body.sdr_full.B_ls8bits = 0;
+	vmc_sdr->sdr_body.sdr_full.B_ms2bits = 0;
+	vmc_sdr->sdr_body.sdr_full.nominal_reading = 0;
+	vmc_sdr->sdr_body.sdr_full.normal_maximum = 0;
+	vmc_sdr->sdr_body.sdr_full.normal_minimum = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_maximum_reading = 255;
+	vmc_sdr->sdr_body.sdr_full.sensor_minimum_reading = 0;
+	vmc_sdr->sdr_body.sdr_full.bmc_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.ipmb_upper_non_recoverable_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.ipmb_lower_non_recoverable_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.containment_enable =
+		sensor_params->containment_enable;
+
+	/* Send SDR to vMC core */
+	rc = vMC_device_sdr_add(vmc_sdr);
+	if (rc != VMC_NO_ERROR) {
+		fprintk("vmc_sensor_init could not add vMC SDR for %s at "
+			"sensor_lun = %d, sensor_id = %d\n",
+			sensor_names[sensor_id], sensor_lun, sensor_id);
+		vMC_device_sdr_delete(&sensor_ident);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(vmc_sensor_init);
+
+/* Report a fault to vMC
+ * See edac_vmc.h for usage */
+int vmc_report_fault(int sensor_id, int sensor_lun, int action,
+		int value, int num_regs, ...)
+{
+	int i, result, rc;
+	va_list argptr;
+	vMC_ipmi_sel_record_t *sel_record;
+	vMC_ipmi_sensor_ident_t sensor_ident;
+	fault_record_t *extended_data;
+	int sensor_value = 0;
+
+	if (num_regs > MAX_FAULT_RECORD_SIZE) {
+		rc = 1;
+		goto error;
+	}
+
+	/* Allocate vMC SEL record */
+	sel_record = vMC_alloc_sel_record(sizeof(fault_record_t), 0, &result);
+	if (result != VMC_NO_ERROR) {
+		rc = 1;
+		goto error;
+	}
+
+	/* Threshold sensor event */
+	sel_record->event_type = 0x01;
+	sel_record->sel_event_data.event_data[0] = 0x01;
+
+	/* Record fault type */
+	extended_data = (fault_record_t *) sel_record->extended_event_data;
+	extended_data->fault_type = 0; /* currently unused */
+
+	/* Store register names and values in SEL record */
+	va_start(argptr, num_regs);
+	for (i = 0; i < num_regs; ++i) {
+		strncpy(extended_data->fault_record_data[i].reg_name,
+			va_arg(argptr, char *), MAX_REG_NAME_SIZE);
+		extended_data->fault_record_data[i].data = va_arg(argptr, int);
+	}
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	/* Increment sensor value */
+	if (action == SENSOR_ACTION_INC) {
+		if (vMC_sensor_get_value(&sensor_ident, &sensor_value) ==
+				VMC_NO_ERROR) {
+			if (sensor_value < (TH_GEN_UPPER_NON_RECOVERABLE-1)) {
+				rc = vMC_sensor_increment_value(&sensor_ident,
+						value, sel_record);
+			}	/* else don't do anything since we would
+				   our unrecoverable case */
+		}
+	}
+	/* ...or set sensor value (action == SENSOR_ACTION_SET) */
+	else {
+		if (vMC_sensor_set_value(&sensor_ident, value, sel_record)) {
+			rc = 1;
+			goto error;
+		}
+	}
+
+	/* return success */
+	rc = 0;
+error:
+	return rc;
+
+}
+EXPORT_SYMBOL(vmc_report_fault);
+
+/* Uninitialize a vMC sensor
+ * See edav_vmc.h for usage */
+void vmc_sensor_uninit(int sensor_id, int sensor_lun)
+{
+	vMC_ipmi_sensor_ident_t sensor_ident;
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	/* Request vMC core remove SDR */
+	vMC_device_sdr_delete(&sensor_ident);
+}
+EXPORT_SYMBOL(vmc_sensor_uninit);
diff --git a/drivers/edac/edac_vmc.h b/drivers/edac/edac_vmc.h
new file mode 100644
index 0000000..81e513b
--- /dev/null
+++ b/drivers/edac/edac_vmc.h
@@ -0,0 +1,183 @@
+/*
+ * edac_vmc.h, EDAC vMC API wrapper header file
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _EDAC_VMC_H_
+#define _EDAC_VMC_H_
+
+#include <linux/vmc.h>
+#include <linux/ipmi_bits.h>
+
+/* vMC MC sensors belong to */
+#define EDAC_VMC_MC				0x20
+
+/* Copied from ipmi/vmc_emu.h */
+#define MAX_LUNS_SUPPORTED			4
+
+/* general sensor threshold values */
+#define TH_GEN_UPPER_NON_RECOVERABLE		255
+#define TH_GEN_UPPER_CRITICAL			120
+#define TH_GEN_UPPER_NON_CRITICAL		60
+#define TH_GEN_LOWER_NON_RECOVERABLE		255
+#define TH_GEN_LOWER_CRITICAL			10
+#define TH_GEN_LOWER_NON_CRITICAL		5
+#define GEN_THRESHOLD_TBL	{	TH_GEN_UPPER_NON_RECOVERABLE,	\
+					TH_GEN_UPPER_CRITICAL,	\
+					TH_GEN_UPPER_NON_CRITICAL,	\
+					TH_GEN_LOWER_NON_RECOVERABLE,	\
+					TH_GEN_LOWER_CRITICAL,	\
+					TH_GEN_LOWER_NON_CRITICAL	}
+
+/* CECC sensor threshold values */
+#define TH_CECC_UPPER_NON_RECOVERABLE		255
+#define TH_CECC_UPPER_CRITICAL			10
+#define TH_CECC_UPPER_NON_CRITICAL		2
+#define TH_CECC_LOWER_NON_RECOVERABLE		255
+#define TH_CECC_LOWER_CRITICAL			10
+#define TH_CECC_LOWER_NON_CRITICAL		2
+#define CECC_THRESHOLD_TBL	{	TH_CECC_UPPER_NON_RECOVERABLE,	\
+					TH_CECC_UPPER_CRITICAL,		\
+					TH_CECC_UPPER_NON_CRITICAL,	\
+					TH_CECC_LOWER_NON_RECOVERABLE,	\
+					TH_CECC_LOWER_CRITICAL,		\
+					TH_CECC_LOWER_NON_CRITICAL	}
+
+/* CRC sensor threshold values */
+#define TH_CRC_UPPER_NON_RECOVERABLE		255
+#define TH_CRC_UPPER_CRITICAL			10
+#define TH_CRC_UPPER_NON_CRITICAL		2
+#define TH_CRC_LOWER_NON_RECOVERABLE		255
+#define TH_CRC_LOWER_CRITICAL			10
+#define TH_CRC_LOWER_NON_CRITICAL		2
+#define CRC_THRESHOLD_TBL	{	TH_CRC_UPPER_NON_RECOVERABLE,	\
+					TH_CRC_UPPER_CRITICAL,		\
+					TH_CRC_UPPER_NON_CRITICAL,	\
+					TH_CRC_LOWER_NON_RECOVERABLE,	\
+					TH_CRC_LOWER_CRITICAL,		\
+					TH_CRC_LOWER_NON_CRITICAL	}
+
+/* Default sensor threshold read and set mask */
+#define DEFAULT_READ_SET_THRES_MASK \
+			(READ_THRES_MASK_LOWER_NON_CRITICAL \
+			| READ_THRES_MASK_LOWER_CRITICAL \
+			| READ_THRES_MASK_LOWER_NON_RECOVERABLE \
+			| READ_THRES_MASK_UPPER_NON_CRITICAL \
+			| READ_THRES_MASK_UPPER_CRITICAL \
+			| READ_THRES_MASK_UPPER_NON_RECOVERABLE)
+
+/* Faults can either increment a sensor or set it to a specific value */
+#define SENSOR_ACTION_INC	1
+#define SENSOR_ACTION_SET	0
+
+/* Convenient KERN_INFO level debug print macro */
+#define fprintk(format, arg...) printk(KERN_INFO "%s:%d " format \
+				       "\n" , __func__, __LINE__, ## arg)
+
+/* Sensor-Entity Map Queries */
+#define get_sensor_entity(x, y) ((char)(x)[(y)] >> 8)
+#define get_sensor_entity_instance(x, y) ((x)[(y)] & 0x0F)
+
+
+/*
+ * Data-type Definitions:
+ */
+
+/* sensor-specific contiguration struct used by vmc_sensor_init */
+struct vmc_sensor_params_s {
+	unsigned char sensor_type;
+	unsigned char event_reading_type;
+	unsigned char thresholds[6];
+	uint16_t threshold_mask;
+	int leak_rate;
+	unsigned char containment_enable:1;
+};
+
+
+/*
+ * Function Prototypes:
+ */
+
+/*
+ * Return a vMC LUN number for all sensors introduced by one EDAC module.
+ * There could be more than just one EDAC module, we prefer sensors
+ * have different LUN number on different EDAC module.
+ *
+ * We always try to return the first "empty" LUN number, so that if one
+ * of EDAC modules removed and then installed later, it could have a chance
+ * to reuse its previous LUN number.
+ *
+ * There are limited supported LUN number, if the number of EDAC modules
+ * were greater than that, LUN = 0 would be shared.
+ */
+unsigned char vmc_assign_lun(void);
+
+/* When an EDAC module removed, release the LUN number used */
+void vmc_release_lun(int lun);
+
+/* Initialize a vMC sensor given it's sensor ID, LUN, sensor-entity map,
+ * name table, and an optional pointer to configuration parameters.
+ * If sensor_params is a NULL pointer, the following defaults are assumed:
+ *   sensor type = IPMI_SENSOR_TYPE_CRITICAL_INTERRUPT
+ *   event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD
+ *   thresholds = GEN_THRESHOLD_TBL,
+ *   threashold_mask = DEFAULT_READ_SET_THRESH_MASK
+ *   leak_rate = RATE_MINUTE,
+ *   containment_enable = false
+ *
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files
+ *
+ * Returns 0 if successful */
+int vmc_sensor_init(int sensor_id, const int *sensor_map,
+			const char *sensor_names[],
+			int sensor_lun,
+			struct vmc_sensor_params_s *sensor_params);
+
+
+/* Report a fault to a vMC sensor given an action, value, and a list of
+ * registers names and their contents.
+ *   Arguments:
+ *      action: increment or set (SENSOR_ACTION_INC or SENSOR_ACTION_SET)
+ *      value: increment-by or set-to (0-255)
+ *      num_regs: number of register name-value pairs to follow
+ *      (...) : register names and value (ex ."reg1_name", reg1_value,
+ *               "reg2_name", reg2_value, ...)
+ *
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files
+ *
+ * Returns 0 if successful */
+int vmc_report_fault(int sensor_id, int sensor_lun, int action, int value,
+			    int num_regs, ...);
+
+
+/* Uninitialize a vMC sensor given its sensor ID and sensor LUN.
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files */
+void vmc_sensor_uninit(int sensor_id, int sensor_lun);
+
+
+/* Register vMC Containment Handlers
+ *   A matching containment handler will only be called on a sensor event if,
+ *   at sensor initialization, containment is enabled for that sensor. */
+void vmc_register_containment(void);
+
+
+/* Unregister all vMC containment handlers */
+void vmc_unregister_containment(void);
+
+#endif	/* _EDAC_VMC_H_ */
diff --git a/drivers/edac/edac_vmc_containment.c b/drivers/edac/edac_vmc_containment.c
new file mode 100644
index 0000000..55d0b7f
--- /dev/null
+++ b/drivers/edac/edac_vmc_containment.c
@@ -0,0 +1,62 @@
+/*
+ * edac_vmc_h.c, vMC Containment handlers and registration functions
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/vmc.h>
+#include <linux/reboot.h>
+
+#include "edac_vmc.h"
+
+/*
+ * Define containment handlers here:
+ */
+
+/* vMC containment hander for non-recoverable faults */
+static void containment_handler_restart(void)
+{
+	kernel_restart(NULL);
+}
+
+/* Register vMC Containment Handlers
+ *   A matching containment handler will only be called on a sensor event if,
+ *   at sensor initialization, containment is enabled for that sensor. */
+void vmc_register_containment(void)
+{
+	/* register restart containment handler for non-recoverable faults */
+	vMC_register_containment_handler(containment_handler_restart,
+				 SEVERITY_UPPER_NON_RECOVERABLE_GOING_HIGH);
+	vMC_register_containment_handler(containment_handler_restart,
+				 SEVERITY_LOWER_NON_RECOVERABLE_GOING_LOW);
+}
+
+/* Unregister all vMC containment handlers */
+void vmc_unregister_containment(void)
+{
+	int severity;
+
+	/* unregister all vMC containment handlers */
+	for (severity = SEVERITY_LOWER_NON_RECOVERABLE_GOING_LOW;
+	     severity <= SEVERITY_UPPER_NON_RECOVERABLE_GOING_HIGH;
+	     ++severity) {
+		vMC_register_containment_handler(NULL, severity);
+	}
+}
+
-- 
1.6.5.2

