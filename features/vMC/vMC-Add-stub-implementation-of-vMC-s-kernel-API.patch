From b88d0faa64045aab0699bad6fa6f891f699b3d77 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Thu, 6 May 2010 23:31:20 -0700
Subject: [PATCH 2/5] vMC: Add stub implementation of vMC's kernel API

Add trivial stub implementations of the vMC API.  This is done via
function pointers that are replaced when the main vMC module is
loaded, but allows static kernel code to link.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
Integrated-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/char/ipmi/Kconfig    |   15 +
 drivers/char/ipmi/Makefile   |    1 +
 drivers/char/ipmi/vmc_stub.c |  363 ++++++++++++++++
 include/linux/vmc.h          |  989 ++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 1368 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/ipmi/vmc_stub.c
 create mode 100644 include/linux/vmc.h

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index 0baa8fa..22e20d2 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -61,4 +61,19 @@ config IPMI_POWEROFF
          This enables a function to power off the system with IPMI if
 	 the IPMI management controller is capable of this.
 
+config IPMI_VMC_STUB
+	tristate 'Include vMC stub functions'
+	help
+	  Static kernel code such as cpu exception handlers may be instrumented
+	  to generate IPMI events. This instrumentation requires the virtual
+	  management controller functions. The user may want to load the vMC as
+	  a module, and in this case, the user will require vMC stub functions
+	  to be statically compiled into the kernel until this module is loaded.
+
+	  The stub functions implement trivial versions of the vMC API, via
+	  function pointers, that is replaced when the vMC module is loaded,
+	  but, allows static kernel code to link. These stub functions should
+	  generally be statically compiled into the kernel, but, may be created
+	  as a module for testing purposes.
+
 endif # IPMI_HANDLER
diff --git a/drivers/char/ipmi/Makefile b/drivers/char/ipmi/Makefile
index eb8a1a8..2733696 100644
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@ -9,3 +9,4 @@ obj-$(CONFIG_IPMI_DEVICE_INTERFACE) += ipmi_devintf.o
 obj-$(CONFIG_IPMI_SI) += ipmi_si.o
 obj-$(CONFIG_IPMI_WATCHDOG) += ipmi_watchdog.o
 obj-$(CONFIG_IPMI_POWEROFF) += ipmi_poweroff.o
+obj-$(CONFIG_IPMI_VMC_STUB) += vmc_stub.o
diff --git a/drivers/char/ipmi/vmc_stub.c b/drivers/char/ipmi/vmc_stub.c
new file mode 100644
index 0000000..eb82bab
--- /dev/null
+++ b/drivers/char/ipmi/vmc_stub.c
@@ -0,0 +1,363 @@
+/*
+ * Wind River IPMI virtual Management Controller API stubs
+ *
+ * The virtual Management Controller (vMC) implements a subset of an IPMI
+ * Baseboard Management Controller (BMC) in a kernel module. The vMC
+ * plugs into the OpenIPMI KLM which makes it look like a normal
+ * IPMI management controller to user applications.
+ *
+ * Users may enable instrumentation of static kernel code such as
+ * exception handlers to generate IPMI events using the vMC. The user
+ * may also want the vMC implementation loaded dynamically as a module.
+ * In this case, this code needs to be statically linked into the
+ * kernel so that the IPMI instrumentation code will link. This
+ * file contains trivial stub implementatins of the vMC API, via
+ * function pointers, that get replaced when the vMC module is loaded.
+ *
+ * Author: Wind River Systems
+ *         Chris Stone <christopher.stone@windriver.com>
+ *
+ * Copyright 2005 Wind River Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/vmc.h>
+
+#if defined(CONFIG_IPMI_VMC_STUB) || defined(CONFIG_IPMI_VMC_STUB_MODULE)
+
+void (*vMC_containment_handler[16]) (void);
+
+/*
+ *  Virtual Management Controller Function API
+ */
+
+
+/* vMC_alloc_sel_record
+ *       Allocate storage for a vMC_ipmi_sel_record_t type. */
+static vMC_ipmi_sel_record_t *
+vMC_alloc_sel_record_stub(unsigned int extended_data_length,
+			  unsigned char mc_ipmb, int *rc)
+{
+	*rc = VMC_MODULE_NOT_LOADED;
+	return NULL;
+}
+
+vMC_ipmi_sel_record_t *(*vMC_alloc_sel_record) (unsigned int
+						extended_data_length,
+						unsigned char mc_ipmb, int *rc)
+    = vMC_alloc_sel_record_stub;
+
+
+/* vMC_alloc_sdr_record
+ *   Allocate storage for a vMC_ipmi_sdr_t type. */
+static vMC_ipmi_sdr_t *vMC_alloc_sdr_record_stub(unsigned char mc_ipmb,
+						 unsigned char record_type,
+						 int *rc)
+{
+	*rc = VMC_MODULE_NOT_LOADED;
+	return NULL;
+}
+
+vMC_ipmi_sdr_t *(*vMC_alloc_sdr_record) (unsigned char mc_ipmb,
+					 unsigned char record_type, int *rc) =
+    vMC_alloc_sdr_record_stub;
+
+
+/* vMC_sel_add */
+static int vMC_sel_add_stub(vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC SEL Add\n");
+
+	if (vMC_sel_record)
+		kfree(vMC_sel_record);
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sel_add) (vMC_ipmi_sel_record_t *vMC_sel_record) = vMC_sel_add_stub;
+
+/* vMC_sel_add Machine check safe */
+static int vMC_sel_add_mcsafe_stub(vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC SEL Add Mcsafe\n");
+
+	kfree(vMC_sel_record);
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sel_add_mcsafe) (vMC_ipmi_sel_record_t *vMC_sel_record) =
+    vMC_sel_add_mcsafe_stub;
+
+
+/* vMC_device_sdr_add */
+static int vMC_device_sdr_add_stub(vMC_ipmi_sdr_t *vMC_sdr_record)
+{
+	printk(KERN_INFO "vMC SDR Add\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_device_sdr_add) (vMC_ipmi_sdr_t *vMC_sdr_record) =
+    vMC_device_sdr_add_stub;
+
+
+/* vMC_device_sdr_delete */
+static int vMC_device_sdr_delete_stub(vMC_ipmi_sensor_ident_t *sensor_ident)
+{
+	printk(KERN_INFO "vMC SDR Delete\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_device_sdr_delete) (vMC_ipmi_sensor_ident_t *sensor_ident) =
+    vMC_device_sdr_delete_stub;
+
+
+/* vMC_sensor_get_threshold_value */
+static int vMC_sensor_get_value_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+			  unsigned int *val)
+{
+	printk(KERN_INFO "vMC Sensor Get Value\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_get_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+			     unsigned int *val)
+    = vMC_sensor_get_value_stub;
+
+
+/* vMC_sensor_set_bit */
+static int vMC_sensor_set_bit_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+			unsigned bit, unsigned val,
+			vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC Sensor Set Bit\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_set_bit) (vMC_ipmi_sensor_ident_t *sensor_ident,
+			   unsigned bit, unsigned val,
+			   vMC_ipmi_sel_record_t *vMC_sel_record)
+    = vMC_sensor_set_bit_stub;
+
+
+/* vMC_sensor_set_value */
+static int vMC_sensor_set_value_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+			  unsigned char value,
+			  vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC Sensor Set Value\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_set_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+			     unsigned char value,
+			     vMC_ipmi_sel_record_t *vMC_sel_record)
+    = vMC_sensor_set_value_stub;
+
+
+/* vMC_sensor_increment_value */
+static int
+vMC_sensor_increment_value_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+				unsigned char value,
+				vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC Sensor Increment Value\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_increment_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				   unsigned char value,
+				   vMC_ipmi_sel_record_t *vMC_sel_record)
+    = vMC_sensor_increment_value_stub;
+
+
+/* vMC_sensor_increment_value, Machine check safe */
+static int
+vMC_sensor_increment_value_mcsafe_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+				       unsigned char value,
+				       vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC Sensor Increment Value MCsafe\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_increment_value_mcsafe) (vMC_ipmi_sensor_ident_t *
+					  sensor_ident, unsigned char value,
+					  vMC_ipmi_sel_record_t *
+					  vMC_sel_record)
+    = vMC_sensor_increment_value_mcsafe_stub;
+
+
+/* vMC_sensor_decrement_value */
+static int
+vMC_sensor_decrement_value_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+				unsigned char value,
+				vMC_ipmi_sel_record_t *vMC_sel_record)
+{
+	printk(KERN_INFO "vMC Sensor Decrement Value\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_decrement_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				   unsigned char value,
+				   vMC_ipmi_sel_record_t *vMC_sel_record)
+    = vMC_sensor_decrement_value_stub;
+
+
+/* vMC_sensor_external_event_mask */
+static int
+vMC_sensor_external_event_mask_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+				    unsigned char mask)
+{
+	printk(KERN_INFO "vMC Sensor External Event Mask\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_external_event_mask) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				       unsigned char mask)
+    = vMC_sensor_external_event_mask_stub;
+
+
+/* vMC_sensor_set_hysteresis */
+static int
+vMC_sensor_set_hysteresis_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+			       unsigned char support, unsigned char pos,
+			       unsigned char neg)
+{
+	printk(KERN_INFO "vMC Sensor Set Hysteresis\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_set_hysteresis) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				  unsigned char support, unsigned char pos,
+				  unsigned char neg)
+    = vMC_sensor_set_hysteresis_stub;
+
+/* vMC_sensor_set_threshold */
+static int
+vMC_sensor_set_threshold_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+			      unsigned char support, unsigned char readmask,
+			      unsigned char setmask, unsigned char *val)
+{
+	printk(KERN_INFO "vMC Sensor Set Threshold\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_set_threshold) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				 unsigned char support, unsigned char readmask,
+				 unsigned char setmask, unsigned char *val)
+    = vMC_sensor_set_threshold_stub;
+
+
+/* vMC_sensor_set_event_support */
+static int
+vMC_sensor_set_event_support_stub(vMC_ipmi_sensor_ident_t *sensor_ident,
+				  unsigned char support,
+				  unsigned int assertions_supported,
+				  unsigned int deassertions_supported)
+{
+	printk(KERN_INFO "vMC Sensor Set Event Support\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_set_event_support) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				     unsigned char support,
+				     unsigned int assertions_supported,
+				     unsigned int deassertions_supported)
+    = vMC_sensor_set_event_support_stub;
+
+
+/* vMC_register_containment_handler */
+void vMC_register_containment_handler(void (*handler) (void), unsigned severity)
+{
+	if (severity < 16)
+		vMC_containment_handler[severity] = handler;
+}
+
+
+/* register_vMC_stub
+ *   This function will set the vMC API functions to point to the stub
+ *   implementations. This function is normally called when another module,
+ *   that has replaced the stub implementations with it's own, is unloaded,
+ *   and needs to put the stub implementations back. */
+void register_vMC_stubs(void)
+{
+	vMC_alloc_sel_record = vMC_alloc_sel_record_stub;
+	vMC_alloc_sdr_record = vMC_alloc_sdr_record_stub;
+	vMC_sel_add = vMC_sel_add_stub;
+	vMC_sel_add_mcsafe = vMC_sel_add_mcsafe_stub;
+	vMC_device_sdr_add = vMC_device_sdr_add_stub;
+	vMC_device_sdr_delete = vMC_device_sdr_delete_stub;
+	vMC_sensor_get_value = vMC_sensor_get_value_stub;
+	vMC_sensor_set_bit = vMC_sensor_set_bit_stub;
+	vMC_sensor_set_value = vMC_sensor_set_value_stub;
+	vMC_sensor_increment_value = vMC_sensor_increment_value_stub;
+	vMC_sensor_increment_value_mcsafe =
+		vMC_sensor_increment_value_mcsafe_stub;
+	vMC_sensor_decrement_value = vMC_sensor_decrement_value_stub;
+	vMC_sensor_external_event_mask = vMC_sensor_external_event_mask_stub;
+	vMC_sensor_set_hysteresis = vMC_sensor_set_hysteresis_stub;
+	vMC_sensor_set_threshold = vMC_sensor_set_threshold_stub;
+	vMC_sensor_set_event_support = vMC_sensor_set_event_support_stub;
+}
+
+static __init int init_vMC_stub_mod(void)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		vMC_containment_handler[i] = NULL;
+
+	return 0;
+}
+
+static __exit void cleanup_vMC_stub(void)
+{
+	return;
+}
+
+module_exit(cleanup_vMC_stub);
+module_init(init_vMC_stub_mod);
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(vMC_alloc_sel_record);
+EXPORT_SYMBOL(vMC_alloc_sdr_record);
+EXPORT_SYMBOL(vMC_sel_add);
+EXPORT_SYMBOL(vMC_sel_add_mcsafe);
+EXPORT_SYMBOL(vMC_device_sdr_add);
+EXPORT_SYMBOL(vMC_device_sdr_delete);
+EXPORT_SYMBOL(vMC_sensor_get_value);
+EXPORT_SYMBOL(vMC_sensor_set_bit);
+EXPORT_SYMBOL(vMC_sensor_set_value);
+EXPORT_SYMBOL(vMC_sensor_increment_value);
+EXPORT_SYMBOL(vMC_sensor_increment_value_mcsafe);
+EXPORT_SYMBOL(vMC_sensor_decrement_value);
+EXPORT_SYMBOL(vMC_sensor_external_event_mask);
+EXPORT_SYMBOL(vMC_sensor_set_hysteresis);
+EXPORT_SYMBOL(vMC_sensor_set_threshold);
+EXPORT_SYMBOL(vMC_sensor_set_event_support);
+EXPORT_SYMBOL(vMC_register_containment_handler);
+EXPORT_SYMBOL(vMC_containment_handler);
+EXPORT_SYMBOL(register_vMC_stubs);
+#endif	/* CONFIG_IPMI_VMC_STUB || CONFIG_IPMI_VMC_STUB_MODULE */
diff --git a/include/linux/vmc.h b/include/linux/vmc.h
new file mode 100644
index 0000000..904043a
--- /dev/null
+++ b/include/linux/vmc.h
@@ -0,0 +1,989 @@
+/*
+ * Wind River IPMI virtual Management Controller interface
+ *
+ * The virtual Management Controller (vMC) implements a subset of an IPMI
+ * Baseboard Management Controller (BMC) in a kernel module. The vMC
+ * plugs into the OpenIPMI KLM which makes it look like a normal
+ * IPMI management controller to user applications. This file defines
+ * an API that fault handling code in the kernel can use to define
+ * IPMI sensors and generate IPMI events using the vMC, allowing the kernel
+ * to be monitored by IPMI compliant shelf managers and applications.
+ *
+ * The API is defined here instead of in the vMC module directory because the
+ * API is permanently stubbed into the kernel. This allows code to use the API,
+ * even if the vMC module has not been loaded. Initially, the stub version
+ * simply uses printk's, but, when the vMC module is loaded the stubs
+ * will be replaced with IPMI implementations of the API.
+ *
+ * Author: Wind River Systems
+ *         Chris Stone <christopher.stone@windriver.com>
+ *
+ * Copyright 2005 Wind River Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_VMC_H
+#define __LINUX_VMC_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/ipmi.h>
+
+#include <linux/version.h>
+
+#include <asm/byteorder.h>
+
+#if (defined(__BIG_ENDIAN_BITFIELD) && defined(__LITTLE_ENDIAN_BITFIELD))
+/* big and little endian defined */
+#error "Big and little endian defined!"
+#endif
+#if (!defined(__BIG_ENDIAN_BITFIELD) && !defined(__LITTLE_ENDIAN_BITFIELD))
+/* neither big nor little endian defined */
+#error "Neither Big nor little endian defined!"
+#endif
+
+#define MAX_SDR_DATA 64
+#define IPMI_EM_V15_VERSION 0x04
+typedef struct lmc_data_s lmc_data_t;
+
+/* Define common SDR header */
+typedef struct vMC_ipmi_sdr_header_s {
+
+	/* Sensor Record Header */
+	uint16_t record_id;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char sdr_minor_version:4;
+	unsigned char sdr_major_version:4;
+#else
+	unsigned char sdr_major_version:4;
+	unsigned char sdr_minor_version:4;
+#endif
+	unsigned char record_type;
+	uint8_t record_length;
+} __attribute__ ((packed)) vMC_ipmi_sdr_header_t;
+
+/* Type 0x01, Internal sensor with thresholds (body bytes) - Full sensor record
+ *    For the vMC, full sensor records can only be used for threshold sensors,
+ *    discrete sensors must use the compact sensor record. */
+#define IPMI_SDR_FULL_TYPE 			0x01
+typedef struct vMC_ipmi_sdr_full_s {
+
+	/* Sensor Key */
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char id:7;
+	unsigned char id_type:1;
+	unsigned char lun_channel:4;
+	unsigned char res1:2;
+	unsigned char sensor_owner_lun:2;
+#else
+	unsigned char id_type:1;
+	unsigned char id:7;
+	unsigned char sensor_owner_lun:2;
+	unsigned char res1:2;
+	unsigned char lun_channel:4;
+#endif
+	uint8_t sensor_number;
+
+	/* Body bytes */
+	unsigned char entity_ID;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char entity_instance_type:1;
+	unsigned char entity_instance_num:7;
+
+	unsigned char res2:1;
+	unsigned char init_scanning:1;
+	unsigned char init_event_messages:1;
+	unsigned char threshold_init_required:1;
+	unsigned char init_hysteresis:1;
+	unsigned char type_init_required:1;
+	unsigned char event_generation_enabled:1;
+	unsigned char sensor_scanning_enabled:1;
+
+	unsigned char sens_capable_ignore:1;
+	unsigned char sens_capable_auto_rearm:1;
+#define NO_HYSTERESIS			0x00
+#define HYSTERESIS_READABLE		0X01
+#define HYSTERESIS_READABLE_SETTABLE	0x02
+#define FIXED_UNREADABLE_HYSTERESIS	0x03
+	unsigned char sens_capable_hysteresis_support:2;
+#define NO_THRESHOLDS			0x00
+#define THRESHOLDS_READABLE		0X01
+#define THRESHOLDS_READABLE_SETTABLE	0x02
+#define FIXED_UNREADABLE_THRESHOLDS	0x03
+	unsigned char sens_capable_threshold_access:2;
+#define PER_THRESHOLD_SHUTDOWN		0x00
+#define ENTIRE_SENSOR_ONLY		0x01
+#define GLOBAL_DISABLE_ONLY		0x02
+#define NO_EVENTS_FROM_SENSOR		0x03
+	unsigned char sens_capable_event_msg_control:2;
+#else
+	unsigned char entity_instance_num:7;
+	unsigned char entity_instance_type:1;
+
+	unsigned char sensor_scanning_enabled:1;
+	unsigned char event_generation_enabled:1;
+	unsigned char type_init_required:1;
+	unsigned char init_hysteresis:1;
+	unsigned char threshold_init_required:1;
+	unsigned char init_event_messages:1;
+	unsigned char init_scanning:1;
+	unsigned char res2:1;
+#define PER_THRESHOLD_SHUTDOWN		0x00
+#define ENTIRE_SENSOR_ONLY		0x01
+#define GLOBAL_DISABLE_ONLY		0x02
+#define NO_EVENTS_FROM_SENSOR		0x03
+	unsigned char sens_capable_event_msg_control:2;
+#define NO_THRESHOLDS			0x00
+#define THRESHOLDS_READABLE		0X01
+#define THRESHOLDS_READABLE_SETTABLE	0x02
+#define FIXED_UNREADABLE_THRESHOLDS	0x03
+	unsigned char sens_capable_threshold_access:2;
+#define NO_HYSTERESIS			0x00
+#define HYSTERESIS_READABLE		0X01
+#define HYSTERESIS_READABLE_SETTABLE	0x02
+#define FIXED_UNREADABLE_HYSTERESIS	0x03
+	unsigned char sens_capable_hysteresis_support:2;
+	unsigned char sens_capable_auto_rearm:1;
+	unsigned char sens_capable_ignore:1;
+#endif
+	unsigned char sensor_type;
+	unsigned char event_reading_type_code;
+	uint16_t assertion_event_mask;
+	uint16_t deassertion_event_mask;
+
+#define READ_THRES_MASK_LOWER_NON_CRITICAL	0x01
+#define READ_THRES_MASK_LOWER_CRITICAL		0x02
+#define READ_THRES_MASK_LOWER_NON_RECOVERABLE	0x04
+#define READ_THRES_MASK_UPPER_NON_CRITICAL	0x08
+#define READ_THRES_MASK_UPPER_CRITICAL		0x10
+#define READ_THRES_MASK_UPPER_NON_RECOVERABLE	0x20
+	unsigned char read_thres_mask;
+
+#define SET_THRES_MASK_LOWER_NON_CRITICAL	0x01
+#define SET_THRES_MASK_LOWER_CRITICAL		0x02
+#define SET_THRES_MASK_LOWER_NON_RECOVERABLE	0x04
+#define SET_THRES_MASK_UPPER_NON_CRITICAL	0x08
+#define SET_THRES_MASK_UPPER_CRITICAL		0x10
+#define SET_THRES_MASK_UPPER_NON_RECOVERABLE	0x20
+	unsigned char set_thres_mask;
+
+#define FORMAT_UNSIGNED				0x00
+#define FORMAT_ONES_COMPLIMENT			0x01
+#define FORMAT_TWOS_COMPLIMENT			0x02
+#define FORMAT_RESERVED				0x03
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char sensor_units_1_raw_data_format:2;
+#define RATE_NONE			0x00
+#define RATE_US				0x01
+#define RATE_MS				0x02
+#define RATE_S				0x03
+#define RATE_MINUTE			0x04
+#define RATE_HOUR			0x05
+#define RATE_DAY			0x06
+#define RATE_RESERVED			0x07
+	unsigned char sensor_units_1_rate_unit:3;
+#define MODIFIER_NONE			0x00
+#define BASIC_UNIT_DIV_MODIFIER_UNIT	0x01
+#define	BASIC_UNIT_MUL_MODIFIER_UNIT	0x02
+#define RES2				0x03
+	unsigned char sensor_units_1_modifier_unit:2;
+	unsigned char sensor_units_1_percentage:1;
+#else
+	unsigned char sensor_units_1_percentage:1;
+#define MODIFIER_NONE							0x00
+#define BASIC_UNIT_DIV_MODIFIER_UNIT			0x01
+#define BASIC_UNIT_MUL_MODIFIER_UNIT			0x02
+#define RES2						0x03
+	unsigned char sensor_units_1_modifier_unit:2;
+#define RATE_NONE					0x00
+#define RATE_US						0x01
+#define RATE_MS						0x02
+#define RATE_S						0x03
+#define RATE_MINUTE					0x04
+#define RATE_HOUR					0x05
+#define RATE_DAY					0x06
+#define RATE_RESERVED					0x07
+
+	unsigned char sensor_units_1_rate_unit:3;
+
+	unsigned char sensor_units_1_raw_data_format:2;
+#endif
+	unsigned char sensor_units_2_base_unit;
+	unsigned char sensor_units_3_modifier_unit;
+
+#define LINEARIZATION_LINEAR			0x00
+#define LINEARIZATION_LN			0x01
+#define LINEARIZATION_LOG10			0x02
+#define LINEARIZATION_LOG2			0x03
+#define LINEARIZATION_E				0x04
+#define LINEARIZATION_EXP10			0x05
+#define LINEARIZATION_EXP2			0x06
+#define LINEARIZATION_1_DIV_X			0x07
+#define LINEARIZATION_SQR_X			0x08
+#define LINEARIZATION_CUBE_X			0x09
+#define LINEARIZATION_SQRT_X			0x0A
+#define LINEARIZATION_CUBE_MINUS_1_X		0x0B
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char res44:1;
+	unsigned char linearization:7;
+
+	char M_ls8bits:8;
+
+	char M_ms2bits:2;
+	unsigned char M_tolerance:6;
+
+	char B_ls8bits:8;
+
+	char B_ms2bits:2;
+	unsigned char accuracy_ls6bits:6;
+
+	unsigned char accuracy_ms4bits:4;
+	unsigned char accuracy_exp:2;
+	unsigned char res4:2;
+
+	char R_exp:4;
+	char B_exp:4;
+
+	unsigned char res5:5;
+	unsigned char normal_min_specified:1;
+	unsigned char normal_max_specified:1;
+	unsigned char nominal_reading_specified:1;
+#else
+	unsigned char linearization:7;
+	unsigned char res44:1;
+
+	char M_ls8bits:8;
+
+	unsigned char M_tolerance:6;
+	char M_ms2bits:2;
+
+	char B_ls8bits:8;
+
+	unsigned char accuracy_ls6bits:6;
+	char B_ms2bits:2;
+
+	unsigned char res4:2;
+	unsigned char accuracy_exp:2;
+	unsigned char accuracy_ms4bits:4;
+
+	char B_exp:4;
+	char R_exp:4;
+
+	unsigned char nominal_reading_specified:1;
+	unsigned char normal_max_specified:1;
+	unsigned char normal_min_specified:1;
+	unsigned char res5:5;
+#endif
+
+	uint8_t nominal_reading;
+	uint8_t normal_maximum;
+	uint8_t normal_minimum;
+	uint8_t sensor_maximum_reading;
+	uint8_t sensor_minimum_reading;
+
+#define UPPER_NON_RECOVERABLE	0
+#define UPPER_CRITICAL		1
+#define UPPER_NON_CRITICAL	2
+#define LOWER_NON_RECOVERABLE	3
+#define LOWER_CRITICAL		4
+#define LOWER_NON_CRITICAL	5
+	unsigned char thresholds[6];
+
+	uint8_t positive_hysteresis;
+	uint8_t negative_hysteresis;
+	unsigned char res6;
+	unsigned char res7;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char ipmb_upper_non_recoverable_enable:1;
+	unsigned char ipmb_upper_critical_enable:1;
+	unsigned char ipmb_upper_non_critical_enable:1;
+	unsigned char ipmb_lower_non_recoverable_enable:1;
+	unsigned char ipmb_lower_critical_enable:1;
+	unsigned char ipmb_lower_non_critical_enable:1;
+	unsigned char containment_enable:1;
+	unsigned char bmc_enable:1;
+
+	unsigned char id_string_type_code:2;
+	unsigned char id_string_num_bytes:6;
+#else
+	unsigned char bmc_enable:1;
+	unsigned char containment_enable:1;
+
+	unsigned char ipmb_lower_non_critical_enable:1;
+
+	unsigned char ipmb_lower_critical_enable:1;
+
+	unsigned char ipmb_lower_non_recoverable_enable:1;
+
+	unsigned char ipmb_upper_non_critical_enable:1;
+
+	unsigned char ipmb_upper_critical_enable:1;
+
+	unsigned char ipmb_upper_non_recoverable_enable:1;
+
+	unsigned char id_string_num_bytes:6;
+	unsigned char id_string_type_code:2;
+#endif
+	unsigned char id_string[16];
+} __attribute__ ((packed)) vMC_ipmi_sdr_full_t;
+
+	/* entityIdent */
+typedef struct vMC_entityIdent_s {
+	unsigned char entityID;
+	unsigned char entityInstance;
+} vMC_entityIdent_t;
+
+	/* Type 0x08, Entity Association Record */
+#define IPMI_SDR_ENTITY_ASSOC_TYPE		0x08
+typedef struct vMC_ipmi_sdr_entity_assoc_s {
+	vMC_entityIdent_t container;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char range:1;
+	unsigned char record_link:1;
+	unsigned char presence:1;
+	unsigned char reserved1:5;
+#else
+	unsigned char reserved1:5;
+	unsigned char presence:1;
+	unsigned char record_link:1;
+	unsigned char range:1;
+#endif
+	vMC_entityIdent_t contained[4];
+} __attribute__ ((packed)) vMC_ipmi_sdr_entity_assoc_t;
+
+	/* Type 0x09, Device-relative Entity Association Record */
+#define IPMI_SDR_DEV_ENTITY_ASSOC_TYPE 			0x09
+typedef struct vMC_ipmi_sdr_dev_entity_assoc_s {
+	vMC_entityIdent_t container;
+
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char container_addr:7;
+	unsigned char reserved1:1;
+
+	unsigned char container_channel:4;
+	unsigned char reserved2:4;
+
+	unsigned char range:1;
+	unsigned char record_link:1;
+	unsigned char presence:1;
+	unsigned char reserved3:5;
+#else
+	unsigned char reserved1:1;
+	unsigned char container_addr:7;
+
+	unsigned char reserved2:4;
+	unsigned char container_channel:4;
+	unsigned char reserved3:5;
+	unsigned char presence:1;
+	unsigned char record_link:1;
+	unsigned char range:1;
+#endif
+	vMC_entityIdent_t contained[4];
+	unsigned char reserved4[6];
+} __attribute__ ((packed)) vMC_ipmi_sdr_dev_entity_assoc_t;
+
+	/* Type 0x10, IPMB Device Locator Record */
+#define IPMI_SDR_DEV_LOCATOR_TYPE 			0x10
+typedef struct vMC_ipmi_sdr_dev_locator_s {
+
+	/* Sensor Key */
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char dev_access_slave_address:7;
+	unsigned char reserved1:1;
+
+	unsigned char i2c_slave_address:7;
+	unsigned char chan_num_hi:1;
+
+	unsigned char chan_num_lo:3;
+	unsigned char master_lun:2;
+#define BUS_TYPE_IPMB				0x00
+#define BUS_TYPE_PRIVATE_I2C			0x01
+	unsigned char private_bus_id_or_lun:3;
+
+	/* Body bytes */
+	unsigned char reserved2:5;
+	unsigned char address_span:3;
+#else
+	unsigned char reserved1:1;
+	unsigned char dev_access_slave_address:7;
+
+	unsigned char chan_num_hi:1;
+	unsigned char i2c_slave_address:7;
+
+#define BUS_TYPE_IPMB		0x00
+#define BUS_TYPE_PRIVATE_I2C	0x01
+	unsigned char private_bus_id_or_lun:3;
+	unsigned char master_lun:2;
+	unsigned char chan_num_lo:3;
+	/* Body bytes */
+	unsigned char address_span:3;
+	unsigned char reserved2:5;
+#endif
+	unsigned char reserved3;
+
+	unsigned char device_type;
+	unsigned char device_type_modifier;
+	unsigned char entity_id;
+	unsigned char oem;
+
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char id_string_type_code:2;
+	unsigned char id_string_num_bytes:6;
+#else
+	unsigned char id_string_num_bytes:6;
+	unsigned char id_string_type_code:2;
+#endif
+
+	unsigned char id_string[16];
+} __attribute__ ((packed)) vMC_ipmi_sdr_dev_locator_t;
+
+	/* Type 0x12h Management Controller Device Locator Record */
+#define IPMI_SDR_MC_LOCATOR_TYPE 			0x12
+typedef struct vMC_ipmi_sdr_mc_locator_s {
+	/* Record Key */
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char dev_slave_addr:7;
+	unsigned char reserved1:1;
+
+	unsigned char reserved2:4;
+	unsigned char channel:4;
+
+	/* Body Bytes: */
+	/* Power State notification */
+	unsigned char sys_power_state:1;
+	unsigned char dev_power_state:1;
+	unsigned char reserved3:2;
+	/* global initialization */
+	unsigned char log_init_errors:1;
+	unsigned char log_agent_errors:1;
+	unsigned char global_enable:2;
+#define ENABLE_EVENT_GENERATION		0x00
+#define DISABLE_EVENT_GENERATION	0x01
+#define DISABLE_INITIALIZATION		0x02
+
+	/* Device capabilies */
+	unsigned char chassis:1;
+	unsigned char bridge:1;
+	unsigned char IPMB_event_generator:1;
+	unsigned char IPMB_event_receiver:1;
+	unsigned char FRU_device:1;
+	unsigned char SEL_device:1;
+	unsigned char SDR_device:1;
+	unsigned char sensor_device:1;
+#else
+	unsigned char reserved1:1;
+	unsigned char dev_slave_addr:7;
+
+	unsigned char channel:4;
+	unsigned char reserved2:4;
+
+	/* Body Bytes: */
+	/*  global initialization */
+	unsigned char global_enable:2;
+	unsigned char log_agent_errors:1;
+	unsigned char log_init_errors:1;
+	/* Power State notification */
+	unsigned char reserved3:2;
+	unsigned char dev_power_state:1;
+	unsigned char sys_power_state:1;
+#define ENABLE_EVENT_GENERATION		0x00
+#define DISABLE_EVENT_GENERATION	0x01
+#define DISABLE_INITIALIZATION		0x02
+
+	/* Device capabilies */
+	unsigned char sensor_device:1;
+	unsigned char SDR_device:1;
+	unsigned char SEL_device:1;
+	unsigned char FRU_device:1;
+	unsigned char IPMB_event_receiver:1;
+	unsigned char IPMB_event_generator:1;
+	unsigned char bridge:1;
+	unsigned char chassis:1;
+#endif
+	/* Reserved */
+	unsigned char reserved4[3];
+	/* Entity ID */
+	unsigned char entity_id;
+	/* Entity instance */
+	unsigned char entity_num;
+	/* OEM byte */
+	unsigned char oem;
+	/* Device ID type/length */
+	unsigned char device_type_length_code;
+	/* Device ID string */
+	unsigned char device_id[16];
+} __attribute__ ((packed)) vMC_ipmi_sdr_mc_locator_t;
+
+	/* Type 0xC0h, OEM Record */
+#define IPMI_SDR_OEM_TYPE 			0xC0
+typedef struct vMC_ipmi_sdr_oem_s {
+
+	/* Body Bytes */
+	unsigned char oem_data[MAX_SDR_DATA];
+} vMC_ipmi_sdr_oem_t;
+
+#define CMD_GET_SDR_REPOSITORY_INFO		0x20
+#define CMD_GET_SDR_REPOSITORY_ALLOC_INFO	0x21
+#define CMD_RESERVE_SDR_REPOSITORY		0x22
+#define CMD_GET_SDR				0x23
+#define CMD_GET_SDR_REPOSITORY_TIME		0x28
+#define CMD_GET_SENSOR_READING			0x2D
+
+/* Generic SDR. */
+typedef struct vMC_ipmi_sdr_s {
+
+	/* Sensor Record Header */
+	vMC_ipmi_sdr_header_t sdr_hdr;
+
+	union {
+		unsigned char data[MAX_SDR_DATA];
+		vMC_ipmi_sdr_full_t sdr_full;
+		vMC_ipmi_sdr_entity_assoc_t sdr_entity_assoc;
+		vMC_ipmi_sdr_dev_entity_assoc_t sdr_entity_dev_assoc;
+		vMC_ipmi_sdr_dev_locator_t sdr_dev_locator;
+		vMC_ipmi_sdr_mc_locator_t sdr_mc_locator;
+		vMC_ipmi_sdr_oem_t sdr_oem;
+	} __attribute__ ((packed)) sdr_body;
+	struct list_head list;	/* for internal use - do not touch */
+	lmc_data_t *mc;		/* for internal use - do not touch */
+} __attribute__ ((packed)) vMC_ipmi_sdr_t;
+
+/*
+ *  System Event Log Data Structures
+ */
+
+#define SENSOR_CLASS_UNKNOWN	0x00
+#define SENSOR_CLASS_DIGITAL	0x01
+#define SENSOR_CLASS_THRESHOLD	0x02
+#define SENSOR_CLASS_DISCRETE	0x03
+
+typedef struct vMC_ipmi_sel_threshold_event_s {
+	/* event data byte 1 */
+#define THRES_EVENT_DATA_BYTE_2_UNSPECIFIED		0x00
+#define THRES_EVENT_DATA_BYTE_2_TRIGGER_READING		0x01
+#define THRES_EVENT_DATA_BYTE_2_OEM_CODE		0x02
+#define THRES_EVENT_DATA_BYTE_2_SENS_SPECIFIC		0x03
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char byte_2_contents:2;
+#define THRES_EVENT_DATA_BYTE_3_UNSPECIFIED		0x00
+#define THRES_EVENT_DATA_BYTE_3_TRIGGER_THRES_VALUE	0x01
+#define THRES_EVENT_DATA_BYTE_3_OEM_CODE		0x02
+#define THRES_EVENT_DATA_BYTE_3_SENS_SPECIFIC		0x03
+	unsigned char byte_3_contents:2;
+	unsigned char event_trigger_offset:4;
+#else
+	unsigned char event_trigger_offset:4;
+#define THRES_EVENT_DATA_BYTE_2_UNSPECIFIED		0x00
+#define THRES_EVENT_DATA_BYTE_2_TRIGGER_READING		0x01
+#define THRES_EVENT_DATA_BYTE_2_OEM_CODE		0x02
+#define THRES_EVENT_DATA_BYTE_2_SENS_SPECIFIC		0x03
+	unsigned char byte_3_contents:2;
+	unsigned char byte_2_contents:2;
+#endif
+	/* event data byte 2 */
+	unsigned char trigger_reading;
+
+	/* event data byte 3 */
+	unsigned char threshold_value2;
+} __attribute__ ((packed)) vMC_ipmi_sel_threshold_event_t;
+
+typedef struct vMC_ipmi_sel_digital_event_s {
+	/* event data byte 1 */
+#define DIG_EVENT_DATA_BYTE_2_UNSPECIFIED	0x00
+#define DIG_EVENT_DATA_BYTE_2_PREV_STATE	0x01
+#define DIG_EVENT_DATA_BYTE_2_OEM_CODE		0x02
+#define DIG_EVENT_DATA_BYTE_2_SENS_SPEC		0x03
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char byte_2_contents:2;
+#define DIG_EVENT_DATA_BYTE_3_UNSPECIFIED	0x00
+#define DIG_EVENT_DATA_BYTE_3_PREV_STATE	0x01
+#define DIG_EVENT_DATA_BYTE_3_OEM_CODE		0x02
+#define DIG_EVENT_DATA_BYTE_3_SENS_SPEC		0x03
+	unsigned char byte_3_contents:2;
+	unsigned char digital_event_offset:4;
+
+	/* event data byte 2 */
+	unsigned char reserved3:4;
+	unsigned char sev_event_trig_offset:4;
+#else
+	unsigned char digital_event_offset:4;
+#define DIG_EVENT_DATA_BYTE_3_UNSPECIFIED	0x00
+#define DIG_EVENT_DATA_BYTE_3_PREV_STATE	0x01
+#define DIG_EVENT_DATA_BYTE_3_OEM_CODE		0x02
+#define DIG_EVENT_DATA_BYTE_3_SENS_SPEC		0x03
+	unsigned char byte_3_contents:2;
+	unsigned char byte_2_contents:2;
+
+	/* event data byte 2 */
+	unsigned char sev_event_trig_offset:4;
+	unsigned char reserved3:4;
+#endif
+	/* event data byte 3 */
+	unsigned char oem_code;
+} __attribute__ ((packed)) vMC_ipmi_sel_digital_event_t;
+
+typedef struct vMC_ipmi_sel_discrete_event_s {
+	/* event data byte 1 */
+#define DIS_EVENT_DATA_BYTE_2_UNSPECIFIED		0x00
+#define DIS_EVENT_DATA_BYTE_2_PREV_STATE_SEVERITY	0x01
+#define DIS_EVENT_DATA_BYTE_2_OEM_CODE			0x02
+#define DIS_EVENT_DATA_BYTE_2_SENS_SPEC			0x03
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char byte_2_contents:2;
+#define DIS_EVENT_DATA_BYTE_3_UNSPECIFIED		0x00
+#define DIS_EVENT_DATA_BYTE_3_RES			0x01
+#define DIS_EVENT_DATA_BYTE_3_OEM_CODE			0x02
+#define DIS_EVENT_DATA_BYTE_3_RESERVED			0x03
+	unsigned char byte_3_contents:2;
+	unsigned char event_trigger_offset:4;
+
+	/* event data byte 2 */
+	unsigned char sev_event_trig_offset:4;
+	unsigned char prev_event_offset:4;
+#else
+	unsigned char event_trigger_offset:4;
+#define DIS_EVENT_DATA_BYTE_3_UNSPECIFIED		0x00
+#define DIS_EVENT_DATA_BYTE_3_RES			0x01
+#define DIS_EVENT_DATA_BYTE_3_OEM_CODE			0x02
+#define DIS_EVENT_DATA_BYTE_3_RESERVED			0x03
+	unsigned char byte_3_contents:2;
+	unsigned char byte_2_contents:2;
+
+	/* event data byte 2 */
+	unsigned char prev_event_offset:4;
+	unsigned char sev_event_trig_offset:4;
+#endif
+	/* event data byte 3 */
+	unsigned char oem_code;
+} __attribute__ ((packed)) vMC_ipmi_sel_discrete_event_t;
+
+/*fault handler extended data*/
+#define MAX_REG_NAME_SIZE	28
+#define MAX_FAULT_RECORD_SIZE	10
+
+typedef struct fault_record_data_s {
+	char reg_name[MAX_REG_NAME_SIZE];
+	u32 data;
+} fault_record_data_t;
+
+typedef struct fault_record_s {
+	int fault_type;
+	fault_record_data_t fault_record_data[MAX_FAULT_RECORD_SIZE];
+} fault_record_t;
+
+/* Generic SEL record */
+typedef struct vMC_ipmi_sel_record_s {
+	/* IPMI Event record */
+	uint16_t recid;
+	unsigned char type;
+	unsigned int timestamp;
+
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char id_ipmb:7;
+	unsigned char id_type:1;
+
+	unsigned char chan:4;
+	unsigned char res:2;
+	unsigned char ipmb_lun:2;
+
+	unsigned char evmrev;
+	unsigned char sensortype;
+	unsigned char sensornum;
+	unsigned char event_dir:1;
+	unsigned char event_type:7;
+#else
+	unsigned char id_type:1;
+	unsigned char id_ipmb:7;
+
+	unsigned char ipmb_lun:2;
+	unsigned char res:2;
+	unsigned char chan:4;
+
+	unsigned char evmrev;
+	unsigned char sensortype;
+	unsigned char sensornum;
+	unsigned char event_type:7;
+	unsigned char event_dir:1;
+#endif
+	union __attribute__ ((packed)) {
+		unsigned char event_data[3];
+		vMC_ipmi_sel_discrete_event_t sel_discrete_event;
+		vMC_ipmi_sel_digital_event_t sel_digital_event;
+		vMC_ipmi_sel_threshold_event_t sel_threshold_event;
+	} sel_event_data;
+
+	/* OEM extension to IPMI event record. The first 16 bytes of this
+	 * structure is the IPMI standard definition of an event log
+	 * record. The first 16 bytes are the only bytes that standard IPMI
+	 * applications will ever see. However, for our own internal purposes
+	 * we allow extra data to be stored into the vMC event log. This data
+	 * is defined below. */
+	struct list_head list;	/* for internal use - do not touch */
+	lmc_data_t *mc;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	unsigned char sm_sent:1;
+	unsigned char res2:7;
+#else
+	unsigned char res2:7;
+	unsigned char sm_sent:1;
+#endif
+	unsigned int extended_event_length;	/* user defined data length */
+	void *extended_event_data;	/* user defined data */
+} __attribute__ ((packed)) vMC_ipmi_sel_record_t;
+
+/* SEL Type 0x02: system; type 0xC0: timestamped OEM Record */
+#define IPMI_SEL_SYS_TYPE	0x02
+#define IPMI_SEL_OEM_TYPE	0xC0
+
+/*
+ *  Other Data Structures
+ */
+
+/* Sensor identification */
+typedef struct vMC_ipmi_sensor_ident_s {
+	unsigned char sensor_mc;/* ipmb address of management controller */
+	unsigned char sensor_lun;
+	unsigned char sensor_num;
+} vMC_ipmi_sensor_ident_t;
+
+/* SEL Type 0x02: system; type 0xC0: timestamped OEM Record */
+#define IPMI_SEL_SYS_TYPE	0x02
+#define IPMI_SEL_OEM_TYPE	0xC0
+
+/*
+ * Virtual Management Controller Function API
+ */
+
+/* vMC_alloc_sel_record
+ *       Allocate storage for a vMC_ipmi_sel_record_t type. If
+ *       extended_data_length is greater than zero, then space of the specified
+ *       size is allocated for user defined data (pointed to by
+ *       extended_event_data). If mc_ipmb is not 0x00, then the event log
+ *       belongs to the mc at the specified ipmb address, otherwise the event
+ *       log belongs to the default mc. If the vMC module is configured with
+ *       IPMI_VMC_SEL_EXTENDED_SIZE > 0 then the extended_data_length can not
+ *       exceed the value of IPMI_VMC_SEL_EXTENDED_SIZE. Also when
+ *       IPMI_VMC_SEL_EXTENDED_SIZE is >0 cache allocation is used making it
+ *       efficient enough to be called from top halves. Returns NULL on error,
+ *       with rc updated to contain error code. */
+extern vMC_ipmi_sel_record_t *(*vMC_alloc_sel_record) (unsigned int
+						       extended_data_length,
+						       unsigned char mc_ipmb,
+						       int *rc);
+
+/* vMC_alloc_sdr_record
+ *   Allocate storage for a vMC_ipmi_sdr_t type. If mc_ipmb is not 0x00, then
+ *   the sdr record belongs to the mc at the specified ipmb address, otherwise
+ *   the sdr record belongs to the default mc. Returns NULL on error with rc
+ *   updated to contain error code. */
+extern vMC_ipmi_sdr_t *(*vMC_alloc_sdr_record) (unsigned char mc_ipmb,
+						unsigned char record_type,
+						int *rc);
+
+/* vMC_sel_add
+ *   Add the given event to the SEL of the vMC.  This command will also send the
+ *   IPMI portion of the event to the BMC via the IPMB bus if configured. */
+extern int (*vMC_sel_add) (vMC_ipmi_sel_record_t *vMC_sel_record);
+
+/*   Same as above, but for use when the caller is in a machine-check state.
+ *   In other words, it has possibly interrupted other VMC code, thus the
+ *   concurrency issues are more stringent. */
+extern int (*vMC_sel_add_mcsafe) (vMC_ipmi_sel_record_t *vMC_sel_record);
+
+/* vMC_device_sdr_add
+ *   Add the given SDR to the Device SDR Repository of the vMC. */
+extern int (*vMC_device_sdr_add) (vMC_ipmi_sdr_t *vMC_sdr_record);
+
+/* vMC_device_sdr_delete
+ *   Delete the given SDR from the Device SDR Repository of the vMC. */
+extern int (*vMC_device_sdr_delete) (vMC_ipmi_sensor_ident_t *sensor_ident);
+
+/* vMC_sensor_get_threshold_value
+ *   Read current value of a threshold sensor */
+extern int (*vMC_sensor_get_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				    unsigned int *val);
+
+/* vMC_sensor_set_bit
+ *   Only for discrete sensors.  The bit identified by bit is set to 0 or 1
+ *   depending on the contents of val.  If a sensor bit changes value and event
+ *   notification is enabled a sensor event will be generated.
+ *   vMC_sel_record should contain a pre-allocated SEL record with the extended
+ *   data filled in and any OEM event bytes filled in. vMC_sel_record may be
+ *   NULL, in which case the vMC will allocate a default SEL record if an
+ *   event is generated. If vMC_sel_record is not NULL, but no event is
+ *   generated, the vMC will free the record. */
+extern int (*vMC_sensor_set_bit) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				  unsigned int bit, unsigned int val,
+				  vMC_ipmi_sel_record_t *vMC_sel_record);
+
+/* vMC_sensor_set_value
+ *   Only for threshold sensors.  Set the sensor to the given value. An event
+ *   will be generated if the sensor crosses an enabled event threshold.
+ *   vMC_sel_record should contain a pre-allocated SEL record with the extended
+ *   data filled in and any OEM event bytes filled in. vMC_sel_record may be
+ *   NULL, in which case the vMC will allocate a default SEL record if an
+ *   event is generated. If vMC_sel_record is not NULL, but no event is
+ *   generated, the vMC will free the record. */
+extern int (*vMC_sensor_set_value) (vMC_ipmi_sensor_ident_t *sensor_ident,
+				    unsigned char value,
+				    vMC_ipmi_sel_record_t *vMC_sel_record);
+
+/* vMC_sensor_increment_value
+ *   Only for threshold sensors. Increment the sensor value by value. An event
+ *   will be generated if the sensor crosses an enabled event threshold.
+ *   vMC_sel_record should contain a pre-allocated SEL record with the extended
+ *   data filled in and any OEM event bytes filled in. vMC_sel_record may be
+ *   NULL, in which case the vMC will allocate a default SEL record if an event
+ *   is generated. If vMC_sel_record is not NULL, but no event is generated,
+ *   the vMC will free the record. */
+extern int (*vMC_sensor_increment_value) (vMC_ipmi_sensor_ident_t *
+					  sensor_ident, unsigned char value,
+					  vMC_ipmi_sel_record_t *
+					  vMC_sel_record);
+
+/* vMC_sensor_increment_value_mcsafe
+ *   Same as above, but for use when the caller is in a machine-check state.
+ *   In other words, it has possibly interrupted other VMC code, thus the
+ *   concurrency issues are more stringent. */
+extern int (*vMC_sensor_increment_value_mcsafe) (vMC_ipmi_sensor_ident_t *
+						 sensor_ident,
+						 unsigned char value,
+						 vMC_ipmi_sel_record_t *
+						 vMC_sel_record);
+
+/* vMC_sensor_decrement_value
+ *   Only for threshold sensors. Decrement the sensor value by value. An event
+ *   will be generated if the sensor crosses an enabled event threshold.
+ *   vMC_sel_record should contain a pre-allocated SEL record with the extended
+ *   data filled in and any OEM event bytes filled in. vMC_sel_record may be
+ *   NULL, in which case the vMC will allocate a default SEL record if an event
+ *   is generated. If vMC_sel_record is not NULL, but no event is generated, the
+ *   vMC will free the record. */
+extern int (*vMC_sensor_decrement_value) (vMC_ipmi_sensor_ident_t *
+					  sensor_ident, unsigned char value,
+					  vMC_ipmi_sel_record_t *
+					  vMC_sel_record);
+
+/* vMC_sensor_external_event_mask
+ *   This function masks event generation for the sensor over a physical IPMB
+ *   bus. The six least significant bits of mask correspond to the six
+ *   threshold levels. If a bit is set to one, corresponding events will be
+ *   sent on the IPMB bus, otherwise they will not. */
+extern int (*vMC_sensor_external_event_mask) (vMC_ipmi_sensor_ident_t *
+					      sensor_ident, unsigned char mask);
+
+/* vMC_sensor_set_hysteresis
+ *   Only for threshold sensors.  Set the hysteresis for the sensor.
+ *   <support> is the standard values from the SDR, which are:
+ *      0 - NO_HYSTERESIS
+ *      1 - HYSTERESIS_READABLE
+ *      2 - HYSTERESIS_READABLE_SETTABLE
+ *      3 - FIXED_UNREADABLE_HYSTERESIS
+ *   <pos> is the positive hysteresis value, and <neg> is the negative one */
+extern int (*vMC_sensor_set_hysteresis) (vMC_ipmi_sensor_ident_t *sensor_ident,
+					 unsigned char support,
+					 unsigned char pos, unsigned char neg);
+
+/* vMC_sensor_set_threshold
+ *   Only for threshold sensors. This sets the threshold support type, supported
+ *   thresholds, and initial values */
+extern int (*vMC_sensor_set_threshold) (vMC_ipmi_sensor_ident_t *sensor_ident,
+					unsigned char support,
+					unsigned char readmask,
+					unsigned char setmask,
+					unsigned char *val);
+
+/* vMC_sensor_set_event_support
+ *   Sets the event support for the sensors */
+extern int (*vMC_sensor_set_event_support) (vMC_ipmi_sensor_ident_t *
+					    sensor_ident, unsigned char support,
+					    unsigned int assertions_supported,
+					    unsigned int
+					    deassertions_supported);
+
+/*
+ * vMC_register_containment_handler
+ *    Registers containment handlers to be called when events are generated.
+ */
+#define SEVERITY_UPPER_NON_RECOVERABLE_GOING_HIGH	11
+#define SEVERITY_UPPER_NON_RECOVERABLE_GOING_LOW	10
+#define SEVERITY_UPPER_CRITICAL_GOING_HIGH		9
+#define SEVERITY_UPPER_CRITICAL_GOING_LOW		8
+#define SEVERITY_UPPER_NON_CRITICAL_GOING_HIGH		7
+#define SEVERITY_UPPER_NON_CRITICAL_GOING_LOW		6
+#define SEVERITY_LOWER_NON_RECOVERABLE_GOING_HIGH	5
+#define SEVERITY_LOWER_NON_RECOVERABLE_GOING_LOW	4
+#define SEVERITY_LOWER_CRITICAL_GOING_HIGH		3
+#define SEVERITY_LOWER_CRITICAL_GOING_LOW		2
+#define SEVERITY_LOWER_NON_CRITICAL_GOING_HIGH		1
+#define SEVERITY_LOWER_NON_CRITICAL_GOING_LOW		0
+extern void vMC_register_containment_handler(void (*handler) (void),
+					     unsigned int severity);
+
+/*
+ * Virtual Management Controller Error Responses
+ */
+#define VMC_NO_ERROR			0
+#define VMC_INVALID_RECORD_TYPE		1
+#define VMC_INVALID_EVENT_MSG_FORMAT	2
+#define VMC_INVALID_SENSOR_TYPE		3
+#define VMC_INVALID_SENSOR_NUMBER	4
+#define VMC_INVALID_EVENT_TYPE		5
+#define VMC_INVALID_OEM_ENTITY_ID	6
+#define VMC_INVALID_SENSOR_CAPABILITIES	7
+#define VMC_INVALID_MC			8
+#define VMC_INVALID_LUN			9
+#define VMC_INVALID_OWNER_ID		10
+#define VMC_INVALID_SUPPORT_TYPE	11
+#define VMC_INVALID_THRESHOLD_VALUES	12
+#define VMC_MODULE_NOT_LOADED		13
+#define VMC_INVALID_ENTITY_ID		14
+#define VMC_INVALID_ENTITY_INSTANCE	15
+#define VMC_INVALID_ASSOCIATION		16
+#define VMC_ENOMEM			17
+#define VMC_ENOSYS			18
+#define VMC_EINVAL			19
+#define VMC_ENOSPC			20
+#define VMC_EAGAIN			21
+#define VMC_LOCKED			22
+#define VMC_INVALID_RATE_SENSOR		23
+#define VMC_TOO_MANY_RATE_SENSORS	24
+
+#define BIT(nr)    (1UL << (nr))
+#define DEFAULT_ASSERTION_EVENT_MASK \
+    (BIT(SEVERITY_UPPER_NON_RECOVERABLE_GOING_HIGH)| \
+    BIT(SEVERITY_UPPER_CRITICAL_GOING_HIGH)| \
+    BIT(SEVERITY_UPPER_NON_CRITICAL_GOING_HIGH)| \
+    BIT(SEVERITY_LOWER_NON_RECOVERABLE_GOING_LOW)| \
+    BIT(SEVERITY_LOWER_CRITICAL_GOING_LOW)| \
+    BIT(SEVERITY_LOWER_NON_CRITICAL_GOING_LOW))
+
+#define DEFAULT_DEASSERTION_EVENT_MASK \
+    (BIT(SEVERITY_UPPER_NON_RECOVERABLE_GOING_HIGH)| \
+    BIT(SEVERITY_UPPER_CRITICAL_GOING_HIGH)| \
+    BIT(SEVERITY_UPPER_NON_CRITICAL_GOING_HIGH)| \
+    BIT(SEVERITY_LOWER_NON_RECOVERABLE_GOING_LOW)| \
+    BIT(SEVERITY_LOWER_CRITICAL_GOING_LOW)| \
+    BIT(SEVERITY_LOWER_NON_CRITICAL_GOING_LOW))
+
+#endif	/* __LINUX_VMC_H */
-- 
1.6.5.2

