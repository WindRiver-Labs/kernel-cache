From 964972dc8bf2ea08d7d213f1bf6ac666a5419735 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Thu, 6 May 2010 23:31:22 -0700
Subject: [PATCH 4/5] vMC: Enhancement

The following enhancement for vMC was added.

1.  Register PMEM region write handler

    pmem_region_get() should be called directly rather than
    overloading pmem_region_reg() again if another pmem_handle
    needs to be installed for one already registered PMEM region.

    And pmem_handle.offset should be set by the PMEM client before
    the first access and therefore it should not be initalized at
    registration.

    In addition, reading a pmem_log_desc_index structure for
    storing logs of varying sizes is irrelevant to vMC's PMEM
    region for fixed size SELs and should not be done here.

2.  Get the exact number of SELs

    When PMEM is used to store fixed-size SEL, the number of SEL
    that an region area for a specified CPU could actually
    accommodate may be slightly different from the number requested
    by user due to partition / block size alignment to the page
    size. Consequently the SEL max_entries counter should be
    adjusted so that handler for the "Get SEL Entry" command could
    have correct semantics.

3.  IPMI command handlers fix

    The handlers for the "Get SEL Allocation / Info" commands
    should differentiate the cases when PMEM is used or not;

    The handler for the "Clear SEL" command should kick off SEL
    clearance when the specified operation code is 0xAA rather
    than 0x00;

    vMC's SEL "last_add_time" timestamps should be updated
    after a SEL is generated.

4.  Delete vMC's sensor_timer when deleting vMC module before
    EDAC module.

    If the leak rate of the SDRs that EDAC registered to vMC is
    other than RATE_NONE, vMC driver would register a kernel timer
    to check their rates periodically. This kernel timer would be
    deleted when all EDAC SDRs are unregistered from vMC.

    However, if the vMC module is removed before that of EDAC,
    this kernel timer must be deliberately deleted along with all
    EDAC SDRs so that we won't leave a pending timer while the
    vMC module is to be removed.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/char/ipmi/vmc_emu.c |   96 +++++++++++++++++++++++++++++++++++--------
 1 files changed, 78 insertions(+), 18 deletions(-)

diff --git a/drivers/char/ipmi/vmc_emu.c b/drivers/char/ipmi/vmc_emu.c
index 810af45..b60f34c 100644
--- a/drivers/char/ipmi/vmc_emu.c
+++ b/drivers/char/ipmi/vmc_emu.c
@@ -261,7 +261,7 @@ int ipmi_mc_enable_sel(lmc_data_t *mc, int max_entries, unsigned char flags)
 	char reg_name[18];
 	char name_region[] = "vMC SEL Entries";
 	char name_partition[] = "vMC SEL Record";
-	char buffer1[sizeof(struct pmem_log_desc_index)];
+	int region_size_per_cpu, actual_num;
 #endif
 
 	if (!mc)
@@ -296,17 +296,31 @@ int ipmi_mc_enable_sel(lmc_data_t *mc, int max_entries, unsigned char flags)
 	if (pmem_region_reg(partition_handle[entrynum],
 			    &sel_region[entrynum],
 			    &region_read_handle[entrynum]) < 0) {
-		printk(KERN_ERR "Unable to get general logs region");
+		printk(KERN_ERR "Unable to register vMC region\n");
 		return -1;
 	}
-	pmem_read_data(region_read_handle[entrynum],
-		       buffer1, sizeof(struct pmem_log_desc_index));
-	if (pmem_region_reg(partition_handle[entrynum],
-			    &sel_region[entrynum],
+	if (pmem_region_get(partition_handle[entrynum],
+			    sel_region[entrynum].desc,
+			    sel_region[entrynum].block_id,
 			    &region_write_handle[entrynum]) < 0) {
-		printk(KERN_ERR "Unable to get general logs region");
+		printk(KERN_ERR "Unable to install write handler for vMC region\n");
 		return -1;
 	}
+
+	region_size_per_cpu =
+		pmem_get_region_size_per_cpu(region_read_handle[entrynum]);
+	if (region_size_per_cpu > 0) {
+		actual_num = region_size_per_cpu /
+				sel_region[entrynum].fixed_size;
+		if (actual_num != max_entries) {
+			max_entries = actual_num;
+			printk(KERN_INFO
+				"%s, actual max_entries is %d "
+				"per cpu region\n",
+				sel_region[entrynum].desc, max_entries);
+		}
+	}
+
 	entrynum++;
 #endif
 
@@ -674,6 +688,28 @@ static int _ipmi_mc_add_to_sel(lmc_data_t *mc,
  * IPMI SEL message handler functions:
  */
 
+static int get_log_entries(lmc_data_t *mc)
+{
+	int log_num = atomic_read(&mc->sel.count);
+
+#ifdef CONFIG_IPMI_VMC_ENABLE_PMEM
+	if (log_num > mc->sel.max_count)
+		log_num = mc->sel.max_count;
+#endif
+
+	return log_num;
+}
+
+static int get_free_space(lmc_data_t *mc)
+{
+#ifdef CONFIG_IPMI_VMC_ENABLE_PMEM
+	return mc->sel.max_count * PMEM_SEL_DATA_LENGTH;
+#else
+	return (mc->sel.max_count - atomic_read(&mc->sel.count)) *
+			PMEM_SEL_DATA_LENGTH;
+#endif
+}
+
 static void handle_get_sel_info(lmc_data_t *mc, unsigned char *rdata,
 				unsigned int *rdata_len)
 {
@@ -688,12 +724,17 @@ static void handle_get_sel_info(lmc_data_t *mc, unsigned char *rdata,
 	}
 
 	memset(rdata, 0, GETSEL_RPLY_LEN);
+	/* SEL version */
 	rdata[1] = SDR_VER_IPMI15;
-	ipmi_set_uint16(rdata + 2, atomic_read(&mc->sel.count));
-	ipmi_set_uint16(rdata + 4,
-			(mc->sel.max_count - atomic_read(&mc->sel.count)) * 16);
+	/* Number of log entries */
+	ipmi_set_uint16(rdata + 2, get_log_entries(mc));
+	/* Free space in bytes */
+	ipmi_set_uint16(rdata + 4, get_free_space(mc));
+	/* Most recent addition time */
 	ipmi_set_uint32(rdata + 6, mc->sel.last_add_time);
+	/* Most recent erase time */
 	ipmi_set_uint32(rdata + 10, mc->sel.last_erase_time);
+	/* Operation support */
 	rdata[14] = mc->sel.flags;
 	*rdata_len = GETSEL_RPLY_LEN;
 }
@@ -718,12 +759,14 @@ static void handle_get_sel_allocation_info(lmc_data_t *mc,
 	}
 
 	memset(rdata, 0, GETSELALL_RPLY_LEN);
-	ipmi_set_uint16(rdata + 1, mc->sel.max_count * 16);
-	ipmi_set_uint16(rdata + 3, 16);
-	ipmi_set_uint16(rdata + 5,
-			(mc->sel.max_count - atomic_read(&mc->sel.count)) * 16);
-	ipmi_set_uint16(rdata + 7,
-			(mc->sel.max_count - atomic_read(&mc->sel.count)) * 16);
+	/* Number of possible allocation units */
+	ipmi_set_uint16(rdata + 1, mc->sel.max_count);
+	/* Allocation unit size */
+	ipmi_set_uint16(rdata + 3, PMEM_SEL_DATA_LENGTH);
+	/* Number of free allocation units */
+	ipmi_set_uint16(rdata + 5, get_free_space(mc)/PMEM_SEL_DATA_LENGTH);
+	/* Number of bytes of the largest contiguous free region */
+	ipmi_set_uint16(rdata + 7, get_free_space(mc));
 	rdata[9] = 1;
 
 	*rdata_len = GETSELALL_RPLY_LEN;
@@ -1019,6 +1062,9 @@ static void handle_clear_sel(lmc_data_t *mc,
 		 ipmi_msg_t *msg,
 		 unsigned char *rdata, unsigned int *rdata_len)
 {
+#define CLR_SEL_CMD_INITIATE_ERASE	0xAA
+#define CLR_SEL_CMD_GET_ERASURE_STATUS	0x00
+
 	unsigned char op;
 	struct timeval t;
 
@@ -1054,14 +1100,15 @@ static void handle_clear_sel(lmc_data_t *mc,
 	}
 
 	op = msg->data[5];
-	if ((op != 0) && (op != 0xaa)) {
+	if ((op != CLR_SEL_CMD_INITIATE_ERASE) &&
+	    (op != CLR_SEL_CMD_GET_ERASURE_STATUS)) {
 		handle_error_response(IPMI_INVALID_DATA_FIELD_CC, rdata,
 				      rdata_len);
 		return;
 	}
 
 	rdata[1] = 1;
-	if (op == 0) {
+	if (op == CLR_SEL_CMD_INITIATE_ERASE) {
 		down(&mc->sel.sem);
 		clear_sel(mc);
 		up(&mc->sel.sem);
@@ -1312,6 +1359,8 @@ do_event(sensor_t *sensor,
 	/* send SEL northbound, and store on linked list if PMEM */
 	/* not configured (frees SEL also, if PMEM configured)   */
 	ipmi_add_to_sel_tlet(selr);
+
+	dest_mc->sel.last_add_time = (unsigned long)tv.tv_sec;
 }
 
 /*  gen_event  Format an Event Record for southbound and northbound.
@@ -4629,6 +4678,17 @@ void ipmi_emu_delete_mc(lmc_data_t *mc)
 
 	clear_sdr(&(mc->main_sdrs.sdrs), &(mc->main_sdrs.lock));
 
+	/*
+	 * Delete the sensor_timer if any "rate based" sensor has been
+	 * installed. rate_based_sensors[] and rate_based_sensor_count
+	 * could be left un-cleaned since the whole vMC module is about
+	 * to be released anyway.
+	 */
+	if (atomic_read(&rate_based_sensor_count) >= 1) {
+		del_timer_sync(&sensor_timer);
+		printk(KERN_INFO "vMC: sensor_timer deleted.\n");
+	}
+
 	for (i = 0; i < 4; i++) {
 		clear_sdr(&(mc->device_sdrs[i].sdrs),
 			  &(mc->device_sdrs[i].lock));
-- 
1.6.5.2

