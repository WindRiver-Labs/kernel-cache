From 92a5bfd65cfef9b9e91c4130bd2b08c037eb4997 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Tue, 11 May 2010 20:12:09 -0700
Subject: [PATCH] vMC: make vMC work in interrupt flood from EDAC

Interrupt mask control driver bind/unbind APIs and related
functions were added to vMC to make it work if EDAC interrupt
food occur.

IRQ handler has high priority over vMC message handler and
may deprive vMC message handler the chance of processing
messages, which will cause vMC fail to work in EDAC interrupt
flood since interrupt repeatedly occurs but fail to report
fault to vMC.

A callback function and a dev_id were register with the vMC
sensor when the EDAC driver is using interrupt or NMI mode.
The interrupt is masked when the EDAC driver reports fault to
vMC, which gives vMC the chance to handle the message. vMC
will reenable the interrupt when it is done.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/char/ipmi/Kconfig    |   10 ++
 drivers/char/ipmi/vmc_emu.c  |   93 ++++++++++++++++++
 drivers/char/ipmi/vmc_emu.h  |   68 +++++++++++++-
 drivers/char/ipmi/vmc_kapi.c |   39 ++++++++
 drivers/char/ipmi/vmc_stub.c |   57 +++++++++++
 drivers/edac/e7xxx_edac.c    |  219 ++++++++++++++++++++++++++++++++++++++++-
 drivers/edac/edac_vmc.c      |   40 ++++++++
 drivers/edac/edac_vmc.h      |   10 ++-
 include/linux/vmc.h          |   45 +++++++++
 9 files changed, 573 insertions(+), 8 deletions(-)

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index f6bf11e..f923bae 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -120,4 +120,14 @@ config IPMI_VMC_PMEM_BLOCKS_NUMBER
 	  After dumping the content of a locked block, the user could
 	  manually mark it as unlocked for future usage.
 
+config VMC_INTERRUPT_FLOOD_CTRL
+	bool 'VMC sensor interrupt flood control'
+	depends on IPMI_VMC
+	default n
+	help
+	 The sensor can register an interrupt mask control function
+	 so that vMC can mask the interrupt before setting or changing
+	 the sensor value and unmask it after these operation to prevent
+	 EDAC interrupt flood.
+
 endif # IPMI_HANDLER
diff --git a/drivers/char/ipmi/vmc_emu.c b/drivers/char/ipmi/vmc_emu.c
index b60f34c..cf1d364 100644
--- a/drivers/char/ipmi/vmc_emu.c
+++ b/drivers/char/ipmi/vmc_emu.c
@@ -4118,6 +4118,90 @@ int ipmi_mc_sensor_set_event_support(vMC_ipmi_sensor_ident_t *sensor_ident,
 	return VMC_NO_ERROR;
 }
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+int ipmi_mc_sensor_bind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+	sensor_t *sensor;
+	int rc = 0;
+
+	sensor = ipmi_find_sensor_byid(sensor_ident, &rc);
+	if (sensor == NULL) {
+		printk(KERN_ERR "Can't bind mask driver, err %d\n", rc);
+		return rc;
+	}
+
+	down(&sensor->sem);
+	spin_lock(&sensor->lock);
+
+	rc = __vMC_sensor_bind_mask_ctrl_driver(sensor, dev_id,
+		       mask_ctrl_driver);
+
+	spin_unlock(&sensor->lock);
+	up(&sensor->sem);
+	ipmi_release_sensor(sensor);
+	printk(KERN_INFO "Bind mask ctrl driver success for %x:%x:%x\n",
+		sensor_ident->sensor_mc, sensor_ident->sensor_lun,
+		sensor_ident->sensor_num);
+	return rc;
+
+}
+
+int ipmi_mc_sensor_unbind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+	sensor_t *sensor;
+	int rc = 0;
+
+	sensor = ipmi_find_sensor_byid(sensor_ident, &rc);
+	if (sensor == NULL) {
+		printk(KERN_ERR "Can't unbind mask driver, err %d\n", rc);
+		return rc;
+	}
+
+	down(&sensor->sem);
+	spin_lock(&sensor->lock);
+
+	rc = __vMC_sensor_unbind_mask_ctrl_driver(sensor, dev_id,
+			mask_ctrl_driver);
+
+	spin_unlock(&sensor->lock);
+	up(&sensor->sem);
+
+	ipmi_release_sensor(sensor);
+
+	return rc;
+}
+
+
+
+int ipmi_mc_sensor_call_mask_ctrl_driver(vMC_ipmi_sensor_ident_t *sensor_ident,
+					vmc_int_ctrl_mask_t ctrl)
+{
+	sensor_t *sensor;
+	int rc = 0 ;
+
+	sensor = ipmi_find_sensor_byid(sensor_ident, &rc);
+	if (sensor == NULL) {
+		printk(KERN_ERR "Can't carry out sensor mask ctrl, err %d\n",
+				rc);
+		return rc;
+	}
+
+	rc = __vMC_call_sensor_mask_ctrl_driver(sensor, ctrl);
+
+	ipmi_release_sensor(sensor);
+
+	return rc;
+
+}
+
+#endif
+
 static void handle_sensor_event_netfn(lmc_data_t *mc, unsigned char lun,
 				      ipmi_msg_t *msg, unsigned char *rdata,
 				      unsigned int *rdata_len)
@@ -4465,6 +4549,9 @@ void kapi_handle_msg(vMC_kapi_cmd_t *cmd)
 			vMC_free_sel_record(cmd->selr);
 		}
 		up(&cmd->s->sem);
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+		__vMC_call_sensor_mask_ctrl_driver(cmd->s, VMC_UNMASK);
+#endif
 		ipmi_release_sensor(cmd->s);
 		break;
 
@@ -4496,6 +4583,9 @@ void kapi_handle_msg(vMC_kapi_cmd_t *cmd)
 		} else
 			vMC_free_sel_record(cmd->selr);
 		up(&cmd->s->sem);
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+		__vMC_call_sensor_mask_ctrl_driver(cmd->s, VMC_UNMASK);
+#endif
 		ipmi_release_sensor(cmd->s);
 		break;
 
@@ -4528,6 +4618,9 @@ void kapi_handle_msg(vMC_kapi_cmd_t *cmd)
 				vMC_free_sel_record(cmd->selr);
 			up(&cmd->s->sem);
 		}
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+		__vMC_call_sensor_mask_ctrl_driver(cmd->s, VMC_UNMASK);
+#endif
 		ipmi_release_sensor(cmd->s);
 		break;
 
diff --git a/drivers/char/ipmi/vmc_emu.h b/drivers/char/ipmi/vmc_emu.h
index a361a86..3bd443d 100644
--- a/drivers/char/ipmi/vmc_emu.h
+++ b/drivers/char/ipmi/vmc_emu.h
@@ -135,7 +135,9 @@ struct sensor_s {
 
 	/* Called when the sensor changes values. */
 	void (*sensor_update_handler) (sensor_t *sensor);
-
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	struct sensor_irq_ctr_t irq_ctrl;
+#endif
 	vMC_ipmi_sdr_t *sdr;	/* Associated SDR entry */
 	lmc_data_t *mc;		/* Associated MC */
 };
@@ -237,6 +239,53 @@ vmc_kfree(const void *objp)
 	kfree(objp);
 }
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+
+/* This function should be called with sem and lock acquired */
+static inline int __vMC_sensor_bind_mask_ctrl_driver(
+	sensor_t *sensor,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+
+	sensor->irq_ctrl.dev_id = dev_id;
+	sensor->irq_ctrl.mask_ctrl_driver = mask_ctrl_driver;
+	return VMC_NO_ERROR;
+}
+
+/* This function should be called with sem and lock acquired */
+static inline int __vMC_sensor_unbind_mask_ctrl_driver(
+	sensor_t *sensor,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+
+	if ((dev_id && sensor->irq_ctrl.dev_id != dev_id) ||
+		(mask_ctrl_driver &&
+			sensor->irq_ctrl.mask_ctrl_driver != mask_ctrl_driver))
+		return VMC_EINVAL;
+
+	sensor->irq_ctrl.dev_id = NULL;
+	sensor->irq_ctrl.mask_ctrl_driver = NULL;
+
+	return VMC_NO_ERROR;
+
+}
+
+static inline int __vMC_call_sensor_mask_ctrl_driver(
+			sensor_t *sensor,
+			vmc_int_ctrl_mask_t ctrl)
+{
+
+	if (sensor->irq_ctrl.mask_ctrl_driver)
+		(*sensor->irq_ctrl.mask_ctrl_driver)(
+			sensor->irq_ctrl.dev_id, ctrl);
+
+	return VMC_NO_ERROR;
+}
+
+#endif
+
 int ipmi_emu_alloc(void *user_data);
 void ipmi_emu_free(void);
 
@@ -315,6 +364,23 @@ int ipmi_mc_sensor_set_event_support(vMC_ipmi_sensor_ident_t *sensor_ident,
 				     unsigned int assertions_supported,
 				     unsigned int deassertions_supported);
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+
+int ipmi_mc_sensor_bind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl));
+
+int ipmi_mc_sensor_unbind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl));
+
+int ipmi_mc_sensor_call_mask_ctrl_driver(vMC_ipmi_sensor_ident_t *sensor_ident,
+					vmc_int_ctrl_mask_t ctrl);
+
+#endif
+
 int ipmi_mc_add_sensor(lmc_data_t *mc,
 		       unsigned char lun,
 		       unsigned char sens_num,
diff --git a/drivers/char/ipmi/vmc_kapi.c b/drivers/char/ipmi/vmc_kapi.c
index 51c7907..b6600e5 100644
--- a/drivers/char/ipmi/vmc_kapi.c
+++ b/drivers/char/ipmi/vmc_kapi.c
@@ -334,7 +334,38 @@ static int _vMC_sensor_set_event_support(vMC_ipmi_sensor_ident_t *sensor_ident,
 						assertions_supported,
 						deassertions_supported);
 }
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
 
+/*
+ * These function are vMC only.
+ *  But we have to define a ipmi_mc* since some of the functions are static.
+ */
+int _vMC_sensor_bind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+	return ipmi_mc_sensor_bind_int_mask_ctrl_driver(sensor_ident,
+				dev_id, mask_ctrl_driver);
+}
+
+int _vMC_sensor_unbind_int_mask_ctrl_driver(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_iid, vmc_int_ctrl_mask_t ctrl))
+{
+	return ipmi_mc_sensor_unbind_int_mask_ctrl_driver(sensor_ident,
+				dev_id, mask_ctrl_driver);
+}
+
+int _vMC_sensor_call_mask_ctrl_driver(vMC_ipmi_sensor_ident_t *sensor_ident,
+					vmc_int_ctrl_mask_t ctrl)
+{
+	return ipmi_mc_sensor_call_mask_ctrl_driver(sensor_ident, ctrl);
+
+}
+
+#endif
 
 /* register_vMC_api
  *   Replace stub implementations of the vMC API with the real implementations
@@ -361,6 +392,14 @@ void register_vMC_api(void)
 	vMC_sensor_set_hysteresis = _vMC_sensor_set_hysteresis;
 	vMC_sensor_set_threshold = _vMC_sensor_set_threshold;
 	vMC_sensor_set_event_support = _vMC_sensor_set_event_support;
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	vMC_sensor_bind_int_mask_ctrl_driver =
+			_vMC_sensor_bind_int_mask_ctrl_driver;
+	vMC_sensor_unbind_int_mask_ctrl_driver =
+			_vMC_sensor_unbind_int_mask_ctrl_driver;
+	vMC_sensor_call_int_mask_ctrl_driver =
+			_vMC_sensor_call_mask_ctrl_driver;
+#endif
 }
 
 
diff --git a/drivers/char/ipmi/vmc_stub.c b/drivers/char/ipmi/vmc_stub.c
index eb82bab..577dcac 100644
--- a/drivers/char/ipmi/vmc_stub.c
+++ b/drivers/char/ipmi/vmc_stub.c
@@ -295,6 +295,50 @@ void vMC_register_containment_handler(void (*handler) (void), unsigned severity)
 		vMC_containment_handler[severity] = handler;
 }
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+int vMC_sensor_bind_int_mask_ctrl_driver_stub(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+	printk(KERN_INFO "vMC Sensor  Bind Int Mask Ctrl Driver  Support\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_bind_int_mask_ctrl_driver)(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+		= vMC_sensor_bind_int_mask_ctrl_driver_stub;
+
+int vMC_sensor_unbind_int_mask_ctrl_driver_stub(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+{
+	printk(KERN_INFO "vMC Sensor Unbind Int Mask Ctrl Driver Support\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_unbind_int_mask_ctrl_driver)(
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl))
+		= vMC_sensor_unbind_int_mask_ctrl_driver_stub;
+
+int vMC_sensor_call_int_mask_ctrl_driver_stub(
+			vMC_ipmi_sensor_ident_t *sensor_ident,
+			vmc_int_ctrl_mask_t ctrl)
+{
+	printk(KERN_INFO "vMC Sensor Call Int Mask Ctrl Driver Support\n");
+	return VMC_MODULE_NOT_LOADED;
+}
+
+int (*vMC_sensor_call_int_mask_ctrl_driver)(
+					vMC_ipmi_sensor_ident_t *sensor_ident,
+					vmc_int_ctrl_mask_t ctrl)
+   = vMC_sensor_call_int_mask_ctrl_driver_stub;
+#endif
 
 /* register_vMC_stub
  *   This function will set the vMC API functions to point to the stub
@@ -320,6 +364,14 @@ void register_vMC_stubs(void)
 	vMC_sensor_set_hysteresis = vMC_sensor_set_hysteresis_stub;
 	vMC_sensor_set_threshold = vMC_sensor_set_threshold_stub;
 	vMC_sensor_set_event_support = vMC_sensor_set_event_support_stub;
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	vMC_sensor_bind_int_mask_ctrl_driver =
+			vMC_sensor_bind_int_mask_ctrl_driver_stub;
+	vMC_sensor_unbind_int_mask_ctrl_driver =
+			vMC_sensor_unbind_int_mask_ctrl_driver_stub;
+	vMC_sensor_call_int_mask_ctrl_driver =
+			vMC_sensor_call_int_mask_ctrl_driver_stub;
+#endif
 }
 
 static __init int init_vMC_stub_mod(void)
@@ -357,6 +409,11 @@ EXPORT_SYMBOL(vMC_sensor_external_event_mask);
 EXPORT_SYMBOL(vMC_sensor_set_hysteresis);
 EXPORT_SYMBOL(vMC_sensor_set_threshold);
 EXPORT_SYMBOL(vMC_sensor_set_event_support);
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+EXPORT_SYMBOL(vMC_sensor_bind_int_mask_ctrl_driver);
+EXPORT_SYMBOL(vMC_sensor_unbind_int_mask_ctrl_driver);
+EXPORT_SYMBOL(vMC_sensor_call_int_mask_ctrl_driver);
+#endif
 EXPORT_SYMBOL(vMC_register_containment_handler);
 EXPORT_SYMBOL(vMC_containment_handler);
 EXPORT_SYMBOL(register_vMC_stubs);
diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index 247316a..6a233a8 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -255,6 +255,9 @@ struct e7xxx_error_info {
 	u8 sysbus_nerr;
 };
 
+#if defined(CONFIG_EDAC_VMC) && defined(CONFIG_VMC_INTERRUPT_FLOOD_CTRL)
+static struct pci_dev *e7xxx_D0F1_dev;
+#endif
 static struct edac_pci_ctl_info *e7xxx_pci;
 static struct e7xxx_dev_info *e7xxx_device;
 
@@ -337,6 +340,49 @@ static void e7501_hiX_err_exit(struct e7xxx_dev_info *dev_info)
 	}
 }
 
+#if defined(CONFIG_EDAC_VMC) && defined(CONFIG_VMC_INTERRUPT_FLOOD_CTRL)
+static void e7501_hix_err_mask_ctrl_driver(void **dev_id,
+			vmc_int_ctrl_mask_t ctrl)
+{
+	struct pci_dev *dev;
+	u16 word;
+	u8 byte;
+
+	if (NULL == dev_id)
+		return;
+	dev = (struct pci_dev *)*dev_id;
+
+	if (NULL == dev)
+		return;
+
+	if (VMC_MASK == ctrl) {
+		pci_read_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+		if (word & (1 << 8)) { /* clear SERR */
+			word &= ~(1 << 8);
+			pci_write_config_word(dev,
+				      E7501_HI_ERROR_REPORT_PCICMD, word);
+		}
+
+		pci_read_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+		if (byte & E7501_HI_SERRCMD_MASK) {
+			byte &= ~E7501_HI_SERRCMD_MASK;
+			pci_write_config_byte(dev,
+				      E7501_HI_ERROR_REPORT_SERRCMD, byte);
+		}
+	} else if (VMC_UNMASK == ctrl) {
+		pci_read_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+		word |=  1 << 8; /* SERR global enable */
+		pci_write_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, word);
+
+		pci_read_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+		byte |= E7501_HI_SERRCMD_MASK;
+		pci_write_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, byte);
+	}
+
+	return;
+}
+#endif
+
 static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 {
 	struct e7xxx_dev_info *dev_info = edac_dev->pvt_info;
@@ -1045,6 +1091,51 @@ static void e7501_D0F1_exit(struct pci_dev *dev)
 	}
 }
 
+#if defined(CONFIG_EDAC_VMC) && defined(CONFIG_VMC_INTERRUPT_FLOOD_CTRL)
+static void e7501_D0F1_err_mask_ctrl_driver(void **dev_id,
+			vmc_int_ctrl_mask_t ctrl)
+{
+	struct pci_dev *dev;
+	u16 word;
+	u8 byte;
+
+	if (NULL == dev_id)
+		return;
+
+	dev = (struct pci_dev *)*dev_id;
+
+	if (NULL == dev)
+		return;
+
+	if (VMC_UNMASK == ctrl) {
+		pci_read_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+		if (word & (1 << 8)) { /* clear SERR */
+			word &= ~(1 << 8);
+			pci_write_config_word(dev,
+				      E7501_HI_ERROR_REPORT_PCICMD, word);
+		}
+
+		pci_read_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+		if (byte & E7501_HI_SERRCMD_MASK) {
+			byte &= ~E7501_HI_SERRCMD_MASK;
+			pci_write_config_byte(dev,
+				      E7501_HI_ERROR_REPORT_SERRCMD, byte);
+		}
+	} else if (VMC_MASK == ctrl) {
+		pci_read_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+		word |=  1 << 8; /* SERR global enable */
+		pci_write_config_word(dev, E7501_HI_ERROR_REPORT_PCICMD, word);
+
+		pci_read_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+		byte |= E7501_HI_SERRCMD_MASK;
+		pci_write_config_byte(dev, E7501_HI_ERROR_REPORT_SERRCMD, byte);
+	}
+
+
+	return;
+}
+#endif
+
 #ifdef CONFIG_EDAC_VMC
 /*
  * Meaning of vmc_intf_num:
@@ -1083,15 +1174,119 @@ static int init_vmc_sensors(void)
 		e7xxx_vmc_lun = vmc_assign_lun();
 
 	/* Sensors with non-default parameters */
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	if (edac_op_state == EDAC_OPSTATE_NMI) {
+		rc  = vmc_sensor_init(UECC_FLT, e7xxx_sensor_map,
+			e7xxx_sensor_names,
+			e7xxx_vmc_lun, &uecc_flt_params,
+			e7501_D0F1_err_mask_ctrl_driver,
+			(void **)&e7xxx_D0F1_dev);
+		rc |= vmc_sensor_init(CECC_FLT, e7xxx_sensor_map,
+			e7xxx_sensor_names,
+			e7xxx_vmc_lun, &cecc_flt_params,
+			e7501_D0F1_err_mask_ctrl_driver,
+			(void **)&e7xxx_D0F1_dev);
+
+	} else {
+		rc  = vmc_sensor_init(UECC_FLT, e7xxx_sensor_map,
+			e7xxx_sensor_names,
+			e7xxx_vmc_lun, &uecc_flt_params, NULL, NULL);
+		rc |= vmc_sensor_init(CECC_FLT, e7xxx_sensor_map,
+			e7xxx_sensor_names,
+			e7xxx_vmc_lun, &cecc_flt_params, NULL, NULL);
+	}
+#else
 	rc  = vmc_sensor_init(UECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
 			      e7xxx_vmc_lun, &uecc_flt_params);
 	rc |= vmc_sensor_init(CECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
 			      e7xxx_vmc_lun, &cecc_flt_params);
+#endif
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), e7xxx_sensor_map,	\
+				e7xxx_sensor_names,	\
+				e7xxx_vmc_lun, NULL, NULL, NULL)
+#define INIT_SENSOR_DEFAULT_D0F1(id) vmc_sensor_init((id), e7xxx_sensor_map,\
+				e7xxx_sensor_names,	\
+				e7xxx_vmc_lun, NULL,	\
+				e7501_D0F1_err_mask_ctrl_driver,\
+				(void **)&e7xxx_D0F1_dev)
+#define INIT_SENSOR_DEFAULT_HIX(id, dev_id)	\
+				vmc_sensor_init((id), e7xxx_sensor_map,\
+				e7xxx_sensor_names,	\
+				e7xxx_vmc_lun, NULL,	\
+				e7501_hix_err_mask_ctrl_driver,\
+				(void **)dev_id)
+#else
 #define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), e7xxx_sensor_map,	\
 						e7xxx_sensor_names,	\
 						e7xxx_vmc_lun, NULL)
+#endif
 	/* Sensors with default parameters: */
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	if (edac_op_state == EDAC_OPSTATE_NMI) {
+		struct e7xxx_dev_info *dev_info;
+		int sensor_id;
+
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_ADD_REQ_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_DSTROBE_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_ASTROBE_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_DATA_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_ADDR_TOM_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_NONDRAM_LOCK_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_MCERR_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(SYSBUS_BINIT_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(HUB_ADDR_CMD_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(HUB_DATA_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT_D0F1(HUB_TARGET_ABORT_FLT);
+
+		for (dev_info = &e7xxx_device[1]; dev_info->err_dev;
+						dev_info++) {
+			/* sanity check */
+			if (!dev_info->check)
+				continue;
+
+			sensor_id = -1;
+			switch (dev_info->err_dev) {
+			case PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT:
+				sensor_id = HIB_FLT;
+				break;
+
+			case PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT:
+				sensor_id = HIC_FLT;
+				break;
+
+			case PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT:
+				sensor_id = HID_FLT;
+				break;
+			default:
+				break;
+			}
+
+			if (sensor_id != -1  && dev_info->dev)
+				INIT_SENSOR_DEFAULT_HIX(sensor_id,
+							&dev_info->dev);
+
+		}
+	} else {
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADD_REQ_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_DSTROBE_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_ASTROBE_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_DATA_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADDR_TOM_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_NONDRAM_LOCK_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_MCERR_FLT);
+		rc |= INIT_SENSOR_DEFAULT(SYSBUS_BINIT_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HUB_ADDR_CMD_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HUB_DATA_PAR_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HUB_TARGET_ABORT_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HIB_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HIC_FLT);
+		rc |= INIT_SENSOR_DEFAULT(HID_FLT);
+	}
+#undef INIT_SENSOR_DEFAULT_D0F1
+#undef INIT_SENSOR_DEFAULT_HIX
+#else
 	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADD_REQ_PAR_FLT);
 	rc |= INIT_SENSOR_DEFAULT(SYSBUS_DSTROBE_FLT);
 	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ASTROBE_FLT);
@@ -1106,6 +1301,7 @@ static int init_vmc_sensors(void)
 	rc |= INIT_SENSOR_DEFAULT(HIB_FLT);
 	rc |= INIT_SENSOR_DEFAULT(HIC_FLT);
 	rc |= INIT_SENSOR_DEFAULT(HID_FLT);
+#endif
 #undef INIT_SENSOR_DEFAULT
 
 	return rc;
@@ -1182,12 +1378,6 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 
 	debugf0("%s(): mci\n", __func__);
 
-#ifdef CONFIG_EDAC_VMC
-	int ret = ipmi_smi_watcher_register(&vmc_watcher);
-	if (ret)
-		e7xxx_printk(KERN_ERR, "can't register vMC's smi watcher!\n");
-#endif
-
 	pci_read_config_dword(pdev, E7XXX_DRC, &drc);
 
 	drc_chan = dual_channel_active(drc, dev_idx);
@@ -1266,9 +1456,23 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 			__func__);
 	}
 
+#if defined(CONFIG_EDAC_VMC) && defined(CONFIG_VMC_INTERRUPT_FLOOD_CTRL)
+	e7xxx_D0F1_dev = pvt->bridge_ck;
+#endif
+
 	/* adding all the rest devices on a e7xxx chipset */
 	e7xxx_add_edac_devices();
 
+#ifdef CONFIG_EDAC_VMC
+	/* Register smi watcher a little late since all the device pointers
+	   used by CONFIG_VMC_INTERRUPT_FLOOD_CTRL should be initialized before
+	   this registration, which are used to initialize all sensors for vMC.
+	*/
+	int ret = ipmi_smi_watcher_register(&vmc_watcher);
+	if (ret)
+		e7xxx_printk(KERN_ERR, "can't register vMC's smi watcher!\n");
+#endif
+
 	/* get this far and it's successful */
 	debugf3("%s(): success\n", __func__);
 	return 0;
@@ -1342,6 +1546,9 @@ static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 
 	pvt = (struct e7xxx_pvt *)mci->pvt_info;
 	e7501_D0F1_exit(pvt->bridge_ck);
+#if defined(CONFIG_EDAC_VMC) && defined(CONFIG_VMC_INTERRUPT_FLOOD_CTRL)
+	e7xxx_D0F1_dev = NULL;
+#endif
 	pci_dev_put(pvt->bridge_ck);
 	edac_mc_free(mci);
 
diff --git a/drivers/edac/edac_vmc.c b/drivers/edac/edac_vmc.c
index 2d291ca..92a2ac2 100644
--- a/drivers/edac/edac_vmc.c
+++ b/drivers/edac/edac_vmc.c
@@ -75,9 +75,17 @@ EXPORT_SYMBOL(vmc_release_lun);
 
 /* Initialize a single fault detection vMC Sensor Data Records (SDR).
  * See edac_vmc.h for usage */
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+int vmc_sensor_init(int sensor_id, const int *sensor_map,
+	const char *sensor_names[], int sensor_lun,
+	struct vmc_sensor_params_s *sensor_params,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl),
+	void **dev_id)
+#else
 int vmc_sensor_init(int sensor_id, const int *sensor_map,
 		     const char *sensor_names[], int sensor_lun,
 		     struct vmc_sensor_params_s *sensor_params)
+#endif
 {
 	int rc = -1;
 	vMC_ipmi_sensor_ident_t sensor_ident;
@@ -204,6 +212,17 @@ int vmc_sensor_init(int sensor_id, const int *sensor_map,
 			sensor_names[sensor_id], sensor_lun, sensor_id);
 		vMC_device_sdr_delete(&sensor_ident);
 	}
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	if (mask_ctrl_driver) {
+		int rc1;
+		rc1 = vMC_sensor_bind_int_mask_ctrl_driver(&sensor_ident,
+						dev_id, mask_ctrl_driver);
+		if (rc1 != VMC_NO_ERROR)
+			fprintk("vmc_sensor_init could not "
+				"bind mask ctrl driver for"
+				"%d %s\n", rc, sensor_names[sensor_id]);
+	}
+#endif
 
 	return rc;
 }
@@ -259,16 +278,32 @@ int vmc_report_fault(int sensor_id, int sensor_lun, int action,
 		if (vMC_sensor_get_value(&sensor_ident, &sensor_value) ==
 				VMC_NO_ERROR) {
 			if (sensor_value < (TH_GEN_UPPER_NON_RECOVERABLE-1)) {
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+				vMC_sensor_call_int_mask_ctrl_driver(
+						&sensor_ident, VMC_MASK);
+#endif
 				rc = vMC_sensor_increment_value(&sensor_ident,
 						value, sel_record);
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+				if (rc)
+					vMC_sensor_call_int_mask_ctrl_driver(
+						&sensor_ident, VMC_UNMASK);
+#endif
 			}	/* else don't do anything since we would
 				   our unrecoverable case */
 		}
 	}
 	/* ...or set sensor value (action == SENSOR_ACTION_SET) */
 	else {
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+		vMC_sensor_call_int_mask_ctrl_driver(&sensor_ident, VMC_MASK);
+#endif
 		if (vMC_sensor_set_value(&sensor_ident, value, sel_record)) {
 			rc = 1;
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+			vMC_sensor_call_int_mask_ctrl_driver(&sensor_ident,
+					VMC_UNMASK);
+#endif
 			goto error;
 		}
 	}
@@ -292,6 +327,11 @@ void vmc_sensor_uninit(int sensor_id, int sensor_lun)
 	sensor_ident.sensor_lun = sensor_lun;
 	sensor_ident.sensor_num = sensor_id;
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+	vMC_sensor_unbind_int_mask_ctrl_driver(&sensor_ident,
+					NULL, NULL);
+#endif
+
 	/* Request vMC core remove SDR */
 	vMC_device_sdr_delete(&sensor_ident);
 }
diff --git a/drivers/edac/edac_vmc.h b/drivers/edac/edac_vmc.h
index 81e513b..f720008 100644
--- a/drivers/edac/edac_vmc.h
+++ b/drivers/edac/edac_vmc.h
@@ -144,10 +144,18 @@ void vmc_release_lun(int lun);
  * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files
  *
  * Returns 0 if successful */
+ #ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
 int vmc_sensor_init(int sensor_id, const int *sensor_map,
 			const char *sensor_names[],
 			int sensor_lun,
-			struct vmc_sensor_params_s *sensor_params);
+	struct vmc_sensor_params_s *sensor_params,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl),
+	void **dev_id);
+ #else
+int vmc_sensor_init(int sensor_id, const int *sensor_map,
+		const char *sensor_names[],
+		int sensor_lun, struct vmc_sensor_params_s *sensor_params);
+ #endif
 
 
 /* Report a fault to a vMC sensor given an action, value, and a list of
diff --git a/include/linux/vmc.h b/include/linux/vmc.h
index c2e8d12..f950863 100644
--- a/include/linux/vmc.h
+++ b/include/linux/vmc.h
@@ -771,6 +771,20 @@ typedef struct vMC_ipmi_sensor_ident_s {
 #define IPMI_SEL_SYS_TYPE	0x02
 #define IPMI_SEL_OEM_TYPE	0xC0
 
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+enum vmc_int_ctrl_mask_s {
+	VMC_MASK,
+	VMC_UNMASK
+};
+
+typedef enum vmc_int_ctrl_mask_s vmc_int_ctrl_mask_t;
+struct sensor_irq_ctr_t {
+	void **dev_id;
+	unsigned long arg;
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl);
+};
+#endif
+
 /*
  * Virtual Management Controller Function API
  */
@@ -946,6 +960,37 @@ extern int (*vMC_sensor_set_event_support) (vMC_ipmi_sensor_ident_t *
 extern void vMC_register_containment_handler(void (*handler) (void),
 					     unsigned int severity);
 
+
+#ifdef CONFIG_VMC_INTERRUPT_FLOOD_CTRL
+
+/*
+ * vMC_bind_int_mask_ctrl_driver
+ *    Bind an interrupt mask ctronl function to the sensor if it is necessary
+ *   to control interrupt flood to give time for vmc to update data.
+ */
+extern int (*vMC_sensor_bind_int_mask_ctrl_driver) (
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl));
+
+/*
+  * vMC_unbind_int_mask_ctrl_driver
+  * Unbind the interrupt mask control fuinction of the sensor specified.
+  */
+extern int (*vMC_sensor_unbind_int_mask_ctrl_driver) (
+	vMC_ipmi_sensor_ident_t *sensor_ident,
+	void **dev_id,
+	void (*mask_ctrl_driver)(void **dev_id, vmc_int_ctrl_mask_t ctrl));
+
+/*
+  * vMC_sensor_call_int_mask_ctrl_driver
+  * Call the interrupt mask control driver
+  */
+extern int (*vMC_sensor_call_int_mask_ctrl_driver) (
+			vMC_ipmi_sensor_ident_t *sensor_ident,
+			vmc_int_ctrl_mask_t ctrl);
+
+#endif
 /*
  * Virtual Management Controller Error Responses
  */
-- 
1.6.5.2

