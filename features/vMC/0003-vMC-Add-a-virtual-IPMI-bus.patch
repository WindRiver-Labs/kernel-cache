From 442658228c612660e5e8b6e9aee87bf1577e18a0 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Thu, 6 Nov 2008 13:39:34 -0500
Subject: [PATCH] vMC - Add a virtual IPMI bus

Add a simple virtual IPMI bus for device drivers to register with.
vMC required this bus. This will be built when IPMI support is
enabled (ie. CONFIG_IPMI_HANDLER is defined).

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/char/ipmi/Makefile  |    2 +-
 drivers/char/ipmi/ipmibus.c |  171 +++++++++++++++++++++++++++++++++++++++++++
 drivers/char/ipmi/ipmibus.h |   36 +++++++++
 3 files changed, 208 insertions(+), 1 deletions(-)
 create mode 100644 drivers/char/ipmi/ipmibus.c
 create mode 100644 drivers/char/ipmi/ipmibus.h

diff --git a/drivers/char/ipmi/Makefile b/drivers/char/ipmi/Makefile
index bf40ce3..eca4cc2 100644
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@ -4,7 +4,7 @@
 
 ipmi_si-objs := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o
 
-obj-$(CONFIG_IPMI_HANDLER) += ipmi_msghandler.o
+obj-$(CONFIG_IPMI_HANDLER) += ipmi_msghandler.o ipmibus.o
 obj-$(CONFIG_IPMI_DEVICE_INTERFACE) += ipmi_devintf.o
 obj-$(CONFIG_IPMI_SI) += ipmi_si.o
 obj-$(CONFIG_IPMI_SERIAL) += ipmi_serial.o
diff --git a/drivers/char/ipmi/ipmibus.c b/drivers/char/ipmi/ipmibus.c
new file mode 100644
index 0000000..c8e5a5b
--- /dev/null
+++ b/drivers/char/ipmi/ipmibus.c
@@ -0,0 +1,171 @@
+/*
+ * A virtual bus for ipmi sample code devices to plug into.  This
+ * code is heavily borrowed from drivers/base/sys.c
+ *
+ * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
+ * Copyright (C) 2001 O'Reilly & Associates
+ *
+ * The source code in this file can be freely used, adapted,
+ * and redistributed in source or binary form, so long as an
+ * acknowledgment appears in derived source files.  The citation
+ * should list that the code comes from the book "Linux Device
+ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
+ * by O'Reilly & Associates.   No warranty is attached;
+ * we cannot take responsibility for errors or fitness for use.
+ *
+ * ipmibus.c,v 1.9 2004/09/26 08:12:27 gregkh
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include "ipmibus.h"
+
+MODULE_AUTHOR("Jonathan Corbet");
+MODULE_LICENSE("GPL");
+static char *Version = "Revision: 1.9";
+
+/*
+ * Respond to userspace events.
+ */
+static int ipmi_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	add_uevent_var(env, "ipmiBUS_VERSION=%s", Version);
+	return 0;
+}
+
+/*
+ * Match ipmi devices to drivers.  Just do a simple name test.
+ */
+static int ipmi_match(struct device *dev, struct device_driver *driver)
+{
+	return !strncmp(dev->bus_id, driver->name, strlen(driver->name));
+}
+
+
+/*
+ * The ipmi bus device.
+ */
+static void ipmi_bus_release(struct device *dev)
+{
+	printk(KERN_DEBUG "ipmibus release\n");
+}
+
+struct device ipmi_bus = {
+	.bus_id   = "ipmi0",
+	.release  = ipmi_bus_release
+};
+
+
+/*
+ * And the bus type.
+ */
+struct bus_type ipmi_bus_type = {
+	.name = "ipmi",
+	.match = ipmi_match,
+	.uevent  = ipmi_uevent,
+};
+
+/*
+ * Export a simple attribute.
+ */
+static ssize_t show_bus_version(struct bus_type *bus, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%s\n", Version);
+}
+
+static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL);
+
+
+
+/*
+ * ipmi devices.
+ */
+
+/*
+ * For now, no references to ipmibus devices go out which are not
+ * tracked via the module reference count, so we use a no-op
+ * release function.
+ */
+static void ipmi_dev_release(struct device *dev)
+{ }
+
+int register_ipmi_device(struct ipmi_device *ipmidev)
+{
+	ipmidev->dev.bus = &ipmi_bus_type;
+	ipmidev->dev.parent = &ipmi_bus;
+	ipmidev->dev.release = ipmi_dev_release;
+	strncpy(ipmidev->dev.bus_id, ipmidev->name, BUS_ID_SIZE);
+	return device_register(&ipmidev->dev);
+}
+EXPORT_SYMBOL(register_ipmi_device);
+
+void unregister_ipmi_device(struct ipmi_device *ipmidev)
+{
+	device_unregister(&ipmidev->dev);
+}
+EXPORT_SYMBOL(unregister_ipmi_device);
+
+/*
+ * Crude driver interface.
+ */
+
+
+static ssize_t show_version(struct device_driver *driver, char *buf)
+{
+	struct ipmi_driver *ldriver = to_ipmi_driver(driver);
+
+	sprintf(buf, "%s\n", ldriver->version);
+	return strlen(buf);
+}
+
+
+int register_ipmi_driver(struct ipmi_driver *driver)
+{
+	int ret;
+
+	driver->driver.bus = &ipmi_bus_type;
+	ret = driver_register(&driver->driver);
+	if (ret)
+		return ret;
+	driver->version_attr.attr.name = "version";
+	driver->version_attr.attr.owner = driver->module;
+	driver->version_attr.attr.mode = S_IRUGO;
+	driver->version_attr.show = show_version;
+	driver->version_attr.store = NULL;
+	return driver_create_file(&driver->driver, &driver->version_attr);
+}
+EXPORT_SYMBOL(register_ipmi_driver);
+
+void unregister_ipmi_driver(struct ipmi_driver *driver)
+{
+	driver_unregister(&driver->driver);
+}
+EXPORT_SYMBOL(unregister_ipmi_driver);
+
+
+static int __init ipmi_bus_init(void)
+{
+	int ret;
+
+	ret = bus_register(&ipmi_bus_type);
+	if (ret)
+		return ret;
+	if (bus_create_file(&ipmi_bus_type, &bus_attr_version))
+		printk(KERN_NOTICE "Unable to create version attribute\n");
+	ret = device_register(&ipmi_bus);
+	if (ret)
+		printk(KERN_NOTICE "Unable to register ipmi0\n");
+	return ret;
+}
+
+static void ipmi_bus_exit(void)
+{
+	device_unregister(&ipmi_bus);
+	bus_unregister(&ipmi_bus_type);
+}
+
+module_init(ipmi_bus_init);
+module_exit(ipmi_bus_exit);
diff --git a/drivers/char/ipmi/ipmibus.h b/drivers/char/ipmi/ipmibus.h
new file mode 100644
index 0000000..9ab5751
--- /dev/null
+++ b/drivers/char/ipmi/ipmibus.h
@@ -0,0 +1,36 @@
+/*
+ * Definitions for the virtual ipmi bus.
+ *
+ * ipmibus.h,v 1.4 2004/08/20 18:49:44 corbet
+ */
+
+extern struct bus_type ipmi_bus_type;
+
+/*
+ * The ipmi driver type.
+ */
+struct ipmi_driver {
+	char *version;
+	struct module *module;
+	struct device_driver driver;
+	struct driver_attribute version_attr;
+};
+
+#define to_ipmi_driver(drv) container_of(drv, struct ipmi_driver, driver);
+
+/*
+ * A device type for things "plugged" into the ipmi bus.
+ */
+
+struct ipmi_device {
+	char *name;
+	struct ipmi_driver *driver;
+	struct device dev;
+};
+
+#define to_ipmi_device(dev) container_of(dev, struct ipmi_device, dev);
+
+extern int register_ipmi_device(struct ipmi_device *);
+extern void unregister_ipmi_device(struct ipmi_device *);
+extern int register_ipmi_driver(struct ipmi_driver *);
+extern void unregister_ipmi_driver(struct ipmi_driver *);
-- 
1.6.0.90.g436ed

