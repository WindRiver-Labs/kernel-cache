From 52779e855d49d3acc82d017d4a4872c5af7c9bbf Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 1 Mar 2010 03:41:33 -0800
Subject: [PATCH] kmemcheck fixes for warnings

fs: introduce __getname_gfp()
commit 3446a8aa7ebcbc0a799e5e8fc4f2da0738d6bc21

The purpose of this change is to allow __getname() users to pass a
custom GFP mask to kmem_cache_alloc(). This is needed for annotating
a certain kmemcheck false positive.

And some warnings fixes:
commit 3b5c760efcddf1ebdd39a2035b554e96febd7466
commit 7a0aeb14e18ad59394bd9bbc6e57fb345819e748

Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
---
 include/linux/fs.h |    5 +++--
 init/do_mounts.c   |    3 ++-
 kernel/signal.c    |   11 ++++++++---
 3 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 909e13e..4b00567 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1634,8 +1634,9 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-#define __getname()	kmem_cache_alloc(names_cachep, GFP_KERNEL)
-#define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
+#define __getname_gfp(gfp)	kmem_cache_alloc(names_cachep, (gfp))
+#define __getname()		__getname_gfp(GFP_KERNEL)
+#define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
 #define putname(name)   __putname(name)
 #else
diff --git a/init/do_mounts.c b/init/do_mounts.c
index c225bc5..60ce69c 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -229,7 +229,8 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 void __init mount_block_root(char *name, int flags)
 {
-	char *fs_names = __getname();
+	char *fs_names = __getname_gfp(GFP_KERNEL
+		| __GFP_NOTRACK_FALSE_POSITIVE);
 	char *p;
 #ifdef CONFIG_BLOCK
 	char b[BDEVNAME_SIZE];
diff --git a/kernel/signal.c b/kernel/signal.c
index efcdc95..0fbadec 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -802,6 +802,7 @@ static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
 {
 	struct sigpending *pending;
 	struct sigqueue *q;
+	int override_rlimit;
 
 	assert_spin_locked(&t->sighand->siglock);
 	if (!prepare_signal(sig, t))
@@ -830,9 +831,13 @@ static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
 	   make sure at least one signal gets delivered and don't
 	   pass on the info struct.  */
 
-	q = __sigqueue_alloc(t, GFP_ATOMIC, (sig < SIGRTMIN &&
-					     (is_si_special(info) ||
-					      info->si_code >= 0)));
+	if (sig < SIGRTMIN)
+		override_rlimit = (is_si_special(info) || info->si_code >= 0);
+	else
+		override_rlimit = 0;
+
+	q = __sigqueue_alloc(t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,
+		override_rlimit);
 	if (q) {
 		list_add_tail(&q->list, &pending->list);
 		switch ((unsigned long) info) {
-- 
1.6.0.3

