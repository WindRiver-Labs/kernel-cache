From b5585c3a14eb21a1222229977fd972eddb2acec3 Mon Sep 17 00:00:00 2001
From: Razvan Stefanescu <razvan.stefanescu@freescale.com>
Date: Mon, 13 Jul 2015 16:13:49 +0300
Subject: [PATCH 158/214] dpaa2-ethsw: Add support for link state update

Use interrupts to detect link state changes and update it accordingly.

Signed-off-by: Razvan Stefanescu <razvan.stefanescu@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-dpaa2/ethsw/switch.c | 157 +++++++++++++++++++++++++++++++
 1 file changed, 157 insertions(+)

diff --git a/drivers/staging/fsl-dpaa2/ethsw/switch.c b/drivers/staging/fsl-dpaa2/ethsw/switch.c
index 41a30f7..ffa7d69 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/switch.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/switch.c
@@ -43,6 +43,9 @@
 #include "dpsw.h"
 #include "dpsw-cmd.h"
 
+/* IRQ index */
+#define DPSW_MAX_IRQ_NUM		2
+
 #define ETHSW_VLAN_MEMBER	1
 #define ETHSW_VLAN_UNTAGGED	2
 #define ETHSW_VLAN_PVID		4
@@ -1217,6 +1220,151 @@ static const struct ethtool_ops ethsw_port_ethtool_ops = {
 /* -------------------------------------------------------------------------- */
 /* ethsw driver functions */
 
+static int ethsw_links_state_update(struct ethsw_dev_priv *priv)
+{
+	struct list_head	*pos;
+	struct ethsw_port_priv	*port_priv;
+	int err;
+
+	list_for_each(pos, &priv->port_list) {
+		port_priv = list_entry(pos, struct ethsw_port_priv,
+				       list);
+
+		err = _ethsw_port_carrier_state_sync(port_priv->netdev);
+		if (err)
+			netdev_err(port_priv->netdev,
+				   "_ethsw_port_carrier_state_sync err %d\n",
+				   err);
+	}
+
+	return 0;
+}
+
+static irqreturn_t ethsw_irq0_handler(int irq_num, void *arg)
+{
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t _ethsw_irq0_handler_thread(int irq_num, void *arg)
+{
+	struct device		*dev = (struct device *)arg;
+	struct fsl_mc_device	*sw_dev = to_fsl_mc_device(dev);
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct ethsw_dev_priv	*priv = netdev_priv(netdev);
+
+	struct fsl_mc_io *io = priv->mc_io;
+	uint16_t token = priv->dpsw_handle;
+	int irq_index = DPSW_IRQ_INDEX_IF;
+	uint32_t status = 0, clear = 0;
+	int err;
+
+	/* Sanity check */
+	if (WARN_ON(!sw_dev || !sw_dev->irqs || !sw_dev->irqs[irq_index]))
+		goto out;
+	if (WARN_ON(sw_dev->irqs[irq_index]->irq_number != irq_num))
+		goto out;
+
+	err = dpsw_get_irq_status(io, 0, token, irq_index, &status);
+	if (unlikely(err)) {
+		netdev_err(netdev, "Can't get irq status (err %d)", err);
+		clear = 0xffffffff;
+		goto out;
+	}
+
+	/* FIXME clear irq status */
+
+	if (status & DPSW_IRQ_EVENT_LINK_CHANGED) {
+		clear |= DPSW_IRQ_EVENT_LINK_CHANGED;
+
+		err = ethsw_links_state_update(priv);
+		if (unlikely(err))
+			goto out;
+	}
+out:
+	err = dpsw_clear_irq_status(io, 0, token, irq_index, clear);
+	if (unlikely(err))
+		netdev_err(netdev, "Can't clear irq status (err %d)", err);
+
+	return IRQ_HANDLED;
+}
+
+static int ethsw_setup_irqs(struct fsl_mc_device *sw_dev)
+{
+	struct device		*dev = &sw_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct ethsw_dev_priv	*priv = netdev_priv(netdev);
+	int err = 0;
+	struct fsl_mc_device_irq *irq;
+	const int irq_index = DPSW_IRQ_INDEX_IF;
+	uint32_t mask = ~0x0u;	/* FIXME: unmask handled irqs */
+
+	err = fsl_mc_allocate_irqs(sw_dev);
+	if (unlikely(err)) {
+		dev_err(dev, "MC irqs allocation failed\n");
+		return err;
+	}
+
+	if (WARN_ON(sw_dev->obj_desc.irq_count != DPSW_MAX_IRQ_NUM)) {
+		err = -EINVAL;
+		goto free_irq;
+	}
+
+	err = dpsw_set_irq_enable(priv->mc_io, 0, priv->dpsw_handle,
+				  irq_index, 0);
+	if (unlikely(err)) {
+		dev_err(dev, "dpsw_set_irq_enable err %d\n", err);
+		goto free_irq;
+	}
+
+	irq = sw_dev->irqs[irq_index];
+
+	err = devm_request_threaded_irq(dev, irq->irq_number,
+					ethsw_irq0_handler,
+					_ethsw_irq0_handler_thread,
+					IRQF_NO_SUSPEND | IRQF_ONESHOT,
+					dev_name(dev), dev);
+	if (unlikely(err)) {
+		dev_err(dev, "devm_request_threaded_irq(): %d", err);
+		goto free_irq;
+	}
+
+	err = dpsw_set_irq_mask(priv->mc_io, 0, priv->dpsw_handle,
+				irq_index, mask);
+	if (unlikely(err)) {
+		dev_err(dev, "dpsw_set_irq_mask(): %d", err);
+		goto free_devm_irq;
+	}
+
+	err = dpsw_set_irq_enable(priv->mc_io, 0, priv->dpsw_handle,
+				  irq_index, 1);
+	if (unlikely(err)) {
+		dev_err(dev, "dpsw_set_irq_enable(): %d", err);
+		goto free_devm_irq;
+	}
+
+	return 0;
+
+free_devm_irq:
+	devm_free_irq(dev, irq->irq_number, dev);
+free_irq:
+	fsl_mc_free_irqs(sw_dev);
+	return err;
+}
+
+static void ethsw_teardown_irqs(struct fsl_mc_device *sw_dev)
+{
+	struct device		*dev = &sw_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct ethsw_dev_priv	*priv = netdev_priv(netdev);
+
+	dpsw_set_irq_enable(priv->mc_io, 0, priv->dpsw_handle,
+			      DPSW_IRQ_INDEX_IF, 0);
+	devm_free_irq(dev,
+		      sw_dev->irqs[DPSW_IRQ_INDEX_IF]->irq_number,
+		      dev);
+	fsl_mc_free_irqs(sw_dev);
+}
+
 static int __cold
 ethsw_init(struct fsl_mc_device *sw_dev)
 {
@@ -1335,6 +1483,8 @@ ethsw_remove(struct fsl_mc_device *sw_dev)
 		free_netdev(port_priv->netdev);
 	}
 
+	ethsw_teardown_irqs(sw_dev);
+
 	unregister_netdev(netdev);
 
 	ethsw_takedown(sw_dev);
@@ -1491,6 +1641,13 @@ ethsw_probe(struct fsl_mc_device *sw_dev)
 	if (err)
 		dev_warn(dev, "dev_open err %d\n", err);
 
+	/* setup irqs */
+	err = ethsw_setup_irqs(sw_dev);
+	if (unlikely(err)) {
+		dev_warn(dev, "ethsw_setup_irqs err %d\n", err);
+		goto err_takedown;
+	}
+
 	dev_info(&netdev->dev,
 		 "probed %d port switch\n", priv->sw_attr.num_ifs);
 	return 0;
-- 
2.5.3

