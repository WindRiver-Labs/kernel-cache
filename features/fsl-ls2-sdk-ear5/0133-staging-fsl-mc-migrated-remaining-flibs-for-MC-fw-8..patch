From 89848e58ceb607e85b5d8b94c2eac4f0865c2ef0 Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Tue, 30 Jun 2015 17:48:32 -0500
Subject: [PATCH 133/214] staging: fsl-mc: migrated remaining flibs for MC fw
 8.0.0

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: Idfd54300ce12d26a42ce151a53d43b342fe526c8
Reviewed-on: http://git.am.freescale.net:8181/39027
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c     |  119 ++-
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c |   12 +-
 drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h      |   89 +-
 drivers/staging/fsl-dpaa2/ethernet/dpni.c          |  478 ++++++---
 drivers/staging/fsl-dpaa2/ethernet/dpni.h          |  641 +++++++----
 drivers/staging/fsl-dpaa2/ethsw/dpsw-cmd.h         |  119 ++-
 drivers/staging/fsl-dpaa2/ethsw/dpsw.c             |  490 ++++++---
 drivers/staging/fsl-dpaa2/ethsw/dpsw.h             | 1129 ++++++++++++--------
 drivers/staging/fsl-dpaa2/ethsw/switch.c           |   70 +-
 drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h         |   20 +-
 drivers/staging/fsl-dpaa2/evb/dpdmux.c             |  155 ++-
 drivers/staging/fsl-dpaa2/evb/dpdmux.h             |  224 ++--
 drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h          |   18 +-
 drivers/staging/fsl-dpaa2/mac/dpmac.c              |  143 ++-
 drivers/staging/fsl-dpaa2/mac/dpmac.h              |  172 +--
 drivers/staging/fsl-dpaa2/mac/mac.c                |   29 +-
 drivers/staging/fsl-mc/bus/dpbp.c                  |  122 ++-
 drivers/staging/fsl-mc/bus/dpio/dpio-drv.c         |   34 +-
 drivers/staging/fsl-mc/bus/dpio/dpio.c             |  164 ++-
 drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h         |  161 ++-
 drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h     |   31 +-
 drivers/staging/fsl-mc/include/dpbp-cmd.h          |   18 +-
 drivers/staging/fsl-mc/include/dpbp.h              |   91 +-
 drivers/staging/fsl-mc/include/dpcon-cmd.h         |   62 +-
 24 files changed, 3083 insertions(+), 1508 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 6c62683..67a5898 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@ -690,7 +690,7 @@ static int ldpaa_eth_set_rx_csum(struct ldpaa_eth_priv *priv, bool enable)
 {
 	int err;
 
-	err = dpni_set_l3_chksum_validation(priv->mc_io, priv->mc_token,
+	err = dpni_set_l3_chksum_validation(priv->mc_io, 0, priv->mc_token,
 					    enable);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev,
@@ -698,7 +698,7 @@ static int ldpaa_eth_set_rx_csum(struct ldpaa_eth_priv *priv, bool enable)
 		return err;
 	}
 
-	err = dpni_set_l4_chksum_validation(priv->mc_io, priv->mc_token,
+	err = dpni_set_l4_chksum_validation(priv->mc_io, 0, priv->mc_token,
 					    enable);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev,
@@ -728,7 +728,7 @@ static int ldpaa_eth_set_tx_csum(struct ldpaa_eth_priv *priv, bool enable)
 			continue;
 
 		/* The Tx flowid is kept in the corresponding TxConf FQ. */
-		err = dpni_set_tx_flow(priv->mc_io, priv->mc_token,
+		err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
 				       &fq->flowid, &tx_flow_cfg);
 		if (unlikely(err)) {
 			netdev_err(priv->net_dev, "dpni_set_tx_flow failed\n");
@@ -844,7 +844,7 @@ static int __cold ldpaa_eth_open(struct net_device *net_dev)
 	 */
 	netif_tx_stop_all_queues(net_dev);
 
-	err = dpni_enable(priv->mc_io, priv->mc_token);
+	err = dpni_enable(priv->mc_io, 0, priv->mc_token);
 	if (err < 0) {
 		dev_err(net_dev->dev.parent, "dpni_enable() failed\n");
 		goto enable_err;
@@ -865,7 +865,7 @@ static int __cold ldpaa_eth_stop(struct net_device *net_dev)
 
 	/* Stop Tx and Rx traffic */
 	netif_tx_stop_all_queues(net_dev);
-	dpni_disable(priv->mc_io, priv->mc_token);
+	dpni_disable(priv->mc_io, 0, priv->mc_token);
 
 	/* TODO: Make sure queues are drained before if down is complete! */
 	msleep(100);
@@ -922,7 +922,7 @@ static int ldpaa_eth_set_addr(struct net_device *net_dev, void *addr)
 		return err;
 	}
 
-	err = dpni_set_primary_mac_addr(priv->mc_io, priv->mc_token,
+	err = dpni_set_primary_mac_addr(priv->mc_io, 0, priv->mc_token,
 					net_dev->dev_addr);
 	if (err) {
 		dev_err(dev, "dpni_set_primary_mac_addr() failed (%d)\n", err);
@@ -970,7 +970,7 @@ static int ldpaa_eth_change_mtu(struct net_device *net_dev, int mtu)
 	/* Set the maximum Rx frame length to match the transmit side;
 	 * account for L2 headers when computing the MFL
 	 */
-	err = dpni_set_max_frame_length(priv->mc_io, priv->mc_token,
+	err = dpni_set_max_frame_length(priv->mc_io, 0, priv->mc_token,
 					(uint16_t)LDPAA_ETH_L2_MAX_FRM(mtu));
 	if (err) {
 		netdev_err(net_dev, "dpni_set_mfl() failed\n");
@@ -998,7 +998,8 @@ static inline void _ldpaa_eth_hw_add_uc_addr(const struct net_device *net_dev,
 	int err;
 
 	netdev_for_each_uc_addr(ha, net_dev) {
-		err = dpni_add_mac_addr(priv->mc_io, priv->mc_token, ha->addr);
+		err = dpni_add_mac_addr(priv->mc_io, 0, priv->mc_token,
+					ha->addr);
 		LDPAA_ETH_WARN_IF_ERR(err, priv->net_dev,
 				      "Could not add ucast MAC %pM to the filtering table (err %d)\n",
 				      ha->addr, err);
@@ -1015,7 +1016,8 @@ static inline void _ldpaa_eth_hw_add_mc_addr(const struct net_device *net_dev,
 	int err;
 
 	netdev_for_each_mc_addr(ha, net_dev) {
-		err = dpni_add_mac_addr(priv->mc_io, priv->mc_token, ha->addr);
+		err = dpni_add_mac_addr(priv->mc_io, 0, priv->mc_token,
+					ha->addr);
 		LDPAA_ETH_WARN_IF_ERR(err, priv->net_dev,
 				      "Could not add mcast MAC %pM to the filtering table (err %d)\n",
 				      ha->addr, err);
@@ -1069,16 +1071,16 @@ static void ldpaa_eth_set_rx_mode(struct net_device *net_dev)
 		 * making an MC call to find it is expensive; so set uc promisc
 		 * nonetheless.
 		 */
-		err = dpni_set_unicast_promisc(mc_io, mc_token, 1);
+		err = dpni_set_unicast_promisc(mc_io, 0, mc_token, 1);
 		LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't set uc promisc\n");
 
 		/* Actual uc table reconstruction. */
-		err = dpni_clear_mac_filters(mc_io, mc_token, 1, 0);
+		err = dpni_clear_mac_filters(mc_io, 0, mc_token, 1, 0);
 		LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't clear uc filters\n");
 		_ldpaa_eth_hw_add_uc_addr(net_dev, priv);
 
 		/* Finally, clear uc promisc and set mc promisc as requested. */
-		err = dpni_set_unicast_promisc(mc_io, mc_token, 0);
+		err = dpni_set_unicast_promisc(mc_io, 0, mc_token, 0);
 		LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't clear uc promisc\n");
 		goto force_mc_promisc;
 	}
@@ -1086,13 +1088,13 @@ static void ldpaa_eth_set_rx_mode(struct net_device *net_dev)
 	/* Neither unicast, nor multicast promisc will be on... eventually.
 	 * For now, rebuild mac filtering tables while forcing both of them on.
 	 */
-	err = dpni_set_unicast_promisc(mc_io, mc_token, 1);
+	err = dpni_set_unicast_promisc(mc_io, 0, mc_token, 1);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't set uc promisc (%d)\n", err);
-	err = dpni_set_multicast_promisc(mc_io, mc_token, 1);
+	err = dpni_set_multicast_promisc(mc_io, 0, mc_token, 1);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't set mc promisc (%d)\n", err);
 
 	/* Actual mac filtering tables reconstruction */
-	err = dpni_clear_mac_filters(mc_io, mc_token, 1, 1);
+	err = dpni_clear_mac_filters(mc_io, 0, mc_token, 1, 1);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't clear mac filters\n");
 	_ldpaa_eth_hw_add_mc_addr(net_dev, priv);
 	_ldpaa_eth_hw_add_uc_addr(net_dev, priv);
@@ -1100,18 +1102,18 @@ static void ldpaa_eth_set_rx_mode(struct net_device *net_dev)
 	/* Now we can clear both ucast and mcast promisc, without risking
 	 * to drop legitimate frames anymore.
 	 */
-	err = dpni_set_unicast_promisc(mc_io, mc_token, 0);
+	err = dpni_set_unicast_promisc(mc_io, 0, mc_token, 0);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't clear ucast promisc\n");
-	err = dpni_set_multicast_promisc(mc_io, mc_token, 0);
+	err = dpni_set_multicast_promisc(mc_io, 0, mc_token, 0);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't clear mcast promisc\n");
 
 	return;
 
 force_promisc:
-	err = dpni_set_unicast_promisc(mc_io, mc_token, 1);
+	err = dpni_set_unicast_promisc(mc_io, 0, mc_token, 1);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't set ucast promisc\n");
 force_mc_promisc:
-	err = dpni_set_multicast_promisc(mc_io, mc_token, 1);
+	err = dpni_set_multicast_promisc(mc_io, 0, mc_token, 1);
 	LDPAA_ETH_WARN_IF_ERR(err, net_dev, "Can't set mcast promisc\n");
 }
 
@@ -1465,20 +1467,20 @@ static int __cold ldpaa_dpbp_setup(struct ldpaa_eth_priv *priv)
 
 	priv->dpbp_dev = dpbp_dev;
 
-	err = dpbp_open(priv->mc_io, priv->dpbp_dev->obj_desc.id,
+	err = dpbp_open(priv->mc_io, 0, priv->dpbp_dev->obj_desc.id,
 			&dpbp_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpbp_open() failed\n");
 		goto err_open;
 	}
 
-	err = dpbp_enable(priv->mc_io, dpbp_dev->mc_handle);
+	err = dpbp_enable(priv->mc_io, 0, dpbp_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpbp_enable() failed\n");
 		goto err_enable;
 	}
 
-	err = dpbp_get_attributes(priv->mc_io, dpbp_dev->mc_handle,
+	err = dpbp_get_attributes(priv->mc_io, 0, dpbp_dev->mc_handle,
 				  &priv->dpbp_attrs);
 	if (err) {
 		dev_err(dev, "dpbp_get_attributes() failed\n");
@@ -1488,9 +1490,9 @@ static int __cold ldpaa_dpbp_setup(struct ldpaa_eth_priv *priv)
 	return 0;
 
 err_get_attr:
-	dpbp_disable(priv->mc_io, dpbp_dev->mc_handle);
+	dpbp_disable(priv->mc_io, 0, dpbp_dev->mc_handle);
 err_enable:
-	dpbp_close(priv->mc_io, dpbp_dev->mc_handle);
+	dpbp_close(priv->mc_io, 0, dpbp_dev->mc_handle);
 err_open:
 	fsl_mc_object_free(dpbp_dev);
 
@@ -1513,8 +1515,8 @@ static void __cold __ldpaa_dpbp_free(struct ldpaa_eth_priv *priv)
 static void __cold ldpaa_dpbp_free(struct ldpaa_eth_priv *priv)
 {
 	__ldpaa_dpbp_free(priv);
-	dpbp_disable(priv->mc_io, priv->dpbp_dev->mc_handle);
-	dpbp_close(priv->mc_io, priv->dpbp_dev->mc_handle);
+	dpbp_disable(priv->mc_io, 0, priv->dpbp_dev->mc_handle);
+	dpbp_close(priv->mc_io, 0, priv->dpbp_dev->mc_handle);
 	fsl_mc_object_free(priv->dpbp_dev);
 }
 
@@ -1531,7 +1533,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	priv->dpni_id = ls_dev->obj_desc.id;
 
 	/* and get a handle for the DPNI this interface is associate with */
-	err = dpni_open(priv->mc_io, priv->dpni_id, &priv->mc_token);
+	err = dpni_open(priv->mc_io, 0, priv->dpni_id, &priv->mc_token);
 	if (err) {
 		dev_err(dev, "dpni_open() failed\n");
 		goto err_open;
@@ -1540,7 +1542,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	/* FIXME Alex's moral compass says this must be done */
 	ls_dev->mc_io = priv->mc_io;
 	ls_dev->mc_handle = priv->mc_token;
-	err = dpni_get_attributes(priv->mc_io, priv->mc_token,
+	err = dpni_get_attributes(priv->mc_io, 0, priv->mc_token,
 				  &priv->dpni_attrs);
 	if (err) {
 		dev_err(dev, "dpni_get_attributes() failed (err=%d)\n", err);
@@ -1555,7 +1557,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	priv->buf_layout.pass_frame_status = true;
 	priv->buf_layout.private_data_size = LDPAA_ETH_SWA_SIZE;
 	/* ...rx, ... */
-	err = dpni_set_rx_buffer_layout(priv->mc_io, priv->mc_token,
+	err = dpni_set_rx_buffer_layout(priv->mc_io, 0, priv->mc_token,
 					&priv->buf_layout);
 	if (err) {
 		dev_err(dev, "dpni_set_rx_buffer_layout() failed");
@@ -1563,7 +1565,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	}
 	/* ... tx, ... */
 	priv->buf_layout.options &= ~DPNI_BUF_LAYOUT_OPT_PARSER_RESULT;
-	err = dpni_set_tx_buffer_layout(priv->mc_io, priv->mc_token,
+	err = dpni_set_tx_buffer_layout(priv->mc_io, 0, priv->mc_token,
 					&priv->buf_layout);
 	if (err) {
 		dev_err(dev, "dpni_set_tx_buffer_layout() failed");
@@ -1571,7 +1573,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	}
 	/* ... tx-confirm. */
 	priv->buf_layout.options &= ~DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE;
-	err = dpni_set_tx_conf_buffer_layout(priv->mc_io, priv->mc_token,
+	err = dpni_set_tx_conf_buffer_layout(priv->mc_io, 0, priv->mc_token,
 					     &priv->buf_layout);
 	if (err) {
 		dev_err(dev, "dpni_set_tx_conf_buffer_layout() failed");
@@ -1580,7 +1582,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 	/* Now that we've set our tx buffer layout, retrieve the minimum
 	 * required tx data offset.
 	 */
-	err = dpni_get_tx_data_offset(priv->mc_io, priv->mc_token,
+	err = dpni_get_tx_data_offset(priv->mc_io, 0, priv->mc_token,
 				      &priv->tx_data_offset);
 	if (err) {
 		dev_err(dev, "dpni_get_tx_data_offset() failed\n");
@@ -1604,7 +1606,7 @@ static int __cold ldpaa_dpni_setup(struct fsl_mc_device *ls_dev)
 err_data_offset:
 err_buf_layout:
 err_get_attr:
-	dpni_close(priv->mc_io, priv->mc_token);
+	dpni_close(priv->mc_io, 0, priv->mc_token);
 err_open:
 	return err;
 }
@@ -1613,12 +1615,12 @@ static void ldpaa_dpni_free(struct ldpaa_eth_priv *priv)
 {
 	int err;
 
-	err = dpni_reset(priv->mc_io, priv->mc_token);
+	err = dpni_reset(priv->mc_io, 0, priv->mc_token);
 	if (unlikely(err))
 		netdev_warn(priv->net_dev, "dpni_reset() failed (err %d)\n",
 			    err);
 
-	dpni_close(priv->mc_io, priv->mc_token);
+	dpni_close(priv->mc_io, 0, priv->mc_token);
 }
 
 static int ldpaa_rx_flow_setup(struct ldpaa_eth_priv *priv,
@@ -1634,7 +1636,7 @@ static int ldpaa_rx_flow_setup(struct ldpaa_eth_priv *priv,
 	queue_cfg.dest_cfg.priority = 3;
 	queue_cfg.user_ctx = fq->nctx.qman64;
 	queue_cfg.dest_cfg.dest_id = fq->nctx.dpio_id;
-	err = dpni_set_rx_flow(priv->mc_io, priv->mc_token, 0, fq->flowid,
+	err = dpni_set_rx_flow(priv->mc_io, 0, priv->mc_token, 0, fq->flowid,
 			       &queue_cfg);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev, "dpni_set_rx_flow() failed\n");
@@ -1642,7 +1644,7 @@ static int ldpaa_rx_flow_setup(struct ldpaa_eth_priv *priv,
 	}
 
 	/* Get the actual FQID that was assigned by MC */
-	err = dpni_get_rx_flow(priv->mc_io, priv->mc_token, 0, fq->flowid,
+	err = dpni_get_rx_flow(priv->mc_io, 0, priv->mc_token, 0, fq->flowid,
 			       &rx_queue_attr);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev, "dpni_get_rx_flow() failed\n");
@@ -1672,14 +1674,14 @@ static int ldpaa_tx_flow_setup(struct ldpaa_eth_priv *priv,
 	queue_cfg.dest_cfg.dest_id = fq->nctx.dpio_id;
 	queue_cfg.dest_cfg.priority = 3;
 	tx_flow_cfg.conf_err_cfg.queue_cfg = queue_cfg;
-	err = dpni_set_tx_flow(priv->mc_io, priv->mc_token,
+	err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
 			       &fq->flowid, &tx_flow_cfg);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev, "dpni_set_tx_flow() failed\n");
 		return err;
 	}
 
-	err = dpni_get_tx_flow(priv->mc_io, priv->mc_token,
+	err = dpni_get_tx_flow(priv->mc_io, 0, priv->mc_token,
 			       fq->flowid, &tx_flow_attr);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev, "dpni_get_tx_flow() failed\n");
@@ -1737,7 +1739,7 @@ static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 	pools_params.num_dpbp = 1;
 	pools_params.pools[0].dpbp_id = priv->dpbp_dev->obj_desc.id;
 	pools_params.pools[0].buffer_size = LDPAA_ETH_RX_BUFFER_SIZE;
-	err = dpni_set_pools(priv->mc_io, priv->mc_token, &pools_params);
+	err = dpni_set_pools(priv->mc_io, 0, priv->mc_token, &pools_params);
 	if (unlikely(err)) {
 		dev_err(dev, "dpni_set_pools() failed\n");
 		return err;
@@ -1762,7 +1764,8 @@ static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 #else
 	err_cfg.error_action = DPNI_ERROR_ACTION_DISCARD;
 #endif
-	err = dpni_set_errors_behavior(priv->mc_io, priv->mc_token, &err_cfg);
+	err = dpni_set_errors_behavior(priv->mc_io, 0, priv->mc_token,
+				       &err_cfg);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev, "dpni_set_errors_behavior failed\n");
 		return err;
@@ -1791,7 +1794,7 @@ static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 			return err;
 	}
 
-	err = dpni_get_qdid(priv->mc_io, priv->mc_token, &priv->tx_qdid);
+	err = dpni_get_qdid(priv->mc_io, 0, priv->mc_token, &priv->tx_qdid);
 	if (unlikely(err)) {
 		netdev_err(net_dev, "dpni_get_qdid() failed\n");
 		return err;
@@ -1842,7 +1845,8 @@ static int ldpaa_eth_netdev_init(struct net_device *net_dev)
 	net_dev->netdev_ops = &ldpaa_eth_ops;
 
 	/* If the DPL contains all-0 mac_addr, set a random hardware address */
-	err = dpni_get_primary_mac_addr(priv->mc_io, priv->mc_token, mac_addr);
+	err = dpni_get_primary_mac_addr(priv->mc_io, 0, priv->mc_token,
+					mac_addr);
 	if (unlikely(err)) {
 		netdev_err(net_dev, "dpni_get_primary_mac_addr() failed (%d)",
 			   err);
@@ -1855,7 +1859,7 @@ static int ldpaa_eth_netdev_init(struct net_device *net_dev)
 		eth_hw_addr_random(net_dev);
 		netdev_info(net_dev, "Replacing all-zero hwaddr with %pM",
 			    net_dev->dev_addr);
-		err = dpni_set_primary_mac_addr(priv->mc_io, priv->mc_token,
+		err = dpni_set_primary_mac_addr(priv->mc_io, 0, priv->mc_token,
 						net_dev->dev_addr);
 		if (unlikely(err)) {
 			netdev_err(net_dev,
@@ -1896,7 +1900,7 @@ static int ldpaa_link_state_update(struct ldpaa_eth_priv *priv)
 	struct dpni_link_state state;
 	int err;
 
-	err = dpni_get_link_state(priv->mc_io, priv->mc_token, &state);
+	err = dpni_get_link_state(priv->mc_io, 0, priv->mc_token, &state);
 	if (unlikely(err)) {
 		netdev_err(priv->net_dev,
 			   "dpni_get_link_state() failed\n");
@@ -1959,7 +1963,7 @@ static irqreturn_t dpni_irq0_handler_thread(int irq_num, void *arg)
 	if (WARN_ON(dpni_dev->irqs[irq_index]->irq_number != irq_num))
 		goto out;
 
-	err = dpni_get_irq_status(dpni_dev->mc_io, dpni_dev->mc_handle,
+	err = dpni_get_irq_status(dpni_dev->mc_io, 0, dpni_dev->mc_handle,
 				  irq_index, &status);
 	if (unlikely(err)) {
 		netdev_err(net_dev, "Can't get irq status (err %d)", err);
@@ -1973,7 +1977,7 @@ static irqreturn_t dpni_irq0_handler_thread(int irq_num, void *arg)
 	}
 
 out:
-	dpni_clear_irq_status(dpni_dev->mc_io, dpni_dev->mc_handle,
+	dpni_clear_irq_status(dpni_dev->mc_io, 0, dpni_dev->mc_handle,
 			      irq_index, clear);
 	return IRQ_HANDLED;
 }
@@ -1982,6 +1986,7 @@ static int ldpaa_eth_setup_irqs(struct fsl_mc_device *ls_dev)
 {
 	int err = 0;
 	struct fsl_mc_device_irq *irq;
+	struct dpni_irq_cfg irq_cfg;
 	int irq_count = ls_dev->obj_desc.irq_count;
 	uint8_t irq_index = DPNI_IRQ_INDEX;
 	uint32_t mask = ~0x0u;
@@ -2001,22 +2006,24 @@ static int ldpaa_eth_setup_irqs(struct fsl_mc_device *ls_dev)
 		return err;
 	}
 
-	err = dpni_set_irq(ls_dev->mc_io, ls_dev->mc_handle,
-			   irq_index, irq->msi_paddr,
-			   irq->msi_value, irq->irq_number);
+	irq_cfg.addr = irq->msi_paddr;
+	irq_cfg.val = irq->msi_value;
+	irq_cfg.user_irq_id = irq->irq_number;
+	err = dpni_set_irq(ls_dev->mc_io, 0, ls_dev->mc_handle,
+			   irq_index, &irq_cfg);
 	if (err < 0) {
 		dev_err(&ls_dev->dev, "dpni_set_irq(): %d", err);
 		return err;
 	}
 
-	err = dpni_set_irq_mask(ls_dev->mc_io, ls_dev->mc_handle,
+	err = dpni_set_irq_mask(ls_dev->mc_io, 0, ls_dev->mc_handle,
 				irq_index, mask);
 	if (err < 0) {
 		dev_err(&ls_dev->dev, "dpni_set_irq_mask(): %d", err);
 		return err;
 	}
 
-	err = dpni_set_irq_enable(ls_dev->mc_io, ls_dev->mc_handle,
+	err = dpni_set_irq_enable(ls_dev->mc_io, 0, ls_dev->mc_handle,
 				  irq_index, 1);
 	if (err < 0) {
 		dev_err(&ls_dev->dev, "dpni_set_irq_enable(): %d", err);
@@ -2116,7 +2123,7 @@ static ssize_t ldpaa_eth_write_txconf_cpumask(struct device *dev,
 		queue_cfg.dest_cfg.dest_id = priv->fq[i].nctx.dpio_id;
 		queue_cfg.dest_cfg.priority = 2;
 		tx_flow_cfg.conf_err_cfg.queue_cfg = queue_cfg;
-		err = dpni_set_tx_flow(priv->mc_io, priv->mc_token,
+		err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
 				       &priv->fq[i].flowid, &tx_flow_cfg);
 		if (unlikely(err)) {
 			netdev_err(priv->net_dev,
@@ -2124,7 +2131,7 @@ static ssize_t ldpaa_eth_write_txconf_cpumask(struct device *dev,
 			return -EPERM;
 		}
 
-		err = dpni_get_tx_flow(priv->mc_io, priv->mc_token,
+		err = dpni_get_tx_flow(priv->mc_io, 0, priv->mc_token,
 				       priv->fq[i].flowid, &tx_flow_attr);
 		if (unlikely(err)) {
 			netdev_err(priv->net_dev,
@@ -2279,7 +2286,7 @@ ldpaa_eth_probe(struct fsl_mc_device *dpni_dev)
 	 * the MC won't do that for us.
 	 */
 	eth_broadcast_addr(bcast_addr);
-	err = dpni_add_mac_addr(priv->mc_io, priv->mc_token, bcast_addr);
+	err = dpni_add_mac_addr(priv->mc_io, 0, priv->mc_token, bcast_addr);
 	if (err) {
 		netdev_warn(net_dev,
 			    "dpni_add_mac_addr() failed with code %d\n", err);
@@ -2345,7 +2352,7 @@ err_alloc_bp_count:
 err_dpio_setup:
 	ldpaa_eth_napi_del(priv);
 	kfree(priv->cls_rule);
-	dpni_close(priv->mc_io, priv->mc_token);
+	dpni_close(priv->mc_io, 0, priv->mc_token);
 err_dpni_setup:
 #ifndef CONFIG_FSL_DPAA2_ETH_LINK_POLL
 	fsl_mc_free_irqs(dpni_dev);
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
index 57099e0..33cc38a 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
@@ -108,7 +108,7 @@ static int __cold ldpaa_get_settings(struct net_device *net_dev,
 	int err = 0;
 	struct ldpaa_eth_priv *priv = netdev_priv(net_dev);
 
-	err = dpni_get_link_state(priv->mc_io, priv->mc_token, &state);
+	err = dpni_get_link_state(priv->mc_io, 0, priv->mc_token, &state);
 	if (unlikely(err)) {
 		netdev_err(net_dev, "ERROR %d getting link state", err);
 		goto out;
@@ -143,7 +143,7 @@ static int __cold ldpaa_set_settings(struct net_device *net_dev,
 	else
 		cfg.options &= ~DPNI_LINK_OPT_HALF_DUPLEX;
 
-	err = dpni_set_link_cfg(priv->mc_io, priv->mc_token, &cfg);
+	err = dpni_set_link_cfg(priv->mc_io, 0, priv->mc_token, &cfg);
 	if (unlikely(err))
 		netdev_err(net_dev, "ERROR %d setting link cfg", err);
 
@@ -206,7 +206,7 @@ static void ldpaa_get_ethtool_stats(struct net_device *net_dev,
 
 	/* Print standard counters, from DPNI statistics */
 	for (i = 0; i < DPNI_CNT_NUM_STATS; i++) {
-		err = dpni_get_counter(priv->mc_io, priv->mc_token, i,
+		err = dpni_get_counter(priv->mc_io, 0, priv->mc_token, i,
 				       data + i);
 		if (err != 0)
 			netdev_warn(net_dev, "Err %d getting DPNI counter %d",
@@ -464,7 +464,7 @@ int ldpaa_set_hash(struct net_device *net_dev, u64 flags)
 		dist_cfg.dist_mode = DPNI_DIST_MODE_HASH;
 	}
 
-	err = dpni_set_rx_tc_dist(priv->mc_io, priv->mc_token, 0, &dist_cfg);
+	err = dpni_set_rx_tc_dist(priv->mc_io, 0, priv->mc_token, 0, &dist_cfg);
 	dma_unmap_single(net_dev->dev.parent, dist_cfg.key_cfg_iova,
 			 LDPAA_CLASSIFIER_DMA_SIZE, DMA_TO_DEVICE);
 	kfree(dma_mem);
@@ -684,10 +684,10 @@ static int ldpaa_do_cls(struct net_device *net_dev,
 
 	/* TODO: no way to control rule order in firmware! */
 	if (add)
-		err = dpni_add_fs_entry(priv->mc_io, priv->mc_token, 0,
+		err = dpni_add_fs_entry(priv->mc_io, 0, priv->mc_token, 0,
 					&rule_cfg, (u16)fs->ring_cookie);
 	else
-		err = dpni_remove_fs_entry(priv->mc_io, priv->mc_token, 0,
+		err = dpni_remove_fs_entry(priv->mc_io, 0, priv->mc_token, 0,
 					   &rule_cfg);
 
 	dma_unmap_single(net_dev->dev.parent, rule_cfg.mask_iova,
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
index 08f25af..8d2b25d 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
@@ -37,7 +37,7 @@
 
 /* DPNI Version */
 #define DPNI_VER_MAJOR				5
-#define DPNI_VER_MINOR				0
+#define DPNI_VER_MINOR				1
 
 /* Command IDs */
 #define DPNI_CMDID_OPEN				0x801
@@ -72,9 +72,10 @@
 #define DPNI_CMDID_SET_L4_CHKSUM_VALIDATION	0x209
 #define DPNI_CMDID_GET_L4_CHKSUM_VALIDATION	0x20A
 #define DPNI_CMDID_SET_ERRORS_BEHAVIOR		0x20B
+#define DPNI_CMDID_SET_TX_CONF_REVOKE		0x20C
 
 #define DPNI_CMDID_GET_QDID			0x210
-#define DPNI_CMDID_GET_SPID			0x211
+#define DPNI_CMDID_GET_SP_INFO			0x211
 #define DPNI_CMDID_GET_TX_DATA_OFFSET		0x212
 #define DPNI_CMDID_GET_COUNTER			0x213
 #define DPNI_CMDID_SET_COUNTER			0x214
@@ -83,7 +84,8 @@
 #define DPNI_CMDID_GET_MAX_FRAME_LENGTH		0x217
 #define DPNI_CMDID_SET_MTU			0x218
 #define DPNI_CMDID_GET_MTU			0x219
-#define DPNI_CMDID_SET_LINK_CFG		0x21A
+#define DPNI_CMDID_SET_LINK_CFG			0x21A
+#define DPNI_CMDID_SET_TX_SHAPING		0x21B
 
 #define DPNI_CMDID_SET_MCAST_PROMISC		0x220
 #define DPNI_CMDID_GET_MCAST_PROMISC		0x221
@@ -124,6 +126,8 @@
 #define DPNI_CMDID_SET_IPR			0x249
 #define DPNI_CMDID_SET_IPF			0x24A
 
+#define DPNI_CMDID_SET_TX_SELECTION			0x250
+
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_OPEN(cmd, dpni_id) \
 	MC_CMD_OP(cmd,	 0,	0,	32,	int,	dpni_id)
@@ -173,6 +177,14 @@ do { \
 #define DPNI_CMD_SET_POOLS(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->num_dpbp); \
+	MC_CMD_OP(cmd, 0, 8,  1,  int,      cfg->pools[0].backup_pool); \
+	MC_CMD_OP(cmd, 0, 9,  1,  int,      cfg->pools[1].backup_pool); \
+	MC_CMD_OP(cmd, 0, 10, 1,  int,      cfg->pools[2].backup_pool); \
+	MC_CMD_OP(cmd, 0, 11, 1,  int,      cfg->pools[3].backup_pool); \
+	MC_CMD_OP(cmd, 0, 12, 1,  int,      cfg->pools[4].backup_pool); \
+	MC_CMD_OP(cmd, 0, 13, 1,  int,      cfg->pools[5].backup_pool); \
+	MC_CMD_OP(cmd, 0, 14, 1,  int,      cfg->pools[6].backup_pool); \
+	MC_CMD_OP(cmd, 0, 15, 1,  int,      cfg->pools[7].backup_pool); \
 	MC_CMD_OP(cmd, 0, 32, 32, int,      cfg->pools[0].dpbp_id); \
 	MC_CMD_OP(cmd, 4, 32, 16, uint16_t, cfg->pools[0].buffer_size);\
 	MC_CMD_OP(cmd, 1, 0,  32, int,      cfg->pools[1].dpbp_id); \
@@ -196,12 +208,12 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPNI_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_CMD_OP(cmd, 2, 0,  32, int,	     user_irq_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -209,11 +221,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPNI_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,      user_irq_id); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,      irq_cfg->user_irq_id); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
@@ -404,8 +416,11 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, qdid)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_SPID(cmd, spid) \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, spid)
+#define DPNI_RSP_GET_SP_INFO(cmd, sp_info) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, sp_info->spids[0]); \
+	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, sp_info->spids[1]); \
+} while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_TX_DATA_OFFSET(cmd, data_offset) \
@@ -442,6 +457,13 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_SET_TX_SHAPING(cmd, tx_shaper) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, tx_shaper->max_burst_size);\
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, tx_shaper->rate_limit);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_MAX_FRAME_LENGTH(cmd, max_frame_length) \
 	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, max_frame_length)
 
@@ -544,6 +566,35 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_SET_TX_SELECTION(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16,  uint16_t, cfg->tc_sched[0].delta_bandwidth);\
+	MC_CMD_OP(cmd, 0, 16,  4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[0].mode); \
+	MC_CMD_OP(cmd, 0, 32, 16,  uint16_t, cfg->tc_sched[1].delta_bandwidth);\
+	MC_CMD_OP(cmd, 0, 48, 4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[1].mode); \
+	MC_CMD_OP(cmd, 1, 0,  16,  uint16_t, cfg->tc_sched[2].delta_bandwidth);\
+	MC_CMD_OP(cmd, 1, 16,  4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[2].mode); \
+	MC_CMD_OP(cmd, 1, 32, 16,  uint16_t, cfg->tc_sched[3].delta_bandwidth);\
+	MC_CMD_OP(cmd, 1, 48, 4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[3].mode); \
+	MC_CMD_OP(cmd, 2, 0,  16,  uint16_t, cfg->tc_sched[4].delta_bandwidth);\
+	MC_CMD_OP(cmd, 2, 16,  4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[4].mode); \
+	MC_CMD_OP(cmd, 2, 32, 16,  uint16_t, cfg->tc_sched[5].delta_bandwidth);\
+	MC_CMD_OP(cmd, 2, 48, 4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[5].mode); \
+	MC_CMD_OP(cmd, 3, 0,  16,  uint16_t, cfg->tc_sched[6].delta_bandwidth);\
+	MC_CMD_OP(cmd, 3, 16,  4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[6].mode); \
+	MC_CMD_OP(cmd, 3, 32, 16,  uint16_t, cfg->tc_sched[7].delta_bandwidth);\
+	MC_CMD_OP(cmd, 3, 48, 4,  enum dpni_tx_schedule_mode, \
+				cfg->tc_sched[7].mode); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_RX_TC_DIST(cmd, tc_id, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->dist_size); \
@@ -611,10 +662,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
 	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
+	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
 	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
 	MC_CMD_OP(cmd, 2, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 2, 32,  32, uint32_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->options); \
 	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
 	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
 		cfg->flc_cfg.frame_data_size);\
@@ -637,6 +689,7 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
 	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
 	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
 	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
 	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
@@ -654,6 +707,7 @@ do { \
 	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
 	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
+	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
 	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options); \
 	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
@@ -671,6 +725,7 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
 	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
 	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type);\
+	MC_CMD_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
 	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
 	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
@@ -703,6 +758,10 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_SET_TX_CONF_REVOKE(cmd, revoke) \
+	MC_CMD_OP(cmd, 0, 0,  1,  int,      revoke)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_QOS_TABLE(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->default_tc); \
@@ -773,7 +832,7 @@ do { \
 	MC_CMD_OP(cmd, 0, 4,  4, enum dpni_policer_color, cfg->default_color); \
 	MC_CMD_OP(cmd, 0, 8,  4, enum dpni_policer_unit, cfg->units); \
 	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t,  cfg->options); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, cfg->options); \
 	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->cir); \
 	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->cbs); \
 	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->eir); \
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.c b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
index 19e4ef0..5a7f7ac 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
@@ -116,14 +116,18 @@ int dpni_prepare_key_cfg(struct dpkg_profile_cfg *cfg,
 	return 0;
 }
 
-int dpni_open(struct fsl_mc_io *mc_io, int dpni_id, uint16_t *token)
+int dpni_open(struct fsl_mc_io *mc_io,
+	      uint32_t cmd_flags,
+	      int dpni_id,
+	      uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPNI_CMD_OPEN(cmd, dpni_id);
 
 	/* send command to mc*/
@@ -137,19 +141,23 @@ int dpni_open(struct fsl_mc_io *mc_io, int dpni_id, uint16_t *token)
 	return 0;
 }
 
-int dpni_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_close(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLOSE,
-					  MC_CMD_PRI_HIGH, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpni_create(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
 		const struct dpni_cfg *cfg,
 		uint16_t *token)
 {
@@ -158,7 +166,7 @@ int dpni_create(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CREATE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  0);
 	DPNI_CMD_CREATE(cmd, cfg);
 
@@ -173,13 +181,15 @@ int dpni_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_destroy(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -187,6 +197,7 @@ int dpni_destroy(struct fsl_mc_io *mc_io, uint16_t token)
 }
 
 int dpni_set_pools(struct fsl_mc_io *mc_io,
+		   uint32_t cmd_flags,
 		   uint16_t token,
 		   const struct dpni_pools_cfg *cfg)
 {
@@ -194,7 +205,7 @@ int dpni_set_pools(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_POOLS,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_POOLS(cmd, cfg);
 
@@ -202,37 +213,45 @@ int dpni_set_pools(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_enable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_enable(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_disable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_disable(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_DISABLE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpni_is_enabled(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_IS_ENABLED, MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_IS_ENABLED, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -246,54 +265,52 @@ int dpni_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpni_reset(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_reset(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_RESET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-
-
-int dpni_set_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id)
+int dpni_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 struct dpni_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+	DPNI_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-
-int dpni_get_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id)
+int dpni_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 struct dpni_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_GET_IRQ(cmd, irq_index);
 
@@ -303,12 +320,13 @@ int dpni_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPNI_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpni_set_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t en)
@@ -317,7 +335,8 @@ int dpni_set_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -325,6 +344,7 @@ int dpni_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t *en)
@@ -334,7 +354,8 @@ int dpni_get_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -349,6 +370,7 @@ int dpni_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t mask)
@@ -357,7 +379,8 @@ int dpni_set_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -365,6 +388,7 @@ int dpni_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t *mask)
@@ -374,7 +398,8 @@ int dpni_get_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -389,6 +414,7 @@ int dpni_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_irq_status(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t *status)
@@ -398,7 +424,8 @@ int dpni_get_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -413,6 +440,7 @@ int dpni_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpni_clear_irq_status(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint32_t status)
@@ -421,7 +449,8 @@ int dpni_clear_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -429,6 +458,7 @@ int dpni_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_attributes(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			struct dpni_attr *attr)
 {
@@ -437,7 +467,7 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -452,6 +482,7 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
 			     uint16_t token,
 			      struct dpni_error_cfg *cfg)
 {
@@ -459,7 +490,8 @@ int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_ERRORS_BEHAVIOR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_ERRORS_BEHAVIOR(cmd, cfg);
 
 	/* send command to mc*/
@@ -467,6 +499,7 @@ int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      struct dpni_buffer_layout *layout)
 {
@@ -475,7 +508,8 @@ int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -489,6 +523,7 @@ int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_rx_buffer_layout(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      const struct dpni_buffer_layout *layout)
 {
@@ -496,7 +531,8 @@ int dpni_set_rx_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_RX_BUFFER_LAYOUT(cmd, layout);
 
 	/* send command to mc*/
@@ -504,6 +540,7 @@ int dpni_set_rx_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_tx_buffer_layout(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      struct dpni_buffer_layout *layout)
 {
@@ -512,7 +549,8 @@ int dpni_get_tx_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -526,6 +564,7 @@ int dpni_get_tx_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_tx_buffer_layout(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      const struct dpni_buffer_layout *layout)
 {
@@ -533,7 +572,8 @@ int dpni_set_tx_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_TX_BUFFER_LAYOUT(cmd, layout);
 
 	/* send command to mc*/
@@ -541,6 +581,7 @@ int dpni_set_tx_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
+				   uint32_t cmd_flags,
 				   uint16_t token,
 				   struct dpni_buffer_layout *layout)
 {
@@ -549,7 +590,8 @@ int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -563,6 +605,7 @@ int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
+				   uint32_t cmd_flags,
 				   uint16_t token,
 				   const struct dpni_buffer_layout *layout)
 {
@@ -570,7 +613,8 @@ int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_TX_CONF_BUFFER_LAYOUT(cmd, layout);
 
 	/* send command to mc*/
@@ -578,6 +622,7 @@ int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_l3_chksum_validation(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  int *en)
 {
@@ -586,7 +631,7 @@ int dpni_get_l3_chksum_validation(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_L3_CHKSUM_VALIDATION,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -601,6 +646,7 @@ int dpni_get_l3_chksum_validation(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_l3_chksum_validation(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  int en)
 {
@@ -608,7 +654,8 @@ int dpni_set_l3_chksum_validation(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_L3_CHKSUM_VALIDATION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_L3_CHKSUM_VALIDATION(cmd, en);
 
 	/* send command to mc*/
@@ -616,6 +663,7 @@ int dpni_set_l3_chksum_validation(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_l4_chksum_validation(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  int *en)
 {
@@ -624,7 +672,8 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_L4_CHKSUM_VALIDATION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -638,6 +687,7 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_l4_chksum_validation(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  int en)
 {
@@ -645,21 +695,25 @@ int dpni_set_l4_chksum_validation(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_L4_CHKSUM_VALIDATION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_L4_CHKSUM_VALIDATION(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_qdid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *qdid)
+int dpni_get_qdid(struct fsl_mc_io *mc_io,
+		  uint32_t cmd_flags,
+		  uint16_t token,
+		  uint16_t *qdid)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_QDID,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -673,14 +727,17 @@ int dpni_get_qdid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *qdid)
 	return 0;
 }
 
-int dpni_get_spid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *spid)
+int dpni_get_sp_info(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     struct dpni_sp_info *sp_info)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_SPID,
-					  MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_SP_INFO,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -689,12 +746,13 @@ int dpni_get_spid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *spid)
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_SPID(cmd, *spid);
+	DPNI_RSP_GET_SP_INFO(cmd, sp_info);
 
 	return 0;
 }
 
 int dpni_get_tx_data_offset(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
 			    uint16_t token,
 			    uint16_t *data_offset)
 {
@@ -703,7 +761,8 @@ int dpni_get_tx_data_offset(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_DATA_OFFSET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -717,6 +776,7 @@ int dpni_get_tx_data_offset(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_counter(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     enum dpni_counter counter,
 		     uint64_t *value)
@@ -726,7 +786,8 @@ int dpni_get_counter(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_COUNTER,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_COUNTER(cmd, counter);
 
 	/* send command to mc*/
@@ -741,6 +802,7 @@ int dpni_get_counter(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_counter(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     enum dpni_counter counter,
 		     uint64_t value)
@@ -749,7 +811,8 @@ int dpni_set_counter(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_COUNTER,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_COUNTER(cmd, counter, value);
 
 	/* send command to mc*/
@@ -757,14 +820,16 @@ int dpni_set_counter(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
-		     const struct dpni_link_cfg *cfg)
+		      const struct dpni_link_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_LINK_CFG,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_LINK_CFG(cmd, cfg);
 
 	/* send command to mc*/
@@ -772,6 +837,7 @@ int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_link_state(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			struct dpni_link_state *state)
 {
@@ -780,7 +846,8 @@ int dpni_get_link_state(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_LINK_STATE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -793,14 +860,33 @@ int dpni_get_link_state(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_set_max_frame_length(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_set_tx_shaping(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
+			uint16_t token,
+			const struct dpni_tx_shaping_cfg *tx_shaper)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_SHAPING,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_SHAPING(cmd, tx_shaper);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_set_max_frame_length(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
+			      uint16_t token,
 			      uint16_t max_frame_length)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_MAX_FRAME_LENGTH,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_MAX_FRAME_LENGTH(cmd, max_frame_length);
 
@@ -808,7 +894,9 @@ int dpni_set_max_frame_length(struct fsl_mc_io *mc_io, uint16_t token,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_max_frame_length(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_get_max_frame_length(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
+			      uint16_t token,
 			      uint16_t *max_frame_length)
 {
 	struct mc_command cmd = { 0 };
@@ -816,7 +904,7 @@ int dpni_get_max_frame_length(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_MAX_FRAME_LENGTH,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -830,13 +918,16 @@ int dpni_get_max_frame_length(struct fsl_mc_io *mc_io, uint16_t token,
 	return 0;
 }
 
-int dpni_set_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t mtu)
+int dpni_set_mtu(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token,
+		 uint16_t mtu)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_MTU,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_MTU(cmd, mtu);
 
@@ -844,14 +935,17 @@ int dpni_set_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t mtu)
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *mtu)
+int dpni_get_mtu(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token,
+		 uint16_t *mtu)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_MTU,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -865,27 +959,35 @@ int dpni_get_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *mtu)
 	return 0;
 }
 
-int dpni_set_multicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_multicast_promisc(struct fsl_mc_io *mc_io,
+			       uint32_t cmd_flags,
+			       uint16_t token,
+			       int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_MCAST_PROMISC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_MULTICAST_PROMISC(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_multicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpni_get_multicast_promisc(struct fsl_mc_io *mc_io,
+			       uint32_t cmd_flags,
+			       uint16_t token,
+			       int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_MCAST_PROMISC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -898,27 +1000,35 @@ int dpni_get_multicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpni_set_unicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_unicast_promisc(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
+			     uint16_t token,
+			     int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_UNICAST_PROMISC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_UNICAST_PROMISC(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_unicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpni_get_unicast_promisc(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
+			     uint16_t token,
+			     int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_UNICAST_PROMISC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -932,6 +1042,7 @@ int dpni_get_unicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 }
 
 int dpni_set_primary_mac_addr(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      const uint8_t mac_addr[6])
 {
@@ -939,7 +1050,8 @@ int dpni_set_primary_mac_addr(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_PRIM_MAC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_PRIMARY_MAC_ADDR(cmd, mac_addr);
 
 	/* send command to mc*/
@@ -947,6 +1059,7 @@ int dpni_set_primary_mac_addr(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_primary_mac_addr(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint8_t mac_addr[6])
 {
@@ -955,7 +1068,8 @@ int dpni_get_primary_mac_addr(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_PRIM_MAC,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -969,6 +1083,7 @@ int dpni_get_primary_mac_addr(struct fsl_mc_io *mc_io,
 }
 
 int dpni_add_mac_addr(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      const uint8_t mac_addr[6])
 {
@@ -976,7 +1091,8 @@ int dpni_add_mac_addr(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_MAC_ADDR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_ADD_MAC_ADDR(cmd, mac_addr);
 
 	/* send command to mc*/
@@ -984,6 +1100,7 @@ int dpni_add_mac_addr(struct fsl_mc_io *mc_io,
 }
 
 int dpni_remove_mac_addr(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 const uint8_t mac_addr[6])
 {
@@ -991,47 +1108,60 @@ int dpni_remove_mac_addr(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_REMOVE_MAC_ADDR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_REMOVE_MAC_ADDR(cmd, mac_addr);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_clear_mac_filters(struct fsl_mc_io *mc_io, uint16_t token, int unicast,
+int dpni_clear_mac_filters(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t token,
+			   int unicast,
 			   int multicast)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLR_MAC_FILTERS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_CLEAR_MAC_FILTERS(cmd, unicast, multicast);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_vlan_filters(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_vlan_filters(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
+			  int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_FILTERS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_VLAN_FILTERS(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_add_vlan_id(struct fsl_mc_io *mc_io, uint16_t token, uint16_t vlan_id)
+int dpni_add_vlan_id(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     uint16_t vlan_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_VLAN_ID,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_ADD_VLAN_ID(cmd, vlan_id);
 
 	/* send command to mc*/
@@ -1039,6 +1169,7 @@ int dpni_add_vlan_id(struct fsl_mc_io *mc_io, uint16_t token, uint16_t vlan_id)
 }
 
 int dpni_remove_vlan_id(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint16_t vlan_id)
 {
@@ -1046,26 +1177,31 @@ int dpni_remove_vlan_id(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_REMOVE_VLAN_ID,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_REMOVE_VLAN_ID(cmd, vlan_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_clear_vlan_filters(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_clear_vlan_filters(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
+			    uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLR_VLAN_FILTERS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpni_set_tx_tc(struct fsl_mc_io *mc_io,
+		   uint32_t cmd_flags,
 		   uint16_t token,
 		   uint8_t tc_id,
 		   const struct dpni_tx_tc_cfg *cfg)
@@ -1074,7 +1210,7 @@ int dpni_set_tx_tc(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_TC,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_TX_TC(cmd, tc_id, cfg);
 
@@ -1082,7 +1218,25 @@ int dpni_set_tx_tc(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
+int dpni_set_tx_selection(struct fsl_mc_io			*mc_io,
+			  uint32_t				cmd_flags,
+			  uint16_t				token,
+			  const struct dpni_tx_selection_cfg	*cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_SELECTION,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_SELECTION(cmd, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
 int dpni_set_rx_tc_dist(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t tc_id,
 			const struct dpni_rx_tc_dist_cfg *cfg)
@@ -1091,7 +1245,7 @@ int dpni_set_rx_tc_dist(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_TC_DIST,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_RX_TC_DIST(cmd, tc_id, cfg);
 
@@ -1100,6 +1254,7 @@ int dpni_set_rx_tc_dist(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_tx_flow(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint16_t *flow_id,
 		     const struct dpni_tx_flow_cfg *cfg)
@@ -1109,7 +1264,8 @@ int dpni_set_tx_flow(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_FLOW,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_TX_FLOW(cmd, *flow_id, cfg);
 
 	/* send command to mc*/
@@ -1124,6 +1280,7 @@ int dpni_set_tx_flow(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint16_t flow_id,
 		     struct dpni_tx_flow_attr *attr)
@@ -1133,7 +1290,8 @@ int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_FLOW,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_TX_FLOW(cmd, flow_id);
 
 	/* send command to mc*/
@@ -1148,6 +1306,7 @@ int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
 }
 
 int dpni_set_rx_flow(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint8_t tc_id,
 		     uint16_t flow_id,
@@ -1157,7 +1316,8 @@ int dpni_set_rx_flow(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_FLOW,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_RX_FLOW(cmd, tc_id, flow_id, cfg);
 
 	/* send command to mc*/
@@ -1165,6 +1325,7 @@ int dpni_set_rx_flow(struct fsl_mc_io *mc_io,
 }
 
 int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint8_t tc_id,
 		     uint16_t flow_id,
@@ -1174,7 +1335,8 @@ int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
 	int err;
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_FLOW,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_GET_RX_FLOW(cmd, tc_id, flow_id);
 
 	/* send command to mc*/
@@ -1188,22 +1350,26 @@ int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-
-int dpni_set_rx_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_set_rx_err_queue(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
 			  const struct dpni_queue_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_ERR_QUEUE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_RX_ERR_QUEUE(cmd, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
 			  struct dpni_queue_attr *attr)
 {
 	struct mc_command cmd = { 0 };
@@ -1211,7 +1377,7 @@ int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_ERR_QUEUE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -1225,21 +1391,26 @@ int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
 	return 0;
 }
 
-int dpni_set_tx_conf_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_set_tx_conf_err_queue(struct fsl_mc_io *mc_io,
+			       uint32_t cmd_flags,
+			       uint16_t token,
 			       const struct dpni_queue_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_ERR_QUEUE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_TX_CONF_ERR_QUEUE(cmd, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_conf_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_get_tx_conf_err_queue(struct fsl_mc_io *mc_io,
+			       uint32_t cmd_flags,
+			       uint16_t token,
 			       struct dpni_queue_attr *attr)
 {
 	struct mc_command cmd = { 0 };
@@ -1247,7 +1418,7 @@ int dpni_get_tx_conf_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF_ERR_QUEUE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -1261,8 +1432,25 @@ int dpni_get_tx_conf_err_queue(struct fsl_mc_io *mc_io, uint16_t token,
 	return 0;
 }
 
+int dpni_set_tx_conf_revoke(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
+			    uint16_t		token,
+			    int		revoke)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_REVOKE,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_CONF_REVOKE(cmd, revoke);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
 
 int dpni_set_qos_table(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
 		       const struct dpni_qos_tbl_cfg *cfg)
 {
@@ -1270,7 +1458,8 @@ int dpni_set_qos_table(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_QOS_TBL,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_SET_QOS_TABLE(cmd, cfg);
 
 	/* send command to mc*/
@@ -1278,6 +1467,7 @@ int dpni_set_qos_table(struct fsl_mc_io *mc_io,
 }
 
 int dpni_add_qos_entry(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
 		       const struct dpni_rule_cfg *cfg,
 		       uint8_t tc_id)
@@ -1286,8 +1476,8 @@ int dpni_add_qos_entry(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_QOS_ENT,
-					  MC_CMD_PRI_LOW, token);
-
+					  cmd_flags,
+					  token);
 	DPNI_CMD_ADD_QOS_ENTRY(cmd, cfg, tc_id);
 
 	/* send command to mc*/
@@ -1295,6 +1485,7 @@ int dpni_add_qos_entry(struct fsl_mc_io *mc_io,
 }
 
 int dpni_remove_qos_entry(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  const struct dpni_rule_cfg *cfg)
 {
@@ -1302,26 +1493,31 @@ int dpni_remove_qos_entry(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_REMOVE_QOS_ENT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_REMOVE_QOS_ENTRY(cmd, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_clear_qos_table(struct fsl_mc_io *mc_io, uint16_t token)
+int dpni_clear_qos_table(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLR_QOS_TBL,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t tc_id,
 		      const struct dpni_rule_cfg *cfg,
@@ -1331,7 +1527,7 @@ int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_FS_ENT,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_ADD_FS_ENTRY(cmd, tc_id, cfg, flow_id);
 
@@ -1340,6 +1536,7 @@ int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
 }
 
 int dpni_remove_fs_entry(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 uint8_t tc_id,
 			 const struct dpni_rule_cfg *cfg)
@@ -1348,21 +1545,24 @@ int dpni_remove_fs_entry(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_REMOVE_FS_ENT,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPNI_CMD_REMOVE_FS_ENTRY(cmd, tc_id, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_clear_fs_entries(struct fsl_mc_io *mc_io, uint16_t token,
+int dpni_clear_fs_entries(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
 			  uint8_t tc_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CLR_FS_ENT,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_CLEAR_FS_ENTRIES(cmd, tc_id);
 
@@ -1370,39 +1570,48 @@ int dpni_clear_fs_entries(struct fsl_mc_io *mc_io, uint16_t token,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_vlan_insertion(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_vlan_insertion(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
+			    uint16_t token,
+			    int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_INSERTION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags, token);
 	DPNI_CMD_SET_VLAN_INSERTION(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_vlan_removal(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_vlan_removal(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
+			  int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_REMOVAL,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags, token);
 	DPNI_CMD_SET_VLAN_REMOVAL(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_ipr(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_ipr(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token,
+		 int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IPR,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_IPR(cmd, en);
 
@@ -1410,13 +1619,16 @@ int dpni_set_ipr(struct fsl_mc_io *mc_io, uint16_t token, int en)
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_ipf(struct fsl_mc_io *mc_io, uint16_t token, int en)
+int dpni_set_ipf(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token,
+		 int en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IPF,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_IPF(cmd, en);
 
@@ -1425,6 +1637,7 @@ int dpni_set_ipf(struct fsl_mc_io *mc_io, uint16_t token, int en)
 }
 
 int dpni_set_rx_tc_policing(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
 			    uint16_t		token,
 			    uint8_t		tc_id,
 			    const struct dpni_rx_tc_policing_cfg *cfg)
@@ -1433,7 +1646,7 @@ int dpni_set_rx_tc_policing(struct fsl_mc_io	*mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_TC_POLICING,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_RX_TC_POLICING(cmd, tc_id, cfg);
 
@@ -1450,15 +1663,16 @@ void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
 }
 
 int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
-			    uint8_t		tc_id,
-			    uint64_t		early_drop_iova)
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_TC_EARLY_DROP,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPNI_CMD_SET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
 
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.h b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
index 8703cc4..bfda601 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
@@ -34,19 +34,21 @@
 
 #include "dpkg.h"
 
+struct fsl_mc_io;
+
 /**
  * Data Path Network Interface API
  * Contains initialization APIs and runtime control APIs for DPNI
  */
 
-struct fsl_mc_io;
-
 /* General DPNI macros */
 
 /* Maximum number of traffic classes */
 #define DPNI_MAX_TC				8
 /* Maximum number of buffer pools per DPNI */
 #define DPNI_MAX_DPBP				8
+/* Maximum number of storage-profiles per DPNI */
+#define DPNI_MAX_SP				2
 
 /* All traffic classes considered; see dpni_set_rx_flow() */
 #define DPNI_ALL_TCS				(uint8_t)(-1)
@@ -58,6 +60,7 @@ struct fsl_mc_io;
 /**
  * dpni_open() - Open a control session for the specified object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpni_id:	DPNI unique ID
  * @token:	Returned token; use in subsequent API calls
  *
@@ -71,11 +74,15 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_open(struct fsl_mc_io *mc_io, int dpni_id, uint16_t *token);
+int dpni_open(struct fsl_mc_io	*mc_io,
+	      uint32_t		cmd_flags,
+	      int		dpni_id,
+	      uint16_t		*token);
 
 /**
  * dpni_close() - Close the control session of the object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  *
  * After this function is called, no further operations are
@@ -83,7 +90,9 @@ int dpni_open(struct fsl_mc_io *mc_io, int dpni_id, uint16_t *token);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_close(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       uint16_t		token);
 
 /* DPNI configuration options */
 
@@ -192,26 +201,27 @@ struct dpni_cfg {
 	 * @ipr_cfg: IP reassembly configuration
 	 */
 	struct {
-		uint32_t options;
-		enum net_prot start_hdr;
-		uint8_t max_senders;
-		uint8_t max_tcs;
-		uint8_t max_dist_per_tc[DPNI_MAX_TC];
-		uint8_t max_unicast_filters;
-		uint8_t max_multicast_filters;
-		uint8_t max_vlan_filters;
-		uint8_t max_qos_entries;
-		uint8_t max_qos_key_size;
-		uint8_t max_dist_key_size;
-		uint8_t max_policers;
-		uint8_t max_congestion_ctrl;
-		struct dpni_ipr_cfg ipr_cfg;
+		uint32_t		options;
+		enum net_prot		start_hdr;
+		uint8_t		max_senders;
+		uint8_t		max_tcs;
+		uint8_t			max_dist_per_tc[DPNI_MAX_TC];
+		uint8_t		max_unicast_filters;
+		uint8_t		max_multicast_filters;
+		uint8_t			max_vlan_filters;
+		uint8_t		max_qos_entries;
+		uint8_t		max_qos_key_size;
+		uint8_t		max_dist_key_size;
+		uint8_t		max_policers;
+		uint8_t		max_congestion_ctrl;
+		struct dpni_ipr_cfg	ipr_cfg;
 	} adv;
 };
 
 /**
  * dpni_create() - Create the DPNI object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -231,17 +241,21 @@ struct dpni_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_create(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
 		const struct dpni_cfg	*cfg,
 		uint16_t		*token);
 
 /**
  * dpni_destroy() - Destroy the DPNI object and release all its resources.
- * @mc_io	Pointer to MC portal's I/O object
- * @token	Token of DPNI object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_destroy(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * struct dpni_pools_cfg - Structure representing buffer pools configuration
@@ -250,21 +264,24 @@ int dpni_destroy(struct fsl_mc_io *mc_io, uint16_t token);
  *	must match 'num_dpbp' value
  */
 struct dpni_pools_cfg {
-	uint8_t num_dpbp;
+	uint8_t		num_dpbp;
 	/**
 	 * struct pools - Buffer pools parameters
 	 * @dpbp_id: DPBP object ID
 	 * @buffer_size: Buffer size
+	 * @backup_pool: Backup pool
 	 */
 	struct {
-		int dpbp_id;
-		uint16_t buffer_size;
+		int		dpbp_id;
+		uint16_t	buffer_size;
+		int		backup_pool;
 	} pools[DPNI_MAX_DPBP];
 };
 
 /**
  * dpni_set_pools() - Set buffer pools configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	Buffer pools configuration
  *
@@ -274,45 +291,59 @@ struct dpni_pools_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_pools(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
 		   uint16_t			token,
 		   const struct dpni_pools_cfg	*cfg);
 
 /**
  * dpni_enable() - Enable the DPNI, allow sending and receiving frames.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPNI object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_enable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_enable(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * dpni_disable() - Disable the DPNI, stop sending and receiving frames.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_disable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_disable(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpni_is_enabled() - Check if the DPNI is enabled.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Returns '1' if object is enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpni_is_enabled(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    int		*en);
 
 /**
- * @dpni_reset() - Reset the DPNI, returns the object to initial state.
+ * dpni_reset() - Reset the DPNI, returns the object to initial state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_reset(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_reset(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       uint16_t		token);
 
 /* DPNI IRQ Index and Events */
 
@@ -322,49 +353,56 @@ int dpni_reset(struct fsl_mc_io *mc_io, uint16_t token);
 #define DPNI_IRQ_EVENT_LINK_CHANGED		0x00000001
 
 /**
+ * struct dpni_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpni_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
+
+/**
  * dpni_set_irq() - Set IRQ information for the DPNI to trigger an interrupt.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *			signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
 		 uint8_t		irq_index,
-		 uint64_t		irq_addr,
-		 uint32_t		irq_val,
-		 int			user_irq_id);
+		 struct dpni_irq_cfg	*irq_cfg);
 
 /**
  * dpni_get_irq() - Get IRQ information from the DPNI.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @type:	Interrupt type: 0 represents message interrupt
- *			type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *			signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: Returned a user defined number associated with this IRQ
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
 		 uint8_t		irq_index,
 		 int			*type,
-		 uint64_t		*irq_addr,
-		 uint32_t		*irq_val,
-		 int			*user_irq_id);
+		 struct dpni_irq_cfg	*irq_cfg);
 
 /**
  * dpni_set_irq_enable() - Set overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @en:		Interrupt state: - enable = 1, disable = 0
@@ -377,6 +415,7 @@ int dpni_get_irq(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			en);
@@ -384,6 +423,7 @@ int dpni_set_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpni_get_irq_enable() - Get overall interrupt state
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @en:		Returned interrupt state - enable = 1, disable = 0
@@ -391,6 +431,7 @@ int dpni_set_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			*en);
@@ -398,6 +439,7 @@ int dpni_get_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpni_set_irq_mask() - Set interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @mask:	event mask to trigger interrupt;
@@ -411,6 +453,7 @@ int dpni_get_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		mask);
@@ -418,6 +461,7 @@ int dpni_set_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpni_get_irq_mask() - Get interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @mask:	Returned event mask to trigger interrupt
@@ -428,6 +472,7 @@ int dpni_set_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		*mask);
@@ -435,6 +480,7 @@ int dpni_get_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpni_get_irq_status() - Get the current status of any pending interrupts.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @status:	Returned interrupts status - one bit per cause:
@@ -444,6 +490,7 @@ int dpni_get_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_irq_status(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint32_t		*status);
@@ -451,6 +498,7 @@ int dpni_get_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * dpni_clear_irq_status() - Clear a pending interrupt's status
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @irq_index:	The interrupt index to configure
  * @status:	bits to clear (W1C) - one bit per cause:
@@ -460,6 +508,7 @@ int dpni_get_irq_status(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_clear_irq_status(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint32_t		status);
@@ -487,7 +536,7 @@ int dpni_clear_irq_status(struct fsl_mc_io	*mc_io,
  * @ipr_cfg: IP reassembly configuration
  */
 struct dpni_attr {
-	int id;
+	int			id;
 	/**
 	 * struct version - DPNI version
 	 * @major: DPNI major version
@@ -497,31 +546,33 @@ struct dpni_attr {
 		uint16_t major;
 		uint16_t minor;
 	} version;
-	enum net_prot start_hdr;
-	uint32_t options;
-	uint8_t max_senders;
-	uint8_t max_tcs;
-	uint8_t max_dist_per_tc[DPNI_MAX_TC];
-	uint8_t max_unicast_filters;
-	uint8_t max_multicast_filters;
-	uint8_t max_vlan_filters;
-	uint8_t max_qos_entries;
-	uint8_t max_qos_key_size;
-	uint8_t max_dist_key_size;
-	uint8_t max_policers;
-	uint8_t max_congestion_ctrl;
-	struct dpni_ipr_cfg ipr_cfg;
+	enum net_prot		start_hdr;
+	uint32_t		options;
+	uint8_t			max_senders;
+	uint8_t		max_tcs;
+	uint8_t		max_dist_per_tc[DPNI_MAX_TC];
+	uint8_t		max_unicast_filters;
+	uint8_t		max_multicast_filters;
+	uint8_t		max_vlan_filters;
+	uint8_t		max_qos_entries;
+	uint8_t		max_qos_key_size;
+	uint8_t		max_dist_key_size;
+	uint8_t			max_policers;
+	uint8_t		max_congestion_ctrl;
+	struct dpni_ipr_cfg	ipr_cfg;
 };
 
 /**
  * dpni_get_attributes() - Retrieve DPNI attributes.
- * @mc_io:	Pointer to MC portal's I/O objec
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @attr:	Returned object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_attributes(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			struct dpni_attr	*attr);
 
@@ -540,7 +591,6 @@ int dpni_get_attributes(struct fsl_mc_io	*mc_io,
 /* Parser L3 checksum error */
 #define DPNI_ERROR_L4CE		0x00000001
 
-
 /**
  *  enum dpni_error_action - Defines DPNI behavior for errors
  *  @DPNI_ERROR_ACTION_DISCARD: Discard the frame
@@ -561,14 +611,15 @@ enum dpni_error_action {
  *		status (FAS); relevant only for the non-discard action
  */
 struct dpni_error_cfg {
-	uint32_t errors;
-	enum dpni_error_action error_action;
-	int set_frame_annotation;
+	uint32_t		errors;
+	enum dpni_error_action	error_action;
+	int			set_frame_annotation;
 };
 
 /**
  * dpni_set_errors_behavior() - Set errors behavior
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	Errors configuration
  *
@@ -578,6 +629,7 @@ struct dpni_error_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_errors_behavior(struct fsl_mc_io		*mc_io,
+			     uint32_t			cmd_flags,
 			     uint16_t			token,
 			     struct dpni_error_cfg	*cfg);
 
@@ -611,31 +663,34 @@ int dpni_set_errors_behavior(struct fsl_mc_io		*mc_io,
  * @data_tail_room: Data tail room
  */
 struct dpni_buffer_layout {
-	uint32_t options;
-	int pass_timestamp;
-	int pass_parser_result;
-	int pass_frame_status;
-	uint16_t private_data_size;
-	uint16_t data_align;
-	uint16_t data_head_room;
-	uint16_t data_tail_room;
+	uint32_t	options;
+	int		pass_timestamp;
+	int		pass_parser_result;
+	int		pass_frame_status;
+	uint16_t	private_data_size;
+	uint16_t	data_align;
+	uint16_t	data_head_room;
+	uint16_t	data_tail_room;
 };
 
 /**
  * dpni_get_rx_buffer_layout() - Retrieve Rx buffer layout attributes.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Returns buffer layout attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_rx_buffer_layout(struct fsl_mc_io		*mc_io,
+			      uint32_t			cmd_flags,
 			      uint16_t			token,
 			      struct dpni_buffer_layout	*layout);
 
 /**
  * dpni_set_rx_buffer_layout() - Set Rx buffer layout configuration.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Buffer layout configuration
  *
@@ -644,24 +699,28 @@ int dpni_get_rx_buffer_layout(struct fsl_mc_io		*mc_io,
  * @warning	Allowed only when DPNI is disabled
  */
 int dpni_set_rx_buffer_layout(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
 			      uint16_t				token,
 			      const struct dpni_buffer_layout	*layout);
 
 /**
  * dpni_get_tx_buffer_layout() - Retrieve Tx buffer layout attributes.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Returns buffer layout attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_tx_buffer_layout(struct fsl_mc_io		*mc_io,
+			      uint32_t			cmd_flags,
 			      uint16_t			token,
 			      struct dpni_buffer_layout	*layout);
 
 /**
  * dpni_set_tx_buffer_layout() - Set Tx buffer layout configuration.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Buffer layout configuration
  *
@@ -670,6 +729,7 @@ int dpni_get_tx_buffer_layout(struct fsl_mc_io		*mc_io,
  * @warning	Allowed only when DPNI is disabled
  */
 int dpni_set_tx_buffer_layout(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
 			      uint16_t				token,
 			      const struct dpni_buffer_layout	*layout);
 
@@ -677,12 +737,14 @@ int dpni_set_tx_buffer_layout(struct fsl_mc_io			*mc_io,
  * dpni_get_tx_conf_buffer_layout() - Retrieve Tx confirmation buffer layout
  *				attributes.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Returns buffer layout attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
+				   uint32_t			cmd_flags,
 				   uint16_t			token,
 				   struct dpni_buffer_layout	*layout);
 
@@ -690,6 +752,7 @@ int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
  * dpni_set_tx_conf_buffer_layout() - Set Tx confirmation buffer layout
  *					configuration.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Buffer layout configuration
  *
@@ -698,54 +761,63 @@ int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
  * @warning	Allowed only when DPNI is disabled
  */
 int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io		   *mc_io,
+				   uint32_t			   cmd_flags,
 				   uint16_t			   token,
 				   const struct dpni_buffer_layout *layout);
 
 /**
  * dpni_set_l3_chksum_validation() - Enable/disable L3 checksum validation
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_l3_chksum_validation(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
 				  uint16_t		token,
 				  int			en);
 
 /**
  * dpni_get_l3_chksum_validation() - Get L3 checksum validation mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Returns '1' if enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_l3_chksum_validation(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
 				  uint16_t		token,
 				  int			*en);
 
 /**
  * dpni_set_l4_chksum_validation() - Enable/disable L4 checksum validation
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_l4_chksum_validation(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
 				  uint16_t		token,
 				  int			en);
 
 /**
  * dpni_get_l4_chksum_validation() - Get L4 checksum validation mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Returns '1' if enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_l4_chksum_validation(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
 				  uint16_t		token,
 				  int			*en);
 
@@ -753,35 +825,54 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io	*mc_io,
  * dpni_get_qdid() - Get the Queuing Destination ID (QDID) that should be used
  *			for enqueue operations
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @qdid:	Returned virtual QDID value that should be used as an argument
  *			in all enqueue operations
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_qdid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *qdid);
+int dpni_get_qdid(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
+		  uint16_t		token,
+		  uint16_t		*qdid);
 
 /**
- * dpni_get_spid() - Get the AIOP storage profile ID associated with the DPNI
+ * struct dpni_sp_info - Structure representing DPNI storage-profile information
+ * (relevant only for DPNI owned by AIOP)
+ * @spids: array of storage-profiles
+ */
+struct dpni_sp_info {
+	uint16_t spids[DPNI_MAX_SP];
+};
+
+/**
+ * dpni_get_spids() - Get the AIOP storage profile IDs associated with the DPNI
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @spid:	Returned aiop storage-profile ID
+ * @sp_info:	Returned AIOP storage-profile information
  *
  * Return:	'0' on Success; Error code otherwise.
  *
  * @warning	Only relevant for DPNI that belongs to AIOP container.
  */
-int dpni_get_spid(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *spid);
+int dpni_get_sp_info(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
+		     uint16_t			token,
+		     struct dpni_sp_info	*sp_info);
 
 /**
  * dpni_get_tx_data_offset() - Get the Tx data offset (from start of buffer)
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @data_offset: Tx data offset (from start of buffer)
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_tx_data_offset(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
 			    uint16_t		token,
 			    uint16_t		*data_offset);
 
@@ -818,6 +909,7 @@ enum dpni_counter {
 /**
  * dpni_get_counter() - Read a specific DPNI counter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @counter:	The requested counter
  * @value:	Returned counter's current value
@@ -825,6 +917,7 @@ enum dpni_counter {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_counter(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
 		     uint16_t		token,
 		     enum dpni_counter	counter,
 		     uint64_t		*value);
@@ -832,6 +925,7 @@ int dpni_get_counter(struct fsl_mc_io	*mc_io,
 /**
  * dpni_set_counter() - Set (or clear) a specific DPNI counter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @counter:	The requested counter
  * @value:	New counter value; typically pass '0' for resetting
@@ -840,6 +934,7 @@ int dpni_get_counter(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_counter(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
 		     uint16_t		token,
 		     enum dpni_counter	counter,
 		     uint64_t		value);
@@ -866,14 +961,16 @@ struct dpni_link_cfg {
 /**
  * dpni_set_link_cfg() - set the link configuration.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	Link configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
-		      uint16_t token,
-		      const struct dpni_link_cfg *cfg);
+int dpni_set_link_cfg(struct fsl_mc_io			*mc_io,
+		      uint32_t				cmd_flags,
+		      uint16_t				token,
+		      const struct dpni_link_cfg	*cfg);
 
 /**
  * struct dpni_link_state - Structure representing DPNI link state
@@ -882,22 +979,24 @@ int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
  * @up: Link state; '0' for down, '1' for up
  */
 struct dpni_link_state {
-	uint32_t rate;
-	uint64_t options;
-	int up;
+	uint32_t	rate;
+	uint64_t	options;
+	int		up;
 };
 
 /**
  * dpni_get_link_state() - Return the link state (either up or down)
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @state:	Returned link state;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_link_state(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			struct dpni_link_state *state);
+int dpni_get_link_state(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			struct dpni_link_state	*state);
 
 /**
  * struct dpni_tx_shaping - Structure representing DPNI tx shaping configuration
@@ -905,25 +1004,28 @@ int dpni_get_link_state(struct fsl_mc_io *mc_io,
  * @max_burst_size: burst size in bytes (up to 64KB)
  */
 struct dpni_tx_shaping_cfg {
-	uint64_t rate_limit;
+	uint32_t rate_limit;
 	uint16_t max_burst_size;
 };
 
 /**
  * dpni_set_tx_shaping() - Set the transmit shaping
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tx_shaper:  tx shaping configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_tx_shaping(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			const struct dpni_tx_shaping_cfg *tx_shaper);
+int dpni_set_tx_shaping(struct fsl_mc_io			*mc_io,
+			uint32_t				cmd_flags,
+			uint16_t				token,
+			const struct dpni_tx_shaping_cfg	*tx_shaper);
 
 /**
  * dpni_set_max_frame_length() - Set the maximum received frame length.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @max_frame_length:	Maximum received frame length (in
  *				bytes); frame is discarded if its
@@ -932,12 +1034,14 @@ int dpni_set_tx_shaping(struct fsl_mc_io *mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_max_frame_length(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
 			      uint16_t		max_frame_length);
 
 /**
  * dpni_get_max_frame_length() - Get the maximum received frame length.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @max_frame_length:	Maximum received frame length (in
  *				bytes); frame is discarded if its
@@ -946,12 +1050,14 @@ int dpni_set_max_frame_length(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_max_frame_length(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
 			      uint16_t		*max_frame_length);
 
 /**
  * dpni_set_mtu() - Set the MTU for the interface.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mtu:	MTU length (in bytes)
  *
@@ -959,113 +1065,141 @@ int dpni_get_max_frame_length(struct fsl_mc_io	*mc_io,
  * fragmentation on egress packets.
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t mtu);
+int dpni_set_mtu(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint16_t		mtu);
 
 /**
  * dpni_get_mtu() - Get the MTU.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mtu:	Returned MTU length (in bytes)
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_mtu(struct fsl_mc_io *mc_io, uint16_t token, uint16_t *mtu);
+int dpni_get_mtu(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint16_t		*mtu);
 
 /**
  * dpni_set_multicast_promisc() - Enable/disable multicast promiscuous mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_multicast_promisc(struct fsl_mc_io	*mc_io,
+int dpni_set_multicast_promisc(struct fsl_mc_io *mc_io,
+			       uint32_t	cmd_flags,
 			       uint16_t		token,
 			       int		en);
 
 /**
  * dpni_get_multicast_promisc() - Get multicast promiscuous mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Returns '1' if enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_multicast_promisc(struct fsl_mc_io	*mc_io,
+int dpni_get_multicast_promisc(struct fsl_mc_io *mc_io,
+			       uint32_t	cmd_flags,
 			       uint16_t		token,
 			       int		*en);
 
 /**
  * dpni_set_unicast_promisc() - Enable/disable unicast promiscuous mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_unicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int en);
+int dpni_set_unicast_promisc(struct fsl_mc_io	*mc_io,
+			     uint32_t		cmd_flags,
+			     uint16_t		token,
+			     int		en);
 
 /**
  * dpni_get_unicast_promisc() - Get unicast promiscuous mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Returns '1' if enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_unicast_promisc(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpni_get_unicast_promisc(struct fsl_mc_io	*mc_io,
+			     uint32_t		cmd_flags,
+			     uint16_t		token,
+			     int		*en);
 
 /**
  * dpni_set_primary_mac_addr() - Set the primary MAC address
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mac_addr:	MAC address to set as primary address
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_primary_mac_addr(struct fsl_mc_io	*mc_io,
+int dpni_set_primary_mac_addr(struct fsl_mc_io *mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
 			      const uint8_t	mac_addr[6]);
 
 /**
  * dpni_get_primary_mac_addr() - Get the primary MAC address
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mac_addr:	Returned MAC address
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_primary_mac_addr(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
 			      uint8_t		mac_addr[6]);
 
 /**
  * dpni_add_mac_addr() - Add MAC address filter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mac_addr:	MAC address to add
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_add_mac_addr(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      const uint8_t	mac_addr[6]);
 
 /**
  * dpni_remove_mac_addr() - Remove MAC address filter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @mac_addr:	MAC address to remove
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_remove_mac_addr(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
 			 uint16_t		token,
 			 const uint8_t		mac_addr[6]);
 
 /**
  * dpni_clear_mac_filters() - Clear all unicast and/or multicast MAC filters
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @unicast:	Set to '1' to clear unicast addresses
  * @multicast:	Set to '1' to clear multicast addresses
@@ -1075,6 +1209,7 @@ int dpni_remove_mac_addr(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_clear_mac_filters(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
 			   uint16_t		token,
 			   int			unicast,
 			   int			multicast);
@@ -1082,45 +1217,56 @@ int dpni_clear_mac_filters(struct fsl_mc_io	*mc_io,
 /**
  * dpni_set_vlan_filters() - Enable/disable VLAN filtering mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_filters(struct fsl_mc_io *mc_io, uint16_t token, int en);
+int dpni_set_vlan_filters(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
+			  uint16_t		token,
+			  int			en);
 
 /**
  * dpni_add_vlan_id() - Add VLAN ID filter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @vlan_id:	VLAN ID to add
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_add_vlan_id(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
 		     uint16_t		token,
 		     uint16_t		vlan_id);
 
 /**
  * dpni_remove_vlan_id() - Remove VLAN ID filter
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @vlan_id:	VLAN ID to remove
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_remove_vlan_id(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint16_t		vlan_id);
 
 /**
  * dpni_clear_vlan_filters() - Clear all VLAN filters
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_clear_vlan_filters(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_clear_vlan_filters(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
+			    uint16_t		token);
 
 /**
  * struct dpni_tx_tc_cfg - Structure representing Tx traffic class configuration
@@ -1135,6 +1281,7 @@ struct dpni_tx_tc_cfg {
 /**
  * dpni_set_tx_tc() - Set Tx traffic class configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	Traffic class configuration
@@ -1142,11 +1289,59 @@ struct dpni_tx_tc_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_tx_tc(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
 		   uint16_t			token,
 		   uint8_t			tc_id,
 		   const struct dpni_tx_tc_cfg	*cfg);
 
 /**
+ * enum dpni_tx_schedule_mode - DPNI Tx scheduling mode
+ * @DPNI_TX_SCHED_STRICT_PRIORITY: strict priority
+ * @DPNI_TX_SCHED_WEIGHTED: weighted based scheduling
+ */
+enum dpni_tx_schedule_mode {
+	DPNI_TX_SCHED_STRICT_PRIORITY,
+	DPNI_TX_SCHED_WEIGHTED,
+};
+
+/**
+ * struct dpni_tx_schedule_cfg - Structure representing Tx
+ *	scheduling configuration
+ * @mode: scheduling mode
+ * @delta_bandwidth: Bandwidth represented in weights from 100 to 10000;
+ *	not applicable for 'strict-priority' mode;
+ */
+struct dpni_tx_schedule_cfg {
+	enum dpni_tx_schedule_mode	mode;
+	uint16_t		delta_bandwidth;
+};
+
+/**
+ * struct dpni_tx_selection_cfg - Structure representing transmission
+ *	selection configuration
+ * @tc_sched: an array of traffic-classes
+ */
+struct dpni_tx_selection_cfg {
+	struct dpni_tx_schedule_cfg tc_sched[DPNI_MAX_TC];
+};
+
+/**
+ * dpni_set_tx_selection() - Set transmission selection configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @cfg:	transmission selection configuration
+ *
+ * warning:	Allowed only when DPNI is disabled
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_tx_selection(struct fsl_mc_io			*mc_io,
+			  uint32_t				cmd_flags,
+			  uint16_t				token,
+			  const struct dpni_tx_selection_cfg	*cfg);
+
+/**
  * enum dpni_dist_mode - DPNI distribution mode
  * @DPNI_DIST_MODE_NONE: No distribution
  * @DPNI_DIST_MODE_HASH: Use hash distribution; only relevant if
@@ -1178,8 +1373,8 @@ enum dpni_fs_miss_action {
  * @default_flow_id: Used when 'miss_action = DPNI_FS_MISS_EXPLICIT_FLOWID'
  */
 struct dpni_fs_tbl_cfg {
-	enum dpni_fs_miss_action miss_action;
-	uint16_t default_flow_id;
+	enum dpni_fs_miss_action	miss_action;
+	uint16_t			default_flow_id;
 };
 
 /**
@@ -1191,8 +1386,8 @@ struct dpni_fs_tbl_cfg {
  *	- dpni_set_rx_tc_dist()
  *		- dpni_set_qos_table()
  */
-int dpni_prepare_key_cfg(struct dpkg_profile_cfg *cfg,
-			 uint8_t *key_cfg_buf);
+int dpni_prepare_key_cfg(struct dpkg_profile_cfg	*cfg,
+			 uint8_t			*key_cfg_buf);
 
 /**
  * struct dpni_rx_tc_dist_cfg - Rx traffic class distribution configuration
@@ -1209,15 +1404,16 @@ int dpni_prepare_key_cfg(struct dpkg_profile_cfg *cfg,
  *		'dist_mode = DPNI_DIST_MODE_FS'
  */
 struct dpni_rx_tc_dist_cfg {
-	uint8_t dist_size;
-	enum dpni_dist_mode dist_mode;
-	uint64_t key_cfg_iova;
-	struct dpni_fs_tbl_cfg fs_cfg;
+	uint8_t		dist_size;
+	enum dpni_dist_mode	dist_mode;
+	uint64_t		key_cfg_iova;
+	struct dpni_fs_tbl_cfg	fs_cfg;
 };
 
 /**
  * dpni_set_rx_tc_dist() - Set Rx traffic class distribution configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	Traffic class distribution configuration
@@ -1228,6 +1424,7 @@ struct dpni_rx_tc_dist_cfg {
  * Return:	'0' on Success; error code otherwise.
  */
 int dpni_set_rx_tc_dist(struct fsl_mc_io			*mc_io,
+			uint32_t				cmd_flags,
 			uint16_t				token,
 			uint8_t					tc_id,
 			const struct dpni_rx_tc_dist_cfg	*cfg);
@@ -1257,7 +1454,8 @@ enum dpni_policer_mode {
  *  @DPNI_POLICER_UNIT_PACKETS: packets units
  */
 enum dpni_policer_unit {
-	DPNI_POLICER_UNIT_BYTES = 0, DPNI_POLICER_UNIT_PACKETS
+	DPNI_POLICER_UNIT_BYTES = 0,
+	DPNI_POLICER_UNIT_PACKETS
 };
 
 /**
@@ -1288,28 +1486,30 @@ enum dpni_policer_color {
  *       Excess burst size (EBS, rfc4115) in bytes or packets
  */
 struct dpni_rx_tc_policing_cfg {
-	uint32_t options;
-	enum dpni_policer_mode mode;
-	enum dpni_policer_unit units;
+	uint32_t		options;
+	enum dpni_policer_mode	mode;
+	enum dpni_policer_unit	units;
 	enum dpni_policer_color default_color;
-	uint32_t cir;
-	uint32_t cbs;
-	uint32_t eir;
-	uint32_t ebs;
+	uint32_t		cir;
+	uint32_t		cbs;
+	uint32_t		eir;
+	uint32_t		ebs;
 };
 
 /**
  * dpni_set_rx_tc_policing() - Set Rx traffic class policing configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	Traffic class policing configuration
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_set_rx_tc_policing(struct fsl_mc_io	*mc_io,
-			    uint16_t		token,
-			    uint8_t		tc_id,
+int dpni_set_rx_tc_policing(struct fsl_mc_io			*mc_io,
+			    uint32_t				cmd_flags,
+			    uint16_t				token,
+			    uint8_t				tc_id,
 			    const struct dpni_rx_tc_policing_cfg *cfg);
 
 /**
@@ -1330,7 +1530,8 @@ enum dpni_early_drop_mode {
  * @DPNI_EARLY_DROP_UNIT_FRAMES: frames units
  */
 enum dpni_early_drop_unit {
-	DPNI_EARLY_DROP_UNIT_BYTES = 0, DPNI_EARLY_DROP_UNIT_FRAMES
+	DPNI_EARLY_DROP_UNIT_BYTES = 0,
+	DPNI_EARLY_DROP_UNIT_FRAMES
 };
 
 /**
@@ -1344,14 +1545,14 @@ enum dpni_early_drop_unit {
  *			associated with the max_threshold).
  */
 struct dpni_wred_cfg {
-	uint64_t max_threshold;
-	uint64_t min_threshold;
-	uint8_t drop_probability;
+	uint64_t	max_threshold;
+	uint64_t	min_threshold;
+	uint8_t	drop_probability;
 };
 
 /**
  * struct dpni_rx_tc_early_drop_cfg - early-drop configuration
- * @drop_mode: drop mode
+ * @mode: drop mode
  * @units: untis type
  * @green: WRED - 'green' configuration
  * @yellow: WRED - 'yellow' configuration
@@ -1359,14 +1560,14 @@ struct dpni_wred_cfg {
  * @tail_drop_threshold: tail drop threshold
  */
 struct dpni_rx_tc_early_drop_cfg {
-	enum dpni_early_drop_mode mode;
-	enum dpni_early_drop_unit units;
+	enum dpni_early_drop_mode	mode;
+	enum dpni_early_drop_unit	units;
 
-	struct dpni_wred_cfg green;
-	struct dpni_wred_cfg yellow;
-	struct dpni_wred_cfg red;
+	struct dpni_wred_cfg		green;
+	struct dpni_wred_cfg		yellow;
+	struct dpni_wred_cfg		red;
 
-	uint32_t tail_drop_threshold;
+	uint32_t			tail_drop_threshold;
 };
 
 /**
@@ -1378,11 +1579,12 @@ struct dpni_rx_tc_early_drop_cfg {
  *
  */
 void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
-				   uint8_t *early_drop_buf);
+				   uint8_t		*early_drop_buf);
 
 /**
  * dpni_set_rx_tc_early_drop() - Set Rx traffic class early-drop configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @early_drop_iova:  I/O virtual address of 64 bytes;
@@ -1394,9 +1596,10 @@ void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
  * Return:	'0' on Success; error code otherwise.
  */
 int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
 			      uint16_t		token,
-			    uint8_t		tc_id,
-			    uint64_t		early_drop_iova);
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova);
 
 /**
  * enum dpni_dest - DPNI destination types
@@ -1426,9 +1629,9 @@ enum dpni_dest {
  *		channel; not relevant for 'DPNI_DEST_NONE' option
  */
 struct dpni_dest_cfg {
-	enum dpni_dest dest_type;
-	int dest_id;
-	uint8_t priority;
+	enum dpni_dest	dest_type;
+	int		dest_id;
+	uint8_t	priority;
 };
 
 /**
@@ -1476,11 +1679,11 @@ enum dpni_stash_size {
  *			Must be cacheline-aligned and DMA-able memory
  */
 struct dpni_flc_cfg {
-	enum dpni_flc_type flc_type;
-	uint32_t options;
-	enum dpni_stash_size frame_data_size;
-	enum dpni_stash_size flow_context_size;
-	uint64_t flow_context;
+	enum dpni_flc_type	flc_type;
+	uint32_t		options;
+	enum dpni_stash_size	frame_data_size;
+	enum dpni_stash_size	flow_context_size;
+	uint64_t		flow_context;
 };
 
 /* DPNI queue modification options */
@@ -1493,7 +1696,8 @@ struct dpni_flc_cfg {
  * not applicable for Tx-conf/Err queues as the FD comes from the user
  */
 #define DPNI_QUEUE_OPT_FLC		0x00000004
-
+/* Select to modify the queue's order preservation */
+#define DPNI_QUEUE_OPT_ORDER_PRESERVATION 0x00000008
 
 /**
  * struct dpni_queue_cfg - Structure representing queue configuration
@@ -1509,12 +1713,16 @@ struct dpni_flc_cfg {
  *		in the case of FS (flow-steering) the flow's FLC settings
  *		are used.
  *		valid only if 'DPNI_QUEUE_OPT_FLC' is contained in 'options'
+ * @order_preservation_en: enable/disable order preservation;
+ *		valid only if 'DPNI_QUEUE_OPT_ORDER_PRESERVATION' is contained
+ *		in 'options'
  */
 struct dpni_queue_cfg {
-	uint32_t options;
-	uint64_t user_ctx;
-	struct dpni_dest_cfg dest_cfg;
-	struct dpni_flc_cfg flc_cfg;
+	uint32_t		options;
+	uint64_t		user_ctx;
+	struct dpni_dest_cfg	dest_cfg;
+	struct dpni_flc_cfg	flc_cfg;
+	int			order_preservation_en;
 };
 
 /**
@@ -1523,13 +1731,16 @@ struct dpni_queue_cfg {
  *	dequeued frame
  * @dest_cfg: Queue destination configuration
  * @flc_cfg: Flow context configuration
+ * @order_preservation_en: enable/disable order preservation
  * @fqid: Virtual fqid value to be used for dequeue operations
  */
 struct dpni_queue_attr {
-	uint64_t user_ctx;
-	struct dpni_dest_cfg dest_cfg;
-	struct dpni_flc_cfg flc_cfg;
-	uint32_t fqid;
+	uint64_t		user_ctx;
+	struct dpni_dest_cfg	dest_cfg;
+	struct dpni_flc_cfg	flc_cfg;
+	int			order_preservation_en;
+
+	uint32_t		fqid;
 };
 
 /* DPNI Tx flow modification options */
@@ -1560,7 +1771,7 @@ struct dpni_queue_attr {
  *		'options'
  */
 struct dpni_tx_flow_cfg {
-	uint32_t options;
+	uint32_t			options;
 	/**
 	 * struct cnf_err_cfg - Tx confirmation and error configuration
 	 * @use_default_queue: Set to '1' to use the common (default) Tx
@@ -1577,17 +1788,18 @@ struct dpni_tx_flow_cfg {
 	 *		'DPNI_TX_FLOW_OPT_QUEUE' is contained in 'options'
 	 */
 	struct {
-		int use_default_queue;
-		int errors_only;
-		struct dpni_queue_cfg queue_cfg;
+		int			use_default_queue;
+		int			errors_only;
+		struct dpni_queue_cfg	queue_cfg;
 	} conf_err_cfg;
-	int l3_chksum_gen;
-	int l4_chksum_gen;
+	int				l3_chksum_gen;
+	int				l4_chksum_gen;
 };
 
 /**
  * dpni_set_tx_flow() - Set Tx flow configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	Provides (or returns) the sender's flow ID;
  *				for each new sender set (*flow_id) to
@@ -1599,6 +1811,7 @@ struct dpni_tx_flow_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_tx_flow(struct fsl_mc_io			*mc_io,
+		     uint32_t				cmd_flags,
 		     uint16_t				token,
 		     uint16_t				*flow_id,
 		     const struct dpni_tx_flow_cfg	*cfg);
@@ -1621,17 +1834,18 @@ struct dpni_tx_flow_attr {
 	 * @queue_attr: Queue attributes
 	 */
 	struct {
-		int use_default_queue;
-		int errors_only;
-		struct dpni_queue_attr queue_attr;
+		int			use_default_queue;
+		int			errors_only;
+		struct dpni_queue_attr	queue_attr;
 	} conf_err_attr;
-	int l3_chksum_gen;
-	int l4_chksum_gen;
+	int				l3_chksum_gen;
+	int				l4_chksum_gen;
 };
 
 /**
  * dpni_get_tx_flow() - Get Tx flow attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	The sender's flow ID, as returned by the
  *			dpni_set_tx_flow() function
@@ -1640,6 +1854,7 @@ struct dpni_tx_flow_attr {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
 		     uint16_t			token,
 		     uint16_t			flow_id,
 		     struct dpni_tx_flow_attr	*attr);
@@ -1647,10 +1862,11 @@ int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
 /**
  * dpni_set_rx_flow() - Set Rx flow configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7);
  *			use 'DPNI_ALL_TCS' to set all TCs and all flows
- * @flow_id	Rx flow id within the traffic class; use
+ * @flow_id:	Rx flow id within the traffic class; use
  *			'DPNI_ALL_TC_FLOWS' to set all flows within
  *			this tc_id; ignored if tc_id is set to
  *			'DPNI_ALL_TCS';
@@ -1659,6 +1875,7 @@ int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_rx_flow(struct fsl_mc_io			*mc_io,
+		     uint32_t				cmd_flags,
 		     uint16_t				token,
 		     uint8_t				tc_id,
 		     uint16_t				flow_id,
@@ -1667,6 +1884,7 @@ int dpni_set_rx_flow(struct fsl_mc_io			*mc_io,
 /**
  * dpni_get_rx_flow() -	Get Rx flow attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @flow_id:	Rx flow id within the traffic class
@@ -1675,6 +1893,7 @@ int dpni_set_rx_flow(struct fsl_mc_io			*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_rx_flow(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
 		     uint16_t			token,
 		     uint8_t			tc_id,
 		     uint16_t			flow_id,
@@ -1683,24 +1902,28 @@ int dpni_get_rx_flow(struct fsl_mc_io		*mc_io,
 /**
  * dpni_set_rx_err_queue() - Set Rx error queue configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	Queue configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_set_rx_err_queue(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  const struct dpni_queue_cfg	*cfg);
 
 /**
  * dpni_get_rx_err_queue() - Get Rx error queue attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @attr:	Returned Queue attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_get_rx_err_queue(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  struct dpni_queue_attr	*attr);
 
@@ -1708,6 +1931,7 @@ int dpni_get_rx_err_queue(struct fsl_mc_io		*mc_io,
  * dpni_set_tx_conf_err_queue() - Set Tx confirmation and error queue
  *			configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	Queue configuration
  *
@@ -1722,15 +1946,17 @@ int dpni_get_rx_err_queue(struct fsl_mc_io		*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_tx_conf_err_queue(struct fsl_mc_io			*mc_io,
+int dpni_set_tx_conf_err_queue(struct fsl_mc_io		*mc_io,
+			       uint32_t			cmd_flags,
 			       uint16_t				token,
 			       const struct dpni_queue_cfg	*cfg);
 
 /**
  * dpni_get_tx_conf_err_queue() - Get Tx confirmation and error queue attributes
- * @mc_io	Pointer to MC portal's I/O object
- * @token	Token of DPNI object
- * @attr	Returned queue attributes
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @attr:	Returned queue attributes
  *
  * If 'DPNI_OPT_TX_CONF_DISABLED' was selected at DPNI creation,
  * only error frames are reported back - successfully transmitted
@@ -1743,11 +1969,35 @@ int dpni_set_tx_conf_err_queue(struct fsl_mc_io			*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_tx_conf_err_queue(struct fsl_mc_io		*mc_io,
+int dpni_get_tx_conf_err_queue(struct fsl_mc_io	*mc_io,
+			       uint32_t		cmd_flags,
 			       uint16_t			token,
 			       struct dpni_queue_attr	*attr);
 
 /**
+ * dpni_set_tx_conf_revoke() - Tx confirmation revocation
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @revoke:	revoke or not
+ *
+ * This function is useful only when 'DPNI_OPT_TX_CONF_DISABLED' is not
+ * selected at DPNI creation.
+ * Calling this function with 'revoke' set to '1' disables all transmit
+ * confirmation (including the private confirmation queues), regardless of
+ * previous settings; Note that in this case, Tx error frames are still
+ * enqueued to the general transmit errors queue.
+ * Calling this function with 'revoke' set to '0' restores the previous
+ * settings for both general and private transmit confirmation.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_tx_conf_revoke(struct fsl_mc_io		*mc_io,
+			    uint32_t			cmd_flags,
+			    uint16_t			token,
+			    int			revoke);
+
+/**
  * struct dpni_qos_tbl_cfg - Structure representing QOS table configuration
  * @key_cfg_iova: I/O virtual address of 256 bytes DMA-able memory filled with
  *		key extractions to be used as the QoS criteria by calling
@@ -1757,14 +2007,15 @@ int dpni_get_tx_conf_err_queue(struct fsl_mc_io		*mc_io,
  * @default_tc: Used in case of no-match and 'discard_on_miss'= 0
  */
 struct dpni_qos_tbl_cfg {
-	uint64_t key_cfg_iova;
-	int discard_on_miss;
-	uint8_t default_tc;
+	uint64_t	key_cfg_iova;
+	int		discard_on_miss;
+	uint8_t	default_tc;
 };
 
 /**
  * dpni_set_qos_table() - Set QoS mapping table
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	QoS table configuration
  *
@@ -1776,7 +2027,8 @@ struct dpni_qos_tbl_cfg {
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_qos_table(struct fsl_mc_io			*mc_io,
+int dpni_set_qos_table(struct fsl_mc_io		*mc_io,
+		       uint32_t			cmd_flags,
 		       uint16_t				token,
 		       const struct dpni_qos_tbl_cfg	*cfg);
 
@@ -1787,21 +2039,23 @@ int dpni_set_qos_table(struct fsl_mc_io			*mc_io,
  * @key_size: key and mask size (in bytes)
  */
 struct dpni_rule_cfg {
-	uint64_t key_iova;
-	uint64_t mask_iova;
-	uint8_t key_size;
+	uint64_t	key_iova;
+	uint64_t	mask_iova;
+	uint8_t	key_size;
 };
 
 /**
  * dpni_add_qos_entry() - Add QoS mapping entry (to select a traffic class)
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	QoS rule to add
  * @tc_id:	Traffic class selection (0-7)
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_add_qos_entry(struct fsl_mc_io			*mc_io,
+int dpni_add_qos_entry(struct fsl_mc_io		*mc_io,
+		       uint32_t			cmd_flags,
 		       uint16_t				token,
 		       const struct dpni_rule_cfg	*cfg,
 		       uint8_t				tc_id);
@@ -1809,18 +2063,21 @@ int dpni_add_qos_entry(struct fsl_mc_io			*mc_io,
 /**
  * dpni_remove_qos_entry() - Remove QoS mapping entry
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @cfg:	QoS rule to remove
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_remove_qos_entry(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  const struct dpni_rule_cfg	*cfg);
 
 /**
  * dpni_clear_qos_table() - Clear all QoS mapping entries
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  *
  * Following this function call, all frames are directed to
@@ -1828,12 +2085,15 @@ int dpni_remove_qos_entry(struct fsl_mc_io		*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_clear_qos_table(struct fsl_mc_io *mc_io, uint16_t token);
+int dpni_clear_qos_table(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
+			 uint16_t		token);
 
 /**
  * dpni_add_fs_entry() - Add Flow Steering entry for a specific traffic class
  *			(to select a flow ID)
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	Flow steering rule to add
@@ -1843,6 +2103,7 @@ int dpni_clear_qos_table(struct fsl_mc_io *mc_io, uint16_t token);
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_add_fs_entry(struct fsl_mc_io			*mc_io,
+		      uint32_t				cmd_flags,
 		      uint16_t				token,
 		      uint8_t				tc_id,
 		      const struct dpni_rule_cfg	*cfg,
@@ -1852,6 +2113,7 @@ int dpni_add_fs_entry(struct fsl_mc_io			*mc_io,
  * dpni_remove_fs_entry() - Remove Flow Steering entry from a specific
  *			traffic class
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	Flow steering rule to remove
@@ -1859,6 +2121,7 @@ int dpni_add_fs_entry(struct fsl_mc_io			*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_remove_fs_entry(struct fsl_mc_io		*mc_io,
+			 uint32_t			cmd_flags,
 			 uint16_t			token,
 			 uint8_t			tc_id,
 			 const struct dpni_rule_cfg	*cfg);
@@ -1867,18 +2130,21 @@ int dpni_remove_fs_entry(struct fsl_mc_io		*mc_io,
  * dpni_clear_fs_entries() - Clear all Flow Steering entries of a specific
  *			traffic class
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_clear_fs_entries(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		tc_id);
 
 /**
  * dpni_set_vlan_insertion() - Enable/disable VLAN insertion for egress frames
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
@@ -1887,11 +2153,15 @@ int dpni_clear_fs_entries(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_insertion(struct fsl_mc_io *mc_io, uint16_t token, int en);
+int dpni_set_vlan_insertion(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
+			    uint16_t		token,
+			    int		en);
 
 /**
  * dpni_set_vlan_removal() - Enable/disable VLAN removal for ingress frames
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
@@ -1900,11 +2170,15 @@ int dpni_set_vlan_insertion(struct fsl_mc_io *mc_io, uint16_t token, int en);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_removal(struct fsl_mc_io *mc_io, uint16_t token, int en);
+int dpni_set_vlan_removal(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
+			  uint16_t		token,
+			  int			en);
 
 /**
  * dpni_set_ipr() - Enable/disable IP reassembly of ingress frames
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
@@ -1912,11 +2186,15 @@ int dpni_set_vlan_removal(struct fsl_mc_io *mc_io, uint16_t token, int en);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_ipr(struct fsl_mc_io *mc_io, uint16_t token, int en);
+int dpni_set_ipr(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 int			en);
 
 /**
  * dpni_set_ipf() - Enable/disable IP fragmentation of egress frames
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @en:		Set to '1' to enable; '0' to disable
  *
@@ -1926,8 +2204,9 @@ int dpni_set_ipr(struct fsl_mc_io *mc_io, uint16_t token, int en);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_ipf(struct fsl_mc_io *mc_io, uint16_t token, int en);
-
-/** @} */
+int dpni_set_ipf(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 int			en);
 
 #endif /* __FSL_DPNI_H */
diff --git a/drivers/staging/fsl-dpaa2/ethsw/dpsw-cmd.h b/drivers/staging/fsl-dpaa2/ethsw/dpsw-cmd.h
index c430c3a..db86f66 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/dpsw-cmd.h
+++ b/drivers/staging/fsl-dpaa2/ethsw/dpsw-cmd.h
@@ -36,7 +36,7 @@
 #define DPSW_CMD_EARLY_DROP_EXT_PARAMS		13
 
 /* DPSW Version */
-#define DPSW_VER_MAJOR				5
+#define DPSW_VER_MAJOR				6
 #define DPSW_VER_MINOR				0
 
 /* Command IDs */
@@ -63,9 +63,8 @@
 #define DPSW_CMDID_SET_REFLECTION_IF		0x022
 
 #define DPSW_CMDID_ADD_CUSTOM_TPID		0x024
-#define DPSW_CMDID_SET_CTRL_IF			0x025
+
 #define DPSW_CMDID_REMOVE_CUSTOM_TPID		0x026
-#define DPSW_CMDID_GET_CTRL_IF			0x027
 
 #define DPSW_CMDID_IF_SET_TCI			0x030
 #define DPSW_CMDID_IF_SET_STP			0x031
@@ -73,7 +72,7 @@
 #define DPSW_CMDID_SET_IF_ACCEPT_ALL_VLAN	0x033
 #define DPSW_CMDID_IF_GET_COUNTER		0x034
 #define DPSW_CMDID_IF_SET_COUNTER		0x035
-#define DPSW_CMDID_IF_SET_TC_MAP		0x036
+#define DPSW_CMDID_IF_SET_TX_SELECTION		0x036
 #define DPSW_CMDID_IF_ADD_REFLECTION		0x037
 #define DPSW_CMDID_IF_REMOVE_REFLECTION		0x038
 #define DPSW_CMDID_IF_SET_FLOODING_METERING	0x039
@@ -125,6 +124,12 @@
 #define DPSW_CMDID_ACL_REMOVE_ENTRY		0x093
 #define DPSW_CMDID_ACL_ADD_IF			0x094
 #define DPSW_CMDID_ACL_REMOVE_IF		0x095
+#define DPSW_CMDID_ACL_GET_ATTR			0x096
+
+#define DPSW_CMDID_CTRL_IF_GET_ATTR		0x0A0
+#define DPSW_CMDID_CTRL_IF_SET_POOLS		0x0A1
+#define DPSW_CMDID_CTRL_IF_ENABLE		0x0A2
+#define DPSW_CMDID_CTRL_IF_DISABLE		0x0A3
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPSW_CMD_OPEN(cmd, dpsw_id) \
@@ -136,7 +141,6 @@ do { \
 	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, cfg->num_ifs);\
 	MC_CMD_OP(cmd, 0, 16,  8, uint8_t,  cfg->adv.max_fdbs);\
 	MC_CMD_OP(cmd, 0, 24,  8, uint8_t,  cfg->adv.max_meters_per_if);\
-	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, cfg->adv.ctrl_if_id);\
 	MC_CMD_OP(cmd, 1, 0,  16, uint16_t, cfg->adv.max_vlans);\
 	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, cfg->adv.max_fdb_entries);\
 	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, cfg->adv.fdb_aging_time);\
@@ -149,12 +153,12 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPSW_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPSW_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr);\
-	MC_CMD_OP(cmd, 2, 0,  32, int,	 user_irq_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_cfg->val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr);\
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -162,12 +166,12 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPSW_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPSW_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr);\
-	MC_RSP_OP(cmd, 2, 0,  32, int,	 user_irq_id); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	 type); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr);\
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -239,14 +243,6 @@ do { \
 	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPSW_CMD_SET_CTRL_IF(cmd, if_id) \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPSW_RSP_GET_CTRL_IF(cmd, if_id) \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, if_id)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPSW_CMD_IF_SET_FLOODING(cmd, if_id, en) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
@@ -331,7 +327,7 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPSW_CMD_IF_SET_TC_MAP(cmd, if_id, cfg) \
+#define DPSW_CMD_IF_SET_TX_SELECTION(cmd, if_id, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
 	MC_CMD_OP(cmd, 0, 16, 3,  enum dpsw_priority_selector, \
@@ -344,6 +340,30 @@ do { \
 	MC_CMD_OP(cmd, 1, 40, 8,  uint8_t,  cfg->tc_id[5]);\
 	MC_CMD_OP(cmd, 1, 48, 8,  uint8_t,  cfg->tc_id[6]);\
 	MC_CMD_OP(cmd, 1, 56, 8,  uint8_t,  cfg->tc_id[7]);\
+	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->tc_sched[0].delta_bandwidth);\
+	MC_CMD_OP(cmd, 2, 16, 4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[0].mode);\
+	MC_CMD_OP(cmd, 2, 32, 16, uint16_t, cfg->tc_sched[1].delta_bandwidth);\
+	MC_CMD_OP(cmd, 2, 48, 4,  enum dpsw_schedule_mode, \
+					    cfg->tc_sched[1].mode);\
+	MC_CMD_OP(cmd, 3, 0,  16, uint16_t, cfg->tc_sched[2].delta_bandwidth);\
+	MC_CMD_OP(cmd, 3, 16, 4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[2].mode);\
+	MC_CMD_OP(cmd, 3, 32, 16, uint16_t, cfg->tc_sched[3].delta_bandwidth);\
+	MC_CMD_OP(cmd, 3, 48, 4,  enum dpsw_schedule_mode, \
+					    cfg->tc_sched[3].mode);\
+	MC_CMD_OP(cmd, 4, 0,  16, uint16_t, cfg->tc_sched[4].delta_bandwidth);\
+	MC_CMD_OP(cmd, 4, 16,  4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[4].mode);\
+	MC_CMD_OP(cmd, 4, 32, 16, uint16_t, cfg->tc_sched[5].delta_bandwidth);\
+	MC_CMD_OP(cmd, 4, 48, 4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[5].mode);\
+	MC_CMD_OP(cmd, 5, 0,  16, uint16_t, cfg->tc_sched[6].delta_bandwidth);\
+	MC_CMD_OP(cmd, 5, 16, 4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[6].mode);\
+	MC_CMD_OP(cmd, 5, 32, 16, uint16_t, cfg->tc_sched[7].delta_bandwidth);\
+	MC_CMD_OP(cmd, 5, 48, 4,  enum dpsw_schedule_mode,  \
+					    cfg->tc_sched[7].mode);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -446,7 +466,8 @@ do { \
 	MC_RSP_OP(cmd, 0, 5,  1,  int,      attr->enabled);\
 	MC_RSP_OP(cmd, 0, 6,  1,  int,      attr->accept_all_vlan);\
 	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  attr->num_tcs);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->options);\
+	MC_RSP_OP(cmd, 0, 32, 32, uint32_t, attr->tx_fqid);\
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->options);\
 	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->rate);\
 } while (0)
 
@@ -782,4 +803,54 @@ do { \
 	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, cfg->num_ifs); \
 } while (0)
 
+/*                cmd, param, offset, width, type, arg_name */
+#define DPSW_CMD_ACL_GET_ATTR(cmd, acl_id) \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, acl_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPSW_RSP_ACL_GET_ATTR(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 1, 0,  16, uint16_t, attr->max_entries);\
+	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, attr->num_entries);\
+	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, attr->num_ifs);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPSW_RSP_CTRL_IF_GET_ATTR(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->rx_fqid);\
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, attr->rx_err_fqid);\
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tx_err_conf_fqid);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPSW_CMD_CTRL_IF_SET_POOLS(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->num_dpbp); \
+	MC_CMD_OP(cmd, 0, 8,  1,  int,      cfg->pools[0].backup_pool); \
+	MC_CMD_OP(cmd, 0, 9,  1,  int,      cfg->pools[1].backup_pool); \
+	MC_CMD_OP(cmd, 0, 10, 1,  int,      cfg->pools[2].backup_pool); \
+	MC_CMD_OP(cmd, 0, 11, 1,  int,      cfg->pools[3].backup_pool); \
+	MC_CMD_OP(cmd, 0, 12, 1,  int,      cfg->pools[4].backup_pool); \
+	MC_CMD_OP(cmd, 0, 13, 1,  int,      cfg->pools[5].backup_pool); \
+	MC_CMD_OP(cmd, 0, 14, 1,  int,      cfg->pools[6].backup_pool); \
+	MC_CMD_OP(cmd, 0, 15, 1,  int,      cfg->pools[7].backup_pool); \
+	MC_CMD_OP(cmd, 0, 32, 32, int,      cfg->pools[0].dpbp_id); \
+	MC_CMD_OP(cmd, 4, 32, 16, uint16_t, cfg->pools[0].buffer_size);\
+	MC_CMD_OP(cmd, 1, 0,  32, int,      cfg->pools[1].dpbp_id); \
+	MC_CMD_OP(cmd, 4, 48, 16, uint16_t, cfg->pools[1].buffer_size);\
+	MC_CMD_OP(cmd, 1, 32, 32, int,      cfg->pools[2].dpbp_id); \
+	MC_CMD_OP(cmd, 5, 0,  16, uint16_t, cfg->pools[2].buffer_size);\
+	MC_CMD_OP(cmd, 2, 0,  32, int,      cfg->pools[3].dpbp_id); \
+	MC_CMD_OP(cmd, 5, 16, 16, uint16_t, cfg->pools[3].buffer_size);\
+	MC_CMD_OP(cmd, 2, 32, 32, int,      cfg->pools[4].dpbp_id); \
+	MC_CMD_OP(cmd, 5, 32, 16, uint16_t, cfg->pools[4].buffer_size);\
+	MC_CMD_OP(cmd, 3, 0,  32, int,      cfg->pools[5].dpbp_id); \
+	MC_CMD_OP(cmd, 5, 48, 16, uint16_t, cfg->pools[5].buffer_size);\
+	MC_CMD_OP(cmd, 3, 32, 32, int,      cfg->pools[6].dpbp_id); \
+	MC_CMD_OP(cmd, 6, 0,  16, uint16_t, cfg->pools[6].buffer_size);\
+	MC_CMD_OP(cmd, 4, 0,  32, int,      cfg->pools[7].dpbp_id); \
+	MC_CMD_OP(cmd, 6, 16, 16, uint16_t, cfg->pools[7].buffer_size);\
+} while (0)
+
 #endif /* __FSL_DPSW_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/ethsw/dpsw.c b/drivers/staging/fsl-dpaa2/ethsw/dpsw.c
index cd9ff69..308b738 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/dpsw.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/dpsw.c
@@ -75,14 +75,18 @@ static int read_if_id_bitmap(uint16_t *if_id,
 }
 
 /* DPSW APIs */
-int dpsw_open(struct fsl_mc_io *mc_io, int dpsw_id, uint16_t *token)
+int dpsw_open(struct fsl_mc_io *mc_io,
+	      uint32_t cmd_flags,
+	      int dpsw_id,
+	      uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPSW_CMD_OPEN(cmd, dpsw_id);
 
 	/* send command to mc*/
@@ -96,19 +100,23 @@ int dpsw_open(struct fsl_mc_io *mc_io, int dpsw_id, uint16_t *token)
 	return 0;
 }
 
-int dpsw_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpsw_close(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CLOSE,
-					  MC_CMD_PRI_HIGH, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpsw_create(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
 		const struct dpsw_cfg *cfg,
 		uint16_t *token)
 {
@@ -117,7 +125,8 @@ int dpsw_create(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CREATE,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPSW_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -131,51 +140,61 @@ int dpsw_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpsw_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpsw_destroy(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_enable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpsw_enable(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_disable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpsw_disable(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_DISABLE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpsw_is_enabled(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IS_ENABLED, MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IS_ENABLED, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -189,51 +208,52 @@ int dpsw_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpsw_reset(struct fsl_mc_io *mc_io, uint16_t token)
+int dpsw_reset(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_RESET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpsw_set_irq(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
 		 uint16_t token,
 		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id)
+		 struct dpsw_irq_cfg *irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
-	DPSW_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+	DPSW_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpsw_get_irq(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
 		 uint16_t token,
 		 uint8_t irq_index,
 		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id)
+		 struct dpsw_irq_cfg *irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_GET_IRQ(cmd, irq_index);
 
@@ -243,12 +263,13 @@ int dpsw_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPSW_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPSW_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpsw_set_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t en)
@@ -257,7 +278,8 @@ int dpsw_set_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -265,6 +287,7 @@ int dpsw_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_get_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t *en)
@@ -274,7 +297,8 @@ int dpsw_get_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -289,6 +313,7 @@ int dpsw_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_set_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t mask)
@@ -297,7 +322,8 @@ int dpsw_set_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -305,6 +331,7 @@ int dpsw_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_get_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t *mask)
@@ -314,7 +341,8 @@ int dpsw_get_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -329,6 +357,7 @@ int dpsw_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_get_irq_status(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t *status)
@@ -338,7 +367,8 @@ int dpsw_get_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -353,6 +383,7 @@ int dpsw_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_clear_irq_status(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint32_t status)
@@ -361,7 +392,8 @@ int dpsw_clear_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -369,6 +401,7 @@ int dpsw_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_get_attributes(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			struct dpsw_attr *attr)
 {
@@ -377,7 +410,7 @@ int dpsw_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -392,6 +425,7 @@ int dpsw_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_set_reflection_if(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t if_id)
 {
@@ -399,60 +433,25 @@ int dpsw_set_reflection_if(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_REFLECTION_IF,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_SET_REFLECTION_IF(cmd, if_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_set_ctrl_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t if_id)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_CTRL_IF,
-					  MC_CMD_PRI_LOW, token);
-	DPSW_CMD_SET_CTRL_IF(cmd, if_id);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpsw_get_ctrl_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t *if_id)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPSW_CMDID_GET_CTRL_IF,
-					  MC_CMD_PRI_LOW, token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPSW_RSP_GET_CTRL_IF(cmd, *if_id);
-
-	return 0;
-}
-
 int dpsw_if_set_link_cfg(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			   uint16_t if_id,
-			   struct dpsw_link_cfg *cfg)
+			 uint16_t if_id,
+			 struct dpsw_link_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_LINK_CFG,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_SET_LINK_CFG(cmd, if_id, cfg);
 
@@ -461,16 +460,17 @@ int dpsw_if_set_link_cfg(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_get_link_state(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
-			     uint16_t if_id,
-			     struct dpsw_link_state *state)
+			   uint16_t if_id,
+			   struct dpsw_link_state *state)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_LINK_STATE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_GET_LINK_STATE(cmd, if_id);
 
@@ -486,6 +486,7 @@ int dpsw_if_get_link_state(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_flooding(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 uint16_t if_id,
 			 int en)
@@ -494,7 +495,8 @@ int dpsw_if_set_flooding(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_FLOODING,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_FLOODING(cmd, if_id, en);
 
 	/* send command to mc*/
@@ -502,6 +504,7 @@ int dpsw_if_set_flooding(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_broadcast(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint16_t if_id,
 			  int en)
@@ -510,7 +513,8 @@ int dpsw_if_set_broadcast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_BROADCAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_FLOODING(cmd, if_id, en);
 
 	/* send command to mc*/
@@ -518,6 +522,7 @@ int dpsw_if_set_broadcast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_multicast(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint16_t if_id,
 			  int en)
@@ -526,7 +531,8 @@ int dpsw_if_set_multicast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_MULTICAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_FLOODING(cmd, if_id, en);
 
 	/* send command to mc*/
@@ -534,6 +540,7 @@ int dpsw_if_set_multicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_tci(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    uint16_t if_id,
 		    const struct dpsw_tci_cfg *cfg)
@@ -542,7 +549,7 @@ int dpsw_if_set_tci(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_TCI,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_SET_TCI(cmd, if_id, cfg);
 
@@ -551,6 +558,7 @@ int dpsw_if_set_tci(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_get_tci(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    uint16_t if_id,
 		    struct dpsw_tci_cfg *cfg)
@@ -560,7 +568,7 @@ int dpsw_if_get_tci(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_TCI,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_GET_TCI(cmd, if_id);
 
@@ -576,6 +584,7 @@ int dpsw_if_get_tci(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_stp(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    uint16_t if_id,
 		    const struct dpsw_stp_cfg *cfg)
@@ -584,7 +593,8 @@ int dpsw_if_set_stp(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_STP,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_STP(cmd, if_id, cfg);
 
 	/* send command to mc*/
@@ -592,6 +602,7 @@ int dpsw_if_set_stp(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_accepted_frames(struct fsl_mc_io *mc_io,
+				uint32_t cmd_flags,
 				uint16_t token,
 				uint16_t if_id,
 				const struct dpsw_accepted_frames_cfg *cfg)
@@ -600,7 +611,8 @@ int dpsw_if_set_accepted_frames(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_ACCEPTED_FRAMES,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_ACCEPTED_FRAMES(cmd, if_id, cfg);
 
 	/* send command to mc*/
@@ -608,6 +620,7 @@ int dpsw_if_set_accepted_frames(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_accept_all_vlan(struct fsl_mc_io *mc_io,
+				uint32_t cmd_flags,
 				uint16_t token,
 				uint16_t if_id,
 				int accept_all)
@@ -616,7 +629,8 @@ int dpsw_if_set_accept_all_vlan(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_SET_IF_ACCEPT_ALL_VLAN,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_ACCEPT_ALL_VLAN(cmd, if_id, accept_all);
 
 	/* send command to mc*/
@@ -624,6 +638,7 @@ int dpsw_if_set_accept_all_vlan(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_get_counter(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint16_t if_id,
 			enum dpsw_counter type,
@@ -634,7 +649,8 @@ int dpsw_if_get_counter(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_COUNTER,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_GET_COUNTER(cmd, if_id, type);
 
 	/* send command to mc*/
@@ -649,6 +665,7 @@ int dpsw_if_get_counter(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_counter(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint16_t if_id,
 			enum dpsw_counter type,
@@ -658,30 +675,34 @@ int dpsw_if_set_counter(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_COUNTER,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_COUNTER(cmd, if_id, type, counter);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_if_set_tc_map(struct fsl_mc_io *mc_io,
-		       uint16_t token,
-		       uint16_t if_id,
-		       const struct dpsw_tc_map_cfg *cfg)
+int dpsw_if_set_tx_selection(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
+			     uint16_t token,
+			     uint16_t if_id,
+			     const struct dpsw_tx_selection_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_TC_MAP,
-					  MC_CMD_PRI_LOW, token);
-	DPSW_CMD_IF_SET_TC_MAP(cmd, if_id, cfg);
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_TX_SELECTION,
+					  cmd_flags,
+					  token);
+	DPSW_CMD_IF_SET_TX_SELECTION(cmd, if_id, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpsw_if_add_reflection(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t if_id,
 			   const struct dpsw_reflection_cfg *cfg)
@@ -690,7 +711,8 @@ int dpsw_if_add_reflection(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_ADD_REFLECTION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_ADD_REFLECTION(cmd, if_id, cfg);
 
 	/* send command to mc*/
@@ -698,6 +720,7 @@ int dpsw_if_add_reflection(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_remove_reflection(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t if_id,
 			      const struct dpsw_reflection_cfg *cfg)
@@ -706,7 +729,8 @@ int dpsw_if_remove_reflection(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_REMOVE_REFLECTION,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_REMOVE_REFLECTION(cmd, if_id, cfg);
 
 	/* send command to mc*/
@@ -714,15 +738,17 @@ int dpsw_if_remove_reflection(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_flooding_metering(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
-				    uint16_t if_id,
-				    const struct dpsw_metering_cfg *cfg)
+				  uint16_t if_id,
+				  const struct dpsw_metering_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_FLOODING_METERING,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_FLOODING_METERING(cmd, if_id, cfg);
 
 	/* send command to mc*/
@@ -730,6 +756,7 @@ int dpsw_if_set_flooding_metering(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_metering(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 uint16_t if_id,
 			 uint8_t tc_id,
@@ -739,7 +766,8 @@ int dpsw_if_set_metering(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_METERING,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_METERING(cmd, if_id, tc_id, cfg);
 
 	/* send command to mc*/
@@ -755,16 +783,17 @@ void dpsw_prepare_early_drop(const struct dpsw_early_drop_cfg *cfg,
 }
 
 int dpsw_if_set_early_drop(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
 			   uint16_t		token,
-			    uint16_t		if_id,
-			    uint8_t		tc_id,
-			    uint64_t		early_drop_iova)
+			   uint16_t		if_id,
+			   uint8_t		tc_id,
+			   uint64_t		early_drop_iova)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_EARLY_DROP,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_SET_EARLY_DROP(cmd, if_id, tc_id, early_drop_iova);
 
@@ -773,14 +802,16 @@ int dpsw_if_set_early_drop(struct fsl_mc_io	*mc_io,
 }
 
 int dpsw_add_custom_tpid(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			    const struct dpsw_custom_tpid_cfg *cfg)
+			 const struct dpsw_custom_tpid_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ADD_CUSTOM_TPID,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_ADD_CUSTOM_TPID(cmd, cfg);
 
 	/* send command to mc*/
@@ -788,6 +819,7 @@ int dpsw_add_custom_tpid(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_remove_custom_tpid(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
 			    uint16_t token,
 			    const struct dpsw_custom_tpid_cfg *cfg)
 {
@@ -795,20 +827,24 @@ int dpsw_remove_custom_tpid(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_REMOVE_CUSTOM_TPID,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_REMOVE_CUSTOM_TPID(cmd, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_if_enable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id)
+int dpsw_if_enable(struct fsl_mc_io *mc_io,
+		   uint32_t cmd_flags,
+		   uint16_t token,
+		   uint16_t if_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_ENABLE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_ENABLE(cmd, if_id);
 
@@ -816,13 +852,16 @@ int dpsw_if_enable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id)
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_if_disable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id)
+int dpsw_if_disable(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    uint16_t if_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_DISABLE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_IF_DISABLE(cmd, if_id);
 
@@ -831,6 +870,7 @@ int dpsw_if_disable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id)
 }
 
 int dpsw_if_get_token(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint16_t if_id,
 		      uint16_t *if_token)
@@ -840,7 +880,8 @@ int dpsw_if_get_token(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_TOKEN,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_GET_TOKEN(cmd, if_id);
 
 	/* send command to mc*/
@@ -855,6 +896,7 @@ int dpsw_if_get_token(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_get_attributes(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t if_id,
 			   struct dpsw_if_attr *attr)
@@ -864,7 +906,8 @@ int dpsw_if_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_ATTR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_GET_ATTR(cmd, if_id);
 
 	/* send command to mc*/
@@ -879,6 +922,7 @@ int dpsw_if_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_set_max_frame_length(struct fsl_mc_io *mc_io,
+				 uint32_t cmd_flags,
 				 uint16_t token,
 				 uint16_t if_id,
 				 uint16_t frame_length)
@@ -887,7 +931,8 @@ int dpsw_if_set_max_frame_length(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_SET_MAX_FRAME_LENGTH,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_SET_MAX_FRAME_LENGTH(cmd, if_id, frame_length);
 
 	/* send command to mc*/
@@ -895,6 +940,7 @@ int dpsw_if_set_max_frame_length(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_if_get_max_frame_length(struct fsl_mc_io *mc_io,
+				 uint32_t cmd_flags,
 				 uint16_t token,
 				 uint16_t if_id,
 				 uint16_t *frame_length)
@@ -904,7 +950,8 @@ int dpsw_if_get_max_frame_length(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_IF_GET_MAX_FRAME_LENGTH,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_IF_GET_MAX_FRAME_LENGTH(cmd, if_id);
 
 	/* send command to mc*/
@@ -918,6 +965,7 @@ int dpsw_if_get_max_frame_length(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_add(struct fsl_mc_io *mc_io,
+		  uint32_t cmd_flags,
 		  uint16_t token,
 		  uint16_t vlan_id,
 		  const struct dpsw_vlan_cfg *cfg)
@@ -926,7 +974,7 @@ int dpsw_vlan_add(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_ADD,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_ADD(cmd, vlan_id, cfg);
 
@@ -935,6 +983,7 @@ int dpsw_vlan_add(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_add_if(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint16_t vlan_id,
 		     const struct dpsw_vlan_if_cfg *cfg)
@@ -944,7 +993,8 @@ int dpsw_vlan_add_if(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_ADD_IF,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_VLAN_ADD_IF(cmd, vlan_id);
 
 	/* send command to mc*/
@@ -952,6 +1002,7 @@ int dpsw_vlan_add_if(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t vlan_id,
 			      const struct dpsw_vlan_if_cfg *cfg)
@@ -961,7 +1012,7 @@ int dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_ADD_IF_UNTAGGED,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_ADD_IF_UNTAGGED(cmd, vlan_id);
 
@@ -970,6 +1021,7 @@ int dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_add_if_flooding(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t vlan_id,
 			      const struct dpsw_vlan_if_cfg *cfg)
@@ -979,7 +1031,7 @@ int dpsw_vlan_add_if_flooding(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_ADD_IF_FLOODING,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_ADD_IF_FLOODING(cmd, vlan_id);
 
@@ -988,6 +1040,7 @@ int dpsw_vlan_add_if_flooding(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_remove_if(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint16_t vlan_id,
 			const struct dpsw_vlan_if_cfg *cfg)
@@ -997,7 +1050,8 @@ int dpsw_vlan_remove_if(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_REMOVE_IF,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_VLAN_REMOVE_IF(cmd, vlan_id);
 
 	/* send command to mc*/
@@ -1005,6 +1059,7 @@ int dpsw_vlan_remove_if(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_remove_if_untagged(struct fsl_mc_io *mc_io,
+				 uint32_t cmd_flags,
 				 uint16_t token,
 				 uint16_t vlan_id,
 				 const struct dpsw_vlan_if_cfg *cfg)
@@ -1014,7 +1069,7 @@ int dpsw_vlan_remove_if_untagged(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_REMOVE_IF_UNTAGGED,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_REMOVE_IF_UNTAGGED(cmd, vlan_id);
 
@@ -1023,6 +1078,7 @@ int dpsw_vlan_remove_if_untagged(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_remove_if_flooding(struct fsl_mc_io *mc_io,
+				 uint32_t cmd_flags,
 				 uint16_t token,
 				 uint16_t vlan_id,
 				 const struct dpsw_vlan_if_cfg *cfg)
@@ -1032,7 +1088,7 @@ int dpsw_vlan_remove_if_flooding(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_REMOVE_IF_FLOODING,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_REMOVE_IF_FLOODING(cmd, vlan_id);
 
@@ -1040,13 +1096,17 @@ int dpsw_vlan_remove_if_flooding(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpsw_vlan_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t vlan_id)
+int dpsw_vlan_remove(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     uint16_t vlan_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_REMOVE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_VLAN_REMOVE(cmd, vlan_id);
 
 	/* send command to mc*/
@@ -1054,6 +1114,7 @@ int dpsw_vlan_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t vlan_id)
 }
 
 int dpsw_vlan_get_attributes(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
 			     uint16_t token,
 			     uint16_t vlan_id,
 			     struct dpsw_vlan_attr *attr)
@@ -1063,7 +1124,7 @@ int dpsw_vlan_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_GET_ATTRIBUTES,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_GET_ATTR(cmd, vlan_id);
 
@@ -1079,6 +1140,7 @@ int dpsw_vlan_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_get_if(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     uint16_t vlan_id,
 		     struct dpsw_vlan_if_cfg *cfg)
@@ -1088,7 +1150,8 @@ int dpsw_vlan_get_if(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_GET_IF,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_VLAN_GET_IF(cmd, vlan_id);
 
 	/* send command to mc*/
@@ -1104,6 +1167,7 @@ int dpsw_vlan_get_if(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_get_if_flooding(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t vlan_id,
 			      struct dpsw_vlan_if_cfg *cfg)
@@ -1113,7 +1177,7 @@ int dpsw_vlan_get_if_flooding(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_GET_IF_FLOODING,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_GET_IF_FLOODING(cmd, vlan_id);
 
@@ -1130,6 +1194,7 @@ int dpsw_vlan_get_if_flooding(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_vlan_get_if_untagged(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t vlan_id,
 			      struct dpsw_vlan_if_cfg *cfg)
@@ -1139,7 +1204,7 @@ int dpsw_vlan_get_if_untagged(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_VLAN_GET_IF_UNTAGGED,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_VLAN_GET_IF_UNTAGGED(cmd, vlan_id);
 
@@ -1156,6 +1221,7 @@ int dpsw_vlan_get_if_untagged(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_add(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
 		 uint16_t token,
 		 uint16_t *fdb_id,
 		 const struct dpsw_fdb_cfg *cfg)
@@ -1165,7 +1231,7 @@ int dpsw_fdb_add(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_ADD,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_FDB_ADD(cmd, cfg);
 
@@ -1180,13 +1246,16 @@ int dpsw_fdb_add(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpsw_fdb_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t fdb_id)
+int dpsw_fdb_remove(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    uint16_t fdb_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_REMOVE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_FDB_REMOVE(cmd, fdb_id);
 
@@ -1195,6 +1264,7 @@ int dpsw_fdb_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t fdb_id)
 }
 
 int dpsw_fdb_add_unicast(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 uint16_t fdb_id,
 			 const struct dpsw_fdb_unicast_cfg *cfg)
@@ -1203,7 +1273,8 @@ int dpsw_fdb_add_unicast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_ADD_UNICAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_FDB_ADD_UNICAST(cmd, fdb_id, cfg);
 
 	/* send command to mc*/
@@ -1211,6 +1282,7 @@ int dpsw_fdb_add_unicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_get_unicast(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
 			 uint16_t fdb_id,
 			 struct dpsw_fdb_unicast_cfg *cfg)
@@ -1220,7 +1292,8 @@ int dpsw_fdb_get_unicast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_GET_UNICAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_FDB_GET_UNICAST(cmd, fdb_id);
 
 	/* send command to mc*/
@@ -1235,6 +1308,7 @@ int dpsw_fdb_get_unicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
 			    uint16_t token,
 			    uint16_t fdb_id,
 			    const struct dpsw_fdb_unicast_cfg *cfg)
@@ -1243,7 +1317,8 @@ int dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_REMOVE_UNICAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_FDB_REMOVE_UNICAST(cmd, fdb_id, cfg);
 
 	/* send command to mc*/
@@ -1251,6 +1326,7 @@ int dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_add_multicast(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t fdb_id,
 			   const struct dpsw_fdb_multicast_cfg *cfg)
@@ -1260,7 +1336,8 @@ int dpsw_fdb_add_multicast(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 2);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_ADD_MULTICAST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_FDB_ADD_MULTICAST(cmd, fdb_id, cfg);
 
 	/* send command to mc*/
@@ -1268,6 +1345,7 @@ int dpsw_fdb_add_multicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_get_multicast(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t fdb_id,
 			   struct dpsw_fdb_multicast_cfg *cfg)
@@ -1277,7 +1355,7 @@ int dpsw_fdb_get_multicast(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_GET_MULTICAST,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_FDB_GET_MULTICAST(cmd, fdb_id);
 
@@ -1294,6 +1372,7 @@ int dpsw_fdb_get_multicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_remove_multicast(struct fsl_mc_io *mc_io,
+			      uint32_t cmd_flags,
 			      uint16_t token,
 			      uint16_t fdb_id,
 			      const struct dpsw_fdb_multicast_cfg *cfg)
@@ -1303,7 +1382,7 @@ int dpsw_fdb_remove_multicast(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 2);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_REMOVE_MULTICAST,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_FDB_REMOVE_MULTICAST(cmd, fdb_id, cfg);
 
@@ -1312,6 +1391,7 @@ int dpsw_fdb_remove_multicast(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_set_learning_mode(struct fsl_mc_io *mc_io,
+			       uint32_t cmd_flags,
 			       uint16_t token,
 			       uint16_t fdb_id,
 			       enum dpsw_fdb_learning_mode mode)
@@ -1320,7 +1400,7 @@ int dpsw_fdb_set_learning_mode(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_SET_LEARNING_MODE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_FDB_SET_LEARNING_MODE(cmd, fdb_id, mode);
 
@@ -1329,6 +1409,7 @@ int dpsw_fdb_set_learning_mode(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_fdb_get_attributes(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
 			    uint16_t token,
 			    uint16_t fdb_id,
 			    struct dpsw_fdb_attr *attr)
@@ -1338,7 +1419,8 @@ int dpsw_fdb_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_FDB_GET_ATTR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_FDB_GET_ATTR(cmd, fdb_id);
 
 	/* send command to mc*/
@@ -1353,6 +1435,7 @@ int dpsw_fdb_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_acl_add(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
 		 uint16_t token,
 		 uint16_t *acl_id,
 		 const struct dpsw_acl_cfg  *cfg)
@@ -1362,7 +1445,8 @@ int dpsw_acl_add(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_ADD,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPSW_CMD_ACL_ADD(cmd, cfg);
 
 	/* send command to mc*/
@@ -1377,6 +1461,7 @@ int dpsw_acl_add(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_acl_remove(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    uint16_t acl_id)
 {
@@ -1384,7 +1469,7 @@ int dpsw_acl_remove(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_REMOVE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_ACL_REMOVE(cmd, acl_id);
 
@@ -1401,6 +1486,7 @@ void dpsw_acl_prepare_entry_cfg(const struct dpsw_acl_key *key,
 }
 
 int dpsw_acl_add_entry(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
 		       uint16_t acl_id,
 		       const struct dpsw_acl_entry_cfg *cfg)
@@ -1409,7 +1495,7 @@ int dpsw_acl_add_entry(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_ADD_ENTRY,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_ACL_ADD_ENTRY(cmd, acl_id, cfg);
 
@@ -1418,15 +1504,16 @@ int dpsw_acl_add_entry(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_acl_remove_entry(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
-		       uint16_t acl_id,
-		       const struct dpsw_acl_entry_cfg *cfg)
+			  uint16_t acl_id,
+			  const struct dpsw_acl_entry_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_REMOVE_ENTRY,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_ACL_REMOVE_ENTRY(cmd, acl_id, cfg);
 
@@ -1435,6 +1522,7 @@ int dpsw_acl_remove_entry(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_acl_add_if(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    uint16_t acl_id,
 		    const struct dpsw_acl_if_cfg *cfg)
@@ -1444,7 +1532,7 @@ int dpsw_acl_add_if(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_ADD_IF,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_ACL_ADD_IF(cmd, acl_id, cfg);
 
@@ -1453,19 +1541,125 @@ int dpsw_acl_add_if(struct fsl_mc_io *mc_io,
 }
 
 int dpsw_acl_remove_if(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
-		    uint16_t acl_id,
-		    const struct dpsw_acl_if_cfg *cfg)
+		       uint16_t acl_id,
+		       const struct dpsw_acl_if_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	build_if_id_bitmap(cfg->if_id, cfg->num_ifs, &cmd, 1);
 	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_REMOVE_IF,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPSW_CMD_ACL_REMOVE_IF(cmd, acl_id, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
+
+int dpsw_acl_get_attributes(struct fsl_mc_io		*mc_io,
+			    uint32_t			cmd_flags,
+			    uint16_t			token,
+			    uint16_t			acl_id,
+			    struct dpsw_acl_attr	*attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_ACL_GET_ATTR,
+					  cmd_flags,
+					  token);
+	DPSW_CMD_ACL_GET_ATTR(cmd, acl_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPSW_RSP_ACL_GET_ATTR(cmd, attr);
+
+	return 0;
+}
+
+int dpsw_ctrl_if_get_attributes(struct fsl_mc_io		*mc_io,
+				uint32_t			cmd_flags,
+				uint16_t			token,
+				struct dpsw_ctrl_if_attr	*attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CTRL_IF_GET_ATTR,
+					  cmd_flags,
+					  token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPSW_RSP_CTRL_IF_GET_ATTR(cmd, attr);
+
+	return 0;
+}
+
+int dpsw_ctrl_if_set_pools(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   const struct dpsw_ctrl_if_pools_cfg *pools)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CTRL_IF_SET_POOLS,
+					  cmd_flags,
+					  token);
+	DPSW_CMD_CTRL_IF_SET_POOLS(cmd, pools);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpsw_ctrl_if_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CTRL_IF_ENABLE,
+					  cmd_flags,
+					  token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+/**
+* @brief    Function disables control interface
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_ctrl_if_disable(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
+			 uint16_t		token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPSW_CMDID_CTRL_IF_DISABLE,
+					  cmd_flags,
+					  token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
diff --git a/drivers/staging/fsl-dpaa2/ethsw/dpsw.h b/drivers/staging/fsl-dpaa2/ethsw/dpsw.h
index a09d1fd..dc57954 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/dpsw.h
+++ b/drivers/staging/fsl-dpaa2/ethsw/dpsw.h
@@ -50,6 +50,7 @@ struct fsl_mc_io;
 /**
  * dpsw_open() - Open a control session for the specified object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpsw_id:	DPSW unique ID
  * @token:	Returned token; use in subsequent API calls
  *
@@ -63,28 +64,34 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_open(struct fsl_mc_io *mc_io, int dpsw_id, uint16_t *token);
+int dpsw_open(struct fsl_mc_io	*mc_io,
+	      uint32_t		cmd_flags,
+	      int		dpsw_id,
+	      uint16_t		*token);
 
 /**
  * dpsw_close() - Close the control session of the object
- * @mc_io	Pointer to MC portal's I/O object
- * @token	Token of DPSW object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
  *
  * After this function is called, no further operations are
  * allowed on the object without opening a new control session.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpsw_close(struct fsl_mc_io *mc_io,
+	       uint32_t	cmd_flags,
+	       uint16_t	token);
 
 /* DPSW options */
 
 /* Disable flooding */
-#define DPSW_OPT_FLOODING_DIS	0x0000000000000001ULL
+#define DPSW_OPT_FLOODING_DIS		0x0000000000000001ULL
 /* Disable Multicast */
-#define DPSW_OPT_MULTICAST_DIS	0x0000000000000004ULL
+#define DPSW_OPT_MULTICAST_DIS		0x0000000000000004ULL
 /* Support control interface */
-#define DPSW_OPT_CTRL		0x0000000000000010ULL
+#define DPSW_OPT_CTRL_IF_DIS		0x0000000000000010ULL
 /* Disable flooding metering */
 #define DPSW_OPT_FLOODING_METERING_DIS  0x0000000000000020ULL
 /* Enable metering */
@@ -97,7 +104,7 @@ int dpsw_close(struct fsl_mc_io *mc_io, uint16_t token);
  *		 use this structure to change default settings
  */
 struct dpsw_cfg {
-	uint16_t num_ifs;
+	uint16_t		num_ifs;
 	/**
 	 * struct adv - Advanced parameters
 	 * @options: Enable/Disable DPSW features (bitmap)
@@ -110,23 +117,22 @@ struct dpsw_cfg {
 	 *			0 - indicates default 300 seconds
 	 * @max_fdb_mc_groups: Number of multicast groups in each FDB table;
 	 *			0 - indicates default 32
-	 * @ctrl_if_id: Control interface
 	 */
 	struct {
-		uint64_t options;
-		uint16_t max_vlans;
-		uint8_t max_meters_per_if;
-		uint8_t max_fdbs;
-		uint16_t max_fdb_entries;
-		uint16_t fdb_aging_time;
-		uint16_t max_fdb_mc_groups;
-		uint16_t ctrl_if_id;
+		uint64_t	options;
+		uint16_t	max_vlans;
+		uint8_t	max_meters_per_if;
+		uint8_t	max_fdbs;
+		uint16_t	max_fdb_entries;
+		uint16_t	fdb_aging_time;
+		uint16_t	max_fdb_mc_groups;
 	} adv;
 };
 
 /**
  * dpsw_create() - Create the DPSW object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -145,56 +151,73 @@ struct dpsw_cfg {
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_create(struct fsl_mc_io *mc_io,
-		const struct dpsw_cfg *cfg,
-		uint16_t *token);
+int dpsw_create(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		const struct dpsw_cfg	*cfg,
+		uint16_t		*token);
 
 /**
  * dpsw_destroy() - Destroy the DPSW object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpsw_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpsw_destroy(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpsw_enable() - Enable DPSW functionality
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_enable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpsw_enable(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * dpsw_disable() - Disable DPSW functionality
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_disable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpsw_disable(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpsw_is_enabled() - Check if the DPSW is enabled
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @en:		Returns '1' if object is enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise
  */
-int dpsw_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpsw_is_enabled(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    int		*en);
 
 /**
  * dpsw_reset() - Reset the DPSW, returns the object to initial state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_reset(struct fsl_mc_io *mc_io, uint16_t token);
+int dpsw_reset(struct fsl_mc_io *mc_io,
+	       uint32_t	cmd_flags,
+	       uint16_t	token);
 
 /* DPSW IRQ Index and Events */
 
@@ -205,50 +228,57 @@ int dpsw_reset(struct fsl_mc_io *mc_io, uint16_t token);
 #define DPSW_IRQ_EVENT_LINK_CHANGED	0x0001
 
 /**
+ * struct dpsw_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpsw_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
+
+/**
  * dpsw_set_irq() - Set IRQ information for the DPSW to trigger an interrupt.
- * @mc_io:		Pointer to MC portal's I/O object
- * @token:		Token of DPSW object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *				signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_set_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id);
+int dpsw_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 struct dpsw_irq_cfg	*irq_cfg);
 
 /**
- * @dpsw_get_irq() - Get IRQ information from the DPSW
+ * dpsw_get_irq() - Get IRQ information from the DPSW
  *
- * @mc_io:		Pointer to MC portal's I/O object
- * @token:		Token of DPSW object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
  * @irq_index:	The interrupt index to configure
- * @type:		Returned interrupt type: 0 represents message interrupt
- *				type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *				signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @type:	Interrupt type: 0 represents message interrupt
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_get_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id);
+int dpsw_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 struct dpsw_irq_cfg	*irq_cfg);
 
 /**
  * dpsw_set_irq_enable() - Set overall interrupt state.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPCI object
  * @irq_index:	The interrupt index to configure
  * @en:			Interrupt state - enable = 1, disable = 0
@@ -260,28 +290,32 @@ int dpsw_get_irq(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_set_irq_enable(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint8_t irq_index,
-			uint8_t en);
+int dpsw_set_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			uint8_t		irq_index,
+			uint8_t		en);
 
 /**
  * dpsw_get_irq_enable() - Get overall interrupt state
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @irq_index:	The interrupt index to configure
  * @en:			Returned Interrupt state - enable = 1, disable = 0
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_get_irq_enable(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint8_t irq_index,
-			uint8_t *en);
+int dpsw_get_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			uint8_t		irq_index,
+			uint8_t		*en);
 
 /**
  * dpsw_set_irq_mask() - Set interrupt mask.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPCI object
  * @irq_index:	The interrupt index to configure
  * @mask:		event mask to trigger interrupt;
@@ -294,14 +328,16 @@ int dpsw_get_irq_enable(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_set_irq_mask(struct fsl_mc_io *mc_io,
-		      uint16_t token,
-		      uint8_t irq_index,
-		      uint32_t mask);
+int dpsw_set_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
+		      uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		mask);
 
 /**
  * dpsw_get_irq_mask() - Get interrupt mask.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @irq_index:	The interrupt index to configure
  * @mask:		Returned event mask to trigger interrupt
@@ -311,14 +347,16 @@ int dpsw_set_irq_mask(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_get_irq_mask(struct fsl_mc_io *mc_io,
-		      uint16_t token,
-		      uint8_t irq_index,
-		      uint32_t *mask);
+int dpsw_get_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
+		      uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		*mask);
 
 /**
  * dpsw_get_irq_status() - Get the current status of any pending interrupts
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @irq_index:	The interrupt index to configure
  * @status:		Returned interrupts status - one bit per cause:
@@ -327,26 +365,29 @@ int dpsw_get_irq_mask(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_get_irq_status(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint8_t irq_index,
-			uint32_t *status);
+int dpsw_get_irq_status(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			uint8_t		irq_index,
+			uint32_t		*status);
 
 /**
  * dpsw_clear_irq_status() - Clear a pending interrupt's status
- * @mc_io		Pointer to MC portal's I/O object
- * @token		Token of DPCI object
- * @irq_index	The interrupt index to configure
- * @status		bits to clear (W1C) - one bit per cause:
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:		Token of DPCI object
+ * @irq_index:	The interrupt index to configure
+ * @status:		bits to clear (W1C) - one bit per cause:
  *					0 = don't change
  *					1 = clear status bit
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_clear_irq_status(struct fsl_mc_io *mc_io,
-			  uint16_t token,
-			  uint8_t irq_index,
-			  uint32_t status);
+int dpsw_clear_irq_status(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
+			  uint16_t		token,
+			  uint8_t		irq_index,
+			  uint32_t		status);
 /**
  * struct dpsw_attr - Structure representing DPSW attributes
  * @id: DPSW object ID
@@ -367,7 +408,7 @@ int dpsw_clear_irq_status(struct fsl_mc_io *mc_io,
  * @num_fdbs: Current number of FDBs
  */
 struct dpsw_attr {
-	int id;
+	int		id;
 	/**
 	 * struct version - DPSW version
 	 * @major: DPSW major version
@@ -377,34 +418,37 @@ struct dpsw_attr {
 		uint16_t major;
 		uint16_t minor;
 	} version;
-	uint64_t options;
-	uint16_t max_vlans;
-	uint8_t max_meters_per_if;
-	uint8_t max_fdbs;
-	uint16_t max_fdb_entries;
-	uint16_t fdb_aging_time;
-	uint16_t max_fdb_mc_groups;
-	uint16_t num_ifs;
-	uint16_t mem_size;
-	uint16_t num_vlans;
-	uint8_t num_fdbs;
+	uint64_t	options;
+	uint16_t	max_vlans;
+	uint8_t	max_meters_per_if;
+	uint8_t	max_fdbs;
+	uint16_t	max_fdb_entries;
+	uint16_t	fdb_aging_time;
+	uint16_t	max_fdb_mc_groups;
+	uint16_t	num_ifs;
+	uint16_t	mem_size;
+	uint16_t	num_vlans;
+	uint8_t		num_fdbs;
 };
 
 /**
  * dpsw_get_attributes() - Retrieve DPSW attributes
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @attr:		Returned DPSW attributes
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_get_attributes(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			struct dpsw_attr *attr);
+int dpsw_get_attributes(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			struct dpsw_attr	*attr);
 
 /**
  * dpsw_set_reflection_if() - Set target interface for reflected interfaces.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Id
  *
@@ -412,34 +456,10 @@ int dpsw_get_attributes(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_set_reflection_if(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t if_id);
-
-/**
- * dpsw_set_ctrl_if() - Set control interface id
- * @mc_io:	Pointer to MC portal's I/O object
- * @token:	Token of DPSW object
- * @if_id:	Interface Id
-
- * Return:      Completion status. '0' on Success; Error code otherwise.
- */
-int dpsw_set_ctrl_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t if_id);
-
-/**
- * dpsw_get_ctrl_if - Get control interface id
- * @mc_io:	Pointer to MC portal's I/O object
- * @token:	Token of DPSW object
- * @if_id:	Returned interface ID
- *
- * Return:      Completion status. '0' on Success; Error - when control
- *		interface disabled
- */
-int dpsw_get_ctrl_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t *if_id);
+int dpsw_set_reflection_if(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
+			   uint16_t		token,
+			   uint16_t		if_id);
 
 /**
  * enum dpsw_action - Action selection for special/control frames
@@ -472,17 +492,19 @@ struct dpsw_link_cfg {
 
 /**
  * dpsw_if_set_link_cfg() - set the link configuration.
- * @mc_io: Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token: Token of DPSW object
  * @if_id: interface id
  * @cfg: Link configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_if_set_link_cfg(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			 uint16_t if_id,
-			 struct dpsw_link_cfg *cfg);
+int dpsw_if_set_link_cfg(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
+			 uint16_t		token,
+			 uint16_t		if_id,
+			 struct dpsw_link_cfg	*cfg);
 /**
  * struct dpsw_link_state - Structure representing DPSW link state
  * @rate: Rate
@@ -497,59 +519,67 @@ struct dpsw_link_state {
 
 /**
  * dpsw_if_get_link_state - Return the link state
- * @mc_io: Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token: Token of DPSW object
  * @if_id: interface id
- * @state: link state
+ * @state: link state	1 - linkup, 0 - link down or disconnected
  *
  * @returns	'0' on Success; Error code otherwise.
  */
-int dpsw_if_get_link_state(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t if_id,
-			   struct dpsw_link_state *state);
+int dpsw_if_get_link_state(struct fsl_mc_io		*mc_io,
+			   uint32_t			cmd_flags,
+			   uint16_t			token,
+			   uint16_t			if_id,
+			   struct dpsw_link_state	*state);
 
 /**
  * dpsw_if_set_flooding() - Enable Disable flooding for particular interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @en:			1 - enable, 0 - disable
-
+ *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_flooding(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			 uint16_t if_id,
-			 int en);
+int dpsw_if_set_flooding(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
+			 uint16_t		token,
+			 uint16_t		if_id,
+			 int			en);
 
 /**
  * dpsw_if_set_broadcast() - Enable/disable broadcast for particular interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @en:			1 - enable, 0 - disable
-
+ *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_broadcast(struct fsl_mc_io *mc_io,
-			  uint16_t token,
-			  uint16_t if_id,
-			  int en);
+int dpsw_if_set_broadcast(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
+			  uint16_t		token,
+			  uint16_t		if_id,
+			  int			en);
 
 /**
  * dpsw_if_set_multicast() - Enable/disable multicast for particular interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @en:			1 - enable, 0 - disable
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_multicast(struct fsl_mc_io *mc_io,
-			  uint16_t token,
-			  uint16_t if_id,
-			  int en);
+int dpsw_if_set_multicast(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
+			  uint16_t		token,
+			  uint16_t		if_id,
+			  int			en);
 
 /**
  * struct dpsw_tci_cfg - Tag Contorl Information (TCI) configuration
@@ -565,37 +595,41 @@ int dpsw_if_set_multicast(struct fsl_mc_io *mc_io,
  *			allowing up to 4,094 VLANs
  */
 struct dpsw_tci_cfg {
-	uint8_t pcp;
-	uint8_t dei;
-	uint16_t vlan_id;
+	uint8_t	pcp;
+	uint8_t	dei;
+	uint16_t	vlan_id;
 };
 
 /**
  * dpsw_if_set_tci() - Set default VLAN Tag Control Information (TCI)
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Tag Control Information Configuration
-
+ *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_tci(struct fsl_mc_io *mc_io,
-		    uint16_t token,
-		    uint16_t if_id,
-		    const struct dpsw_tci_cfg *cfg);
+int dpsw_if_set_tci(struct fsl_mc_io		*mc_io,
+		    uint32_t			cmd_flags,
+		    uint16_t			token,
+		    uint16_t			if_id,
+		    const struct dpsw_tci_cfg	*cfg);
 
 /**
  * dpsw_if_get_tci() - Get default VLAN Tag Control Information (TCI)
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Tag Control Information Configuration
-
+ *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_get_tci(struct fsl_mc_io *mc_io,
-		    uint16_t token,
-		    uint16_t if_id,
+int dpsw_if_get_tci(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    uint16_t		if_id,
 		    struct dpsw_tci_cfg *cfg);
 
 /**
@@ -619,13 +653,14 @@ enum dpsw_stp_state {
  * @state: STP state
  */
 struct dpsw_stp_cfg {
-	uint16_t vlan_id;
-	enum dpsw_stp_state state;
+	uint16_t		vlan_id;
+	enum dpsw_stp_state	state;
 };
 
 /**
  * dpsw_if_set_stp() - Function sets Spanning Tree Protocol (STP) state.
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		STP State configuration parameters
@@ -635,10 +670,11 @@ struct dpsw_stp_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_stp(struct fsl_mc_io *mc_io,
-		    uint16_t token,
-		    uint16_t if_id,
-		    const struct dpsw_stp_cfg *cfg);
+int dpsw_if_set_stp(struct fsl_mc_io		*mc_io,
+		    uint32_t			cmd_flags,
+		    uint16_t			token,
+		    uint16_t			if_id,
+		    const struct dpsw_stp_cfg	*cfg);
 
 /**
  * enum dpsw_accepted_frames - Types of frames to accept
@@ -660,13 +696,14 @@ enum dpsw_accepted_frames {
  *			redirected to control interface depending on this mode
  */
 struct dpsw_accepted_frames_cfg {
-	enum dpsw_accepted_frames type;
-	enum dpsw_action unaccept_act;
+	enum dpsw_accepted_frames	type;
+	enum dpsw_action		unaccept_act;
 };
 
 /**
  * dpsw_if_set_accepted_frames()
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Frame types configuration
@@ -679,17 +716,19 @@ struct dpsw_accepted_frames_cfg {
  * When admit_all - the device will accept VLAN tagged, untagged
  * and priority tagged frames.
  * The default is admit_all
-
+ *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_accepted_frames(struct fsl_mc_io *mc_io,
-				uint16_t token,
-				uint16_t if_id,
+int dpsw_if_set_accepted_frames(struct fsl_mc_io		*mc_io,
+				uint32_t			cmd_flags,
+				uint16_t			token,
+				uint16_t			if_id,
 				const struct dpsw_accepted_frames_cfg *cfg);
 
 /**
  * dpsw_if_set_accept_all_vlan()
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @accept_all:	Accept or drop frames having different VLAN
@@ -700,10 +739,11 @@ int dpsw_if_set_accepted_frames(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_accept_all_vlan(struct fsl_mc_io *mc_io,
-				uint16_t token,
-				uint16_t if_id,
-				int accept_all);
+int dpsw_if_set_accept_all_vlan(struct fsl_mc_io	*mc_io,
+				uint32_t		cmd_flags,
+				uint16_t		token,
+				uint16_t		if_id,
+				int			accept_all);
 
 /**
  * enum dpsw_counter  - Counters types
@@ -718,7 +758,7 @@ int dpsw_if_set_accept_all_vlan(struct fsl_mc_io *mc_io,
  * @DPSW_CNT_EGR_FRAME: Counts egress frames
  * @DPSW_CNT_EGR_BYTE: Counts eEgress bytes
  * @DPSW_CNT_EGR_FRAME_DISCARD: Counts discarded egress frames
- *
+ * @DPSW_CNT_EGR_STP_FRAME_DISCARD: Counts egress STP discarded frames
  */
 enum dpsw_counter {
 	DPSW_CNT_ING_FRAME = 0x0,
@@ -731,12 +771,14 @@ enum dpsw_counter {
 	DPSW_CNT_ING_BCAST_BYTES = 0x7,
 	DPSW_CNT_EGR_FRAME = 0x8,
 	DPSW_CNT_EGR_BYTE = 0x9,
-	DPSW_CNT_EGR_FRAME_DISCARD = 0xa
+	DPSW_CNT_EGR_FRAME_DISCARD = 0xa,
+	DPSW_CNT_EGR_STP_FRAME_DISCARD = 0xb
 };
 
 /**
  * dpsw_if_get_counter() - Get specific counter of particular interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @type:		Counter type
@@ -744,15 +786,17 @@ enum dpsw_counter {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_get_counter(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint16_t if_id,
-			enum dpsw_counter type,
-			uint64_t *counter);
+int dpsw_if_get_counter(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			uint16_t		if_id,
+			enum dpsw_counter	type,
+			uint64_t		*counter);
 
 /**
  * dpsw_if_set_counter() - Set specific counter of particular interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @type:		Counter type
@@ -760,11 +804,15 @@ int dpsw_if_get_counter(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_counter(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint16_t if_id,
-			enum dpsw_counter type,
-			uint64_t counter);
+int dpsw_if_set_counter(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token,
+			uint16_t		if_id,
+			enum dpsw_counter	type,
+			uint64_t		counter);
+
+/* Maximum number of TC */
+#define DPSW_MAX_TC             8
 
 /**
  * enum dpsw_priority_selector - User priority
@@ -780,21 +828,44 @@ enum dpsw_priority_selector {
 };
 
 /**
- * struct dpsw_tc_map_cfg - Mapping user priority into traffic class
- *				configuration
+ * enum dpsw_schedule_mode - Traffic classes scheduling
+ * @DPSW_SCHED_STRICT_PRIORITY: schedule strict priority
+ * @DPSW_SCHED_WEIGHTED: schedule based on token bucket created algorithm
+ */
+enum dpsw_schedule_mode {
+	DPSW_SCHED_STRICT_PRIORITY,
+	DPSW_SCHED_WEIGHTED
+};
+
+/**
+ * struct dpsw_tx_schedule_cfg - traffic class configuration
+ * @mode: Strict or weight-based scheduling
+ * @delta_bandwidth: weighted Bandwidth in range from 100 to 10000
+ */
+struct dpsw_tx_schedule_cfg {
+	enum dpsw_schedule_mode	mode;
+	uint16_t		delta_bandwidth;
+};
+
+/**
+ * struct dpsw_tx_selection_cfg - Mapping user priority into traffic
+ *					class configuration
  * @priority_selector: Source for user priority regeneration
  * @tc_id: The Regenerated User priority that the incoming
  *				User Priority is mapped to for this interface
- *
+ * @tc_sched: Traffic classes configuration
  */
-struct dpsw_tc_map_cfg {
-	enum dpsw_priority_selector priority_selector;
-	uint8_t tc_id[DPSW_MAX_PRIORITIES];
+struct dpsw_tx_selection_cfg {
+	enum dpsw_priority_selector	priority_selector;
+	uint8_t			tc_id[DPSW_MAX_PRIORITIES];
+	struct dpsw_tx_schedule_cfg	tc_sched[DPSW_MAX_TC];
 };
 
 /**
- * dpsw_if_set_tc_map() - Function is used for mapping variety of frame fields
- * @mc_io:		Pointer to MC portal's I/O object
+ * dpsw_if_set_tx_selection() - Function is used for mapping variety
+ *				of frame fields
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Traffic class mapping configuration
@@ -805,15 +876,16 @@ struct dpsw_tc_map_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_tc_map(struct fsl_mc_io *mc_io,
-		       uint16_t token,
-		       uint16_t if_id,
-		       const struct dpsw_tc_map_cfg *cfg);
+int dpsw_if_set_tx_selection(struct fsl_mc_io			*mc_io,
+			     uint32_t				cmd_flags,
+			     uint16_t				token,
+			     uint16_t				if_id,
+			     const struct dpsw_tx_selection_cfg	*cfg);
 
 /**
  * enum dpsw_reflection_filter - Filter type for frames to reflect
- * @DPSW_REFLECTION_FILTER_INGRESS_ALL - Reflect all frames
- * @DPSW_REFLECTION_FILTER_INGRESS_VLAN - Reflect only frames belong to
+ * @DPSW_REFLECTION_FILTER_INGRESS_ALL: Reflect all frames
+ * @DPSW_REFLECTION_FILTER_INGRESS_VLAN: Reflect only frames belong to
  *			particular VLAN defined by vid parameter
  *
  */
@@ -829,37 +901,41 @@ enum dpsw_reflection_filter {
  *		DPSW_INGRESS_VLAN
  */
 struct dpsw_reflection_cfg {
-	enum dpsw_reflection_filter filter;
-	uint16_t vlan_id;
+	enum dpsw_reflection_filter	filter;
+	uint16_t			vlan_id;
 };
 
 /**
  * dpsw_if_add_reflection() - Identify interface to be reflected or mirrored
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Reflection configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_add_reflection(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t if_id,
-			   const struct dpsw_reflection_cfg *cfg);
+int dpsw_if_add_reflection(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   uint16_t				if_id,
+			   const struct dpsw_reflection_cfg	*cfg);
 
 /**
  * dpsw_if_remove_reflection() - Remove interface to be reflected or mirrored
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  * @cfg:		Reflection configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_remove_reflection(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t if_id,
-			      const struct dpsw_reflection_cfg *cfg);
+int dpsw_if_remove_reflection(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
+			      uint16_t				token,
+			      uint16_t				if_id,
+			      const struct dpsw_reflection_cfg	*cfg);
 
 /**
  * enum dpsw_metering_mode - Metering modes
@@ -898,40 +974,45 @@ enum dpsw_metering_unit {
 struct dpsw_metering_cfg {
 	enum dpsw_metering_mode mode;
 	enum dpsw_metering_unit units;
-	uint32_t cir;
-	uint32_t eir;
-	uint32_t cbs;
-	uint32_t ebs;
+	uint32_t		cir;
+	uint32_t		eir;
+	uint32_t		cbs;
+	uint32_t		ebs;
 };
 
 /**
  * dpsw_if_set_flooding_metering() - Set flooding metering
- * @mc_io:		Pointer to MC portal's I/O object
- * @token:		Token of DPSW object
- * @if_id:		Interface Identifier
- * @cfg:		Metering parameters
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
+ * @if_id:	Interface Identifier
+ * @cfg:	Metering parameters
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_flooding_metering(struct fsl_mc_io *mc_io,
-				  uint16_t token,
-				    uint16_t if_id,
-				    const struct dpsw_metering_cfg *cfg);
+int dpsw_if_set_flooding_metering(struct fsl_mc_io		*mc_io,
+				  uint32_t			cmd_flags,
+				  uint16_t			token,
+				  uint16_t			if_id,
+				  const struct dpsw_metering_cfg *cfg);
 
 /**
  * dpsw_if_set_metering() - Set interface metering for flooding
- * @mc_io:		Pointer to MC portal's I/O object
- * @token:		Token of DPSW object
- * @if_id:		Interface Identifier
- * @cfg:		Metering parameters
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
+ * @if_id:	Interface Identifier
+ * @tc_id:	Traffic class ID
+ * @cfg:	Metering parameters
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_metering(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			    uint16_t if_id,
-			    uint8_t tc_id,
-			    const struct dpsw_metering_cfg *cfg);
+int dpsw_if_set_metering(struct fsl_mc_io			*mc_io,
+			 uint32_t				cmd_flags,
+			 uint16_t				token,
+			 uint16_t				if_id,
+			 uint8_t				tc_id,
+			 const struct dpsw_metering_cfg	*cfg);
 
 /**
  * enum dpsw_early_drop_unit - DPSW early drop unit
@@ -983,7 +1064,7 @@ struct dpsw_early_drop_cfg {
 	enum dpsw_early_drop_mode       drop_mode;
 	enum dpsw_early_drop_unit	units;
 	struct dpsw_wred_cfg	        yellow;
-	struct dpsw_wred_cfg	green;
+	struct dpsw_wred_cfg		green;
 	uint32_t			tail_drop_threshold;
 };
 
@@ -996,12 +1077,13 @@ struct dpsw_early_drop_cfg {
  *
  */
 void dpsw_prepare_early_drop(const struct dpsw_early_drop_cfg *cfg,
-			     uint8_t *early_drop_buf);
+			     uint8_t			*early_drop_buf);
 
 /**
  * dpsw_if_set_early_drop() - Set interface traffic class early-drop
  *				configuration
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @if_id:		Interface Identifier
  * @tc_id:	Traffic class selection (0-7)
@@ -1014,10 +1096,11 @@ void dpsw_prepare_early_drop(const struct dpsw_early_drop_cfg *cfg,
  * Return:	'0' on Success; error code otherwise.
  */
 int dpsw_if_set_early_drop(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
 			   uint16_t		token,
-			    uint16_t		if_id,
-			    uint8_t		tc_id,
-			    uint64_t		early_drop_iova);
+			   uint16_t		if_id,
+			   uint8_t		tc_id,
+			   uint64_t		early_drop_iova);
 
 /**
  * struct dpsw_custom_tpid_cfg - Structure representing tag Protocol identifier
@@ -1029,7 +1112,8 @@ struct dpsw_custom_tpid_cfg {
 
 /**
  * dpsw_add_custom_tpid() - API Configures a distinct Ethernet type value
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @cfg:		Tag Protocol identifier
  *
@@ -1040,55 +1124,68 @@ struct dpsw_custom_tpid_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_add_custom_tpid(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			 const struct dpsw_custom_tpid_cfg *cfg);
+int dpsw_add_custom_tpid(struct fsl_mc_io			*mc_io,
+			 uint32_t				cmd_flags,
+			 uint16_t				token,
+			 const struct dpsw_custom_tpid_cfg	*cfg);
 
 /**
  * dpsw_remove_custom_tpid - API removes a distinct Ethernet type value
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @cfg:		Tag Protocol identifier
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_remove_custom_tpid(struct fsl_mc_io *mc_io,
-			    uint16_t token,
-			    const struct dpsw_custom_tpid_cfg *cfg);
+int dpsw_remove_custom_tpid(struct fsl_mc_io			*mc_io,
+			    uint32_t				cmd_flags,
+			    uint16_t				token,
+			    const struct dpsw_custom_tpid_cfg	*cfg);
 
 /**
  * dpsw_if_enable() - Enable Interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_enable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id);
+int dpsw_if_enable(struct fsl_mc_io	*mc_io,
+		   uint32_t		cmd_flags,
+		   uint16_t		token,
+		   uint16_t		if_id);
 
 /**
  * dpsw_if_disable() - Disable Interface
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPSW object
  * @if_id:		Interface Identifier
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_disable(struct fsl_mc_io *mc_io, uint16_t token, uint16_t if_id);
+int dpsw_if_disable(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    uint16_t		if_id);
 
 /**
  * dpsw_if_get_token - Obtains interface token
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @if_id:	Interface id
  * @if_token:	Interface token
  *
  * @returns      Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_get_token(struct fsl_mc_io *mc_io,
-		      uint16_t token,
-		      uint16_t if_id,
-		      uint16_t *if_token);
+int dpsw_if_get_token(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
+		      uint16_t		token,
+		      uint16_t		if_id,
+		      uint16_t		*if_token);
 
 /**
  * struct dpsw_if_attr - Structure representing DPSW interface attributes
@@ -1103,57 +1200,65 @@ int dpsw_if_get_token(struct fsl_mc_io *mc_io,
  *		this interface;
  *		When set to 'DPSW_ADMIT_ALL', untagged frames or priority-
  *		tagged frames received on this interface are accepted
+ * @tx_fqid Transmit FQID
  */
 struct dpsw_if_attr {
-	uint8_t num_tcs;
-	uint32_t rate;
-	uint64_t options;
-	int enabled;
-	int accept_all_vlan;
-	enum dpsw_accepted_frames admit_untagged;
+	uint8_t				num_tcs;
+	uint32_t			rate;
+	uint32_t			options;
+	int				enabled;
+	int				accept_all_vlan;
+	enum dpsw_accepted_frames	admit_untagged;
+	uint32_t			tx_fqid;
 };
 
 /**
  * dpsw_if_get_attributes() - Function obtains attributes of interface
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @if_id:	Interface Identifier
  * @attr:	Returned interface attributes
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_get_attributes(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t if_id,
-			   struct dpsw_if_attr *attr);
+int dpsw_if_get_attributes(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
+			   uint16_t		token,
+			   uint16_t		if_id,
+			   struct dpsw_if_attr	*attr);
 
 /**
  * dpsw_if_set_max_frame_length() - Set Maximum Receive frame length.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @if_id:	Interface Identifier
  * @frame_length: Maximum Frame Length
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_set_max_frame_length(struct fsl_mc_io *mc_io,
-				 uint16_t token,
-				 uint16_t if_id,
-				 uint16_t frame_length);
+int dpsw_if_set_max_frame_length(struct fsl_mc_io	*mc_io,
+				 uint32_t		cmd_flags,
+				 uint16_t		token,
+				 uint16_t		if_id,
+				 uint16_t		frame_length);
 
 /**
  * dpsw_if_get_max_frame_length() - Get Maximum Receive frame length.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @if_id:	Interface Identifier
  * @frame_length: Returned maximum Frame Length
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_if_get_max_frame_length(struct fsl_mc_io *mc_io,
-				 uint16_t token,
-				 uint16_t if_id,
-				 uint16_t *frame_length);
+int dpsw_if_get_max_frame_length(struct fsl_mc_io	*mc_io,
+				 uint32_t		cmd_flags,
+				 uint16_t		token,
+				 uint16_t		if_id,
+				 uint16_t		*frame_length);
 
 /**
  * struct dpsw_vlan_cfg - VLAN Configuration
@@ -1166,6 +1271,7 @@ struct dpsw_vlan_cfg {
 /**
  * dpsw_vlan_add() - Adding new VLAN to DPSW.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	VLAN configuration
@@ -1179,10 +1285,11 @@ struct dpsw_vlan_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_add(struct fsl_mc_io *mc_io,
-		  uint16_t token,
-		  uint16_t vlan_id,
-		  const struct dpsw_vlan_cfg *cfg);
+int dpsw_vlan_add(struct fsl_mc_io		*mc_io,
+		  uint32_t			cmd_flags,
+		  uint16_t			token,
+		  uint16_t			vlan_id,
+		  const struct dpsw_vlan_cfg	*cfg);
 
 /**
  * struct dpsw_vlan_if_cfg - Set of VLAN Interfaces
@@ -1199,6 +1306,7 @@ struct dpsw_vlan_if_cfg {
 /**
  * dpsw_vlan_add_if() - Adding a set of interfaces to an existing VLAN.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	Set of interfaces to add
@@ -1210,15 +1318,17 @@ struct dpsw_vlan_if_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_add_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t vlan_id,
-		     const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_add_if(struct fsl_mc_io			*mc_io,
+		     uint32_t				cmd_flags,
+		     uint16_t				token,
+		     uint16_t				vlan_id,
+		     const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_add_if_untagged() - Defining a set of interfaces that should be
  *				transmitted as untagged.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	set of interfaces that should be transmitted as untagged
@@ -1231,16 +1341,18 @@ int dpsw_vlan_add_if(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t vlan_id,
-			      const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_add_if_untagged(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
+			      uint16_t				token,
+			      uint16_t				vlan_id,
+			      const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_add_if_flooding() - Define a set of interfaces that should be
  *			included in flooding when frame with unknown destination
  *			unicast MAC arrived.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	Set of interfaces that should be used for flooding
@@ -1253,14 +1365,16 @@ int dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_add_if_flooding(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t vlan_id,
-			      const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_add_if_flooding(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
+			      uint16_t				token,
+			      uint16_t				vlan_id,
+			      const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_remove_if() - Remove interfaces from an existing VLAN.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	Set of interfaces that should be removed
@@ -1270,15 +1384,17 @@ int dpsw_vlan_add_if_flooding(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_remove_if(struct fsl_mc_io *mc_io,
-			uint16_t token,
-			uint16_t vlan_id,
-			const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_remove_if(struct fsl_mc_io		*mc_io,
+			uint32_t			cmd_flags,
+			uint16_t			token,
+			uint16_t			vlan_id,
+			const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_remove_if_untagged() - Define a set of interfaces that should be
  *		converted from transmitted as untagged to transmit as tagged.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	set of interfaces that should be removed
@@ -1289,35 +1405,42 @@ int dpsw_vlan_remove_if(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_remove_if_untagged(struct fsl_mc_io *mc_io,
-				 uint16_t token,
-				 uint16_t vlan_id,
-				 const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_remove_if_untagged(struct fsl_mc_io		*mc_io,
+				 uint32_t			cmd_flags,
+				 uint16_t			token,
+				 uint16_t			vlan_id,
+				 const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_remove_if_flooding() - Define a set of interfaces that should be
  *			removed from the flooding list.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	set of interfaces used for flooding
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_remove_if_flooding(struct fsl_mc_io *mc_io,
-				 uint16_t token,
-				 uint16_t vlan_id,
-				 const struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_remove_if_flooding(struct fsl_mc_io		*mc_io,
+				 uint32_t			cmd_flags,
+				 uint16_t			token,
+				 uint16_t			vlan_id,
+				 const struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_remove() - Remove an entire VLAN
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t vlan_id);
+int dpsw_vlan_remove(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		vlan_id);
 
 /**
  * struct dpsw_vlan_attr - VLAN attributes
@@ -1336,59 +1459,67 @@ struct dpsw_vlan_attr {
 /**
  * dpsw_vlan_get_attributes() - Get VLAN attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @attr:	Returned DPSW attributes
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_get_attributes(struct fsl_mc_io *mc_io,
-			     uint16_t token,
-			     uint16_t vlan_id,
-			     struct dpsw_vlan_attr *attr);
+int dpsw_vlan_get_attributes(struct fsl_mc_io		*mc_io,
+			     uint32_t			cmd_flags,
+			     uint16_t			token,
+			     uint16_t			vlan_id,
+			     struct dpsw_vlan_attr	*attr);
 
 /**
  * dpsw_vlan_get_if() - Get interfaces belong to this VLAN
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	Returned set of interfaces belong to this VLAN
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_get_if(struct fsl_mc_io *mc_io,
-		     uint16_t token,
-		     uint16_t vlan_id,
-		     struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_get_if(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
+		     uint16_t			token,
+		     uint16_t			vlan_id,
+		     struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_get_if_flooding() - Get interfaces used in flooding for this VLAN
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @vlan_id:	VLAN Identifier
  * @cfg:	Returned set of flooding interfaces
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_get_if_flooding(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t vlan_id,
-			      struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_get_if_flooding(struct fsl_mc_io		*mc_io,
+			      uint32_t			cmd_flags,
+			      uint16_t			token,
+			      uint16_t			vlan_id,
+			      struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * dpsw_vlan_get_if_untagged() - Get interfaces that should be transmitted as
  *				untagged
- * @mc_io	Pointer to MC portal's I/O object
- * @token	Token of DPSW object
- * @vlan_id	VLAN Identifier
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
+ * @vlan_id:	VLAN Identifier
  * @cfg:	Returned set of untagged interfaces
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_vlan_get_if_untagged(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t vlan_id,
-			      struct dpsw_vlan_if_cfg *cfg);
+int dpsw_vlan_get_if_untagged(struct fsl_mc_io		*mc_io,
+			      uint32_t			cmd_flags,
+			      uint16_t			token,
+			      uint16_t			vlan_id,
+			      struct dpsw_vlan_if_cfg	*cfg);
 
 /**
  * struct dpsw_fdb_cfg  - FDB Configuration
@@ -1404,26 +1535,32 @@ struct dpsw_fdb_cfg {
  * dpsw_fdb_add() - Add FDB to switch and Returns handle to FDB table for
  *		the reference
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Returned Forwarding Database Identifier
  * @cfg:	FDB Configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_add(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint16_t *fdb_id,
-		 const struct dpsw_fdb_cfg *cfg);
+int dpsw_fdb_add(struct fsl_mc_io		*mc_io,
+		 uint32_t			cmd_flags,
+		 uint16_t			token,
+		 uint16_t			*fdb_id,
+		 const struct dpsw_fdb_cfg	*cfg);
 
 /**
  * dpsw_fdb_remove() - Remove FDB from switch
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_remove(struct fsl_mc_io *mc_io, uint16_t token, uint16_t fdb_id);
+int dpsw_fdb_remove(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    uint16_t		fdb_id);
 
 /**
  * enum dpsw_fdb_entry_type - FDB Entry type - Static/Dynamic
@@ -1442,53 +1579,59 @@ enum dpsw_fdb_entry_type {
  * @if_egress: Egress interface ID
  */
 struct dpsw_fdb_unicast_cfg {
-	enum dpsw_fdb_entry_type type;
-	uint8_t mac_addr[6];
-	uint16_t if_egress;
+	enum dpsw_fdb_entry_type	type;
+	uint8_t			mac_addr[6];
+	uint16_t			if_egress;
 };
 
 /**
  * dpsw_fdb_add_unicast() - Function adds an unicast entry into MAC lookup table
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @cfg:	Unicast entry configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_add_unicast(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			 uint16_t fdb_id,
-			 const struct dpsw_fdb_unicast_cfg *cfg);
+int dpsw_fdb_add_unicast(struct fsl_mc_io			*mc_io,
+			 uint32_t				cmd_flags,
+			 uint16_t				token,
+			 uint16_t				fdb_id,
+			 const struct dpsw_fdb_unicast_cfg	*cfg);
 
 /**
  * dpsw_fdb_get_unicast() - Get unicast entry from MAC lookup table by
  *		unicast Ethernet address
- * @mc_io	Pointer to MC portal's I/O object
- * @token	Token of DPSW object
- * @fdb_id	Forwarding Database Identifier
- * @cfg		Returned unicast entry configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPSW object
+ * @fdb_id:	Forwarding Database Identifier
+ * @cfg:	Returned unicast entry configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_get_unicast(struct fsl_mc_io *mc_io,
-			 uint16_t token,
-			 uint16_t fdb_id,
-			 struct dpsw_fdb_unicast_cfg *cfg);
+int dpsw_fdb_get_unicast(struct fsl_mc_io		*mc_io,
+			 uint32_t			cmd_flags,
+			 uint16_t			token,
+			 uint16_t			fdb_id,
+			 struct dpsw_fdb_unicast_cfg	*cfg);
 
 /**
  * dpsw_fdb_remove_unicast() - removes an entry from MAC lookup table
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @cfg:	Unicast entry configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io,
-			    uint16_t token,
-			    uint16_t fdb_id,
-			    const struct dpsw_fdb_unicast_cfg *cfg);
+int dpsw_fdb_remove_unicast(struct fsl_mc_io			*mc_io,
+			    uint32_t				cmd_flags,
+			    uint16_t				token,
+			    uint16_t				fdb_id,
+			    const struct dpsw_fdb_unicast_cfg	*cfg);
 
 /**
  * struct dpsw_fdb_multicast_cfg - Multi-cast entry configuration
@@ -1498,15 +1641,16 @@ int dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io,
  * @if_id: Egress interface IDs
  */
 struct dpsw_fdb_multicast_cfg {
-	enum dpsw_fdb_entry_type type;
-	uint8_t mac_addr[6];
-	uint16_t num_ifs;
-	uint16_t if_id[DPSW_MAX_IF];
+	enum dpsw_fdb_entry_type	type;
+	uint8_t			mac_addr[6];
+	uint16_t			num_ifs;
+	uint16_t			if_id[DPSW_MAX_IF];
 };
 
 /**
  * dpsw_fdb_add_multicast() - Add a set of egress interfaces to multi-cast group
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @cfg:	Multicast entry configuration
@@ -1520,30 +1664,34 @@ struct dpsw_fdb_multicast_cfg {
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_add_multicast(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t fdb_id,
-			   const struct dpsw_fdb_multicast_cfg *cfg);
+int dpsw_fdb_add_multicast(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   uint16_t				fdb_id,
+			   const struct dpsw_fdb_multicast_cfg	*cfg);
 
 /**
  * dpsw_fdb_get_multicast() - Reading multi-cast group by multi-cast Ethernet
  *				address.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @cfg:	Returned multicast entry configuration
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_get_multicast(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t fdb_id,
-			   struct dpsw_fdb_multicast_cfg *cfg);
+int dpsw_fdb_get_multicast(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   uint16_t				fdb_id,
+			   struct dpsw_fdb_multicast_cfg	*cfg);
 
 /**
  * dpsw_fdb_remove_multicast() - Removing interfaces from an existing multicast
  *				group.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @cfg:	Multicast entry configuration
@@ -1555,9 +1703,10 @@ int dpsw_fdb_get_multicast(struct fsl_mc_io *mc_io,
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_remove_multicast(struct fsl_mc_io *mc_io,
-			      uint16_t token,
-			      uint16_t fdb_id,
+int dpsw_fdb_remove_multicast(struct fsl_mc_io			*mc_io,
+			      uint32_t				cmd_flags,
+			      uint16_t				token,
+			      uint16_t				fdb_id,
 			      const struct dpsw_fdb_multicast_cfg *cfg);
 
 /**
@@ -1600,16 +1749,18 @@ enum dpsw_fdb_learning_mode {
 /**
  * dpsw_fdb_set_learning_mode() - Define FDB learning mode
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @mode:	learning mode
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_set_learning_mode(struct fsl_mc_io *mc_io,
-			       uint16_t token,
-			       uint16_t fdb_id,
-			       enum dpsw_fdb_learning_mode mode);
+int dpsw_fdb_set_learning_mode(struct fsl_mc_io		*mc_io,
+			       uint32_t			cmd_flags,
+			       uint16_t			token,
+			       uint16_t			fdb_id,
+			       enum dpsw_fdb_learning_mode	mode);
 
 /**
  * struct dpsw_fdb_attr - FDB Attributes
@@ -1620,26 +1771,28 @@ int dpsw_fdb_set_learning_mode(struct fsl_mc_io *mc_io,
  * @max_fdb_mc_groups: Maximum number of multicast groups
  */
 struct dpsw_fdb_attr {
-	uint16_t max_fdb_entries;
-	uint16_t fdb_aging_time;
-	enum dpsw_fdb_learning_mode learning_mode;
-	uint16_t num_fdb_mc_groups;
-	uint16_t max_fdb_mc_groups;
+	uint16_t			max_fdb_entries;
+	uint16_t			fdb_aging_time;
+	enum dpsw_fdb_learning_mode	learning_mode;
+	uint16_t			num_fdb_mc_groups;
+	uint16_t			max_fdb_mc_groups;
 };
 
 /**
  * dpsw_fdb_get_attributes() - Get FDB attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @fdb_id:	Forwarding Database Identifier
  * @attr:	Returned FDB attributes
  *
  * Return:	Completion status. '0' on Success; Error code otherwise.
  */
-int dpsw_fdb_get_attributes(struct fsl_mc_io *mc_io,
-			    uint16_t token,
-			    uint16_t fdb_id,
-			    struct dpsw_fdb_attr *attr);
+int dpsw_fdb_get_attributes(struct fsl_mc_io		*mc_io,
+			    uint32_t			cmd_flags,
+			    uint16_t			token,
+			    uint16_t			fdb_id,
+			    struct dpsw_fdb_attr	*attr);
 
 /**
  * struct dpsw_acl_cfg - ACL Configuration
@@ -1700,11 +1853,13 @@ struct dpsw_acl_key {
  * @DPSW_ACL_ACTION_DROP: Drop frame
  * @DPSW_ACL_ACTION_REDIRECT: Redirect to certain port
  * @DPSW_ACL_ACTION_ACCEPT: Accept frame
+ * @DPSW_ACL_ACTION_REDIRECT_TO_CTRL_IF: Redirect to control interface
  */
 enum dpsw_acl_action {
-	DPSW_ACL_ACTION_DROP,            /*! Drop frame */
-	DPSW_ACL_ACTION_REDIRECT,        /*! Redirect to certain port */
-	DPSW_ACL_ACTION_ACCEPT           /*! Accept frame */
+	DPSW_ACL_ACTION_DROP,
+	DPSW_ACL_ACTION_REDIRECT,
+	DPSW_ACL_ACTION_ACCEPT,
+	DPSW_ACL_ACTION_REDIRECT_TO_CTRL_IF
 };
 
 /**
@@ -1728,7 +1883,7 @@ struct dpsw_acl_result {
  *		space the priorities according to consequent rule additions.
  */
 struct dpsw_acl_entry_cfg {
-	uint64_t			key_iova;
+	uint64_t		key_iova;
 	struct dpsw_acl_result  result;
 	int                     precedence;
 };
@@ -1736,31 +1891,35 @@ struct dpsw_acl_entry_cfg {
 /**
  * dpsw_acl_add() - Adds ACL to L2 switch.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
- * @acl_id	Returned ACL ID, for the future reference
- * @cfg		ACL configuration
+ * @acl_id:	Returned ACL ID, for the future reference
+ * @cfg:	ACL configuration
  *
  * Create Access Control List. Multiple ACLs can be created and
  * co-exist in L2 switch
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_add(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint16_t *acl_id,
-		 const struct dpsw_acl_cfg  *cfg);
+int dpsw_acl_add(struct fsl_mc_io		*mc_io,
+		 uint32_t			cmd_flags,
+		 uint16_t			token,
+		 uint16_t			*acl_id,
+		 const struct dpsw_acl_cfg	*cfg);
 
 /**
  * dpsw_acl_remove() - Removes ACL from L2 switch.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @acl_id:	ACL ID
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_remove(struct fsl_mc_io *mc_io,
-		    uint16_t token,
-		    uint16_t acl_id);
+int dpsw_acl_remove(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    uint16_t		acl_id);
 
 /**
  * dpsw_acl_prepare_entry_cfg() - Set an entry to ACL.
@@ -1770,12 +1929,13 @@ int dpsw_acl_remove(struct fsl_mc_io *mc_io,
  * This function has to be called before adding or removing acl_entry
  *
  */
-void dpsw_acl_prepare_entry_cfg(const struct dpsw_acl_key *key,
-				uint8_t *entry_cfg_buf);
+void dpsw_acl_prepare_entry_cfg(const struct dpsw_acl_key	*key,
+				uint8_t			*entry_cfg_buf);
 
 /**
  * dpsw_acl_add_entry() - Adds an entry to ACL.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @acl_id:	ACL ID
  * @cfg:	entry configuration
@@ -1784,14 +1944,16 @@ void dpsw_acl_prepare_entry_cfg(const struct dpsw_acl_key *key,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_add_entry(struct fsl_mc_io *mc_io,
-		       uint16_t token,
-		       uint16_t acl_id,
-		       const struct dpsw_acl_entry_cfg *cfg);
+int dpsw_acl_add_entry(struct fsl_mc_io		*mc_io,
+		       uint32_t			cmd_flags,
+		       uint16_t			token,
+		       uint16_t			acl_id,
+		       const struct dpsw_acl_entry_cfg	*cfg);
 
 /**
  * dpsw_acl_remove_entry() - Removes an entry from ACL.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @acl_id:	ACL ID
  * @cfg:	entry configuration
@@ -1800,10 +1962,11 @@ int dpsw_acl_add_entry(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_remove_entry(struct fsl_mc_io *mc_io,
-			  uint16_t token,
-			  uint16_t acl_id,
-			  const struct dpsw_acl_entry_cfg *cfg);
+int dpsw_acl_remove_entry(struct fsl_mc_io			*mc_io,
+			  uint32_t				cmd_flags,
+			  uint16_t				token,
+			  uint16_t				acl_id,
+			  const struct dpsw_acl_entry_cfg	*cfg);
 
 /**
  * struct dpsw_acl_if_cfg - List of interfaces to Associate with ACL
@@ -1818,28 +1981,148 @@ struct dpsw_acl_if_cfg {
 /**
  * dpsw_acl_add_if() - Associate interface/interfaces with ACL.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @acl_id:	ACL ID
  * @cfg:	interfaces list
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_add_if(struct fsl_mc_io *mc_io,
-		    uint16_t token,
-		    uint16_t acl_id,
+int dpsw_acl_add_if(struct fsl_mc_io			*mc_io,
+		    uint32_t				cmd_flags,
+		    uint16_t				token,
+		    uint16_t				acl_id,
 		    const struct dpsw_acl_if_cfg	*cfg);
 
 /**
  * dpsw_acl_remove_if() - De-associate interface/interfaces from ACL.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPSW object
  * @acl_id:	ACL ID
  * @cfg:	interfaces list
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpsw_acl_remove_if(struct fsl_mc_io *mc_io,
-		       uint16_t token,
-		       uint16_t acl_id,
+int dpsw_acl_remove_if(struct fsl_mc_io		*mc_io,
+		       uint32_t			cmd_flags,
+		       uint16_t			token,
+		       uint16_t			acl_id,
 		       const struct dpsw_acl_if_cfg	*cfg);
+
+/**
+ * struct dpsw_acl_attr -  ACL Attributes
+ * @max_entries: Max number of ACL entries
+ * @num_entries: Number of used ACL entries
+ * @num_ifs: Number of interfaces associated with ACL
+ */
+struct dpsw_acl_attr {
+	uint16_t max_entries;
+	uint16_t num_entries;
+	uint16_t num_ifs;
+};
+
+/**
+* dpsw_acl_get_attributes() - Get specific counter of particular interface
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+* @acl_id:      ACL Identifier
+* @attr:        Returned ACL attributes
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_acl_get_attributes(struct fsl_mc_io		*mc_io,
+			    uint32_t			cmd_flags,
+			    uint16_t			token,
+			    uint16_t			acl_id,
+			    struct dpsw_acl_attr	*attr);
+/**
+* struct dpsw_ctrl_if_attr - Control interface attributes
+* @rx_fqid:		Receive FQID
+* @rx_err_fqid:		Receive error FQID
+* @tx_err_conf_fqid:	Transmit error and confirmation FQID
+*/
+struct dpsw_ctrl_if_attr {
+	uint32_t	rx_fqid;
+	uint32_t	rx_err_fqid;
+	uint32_t	tx_err_conf_fqid;
+};
+
+/**
+* dpsw_ctrl_if_get_attributes() - Obtain control interface attributes
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+* @attr:        Returned control interface attributes
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_ctrl_if_get_attributes(struct fsl_mc_io		*mc_io,
+				uint32_t			cmd_flags,
+				uint16_t			token,
+				struct dpsw_ctrl_if_attr	*attr);
+
+/* Maximum number of DPBP */
+#define DPSW_MAX_DPBP     8
+
+/**
+ * struct dpsw_ctrl_if_pools_cfg - Control interface buffer pools configuration
+ * @num_dpbp: Number of DPBPs
+ * @pools: Array of buffer pools parameters; The number of valid entries
+ *	must match 'num_dpbp' value
+ */
+struct dpsw_ctrl_if_pools_cfg {
+	uint8_t num_dpbp;
+	/**
+	* struct pools - Buffer pools parameters
+	* @dpbp_id: DPBP object ID
+	* @buffer_size: Buffer size
+	* @backup_pool: Backup pool
+	*/
+	struct {
+		int dpbp_id;
+		uint16_t buffer_size;
+		int backup_pool;
+	} pools[DPSW_MAX_DPBP];
+};
+
+/**
+* dpsw_ctrl_if_set_pools() - Set control interface buffer pools
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+* @cfg:         buffer pools configuration
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_ctrl_if_set_pools(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   const struct dpsw_ctrl_if_pools_cfg *cfg);
+
+/**
+* dpsw_ctrl_if_enable() - Enable control interface
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_ctrl_if_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
+			uint16_t		token);
+
+/**
+* @brief    Function disables control interface
+* @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+* @token:	Token of DPSW object
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpsw_ctrl_if_disable(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
+			 uint16_t		token);
+
 #endif /* __FSL_DPSW_H */
diff --git a/drivers/staging/fsl-dpaa2/ethsw/switch.c b/drivers/staging/fsl-dpaa2/ethsw/switch.c
index 28deb79..f69ad38 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/switch.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/switch.c
@@ -114,7 +114,7 @@ static int ethsw_open(struct net_device *netdev)
 	struct ethsw_port_priv	*port_priv = NULL;
 	int			err;
 
-	err = dpsw_enable(priv->mc_io, priv->dpsw_handle);
+	err = dpsw_enable(priv->mc_io, 0, priv->dpsw_handle);
 	if (err) {
 		netdev_err(netdev, "dpsw_enable err %d\n", err);
 		return err;
@@ -137,7 +137,7 @@ static int ethsw_stop(struct net_device *netdev)
 	struct ethsw_port_priv	*port_priv = NULL;
 	int			err;
 
-	err = dpsw_disable(priv->mc_io, priv->dpsw_handle);
+	err = dpsw_disable(priv->mc_io, 0, priv->dpsw_handle);
 	if (err) {
 		netdev_err(netdev, "dpsw_disable err %d\n", err);
 		return err;
@@ -168,7 +168,7 @@ static int ethsw_add_vlan(struct net_device *netdev, u16 vid)
 		return -EEXIST;
 	}
 
-	err = dpsw_vlan_add(priv->mc_io, priv->dpsw_handle, vid, &vcfg);
+	err = dpsw_vlan_add(priv->mc_io, 0, priv->dpsw_handle, vid, &vcfg);
 	if (err) {
 		netdev_err(netdev, "dpsw_vlan_add err %d\n", err);
 		return err;
@@ -199,7 +199,7 @@ static int ethsw_port_add_vlan(struct net_device *netdev, u16 vid, u16 flags)
 		return -EBUSY;
 	}
 
-	err = dpsw_vlan_add_if(priv->mc_io, priv->dpsw_handle, vid, &vcfg);
+	err = dpsw_vlan_add_if(priv->mc_io, 0, priv->dpsw_handle, vid, &vcfg);
 	if (err) {
 		netdev_err(netdev, "dpsw_vlan_add_if err %d\n", err);
 		return err;
@@ -207,8 +207,8 @@ static int ethsw_port_add_vlan(struct net_device *netdev, u16 vid, u16 flags)
 	port_priv->vlans[vid] = ETHSW_VLAN_MEMBER;
 
 	if (flags & BRIDGE_VLAN_INFO_UNTAGGED) {
-		err = dpsw_vlan_add_if_untagged(priv->mc_io, priv->dpsw_handle,
-						vid, &vcfg);
+		err = dpsw_vlan_add_if_untagged(priv->mc_io, 0,
+						priv->dpsw_handle, vid, &vcfg);
 		if (err) {
 			netdev_err(netdev, "dpsw_vlan_add_if_untagged err %d\n",
 				   err);
@@ -227,7 +227,7 @@ static int ethsw_port_add_vlan(struct net_device *netdev, u16 vid, u16 flags)
 			.vlan_id = vid,
 		};
 
-		err = dpsw_if_set_tci(priv->mc_io, priv->dpsw_handle,
+		err = dpsw_if_set_tci(priv->mc_io, 0, priv->dpsw_handle,
 				      port_priv->port_index, &tci_cfg);
 		if (err) {
 			netdev_err(netdev, "dpsw_if_set_tci err %d\n", err);
@@ -309,7 +309,7 @@ static int ethsw_set_learning(struct net_device *netdev, u8 flag)
 	else
 		learn_mode = DPSW_FDB_LEARNING_MODE_DIS;
 
-	err = dpsw_fdb_set_learning_mode(priv->mc_io, priv->dpsw_handle,
+	err = dpsw_fdb_set_learning_mode(priv->mc_io, 0, priv->dpsw_handle,
 					 0, learn_mode);
 	if (err) {
 		netdev_err(netdev, "dpsw_fdb_set_learning_mode err %d\n", err);
@@ -326,7 +326,7 @@ static int ethsw_port_set_flood(struct net_device *netdev, u8 flag)
 	struct ethsw_dev_priv	*priv = port_priv->ethsw_priv;
 	int			err;
 
-	err = dpsw_if_set_flooding(priv->mc_io, priv->dpsw_handle,
+	err = dpsw_if_set_flooding(priv->mc_io, 0, priv->dpsw_handle,
 				   port_priv->port_index, (int)flag);
 	if (err) {
 		netdev_err(netdev, "dpsw_fdb_set_learning_mode err %d\n", err);
@@ -363,7 +363,7 @@ static int ethsw_port_set_state(struct net_device *netdev, u8 state)
 		if (err)
 			goto error;
 	} else {
-		err = dpsw_if_set_stp(priv->mc_io, priv->dpsw_handle,
+		err = dpsw_if_set_stp(priv->mc_io, 0, priv->dpsw_handle,
 				      port_priv->port_index, &stp_cfg);
 		if (err) {
 			netdev_err(netdev, "dpsw_if_set_stp err %d\n", err);
@@ -666,7 +666,7 @@ static int ethsw_dellink_switch(struct ethsw_dev_priv *priv, u16 vid)
 	if (!priv->vlans[vid])
 		return -ENOENT;
 
-	err = dpsw_vlan_remove(priv->mc_io, priv->dpsw_handle, vid);
+	err = dpsw_vlan_remove(priv->mc_io, 0, priv->dpsw_handle, vid);
 	if (err) {
 		netdev_err(priv->netdev, "dpsw_vlan_remove err %d\n", err);
 		return err;
@@ -713,7 +713,7 @@ static int ethsw_dellink_port(struct ethsw_dev_priv *priv,
 			return ethsw_dellink_switch(priv, vid);
 	}
 
-	err = dpsw_vlan_remove_if(priv->mc_io, priv->dpsw_handle,
+	err = dpsw_vlan_remove_if(priv->mc_io, 0, priv->dpsw_handle,
 				  vid, &vcfg);
 	if (err) {
 		netdev_err(priv->netdev, "dpsw_vlan_remove_if err %d\n", err);
@@ -784,7 +784,7 @@ static int ethsw_port_open(struct net_device *netdev)
 	    port_priv->stp_state == BR_STATE_DISABLED)
 		return 0;
 
-	err = dpsw_if_enable(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_enable(port_priv->ethsw_priv->mc_io, 0,
 			     port_priv->ethsw_priv->dpsw_handle,
 			     port_priv->port_index);
 	if (err) {
@@ -800,7 +800,7 @@ static int ethsw_port_stop(struct net_device *netdev)
 	struct ethsw_port_priv	*port_priv = netdev_priv(netdev);
 	int			err;
 
-	err = dpsw_if_disable(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_disable(port_priv->ethsw_priv->mc_io, 0,
 			      port_priv->ethsw_priv->dpsw_handle,
 			      port_priv->port_index);
 	if (err) {
@@ -822,7 +822,7 @@ static int ethsw_port_fdb_add_uc(struct net_device *netdev,
 	entry.type = DPSW_FDB_ENTRY_STATIC;
 	ether_addr_copy(entry.mac_addr, addr);
 
-	err = dpsw_fdb_add_unicast(port_priv->ethsw_priv->mc_io,
+	err = dpsw_fdb_add_unicast(port_priv->ethsw_priv->mc_io, 0,
 				   port_priv->ethsw_priv->dpsw_handle,
 				   0, &entry);
 	if (err)
@@ -841,7 +841,7 @@ static int ethsw_port_fdb_del_uc(struct net_device *netdev,
 	entry.type = DPSW_FDB_ENTRY_STATIC;
 	ether_addr_copy(entry.mac_addr, addr);
 
-	err = dpsw_fdb_remove_unicast(port_priv->ethsw_priv->mc_io,
+	err = dpsw_fdb_remove_unicast(port_priv->ethsw_priv->mc_io, 0,
 				      port_priv->ethsw_priv->dpsw_handle,
 				      0, &entry);
 	if (err)
@@ -861,7 +861,7 @@ static int ethsw_port_fdb_add_mc(struct net_device *netdev,
 	entry.num_ifs = 1;
 	entry.if_id[0] = port_priv->port_index;
 
-	err = dpsw_fdb_add_multicast(port_priv->ethsw_priv->mc_io,
+	err = dpsw_fdb_add_multicast(port_priv->ethsw_priv->mc_io, 0,
 				     port_priv->ethsw_priv->dpsw_handle,
 				     0, &entry);
 	if (err)
@@ -881,7 +881,7 @@ static int ethsw_port_fdb_del_mc(struct net_device *netdev,
 	entry.num_ifs = 1;
 	entry.if_id[0] = port_priv->port_index;
 
-	err = dpsw_fdb_remove_multicast(port_priv->ethsw_priv->mc_io,
+	err = dpsw_fdb_remove_multicast(port_priv->ethsw_priv->mc_io, 0,
 					port_priv->ethsw_priv->dpsw_handle,
 					0, &entry);
 	if (err)
@@ -971,7 +971,7 @@ static int ethsw_port_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 
 		/* check if the address exists on other port */
 		ether_addr_copy(entry.mac_addr, addr);
-		err = dpsw_fdb_get_multicast(priv->mc_io, priv->dpsw_handle,
+		err = dpsw_fdb_get_multicast(priv->mc_io, 0, priv->dpsw_handle,
 					     0, &entry);
 		if (!err) {
 			/* entry exists, can we replace it? */
@@ -1049,35 +1049,35 @@ ethsw_port_get_stats(struct net_device *netdev,
 	u64			tmp;
 	int			err;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_ING_FRAME, &storage->rx_packets);
 	if (err)
 		goto error;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_EGR_FRAME, &storage->tx_packets);
 	if (err)
 		goto error;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_ING_BYTE, &storage->rx_bytes);
 	if (err)
 		goto error;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_EGR_BYTE, &storage->tx_bytes);
 	if (err)
 		goto error;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_ING_FRAME_DISCARD,
@@ -1085,7 +1085,7 @@ ethsw_port_get_stats(struct net_device *netdev,
 	if (err)
 		goto error;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_ING_FLTR_FRAME,
@@ -1094,7 +1094,7 @@ ethsw_port_get_stats(struct net_device *netdev,
 		goto error;
 	storage->rx_dropped += tmp;
 
-	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+	err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 				  port_priv->ethsw_priv->dpsw_handle,
 				  port_priv->port_index,
 				  DPSW_CNT_EGR_FRAME_DISCARD,
@@ -1173,7 +1173,7 @@ static void ethsw_ethtool_get_stats(struct net_device *netdev,
 	int			err;
 
 	for (i = 0; i < ARRAY_SIZE(ethsw_ethtool_counters); i++) {
-		err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io,
+		err = dpsw_if_get_counter(port_priv->ethsw_priv->mc_io, 0,
 					  port_priv->ethsw_priv->dpsw_handle,
 					  port_priv->port_index,
 					  ethsw_ethtool_counters[i].id,
@@ -1211,7 +1211,7 @@ ethsw_init(struct fsl_mc_device *sw_dev)
 
 	priv->dev_id = sw_dev->obj_desc.id;
 
-	err = dpsw_open(priv->mc_io, priv->dev_id, &priv->dpsw_handle);
+	err = dpsw_open(priv->mc_io, 0, priv->dev_id, &priv->dpsw_handle);
 	if (err) {
 		dev_err(dev, "dpsw_open err %d\n", err);
 		goto err_exit;
@@ -1222,20 +1222,20 @@ ethsw_init(struct fsl_mc_device *sw_dev)
 		goto err_exit;
 	}
 
-	err = dpsw_get_attributes(priv->mc_io, priv->dpsw_handle,
+	err = dpsw_get_attributes(priv->mc_io, 0, priv->dpsw_handle,
 				  &priv->sw_attr);
 	if (err) {
 		dev_err(dev, "dpsw_get_attributes err %d\n", err);
 		goto err_close;
 	}
 
-	err = dpsw_reset(priv->mc_io, priv->dpsw_handle);
+	err = dpsw_reset(priv->mc_io, 0, priv->dpsw_handle);
 	if (err) {
 		dev_err(dev, "dpsw_reset err %d\n", err);
 		goto err_close;
 	}
 
-	err = dpsw_fdb_set_learning_mode(priv->mc_io, priv->dpsw_handle, 0,
+	err = dpsw_fdb_set_learning_mode(priv->mc_io, 0, priv->dpsw_handle, 0,
 					 DPSW_FDB_LEARNING_MODE_HW);
 	if (err) {
 		dev_err(dev, "dpsw_fdb_set_learning_mode err %d\n", err);
@@ -1243,7 +1243,7 @@ ethsw_init(struct fsl_mc_device *sw_dev)
 	}
 
 	for (i = 0; i < priv->sw_attr.num_ifs; i++) {
-		err = dpsw_if_set_stp(priv->mc_io, priv->dpsw_handle, i,
+		err = dpsw_if_set_stp(priv->mc_io, 0, priv->dpsw_handle, i,
 				      &stp_cfg);
 		if (err) {
 			dev_err(dev, "dpsw_if_set_stp err %d for port %d\n",
@@ -1251,7 +1251,7 @@ ethsw_init(struct fsl_mc_device *sw_dev)
 			goto err_close;
 		}
 
-		err = dpsw_if_set_broadcast(priv->mc_io,
+		err = dpsw_if_set_broadcast(priv->mc_io, 0,
 					    priv->dpsw_handle, i, 1);
 		if (err) {
 			dev_err(dev,
@@ -1264,7 +1264,7 @@ ethsw_init(struct fsl_mc_device *sw_dev)
 	return 0;
 
 err_close:
-	dpsw_close(priv->mc_io, priv->dpsw_handle);
+	dpsw_close(priv->mc_io, 0, priv->dpsw_handle);
 err_exit:
 	return err;
 }
@@ -1280,7 +1280,7 @@ ethsw_takedown(struct fsl_mc_device *sw_dev)
 	netdev = dev_get_drvdata(dev);
 	priv = netdev_priv(netdev);
 
-	err = dpsw_close(priv->mc_io, priv->dpsw_handle);
+	err = dpsw_close(priv->mc_io, 0, priv->dpsw_handle);
 	if (err)
 		dev_warn(dev, "dpsw_close err %d\n", err);
 
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h b/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
index e7b8dbc..64ecb93 100644
--- a/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
@@ -34,7 +34,7 @@
 
 /* DPDMUX Version */
 #define DPDMUX_VER_MAJOR				4
-#define DPDMUX_VER_MINOR				0
+#define DPDMUX_VER_MINOR				1
 
 /* Command IDs */
 #define DPDMUX_CMDID_CLOSE				0x800
@@ -93,12 +93,12 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
-	MC_CMD_OP(cmd, 0, 0,  64, uint64_t, irq_addr);\
-	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_cfg->val);\
+	MC_CMD_OP(cmd, 0, 0,  64, uint64_t, irq_cfg->addr);\
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -106,11 +106,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPDMUX_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPDMUX_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
@@ -255,7 +255,7 @@ do { \
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPDMUX_CMD_IF_GET_LINK_STATE(cmd, if_id) \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id) \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPDMUX_RSP_IF_GET_LINK_STATE(cmd, state) \
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux.c b/drivers/staging/fsl-dpaa2/evb/dpdmux.c
index 1e924de..757de0d 100644
--- a/drivers/staging/fsl-dpaa2/evb/dpdmux.c
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux.c
@@ -34,14 +34,18 @@
 #include "dpdmux.h"
 #include "dpdmux-cmd.h"
 
-int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token)
+int dpdmux_open(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		int dpdmux_id,
+		uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPDMUX_CMD_OPEN(cmd, dpdmux_id);
 
 	/* send command to mc*/
@@ -55,13 +59,15 @@ int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token)
 	return 0;
 }
 
-int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpdmux_close(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CLOSE,
-					  MC_CMD_PRI_HIGH,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -69,6 +75,7 @@ int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token)
 }
 
 int dpdmux_create(struct fsl_mc_io *mc_io,
+		  uint32_t cmd_flags,
 		  const struct dpdmux_cfg *cfg,
 		  uint16_t *token)
 {
@@ -77,7 +84,8 @@ int dpdmux_create(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CREATE,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPDMUX_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -91,49 +99,61 @@ int dpdmux_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpdmux_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpdmux_destroy(struct fsl_mc_io *mc_io,
+		   uint32_t cmd_flags,
+		   uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_enable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpdmux_enable(struct fsl_mc_io *mc_io,
+		  uint32_t cmd_flags,
+		  uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_disable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpdmux_disable(struct fsl_mc_io *mc_io,
+		   uint32_t cmd_flags,
+		   uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_DISABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpdmux_is_enabled(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
+		      uint16_t token,
+		      int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IS_ENABLED,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -147,51 +167,52 @@ int dpdmux_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpdmux_reset(struct fsl_mc_io *mc_io, uint16_t token)
+int dpdmux_reset(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_RESET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_set_irq(struct fsl_mc_io *mc_io,
-		   uint16_t token,
-		   uint8_t irq_index,
-		   uint64_t irq_addr,
-		   uint32_t irq_val,
-		   int user_irq_id)
+int dpdmux_set_irq(struct fsl_mc_io	*mc_io,
+		   uint32_t		cmd_flags,
+		   uint16_t		token,
+		   uint8_t		irq_index,
+		   struct dpdmux_irq_cfg *irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
-	DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+	DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpdmux_get_irq(struct fsl_mc_io *mc_io,
-		   uint16_t token,
-		   uint8_t irq_index,
-		   int *type,
-		   uint64_t *irq_addr,
-		   uint32_t *irq_val,
-		   int *user_irq_id)
+		   uint32_t cmd_flags,
+		   uint16_t		token,
+		   uint8_t		irq_index,
+		   int			*type,
+		   struct dpdmux_irq_cfg *irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_GET_IRQ(cmd, irq_index);
 
@@ -201,12 +222,13 @@ int dpdmux_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPDMUX_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPDMUX_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpdmux_set_irq_enable(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint8_t en)
@@ -215,7 +237,8 @@ int dpdmux_set_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -223,6 +246,7 @@ int dpdmux_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_get_irq_enable(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint8_t *en)
@@ -232,7 +256,8 @@ int dpdmux_get_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -247,6 +272,7 @@ int dpdmux_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_set_irq_mask(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t mask)
@@ -255,7 +281,8 @@ int dpdmux_set_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -263,6 +290,7 @@ int dpdmux_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_get_irq_mask(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t *mask)
@@ -272,7 +300,8 @@ int dpdmux_get_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -287,6 +316,7 @@ int dpdmux_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_get_irq_status(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint32_t *status)
@@ -296,7 +326,8 @@ int dpdmux_get_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -311,6 +342,7 @@ int dpdmux_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_clear_irq_status(struct fsl_mc_io *mc_io,
+			    uint32_t cmd_flags,
 			    uint16_t token,
 			    uint8_t irq_index,
 			    uint32_t status)
@@ -319,7 +351,8 @@ int dpdmux_clear_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPDMUX_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -327,6 +360,7 @@ int dpdmux_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_get_attributes(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  struct dpdmux_attr *attr)
 {
@@ -335,7 +369,8 @@ int dpdmux_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -349,14 +384,15 @@ int dpdmux_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_ul_set_max_frame_length(struct fsl_mc_io *mc_io,
+				   uint32_t cmd_flags,
 				   uint16_t token,
-				uint16_t max_frame_length)
+				   uint16_t max_frame_length)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_UL_SET_MAX_FRAME_LENGTH,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_UL_SET_MAX_FRAME_LENGTH(cmd, max_frame_length);
 
@@ -365,6 +401,7 @@ int dpdmux_ul_set_max_frame_length(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_set_default_if(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint16_t if_id,
 			  int no_default_if)
@@ -373,7 +410,7 @@ int dpdmux_set_default_if(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_DEFAULT_IF,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_SET_DEFAULT_IF(cmd, if_id, no_default_if);
 
@@ -381,7 +418,9 @@ int dpdmux_set_default_if(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_get_default_if(struct fsl_mc_io *mc_io, uint16_t token,
+int dpdmux_get_default_if(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
 			  uint16_t *if_id)
 {
 	struct mc_command cmd = { 0 };
@@ -389,7 +428,7 @@ int dpdmux_get_default_if(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_DEFAULT_IF,
-						  MC_CMD_PRI_LOW,
+						  cmd_flags,
 						  token);
 
 	/* send command to mc*/
@@ -404,13 +443,14 @@ int dpdmux_get_default_if(struct fsl_mc_io *mc_io, uint16_t token,
 }
 
 int dpdmux_ul_reset_counters(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
 			     uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_UL_RESET_COUNTERS,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -418,6 +458,7 @@ int dpdmux_ul_reset_counters(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_if_set_accepted_frames(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  uint16_t if_id,
 				  const struct dpdmux_accepted_frames *cfg)
@@ -426,7 +467,7 @@ int dpdmux_if_set_accepted_frames(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_SET_ACCEPTED_FRAMES,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_SET_ACCEPTED_FRAMES(cmd, if_id, cfg);
 
@@ -435,6 +476,7 @@ int dpdmux_if_set_accepted_frames(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_if_get_attributes(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
 			     uint16_t token,
 			     uint16_t if_id,
 			     struct dpdmux_if_attr *attr)
@@ -444,7 +486,7 @@ int dpdmux_if_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_ATTR,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_GET_ATTR(cmd, if_id);
 
@@ -459,7 +501,9 @@ int dpdmux_if_get_attributes(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpdmux_if_remove_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
+int dpdmux_if_remove_l2_rule(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
+			     uint16_t token,
 			     uint16_t if_id,
 			     const struct dpdmux_l2_rule *rule)
 {
@@ -467,7 +511,7 @@ int dpdmux_if_remove_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_REMOVE_L2_RULE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_REMOVE_L2_RULE(cmd, if_id, rule);
 
@@ -475,7 +519,9 @@ int dpdmux_if_remove_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpdmux_if_add_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
+int dpdmux_if_add_l2_rule(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token,
 			  uint16_t if_id,
 			  const struct dpdmux_l2_rule *rule)
 {
@@ -483,7 +529,7 @@ int dpdmux_if_add_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_ADD_L2_RULE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_ADD_L2_RULE(cmd, if_id, rule);
 
@@ -492,6 +538,7 @@ int dpdmux_if_add_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
 }
 
 int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  uint16_t			if_id,
 			  enum dpdmux_counter_type	counter_type,
@@ -502,7 +549,7 @@ int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_COUNTER,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_GET_COUNTER(cmd, if_id, counter_type);
 
@@ -518,6 +565,7 @@ int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
 }
 
 int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
 			   uint16_t if_id,
 			   struct dpdmux_link_cfg *cfg)
@@ -526,7 +574,7 @@ int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_SET_LINK_CFG,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_SET_LINK_CFG(cmd, if_id, cfg);
 
@@ -535,6 +583,7 @@ int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
 }
 
 int dpdmux_if_get_link_state(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
 			     uint16_t token,
 			     uint16_t if_id,
 			     struct dpdmux_link_state *state)
@@ -544,7 +593,7 @@ int dpdmux_if_get_link_state(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_LINK_STATE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPDMUX_CMD_IF_GET_LINK_STATE(cmd, if_id);
 
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux.h b/drivers/staging/fsl-dpaa2/evb/dpdmux.h
index 0035653..1916ae0 100644
--- a/drivers/staging/fsl-dpaa2/evb/dpdmux.h
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux.h
@@ -42,7 +42,8 @@ struct fsl_mc_io;
 
 /**
  * dpdmux_open() - Open a control session for the specified object
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpdmux_id:		DPDMUX unique ID
  * @token:		Returned token; use in subsequent API calls
  *
@@ -56,11 +57,15 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token);
+int dpdmux_open(struct fsl_mc_io	 *mc_io,
+		uint32_t		 cmd_flags,
+		int			 dpdmux_id,
+		uint16_t		 *token);
 
 /**
  * dpdmux_close() - Close the control session of the object
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPDMUX object
  *
  * After this function is called, no further operations are
@@ -68,7 +73,9 @@ int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_close(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /*!
  * @name DPDMUX general options
@@ -77,6 +84,12 @@ int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token);
 /*!< Enable bridging between internal interfaces */
 /* @} */
 
+#define DPDMUX_IRQ_INDEX_IF			0x0000
+#define DPDMUX_IRQ_INDEX		0x0001
+
+/*!< IRQ event - Indicates that the link state changed */
+#define DPDMUX_IRQ_EVENT_LINK_CHANGED	0x0001
+
 /**
  * enum dpdmux_manip - DPDMUX manipulation operations
  * @DPDMUX_MANIP_NONE:	No manipulation on frames
@@ -113,10 +126,10 @@ enum dpdmux_method {
  *	 use this structure to change default settings
  */
 struct dpdmux_cfg {
-	enum dpdmux_method method;
-	enum dpdmux_manip manip;
-	int control_if;
-	uint16_t num_ifs;
+	enum dpdmux_method	method;
+	enum dpdmux_manip	manip;
+	int			control_if;
+	uint16_t		num_ifs;
 	/**
 	 * struct adv - Advanced parameters
 	 * @options: DPDMUX options - combination of 'DPDMUX_OPT_<X>' flags
@@ -139,6 +152,7 @@ struct dpdmux_cfg {
 /**
  * dpdmux_create() - Create the DPDMUX object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -157,100 +171,124 @@ struct dpdmux_cfg {
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_create(struct fsl_mc_io *mc_io, const struct dpdmux_cfg *cfg,
-		  uint16_t *token);
+int dpdmux_create(struct fsl_mc_io		*mc_io,
+		  uint32_t			cmd_flags,
+		  const struct dpdmux_cfg	*cfg,
+		  uint16_t			*token);
 
 /**
  * dpdmux_destroy() - Destroy the DPDMUX object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpdmux_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_destroy(struct fsl_mc_io	*mc_io,
+		   uint32_t		cmd_flags,
+		   uint16_t		token);
 
 /**
  * dpdmux_enable() - Enable DPDMUX functionality
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_enable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_enable(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
+		  uint16_t		token);
 
 /**
  * dpdmux_disable() - Disable DPDMUX functionality
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_disable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_disable(struct fsl_mc_io	*mc_io,
+		   uint32_t		cmd_flags,
+		   uint16_t		token);
 
 /**
  * dpdmux_is_enabled() - Check if the DPDMUX is enabled.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @en:		Returns '1' if object is enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpdmux_is_enabled(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
+		      uint16_t		token,
+		      int		*en);
 
 /**
  * dpdmux_reset() - Reset the DPDMUX, returns the object to initial state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_reset(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_reset(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
+/**
+ * struct dpdmux_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpdmux_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
 
 /**
  * dpdmux_set_irq() - Set IRQ information for the DPDMUX to trigger an interrupt.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *		signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_set_irq(struct fsl_mc_io	*mc_io,
-		   uint16_t		token,
-		   uint8_t		irq_index,
-		   uint64_t		irq_addr,
-		   uint32_t		irq_val,
-		   int			user_irq_id);
+int dpdmux_set_irq(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
+		   uint16_t			token,
+		   uint8_t			irq_index,
+		   struct dpdmux_irq_cfg	*irq_cfg);
 
 /**
  * dpdmux_get_irq() - Get IRQ information from the DPDMUX.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
- * @type:	Returned interrupt type: 0 represents message interrupt
+ * @type:	Interrupt type: 0 represents message interrupt
  *		type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *		signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_get_irq(struct fsl_mc_io	*mc_io,
-		   uint16_t		token,
-		   uint8_t		irq_index,
-		   int			*type,
-		   uint64_t		*irq_addr,
-		   uint32_t		*irq_val,
-		   int			*user_irq_id);
+int dpdmux_get_irq(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
+		   uint16_t			token,
+		   uint8_t			irq_index,
+		   int				*type,
+		   struct dpdmux_irq_cfg	*irq_cfg);
 
 /**
  * dpdmux_set_irq_enable() - Set overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
  * @en:		Interrupt state - enable = 1, disable = 0
@@ -263,6 +301,7 @@ int dpdmux_get_irq(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_set_irq_enable(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint8_t		en);
@@ -270,6 +309,7 @@ int dpdmux_set_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_get_irq_enable() - Get overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
  * @en:		Returned interrupt state - enable = 1, disable = 0
@@ -277,6 +317,7 @@ int dpdmux_set_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_get_irq_enable(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint8_t		*en);
@@ -284,6 +325,7 @@ int dpdmux_get_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_set_irq_mask() - Set interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
  * @mask:	event mask to trigger interrupt;
@@ -297,6 +339,7 @@ int dpdmux_get_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_set_irq_mask(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint32_t		mask);
@@ -304,6 +347,7 @@ int dpdmux_set_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_get_irq_mask() - Get interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
  * @mask:	Returned event mask to trigger interrupt
@@ -314,6 +358,7 @@ int dpdmux_set_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_get_irq_mask(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint32_t		*mask);
@@ -321,15 +366,17 @@ int dpdmux_get_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_get_irq_status() - Get the current status of any pending interrupts.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
- * @status	Returned interrupts status - one bit per cause:
+ * @status:	Returned interrupts status - one bit per cause:
  *			0 = no interrupt pending
  *			1 = interrupt pending
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_get_irq_status(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint32_t		*status);
@@ -337,6 +384,7 @@ int dpdmux_get_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_clear_irq_status() - Clear a pending interrupt's status
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @irq_index:	The interrupt index to configure
  * @status:	bits to clear (W1C) - one bit per cause:
@@ -346,6 +394,7 @@ int dpdmux_get_irq_status(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_clear_irq_status(struct fsl_mc_io	*mc_io,
+			    uint32_t		cmd_flags,
 			    uint16_t		token,
 			    uint8_t		irq_index,
 			    uint32_t		status);
@@ -362,53 +411,56 @@ int dpdmux_clear_irq_status(struct fsl_mc_io	*mc_io,
  * @control_if: Control interface ID
  */
 struct dpdmux_attr {
-	int id;
+	int			id;
 	/**
 	 * struct version - DPDMUX version
 	 * @major: DPDMUX major version
 	 * @minor: DPDMUX minor version
 	 */
 	struct {
-		uint16_t major;
-		uint16_t minor;
+		uint16_t	major;
+		uint16_t	minor;
 	} version;
-	uint64_t options;
-	enum dpdmux_method method;
-	enum dpdmux_manip manip;
-	uint16_t num_ifs;
-	uint16_t mem_size;
-	int control_if;
+	uint64_t		options;
+	enum dpdmux_method	method;
+	enum dpdmux_manip	manip;
+	uint16_t		num_ifs;
+	uint16_t		mem_size;
+	int			control_if;
 };
 
 /**
  * dpdmux_get_attributes() - Retrieve DPDMUX attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @attr:	Returned object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_get_attributes(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  struct dpdmux_attr	*attr);
 
 /**
- *
  * dpdmux_ul_set_max_frame_length() - Set the maximum frame length in DPDMUX
- * @mc_io:		Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:		Token of DPDMUX object
  * @max_frame_length:	The required maximum frame length
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_ul_set_max_frame_length(struct fsl_mc_io	*mc_io,
+				   uint32_t		cmd_flags,
 				   uint16_t		token,
 				   uint16_t		max_frame_length);
 
 /**
- *
  * dpdmux_set_default_if() - Set the interface to be the default interface
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
  *		Ignored if 'no_default_if = 1'
@@ -423,6 +475,7 @@ int dpdmux_ul_set_max_frame_length(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_set_default_if(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint16_t		if_id,
 			  int			no_default_if);
@@ -430,6 +483,7 @@ int dpdmux_set_default_if(struct fsl_mc_io	*mc_io,
 /**
  * dpdmux_get_default_if() - Get the default interface
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Returns default interface ID (0 for uplink,
  *		or 1-num_ifs);
@@ -437,6 +491,7 @@ int dpdmux_set_default_if(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_get_default_if(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint16_t		*if_id);
 
@@ -501,13 +556,14 @@ enum dpdmux_action {
  * @unaccept_act: Defines action on frames not accepted
  */
 struct dpdmux_accepted_frames {
-	enum dpdmux_accepted_frames_type type;
-	enum dpdmux_action unaccept_act;
+	enum dpdmux_accepted_frames_type	type;
+	enum dpdmux_action			unaccept_act;
 };
 
 /**
  * dpdmux_if_set_accepted_frames() - Set the accepted frame types
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
  * @cfg:	Frame types configuration
@@ -521,10 +577,11 @@ struct dpdmux_accepted_frames {
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_if_set_accepted_frames(struct fsl_mc_io			*mc_io,
-				  uint16_t				token,
-				  uint16_t				if_id,
-				  const struct dpdmux_accepted_frames	*cfg);
+int dpdmux_if_set_accepted_frames(struct fsl_mc_io		      *mc_io,
+				  uint32_t			      cmd_flags,
+				  uint16_t			      token,
+				  uint16_t			      if_id,
+				  const struct dpdmux_accepted_frames *cfg);
 
 /**
  * struct dpdmux_if_attr - Structure representing frame types configuration
@@ -534,15 +591,16 @@ int dpdmux_if_set_accepted_frames(struct fsl_mc_io			*mc_io,
  * @is_default: Indicates if configured as default interface
  */
 struct dpdmux_if_attr {
-	uint32_t rate;
-	int enabled;
-	enum dpdmux_accepted_frames_type accept_frame_type;
-	int is_default;
+	uint32_t				rate;
+	int					enabled;
+	enum dpdmux_accepted_frames_type	accept_frame_type;
+	int					is_default;
 };
 
 /**
  * dpdmux_if_get_attributes() - Obtain DPDMUX interface attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
  * @attr:	Interface attributes
@@ -550,6 +608,7 @@ struct dpdmux_if_attr {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_if_get_attributes(struct fsl_mc_io		*mc_io,
+			     uint32_t			cmd_flags,
 			     uint16_t			token,
 			     uint16_t			if_id,
 			     struct dpdmux_if_attr	*attr);
@@ -560,13 +619,14 @@ int dpdmux_if_get_attributes(struct fsl_mc_io		*mc_io,
  * @vlan_id: VLAN ID
  */
 struct dpdmux_l2_rule {
-	uint8_t mac_addr[6];
-	uint16_t vlan_id;
+	uint8_t	mac_addr[6];
+	uint16_t	vlan_id;
 };
 
 /**
  * dpdmux_if_remove_l2_rule() - Remove L2 rule from DPDMUX table
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Destination interface ID
  * @rule:	L2 rule
@@ -577,6 +637,7 @@ struct dpdmux_l2_rule {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_if_remove_l2_rule(struct fsl_mc_io			*mc_io,
+			     uint32_t				cmd_flags,
 			     uint16_t				token,
 			     uint16_t				if_id,
 			     const struct dpdmux_l2_rule	*rule);
@@ -584,6 +645,7 @@ int dpdmux_if_remove_l2_rule(struct fsl_mc_io			*mc_io,
 /**
  * dpdmux_if_add_l2_rule() - Add L2 rule into DPDMUX table
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPDMUX object
  * @if_id:	Destination interface ID
  * @rule:	L2 rule
@@ -594,14 +656,16 @@ int dpdmux_if_remove_l2_rule(struct fsl_mc_io			*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpdmux_if_add_l2_rule(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  uint16_t			if_id,
 			  const struct dpdmux_l2_rule	*rule);
 
 /**
-* @dpdmux_if_get_counter() - Functions obtains specific counter of an interface
-* @mc_io:	Pointer to MC portal's I/O object
-* @token:	Token of DPDMUX object
+* dpdmux_if_get_counter() - Functions obtains specific counter of an interface
+* @mc_io: Pointer to MC portal's I/O object
+* @cmd_flags: Command flags; one or more of 'MC_CMD_FLAG_'
+* @token: Token of DPDMUX object
 * @if_id:  Interface Id
 * @counter_type: counter type
 * @counter: Returned specific counter information
@@ -609,6 +673,7 @@ int dpdmux_if_add_l2_rule(struct fsl_mc_io		*mc_io,
 * Return:	'0' on Success; Error code otherwise.
 */
 int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
+			  uint32_t			cmd_flags,
 			  uint16_t			token,
 			  uint16_t			if_id,
 			  enum dpdmux_counter_type	counter_type,
@@ -617,11 +682,14 @@ int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
 /**
 * dpdmux_ul_reset_counters() - Function resets the uplink counter
 * @mc_io:	Pointer to MC portal's I/O object
+* @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
 * @token:	Token of DPDMUX object
 *
 * Return:	'0' on Success; Error code otherwise.
 */
-int dpdmux_ul_reset_counters(struct fsl_mc_io *mc_io, uint16_t token);
+int dpdmux_ul_reset_counters(struct fsl_mc_io	*mc_io,
+			     uint32_t		cmd_flags,
+			     uint16_t		token);
 
 /* Enable auto-negotiation */
 #define DPDMUX_LINK_OPT_AUTONEG		0x0000000000000001ULL
@@ -644,17 +712,19 @@ struct dpdmux_link_cfg {
 
 /**
  * dpdmux_if_set_link_cfg() - set the link configuration.
- * @mc_io: Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token: Token of DPSW object
  * @if_id: interface id
  * @cfg: Link configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
-			   uint16_t token,
-			   uint16_t if_id,
-			   struct dpdmux_link_cfg *cfg);
+int dpdmux_if_set_link_cfg(struct fsl_mc_io		*mc_io,
+			   uint32_t			cmd_flags,
+			   uint16_t			token,
+			   uint16_t			if_id,
+			   struct dpdmux_link_cfg	*cfg);
 /**
  * struct dpdmux_link_state - Structure representing DPDMUX link state
  * @rate: Rate
@@ -669,16 +739,18 @@ struct dpdmux_link_state {
 
 /**
  * dpdmux_if_get_link_state - Return the link state
- * @mc_io: Pointer to MC portal's I/O object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token: Token of DPSW object
  * @if_id: interface id
  * @state: link state
  *
  * @returns	'0' on Success; Error code otherwise.
  */
-int dpdmux_if_get_link_state(struct fsl_mc_io *mc_io,
-			     uint16_t token,
-			     uint16_t if_id,
-			     struct dpdmux_link_state *state);
+int dpdmux_if_get_link_state(struct fsl_mc_io		*mc_io,
+			     uint32_t			cmd_flags,
+			     uint16_t			token,
+			     uint16_t			if_id,
+			     struct dpdmux_link_state	*state);
 
 #endif /* __FSL_DPDMUX_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
index c123aab..670c19b 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
@@ -34,7 +34,7 @@
 
 /* DPMAC Version */
 #define DPMAC_VER_MAJOR				3
-#define DPMAC_VER_MINOR				0
+#define DPMAC_VER_MINOR				1
 
 /* Command IDs */
 #define DPMAC_CMDID_CLOSE			0x800
@@ -69,12 +69,12 @@
 	MC_CMD_OP(cmd, 0, 0,  32, int,	    dpmac_id)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_cfg->val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -82,11 +82,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPMAC_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPMAC_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.c b/drivers/staging/fsl-dpaa2/mac/dpmac.c
index ad1e147..dbc60b8 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac.c
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.c
@@ -34,14 +34,18 @@
 #include "dpmac.h"
 #include "dpmac-cmd.h"
 
-int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token)
+int dpmac_open(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       int dpmac_id,
+	       uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPMAC_CMD_OPEN(cmd, dpmac_id);
 
 	/* send command to mc*/
@@ -55,12 +59,14 @@ int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token)
 	return err;
 }
 
-int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpmac_close(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CLOSE, MC_CMD_PRI_HIGH,
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CLOSE, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -68,15 +74,17 @@ int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token)
 }
 
 int dpmac_create(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
 		 const struct dpmac_cfg *cfg,
-		uint16_t *token)
+		 uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CREATE,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPMAC_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -90,50 +98,53 @@ int dpmac_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpmac_destroy(struct fsl_mc_io *mc_io,
+		  uint32_t cmd_flags,
+		  uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_set_irq(struct fsl_mc_io *mc_io,
-		  uint16_t token,
-		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id)
+int dpmac_set_irq(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
+		  uint16_t		token,
+		  uint8_t		irq_index,
+		  struct dpmac_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW, token);
-	DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+					  cmd_flags,
+					  token);
+	DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_get_irq(struct fsl_mc_io *mc_io,
-		  uint16_t token,
-		 uint8_t irq_index,
-		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id)
+int dpmac_get_irq(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
+		  uint16_t		token,
+		  uint8_t		irq_index,
+		  int			*type,
+		  struct dpmac_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_GET_IRQ(cmd, irq_index);
 
 	/* send command to mc*/
@@ -142,21 +153,23 @@ int dpmac_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPMAC_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPMAC_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpmac_set_irq_enable(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			uint8_t irq_index,
-			uint8_t en)
+			 uint8_t irq_index,
+			 uint8_t en)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -164,16 +177,18 @@ int dpmac_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_get_irq_enable(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			uint8_t irq_index,
-			uint8_t *en)
+			 uint8_t irq_index,
+			 uint8_t *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -188,15 +203,17 @@ int dpmac_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_set_irq_mask(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
-		      uint8_t irq_index,
-		      uint32_t mask)
+		       uint8_t irq_index,
+		       uint32_t mask)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -204,16 +221,18 @@ int dpmac_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_get_irq_mask(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
-		      uint8_t irq_index,
-		      uint32_t *mask)
+		       uint8_t irq_index,
+		       uint32_t *mask)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -228,16 +247,18 @@ int dpmac_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_get_irq_status(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			uint8_t irq_index,
-			uint32_t *status)
+			 uint8_t irq_index,
+			 uint32_t *status)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -252,15 +273,17 @@ int dpmac_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_clear_irq_status(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
 			   uint16_t token,
-			  uint8_t irq_index,
-			  uint32_t status)
+			   uint8_t irq_index,
+			   uint32_t status)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -268,15 +291,17 @@ int dpmac_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_get_attributes(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-			struct dpmac_attr *attr)
+			 struct dpmac_attr *attr)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -290,6 +315,7 @@ int dpmac_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_mdio_read(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
 		    uint16_t token,
 		    struct dpmac_mdio_cfg *cfg)
 {
@@ -298,7 +324,7 @@ int dpmac_mdio_read(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_READ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPMAC_CMD_MDIO_READ(cmd, cfg);
 
@@ -314,6 +340,7 @@ int dpmac_mdio_read(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_mdio_write(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
 		     uint16_t token,
 		     struct dpmac_mdio_cfg *cfg)
 {
@@ -321,7 +348,8 @@ int dpmac_mdio_write(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_WRITE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_MDIO_WRITE(cmd, cfg);
 
 	/* send command to mc*/
@@ -329,15 +357,17 @@ int dpmac_mdio_write(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_get_link_cfg(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
 		       uint16_t token,
-		      struct dpmac_link_cfg *cfg)
+		       struct dpmac_link_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err = 0;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_LINK_CFG,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -350,30 +380,35 @@ int dpmac_get_link_cfg(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_set_link_state(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
 			 uint16_t token,
-		      struct dpmac_link_state *link_state)
+			 struct dpmac_link_state *link_state)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_LINK_STATE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_SET_LINK_STATE(cmd, link_state);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_get_counter(struct fsl_mc_io *mc_io, uint16_t token,
+int dpmac_get_counter(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
+		      uint16_t token,
 		      enum dpmac_counter type,
-			   uint64_t *counter)
+		      uint64_t *counter)
 {
 	struct mc_command cmd = { 0 };
 	int err = 0;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_COUNTER,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPMAC_CMD_GET_COUNTER(cmd, type);
 
 	/* send command to mc*/
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.h b/drivers/staging/fsl-dpaa2/mac/dpmac.h
index 88091b5..4db1458 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac.h
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.h
@@ -41,6 +41,7 @@ struct fsl_mc_io;
 /**
  * dpmac_open() - Open a control session for the specified object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpmac_id:	DPMAC unique ID
  * @token:	Returned token; use in subsequent API calls
  *
@@ -54,11 +55,15 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token);
+int dpmac_open(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       int			dpmac_id,
+	       uint16_t		*token);
 
 /**
  * dpmac_close() - Close the control session of the object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  *
  * After this function is called, no further operations are
@@ -66,7 +71,9 @@ int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpmac_close(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * enum dpmac_link_type -  DPMAC link type
@@ -90,7 +97,6 @@ enum dpmac_link_type {
  * @DPMAC_ETH_IF_GMII: GMII interface
  * @DPMAC_ETH_IF_RGMII: RGMII interface
  * @DPMAC_ETH_IF_SGMII: SGMII interface
- * @DPMAC_ETH_IF_XGMII: XGMII interface
  * @DPMAC_ETH_IF_QSGMII: QSGMII interface
  * @DPMAC_ETH_IF_XAUI: XAUI interface
  * @DPMAC_ETH_IF_XFI: XFI interface
@@ -102,14 +108,13 @@ enum dpmac_eth_if {
 	DPMAC_ETH_IF_GMII,
 	DPMAC_ETH_IF_RGMII,
 	DPMAC_ETH_IF_SGMII,
-	DPMAC_ETH_IF_XGMII,
 	DPMAC_ETH_IF_QSGMII,
 	DPMAC_ETH_IF_XAUI,
 	DPMAC_ETH_IF_XFI
 };
 
 /**
- * struct dpmac_cfg() - Structure representing DPMAC configuration
+ * struct dpmac_cfg - Structure representing DPMAC configuration
  * @mac_id:	Represents the Hardware MAC ID; in case of multiple WRIOP,
  *		the MAC IDs are continuous.
  *		For example:  2 WRIOPs, 16 MACs in each:
@@ -123,6 +128,7 @@ struct dpmac_cfg {
 /**
  * dpmac_create() - Create the DPMAC object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -141,17 +147,21 @@ struct dpmac_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_create(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 const struct dpmac_cfg	*cfg,
-		uint16_t		*token);
+		 uint16_t		*token);
 
 /**
  * dpmac_destroy() - Destroy the DPMAC object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpmac_destroy(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
+		  uint16_t		token);
 
 /* DPMAC IRQ Index and Events */
 
@@ -163,49 +173,56 @@ int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token);
 #define DPMAC_IRQ_EVENT_LINK_CHANGED		0x00000002
 
 /**
+ * struct dpmac_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpmac_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
+
+/**
  * dpmac_set_irq() - Set IRQ information for the DPMAC to trigger an interrupt.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *				signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_set_irq(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
 		  uint16_t		token,
-		 uint8_t		irq_index,
-		 uint64_t		irq_addr,
-		 uint32_t		irq_val,
-		 int			user_irq_id);
+		  uint8_t		irq_index,
+		  struct dpmac_irq_cfg	*irq_cfg);
 
 /**
  * dpmac_get_irq() - Get IRQ information from the DPMAC.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @type:	Interrupt type: 0 represents message interrupt
- *				type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *				signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_get_irq(struct fsl_mc_io	*mc_io,
+		  uint32_t		cmd_flags,
 		  uint16_t		token,
-		 uint8_t		irq_index,
-		 int			*type,
-		 uint64_t		*irq_addr,
-		 uint32_t		*irq_val,
-		 int			*user_irq_id);
+		  uint8_t		irq_index,
+		  int			*type,
+		  struct dpmac_irq_cfg	*irq_cfg);
 
 /**
  * dpmac_set_irq_enable() - Set overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @en:	Interrupt state - enable = 1, disable = 0
@@ -218,13 +235,15 @@ int dpmac_get_irq(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_set_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
 			 uint16_t		token,
-			uint8_t			irq_index,
-			uint8_t			en);
+			 uint8_t		irq_index,
+			 uint8_t		en);
 
 /**
  * dpmac_get_irq_enable() - Get overall interrupt state
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @en:		Returned interrupt state - enable = 1, disable = 0
@@ -232,13 +251,15 @@ int dpmac_set_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_get_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
 			 uint16_t		token,
-			uint8_t			irq_index,
-			uint8_t			*en);
+			 uint8_t		irq_index,
+			 uint8_t		*en);
 
 /**
  * dpmac_set_irq_mask() - Set interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @mask:	Event mask to trigger interrupt;
@@ -251,14 +272,16 @@ int dpmac_get_irq_enable(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_set_irq_mask(struct fsl_mc_io	*mc_io,
+int dpmac_set_irq_mask(struct fsl_mc_io *mc_io,
+		       uint32_t	cmd_flags,
 		       uint16_t		token,
-		      uint8_t		irq_index,
-		      uint32_t		mask);
+		       uint8_t		irq_index,
+		       uint32_t		mask);
 
 /**
  * dpmac_get_irq_mask() - Get interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @mask:	Returned event mask to trigger interrupt
@@ -268,15 +291,17 @@ int dpmac_set_irq_mask(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_get_irq_mask(struct fsl_mc_io	*mc_io,
+int dpmac_get_irq_mask(struct fsl_mc_io *mc_io,
+		       uint32_t	cmd_flags,
 		       uint16_t		token,
-		      uint8_t		irq_index,
-		      uint32_t		*mask);
+		       uint8_t		irq_index,
+		       uint32_t		*mask);
 
 /**
  * dpmac_get_irq_status() - Get the current status of any pending interrupts.
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @status:	Returned interrupts status - one bit per cause:
@@ -286,14 +311,16 @@ int dpmac_get_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_get_irq_status(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
 			 uint16_t		token,
-			uint8_t			irq_index,
-			uint32_t		*status);
+			 uint8_t		irq_index,
+			 uint32_t		*status);
 
 /**
  * dpmac_clear_irq_status() - Clear a pending interrupt's status
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @irq_index:	The interrupt index to configure
  * @status:	Bits to clear (W1C) - one bit per cause:
@@ -303,9 +330,10 @@ int dpmac_get_irq_status(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_clear_irq_status(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
 			   uint16_t		token,
-			  uint8_t		irq_index,
-			  uint32_t		status);
+			   uint8_t		irq_index,
+			   uint32_t		status);
 
 /**
  * struct dpmac_attr - Structure representing DPMAC attributes
@@ -317,11 +345,11 @@ int dpmac_clear_irq_status(struct fsl_mc_io	*mc_io,
  * @version:	DPMAC version
  */
 struct dpmac_attr {
-	int id;
-	int phy_id;
-	enum dpmac_link_type link_type;
-	enum dpmac_eth_if eth_if;
-	uint32_t max_rate;
+	int			id;
+	int			phy_id;
+	enum dpmac_link_type	link_type;
+	enum dpmac_eth_if	eth_if;
+	uint32_t		max_rate;
 	/**
 	 * struct version - Structure representing DPMAC version
 	 * @major:	DPMAC major version
@@ -337,14 +365,16 @@ struct dpmac_attr {
  * dpmac_get_attributes - Retrieve DPMAC attributes.
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @attr:	Returned object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_get_attributes(struct fsl_mc_io	*mc_io,
+			 uint32_t		cmd_flags,
 			 uint16_t		token,
-			struct dpmac_attr	*attr);
+			 struct dpmac_attr	*attr);
 
 /**
  * struct dpmac_mdio_cfg - DPMAC MDIO read/write parameters
@@ -354,33 +384,38 @@ int dpmac_get_attributes(struct fsl_mc_io	*mc_io,
  * @data: Data read/write from/to MDIO
  */
 struct dpmac_mdio_cfg {
-	uint8_t	phy_addr;
-	uint8_t	 reg;
-	uint16_t data;
+	uint8_t		phy_addr;
+	uint8_t		reg;
+	uint16_t	data;
 };
 
 /**
  * dpmac_mdio_read() - Perform MDIO read transaction
  * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @cfg:	Structure with MDIO transaction parameters
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_mdio_read(struct fsl_mc_io *mc_io, uint16_t token,
-		    struct dpmac_mdio_cfg *cfg);
-
+int dpmac_mdio_read(struct fsl_mc_io		*mc_io,
+		    uint32_t			cmd_flags,
+		    uint16_t			token,
+		    struct dpmac_mdio_cfg	*cfg);
 
 /**
  * dpmac_mdio_write() - Perform MDIO write transaction
  * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @cfg:	Structure with MDIO transaction parameters
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_mdio_write(struct fsl_mc_io *mc_io, uint16_t token,
-		     struct dpmac_mdio_cfg *cfg);
+int dpmac_mdio_write(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
+		     uint16_t			token,
+		     struct dpmac_mdio_cfg	*cfg);
 
 /* DPMAC link configuration/state options */
 
@@ -406,13 +441,16 @@ struct dpmac_link_cfg {
 /**
  * dpmac_get_link_cfg() - Get Ethernet link configuration
  * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @cfg:	Returned structure with the link configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_get_link_cfg(struct fsl_mc_io *mc_io, uint16_t token,
-		       struct dpmac_link_cfg *cfg);
+int dpmac_get_link_cfg(struct fsl_mc_io	*mc_io,
+		       uint32_t		cmd_flags,
+		       uint16_t		token,
+		       struct dpmac_link_cfg	*cfg);
 
 /**
  * struct dpmac_link_state - DPMAC link configuration request
@@ -421,21 +459,24 @@ int dpmac_get_link_cfg(struct fsl_mc_io *mc_io, uint16_t token,
  * @up: Link state
  */
 struct dpmac_link_state {
-	uint32_t rate;
-	uint64_t options;
-	int up;
+	uint32_t	rate;
+	uint64_t	options;
+	int		up;
 };
 
 /**
  * dpmac_set_link_state() - Set the Ethernet link status
  * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @link_state:	Link state configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpmac_set_link_state(struct fsl_mc_io *mc_io, uint16_t token,
-			 struct dpmac_link_state *link_state);
+int dpmac_set_link_state(struct fsl_mc_io		*mc_io,
+			 uint32_t			cmd_flags,
+			 uint16_t			token,
+			 struct dpmac_link_state	*link_state);
 
 /**
  * enum dpni_counter - DPNI counter types
@@ -466,7 +507,7 @@ int dpmac_set_link_state(struct fsl_mc_io *mc_io, uint16_t token,
  * @DPMAC_CNT_EGR_VALID_PAUSE_FRAME: counts valid pause frame transmitted
  *				     (regular and PFC).
  * @DPMAC_CNT_ING_BYTE: counts octet received except preamble for all valid
-			frames and valid pause frames.
+ *				frames and valid pause frames.
  * @DPMAC_CNT_ING_MCAST_FRAME: counts received multicast frame
  * @DPMAC_CNT_ING_BCAST_FRAME: counts received broadcast frame
  * @DPMAC_CNT_ING_ALL_FRAME: counts each good or bad packet received.
@@ -515,14 +556,17 @@ enum dpmac_counter {
 /**
  * dpmac_get_counter() - Read a specific DPMAC counter
  * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPMAC object
  * @type:	The requested counter
  * @counter:	Returned counter value
  *
  * Return:	The requested counter; '0' otherwise.
  */
-int dpmac_get_counter(struct fsl_mc_io *mc_io, uint16_t token,
-		      enum dpmac_counter type,
-			   uint64_t *counter);
+int dpmac_get_counter(struct fsl_mc_io		*mc_io,
+		      uint32_t			cmd_flags,
+		      uint16_t			token,
+		      enum dpmac_counter	 type,
+		      uint64_t			*counter);
 
 #endif /* __FSL_DPMAC_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/mac.c b/drivers/staging/fsl-dpaa2/mac/mac.c
index 15dd9f7..b75715c 100644
--- a/drivers/staging/fsl-dpaa2/mac/mac.c
+++ b/drivers/staging/fsl-dpaa2/mac/mac.c
@@ -357,7 +357,7 @@ static void ppx_link_changed(struct net_device *netdev)
 	/* we intentionally ignore the error here as MC will return an error
 	 * if peer L2 interface (like a DPNI) is down at this time
 	 */
-	err = dpmac_set_link_state(priv->mc_dev->mc_io,
+	err = dpmac_set_link_state(priv->mc_dev->mc_io, 0,
 				   priv->mc_dev->mc_handle, &state);
 
 	if (err && err != -EACCES && err != -ENAVAIL)
@@ -406,7 +406,7 @@ static irqreturn_t ppx_irq_handler(int irq_num, void *arg)
 		goto err;
 	}
 
-	err = dpmac_get_link_cfg(mc_dev->mc_io,
+	err = dpmac_get_link_cfg(mc_dev->mc_io, 0,
 				 priv->mc_dev->mc_handle, &link_cfg);
 	if (err) {
 		dev_err(dev, "dpmac_get_link_cfg err %d\n", err);
@@ -417,7 +417,7 @@ static irqreturn_t ppx_irq_handler(int irq_num, void *arg)
 	if (err)
 		goto err;
 
-	err = dpmac_clear_irq_status(mc_dev->mc_io,
+	err = dpmac_clear_irq_status(mc_dev->mc_io, 0,
 				     priv->mc_dev->mc_handle,
 				     0, DPMAC_IRQ_EVENT_LINK_CFG_REQ);
 	if (err < 0) {
@@ -435,6 +435,7 @@ err:
 static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
 {
 	int err;
+	struct dpmac_irq_cfg irq_cfg;
 
 	err = fsl_mc_allocate_irqs(mc_dev);
 	if (err) {
@@ -442,7 +443,7 @@ static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
 		return err;
 	}
 
-	err = dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+	err = dpmac_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle,
 				   DPMAC_IRQ_INDEX, 0);
 	if (err) {
 		dev_err(&mc_dev->dev, "dpmac_set_irq_enable err %d\n", err);
@@ -460,15 +461,17 @@ static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
 		goto free_irq;
 	}
 
-	err = dpmac_set_irq(mc_dev->mc_io, mc_dev->mc_handle, DPMAC_IRQ_INDEX,
-			    mc_dev->irqs[0]->msi_paddr,
-			    mc_dev->irqs[0]->msi_value, 0 /*?*/);
+	irq_cfg.addr = mc_dev->irqs[0]->msi_paddr;
+	irq_cfg.val = mc_dev->irqs[0]->msi_value;
+	irq_cfg.user_irq_id = mc_dev->irqs[0]->irq_number;
+	err = dpmac_set_irq(mc_dev->mc_io, 0, mc_dev->mc_handle,
+			    DPMAC_IRQ_INDEX, &irq_cfg);
 	if (err) {
 		dev_err(&mc_dev->dev, "dpmac_set_irq err %d\n", err);
 		goto unregister_irq;
 	}
 
-	err = dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+	err = dpmac_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle,
 				   DPMAC_IRQ_INDEX, 1);
 	if (err) {
 		dev_err(&mc_dev->dev, "dpmac_set_irq_enable err %d\n", err);
@@ -487,7 +490,7 @@ free_irq:
 
 static void ppx_teardown_irqs(struct fsl_mc_device *mc_dev)
 {
-	dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+	dpmac_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle,
 			     DPMAC_IRQ_INDEX, 0);
 	devm_free_irq(&mc_dev->dev, mc_dev->irqs[0]->irq_number, &mc_dev->dev);
 	fsl_mc_free_irqs(mc_dev);
@@ -541,7 +544,7 @@ ppx_probe(struct fsl_mc_device *mc_dev)
 		goto err_free_netdev;
 	}
 
-	err = dpmac_open(mc_dev->mc_io, mc_dev->obj_desc.id,
+	err = dpmac_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,
 			 &mc_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpmac_open err %d\n", err);
@@ -553,7 +556,7 @@ ppx_probe(struct fsl_mc_device *mc_dev)
 		goto err_free_mcp;
 	}
 
-	err = dpmac_get_attributes(mc_dev->mc_io,
+	err = dpmac_get_attributes(mc_dev->mc_io, 0,
 				   mc_dev->mc_handle, &priv->attr);
 	if (err) {
 		dev_err(dev, "dpmac_get_attributes err %d\n", err);
@@ -653,7 +656,7 @@ err_no_phy:
 err_free_irq:
 	ppx_teardown_irqs(mc_dev);
 err_close:
-	dpmac_close(mc_dev->mc_io, mc_dev->mc_handle);
+	dpmac_close(mc_dev->mc_io, 0, mc_dev->mc_handle);
 err_free_mcp:
 	fsl_mc_portal_free(mc_dev->mc_io);
 err_free_netdev:
@@ -670,7 +673,7 @@ ppx_remove(struct fsl_mc_device *devppx)
 
 	unregister_netdev(priv->netdev);
 	ppx_teardown_irqs(priv->mc_dev);
-	dpmac_close(priv->mc_dev->mc_io, priv->mc_dev->mc_handle);
+	dpmac_close(priv->mc_dev->mc_io, 0, priv->mc_dev->mc_handle);
 	fsl_mc_portal_free(priv->mc_dev->mc_io);
 	free_netdev(priv->netdev);
 
diff --git a/drivers/staging/fsl-mc/bus/dpbp.c b/drivers/staging/fsl-mc/bus/dpbp.c
index 6fede3d..6857a67 100644
--- a/drivers/staging/fsl-mc/bus/dpbp.c
+++ b/drivers/staging/fsl-mc/bus/dpbp.c
@@ -34,14 +34,18 @@
 #include "../include/dpbp.h"
 #include "../include/dpbp-cmd.h"
 
-int dpbp_open(struct fsl_mc_io *mc_io, int dpbp_id, uint16_t *token)
+int dpbp_open(struct fsl_mc_io *mc_io,
+	      uint32_t cmd_flags,
+	      int dpbp_id,
+	      uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPBP_CMD_OPEN(cmd, dpbp_id);
 
 	/* send command to mc*/
@@ -55,12 +59,14 @@ int dpbp_open(struct fsl_mc_io *mc_io, int dpbp_id, uint16_t *token)
 	return err;
 }
 
-int dpbp_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpbp_close(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CLOSE, MC_CMD_PRI_HIGH,
+	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CLOSE, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -68,6 +74,7 @@ int dpbp_close(struct fsl_mc_io *mc_io, uint16_t token)
 }
 
 int dpbp_create(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
 		const struct dpbp_cfg *cfg,
 		uint16_t *token)
 {
@@ -78,7 +85,8 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CREATE,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -91,48 +99,59 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpbp_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpbp_destroy(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpbp_enable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpbp_enable(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPBP_CMDID_ENABLE, MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPBP_CMDID_ENABLE, cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpbp_disable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpbp_disable(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_DISABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpbp_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpbp_is_enabled(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPBP_CMDID_IS_ENABLED, MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPBP_CMDID_IS_ENABLED, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -146,50 +165,55 @@ int dpbp_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpbp_reset(struct fsl_mc_io *mc_io, uint16_t token)
+int dpbp_reset(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_RESET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpbp_set_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id)
+int dpbp_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 struct dpbp_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW, token);
-	DPBP_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+					  cmd_flags,
+					  token);
+
+	DPBP_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpbp_get_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id)
+int dpbp_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 struct dpbp_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_GET_IRQ(cmd, irq_index);
 
 	/* send command to mc*/
@@ -198,12 +222,13 @@ int dpbp_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPBP_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPBP_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpbp_set_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t en)
@@ -212,7 +237,9 @@ int dpbp_set_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -220,6 +247,7 @@ int dpbp_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_get_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t *en)
@@ -229,7 +257,9 @@ int dpbp_get_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -244,6 +274,7 @@ int dpbp_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_set_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t mask)
@@ -252,7 +283,9 @@ int dpbp_set_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -260,6 +293,7 @@ int dpbp_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_get_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t *mask)
@@ -269,7 +303,9 @@ int dpbp_get_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -284,6 +320,7 @@ int dpbp_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_get_irq_status(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t *status)
@@ -293,7 +330,9 @@ int dpbp_get_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -308,6 +347,7 @@ int dpbp_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_clear_irq_status(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint32_t status)
@@ -316,7 +356,9 @@ int dpbp_clear_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
+
 	DPBP_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -324,6 +366,7 @@ int dpbp_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_get_attributes(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			struct dpbp_attr *attr)
 {
@@ -332,7 +375,8 @@ int dpbp_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
diff --git a/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c b/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
index 5b642e0..0dbdfc6 100644
--- a/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
+++ b/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
@@ -113,6 +113,8 @@ static int register_dpio_irq_handlers(struct fsl_mc_device *ls_dev, int cpu)
 		return -EINVAL;
 
 	for (i = 0; i < irq_count; i++) {
+		struct dpio_irq_cfg irq_cfg;
+
 		irq = ls_dev->irqs[i];
 		error = devm_request_irq(&ls_dev->dev,
 					 irq->irq_number,
@@ -141,10 +143,12 @@ static int register_dpio_irq_handlers(struct fsl_mc_device *ls_dev, int cpu)
 		 * when the MC object-independent dprc_set_irq() flib API
 		 * becomes available
 		 */
-		error = dpio_set_irq(ls_dev->mc_io, ls_dev->mc_handle,
-				     i, irq->msi_paddr,
-				     irq->msi_value,
-				     irq->irq_number);
+		irq_cfg.addr = irq->msi_paddr;
+		irq_cfg.val = irq->msi_value;
+		irq_cfg.user_irq_id = irq->irq_number;
+		error = dpio_set_irq(ls_dev->mc_io, 0, ls_dev->mc_handle,
+				     i,
+				     &irq_cfg);
 		if (error < 0) {
 			dev_err(&ls_dev->dev,
 				"mc_set_irq() failed: %d\n", error);
@@ -191,19 +195,20 @@ ldpaa_dpio_probe(struct fsl_mc_device *ls_dev)
 		goto err_mcportal;
 	}
 
-	err = dpio_open(ls_dev->mc_io, ls_dev->obj_desc.id, &ls_dev->mc_handle);
+	err = dpio_open(ls_dev->mc_io, 0, ls_dev->obj_desc.id,
+			&ls_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpio_open() failed\n");
 		goto err_open;
 	}
 
-	err = dpio_get_attributes(ls_dev->mc_io, ls_dev->mc_handle,
-				&dpio_attrs);
+	err = dpio_get_attributes(ls_dev->mc_io, 0, ls_dev->mc_handle,
+				  &dpio_attrs);
 	if (err) {
 		dev_err(dev, "dpio_get_attributes() failed %d\n", err);
 		goto err_get_attr;
 	}
-	err = dpio_enable(ls_dev->mc_io, ls_dev->mc_handle);
+	err = dpio_enable(ls_dev->mc_io, 0, ls_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpio_enable() failed %d\n", err);
 		goto err_get_attr;
@@ -295,7 +300,7 @@ ldpaa_dpio_probe(struct fsl_mc_device *ls_dev)
 	dev_info(dev, "   receives_notifications = %d\n",
 			desc.receives_notifications);
 	dev_info(dev, "   has_irq = %d\n", desc.has_irq);
-	dpio_close(ls_dev->mc_io, ls_dev->mc_handle);
+	dpio_close(ls_dev->mc_io, 0, ls_dev->mc_handle);
 	fsl_mc_portal_free(ls_dev->mc_io);
 	return 0;
 
@@ -307,9 +312,9 @@ err_dpaa_io_add:
 */
 err_dpaa_thread:
 err_dpaa_io_create:
-	dpio_disable(ls_dev->mc_io, ls_dev->mc_handle);
+	dpio_disable(ls_dev->mc_io, 0, ls_dev->mc_handle);
 err_get_attr:
-	dpio_close(ls_dev->mc_io, ls_dev->mc_handle);
+	dpio_close(ls_dev->mc_io, 0, ls_dev->mc_handle);
 err_open:
 	fsl_mc_portal_free(ls_dev->mc_io);
 err_mcportal:
@@ -355,7 +360,8 @@ ldpaa_dpio_remove(struct fsl_mc_device *ls_dev)
 		goto err_mcportal;
 	}
 
-	err = dpio_open(ls_dev->mc_io, ls_dev->obj_desc.id, &ls_dev->mc_handle);
+	err = dpio_open(ls_dev->mc_io, 0, ls_dev->obj_desc.id,
+			&ls_dev->mc_handle);
 	if (err) {
 		dev_err(dev, "dpio_open() failed\n");
 		goto err_open;
@@ -366,8 +372,8 @@ ldpaa_dpio_remove(struct fsl_mc_device *ls_dev)
 
 	err = 0;
 
-	dpio_disable(ls_dev->mc_io, ls_dev->mc_handle);
-	dpio_close(ls_dev->mc_io, ls_dev->mc_handle);
+	dpio_disable(ls_dev->mc_io, 0, ls_dev->mc_handle);
+	dpio_close(ls_dev->mc_io, 0, ls_dev->mc_handle);
 err_open:
 	fsl_mc_portal_free(ls_dev->mc_io);
 err_mcportal:
diff --git a/drivers/staging/fsl-mc/bus/dpio/dpio.c b/drivers/staging/fsl-mc/bus/dpio/dpio.c
index 7823bdc..84573d1 100644
--- a/drivers/staging/fsl-mc/bus/dpio/dpio.c
+++ b/drivers/staging/fsl-mc/bus/dpio/dpio.c
@@ -34,14 +34,18 @@
 #include "fsl_dpio.h"
 #include "fsl_dpio_cmd.h"
 
-int dpio_open(struct fsl_mc_io *mc_io, int dpio_id, uint16_t *token)
+int dpio_open(struct fsl_mc_io *mc_io,
+	      uint32_t cmd_flags,
+	      int dpio_id,
+	      uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_OPEN,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPIO_CMD_OPEN(cmd, dpio_id);
 
 	/* send command to mc*/
@@ -55,19 +59,23 @@ int dpio_open(struct fsl_mc_io *mc_io, int dpio_id, uint16_t *token)
 	return 0;
 }
 
-int dpio_close(struct fsl_mc_io *mc_io, uint16_t token)
+int dpio_close(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_CLOSE,
-					  MC_CMD_PRI_HIGH, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
 int dpio_create(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
 		const struct dpio_cfg *cfg,
 		uint16_t *token)
 {
@@ -76,7 +84,8 @@ int dpio_create(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_CREATE,
-					  MC_CMD_PRI_LOW, 0);
+					  cmd_flags,
+					  0);
 	DPIO_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -90,50 +99,60 @@ int dpio_create(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpio_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+int dpio_destroy(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_DESTROY,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_enable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpio_enable(struct fsl_mc_io *mc_io,
+		uint32_t cmd_flags,
+		uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_disable(struct fsl_mc_io *mc_io, uint16_t token)
+int dpio_disable(struct fsl_mc_io *mc_io,
+		 uint32_t cmd_flags,
+		 uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_DISABLE,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+int dpio_is_enabled(struct fsl_mc_io *mc_io,
+		    uint32_t cmd_flags,
+		    uint16_t token,
+		    int *en)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPIO_CMDID_IS_ENABLED, MC_CMD_PRI_LOW,
+	cmd.header = mc_encode_cmd_header(DPIO_CMDID_IS_ENABLED, cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -147,51 +166,52 @@ int dpio_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
 	return 0;
 }
 
-int dpio_reset(struct fsl_mc_io *mc_io, uint16_t token)
+int dpio_reset(struct fsl_mc_io *mc_io,
+	       uint32_t cmd_flags,
+	       uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_RESET,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_set_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 uint64_t irq_addr,
-		 uint32_t irq_val,
-		 int user_irq_id)
+int dpio_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 struct dpio_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_SET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
-	DPIO_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+	DPIO_CMD_SET_IRQ(cmd, irq_index, irq_cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_get_irq(struct fsl_mc_io *mc_io,
-		 uint16_t token,
-		 uint8_t irq_index,
-		 int *type,
-		 uint64_t *irq_addr,
-		 uint32_t *irq_val,
-		 int *user_irq_id)
+int dpio_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 struct dpio_irq_cfg	*irq_cfg)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_IRQ,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 	DPIO_CMD_GET_IRQ(cmd, irq_index);
 
@@ -201,12 +221,13 @@ int dpio_get_irq(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPIO_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+	DPIO_RSP_GET_IRQ(cmd, *type, irq_cfg);
 
 	return 0;
 }
 
 int dpio_set_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t en)
@@ -215,7 +236,8 @@ int dpio_set_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_SET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
 
 	/* send command to mc*/
@@ -223,6 +245,7 @@ int dpio_set_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpio_get_irq_enable(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint8_t *en)
@@ -232,7 +255,8 @@ int dpio_get_irq_enable(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_IRQ_ENABLE,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_GET_IRQ_ENABLE(cmd, irq_index);
 
 	/* send command to mc*/
@@ -247,6 +271,7 @@ int dpio_get_irq_enable(struct fsl_mc_io *mc_io,
 }
 
 int dpio_set_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t mask)
@@ -255,7 +280,8 @@ int dpio_set_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_SET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
 
 	/* send command to mc*/
@@ -263,6 +289,7 @@ int dpio_set_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpio_get_irq_mask(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t irq_index,
 		      uint32_t *mask)
@@ -272,7 +299,8 @@ int dpio_get_irq_mask(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_IRQ_MASK,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_GET_IRQ_MASK(cmd, irq_index);
 
 	/* send command to mc*/
@@ -287,6 +315,7 @@ int dpio_get_irq_mask(struct fsl_mc_io *mc_io,
 }
 
 int dpio_get_irq_status(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			uint8_t irq_index,
 			uint32_t *status)
@@ -296,7 +325,8 @@ int dpio_get_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_GET_IRQ_STATUS(cmd, irq_index);
 
 	/* send command to mc*/
@@ -311,6 +341,7 @@ int dpio_get_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpio_clear_irq_status(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
 			  uint16_t token,
 			  uint8_t irq_index,
 			  uint32_t status)
@@ -319,7 +350,8 @@ int dpio_clear_irq_status(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_CLEAR_IRQ_STATUS,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
 
 	/* send command to mc*/
@@ -327,6 +359,7 @@ int dpio_clear_irq_status(struct fsl_mc_io *mc_io,
 }
 
 int dpio_get_attributes(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
 			uint16_t token,
 			struct dpio_attr *attr)
 {
@@ -335,7 +368,7 @@ int dpio_get_attributes(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_ATTR,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
 					  token);
 
 	/* send command to mc*/
@@ -350,6 +383,7 @@ int dpio_get_attributes(struct fsl_mc_io *mc_io,
 }
 
 int dpio_set_stashing_destination(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  uint8_t sdest)
 {
@@ -357,7 +391,8 @@ int dpio_set_stashing_destination(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_SET_STASHING_DEST,
-					  MC_CMD_PRI_LOW, token);
+					  cmd_flags,
+					  token);
 	DPIO_CMD_SET_STASHING_DEST(cmd, sdest);
 
 	/* send command to mc*/
@@ -365,6 +400,7 @@ int dpio_set_stashing_destination(struct fsl_mc_io *mc_io,
 }
 
 int dpio_get_stashing_destination(struct fsl_mc_io *mc_io,
+				  uint32_t cmd_flags,
 				  uint16_t token,
 				  uint8_t *sdest)
 {
@@ -373,8 +409,34 @@ int dpio_get_stashing_destination(struct fsl_mc_io *mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_STASHING_DEST,
-					  MC_CMD_PRI_LOW,
+					  cmd_flags,
+					  token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPIO_RSP_GET_STASHING_DEST(cmd, sdest);
+
+	return 0;
+}
+
+int dpio_add_static_dequeue_channel(struct fsl_mc_io *mc_io,
+				    uint32_t cmd_flags,
+				    uint16_t token,
+				    int dpcon_id,
+				    uint8_t *channel_index)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPIO_CMDID_ADD_STATIC_DEQUEUE_CHANNEL,
+					  cmd_flags,
 					  token);
+	DPIO_CMD_ADD_STATIC_DEQUEUE_CHANNEL(cmd, dpcon_id);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -382,7 +444,25 @@ int dpio_get_stashing_destination(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPIO_RSP_GET_STASHING_DEST(cmd, *sdest);
+	DPIO_RSP_ADD_STATIC_DEQUEUE_CHANNEL(cmd, *channel_index);
 
 	return 0;
 }
+
+int dpio_remove_static_dequeue_channel(struct fsl_mc_io *mc_io,
+				       uint32_t cmd_flags,
+				       uint16_t token,
+				       int dpcon_id)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+				DPIO_CMDID_REMOVE_STATIC_DEQUEUE_CHANNEL,
+				cmd_flags,
+				token);
+	DPIO_CMD_REMOVE_STATIC_DEQUEUE_CHANNEL(cmd, dpcon_id);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
diff --git a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
index a5f8e9a..e04d2e1 100644
--- a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
+++ b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
@@ -41,6 +41,7 @@ struct fsl_mc_io;
 /**
  * dpio_open() - Open a control session for the specified object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpio_id:	DPIO unique ID
  * @token:	Returned token; use in subsequent API calls
  *
@@ -54,16 +55,22 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_open(struct fsl_mc_io *mc_io, int dpio_id, uint16_t *token);
+int dpio_open(struct fsl_mc_io	*mc_io,
+	      uint32_t		cmd_flags,
+	      int		dpio_id,
+	      uint16_t		*token);
 
 /**
  * dpio_close() - Close the control session of the object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpio_close(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       uint16_t		token);
 
 /**
  * enum dpio_channel_mode - DPIO notification channel mode
@@ -84,13 +91,14 @@ enum dpio_channel_mode {
  *			relevant only if 'channel_mode = DPIO_LOCAL_CHANNEL'
  */
 struct dpio_cfg {
-	enum dpio_channel_mode channel_mode;
-	uint8_t num_priorities;
+	enum dpio_channel_mode	channel_mode;
+	uint8_t		num_priorities;
 };
 
 /**
  * dpio_create() - Create the DPIO object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -110,131 +118,187 @@ struct dpio_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_create(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
 		const struct dpio_cfg	*cfg,
 		uint16_t		*token);
 
 /**
  * dpio_destroy() - Destroy the DPIO object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  *
  * Return:	'0' on Success; Error code otherwise
  */
-int dpio_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpio_destroy(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpio_enable() - Enable the DPIO, allow I/O portal operations.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  *
  * Return:	'0' on Success; Error code otherwise
  */
-int dpio_enable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpio_enable(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * dpio_disable() - Disable the DPIO, stop any I/O portal operation.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  *
  * Return:	'0' on Success; Error code otherwise
  */
-int dpio_disable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpio_disable(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpio_is_enabled() - Check if the DPIO is enabled.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @en:	Returns '1' if object is enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpio_is_enabled(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    int		*en);
 
 /**
  * dpio_reset() - Reset the DPIO, returns the object to initial state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_reset(struct fsl_mc_io *mc_io, uint16_t token);
+int dpio_reset(struct fsl_mc_io	*mc_io,
+	       uint32_t			cmd_flags,
+	       uint16_t		token);
 
 /**
  * dpio_set_stashing_destination() - Set the stashing destination.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @sdest:	stashing destination value
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_set_stashing_destination(struct fsl_mc_io *mc_io,
-				  uint16_t token,
-				  uint8_t sdest);
+int dpio_set_stashing_destination(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
+				  uint16_t		token,
+				  uint8_t		sdest);
 
 /**
  * dpio_get_stashing_destination() - Get the stashing destination..
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @sdest:	Returns the stashing destination value
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpio_get_stashing_destination(struct fsl_mc_io *mc_io,
-				  uint16_t token,
-				  uint8_t *sdest);
+int dpio_get_stashing_destination(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
+				  uint16_t		token,
+				  uint8_t		*sdest);
 
-/*!
- * @name DPIO IRQ Index and Events
+/**
+ * dpio_add_static_dequeue_channel() - Add a static dequeue channel.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPIO object
+ * @dpcon_id:	DPCON object ID
+ * @channel_index: Returned channel index to be used in qbman API
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpio_add_static_dequeue_channel(struct fsl_mc_io	*mc_io,
+				    uint32_t		cmd_flags,
+				    uint16_t		token,
+				    int		dpcon_id,
+				    uint8_t		*channel_index);
+
+/**
+ * dpio_remove_static_dequeue_channel() - Remove a static dequeue channel.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPIO object
+ * @dpcon_id:	DPCON object ID
+ *
+ * Return:	'0' on Success; Error code otherwise.
  */
+int dpio_remove_static_dequeue_channel(struct fsl_mc_io	*mc_io,
+				       uint32_t		cmd_flags,
+				       uint16_t		token,
+				       int			dpcon_id);
+
+/* DPIO IRQ Index and Events */
+
+/* Irq software-portal index */
 #define DPIO_IRQ_SWP_INDEX				0
-/*!< Irq software-portal index */
-/* @} */
+
+/**
+ * struct dpio_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpio_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
 
 /**
  * dpio_set_irq() - Set IRQ information for the DPIO to trigger an interrupt.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *		signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
-		uint8_t			irq_index,
-		uint64_t		irq_addr,
-		uint32_t		irq_val,
-		int			user_irq_id);
+		 uint8_t		irq_index,
+		 struct dpio_irq_cfg	*irq_cfg);
 
 /**
  * dpio_get_irq() - Get IRQ information from the DPIO.
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
- * @type:	Returned interrupt type: 0 represents message interrupt
- *				type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *				signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @type:	Interrupt type: 0 represents message interrupt
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
 		 uint8_t		irq_index,
 		 int			*type,
-		 uint64_t		*irq_addr,
-		 uint32_t		*irq_val,
-		 int			*user_irq_id);
+		 struct dpio_irq_cfg	*irq_cfg);
 
 /**
  * dpio_set_irq_enable() - Set overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @en:		Interrupt state - enable = 1, disable = 0
@@ -247,6 +311,7 @@ int dpio_get_irq(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_set_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			en);
@@ -254,6 +319,7 @@ int dpio_set_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpio_get_irq_enable() - Get overall interrupt state
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @en:		Returned interrupt state - enable = 1, disable = 0
@@ -261,6 +327,7 @@ int dpio_set_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_get_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			*en);
@@ -268,6 +335,7 @@ int dpio_get_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpio_set_irq_mask() - Set interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @mask:	event mask to trigger interrupt;
@@ -281,6 +349,7 @@ int dpio_get_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_set_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		mask);
@@ -288,6 +357,7 @@ int dpio_set_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpio_get_irq_mask() - Get interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @mask:	Returned event mask to trigger interrupt
@@ -298,6 +368,7 @@ int dpio_set_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_get_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		*mask);
@@ -305,6 +376,7 @@ int dpio_get_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpio_get_irq_status() - Get the current status of any pending interrupts.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @status:	Returned interrupts status - one bit per cause:
@@ -314,6 +386,7 @@ int dpio_get_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_get_irq_status(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint32_t		*status);
@@ -321,6 +394,7 @@ int dpio_get_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * dpio_clear_irq_status() - Clear a pending interrupt's status
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @irq_index:	The interrupt index to configure
  * @status:	bits to clear (W1C) - one bit per cause:
@@ -330,6 +404,7 @@ int dpio_get_irq_status(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_clear_irq_status(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint32_t		status);
@@ -346,7 +421,7 @@ int dpio_clear_irq_status(struct fsl_mc_io	*mc_io,
  *			relevant only if 'channel_mode = DPIO_LOCAL_CHANNEL'
  */
 struct dpio_attr {
-	int id;
+	int			id;
 	/**
 	 * struct version - DPIO version
 	 * @major: DPIO major version
@@ -356,22 +431,24 @@ struct dpio_attr {
 		uint16_t major;
 		uint16_t minor;
 	} version;
-	uint64_t qbman_portal_ce_offset;
-	uint64_t qbman_portal_ci_offset;
-	uint16_t qbman_portal_id;
-	enum dpio_channel_mode channel_mode;
-	uint8_t num_priorities;
+	uint64_t		qbman_portal_ce_offset;
+	uint64_t		qbman_portal_ci_offset;
+	uint16_t		qbman_portal_id;
+	enum dpio_channel_mode	channel_mode;
+	uint8_t		num_priorities;
 };
 
 /**
  * dpio_get_attributes() - Retrieve DPIO attributes
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPIO object
  * @attr:	Returned object's attributes
  *
  * Return:	'0' on Success; Error code otherwise
  */
 int dpio_get_attributes(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			struct dpio_attr	*attr);
 #endif /* __FSL_DPIO_H */
diff --git a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
index a74b81a..b374174 100644
--- a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
+++ b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
@@ -34,7 +34,7 @@
 
 /* DPIO Version */
 #define DPIO_VER_MAJOR				3
-#define DPIO_VER_MINOR				0
+#define DPIO_VER_MINOR				1
 
 /* Command IDs */
 #define DPIO_CMDID_CLOSE				0x800
@@ -59,6 +59,8 @@
 
 #define DPIO_CMDID_SET_STASHING_DEST		0x120
 #define DPIO_CMDID_GET_STASHING_DEST		0x121
+#define DPIO_CMDID_ADD_STATIC_DEQUEUE_CHANNEL		0x122
+#define DPIO_CMDID_REMOVE_STATIC_DEQUEUE_CHANNEL	0x123
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPIO_CMD_OPEN(cmd, dpio_id) \
@@ -77,12 +79,12 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPIO_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPIO_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr);\
-	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_cfg->val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr);\
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -90,11 +92,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPIO_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPIO_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
@@ -164,4 +166,15 @@ do { \
 #define DPIO_RSP_GET_STASHING_DEST(cmd, sdest) \
 	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,  sdest)
 
+/*                cmd, param, offset, width, type, arg_name */
+#define DPIO_CMD_ADD_STATIC_DEQUEUE_CHANNEL(cmd, dpcon_id) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,      dpcon_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPIO_RSP_ADD_STATIC_DEQUEUE_CHANNEL(cmd, channel_index) \
+	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,  channel_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPIO_CMD_REMOVE_STATIC_DEQUEUE_CHANNEL(cmd, dpcon_id) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,      dpcon_id)
 #endif /* _FSL_DPIO_CMD_H */
diff --git a/drivers/staging/fsl-mc/include/dpbp-cmd.h b/drivers/staging/fsl-mc/include/dpbp-cmd.h
index 12c0117..be80c03 100644
--- a/drivers/staging/fsl-mc/include/dpbp-cmd.h
+++ b/drivers/staging/fsl-mc/include/dpbp-cmd.h
@@ -34,7 +34,7 @@
 
 /* DPBP Version */
 #define DPBP_VER_MAJOR				2
-#define DPBP_VER_MINOR				0
+#define DPBP_VER_MINOR				1
 
 /* Command IDs */
 #define DPBP_CMDID_CLOSE				0x800
@@ -66,12 +66,12 @@
 	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPBP_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+#define DPBP_CMD_SET_IRQ(cmd, irq_index, irq_cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_cfg->val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -79,11 +79,11 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPBP_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+#define DPBP_RSP_GET_IRQ(cmd, type, irq_cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
diff --git a/drivers/staging/fsl-mc/include/dpbp.h b/drivers/staging/fsl-mc/include/dpbp.h
index 5f3c8e7..5d16bb1 100644
--- a/drivers/staging/fsl-mc/include/dpbp.h
+++ b/drivers/staging/fsl-mc/include/dpbp.h
@@ -41,6 +41,7 @@ struct fsl_mc_io;
 /**
  * dpbp_open() - Open a control session for the specified object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @dpbp_id:	DPBP unique ID
  * @token:	Returned token; use in subsequent API calls
  *
@@ -54,11 +55,15 @@ struct fsl_mc_io;
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_open(struct fsl_mc_io *mc_io, int dpbp_id, uint16_t *token);
+int dpbp_open(struct fsl_mc_io	*mc_io,
+	      uint32_t		cmd_flags,
+	      int		dpbp_id,
+	      uint16_t		*token);
 
 /**
  * dpbp_close() - Close the control session of the object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  *
  * After this function is called, no further operations are
@@ -66,10 +71,12 @@ int dpbp_open(struct fsl_mc_io *mc_io, int dpbp_id, uint16_t *token);
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_close(struct fsl_mc_io *mc_io, uint16_t token);
+int dpbp_close(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       uint16_t	token);
 
 /**
- * struct dpbp_cfg() - Structure representing DPBP configuration
+ * struct dpbp_cfg - Structure representing DPBP configuration
  * @options:	place holder
  */
 struct dpbp_cfg {
@@ -79,6 +86,7 @@ struct dpbp_cfg {
 /**
  * dpbp_create() - Create the DPBP object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
  * @token:	Returned token; use in subsequent API calls
  *
@@ -97,99 +105,123 @@ struct dpbp_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_create(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
 		const struct dpbp_cfg	*cfg,
 		uint16_t		*token);
 
 /**
  * dpbp_destroy() - Destroy the DPBP object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpbp_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+int dpbp_destroy(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpbp_enable() - Enable the DPBP.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_enable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpbp_enable(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * dpbp_disable() - Disable the DPBP.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_disable(struct fsl_mc_io *mc_io, uint16_t token);
+int dpbp_disable(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
+		 uint16_t		token);
 
 /**
  * dpbp_is_enabled() - Check if the DPBP is enabled.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @en:		Returns '1' if object is enabled; '0' otherwise
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+int dpbp_is_enabled(struct fsl_mc_io	*mc_io,
+		    uint32_t		cmd_flags,
+		    uint16_t		token,
+		    int		*en);
 
 /**
  * dpbp_reset() - Reset the DPBP, returns the object to initial state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_reset(struct fsl_mc_io *mc_io, uint16_t token);
+int dpbp_reset(struct fsl_mc_io	*mc_io,
+	       uint32_t		cmd_flags,
+	       uint16_t	token);
+
+/**
+ * struct dpbp_irq_cfg - IRQ configuration
+ * @addr:	Address that must be written to signal a message-based interrupt
+ * @val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ */
+struct dpbp_irq_cfg {
+	     uint64_t		addr;
+	     uint32_t		val;
+	     int		user_irq_id;
+};
 
 /**
  * dpbp_set_irq() - Set IRQ information for the DPBP to trigger an interrupt.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	Identifies the interrupt index to configure
- * @irq_addr:	Address that must be written to
- *				signal a message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_cfg:	IRQ configuration
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_set_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
 		 uint8_t		irq_index,
-		 uint64_t		irq_addr,
-		 uint32_t		irq_val,
-		 int			user_irq_id);
+		 struct dpbp_irq_cfg	*irq_cfg);
 
 /**
  * dpbp_get_irq() - Get IRQ information from the DPBP.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @type:	Interrupt type: 0 represents message interrupt
- *				type (both irq_addr and irq_val are valid)
- * @irq_addr:	Returned address that must be written to
- *				signal the message-based interrupt
- * @irq_val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_cfg:	IRQ attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_irq(struct fsl_mc_io	*mc_io,
+		 uint32_t		cmd_flags,
 		 uint16_t		token,
 		 uint8_t		irq_index,
 		 int			*type,
-		 uint64_t		*irq_addr,
-		 uint32_t		*irq_val,
-		 int			*user_irq_id);
+		 struct dpbp_irq_cfg	*irq_cfg);
 
 /**
  * dpbp_set_irq_enable() - Set overall interrupt state.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @en:	Interrupt state - enable = 1, disable = 0
@@ -202,6 +234,7 @@ int dpbp_get_irq(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_set_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			en);
@@ -209,6 +242,7 @@ int dpbp_set_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpbp_get_irq_enable() - Get overall interrupt state
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @en:		Returned interrupt state - enable = 1, disable = 0
@@ -216,6 +250,7 @@ int dpbp_set_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_irq_enable(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint8_t			*en);
@@ -223,6 +258,7 @@ int dpbp_get_irq_enable(struct fsl_mc_io	*mc_io,
 /**
  * dpbp_set_irq_mask() - Set interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @mask:	Event mask to trigger interrupt;
@@ -236,6 +272,7 @@ int dpbp_get_irq_enable(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_set_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		mask);
@@ -243,6 +280,7 @@ int dpbp_set_irq_mask(struct fsl_mc_io	*mc_io,
 /**
  * dpbp_get_irq_mask() - Get interrupt mask.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @mask:	Returned event mask to trigger interrupt
@@ -253,6 +291,7 @@ int dpbp_set_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_irq_mask(struct fsl_mc_io	*mc_io,
+		      uint32_t		cmd_flags,
 		      uint16_t		token,
 		      uint8_t		irq_index,
 		      uint32_t		*mask);
@@ -261,6 +300,7 @@ int dpbp_get_irq_mask(struct fsl_mc_io	*mc_io,
  * dpbp_get_irq_status() - Get the current status of any pending interrupts.
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @status:	Returned interrupts status - one bit per cause:
@@ -270,6 +310,7 @@ int dpbp_get_irq_mask(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_irq_status(struct fsl_mc_io	*mc_io,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			uint8_t			irq_index,
 			uint32_t		*status);
@@ -278,6 +319,7 @@ int dpbp_get_irq_status(struct fsl_mc_io	*mc_io,
  * dpbp_clear_irq_status() - Clear a pending interrupt's status
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @irq_index:	The interrupt index to configure
  * @status:	Bits to clear (W1C) - one bit per cause:
@@ -287,6 +329,7 @@ int dpbp_get_irq_status(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_clear_irq_status(struct fsl_mc_io	*mc_io,
+			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  uint8_t		irq_index,
 			  uint32_t		status);
@@ -316,12 +359,14 @@ struct dpbp_attr {
  * dpbp_get_attributes - Retrieve DPBP attributes.
  *
  * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPBP object
  * @attr:	Returned object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_attributes(struct fsl_mc_io	*mc_io,
+			uint32_t	cmd_flags,
 			uint16_t		token,
 			struct dpbp_attr	*attr);
 
diff --git a/drivers/staging/fsl-mc/include/dpcon-cmd.h b/drivers/staging/fsl-mc/include/dpcon-cmd.h
index c878d33..536b2ef 100644
--- a/drivers/staging/fsl-mc/include/dpcon-cmd.h
+++ b/drivers/staging/fsl-mc/include/dpcon-cmd.h
@@ -1,40 +1,40 @@
 /* Copyright 2013-2015 Freescale Semiconductor Inc.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-* * Redistributions of source code must retain the above copyright
-* notice, this list of conditions and the following disclaimer.
-* * Redistributions in binary form must reproduce the above copyright
-* notice, this list of conditions and the following disclaimer in the
-* documentation and/or other materials provided with the distribution.
-* * Neither the name of the above-listed copyright holders nor the
-* names of any contributors may be used to endorse or promote products
-* derived from this software without specific prior written permission.
-*
-*
-* ALTERNATIVELY, this software may be distributed under the terms of the
-* GNU General Public License ("GPL") as published by the Free Software
-* Foundation, either version 2 of that License or (at your option) any
-* later version.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
-* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-* POSSIBILITY OF SUCH DAMAGE.
-*/
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
 #ifndef _FSL_DPCON_CMD_H
 #define _FSL_DPCON_CMD_H
 
 /* DPCON Version */
 #define DPCON_VER_MAJOR				2
-#define DPCON_VER_MINOR				0
+#define DPCON_VER_MINOR				1
 
 /* Command IDs */
 #define DPCON_CMDID_CLOSE				0x800
-- 
2.5.3

