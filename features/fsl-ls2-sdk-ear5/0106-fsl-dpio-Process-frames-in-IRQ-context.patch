From e82655ab5e41b52bbeed1d459ec7c6ffcac605a9 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 6 May 2015 16:21:17 -0400
Subject: [PATCH 106/214] fsl-dpio: Process frames in IRQ context

Stop using threaded IRQs and move back to hardirq top-halves.
This is the first patch of a small series adapting the DPIO and Ethernet
code to these changes.

Signed-off-by: Roy Pledge <roy.pledge@freescale.com>
Tested-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Tested-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: I3389e7baf012f80262b4a8283d448598ee546d4d
Reviewed-on: http://git.am.freescale.net:8181/37677
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c | 14 +-------------
 drivers/staging/fsl-mc/bus/dpio/dpio-drv.c     | 22 ++++++----------------
 drivers/staging/fsl-mc/bus/dpio/dpio_service.c | 24 ++++++++----------------
 3 files changed, 15 insertions(+), 45 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
index 284c161..9435783 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
@@ -750,6 +750,7 @@ static int ldpaa_eth_poll(struct napi_struct *napi, int budget)
 
 	fq = container_of(napi, struct ldpaa_eth_fq, napi);
 	/* TODO Must prioritize TxConf over Rx NAPIs */
+	__ldpaa_eth_pull_fq(fq);
 
 	do {
 		store_cleaned = ldpaa_eth_store_consume(fq);
@@ -1133,9 +1134,6 @@ static void ldpaa_eth_fqdan_cb(struct dpaa_io_notification_ctx *ctx)
 {
 	struct ldpaa_eth_fq *fq = container_of(ctx, struct ldpaa_eth_fq, nctx);
 
-	/* TODO check return value */
-	__ldpaa_eth_pull_fq(fq);
-
 	/* Update NAPI statistics */
 	switch (fq->type) {
 	case LDPAA_RX_FQ:
@@ -1155,16 +1153,6 @@ static void ldpaa_eth_fqdan_cb(struct dpaa_io_notification_ctx *ctx)
 
 	fq->has_frames = true;
 	napi_schedule(&fq->napi);
-	/* Provide a guaranteed scheduling point for the bottom-half;
-	 * with threaded interrupts, that isn't automatically the case.
-	 * FIXME: we're effectively running in the software portal's top-half.
-	 * As long as:
-	 *   1. the Ethernet driver is the only client of the portal, and
-	 *   2. we only expect Dequeue Available Notifications,
-	 * this approach is fine. Once either of the conditions no longer holds,
-	 * we will have to move this to a separate execution context.
-	 */
-	do_softirq();
 }
 
 static void ldpaa_eth_setup_fqs(struct ldpaa_eth_priv *priv)
diff --git a/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c b/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
index f4e1d13..5b642e0 100644
--- a/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
+++ b/drivers/staging/fsl-mc/bus/dpio/dpio-drv.c
@@ -77,14 +77,6 @@ static int dpio_thread(void *data)
 	return 0;
 }
 
-static irqreturn_t dpio_irq_pre_handler(int irq_num, void *arg)
-{
-	struct device *dev = (struct device *)arg;
-	struct dpio_priv *priv = dev_get_drvdata(dev);
-
-	return dpaa_io_preirq(priv->io);
-}
-
 static irqreturn_t dpio_irq_handler(int irq_num, void *arg)
 {
 	struct device *dev = (struct device *)arg;
@@ -122,14 +114,12 @@ static int register_dpio_irq_handlers(struct fsl_mc_device *ls_dev, int cpu)
 
 	for (i = 0; i < irq_count; i++) {
 		irq = ls_dev->irqs[i];
-		error = devm_request_threaded_irq(&ls_dev->dev,
-						irq->irq_number,
-						dpio_irq_pre_handler,
-						dpio_irq_handler,
-						IRQF_NO_SUSPEND |
-							IRQF_ONESHOT,
-						priv->irq_name,
-						&ls_dev->dev);
+		error = devm_request_irq(&ls_dev->dev,
+					 irq->irq_number,
+					 dpio_irq_handler,
+					 0,
+					 priv->irq_name,
+					 &ls_dev->dev);
 		if (error < 0) {
 			dev_err(&ls_dev->dev,
 				"devm_request_threaded_irq() failed: %d\n",
diff --git a/drivers/staging/fsl-mc/bus/dpio/dpio_service.c b/drivers/staging/fsl-mc/bus/dpio/dpio_service.c
index f7acd0b..f3c8f33 100644
--- a/drivers/staging/fsl-mc/bus/dpio/dpio_service.c
+++ b/drivers/staging/fsl-mc/bus/dpio/dpio_service.c
@@ -364,16 +364,19 @@ int dpaa_io_get_descriptor(struct dpaa_io *obj, struct dpaa_io_desc *desc)
 }
 EXPORT_SYMBOL(dpaa_io_get_descriptor);
 
+#define DPAA_POLL_MAX 32
+
 int dpaa_io_poll(struct dpaa_io *obj)
 {
 	const struct ldpaa_dq *dq;
 	struct qbman_swp *swp;
+	int max = 0;
 
 	if (obj->magic != MAGIC_OBJECT)
 		return -EINVAL;
 	swp = obj->object.swp;
 	dq = qbman_swp_dqrr_next(swp);
-	if (dq) {
+	while (dq) {
 		if (qbman_result_is_FQDAN(dq)) {
 			struct dpaa_io_notification_ctx *ctx;
 			uint64_t q64;
@@ -384,26 +387,15 @@ int dpaa_io_poll(struct dpaa_io *obj)
 		} else
 			pr_crit("Unrecognised/ignored DQRR entry\n");
 		qbman_swp_dqrr_consume(swp, dq);
+		++max;
+		if (max > DPAA_POLL_MAX)
+			return 0;
+		dq = qbman_swp_dqrr_next(swp);
 	}
 	return 0;
 }
 EXPORT_SYMBOL(dpaa_io_poll);
 
-int dpaa_io_preirq(struct dpaa_io *obj)
-{
-	struct qbman_swp *swp;
-	uint32_t status;
-
-	if (obj->magic != MAGIC_OBJECT)
-		return -EINVAL;
-	swp = obj->object.swp;
-	status = qbman_swp_interrupt_read_status(swp);
-	if (!status)
-		return IRQ_NONE;
-	qbman_swp_interrupt_set_inhibit(swp, 1);
-	return IRQ_WAKE_THREAD;
-}
-
 int dpaa_io_irq(struct dpaa_io *obj)
 {
 	struct qbman_swp *swp;
-- 
2.5.3

