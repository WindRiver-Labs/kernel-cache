From 41fbaa804f5d78e16aad90ff3ecbf5c089e3683b Mon Sep 17 00:00:00 2001
From: Bhupesh Sharma <bhupesh.sharma@freescale.com>
Date: Fri, 23 Jan 2015 16:26:00 +0530
Subject: [PATCH 010/214] fsl/ls2085a: Add handling for ARM generic timer
 errata (ERR008585)

This patch adds s/w handling for LS2085A-Rev1 SoC Errata ERR008585:
ARM Generic Timer may contain an erroneous value.

Errata Description:
------------------
The ARM Generic Timer (as specified in the ARMv8 Architecture Reference
Manual) is supported. The ARM Generic Timer can schedule events and
trigger interrupts based on an incrementing counter value. However, it
has the potential to contain an erroneous value for a small number of
core clock cycles every time the timer value changes.

Errata Workaround:
-----------------
Use ARM Generic Timer and ignore spurious interrupts. Any time in
software reading registers CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL,
CNTPCT, or CNTVCT), have software read the register twice. If the
value read differs, then re-read the register, and continue to read
until two consecutive reads return the same value.

Signed-off-by: Bhupesh Sharma <bhupesh.sharma@freescale.com>
Change-Id: I829792ac6d85ca7a3aeb9b9740c2edcd128a8353
Reviewed-on: http://git.am.freescale.net:8181/29726
(cherry picked from commit 95fdc95afa2f78a1b9245723d2ac98d7b471102e)
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm64/Kconfig                   | 11 +++++++++++
 arch/arm64/include/asm/arch_timer.h  | 14 ++++++++++++++
 drivers/clocksource/arm_arch_timer.c | 35 +++++++++++++++++++++++++++++++++++
 3 files changed, 60 insertions(+)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 7796af4..fa5f55c 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -176,8 +176,19 @@ config ARCH_EXYNOS7
 	help
 	  This enables support for Samsung Exynos7 SoC family
 
+config LS2085A_ERRATA_ERR008585
+	bool "Freescale LS2085A SOC Errata ERR008585"
+	help
+	  This enables support for Freescale LS2085A SOC Errata ERR008585, which
+	  is related to ARM generic timers. The Errata is related to spurious
+	  arriving from ARM generic timers. Software should read registers
+	  CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL, CNTPCT, or CNTVCT twice.
+	  If the value read differs, then re-read the register, and continue to
+	  read until two consecutive reads return the same value.
+
 config ARCH_FSL_LS2085A
 	bool "Freescale LS2085A SOC"
+	select LS2085A_ERRATA_ERR008585
 	help
 	  This enables support for Freescale LS2085A SOC.
 
diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index fbe0ca3..a7c9e02 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -118,9 +118,23 @@ static inline u64 arch_counter_get_cntvct(void)
 {
 	u64 cval;
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u64 cval_new, timeout = 200;
+#endif
+
 	isb();
 	asm volatile("mrs %0, cntvct_el0" : "=r" (cval));
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
+	while (cval != cval_new && timeout) {
+		cval = cval_new;
+		asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
+		timeout--;
+	}
+	BUG_ON((timeout <= 0) && (cval != cval_new));
+#endif
+
 	return cval;
 }
 
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 0aa135d..1f0238e 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -110,6 +110,10 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 {
 	u32 val;
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u32 val_new, timeout = 200;
+#endif
+
 	if (access == ARCH_TIMER_MEM_PHYS_ACCESS) {
 		struct arch_timer *timer = to_arch_timer(clk);
 		switch (reg) {
@@ -118,6 +122,17 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			val = readl_relaxed(timer->base + CNTP_TVAL);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			val_new = readl_relaxed(timer->base + CNTP_TVAL);
+			while (val != val_new && timeout) {
+				val = val_new;
+				val_new = readl_relaxed(timer->base +
+							CNTP_TVAL);
+				timeout--;
+
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	} else if (access == ARCH_TIMER_MEM_VIRT_ACCESS) {
@@ -128,10 +143,30 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			val = readl_relaxed(timer->base + CNTV_TVAL);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			val_new = readl_relaxed(timer->base + CNTV_TVAL);
+			while (val != val_new && timeout) {
+				val = val_new;
+				val_new = readl_relaxed(timer->base +
+							CNTV_TVAL);
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
+
 			break;
 		}
 	} else {
 		val = arch_timer_reg_read_cp15(access, reg);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+		val_new = arch_timer_reg_read_cp15(access, reg);
+		while (val != val_new && timeout) {
+			val = val_new;
+			val_new = arch_timer_reg_read_cp15(access, reg);
+			timeout--;
+		}
+		BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 	}
 
 	return val;
-- 
2.5.3

