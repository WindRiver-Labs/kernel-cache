From 41d31635f96694d44d8182f20da77e3275363a83 Mon Sep 17 00:00:00 2001
From: Razvan Stefanescu <razvan.stefanescu@freescale.com>
Date: Mon, 13 Jul 2015 16:15:54 +0300
Subject: [PATCH 160/214] dpaa2-evb: Add support for link state update

Use interrupts to detect link state changes and update it.

Signed-off-by: Razvan Stefanescu <razvan.stefanescu@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-dpaa2/evb/evb.c | 164 ++++++++++++++++++++++++++++++++++--
 1 file changed, 159 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/evb/evb.c b/drivers/staging/fsl-dpaa2/evb/evb.c
index 741d437..ed13d29 100644
--- a/drivers/staging/fsl-dpaa2/evb/evb.c
+++ b/drivers/staging/fsl-dpaa2/evb/evb.c
@@ -42,6 +42,9 @@
 #include "dpdmux.h"
 #include "dpdmux-cmd.h"
 
+/* IRQ index */
+#define DPDMUX_MAX_IRQ_NUM			2
+
 struct evb_port_priv {
 	struct net_device	*netdev;
 	struct list_head	list;
@@ -65,12 +68,11 @@ static int _evb_port_carrier_state_sync(struct net_device *netdev)
 {
 	struct evb_port_priv		*port_priv = netdev_priv(netdev);
 	struct dpdmux_link_state	state;
-	int			err;
+	int err;
 
-	err = dpdmux_if_get_link_state(port_priv->evb_priv->mc_io,
-				     0,
-				     port_priv->evb_priv->mux_handle,
-				     port_priv->port_index, &state);
+	err = dpdmux_if_get_link_state(port_priv->evb_priv->mc_io, 0,
+				       port_priv->evb_priv->mux_handle,
+				       port_priv->port_index, &state);
 	if (unlikely(err)) {
 		netdev_err(netdev, "dpdmux_if_get_link_state() err %d\n", err);
 		return err;
@@ -109,6 +111,149 @@ static netdev_tx_t evb_dropframe(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
+static int evb_links_state_update(struct evb_priv *priv)
+{
+	struct evb_port_priv	*port_priv;
+	struct list_head	*pos;
+	int err;
+
+	list_for_each(pos, &priv->port_list) {
+		port_priv = list_entry(pos, struct evb_port_priv, list);
+
+		err = _evb_port_carrier_state_sync(port_priv->netdev);
+		if (err)
+			netdev_err(port_priv->netdev,
+				   "_evb_port_carrier_state_sync err %d\n",
+				   err);
+	}
+
+	return 0;
+}
+
+static irqreturn_t evb_irq0_handler(int irq_num, void *arg)
+{
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t _evb_irq0_handler_thread(int irq_num, void *arg)
+{
+	struct device		*dev = (struct device *)arg;
+	struct fsl_mc_device	*evb_dev = to_fsl_mc_device(dev);
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+	struct fsl_mc_io *io = priv->mc_io;
+	uint16_t token = priv->mux_handle;
+	int irq_index = DPDMUX_IRQ_INDEX_IF;
+	uint32_t status = 0, clear = 0;
+	int err;
+
+	/* Sanity check */
+	if (WARN_ON(!evb_dev || !evb_dev->irqs || !evb_dev->irqs[irq_index]))
+		goto out;
+	if (WARN_ON(evb_dev->irqs[irq_index]->irq_number != irq_num))
+		goto out;
+
+	err = dpdmux_get_irq_status(io, 0, token, irq_index, &status);
+	if (unlikely(err)) {
+		netdev_err(netdev, "Can't get irq status (err %d)", err);
+		clear = 0xffffffff;
+		goto out;
+	}
+
+	/* FIXME clear irq status */
+
+	if (status & DPDMUX_IRQ_EVENT_LINK_CHANGED) {
+		clear |= DPDMUX_IRQ_EVENT_LINK_CHANGED;
+
+		err = evb_links_state_update(priv);
+		if (unlikely(err))
+			goto out;
+	}
+out:
+	err = dpdmux_clear_irq_status(io, 0, token, irq_index, clear);
+	if (unlikely(err))
+		netdev_err(netdev, "Can't clear irq status (err %d)", err);
+	return IRQ_HANDLED;
+}
+
+static int evb_setup_irqs(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev = &evb_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+	int err = 0;
+	struct fsl_mc_device_irq *irq;
+	const int irq_index = DPDMUX_IRQ_INDEX_IF;
+	uint32_t mask = ~0x0u;	/* FIXME: unmask handled irqs */
+
+	err = fsl_mc_allocate_irqs(evb_dev);
+	if (unlikely(err)) {
+		dev_err(dev, "MC irqs allocation failed\n");
+		return err;
+	}
+
+	if (WARN_ON(evb_dev->obj_desc.irq_count != DPDMUX_MAX_IRQ_NUM)) {
+		err = -EINVAL;
+		goto free_irq;
+	}
+
+	err = dpdmux_set_irq_enable(priv->mc_io, 0, priv->mux_handle,
+				    irq_index, 0);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_set_irq_enable err %d\n", err);
+		goto free_irq;
+	}
+
+	irq = evb_dev->irqs[irq_index];
+
+	err = devm_request_threaded_irq(dev, irq->irq_number,
+					evb_irq0_handler,
+					_evb_irq0_handler_thread,
+					IRQF_NO_SUSPEND | IRQF_ONESHOT,
+					dev_name(dev), dev);
+	if (unlikely(err)) {
+		dev_err(dev, "devm_request_threaded_irq(): %d", err);
+		goto free_irq;
+	}
+
+	err = dpdmux_set_irq_mask(priv->mc_io, 0, priv->mux_handle,
+				  irq_index, mask);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_set_irq_mask(): %d", err);
+		goto free_devm_irq;
+	}
+
+	err = dpdmux_set_irq_enable(priv->mc_io, 0, priv->mux_handle,
+				    irq_index, 1);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_set_irq_enable(): %d", err);
+		goto free_devm_irq;
+	}
+
+	return 0;
+
+free_devm_irq:
+	devm_free_irq(dev, irq->irq_number, dev);
+free_irq:
+	fsl_mc_free_irqs(evb_dev);
+	return err;
+}
+
+static void evb_teardown_irqs(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev = &evb_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+
+	dpdmux_set_irq_enable(priv->mc_io, 0, priv->mux_handle,
+			      DPDMUX_IRQ_INDEX_IF, 0);
+
+	devm_free_irq(dev,
+		      evb_dev->irqs[DPDMUX_IRQ_INDEX_IF]->irq_number,
+		      dev);
+	fsl_mc_free_irqs(evb_dev);
+}
+
 static int evb_port_add_rule(struct net_device *netdev,
 			     const unsigned char *addr, u16 vid)
 {
@@ -841,6 +986,8 @@ static int evb_remove(struct fsl_mc_device *evb_dev)
 		free_netdev(port_priv->netdev);
 	}
 
+	evb_teardown_irqs(evb_dev);
+
 	unregister_netdev(netdev);
 
 	evb_takedown(evb_dev);
@@ -973,6 +1120,13 @@ static int evb_probe(struct fsl_mc_device *evb_dev)
 			dev_warn(dev, "dev_open err %d\n", err);
 	}
 
+	/* setup irqs */
+	err = evb_setup_irqs(evb_dev);
+	if (unlikely(err)) {
+		dev_warn(dev, "evb_setup_irqs err %d\n", err);
+		goto err_takedown;
+	}
+
 	dev_info(dev, "probed evb device with %d ports\n",
 		 priv->attr.num_ifs);
 	return 0;
-- 
2.5.3

