From 2b26da326e13c5288bd573d96cdf321fa04236de Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@freescale.com>
Date: Tue, 28 Apr 2015 16:14:47 +0300
Subject: [PATCH 090/214] staging: fsl-dpaa2: evb: Added ethtool port counters

Signed-off-by: Alex Marginean <alexandru.marginean@freescale.com>
Change-Id: Iae23b0313532c71f50541400a24e9d0c0ba8c8c1
Reviewed-on: http://git.am.freescale.net:8181/35704
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Razvan Stefanescu <razvan.stefanescu@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-dpaa2/evb/evb.c | 69 +++++++++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/drivers/staging/fsl-dpaa2/evb/evb.c b/drivers/staging/fsl-dpaa2/evb/evb.c
index 373fba5..3679584 100644
--- a/drivers/staging/fsl-dpaa2/evb/evb.c
+++ b/drivers/staging/fsl-dpaa2/evb/evb.c
@@ -605,6 +605,73 @@ static const struct net_device_ops evb_port_ops = {
 	.ndo_get_stats64	= &evb_port_get_stats,
 };
 
+static struct {
+	enum dpdmux_counter_type id;
+	char name[ETH_GSTRING_LEN];
+} evb_ethtool_counters[] =  {
+	{DPDMUX_CNT_ING_FRAME,		"rx frames"},
+	{DPDMUX_CNT_ING_BYTE,		"rx bytes"},
+	{DPDMUX_CNT_ING_FLTR_FRAME,	"rx filtered frames"},
+	{DPDMUX_CNT_ING_FRAME_DISCARD,	"rx discarded frames"},
+	{DPDMUX_CNT_ING_BCAST_FRAME,	"rx b-cast frames"},
+	{DPDMUX_CNT_ING_BCAST_BYTES,	"rx b-cast bytes"},
+	{DPDMUX_CNT_ING_MCAST_FRAME,	"rx m-cast frames"},
+	{DPDMUX_CNT_ING_MCAST_BYTE,	"rx m-cast bytes"},
+	{DPDMUX_CNT_EGR_FRAME,		"tx frames"},
+	{DPDMUX_CNT_EGR_BYTE,		"tx bytes"},
+	{DPDMUX_CNT_EGR_FRAME_DISCARD,	"tx discarded frames"},
+};
+
+static int evb_ethtool_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(evb_ethtool_counters);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void evb_ethtool_get_strings(struct net_device *netdev,
+				    u32 stringset, u8 *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ARRAY_SIZE(evb_ethtool_counters); i++)
+			memcpy(data + i * ETH_GSTRING_LEN,
+			       evb_ethtool_counters[i].name, ETH_GSTRING_LEN);
+		break;
+	}
+}
+
+static void evb_ethtool_get_stats(struct net_device *netdev,
+				  struct ethtool_stats *stats,
+				  u64 *data)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	int			i;
+	int			err;
+
+	for (i = 0; i < ARRAY_SIZE(evb_ethtool_counters); i++) {
+		err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+					    port_priv->evb_priv->mux_handle,
+					    port_priv->port_index,
+					    evb_ethtool_counters[i].id,
+					    &data[i]);
+		if (err)
+			netdev_err(netdev, "dpdmux_if_get_counter[%s] err %d\n",
+				   evb_ethtool_counters[i].name, err);
+	}
+}
+
+static const struct ethtool_ops evb_port_ethtool_ops = {
+	.get_strings		= &evb_ethtool_get_strings,
+	.get_ethtool_stats	= &evb_ethtool_get_stats,
+	.get_sset_count		= &evb_ethtool_get_sset_count,
+};
+
 static int evb_open(struct net_device *netdev)
 {
 	struct evb_priv	*priv = netdev_priv(netdev);
@@ -837,6 +904,8 @@ static int evb_probe(struct fsl_mc_device *evb_dev)
 			}
 		}
 
+		port_netdev->ethtool_ops = &evb_port_ethtool_ops;
+
 		/* ports are up from init */
 		rtnl_lock();
 		err = dev_open(port_netdev);
-- 
2.5.3

