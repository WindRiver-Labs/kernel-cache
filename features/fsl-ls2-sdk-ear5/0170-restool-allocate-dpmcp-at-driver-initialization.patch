From 0684600f99c3539f50eb6222ea7b8ffb72dd812e Mon Sep 17 00:00:00 2001
From: Lijun Pan <Lijun.Pan@freescale.com>
Date: Tue, 30 Jun 2015 17:32:19 -0500
Subject: [PATCH 170/214] restool: allocate dpmcp at driver initialization

Current driver does not allocate a dpmcp while initializaing itself.
Current driver only allcoate portal at run time. In current condition,
if dpmcp is used up, restool cannot work at run time.
In order to overcome this defect, we allocate a dpmcp at driver
initialization, and keep that dpmcp until driver exit.
We use that dpmcp by default. If that dpmcp is in use, we create
another portal at run time and destroy the newly created portal after use.

Signed-off-by: Lijun Pan <Lijun.Pan@freescale.com>
Change-Id: Ief78109b2391f8b14228ba8a0af802f0ca76d343
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl-mc/bus/mc-restool.c | 143 +++++++++++++++++++++++++++-----
 1 file changed, 122 insertions(+), 21 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/mc-restool.c b/drivers/staging/fsl-mc/bus/mc-restool.c
index a2715eb..a574842 100644
--- a/drivers/staging/fsl-mc/bus/mc-restool.c
+++ b/drivers/staging/fsl-mc/bus/mc-restool.c
@@ -16,6 +16,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
+#include <linux/mutex.h>
 #include "mc-ioctl.h"
 #include "../include/mc-sys.h"
 #include "../include/mc-cmd.h"
@@ -34,51 +35,115 @@ struct fsl_mc_restool {
 	struct fsl_mc_io *tool_mc_io;
 };
 
+/**
+ * struct global_state - indicating the number of static and dynamic instance
+ * @dynamic_instance_count - number of dynamically created instances
+ * @static_instance_in_use - static instance is in use or not
+ * @mutex - mutex lock to serialze the operations
+ */
+struct global_state {
+	uint32_t dynamic_instance_count;
+	bool static_instance_in_use;
+	struct mutex mutex;
+};
+
+static struct fsl_mc_restool fsl_mc_restool = { 0 };
+static struct global_state global_state = { 0 };
+
 static int fsl_mc_restool_dev_open(struct inode *inode, struct file *filep)
 {
 	struct fsl_mc_device *root_mc_dev;
-	int error = -EINVAL;
-	struct fsl_mc_restool *fsl_mc_restool;
+	int error = 0;
+	struct fsl_mc_restool *fsl_mc_restool_new = NULL;
 
-	fsl_mc_restool = kmalloc(sizeof(struct fsl_mc_restool), GFP_KERNEL);
-	if (fsl_mc_restool == NULL)
-		goto error;
+	mutex_lock(&global_state.mutex);
 
-	if (WARN_ON(fsl_mc_bus_type.dev_root == NULL))
+	if (WARN_ON(fsl_mc_bus_type.dev_root == NULL)) {
+		error = -EINVAL;
 		goto error;
+	}
 
-	root_mc_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
-	error = fsl_mc_portal_allocate(root_mc_dev, 0,
-				       &fsl_mc_restool->tool_mc_io);
-	if (error < 0) {
-		pr_err("Not able to allocate MC portal\n");
-		goto error;
+	if (!global_state.static_instance_in_use) {
+		global_state.static_instance_in_use = true;
+		filep->private_data = &fsl_mc_restool;
+	} else {
+		fsl_mc_restool_new = kmalloc(sizeof(struct fsl_mc_restool),
+						GFP_KERNEL);
+		if (fsl_mc_restool_new == NULL) {
+			error = -ENOMEM;
+			goto error;
+		}
+		memset(fsl_mc_restool_new, 0, sizeof(*fsl_mc_restool_new));
+
+		root_mc_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
+		error = fsl_mc_portal_allocate(root_mc_dev, 0,
+				       &fsl_mc_restool_new->tool_mc_io);
+		if (error < 0) {
+			pr_err("Not able to allocate MC portal\n");
+			goto error;
+		}
+		++global_state.dynamic_instance_count;
+		filep->private_data = fsl_mc_restool_new;
 	}
 
-	filep->private_data = fsl_mc_restool;
+	mutex_unlock(&global_state.mutex);
 	return 0;
 error:
-	if (fsl_mc_restool->tool_mc_io != NULL) {
-		fsl_mc_portal_free(fsl_mc_restool->tool_mc_io);
-		fsl_mc_restool->tool_mc_io = NULL;
+	if (fsl_mc_restool_new != NULL &&
+	    fsl_mc_restool_new->tool_mc_io != NULL) {
+		fsl_mc_portal_free(fsl_mc_restool_new->tool_mc_io);
+		fsl_mc_restool_new->tool_mc_io = NULL;
 	}
-	kfree(fsl_mc_restool);
+
+	kfree(fsl_mc_restool_new);
+	mutex_unlock(&global_state.mutex);
 	return error;
 }
 
 static int fsl_mc_restool_dev_release(struct inode *inode, struct file *filep)
 {
-	struct fsl_mc_restool *fsl_mc_restool = filep->private_data;
+	struct fsl_mc_restool *fsl_mc_restool_local = filep->private_data;
 
 	if (WARN_ON(filep->private_data == NULL))
 		return -EINVAL;
 
+	mutex_lock(&global_state.mutex);
+
+	if (WARN_ON(global_state.dynamic_instance_count == 0 &&
+	    !global_state.static_instance_in_use)) {
+		mutex_unlock(&global_state.mutex);
+		return -EINVAL;
+	}
+
 	/* Globally clean up opened/untracked handles */
-	fsl_mc_portal_reset(fsl_mc_restool->tool_mc_io);
+	fsl_mc_portal_reset(fsl_mc_restool_local->tool_mc_io);
+
+	pr_debug("dynamic instance count: %d\n",
+		global_state.dynamic_instance_count);
+	pr_debug("static instance count: %d\n",
+		global_state.static_instance_in_use);
+
+	/*
+	 * must check
+	 * whether fsl_mc_restool_local is dynamic or global instance
+	 * Otherwise it will free up the reserved portal by accident
+	 * or even not free up the dynamic allocated portal
+	 * if 2 or more instances running concurrently
+	 */
+	if (fsl_mc_restool_local == &fsl_mc_restool) {
+		pr_debug("this is reserved portal");
+		pr_debug("reserved portal not in use\n");
+		global_state.static_instance_in_use = false;
+	} else {
+		pr_debug("this is dynamically allocated  portal");
+		pr_debug("free one dynamically allocated portal\n");
+		fsl_mc_portal_free(fsl_mc_restool_local->tool_mc_io);
+		kfree(filep->private_data);
+		--global_state.dynamic_instance_count;
+	}
 
-	fsl_mc_portal_free(fsl_mc_restool->tool_mc_io);
-	kfree(filep->private_data);
 	filep->private_data = NULL;
+	mutex_unlock(&global_state.mutex);
 	return 0;
 }
 
@@ -170,14 +235,34 @@ static struct miscdevice fsl_mc_restool_dev = {
 
 static int __init fsl_mc_restool_driver_init(void)
 {
+	struct fsl_mc_device *root_mc_dev;
 	int error = -EINVAL;
 	bool restool_dev_registered = false;
 
+	mutex_init(&global_state.mutex);
+
+	if (WARN_ON(fsl_mc_restool.tool_mc_io != NULL))
+		goto error;
+
+	if (WARN_ON(global_state.dynamic_instance_count != 0))
+		goto error;
+
+	if (WARN_ON(global_state.static_instance_in_use))
+		goto error;
+
 	if (fsl_mc_bus_type.dev_root == NULL) {
 		pr_err("fsl-mc bus not found, restool driver registration failed\n");
 		goto error;
 	}
 
+	root_mc_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
+	error = fsl_mc_portal_allocate(root_mc_dev, 0,
+				       &fsl_mc_restool.tool_mc_io);
+	if (error < 0) {
+		pr_err("Not able to allocate MC portal\n");
+		goto error;
+	}
+
 	error = misc_register(&fsl_mc_restool_dev);
 	if (error < 0) {
 		pr_err("misc_register() failed: %d\n", error);
@@ -191,6 +276,11 @@ error:
 	if (restool_dev_registered)
 		misc_deregister(&fsl_mc_restool_dev);
 
+	if (fsl_mc_restool.tool_mc_io != NULL) {
+		fsl_mc_portal_free(fsl_mc_restool.tool_mc_io);
+		fsl_mc_restool.tool_mc_io = NULL;
+	}
+
 	return error;
 }
 
@@ -198,7 +288,18 @@ module_init(fsl_mc_restool_driver_init);
 
 static void __exit fsl_mc_restool_driver_exit(void)
 {
+	if (WARN_ON(fsl_mc_restool.tool_mc_io == NULL))
+		return;
+
+	if (WARN_ON(global_state.dynamic_instance_count != 0))
+		return;
+
+	if (WARN_ON(global_state.static_instance_in_use))
+		return;
+
 	misc_deregister(&fsl_mc_restool_dev);
+	fsl_mc_portal_free(fsl_mc_restool.tool_mc_io);
+	fsl_mc_restool.tool_mc_io = NULL;
 	pr_info("%s driver unregistered\n", fsl_mc_restool_dev.name);
 }
 
-- 
2.5.3

