From 0b4c3d328a3178552c9559b9c3be2e07afa311d9 Mon Sep 17 00:00:00 2001
From: Tang Yuantian <Yuantian.Tang@freescale.com>
Date: Fri, 24 Apr 2015 17:44:14 +0800
Subject: [PATCH 013/214] Cherry-pick clk-qoriq driver from upstream

This patch cherry-picks the clk-qoriq driver which was
recently ported from PPC platform for reuse on ARM platforms
(and tested on LS1021A SoC) from upstream tree of the CLK
maintainer (git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux.git)

Also this patch adds the support of chassis-3.0 clock sources
in the driver.

Signed-off-by: Bhupesh Sharma <bhupesh.sharma@freescale.com>
Change-Id: I88126592da289d3b3970660c4e1b1e493f141fab
Reviewed-on: http://git.am.freescale.net:8181/35513
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Tested-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch extracted from FSL LS2085 SDK EAR5.0,
Layerscape2-SDK-SOURCE-20150828-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/clk/Kconfig     |  2 +-
 drivers/clk/clk-qoriq.c | 26 +++++++++++++++++++++++++-
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 9897f35..0f7a0a1 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -104,7 +104,7 @@ config COMMON_CLK_AXI_CLKGEN
 
 config CLK_QORIQ
 	bool "Clock driver for Freescale QorIQ platforms"
-	depends on (PPC_E500MC || ARM) && OF
+	depends on (PPC_E500MC || ARM || ARM64) && OF
 	---help---
 	  This adds the clock driver support for Freescale QorIQ platforms
 	  using common clock framework.
diff --git a/drivers/clk/clk-qoriq.c b/drivers/clk/clk-qoriq.c
index cda90a9..ebbff67 100644
--- a/drivers/clk/clk-qoriq.c
+++ b/drivers/clk/clk-qoriq.c
@@ -40,7 +40,12 @@ static int cmux_set_parent(struct clk_hw *hw, u8 idx)
 	if (clk->flags & CLKSEL_ADJUST)
 		clksel += 8;
 	clksel = (clksel & 0xf) << CLKSEL_SHIFT;
+#ifdef CONFIG_ARCH_FSL_LS2085A
+	/* FIXME: Make this better */
+	iowrite32(clksel, clk->reg);
+#else
 	iowrite32be(clksel, clk->reg);
+#endif
 
 	return 0;
 }
@@ -50,7 +55,12 @@ static u8 cmux_get_parent(struct clk_hw *hw)
 	struct cmux_clk *clk = to_cmux_clk(hw);
 	u32 clksel;
 
+#ifdef CONFIG_ARCH_FSL_LS2085A
+	/* FIXME: Make this better */
+	clksel = ioread32(clk->reg);
+#else
 	clksel = ioread32be(clk->reg);
+#endif
 	clksel = (clksel >> CLKSEL_SHIFT) & 0xf;
 	if (clk->flags & CLKSEL_ADJUST)
 		clksel -= 8;
@@ -171,8 +181,17 @@ static void __init core_pll_init(struct device_node *np)
 	}
 
 	/* get the multiple of PLL */
+#ifdef CONFIG_ARCH_FSL_LS2085A
+	/* FIXME: Make this better */
+	mult = ioread32(base);
+	/* check if this PLL is disabled */
+	if (mult & PLL_KILL) {
+		pr_debug("PLL:%s is disabled\n", np->name);
+		goto err_map;
+	}
+	mult = (mult >> 1) & 0xff;
+#else
 	mult = ioread32be(base);
-
 	/* check if this PLL is disabled */
 	if (mult & PLL_KILL) {
 		pr_debug("PLL:%s is disabled\n", np->name);
@@ -180,6 +199,8 @@ static void __init core_pll_init(struct device_node *np)
 	}
 	mult = (mult >> 1) & 0x3f;
 
+#endif
+
 	parent_name = of_clk_get_parent_name(np, 0);
 	if (!parent_name) {
 		pr_err("PLL: %s must have a parent\n", np->name);
@@ -354,9 +375,12 @@ return_clk_unregister:
 
 CLK_OF_DECLARE(qoriq_sysclk_1, "fsl,qoriq-sysclk-1.0", sysclk_init);
 CLK_OF_DECLARE(qoriq_sysclk_2, "fsl,qoriq-sysclk-2.0", sysclk_init);
+CLK_OF_DECLARE(qoriq_sysclk_3, "fsl,qoriq-sysclk-3.0", sysclk_init);
 CLK_OF_DECLARE(qoriq_core_pll_1, "fsl,qoriq-core-pll-1.0", core_pll_init);
 CLK_OF_DECLARE(qoriq_core_pll_2, "fsl,qoriq-core-pll-2.0", core_pll_init);
+CLK_OF_DECLARE(qoriq_core_pll_3, "fsl,qoriq-core-pll-3.0", core_pll_init);
 CLK_OF_DECLARE(qoriq_core_mux_1, "fsl,qoriq-core-mux-1.0", core_mux_init);
 CLK_OF_DECLARE(qoriq_core_mux_2, "fsl,qoriq-core-mux-2.0", core_mux_init);
+CLK_OF_DECLARE(qoriq_core_mux_3, "fsl,qoriq-core-mux-3.0", core_mux_init);
 CLK_OF_DECLARE(qoriq_pltfrm_pll_1, "fsl,qoriq-platform-pll-1.0", pltfrm_pll_init);
 CLK_OF_DECLARE(qoriq_pltfrm_pll_2, "fsl,qoriq-platform-pll-2.0", pltfrm_pll_init);
-- 
2.5.3

