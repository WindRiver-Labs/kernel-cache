From 580123b6f8e61bc4551603ea1e7443a1a261f5e4 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Wed, 14 Aug 2013 20:34:23 +0800
Subject: [PATCH] mac80211/wireless: make common code base for net/mac80211
 upgrade

These changes were added by 505dff737fe(GRSecurity 2.9.1 --
201207080925) via grsecurity patch. Revert those changes within
mac80211/wireless subsystem in 505dff737fe, and put them back when
the upgrade is done.

Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 net/mac80211/ieee80211_i.h         |  3 +--
 net/mac80211/iface.c               | 12 ++++++------
 net/mac80211/main.c                |  2 +-
 net/mac80211/pm.c                  |  6 +++---
 net/mac80211/rate.c                |  2 +-
 net/mac80211/rc80211_pid_debugfs.c |  2 +-
 net/mac80211/util.c                |  2 +-
 net/wireless/core.h                |  2 +-
 net/wireless/wext-core.c           | 19 ++++++++++++++++++-
 9 files changed, 33 insertions(+), 17 deletions(-)

diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index b9a1ce6..05160db 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -28,7 +28,6 @@
 #include <net/ieee80211_radiotap.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
-#include <asm/local.h>
 #include "key.h"
 #include "sta_info.h"
 
@@ -843,7 +842,7 @@ struct ieee80211_local {
 	/* also used to protect ampdu_ac_queue and amdpu_ac_stop_refcnt */
 	spinlock_t queue_stop_reason_lock;
 
-	local_t open_count;
+	int open_count;
 	int monitors, cooked_mntrs;
 	/* number of interfaces with corresponding FIF_ flags */
 	int fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll,
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 4ccd7b8..48f937e 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -222,7 +222,7 @@ static int ieee80211_do_open(struct net_device *dev, bool coming_up)
 		break;
 	}
 
-	if (local_read(&local->open_count) == 0) {
+	if (local->open_count == 0) {
 		res = drv_start(local);
 		if (res)
 			goto err_del_bss;
@@ -246,7 +246,7 @@ static int ieee80211_do_open(struct net_device *dev, bool coming_up)
 		memcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);
 
 		if (!is_valid_ether_addr(dev->dev_addr)) {
-			if (!local_read(&local->open_count))
+			if (!local->open_count)
 				drv_stop(local);
 			return -EADDRNOTAVAIL;
 		}
@@ -347,7 +347,7 @@ static int ieee80211_do_open(struct net_device *dev, bool coming_up)
 	mutex_unlock(&local->mtx);
 
 	if (coming_up)
-		local_inc(&local->open_count);
+		local->open_count++;
 
 	if (hw_reconf_flags)
 		ieee80211_hw_config(local, hw_reconf_flags);
@@ -360,7 +360,7 @@ static int ieee80211_do_open(struct net_device *dev, bool coming_up)
  err_del_interface:
 	drv_remove_interface(local, sdata);
  err_stop:
-	if (!local_read(&local->open_count))
+	if (!local->open_count)
 		drv_stop(local);
  err_del_bss:
 	sdata->bss = NULL;
@@ -491,7 +491,7 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata,
 	}
 
 	if (going_down)
-		local_dec(&local->open_count);
+		local->open_count--;
 
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_AP_VLAN:
@@ -562,7 +562,7 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata,
 
 	ieee80211_recalc_ps(local, -1);
 
-	if (local_read(&local->open_count) == 0) {
+	if (local->open_count == 0) {
 		if (local->ops->napi_poll)
 			napi_disable(&local->napi);
 		ieee80211_clear_tx_pending(local);
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index d45ebfa..1633648 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -164,7 +164,7 @@ int ieee80211_hw_config(struct ieee80211_local *local, u32 changed)
 		local->hw.conf.power_level = power;
 	}
 
-	if (changed && local_read(&local->open_count)) {
+	if (changed && local->open_count) {
 		ret = drv_config(local, changed);
 		/*
 		 * Goal:
diff --git a/net/mac80211/pm.c b/net/mac80211/pm.c
index 5c63952..ef8eba1 100644
--- a/net/mac80211/pm.c
+++ b/net/mac80211/pm.c
@@ -34,7 +34,7 @@ int __ieee80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 	struct ieee80211_sub_if_data *sdata;
 	struct sta_info *sta;
 
-	if (!local_read(&local->open_count))
+	if (!local->open_count)
 		goto suspend;
 
 	ieee80211_scan_cancel(local);
@@ -72,7 +72,7 @@ int __ieee80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 	cancel_work_sync(&local->dynamic_ps_enable_work);
 	del_timer_sync(&local->dynamic_ps_timer);
 
-	local->wowlan = wowlan && local_read(&local->open_count);
+	local->wowlan = wowlan && local->open_count;
 	if (local->wowlan) {
 		int err = drv_suspend(local, wowlan);
 		if (err < 0) {
@@ -128,7 +128,7 @@ int __ieee80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 	}
 
 	/* stop hardware - this must stop RX */
-	if (local_read(&local->open_count))
+	if (local->open_count)
 		ieee80211_stop_device(local);
 
  suspend:
diff --git a/net/mac80211/rate.c b/net/mac80211/rate.c
index bec9f17..3313c11 100644
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -494,7 +494,7 @@ int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
 
 	ASSERT_RTNL();
 
-	if (local_read(&local->open_count))
+	if (local->open_count)
 		return -EBUSY;
 
 	if (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) {
diff --git a/net/mac80211/rc80211_pid_debugfs.c b/net/mac80211/rc80211_pid_debugfs.c
index ff61928..c97a065 100644
--- a/net/mac80211/rc80211_pid_debugfs.c
+++ b/net/mac80211/rc80211_pid_debugfs.c
@@ -193,7 +193,7 @@ static ssize_t rate_control_pid_events_read(struct file *file, char __user *buf,
 
 	spin_unlock_irqrestore(&events->lock, status);
 
-	if (p > sizeof(pb) || copy_to_user(buf, pb, p))
+	if (copy_to_user(buf, pb, p))
 		return -EFAULT;
 
 	return p;
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index e23058d..73ef163 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -1204,7 +1204,7 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	}
 #endif
 	/* everything else happens only if HW was up & running */
-	if (!local_read(&local->open_count))
+	if (!local->open_count)
 		goto wake_up;
 
 	/*
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 46d01db..ce5597c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -27,7 +27,7 @@ struct cfg80211_registered_device {
 	struct mutex mtx;
 
 	/* rfkill support */
-	rfkill_ops_no_const rfkill_ops;
+	struct rfkill_ops rfkill_ops;
 	struct rfkill *rfkill;
 	struct work_struct rfkill_sync;
 
diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c
index 6185d3a..af648e0 100644
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -747,7 +747,8 @@ static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,
 		 */
 
 		/* Support for very large requests */
-		if (user_length > descr->max_tokens) {
+		if ((descr->flags & IW_DESCR_FLAG_NOMAX) &&
+		    (user_length > descr->max_tokens)) {
 			/* Allow userspace to GET more than max so
 			 * we can support any size GET requests.
 			 * There is still a limit : -ENOMEM.
@@ -786,6 +787,22 @@ static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,
 		}
 	}
 
+	if (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {
+		/*
+		 * If this is a GET, but not NOMAX, it means that the extra
+		 * data is not bounded by userspace, but by max_tokens. Thus
+		 * set the length to max_tokens. This matches the extra data
+		 * allocation.
+		 * The driver should fill it with the number of tokens it
+		 * provided, and it may check iwp->length rather than having
+		 * knowledge of max_tokens. If the driver doesn't change the
+		 * iwp->length, this ioctl just copies back max_token tokens
+		 * filled with zeroes. Hopefully the driver isn't claiming
+		 * them to be valid data.
+		 */
+		iwp->length = descr->max_tokens;
+	}
+
 	err = handler(dev, info, (union iwreq_data *) iwp, extra);
 
 	iwp->length += essid_compat;
-- 
1.8.1.2

