From d3820f4813598e1160218e3e92b720cb5fffabd3 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Thu, 15 Aug 2013 12:45:01 +0800
Subject: [PATCH 41/41] iwlwifi: avoid calling __free_pages() while holding a
 raw_spin_lock

In iwl_pcie_rx_init(), __free_pages is called when holding a
raw_spin_lock, so the following call trace is shown:

BUG: sleeping function called from invalid context at
/home/ywei/workspace/projects/0809-wifi-pt/bitbake_build/tmp/work/intel_xeon_core_haswell-wrs-linux/linux-windriver-3.4-r0/linux/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 1, pid: 1612, name: ifconfig
Pid: 1612, comm: ifconfig Not tainted 3.4.43-rt56-WR5.0.1.0_preempt-rt #2
Call Trace:
 [<ffffffff81070fbe>] __might_sleep+0xce/0x100
 [<ffffffff81824a34>] rt_spin_lock+0x24/0x50
 [<ffffffff81109fdb>] free_hot_cold_page+0xcb/0x300
 [<ffffffff8110a23d>] __free_pages+0x2d/0x40
 [<ffffffffa00c0c0e>] iwl_pcie_rxq_free_rbs+0x5e/0xb0 [iwlwifi]
 [<ffffffffa00c11f3>] iwl_pcie_rx_init+0x73/0x550 [iwlwifi]
 [<ffffffffa009b69e>] ? iwl_mvm_nic_config+0xbe/0xd0 [iwlmvm]
 [<ffffffffa00c8385>] iwl_trans_pcie_start_fw+0x145/0x770 [iwlwifi]
 [<ffffffff8104770e>] ? local_bh_enable+0x4e/0x160
 [<ffffffffa00bdca5>] ? iwl_init_notification_wait+0x85/0xc0 [iwlwifi]
 [<ffffffffa0098127>] iwl_mvm_load_ucode_wait_alive+0xb7/0x240 [iwlmvm]
 [<ffffffffa0098000>] ? 0xffffffffa0097fff
 [<ffffffffa009880a>] iwl_mvm_up+0x7a/0x2b0 [iwlmvm]
 [<ffffffff81824484>] ? rt_mutex_lock+0x24/0x60
 [<ffffffffa009a879>] iwl_mvm_mac_start+0xf9/0x120 [iwlmvm]
 [<ffffffff817bc178>] ieee80211_do_open+0x328/0xfc0
 [<ffffffff817bce81>] ieee80211_open+0x71/0x80
 [<ffffffff816655df>] __dev_open+0x9f/0x100
 [<ffffffff816658a1>] __dev_change_flags+0xa1/0x180
 [<ffffffff81665a38>] dev_change_flags+0x28/0x70
 [<ffffffff816c8013>] devinet_ioctl+0x6a3/0x7d0
 [<ffffffff816c8b75>] inet_ioctl+0x75/0x90
 [<ffffffff81649ae0>] sock_do_ioctl+0x30/0x70
 [<ffffffff81649de4>] sock_ioctl+0x84/0x2a0
 [<ffffffff81169ee9>] do_vfs_ioctl+0x99/0x620
 [<ffffffff8116a519>] sys_ioctl+0xa9/0x120
 [<ffffffff8182c5d6>] system_call_fastpath+0x1a/0x1f

Keep the pointers of pages to be freed during the raw_spin_lock is
hold, and free them when the lock is released. We use a dymamic
memory to keep the pages pointer, as there are so many pages to be
freed. A static array will cause a build warning, as it takes more
than 2KB memory space in stack.

Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/net/wireless/iwlwifi/pcie/rx.c | 58 ++++++++++++++++++++++++++++++++--
 1 file changed, 56 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/iwlwifi/pcie/rx.c b/drivers/net/wireless/iwlwifi/pcie/rx.c
index b4df06b..f0c947d 100644
--- a/drivers/net/wireless/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/rx.c
@@ -365,7 +365,6 @@ static void iwl_pcie_rxq_free_rbs(struct iwl_trans *trans)
 		dma_unmap_page(trans->dev, rxq->pool[i].page_dma,
 			       PAGE_SIZE << trans_pcie->rx_page_order,
 			       DMA_FROM_DEVICE);
-		__free_pages(rxq->pool[i].page, trans_pcie->rx_page_order);
 		rxq->pool[i].page = NULL;
 	}
 }
@@ -510,17 +509,35 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
 	struct iwl_rxq *rxq = &trans_pcie->rxq;
 	int i, err;
 	unsigned long flags;
+	/* As more than 2KB memory is used here, so use dynamic memory
+	 * rather than static memory */
+	struct page **free_pages =
+		    kmalloc((RX_QUEUE_SIZE + RX_FREE_BUFFERS) * sizeof(struct page *),
+			    GFP_KERNEL);
+
+	if (!free_pages)
+		return -ENOMEM;
+
+	memset(free_pages, 0,
+	       (RX_QUEUE_SIZE + RX_FREE_BUFFERS) * sizeof(struct page *));
 
 	if (!rxq->bd) {
 		err = iwl_pcie_rx_alloc(trans);
-		if (err)
+		if (err) {
+			kfree(free_pages);
 			return err;
+		}
 	}
 
 	raw_spin_lock_irqsave(&rxq->lock, flags);
 
 	INIT_WORK(&trans_pcie->rx_replenish, iwl_pcie_rx_replenish_work);
 
+	/* keep allocated pages, as __free_pages is not supposed to be
+	 * called when holding a spin_lock */
+	for (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++)
+		free_pages[i] = rxq->pool[i].page;
+
 	/* free all first - we might be reconfigured for a different size */
 	iwl_pcie_rxq_free_rbs(trans);
 	iwl_pcie_rx_init_rxb_lists(rxq);
@@ -535,6 +552,15 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
 	memset(rxq->rb_stts, 0, sizeof(*rxq->rb_stts));
 	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
+	/* free pages now when spin_lock is released */
+	for (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++)
+		if (free_pages[i])
+			__free_pages(free_pages[i],
+				     trans_pcie->rx_page_order);
+
+	kfree(free_pages);
+
+	/* release rx buffer before replenish */
 	iwl_pcie_rx_replenish(trans);
 
 	iwl_pcie_rx_hw_init(trans, rxq);
@@ -552,20 +578,48 @@ void iwl_pcie_rx_free(struct iwl_trans *trans)
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	struct iwl_rxq *rxq = &trans_pcie->rxq;
 	unsigned long flags;
+	int i;
+
+       /* As more than 2KB memory is used here, so use dynamic memory
+        * rather than static memory */
+        struct page **free_pages =
+                    kmalloc((RX_QUEUE_SIZE + RX_FREE_BUFFERS) * sizeof(struct page *),
+                            GFP_KERNEL);
+
+        if ( !free_pages)
+                return;
+
+        memset(free_pages, 0,
+               (RX_QUEUE_SIZE + RX_FREE_BUFFERS) * sizeof(struct page *));
 
 	/*if rxq->bd is NULL, it means that nothing has been allocated,
 	 * exit now */
 	if (!rxq->bd) {
 		IWL_DEBUG_INFO(trans, "Free NULL rx context\n");
+		kfree(free_pages);
 		return;
 	}
 
 	cancel_work_sync(&trans_pcie->rx_replenish);
 
 	raw_spin_lock_irqsave(&rxq->lock, flags);
+
+        /* keep allocated pages, as __free_pages is not supposed to be
+	 * called when holding a spin_lock */
+        for (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++)
+                free_pages[i] = rxq->pool[i].page;
+
 	iwl_pcie_rxq_free_rbs(trans);
 	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
+	/* free pages now when spin_lock is released */
+	for (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++)
+		if (free_pages[i])
+			__free_pages(free_pages[i],
+				     trans_pcie->rx_page_order);
+
+	kfree(free_pages);
+
 	dma_free_coherent(trans->dev, sizeof(__le32) * RX_QUEUE_SIZE,
 			  rxq->bd, rxq->bd_dma);
 	rxq->bd_dma = 0;
-- 
1.8.1.2

