From 44f38c85454be2185fe9df036afd9e5d5882bdc2 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Thu, 15 Aug 2013 11:46:24 +0800
Subject: [PATCH 38/41] iwlwifi: change irq_lock from spin_lock to
 raw_spin_lock

This lock is used in a hardware interrupt handler (iwl_pcie_isr_ict),
and the following call trace is shown:

BUG: sleeping function called from invalid context at
/home/ywei/workspace/projects/0809-wifi-pt/bitbake_build/tmp/work/intel_xeon_core_haswell-wrs-linux/linux-windriver-3.4-r0/linux/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Pid: 0, comm: swapper/0 Tainted: G        W
3.4.43-rt56-WR5.0.1.0_preempt-rt #2
Call Trace:
  <IRQ>   [<ffffffff81070fbe>] __might_sleep+0xce/0x100
  [<ffffffff81824a34>] rt_spin_lock+0x24/0x50
  [<ffffffffa0176c28>] iwl_pcie_isr_ict+0x38/0x4d0 [iwlwifi]
  [<ffffffff810725d5>] ? check_preempt_curr+0x75/0xa0
  [<ffffffff810c14e7>] handle_irq_event_percpu+0x97/0x370
  [<ffffffff813c13d7>] ? intel_idle+0xe7/0x140
  [<ffffffff810c1811>] handle_irq_event+0x51/0x80
  [<ffffffff810c4083>] handle_edge_irq+0x73/0x150
  [<ffffffff810046e2>] handle_irq+0x22/0x40
  [<ffffffff8182e05a>] do_IRQ+0x5a/0xd0
  [<ffffffff818251e7>] common_interrupt+0x67/0x67
  <EOI>   [<ffffffff813c13d7>] ? intel_idle+0xe7/0x140
  [<ffffffff813c13b5>] ? intel_idle+0xc5/0x140
  [<ffffffff816363b8>] cpuidle_enter+0x18/0x20
  [<ffffffff81636a1f>] cpuidle_idle_call+0xbf/0x350
  [<ffffffff8100c34f>] cpu_idle+0x7f/0xe0
  [<ffffffff817fe87c>] rest_init+0x80/0x84
  [<ffffffff81ef8b8a>] start_kernel+0x388/0x395
  [<ffffffff81ef85ff>] ? repair_env_string+0x5e/0x5e
  [<ffffffff81ef8321>] x86_64_start_reservations+0x131/0x135
  [<ffffffff81ef83fe>] x86_64_start_kernel+0xd9/0xdd

Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/net/wireless/iwlwifi/pcie/internal.h |  2 +-
 drivers/net/wireless/iwlwifi/pcie/rx.c       | 30 ++++++++++++++--------------
 drivers/net/wireless/iwlwifi/pcie/trans.c    | 22 ++++++++++----------
 drivers/net/wireless/iwlwifi/pcie/tx.c       |  8 ++++----
 4 files changed, 31 insertions(+), 31 deletions(-)

diff --git a/drivers/net/wireless/iwlwifi/pcie/internal.h b/drivers/net/wireless/iwlwifi/pcie/internal.h
index b654dcd..bcdc137 100644
--- a/drivers/net/wireless/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/iwlwifi/pcie/internal.h
@@ -278,7 +278,7 @@ struct iwl_trans_pcie {
 	bool use_ict;
 	struct isr_statistics isr_stats;
 
-	spinlock_t irq_lock;
+	raw_spinlock_t irq_lock;
 	u32 inta_mask;
 	u32 scd_base_addr;
 	struct iwl_dma_ptr scd_bc_tbls;
diff --git a/drivers/net/wireless/iwlwifi/pcie/rx.c b/drivers/net/wireless/iwlwifi/pcie/rx.c
index fd848cd..974776e 100644
--- a/drivers/net/wireless/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/rx.c
@@ -385,9 +385,9 @@ static void iwl_pcie_rx_replenish(struct iwl_trans *trans)
 
 	iwl_pcie_rxq_alloc_rbs(trans, GFP_KERNEL);
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_pcie_rxq_restock(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 }
 
 static void iwl_pcie_rx_replenish_now(struct iwl_trans *trans)
@@ -539,10 +539,10 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
 
 	iwl_pcie_rx_hw_init(trans, rxq);
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	rxq->need_update = 1;
 	iwl_pcie_rxq_inc_wr_ptr(trans, rxq);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	return 0;
 }
@@ -816,7 +816,7 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
 
 	lock_map_acquire(&trans->sync_cmd_lockdep_map);
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 
 	/* Ack/clear/reset pending uCode interrupts.
 	 * Note:  Some bits in CSR_INT are "OR" of bits in CSR_FH_INT_STATUS,
@@ -841,7 +841,7 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
 	/* saved interrupt in inta variable now we can reset trans_pcie->inta */
 	trans_pcie->inta = 0;
 
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	/* Now service all interrupt bits discovered above. */
 	if (inta & CSR_INT_BIT_HW_ERR) {
@@ -1083,7 +1083,7 @@ void iwl_pcie_reset_ict(struct iwl_trans *trans)
 	if (!trans_pcie->ict_tbl)
 		return;
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_disable_interrupts(trans);
 
 	memset(trans_pcie->ict_tbl, 0, ICT_SIZE);
@@ -1100,7 +1100,7 @@ void iwl_pcie_reset_ict(struct iwl_trans *trans)
 	trans_pcie->ict_index = 0;
 	iwl_write32(trans, CSR_INT, trans_pcie->inta_mask);
 	iwl_enable_interrupts(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 }
 
 /* Device is going down disable ict interrupt usage */
@@ -1109,9 +1109,9 @@ void iwl_pcie_disable_ict(struct iwl_trans *trans)
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	unsigned long flags;
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	trans_pcie->use_ict = false;
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 }
 
 /* legacy (non-ICT) ISR. Assumes that trans_pcie->irq_lock is held */
@@ -1205,14 +1205,14 @@ irqreturn_t iwl_pcie_isr_ict(int irq, void *data)
 
 	trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 
 	/* dram interrupt table not set yet,
 	 * use legacy interrupt.
 	 */
 	if (unlikely(!trans_pcie->use_ict)) {
 		irqreturn_t ret = iwl_pcie_isr(irq, data);
-		spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+		raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 		return ret;
 	}
 
@@ -1278,7 +1278,7 @@ irqreturn_t iwl_pcie_isr_ict(int irq, void *data)
 
 	/* iwl_pcie_tasklet() will service interrupts and re-enable them */
 	if (likely(inta)) {
-		spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+		raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 		return IRQ_WAKE_THREAD;
 	} else if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status) &&
 		 !trans_pcie->inta) {
@@ -1289,7 +1289,7 @@ irqreturn_t iwl_pcie_isr_ict(int irq, void *data)
 		iwl_enable_interrupts(trans);
 	}
 
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 	return IRQ_HANDLED;
 
  none:
@@ -1300,6 +1300,6 @@ irqreturn_t iwl_pcie_isr_ict(int irq, void *data)
 	    !trans_pcie->inta)
 		iwl_enable_interrupts(trans);
 
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 	return IRQ_NONE;
 }
diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c
index ec1bd5f..a795221 100644
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@ -273,13 +273,13 @@ static int iwl_pcie_nic_init(struct iwl_trans *trans)
 	unsigned long flags;
 
 	/* nic_init */
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_pcie_apm_init(trans);
 
 	/* Set interrupt coalescing calibration timer to default (512 usecs) */
 	iwl_write8(trans, CSR_INT_COALESCING, IWL_HOST_INT_CALIB_TIMEOUT_DEF);
 
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	iwl_pcie_set_pwr(trans, false);
 
@@ -527,9 +527,9 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
 	unsigned long flags;
 
 	/* tell the device to stop sending interrupts */
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_disable_interrupts(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	/* device going down, Stop using ICT table */
 	iwl_pcie_disable_ict(trans);
@@ -561,9 +561,9 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
 	/* Upon stop, the APM issues an interrupt if HW RF kill is set.
 	 * Clean again the interrupt here
 	 */
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_disable_interrupts(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	iwl_enable_rfkill_int(trans);
 
@@ -692,15 +692,15 @@ static void iwl_trans_pcie_stop_hw(struct iwl_trans *trans,
 	bool hw_rfkill;
 	unsigned long flags;
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_disable_interrupts(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	iwl_pcie_apm_stop(trans);
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 	iwl_disable_interrupts(trans);
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	iwl_pcie_disable_ict(trans);
 
@@ -1493,7 +1493,7 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 	trans->cfg = cfg;
 	trans_lockdep_init(trans);
 	trans_pcie->trans = trans;
-	spin_lock_init(&trans_pcie->irq_lock);
+	raw_spin_lock_init(&trans_pcie->irq_lock);
 	spin_lock_init(&trans_pcie->reg_lock);
 	init_waitqueue_head(&trans_pcie->ucode_write_waitq);
 
diff --git a/drivers/net/wireless/iwlwifi/pcie/tx.c b/drivers/net/wireless/iwlwifi/pcie/tx.c
index c47c921..9a698a0 100644
--- a/drivers/net/wireless/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c
@@ -733,7 +733,7 @@ int iwl_pcie_tx_stop(struct iwl_trans *trans)
 	unsigned long flags;
 
 	/* Turn off all Tx DMA fifos */
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 
 	iwl_pcie_txq_set_sched(trans, 0);
 
@@ -750,7 +750,7 @@ int iwl_pcie_tx_stop(struct iwl_trans *trans)
 				iwl_read_direct32(trans,
 						  FH_TSSR_TX_STATUS_REG));
 	}
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	if (!trans_pcie->txq) {
 		IWL_WARN(trans,
@@ -868,7 +868,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
 		alloc = true;
 	}
 
-	spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+	raw_spin_lock_irqsave(&trans_pcie->irq_lock, flags);
 
 	/* Turn off all Tx DMA fifos */
 	iwl_write_prph(trans, SCD_TXFACT, 0);
@@ -877,7 +877,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
 	iwl_write_direct32(trans, FH_KW_MEM_ADDR_REG,
 			   trans_pcie->kw.dma >> 4);
 
-	spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+	raw_spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
 
 	/* Alloc and init all Tx queues, including the command queue (#4/#9) */
 	for (txq_id = 0; txq_id < trans->cfg->base_params->num_of_queues;
-- 
1.8.1.2

