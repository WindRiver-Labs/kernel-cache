From f304f49045ae11f5ab292a325bf2b66abd661912 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Thu, 15 Aug 2013 12:33:53 +0800
Subject: [PATCH 40/41] iwlwifi: change rxq lock from spin_lock to
 raw_spin_lock

rxq lock is called in iwl_pcie_rxq_restock whiling holding the irq_lock.
Since irq_lock is a raw_spin_lock, it will cause the following call
trace:

BUG: sleeping function called from invalid context at
/home/ywei/workspace/projects/0809-wifi-pt/bitbake_build/tmp/work/intel_xeon_core_haswell-wrs-linux/linux-windriver-3.4-r0/linux/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 1, pid: 1020, name: modprobe
Pid: 1020, comm: modprobe Not tainted 3.4.43-rt56-WR5.0.1.0_preempt-rt #2
Call Trace: 000000009f7da000 - 000000009f7db000 (ACPI data)
 [<ffffffff81070fbe>] __might_sleep+0xce/0x1000 (usable)
 [<ffffffff81824a34>] rt_spin_lock+0x24/0x50000 (ACPI data)
 [<ffffffffa00c1f94>] iwl_pcie_rxq_restock+0x34/0x180 [iwlwifi]
 [<ffffffffa00c2120>] iwl_pcie_rx_replenish+0x40/0x60 [iwlwifi]
 [<ffffffffa00c22e3>] iwl_pcie_rx_init+0x143/0x570 [iwlwifi]
 [<ffffffffa006b600>] ? iwl_mvm_nic_config+0x20/0xd0 [iwlmvm]
 [<ffffffffa00c93d5>] iwl_trans_pcie_start_fw+0x145/0x770 [iwlwifi]
 [<ffffffff8104770e>] ? local_bh_enable+0x4e/0x160
 [<ffffffffa00beca5>] ? iwl_init_notification_wait+0x85/0xc0 [iwlwifi]
 [<ffffffffa0068127>] iwl_mvm_load_ucode_wait_alive+0xb7/0x240 [iwlmvm]
 [<ffffffffa0068000>] ? 0xffffffffa0067fff
 [<ffffffffa0068477>] iwl_run_init_mvm_ucode+0x87/0x3a0 [iwlmvm]
 [<ffffffffa0068390>] ? iwl_send_phy_cfg_cmd+0x80/0x80 [iwlmvm]
 [<ffffffffa006bdfc>] iwl_op_mode_mvm_start+0x2fc/0x460 [iwlmvm]
 [<ffffffffa00bd4ec>] iwl_opmode_register+0xcc/0xf0 [iwlwifi]
 [<ffffffffa0022000>] ? 0xffffffffa0021fff
 [<ffffffffa0022037>] iwl_mvm_init+0x37/0x59 [iwlmvm]
 [<ffffffff810002b2>] do_one_initcall+0x122/0x170
 [<ffffffff810a2ab4>] sys_init_module+0xee4/0x1e90
 [<ffffffff8182c5d6>] system_call_fastpath+0x1a/0x1f

Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/net/wireless/iwlwifi/pcie/internal.h |  2 +-
 drivers/net/wireless/iwlwifi/pcie/rx.c       | 46 ++++++++++++++--------------
 2 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/drivers/net/wireless/iwlwifi/pcie/internal.h b/drivers/net/wireless/iwlwifi/pcie/internal.h
index 710cc51..db51983 100644
--- a/drivers/net/wireless/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/iwlwifi/pcie/internal.h
@@ -105,7 +105,7 @@ struct iwl_rxq {
 	int need_update;
 	struct iwl_rb_status *rb_stts;
 	dma_addr_t rb_stts_dma;
-	spinlock_t lock;
+	raw_spinlock_t lock;
 };
 
 struct iwl_dma_ptr {
diff --git a/drivers/net/wireless/iwlwifi/pcie/rx.c b/drivers/net/wireless/iwlwifi/pcie/rx.c
index 974776e..b4df06b 100644
--- a/drivers/net/wireless/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/rx.c
@@ -150,7 +150,7 @@ static void iwl_pcie_rxq_inc_wr_ptr(struct iwl_trans *trans,
 	unsigned long flags;
 	u32 reg;
 
-	spin_lock_irqsave(&rxq->lock, flags);
+	raw_spin_lock_irqsave(&rxq->lock, flags);
 
 	if (rxq->need_update == 0)
 		goto exit_unlock;
@@ -192,7 +192,7 @@ static void iwl_pcie_rxq_inc_wr_ptr(struct iwl_trans *trans,
 	rxq->need_update = 0;
 
  exit_unlock:
-	spin_unlock_irqrestore(&rxq->lock, flags);
+	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 }
 
 /*
@@ -224,7 +224,7 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
 	if (!test_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status))
 		return;
 
-	spin_lock_irqsave(&rxq->lock, flags);
+	raw_spin_lock_irqsave(&rxq->lock, flags);
 	while ((iwl_rxq_space(rxq) > 0) && (rxq->free_count)) {
 		/* The overwritten rxb must be a used one */
 		rxb = rxq->queue[rxq->write];
@@ -241,7 +241,7 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
 		rxq->write = (rxq->write + 1) & RX_QUEUE_MASK;
 		rxq->free_count--;
 	}
-	spin_unlock_irqrestore(&rxq->lock, flags);
+	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 	/* If the pre-allocated buffer pool is dropping low, schedule to
 	 * refill it */
 	if (rxq->free_count <= RX_LOW_WATERMARK)
@@ -250,9 +250,9 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
 	/* If we've added more space for the firmware to place data, tell it.
 	 * Increment device's write pointer in multiples of 8. */
 	if (rxq->write_actual != (rxq->write & ~0x7)) {
-		spin_lock_irqsave(&rxq->lock, flags);
+		raw_spin_lock_irqsave(&rxq->lock, flags);
 		rxq->need_update = 1;
-		spin_unlock_irqrestore(&rxq->lock, flags);
+		raw_spin_unlock_irqrestore(&rxq->lock, flags);
 		iwl_pcie_rxq_inc_wr_ptr(trans, rxq);
 	}
 }
@@ -276,12 +276,12 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
 	gfp_t gfp_mask = priority;
 
 	while (1) {
-		spin_lock_irqsave(&rxq->lock, flags);
+		raw_spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
-			spin_unlock_irqrestore(&rxq->lock, flags);
+			raw_spin_unlock_irqrestore(&rxq->lock, flags);
 			return;
 		}
-		spin_unlock_irqrestore(&rxq->lock, flags);
+		raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
 		if (rxq->free_count > RX_LOW_WATERMARK)
 			gfp_mask |= __GFP_NOWARN;
@@ -310,17 +310,17 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
 			return;
 		}
 
-		spin_lock_irqsave(&rxq->lock, flags);
+		raw_spin_lock_irqsave(&rxq->lock, flags);
 
 		if (list_empty(&rxq->rx_used)) {
-			spin_unlock_irqrestore(&rxq->lock, flags);
+			raw_spin_unlock_irqrestore(&rxq->lock, flags);
 			__free_pages(page, trans_pcie->rx_page_order);
 			return;
 		}
 		rxb = list_first_entry(&rxq->rx_used, struct iwl_rx_mem_buffer,
 				       list);
 		list_del(&rxb->list);
-		spin_unlock_irqrestore(&rxq->lock, flags);
+		raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
 		BUG_ON(rxb->page);
 		rxb->page = page;
@@ -331,9 +331,9 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
 				     DMA_FROM_DEVICE);
 		if (dma_mapping_error(trans->dev, rxb->page_dma)) {
 			rxb->page = NULL;
-			spin_lock_irqsave(&rxq->lock, flags);
+			raw_spin_lock_irqsave(&rxq->lock, flags);
 			list_add(&rxb->list, &rxq->rx_used);
-			spin_unlock_irqrestore(&rxq->lock, flags);
+			raw_spin_unlock_irqrestore(&rxq->lock, flags);
 			__free_pages(page, trans_pcie->rx_page_order);
 			return;
 		}
@@ -342,12 +342,12 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
 		/* and also 256 byte aligned! */
 		BUG_ON(rxb->page_dma & DMA_BIT_MASK(8));
 
-		spin_lock_irqsave(&rxq->lock, flags);
+		raw_spin_lock_irqsave(&rxq->lock, flags);
 
 		list_add_tail(&rxb->list, &rxq->rx_free);
 		rxq->free_count++;
 
-		spin_unlock_irqrestore(&rxq->lock, flags);
+		raw_spin_unlock_irqrestore(&rxq->lock, flags);
 	}
 }
 
@@ -413,7 +413,7 @@ static int iwl_pcie_rx_alloc(struct iwl_trans *trans)
 
 	memset(&trans_pcie->rxq, 0, sizeof(trans_pcie->rxq));
 
-	spin_lock_init(&rxq->lock);
+	raw_spin_lock_init(&rxq->lock);
 
 	if (WARN_ON(rxq->bd || rxq->rb_stts))
 		return -EINVAL;
@@ -517,7 +517,7 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
 			return err;
 	}
 
-	spin_lock_irqsave(&rxq->lock, flags);
+	raw_spin_lock_irqsave(&rxq->lock, flags);
 
 	INIT_WORK(&trans_pcie->rx_replenish, iwl_pcie_rx_replenish_work);
 
@@ -533,7 +533,7 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
 	rxq->read = rxq->write = 0;
 	rxq->write_actual = 0;
 	memset(rxq->rb_stts, 0, sizeof(*rxq->rb_stts));
-	spin_unlock_irqrestore(&rxq->lock, flags);
+	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
 	iwl_pcie_rx_replenish(trans);
 
@@ -562,9 +562,9 @@ void iwl_pcie_rx_free(struct iwl_trans *trans)
 
 	cancel_work_sync(&trans_pcie->rx_replenish);
 
-	spin_lock_irqsave(&rxq->lock, flags);
+	raw_spin_lock_irqsave(&rxq->lock, flags);
 	iwl_pcie_rxq_free_rbs(trans);
-	spin_unlock_irqrestore(&rxq->lock, flags);
+	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 
 	dma_free_coherent(trans->dev, sizeof(__le32) * RX_QUEUE_SIZE,
 			  rxq->bd, rxq->bd_dma);
@@ -689,7 +689,7 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
 	/* Reuse the page if possible. For notification packets and
 	 * SKBs that fail to Rx correctly, add them back into the
 	 * rx_free list for reuse later. */
-	spin_lock_irqsave(&rxq->lock, flags);
+	raw_spin_lock_irqsave(&rxq->lock, flags);
 	if (rxb->page != NULL) {
 		rxb->page_dma =
 			dma_map_page(trans->dev, rxb->page, 0,
@@ -710,7 +710,7 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
 		}
 	} else
 		list_add_tail(&rxb->list, &rxq->rx_used);
-	spin_unlock_irqrestore(&rxq->lock, flags);
+	raw_spin_unlock_irqrestore(&rxq->lock, flags);
 }
 
 /*
-- 
1.8.1.2

