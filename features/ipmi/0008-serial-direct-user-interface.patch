From 16d6fdacf99c912ccefa3d114982678da70f9a0f Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Thu, 28 Aug 2008 08:25:41 -0400
Subject: [PATCH] serial direct user interface

Add an upper level interface so that an in-kernel use can direclty
grab a serial port for its own use.  This is the interface that the
IPMI serial driver and kgdb can share.

FIXME - I don't really like the way the mutual exclusion is done
between the "normal" and "direct" users, but I can't think of a better
way to do it.

Signed-off-by: Corey Minyard <minyard@acm.org>
Integrated-by: Jonathan Fournier <jonathan.fournier@windriver.com>
---
 Documentation/serial/direct  |  156 +++++++++++++++++++++++++++
 drivers/serial/serial_core.c |  238 ++++++++++++++++++++++++++++++++++++++----
 include/linux/serial_core.h  |   76 +++++++++++++-
 3 files changed, 447 insertions(+), 23 deletions(-)
 create mode 100644 Documentation/serial/direct

diff --git a/Documentation/serial/direct b/Documentation/serial/direct
new file mode 100644
index 0000000..f03a1ad
--- /dev/null
+++ b/Documentation/serial/direct
@@ -0,0 +1,156 @@
+                    The direct serial interface
+		    ---------------------------
+
+Sometimes something in the kernel needs to use a serial port.  Maybe a
+device driver talks over a UART to its device.  Maybe a kernel
+debugger needs to run over a UART.  Maybe there is some kernel-level
+protocol that runs over a serial port.
+
+These sorts of things should normally use the tty line discipline for
+this, like ppp does.  This has several advantages: the driver does not
+need to be modified to support polling, the configuration of the
+serial port can be done by a user process, it can run over a pty as
+well as a UART (good for testing) and it's just the right thing to do
+in general.
+
+However, something may need to run when the system is not completely
+operational.  A kernel debugger, for instance, has to run when the
+kernel won't schedule.  Maybe a device needs to be accessed before the
+system is completely up.  Maybe the device needs something done to it
+when a panic occurs.  The direct interface exists for these needs.
+
+
+Driver Concerns
+---------------
+
+The low-level serial driver must support the poll functions to be able
+to be used as a direct interface and must register itself as a polled
+device.  If you don't need polling, well, you should be using the line
+discipline.  Beyond that, there are no special concerns for the driver.
+
+
+Using The Direct API
+--------------------
+
+The serial direct API uses as much of the existing interface to a UART
+as possible.  It uses the uart_port structure as the main interface
+between the user and the driver.  The user provides a struct
+uart_direct to the serial core to transfer information from the driver
+to the user.
+
+The user must claim the port with uart_get_direct_port().  It should
+do the following after the port is allocated:
+  1) Save port->info (to be restored when done)
+  2) Set port->info to a new info structure.
+  3) Set port->info->xmit.buf to a byte array of size UART_XMIT_SIZE.
+  4) Call uart_circ_clear(&port->info->xmit)
+  5) Set port->info->flags to UIF_BOOT_ALLOCATED
+  6) Set port->info->direct to the uart_direct structure for the user.
+  7) Initialize port->info->tlet to a tasklet function that will be
+     called when there is transmit buffer space ready.
+  8) Set port->info->direct->direct_data to whatever you need to
+     find the port in the direct callbacks.
+  9) Set port->info->direct->handle_char to an input character handler
+     routine.  See below for details.
+ 10) Set port->info->direct->push to a routine to process input
+     characters.
+ 11) Set the other routines in the direct structure as needed.
+ 12) Call port->startup() to enable operation on the port and
+     port->set_termios() to do any configuration required on the port.
+
+When the user is done with the port, they should call port->shutdown()
+to disable the port, restore the value of port->info and then call
+uart_put_direct_port() to free the port.
+
+The uart_direct_write() function should be use write data to the UART.
+Data comes from the handle_char and push funcions in the uart_direct.
+Note that if the write buffer fills up, you can use the tasklet to
+tell you when data has been freed up in the write buffer.
+
+
+Polling the Interface
+---------------------
+
+Polling works much like the normal interface, except that you must
+call the port->poll() routine periodically and tell it what you want
+to poll (read, write, and/or modem control).  Also, the tasklets will
+not work, so any changes to CTS, DCD, or a break should be set as
+variables and actually processed once the port->poll() call returns.
+For transmit, the circular buffer status should be polled, too.
+This might look like
+
+	struct circ_buf *circ = uart_get_circ_buf(port);
+	port->ops->poll(port, UART_POLL_FLAGS_TX | UART_POLL_FLAGS_RX
+			| UART_POLL_FLAGS_MCTRL);
+	if (dcd_set) {
+		dcd_set = 0;
+		dcd_changed(...);
+	}
+	if (cts_set) {
+		cts_set = 0;
+		cts_changed(...);
+	}
+	if (uart_circ_chars_free(circ) > 0)
+		tx_ready(...);
+
+Polling is generally done when the entire system is single-threaded
+(like at panic time or when a debugger has shut down everything else),
+so locking is not that critical.
+
+
+The Direct API
+--------------
+
+The uart_direct structure has the following functions:
+  handle_break(port)
+	Called when a break comes in on the port.
+
+  handle_dcd_change(port, value)
+	Called when the DCD line changes on the port.  The status is
+	true if DCD is asserted, false if not.
+
+  handle_cts_change(port, value)
+	Called when the CTS line changes on the port.  The status is
+	true if CTS is asserted, false if not.
+
+  handle_char(port, status, overrun, ch, flag)
+	Handle a new input character.  status is a set of bits that
+	report errors.  If the bit specific by overrun (status & overrun != 0)
+	then an overrun has occured.  ch is the character.  flag reports
+	various conditions, like TTY_BREAK, TTY_PARITY, or TTY_FRAME for
+	a break, parity error, or framing error.  It is TTY_NORMAL for
+	normal characters without error.
+
+	Note that you should only queue the data in the above routine,
+	you should *NOT* process them because the port lock is held for
+	the port.  For breaks, DCD changes, and CTS
+	changes you should start a taskelet (or set a variable if
+	polling).  For characters, you should process them in the push
+	routine.
+
+  push(port)
+	Called when receipt of characters is complete, the user should
+	process incoming characters here (or schedule them to be
+	processed).
+
+The following functions are provided for the user:
+
+  struct uart_port *uart_get_direct_port(name, line, force)
+	Attempt to find a port with the given name and line.  The name
+	is something like "ttyS", the line is the line number of the
+	port.  If "force" is true, this call doesn't do any locking
+	and it doesn't care if the port is already in use.  Otherwise,
+	if the port is in use the call fails.  NULL is returned on a
+	failure, otherwise the uart port is returned.
+
+  uart_put_direct_port(port, force)
+	Free a port claimed with uart_get_direct_port.  If you
+	specified force when claiming the port, you should specify
+	force when returning it.
+
+  int uart_direct_write(port, buf, count)
+	Write count bytes from buf to the port's circular buffer.
+	This returns the number of bytes actually written. If the
+	number of bytes is larger than the circular buffer free space,
+	this will only write the number of bytes it can and return
+	immediately.
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 91f6c4f..450beff 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -492,6 +492,27 @@ static void uart_flush_chars(struct tty_struct *tty)
 	uart_start(tty);
 }
 
+static int uart_circ_write(struct circ_buf *circ, const unsigned char *buf,
+			   int count)
+{
+	int c, ret = 0;
+
+	while (1) {
+		c = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);
+		if (count < c)
+			c = count;
+		if (c <= 0)
+			break;
+		memcpy(circ->buf + circ->head, buf, c);
+		circ->head = (circ->head + c) & (UART_XMIT_SIZE - 1);
+		buf += c;
+		count -= c;
+		ret += c;
+	}
+
+	return ret;
+}
+
 static int
 uart_write(struct tty_struct *tty, const unsigned char *buf, int count)
 {
@@ -499,7 +520,7 @@ uart_write(struct tty_struct *tty, const unsigned char *buf, int count)
 	struct uart_port *port;
 	struct circ_buf *circ;
 	unsigned long flags;
-	int c, ret = 0;
+	int ret;
 
 	/*
 	 * This means you called this function _after_ the port was
@@ -517,18 +538,7 @@ uart_write(struct tty_struct *tty, const unsigned char *buf, int count)
 		return 0;
 
 	spin_lock_irqsave(&port->lock, flags);
-	while (1) {
-		c = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);
-		if (count < c)
-			c = count;
-		if (c <= 0)
-			break;
-		memcpy(circ->buf + circ->head, buf, c);
-		circ->head = (circ->head + c) & (UART_XMIT_SIZE - 1);
-		buf += c;
-		count -= c;
-		ret += c;
-	}
+	ret = uart_circ_write(circ, buf, count);
 	spin_unlock_irqrestore(&port->lock, flags);
 
 	uart_start(tty);
@@ -1340,6 +1350,9 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 	 * Wake up anyone trying to open this port.
 	 */
 	state->info->flags &= ~UIF_NORMAL_ACTIVE;
+	spin_lock_irq(&state->port->lock);
+	port->flags &= ~UPF_INUSE_NORMAL;
+	spin_unlock_irq(&state->port->lock);
 	wake_up_interruptible(&state->info->port.open_wait);
 
  done:
@@ -1477,6 +1490,7 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 	struct uart_info *info = state->info;
 	struct uart_port *port = state->port;
 	unsigned int mctrl;
+	int ret = 0;
 
 	info->port.blocked_open++;
 	state->count--;
@@ -1536,6 +1550,22 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 
 		if (signal_pending(current))
 			break;
+
+		/*
+		 * The UPF_INUSE_NORMAL flag may have been cleared
+		 * while we were waiting on the port.  Make sure the
+		 * that the port wasn't grabbed by a direct user and
+		 * that the UPF_INUSE_NORMAL flags is set if we are
+		 * trying to grab the port now.
+		 */
+		spin_lock_irq(&state->port->lock);
+		if (port->flags & UPF_INUSE_DIRECT) {
+			spin_unlock_irq(&state->port->lock);
+			ret = -EAGAIN;
+			break;
+		}
+		port->flags |= UPF_INUSE_NORMAL;
+		spin_unlock_irq(&state->port->lock);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&info->port.open_wait, &wait);
@@ -1543,13 +1573,19 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 	state->count++;
 	info->port.blocked_open--;
 
-	if (signal_pending(current))
-		return -ERESTARTSYS;
-
-	if (!info->port.tty || tty_hung_up_p(filp))
-		return -EAGAIN;
+	if (!ret) {
+		if (signal_pending(current))
+			ret = -ERESTARTSYS;
+		else if (!info->tty || tty_hung_up_p(filp))
+			ret = -EAGAIN;
+		if (ret) {
+			spin_lock_irq(&state->port->lock);
+			port->flags &= ~UPF_INUSE_NORMAL;
+			spin_unlock_irq(&state->port->lock);
+		}
+	}
 
-	return 0;
+	return ret;
 }
 
 static struct uart_state *uart_get(struct uart_driver *drv, int line)
@@ -1569,6 +1605,15 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 		goto err_unlock;
 	}
 
+	spin_lock_irq(&state->port->lock);
+	if (state->port->flags & UPF_INUSE_DIRECT) {
+		spin_unlock_irq(&state->port->lock);
+		ret = -EAGAIN;
+		goto err_unlock;
+	}
+	state->port->flags |= UPF_INUSE_NORMAL;
+	spin_unlock_irq(&state->port->lock);
+
 	/* BKL: RACE HERE - LEAK */
 	/* We should move this into the uart_state structure and kill off
 	   this whole complexity */
@@ -1586,7 +1631,7 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 					      GFP_KERNEL);
 			if (!state->info) {
 				ret = -ENOMEM;
-				goto err_unlock;
+				goto err_unlock_release;
 			}
 
 			init_waitqueue_head(&state->info->port.open_wait);
@@ -1609,6 +1654,10 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 
 	return state;
 
+ err_unlock_release:
+	spin_lock_irq(&state->port->lock);
+	state->port->flags &= ~UPF_INUSE_NORMAL;
+	spin_unlock_irq(&state->port->lock);
  err_unlock:
 	state->count--;
 	mutex_unlock(&state->mutex);
@@ -1693,6 +1742,16 @@ static int uart_open(struct tty_struct *tty, struct file *filp)
 	 */
 	if (retval == 0)
 		retval = uart_block_til_ready(filp, state);
+
+	spin_lock_irq(&state->port->lock);
+	if (retval && (state->port->flags & UPF_INUSE_NORMAL))
+		/*
+		 * The block failed, make sure that the inuse flag is
+		 * cleared.
+		 */
+		state->port->flags &= ~UPF_INUSE_NORMAL;
+	spin_unlock_irq(&state->port->lock);
+
 	mutex_unlock(&state->mutex);
 
 	/*
@@ -2521,6 +2580,138 @@ static const struct tty_operations uart_ops = {
 #endif
 };
 
+/*
+ * Holds a list of poll-capable uart drivers, so that polled driver
+ * users can look them up.
+ */
+static LIST_HEAD(polled_list);
+static DEFINE_MUTEX(polled_list_lock);
+
+#define PORT_INUSE (UPF_INUSE_NORMAL | UPF_INUSE_DIRECT)
+
+/**
+ *	uart_get_direct_port - Directly get a port for use
+ *	@name: The name to search for
+ *	@line: The line number to reserve
+ *      @force: If true, get the port even if it is in use already.
+ *
+ *	Find and reserve (if found) a serial port.  This is so things
+ *	like device drivers and debuggers can directly reserve a
+ *	serial port.  The force options is the serial port can be
+ *	taken over even while in use.  If the force option is set, it
+ *	is assumed that the system is in a stopped state and nothing
+ *	else will be touching the port until the debugger returns it.
+ */
+struct uart_port *uart_get_direct_port(char *name, int line, int force)
+{
+	struct uart_driver *drv;
+	struct uart_port *port = NULL;
+	unsigned long flags = 0;
+
+	if (!force)
+		mutex_lock(&polled_list_lock);
+	list_for_each_entry(drv, &polled_list, polled_link) {
+		if (strcmp(drv->dev_name, name) == 0) {
+			if (line < drv->nr_pollable
+						&& drv->pollable_ports[line])
+				port = drv->pollable_ports[line];
+			else
+				break;
+			if (!try_module_get(drv->owner)) {
+				port = NULL;
+				break;
+			}
+			if (!force)
+				spin_lock_irqsave(&port->lock, flags);
+			if (!force && port->flags & PORT_INUSE) {
+				spin_unlock_irqrestore(&port->lock, flags);
+				module_put(drv->owner);
+				port = NULL;
+				break;
+			}
+			port->flags |= UPF_INUSE_DIRECT;
+			if (!force)
+				spin_unlock_irqrestore(&port->lock, flags);
+			break;
+		}
+	}
+	if (!force)
+		mutex_unlock(&polled_list_lock);
+
+	return port;
+}
+EXPORT_SYMBOL(uart_get_direct_port);
+
+/**
+ *	uart_put_direct_port - Release a port reserved for direct use.
+ *	@port: The port to release
+ *      @force: If true, free the port even if it is in use already.
+ *
+ *	Free a port that was previously returned by uart_get_direct_port.
+ *	If you specified force in the get, you should do so in the put.
+ */
+int uart_put_direct_port(struct uart_port *port, int force)
+{
+	struct uart_driver *drv;
+	unsigned long flags = 0;
+	int i;
+	int retval = -EINVAL;
+
+	if (!force)
+		mutex_lock(&polled_list_lock);
+	list_for_each_entry(drv, &polled_list, polled_link) {
+		for (i = 0; i < drv->nr_pollable; i++) {
+			if (drv->pollable_ports[i] == port) {
+				if (!force)
+					spin_lock_irqsave(&port->lock, flags);
+				port->flags &= ~UPF_INUSE_DIRECT;
+				if (!force)
+					spin_unlock_irqrestore(&port->lock,
+							       flags);
+				module_put(drv->owner);
+				retval = 0;
+				goto out_unlock;
+			}
+		}
+	}
+ out_unlock:
+	if (!force)
+		mutex_unlock(&polled_list_lock);
+
+	return retval;
+}
+EXPORT_SYMBOL(uart_put_direct_port);
+
+/**
+ *	uart_direct_write - Write data as a direct serial user
+ *	@port: The port to write on
+ *	@buf: The data to write
+ *	@count: The number of bytes to write.
+ *
+ *	Write bytes to a serial port that is reserved with the
+ *	uart_get_direct_port() function.  This is non-blocking and
+ *	will return the number of bytes actually written.
+ */
+int
+uart_direct_write(struct uart_port *port, const unsigned char *buf, int count,
+		  int lock)
+{
+	struct circ_buf *circ;
+	unsigned long flags = 0; /* Keep us warning-free. */
+	int ret;
+
+	circ = &port->info->xmit;
+	if (lock)
+		spin_lock_irqsave(&port->lock, flags);
+	ret = uart_circ_write(circ, buf, count);
+	if (ret > 0)
+		port->ops->start_tx(port);
+	if (lock)
+		spin_unlock_irqrestore(&port->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(uart_direct_write);
+
 /**
  *	uart_register_polled - register a driver to be used as a polled device
  *	@drv: low level driver structure
@@ -2531,6 +2722,10 @@ static const struct tty_operations uart_ops = {
  */
 void uart_register_polled(struct uart_driver *drv)
 {
+	mutex_lock(&polled_list_lock);
+	list_add_tail(&drv->polled_link, &polled_list);
+	mutex_unlock(&polled_list_lock);
+
 #ifdef CONFIG_SERIAL_CORE_CONSOLE
 	if (drv->nr_pollable && drv->cons &&
 					!(drv->cons->flags & CON_ENABLED)) {
@@ -2558,6 +2753,9 @@ void uart_unregister_polled(struct uart_driver *drv)
 	if (drv->nr_pollable && drv->cons)
 		unregister_console(drv->cons);
 #endif
+	mutex_lock(&polled_list_lock);
+	list_del(&drv->polled_link);
+	mutex_unlock(&polled_list_lock);
 }
 EXPORT_SYMBOL(uart_unregister_polled);
 
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6f81efb..4053197 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -317,6 +317,11 @@ struct uart_port {
 
 	upf_t			flags;
 
+/*
+ * The port lock protects UPF_INUSE_DIRECT and UPF_INUSE_NORMAL.  One
+ * of those two bits must be set before any other bits can be changed
+ * in port->flags.
+ */
 #define UPF_FOURPORT		((__force upf_t) (1 << 1))
 #define UPF_SAK			((__force upf_t) (1 << 2))
 #define UPF_SPD_MASK		((__force upf_t) (0x1030))
@@ -333,6 +338,8 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+#define UPF_INUSE_NORMAL	((__force uif_t) (1 << 26))
+#define UPF_INUSE_DIRECT	((__force uif_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
 #define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
 #define UPF_DEAD		((__force upf_t) (1 << 30))
@@ -377,6 +384,36 @@ struct uart_state {
 
 #define UART_XMIT_SIZE	PAGE_SIZE
 
+/*
+ * Structure used by the direct uart driver.
+ */
+struct uart_direct {
+	/* Generic data for use by the layered driver. */
+	void *direct_data;
+
+	/*
+	 * Port status, called with the port lock held.
+	 */
+	void (*handle_break)(struct uart_port *port);
+	void (*handle_dcd_change)(struct uart_port *port, unsigned int status);
+	void (*handle_cts_change)(struct uart_port *port, unsigned int status);
+
+	/*
+	 * A receive character from the port.  Called with the port
+	 * lock held, buffer and use the "push" function to actually
+	 * handle the characters.
+	 */
+	void (*handle_char)(struct uart_port *port, unsigned int status,
+			    unsigned int overrun, unsigned int ch,
+			    unsigned int flag);
+
+	/*
+	 * Done receiving characters for now, called with the port
+	 * lock not held.
+	 */
+	void (*push)(struct uart_port *port);
+};
+
 typedef unsigned int __bitwise__ uif_t;
 
 /*
@@ -406,6 +443,9 @@ struct uart_info {
 
 	struct tasklet_struct	tlet;
 	wait_queue_head_t	delta_msr_wait;
+
+	/* For the direct serial interface */
+	struct uart_direct	*direct;
 };
 
 /* number of characters left in xmit buffer before we ask for more */
@@ -441,6 +481,7 @@ struct uart_driver {
 	 */
 	struct uart_state	*state;
 	struct tty_driver	*tty_driver;
+	struct list_head        polled_link;
 };
 
 void uart_write_wakeup(struct uart_port *port);
@@ -481,6 +522,14 @@ int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_match_port(struct uart_port *port1, struct uart_port *port2);
 
 /*
+ * Direct serial port access.
+ */
+struct uart_port *uart_get_direct_port(char *name, int line, int force);
+int uart_put_direct_port(struct uart_port *port, int force);
+int uart_direct_write(struct uart_port *port, const unsigned char *buf,
+		      int count, int lock);
+
+/*
  * Power Management
  */
 int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
@@ -532,6 +581,13 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 static inline int uart_handle_break(struct uart_port *port)
 {
 	struct uart_info *info = port->info;
+
+	if (info->direct) {
+		if (info->direct->handle_break)
+			info->direct->handle_break(port);
+		return 0;
+	}
+
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
 		if (!port->sysrq) {
@@ -554,7 +610,13 @@ static inline int uart_handle_break(struct uart_port *port)
 static inline void
 uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 {
-	struct uart_info *info = port->info;
+	struct uart_info *info = port->info;;
+
+	if (info->direct) {
+		if (info->direct->handle_dcd_change)
+			info->direct->handle_dcd_change(port, status);
+		return;
+	}
 
 	port->icount.dcd++;
 
@@ -625,10 +687,18 @@ uart_insert_char(struct uart_port *port, unsigned int status,
 static inline void
 uart_push(struct uart_port *port)
 {
-	if (!port->info->tty)
+	struct uart_info *info = port->info;
+
+	if (info->direct) {
+		if (info->direct->push)
+			info->direct->push(port);
+		return;
+	}
+
+	if (!info->tty)
 		return;
 
-	tty_flip_buffer_push(port->info->tty);
+	tty_flip_buffer_push(info->tty);
 }
 
 /*
-- 
1.5.5.1

