>From cc12bbdcb1cb9bf9320e5b17fb655575fb15ba81 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Fri, 12 Sep 2008 17:32:40 -0400
Subject: [PATCH] serial config poll api

New handling of serial ports/consoles required by IPMI. This prevent
adding all the serial polling interface if not using IPMI_SERIAL. This
patch adds back the code that was removed by the serial driver rework
needed by IPMI_SERIAL, and it adds the proper #ifdef / #ifndef based
on the CONFIG_SERIAL_POLL_API kernel config option.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
Signed-off-by: Jonathan Fournier <jonathan.fournier@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index b062247..af09c0a 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -2469,6 +2469,7 @@ serial8250_type(struct uart_port *port)
 	return uart_config[type].name;
 }
 
+#ifdef CONFIG_SERIAL_POLL_API
 static void serial8250_poll(struct uart_port *port, unsigned int flags)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
@@ -2536,6 +2537,7 @@ int serial8250_in_flow_control(struct uart_port *port)
 	up->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
 	return !(msr & UART_MSR_CTS);
 }
+#endif /* CONFIG_SERIAL_POLL_API */
 
 static struct uart_ops serial8250_pops = {
 	.tx_empty	= serial8250_tx_empty,
@@ -2550,10 +2552,12 @@ static struct uart_ops serial8250_pops = {
 	.shutdown	= serial8250_shutdown,
 	.set_termios	= serial8250_set_termios,
 	.pm		= serial8250_pm,
+#ifdef CONFIG_SERIAL_POLL_API
 	.poll		= serial8250_poll,
 	.poll_startup	= serial8250_poll_startup,
 	.poll_shutdown	= serial8250_poll_shutdown,
 	.in_flow_control = serial8250_in_flow_control,
+#endif
 	.type		= serial8250_type,
 	.release_port	= serial8250_release_port,
 	.request_port	= serial8250_request_port,
@@ -2566,7 +2570,9 @@ static struct uart_ops serial8250_pops = {
 };
 
 static struct uart_8250_port serial8250_ports[UART_NR];
+#ifdef CONFIG_SERIAL_POLL_API
 static struct uart_port *serial8250_pollable_ports[UART_NR];
+#endif
 
 static void __init serial8250_isa_init_ports(void)
 {
@@ -2634,11 +2640,132 @@ static int serial8250_console_early_setup(void)
 	return serial8250_find_port_for_earlycon();
 }
 
+#ifndef CONFIG_SERIAL_POLL_API
+
+static void serial8250_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	wait_for_xmitr(up, UART_LSR_THRE);
+	serial_out(up, UART_TX, ch);
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+serial8250_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_8250_port *up = &serial8250_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	touch_nmi_watchdog();
+
+	local_irq_save(flags);
+	if (up->port.sysrq) {
+		/* serial8250_handle_port() already took the lock */
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&up->port.lock);
+	} else
+		spin_lock(&up->port.lock);
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_IER);
+
+	if (up->capabilities & UART_CAP_UUE)
+		serial_out(up, UART_IER, UART_IER_UUE);
+	else
+		serial_out(up, UART_IER, 0);
+
+	uart_console_write(&up->port, s, count, serial8250_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(up, BOTH_EMPTY);
+	serial_out(up, UART_IER, ier);
+
+	/*
+	 *	The receive handling will happen properly because the
+	 *	receive ready bit will still be set; it is not cleared
+	 *	on read.  However, modem control will not, we must
+	 *	call it if we have saved something in the saved flags
+	 *	while processing with interrupts off.
+	 */
+	if (up->msr_saved_flags)
+		check_modem_status(up);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init serial8250_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= nr_uarts)
+		co->index = 0;
+	port = &serial8250_ports[co->index].port;
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver serial8250_reg;
+static struct console serial8250_console = {
+	.name		= "ttyS",
+	.write		= serial8250_console_write,
+	.device		= uart_console_device,
+	.setup		= serial8250_console_setup,
+	.early_setup	= serial8250_console_early_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial8250_reg,
+};
+
+static int __init serial8250_console_init(void)
+{
+	if (nr_uarts > UART_NR)
+		nr_uarts = UART_NR;
+
+	serial8250_isa_init_ports();
+	register_console(&serial8250_console);
+	return 0;
+}
+console_initcall(serial8250_console_init);
+
+#else   /* CONFIG_SERIAL_POLL_API */
+
 static struct console serial8250_console = {
 	.name		= "ttyS",
 	.early_setup	= serial8250_console_early_setup
 };
 
+#endif  /* CONFIG_SERIAL_POLL_API */
+
 int serial8250_find_port(struct uart_port *p)
 {
 	int line;
@@ -2668,6 +2795,7 @@ static struct uart_driver serial8250_reg = {
 	.cons			= SERIAL8250_CONSOLE,
 };
 
+#ifdef CONFIG_SERIAL_POLL_API
 static int __init serial8250_polled_init(void)
 {
 	int i;
@@ -2697,6 +2825,7 @@ static int __init serial8250_polled_init(void)
 	return 0;
 }
 console_initcall(serial8250_polled_init);
+#endif
 
 /*
  * early_serial_setup - early registration for 8250 ports
@@ -2997,12 +3126,23 @@ EXPORT_SYMBOL_GPL(serial8250_get_port_def);
 static int __init serial8250_init(void)
 {
 	int ret;
+#ifndef CONFIG_SERIAL_POLL_API
+	int i;
+
+	if (nr_uarts > UART_NR)
+		nr_uarts = UART_NR;
+#endif
 
 	printk(KERN_INFO "Serial: 8250/16550 driver"
 		"%d ports, IRQ sharing %sabled\n", nr_uarts,
 		share_irqs ? "en" : "dis");
 
+#ifndef CONFIG_SERIAL_POLL_API
+	for (i = 0; i < NR_IRQS; i++)
+		spin_lock_init(&irq_lists[i].lock);
+#else
 	serial8250_polled_init();
+#endif
 
 	ret = uart_register_driver(&serial8250_reg);
 	if (ret)
@@ -3049,8 +3189,9 @@ static void __exit serial8250_exit(void)
 	platform_device_unregister(isa_dev);
 
 	uart_unregister_driver(&serial8250_reg);
-
+#ifdef CONFIG_SERIAL_POLL_API
 	uart_unregister_polled(&serial8250_reg);
+#endif
 }
 
 module_init(serial8250_init);
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 77cb342..bb36f1a 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -5,6 +5,11 @@
 menu "Serial drivers"
 	depends on HAS_IOMEM
 
+# New handling of serial ports/consoles required by IPMI
+config SERIAL_POLL_API
+   bool
+   default y if IPMI_SERIAL
+
 #
 # The new 8250/16550 serial drivers
 config SERIAL_8250
diff --git a/drivers/serial/mpsc.c b/drivers/serial/mpsc.c
index 638d59f..8b893db 100644
--- a/drivers/serial/mpsc.c
+++ b/drivers/serial/mpsc.c
@@ -57,6 +57,10 @@
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#ifndef CONFIG_SERIAL_POLL_API
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#endif
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/console.h>
@@ -934,6 +938,9 @@ static int serial_polled;
 static int mpsc_rx_intr(struct mpsc_port_info *pi)
 {
 	struct mpsc_rx_desc *rxre;
+#ifndef CONFIG_SERIAL_POLL_API
+	struct tty_struct *tty = pi->port.info->port.tty;
+#endif
 	u32	cmdstat, bytes_in, i;
 	int	rc = 0;
 	u8	*bp;
@@ -964,6 +971,19 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 		}
 #endif
 
+#ifndef CONFIG_SERIAL_POLL_API
+		/* Following use of tty struct directly is deprecated */
+		if (unlikely(tty_buffer_request_room(tty, bytes_in)
+					< bytes_in)) {
+			if (tty->low_latency)
+				tty_flip_buffer_push(tty);
+			/*
+			 * If this failed then we will throw away the bytes
+			 * but must do so to clear interrupts.
+			 */
+		}
+#endif
+
 		bp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);
 		dma_cache_sync(pi->port.dev, (void *)bp, MPSC_RXBE_SIZE,
 				DMA_FROM_DEVICE);
@@ -1004,6 +1024,10 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 				flag = TTY_BREAK;
 			else if (cmdstat & SDMA_DESC_CMDSTAT_FR)
 				flag = TTY_FRAME;
+#ifndef CONFIG_SERIAL_POLL_API
+			else if (cmdstat & SDMA_DESC_CMDSTAT_OR)
+				flag = TTY_OVERRUN;
+#endif
 			else if (cmdstat & SDMA_DESC_CMDSTAT_PE)
 				flag = TTY_PARITY;
 		}
@@ -1024,14 +1048,22 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 						| SDMA_DESC_CMDSTAT_FR
 						| SDMA_DESC_CMDSTAT_OR)))
 				&& !(cmdstat & pi->port.ignore_status_mask)) {
+#ifdef CONFIG_SERIAL_POLL_API
 			uart_insert_char(&pi->port, cmdstat,
 					 SDMA_DESC_CMDSTAT_OR,
 					 *bp, flag);
+#else
+			tty_insert_flip_char(tty, *bp, flag);
+#endif
 		} else {
 			for (i=0; i<bytes_in; i++)
+#ifdef CONFIG_SERIAL_POLL_API
 				uart_insert_char(&pi->port, cmdstat,
 						 SDMA_DESC_CMDSTAT_OR,
 						 *bp++, flag);
+#else
+				tty_insert_flip_char(tty, *bp++, TTY_NORMAL);
+#endif
 
 			pi->port.icount.rx += bytes_in;
 		}
@@ -1069,6 +1101,11 @@ next_frame:
 	if ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)
 		mpsc_start_rx(pi);
 
+#ifndef CONFIG_SERIAL_POLL_API
+	spin_unlock(&pi->port.lock);
+	tty_flip_buffer_push(tty);
+	spin_lock(&pi->port.lock);
+#endif
 	return rc;
 }
 
@@ -1212,9 +1249,11 @@ static irqreturn_t mpsc_sdma_intr(int irq, void *dev_id)
 	mpsc_sdma_intr_ack(pi);
 	if (mpsc_rx_intr(pi)) {
 		rc = IRQ_HANDLED;
+#ifdef CONFIG_SERIAL_POLL_API
 		spin_unlock(&pi->port.lock);
 		uart_push(&pi->port);
 		spin_lock(&pi->port.lock);
+#endif
 	}
 	if (mpsc_tx_intr(pi))
 		rc = IRQ_HANDLED;
@@ -1654,6 +1693,7 @@ static void mpsc_put_poll_char(struct uart_port *port,
 }
 #endif
 
+#ifdef CONFIG_SERIAL_POLL_API
 static void mpsc_poll(struct uart_port *port, unsigned int flags)
 {
 	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
@@ -1707,6 +1747,7 @@ static int mpsc_port_defaults(struct uart_port *port, int *baud, int *parity,
 
 	return 0;
 }
+#endif /* CONFIG_SERIAL_POLL_API */
 
 static struct uart_ops mpsc_pops = {
 	.tx_empty	= mpsc_tx_empty,
@@ -1720,11 +1761,13 @@ static struct uart_ops mpsc_pops = {
 	.startup	= mpsc_startup,
 	.shutdown	= mpsc_shutdown,
 	.set_termios	= mpsc_set_termios,
+#ifdef CONFIG_SERIAL_POLL_API
 	.poll		= mpsc_poll,
 	.poll_startup	= mpsc_poll_startup,
 	.poll_shutdown	= mpsc_poll_shutdown,
 	.in_flow_control = mpsc_in_flow_control,
 	.port_defaults	= mpsc_port_defaults,
+#endif
 	.type		= mpsc_type,
 	.release_port	= mpsc_release_port,
 	.request_port	= mpsc_request_port,
@@ -1745,9 +1788,123 @@ static struct uart_ops mpsc_pops = {
  */
 
 #ifdef CONFIG_SERIAL_MPSC_CONSOLE
+#ifndef CONFIG_SERIAL_POLL_API
+static void mpsc_console_write(struct console *co, const char *s, uint count)
+{
+	struct mpsc_port_info *pi = &mpsc_ports[co->index];
+	u8 *bp, *dp, add_cr = 0;
+	int i;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&pi->tx_lock, iflags);
+
+	while (pi->txr_head != pi->txr_tail) {
+		while (mpsc_sdma_tx_active(pi))
+			udelay(100);
+		mpsc_sdma_intr_ack(pi);
+		mpsc_tx_intr(pi);
+	}
+
+	while (mpsc_sdma_tx_active(pi))
+		udelay(100);
+
+	while (count > 0) {
+		bp = dp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);
+
+		for (i = 0; i < MPSC_TXBE_SIZE; i++) {
+			if (count == 0)
+				break;
+
+			if (add_cr) {
+				*(dp++) = '\r';
+				add_cr = 0;
+			} else {
+				*(dp++) = *s;
+
+				if (*(s++) == '\n') { /* add '\r' after '\n' */
+					add_cr = 1;
+					count++;
+				}
+			}
+
+			count--;
+		}
+
+		dma_cache_sync(pi->port.dev, (void *)bp, MPSC_TXBE_SIZE,
+				DMA_BIDIRECTIONAL);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			flush_dcache_range((ulong)bp,
+					(ulong)bp + MPSC_TXBE_SIZE);
+#endif
+		mpsc_setup_tx_desc(pi, i, 0);
+		pi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);
+		mpsc_sdma_start_tx(pi);
+
+		while (mpsc_sdma_tx_active(pi))
+			udelay(100);
+
+		pi->txr_tail = (pi->txr_tail + 1) & (MPSC_TXR_ENTRIES - 1);
+	}
+
+	spin_unlock_irqrestore(&pi->tx_lock, iflags);
+}
+
+static int __init mpsc_console_setup(struct console *co, char *options)
+{
+	struct mpsc_port_info *pi;
+	int baud, bits, parity, flow;
+
+	pr_debug("mpsc_console_setup[%d]: options: %s\n", co->index, options);
+
+	if (co->index >= MPSC_NUM_CTLRS)
+		co->index = 0;
+
+	pi = &mpsc_ports[co->index];
+
+	baud = pi->default_baud;
+	bits = pi->default_bits;
+	parity = pi->default_parity;
+	flow = pi->default_flow;
+
+	if (!pi->port.ops)
+		return -ENODEV;
+
+	spin_lock_init(&pi->port.lock);	/* Temporary fix--copied from 8250.c */
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&pi->port, co, baud, parity, bits, flow);
+}
+
 static struct console mpsc_console = {
 	.name	= MPSC_DEV_NAME,
+	.write	= mpsc_console_write,
+	.device	= uart_console_device,
+	.setup	= mpsc_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &mpsc_reg,
 };
+
+static int __init mpsc_late_console_init(void)
+{
+	pr_debug("mpsc_late_console_init: Enter\n");
+
+	if (!(mpsc_console.flags & CON_ENABLED))
+		register_console(&mpsc_console);
+	return 0;
+}
+
+late_initcall(mpsc_late_console_init);
+
+#else  /* CONFIG_SERIAL_POLL_API */
+static struct console mpsc_console = {
+   .name   = MPSC_DEV_NAME,
+};
+#endif /* CONFIG_SERIAL_POLL_API */
+
 #define MPSC_CONSOLE	&mpsc_console
 #else
 #define MPSC_CONSOLE	NULL
@@ -1885,8 +2042,12 @@ static struct uart_driver mpsc_reg = {
 	.major		= MPSC_MAJOR,
 	.minor		= MPSC_MINOR_START,
 	.nr		= MPSC_NUM_CTLRS,
+#ifndef CONFIG_SERIAL_POLL_API
+	.cons		= MPSC_CONSOLE,
+#endif
 };
 
+#ifdef CONFIG_SERIAL_POLL_API
 struct mpsc_port_info *pid;
 static struct uart_port *mpsc_pollable_ports[MPSC_NUM_CTLRS];
 
@@ -1917,6 +2078,7 @@ static void mpsc_polled_init(void)
 	mpsc_reg.cons = MPSC_CONSOLE;
 	uart_register_polled(&mpsc_reg);
 }
+#endif /* CONFIG_SERIAL_POLL_API */
 
 static int mpsc_drv_map_regs(struct mpsc_port_info *pi,
 		struct platform_device *pd)
@@ -2010,7 +2172,9 @@ static void mpsc_drv_get_platform_data(struct mpsc_port_info *pi,
 	pi->port.membase = pi->mpsc_base;
 	pi->port.mapbase = (ulong)pi->mpsc_base;
 	pi->port.ops = &mpsc_pops;
+#ifdef CONFIG_SERIAL_POLL_API
 	pi->port.dev = &pd->dev;
+#endif
 
 	pi->mirror_regs = pdata->mirror_regs;
 	pi->cache_mgmt = pdata->cache_mgmt;
@@ -2063,7 +2227,9 @@ static int mpsc_drv_probe(struct platform_device *dev)
 		}
 	}
 
+#ifdef CONFIG_SERIAL_POLL_API
 	mpsc_polled_init();
+#endif
 
 	return rc;
 }
@@ -2106,11 +2272,15 @@ static int __init mpsc_drv_init(void)
 			if ((rc = platform_driver_register(&mpsc_driver))) {
 				platform_driver_unregister(&mpsc_shared_driver);
 				uart_unregister_driver(&mpsc_reg);
+#ifdef CONFIG_SERIAL_POLL_API
 				uart_unregister_polled(&mpsc_reg);
+#endif
 			}
 		} else {
 			uart_unregister_driver(&mpsc_reg);
+#ifdef CONFIG_SERIAL_POLL_API
 			uart_unregister_polled(&mpsc_reg);
+#endif
 		}
 	}
 
@@ -2122,7 +2292,9 @@ static void __exit mpsc_drv_exit(void)
 	platform_driver_unregister(&mpsc_driver);
 	platform_driver_unregister(&mpsc_shared_driver);
 	uart_unregister_driver(&mpsc_reg);
+#ifdef CONFIG_SERIAL_POLL_API
 	uart_unregister_polled(&mpsc_reg);
+#endif
 	memset(mpsc_ports, 0, sizeof(mpsc_ports));
 	memset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));
 }
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index fc6ee84..841dda1 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -76,7 +76,9 @@ void uart_write_wakeup(struct uart_port *port)
 	 * closed.  No cookie for you.
 	 */
 	BUG_ON(!info);
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->flags & UIF_TASKLET_SETUP)
+#endif
 		tasklet_schedule(&info->tlet);
 }
 
@@ -255,15 +257,23 @@ static void uart_shutdown(struct uart_state *state)
 	/*
 	 * kill off our tasklet
 	 */
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->flags & UIF_TASKLET_SETUP) {
 		info->flags &= ~UIF_TASKLET_SETUP;
 		tasklet_kill(&info->tlet);
 	}
+#else
+	tasklet_kill(&info->tlet);
+#endif
 
 	/*
 	 * Free the transmit buffer page.
 	 */
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->xmit.buf && !(info->flags & UIF_BOOT_ALLOCATED)) {
+#else
+	if (info->xmit.buf) {
+#endif
 		free_page((unsigned long)info->xmit.buf);
 		info->xmit.buf = NULL;
 	}
@@ -461,6 +471,7 @@ uart_change_speed(struct uart_state *state, struct ktermios *old_termios)
 	port->ops->set_termios(port, termios, old_termios);
 }
 
+#ifdef CONFIG_SERIAL_POLL_API
 static inline int
 __uart_put_char(struct uart_port *port, struct circ_buf *circ, unsigned char c)
 {
@@ -488,12 +499,36 @@ _uart_put_char(struct uart_port *port, struct circ_buf *circ, unsigned char c)
 	spin_unlock_irqrestore(&port->lock, flags);
 	return ret;
 }
+#else
+static inline int
+__uart_put_char(struct uart_port *port, struct circ_buf *circ, unsigned char c)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	if (!circ->buf)
+		return 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+	if (uart_circ_chars_free(circ) != 0) {
+		circ->buf[circ->head] = c;
+		circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&port->lock, flags);
+	return ret;
+}
+#endif /* CONFIG_SERIAL_POLL_API */
 
 static int uart_put_char(struct tty_struct *tty, unsigned char ch)
 {
 	struct uart_state *state = tty->driver_data;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	return _uart_put_char(state->port, &state->info->xmit, ch);
+#else
+	return __uart_put_char(state->port, &state->info->xmit, ch);
+#endif /* CONFIG_SERIAL_POLL_API */
 }
 
 static void uart_flush_chars(struct tty_struct *tty)
@@ -1359,9 +1394,11 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 	 * Wake up anyone trying to open this port.
 	 */
 	state->info->flags &= ~UIF_NORMAL_ACTIVE;
+#ifdef CONFIG_SERIAL_POLL_API
 	spin_lock_irq(&state->port->lock);
 	port->flags &= ~UPF_INUSE_NORMAL;
 	spin_unlock_irq(&state->port->lock);
+#endif
 	wake_up_interruptible(&state->info->port.open_wait);
 
  done:
@@ -1560,6 +1597,7 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 		if (signal_pending(current))
 			break;
 
+#ifdef CONFIG_SERIAL_POLL_API
 		/*
 		 * The UPF_INUSE_NORMAL flag may have been cleared
 		 * while we were waiting on the port.  Make sure the
@@ -1575,6 +1613,7 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 		}
 		port->flags |= UPF_INUSE_NORMAL;
 		spin_unlock_irq(&state->port->lock);
+#endif
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&info->port.open_wait, &wait);
@@ -1582,6 +1621,13 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 	state->count++;
 	info->port.blocked_open--;
 
+#ifndef CONFIG_SERIAL_POLL_API
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+
+	if (!info->port.tty || tty_hung_up_p(filp))
+		return -EAGAIN;
+#else
 	if (!ret) {
 		if (signal_pending(current))
 			ret = -ERESTARTSYS;
@@ -1593,6 +1639,7 @@ uart_block_til_ready(struct file *filp, struct uart_state *state)
 			spin_unlock_irq(&state->port->lock);
 		}
 	}
+#endif
 
 	return ret;
 }
@@ -1614,6 +1661,7 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 		goto err_unlock;
 	}
 
+#ifdef CONFIG_SERIAL_POLL_API
 	spin_lock_irq(&state->port->lock);
 	if (state->port->flags & UPF_INUSE_DIRECT) {
 		spin_unlock_irq(&state->port->lock);
@@ -1622,6 +1670,7 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 	}
 	state->port->flags |= UPF_INUSE_NORMAL;
 	spin_unlock_irq(&state->port->lock);
+#endif
 
 	/* BKL: RACE HERE - LEAK */
 	/* We should move this into the uart_state structure and kill off
@@ -1632,10 +1681,12 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 		 * (and other polled users) needs to set up an info
 		 * structure, but it can't set up the tasklet.
 		 */
+#ifdef CONFIG_SERIAL_POLL_API
 		if (state->port->info)
 			/* Already there from the console code. */
 			state->info = state->port->info;
 		else {
+#endif
 			state->info = kzalloc(sizeof(struct uart_info),
 					      GFP_KERNEL);
 			if (!state->info) {
@@ -1650,23 +1701,27 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 			 * Link the info into the other structures.
 			 */
 			state->port->info = state->info;
-
 		}
 
+#ifdef CONFIG_SERIAL_POLL_API
 	}
 
 	if (!(state->info->flags & UIF_TASKLET_SETUP)) {
+#endif
 		tasklet_init(&state->info->tlet, uart_tasklet_action,
 			     (unsigned long)state);
+#ifdef CONFIG_SERIAL_POLL_API
 		state->info->flags |= UIF_TASKLET_SETUP;
 	}
-
+#endif
 	return state;
 
  err_unlock_release:
+#ifdef CONFIG_SERIAL_POLL_API
 	spin_lock_irq(&state->port->lock);
 	state->port->flags &= ~UPF_INUSE_NORMAL;
 	spin_unlock_irq(&state->port->lock);
+#endif
  err_unlock:
 	state->count--;
 	mutex_unlock(&state->mutex);
@@ -1752,6 +1807,7 @@ static int uart_open(struct tty_struct *tty, struct file *filp)
 	if (retval == 0)
 		retval = uart_block_til_ready(filp, state);
 
+#ifdef CONFIG_SERIAL_POLL_API
 	spin_lock_irq(&state->port->lock);
 	if (retval && (state->port->flags & UPF_INUSE_NORMAL))
 		/*
@@ -1760,6 +1816,7 @@ static int uart_open(struct tty_struct *tty, struct file *filp)
 		 */
 		state->port->flags &= ~UPF_INUSE_NORMAL;
 	spin_unlock_irq(&state->port->lock);
+#endif
 
 	mutex_unlock(&state->mutex);
 
@@ -2068,6 +2125,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 }
 EXPORT_SYMBOL_GPL(uart_set_options);
 
+#ifdef CONFIG_SERIAL_POLL_API
 static void uartdrv_console_write(struct console *co, const char *s,
 				  unsigned count)
 {
@@ -2236,6 +2294,7 @@ static int uartdrv_console_setup(struct console *co, char *options)
 	init_waitqueue_head(&info->delta_msr_wait);
 	return 0;
 }
+#endif /* CONFIG_SERIAL_POLL_API */
 #endif /* CONFIG_SERIAL_CORE_CONSOLE */
 
 static void uart_change_pm(struct uart_state *state, int pm_state)
@@ -2589,6 +2648,7 @@ static const struct tty_operations uart_ops = {
 #endif
 };
 
+#ifdef CONFIG_SERIAL_POLL_API
 /*
  * Holds a list of poll-capable uart drivers, so that polled driver
  * users can look them up.
@@ -2767,6 +2827,7 @@ void uart_unregister_polled(struct uart_driver *drv)
 	mutex_unlock(&polled_list_lock);
 }
 EXPORT_SYMBOL(uart_unregister_polled);
+#endif  /* CONFIG_SERIAL_POLL_API */
 
 /**
  *	uart_register_driver - register a driver with the uart core layer
@@ -2897,7 +2958,9 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 	state->pm_state = -1;
 
 	port->cons = drv->cons;
-
+#ifndef CONFIG_SERIAL_POLL_API
+	port->info = state->info;
+#else
 	/*
 	 * Don't assign info if it has already been assigned.
 	 *
@@ -2907,6 +2970,7 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 	 */
 	if (!port->info)
 		port->info = state->info;
+#endif
 
 	/*
 	 * If this port is a console, then the spinlock is already
@@ -3004,10 +3068,15 @@ int uart_remove_one_port(struct uart_driver *drv, struct uart_port *port)
 	 * Kill the tasklet, and free resources.
 	 */
 	if (info) {
+#ifndef CONFIG_SERIAL_POLL_API
+		tasklet_kill(&info->tlet);
+		kfree(info);
+#else
 		if (info->flags & UIF_TASKLET_SETUP)
 			tasklet_kill(&info->tlet);
 		if (!(info->flags & UIF_BOOT_ALLOCATED))
 			kfree(info);
+#endif
 	}
 
 	state->port = NULL;
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e68c91a..a66e074 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -171,9 +171,11 @@ struct uart_info;
 struct serial_struct;
 struct device;
 
+#ifdef CONFIG_SERIAL_POLL_API
 #define UART_POLL_FLAGS_RX	(1 << 0)	/* Poll Receiver */
 #define UART_POLL_FLAGS_TX	(1 << 1)	/* Poll Transmitter */
 #define UART_POLL_FLAGS_MCTRL	(1 << 2)	/* Poll modem control */
+#endif
 
 /*
  * This structure describes all the operations that can be
@@ -200,6 +202,7 @@ struct uart_ops {
 	int		(*set_wake)(struct uart_port *, unsigned int state);
 
 
+#ifdef CONFIG_SERIAL_POLL_API
 	/*
 	 * Note: Poll routines must be called with the port lock held and
 	 * interrupts off.
@@ -239,6 +242,7 @@ struct uart_ops {
 	int		(*port_defaults)(struct uart_port *,
 					 int *baud, int *parity, int *bits,
 					 int *flow);
+#endif  /* CONFIG_SERIAL_POLL_API */
 
 	/*
 	 * Return a string describing the type of the port
@@ -338,8 +342,10 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+#ifdef CONFIG_SERIAL_POLL_API
 #define UPF_INUSE_NORMAL	((__force uif_t) (1 << 26))
 #define UPF_INUSE_DIRECT	((__force uif_t) (1 << 27))
+#endif
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
 #define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
 #define UPF_DEAD		((__force upf_t) (1 << 30))
@@ -384,6 +390,7 @@ struct uart_state {
 
 #define UART_XMIT_SIZE	PAGE_SIZE
 
+#ifdef CONFIG_SERIAL_POLL_API
 /*
  * Structure used by the direct uart driver.
  */
@@ -413,6 +420,7 @@ struct uart_direct {
 	 */
 	void (*push)(struct uart_port *port);
 };
+#endif /* CONFIG_SERIAL_POLL_API */
 
 typedef unsigned int __bitwise__ uif_t;
 
@@ -433,8 +441,10 @@ struct uart_info {
  *
  * FIXME: use the ASY_ definitions
  */
+#ifdef CONFIG_SERIAL_POLL_API
 #define UIF_TASKLET_SETUP	((__force uif_t) (1 << 23))
 #define UIF_BOOT_ALLOCATED	((__force uif_t) (1 << 24))
+#endif
 #define UIF_CHECK_CD		((__force uif_t) (1 << 25))
 #define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
 #define UIF_NORMAL_ACTIVE	((__force uif_t) (1 << 29))
@@ -444,8 +454,10 @@ struct uart_info {
 	struct tasklet_struct	tlet;
 	wait_queue_head_t	delta_msr_wait;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	/* For the direct serial interface */
 	struct uart_direct	*direct;
+#endif
 };
 
 /* number of characters left in xmit buffer before we ask for more */
@@ -463,6 +475,7 @@ struct uart_driver {
 	int			 nr;
 	struct console		*cons;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	/*
 	 * If nr_pollable is non-zero, then pollable_ports is an array of uart
 	 * ports that can be used for polling.  The serial_core code
@@ -474,6 +487,7 @@ struct uart_driver {
 	 */
 	int			 nr_pollable;
 	struct uart_port	**pollable_ports;
+#endif
 
 	/*
 	 * these are private; the low level driver should not
@@ -481,7 +495,9 @@ struct uart_driver {
 	 */
 	struct uart_state	*state;
 	struct tty_driver	*tty_driver;
+#ifdef CONFIG_SERIAL_POLL_API
 	struct list_head        polled_link;
+#endif
 };
 
 void uart_write_wakeup(struct uart_port *port);
@@ -513,14 +529,17 @@ void uart_console_write(struct uart_port *port, const char *s,
 /*
  * Port/driver registration/removal
  */
+#ifdef CONFIG_SERIAL_POLL_API
 void uart_register_polled(struct uart_driver *uart);
 void uart_unregister_polled(struct uart_driver *uart);
+#endif
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_match_port(struct uart_port *port1, struct uart_port *port2);
 
+#ifdef CONFIG_SERIAL_POLL_API
 /*
  * Direct serial port access.
  */
@@ -528,6 +547,7 @@ struct uart_port *uart_get_direct_port(char *name, int line, int force);
 int uart_put_direct_port(struct uart_port *port, int force);
 int uart_direct_write(struct uart_port *port, const unsigned char *buf,
 		      int count, int lock);
+#endif
 
 /*
  * Power Management
@@ -546,12 +566,17 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 #define uart_circ_chars_free(circ)	\
 	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
 
+#ifndef CONFIG_SERIAL_POLL_API
+#define uart_tx_stopped(portp)		\
+	((portp)->info->port.tty->stopped || (portp)->info->port.tty->hw_stopped)
+#else
 static inline int uart_tx_stopped(struct uart_port *port)
 {
 	if (!port->info->port.tty)
 		return 0;
 	return port->info->port.tty->stopped || port->info->port.tty->hw_stopped;
 }
+#endif  /* CONFIG_SERIAL_POLL_API */
 
 /*
  * The following are helper functions for the low level drivers.
@@ -582,11 +607,13 @@ static inline int uart_handle_break(struct uart_port *port)
 {
 	struct uart_info *info = port->info;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->direct) {
 		if (info->direct->handle_break)
 			info->direct->handle_break(port);
 		return 0;
 	}
+#endif
 
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
@@ -612,11 +639,13 @@ uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 {
 	struct uart_info *info = port->info;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->direct) {
 		if (info->direct->handle_dcd_change)
 			info->direct->handle_dcd_change(port, status);
 		return;
 	}
+#endif
 
 	port->icount.dcd++;
 
@@ -644,11 +673,13 @@ uart_handle_cts_change(struct uart_port *port, unsigned int status)
 	struct tty_struct *tty = port->info->port.tty;
 	struct uart_info *info = port->info;
 
+#ifdef CONFIG_SERIAL_POLL_API
    if (info->direct) {
       if (info->direct->handle_cts_change)
          info->direct->handle_cts_change(port, status);
       return;
    }
+#endif
 
 	if (!tty)
       return;
@@ -680,12 +711,14 @@ uart_insert_char(struct uart_port *port, unsigned int status,
 	struct tty_struct *tty = port->info->port.tty;
 	struct uart_info *info = port->info;
 
+#ifdef CONFIG_SERIAL_POLL_API
    if (info->direct) {
       if (info->direct->handle_char)
          info->direct->handle_char(port, status, overrun,
                     ch, flag);
       return;
    }
+#endif
 
 	if (!tty)
 		return;
@@ -707,11 +740,13 @@ uart_push(struct uart_port *port)
 	struct tty_struct *tty = port->info->port.tty;
 	struct uart_info *info = port->info;
 
+#ifdef CONFIG_SERIAL_POLL_API
 	if (info->direct) {
 		if (info->direct->push)
 			info->direct->push(port);
 		return;
 	}
+#endif
 
 	if (!tty)
 		return;
