From 518f66e452adba678f30b56ca91f218a69bff675 Mon Sep 17 00:00:00 2001
From: Boban Petrovic <boban.petrovic@windriver.com>
Date: Thu, 6 Nov 2008 22:38:41 -0500
Subject: [PATCH] sun4v serial virtual channel

SUN4V VLDC (Virtual Logical Domain Channel) driver for serial IPMI.

Signed-off-by: Boban Petrovic <boban.petrovic@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/serial/Kconfig  |    9 +
 drivers/serial/Makefile |    1 +
 drivers/serial/sunvc.c  |  657 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 667 insertions(+), 0 deletions(-)

diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index bb36f1a..77749b4 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -930,16 +930,25 @@ config SERIAL_SUNSAB_CONSOLE
 
 config SERIAL_SUNHV
 	bool "Sun4v Hypervisor Console support"
 	depends on SPARC64
 	help
 	  This driver supports the console device found on SUN4V Sparc
 	  systems.  Say Y if you want to be able to use this device.
 
+config SERIAL_SUNVC
+	tristate "Sun4v IPMI virtual channel support"
+	depends on SPARC64
+	depends on SERIAL_POLL_API
+	default m if SERIAL_POLL_API
+	help
+	  This driver supports the virtual channel device found on SUN4V SPARC
+	  systems.  Say Y if you want to be able to use this device.
+
 config SERIAL_IP22_ZILOG
 	tristate "SGI Zilog8530 serial support"
 	depends on SGI_HAS_ZILOG
 	select SERIAL_CORE
 	help
 	  This driver supports the Zilog8530 serial ports found on SGI
 	  systems.  Say Y or M if you want to be able to these serial ports.
 
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 4534b00..4aa147a 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -28,16 +28,17 @@ obj-$(CONFIG_SERIAL_BFIN) += bfin_5xx.o
 obj-$(CONFIG_SERIAL_BFIN_SPORT) += bfin_sport_uart.o
 obj-$(CONFIG_SERIAL_SAMSUNG) += samsung.o
 obj-$(CONFIG_SERIAL_S3C2400) += s3c2400.o
 obj-$(CONFIG_SERIAL_S3C2410) += s3c2410.o
 obj-$(CONFIG_SERIAL_S3C2412) += s3c2412.o
 obj-$(CONFIG_SERIAL_S3C2440) += s3c2440.o
 obj-$(CONFIG_SERIAL_SUNCORE) += suncore.o
 obj-$(CONFIG_SERIAL_SUNHV) += sunhv.o
+obj-$(CONFIG_SERIAL_SUNVC) += sunvc.o
 obj-$(CONFIG_SERIAL_SUNZILOG) += sunzilog.o
 obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
 obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
 obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 obj-$(CONFIG_SERIAL_MUX) += mux.o
 obj-$(CONFIG_SERIAL_68328) += 68328serial.o
 obj-$(CONFIG_SERIAL_68360) += 68360serial.o
 obj-$(CONFIG_SERIAL_COLDFIRE) += mcfserial.o
diff --git a/drivers/serial/sunvc.c b/drivers/serial/sunvc.c
new file mode 100644
index 0000000..6ebe224
--- /dev/null
+++ b/drivers/serial/sunvc.c
@@ -0,0 +1,657 @@
+/* sunvc.c: Serial driver for SUN4V hypervisor virtual channel.
+ *          based on sunhv.c from David S. Miller (davem@davemloft.net)
+ *
+ * Copyright (C) 2007 Andrei Kholodnyi (Andrei.Kholodnyi@windriver.com)
+ * Copyright (C) 2008 Wind River Systems Services
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/sysrq.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+
+#include <asm/hypervisor.h>
+#include <asm/spitfire.h>
+#include <asm/ldc.h>
+#include <asm/vio.h>
+#include <asm/mdesc.h>
+#include <asm/head.h>
+#include <asm/irq.h>
+
+#include "suncore.h"
+
+#define IGNORE_BREAK		0x1
+#define IGNORE_ALL		0x2
+
+/* Default mtu size 4K. */
+#define VLDC_DEFAULT_MTU	0x1000
+
+static int vldc_debug = 0;
+#define VLDC_DEBUG if (vldc_debug) printk
+
+#ifdef CONFIG_SERIAL_POLL_API
+static struct uart_port *vldc_uart_pollable_ports[1];
+#endif
+
+typedef struct vldc_port {
+	struct uart_port port;
+	struct ldc_channel *lp;
+	int channel_id;
+	const char *channel_name;
+	spinlock_t vldc_lock;
+} vldc_port_t;
+
+static unsigned int vldc_uart_tx_empty(struct uart_port *port)
+{
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	/* Transmitter is always empty for us.  If the circ buffer
+	 * is non-empty or there is an x_char pending, our caller
+	 * will do the right thing and ignore what we return here.
+	 */
+	return TIOCSER_TEMT;
+}
+
+static void vldc_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+/* port->lock is held by caller and interrupts are disabled.  */
+static unsigned int vldc_uart_get_mctrl(struct uart_port *port)
+{
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	return TIOCM_DSR | TIOCM_CAR | TIOCM_CTS;
+}
+
+static void vldc_uart_stop_tx(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+/* port->lock held by caller.  */
+static void vldc_uart_start_tx(struct uart_port *port)
+{
+	vldc_port_t *vldc_port = (vldc_port_t *)port;
+	struct circ_buf *xmit = &port->info->xmit;
+	uint64_t size = 0;
+	int64_t err = 0;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	while (!uart_circ_empty(xmit)) {
+		size = uart_circ_chars_pending(xmit);
+
+		if (vldc_port->lp != NULL)
+			err = ldc_write(vldc_port->lp, &xmit->buf[xmit->tail], size);
+
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: size[%ld], err[%ld].\n",
+			   __FUNCTION__, size, err);
+
+		if (err < 0) {
+			VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_write failed[%ld].\n",
+				   __FUNCTION__, err);
+			break;
+		}
+
+		xmit->tail = (xmit->tail + size) & (UART_XMIT_SIZE - 1);
+		port->icount.tx += size;
+	}
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s finished.\n", __FUNCTION__);
+}
+
+static void vldc_uart_send_xchar(struct uart_port *port, char ch)
+{
+	unsigned long flags;
+	int limit = 10000;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	while (limit-- > 0) {
+		long status = 0;
+
+		if (status == HV_EOK)
+			break;
+	}
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s finished.\n", __FUNCTION__);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/* port->lock held by caller.  */
+static void vldc_uart_stop_rx(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+/* port->lock held by caller.  */
+static void vldc_uart_enable_ms(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+static void vldc_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+static int vldc_uart_startup(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return 0;
+}
+
+static void vldc_uart_shutdown(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+static void vldc_uart_set_termios(struct uart_port *port,
+				  struct ktermios *termios,
+				  struct ktermios *old)
+{
+	unsigned int iflag, cflag;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	iflag = termios->c_iflag;
+	cflag = termios->c_cflag;
+
+	port->ignore_status_mask = 0;
+	if (iflag & IGNBRK)
+		port->ignore_status_mask |= IGNORE_BREAK;
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= IGNORE_ALL;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *vldc_uart_type(struct uart_port *port)
+{
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	return "sun4V virtual channel";
+}
+
+static void vldc_uart_release_port(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+static int vldc_uart_request_port(struct uart_port *port)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return 0;
+}
+
+static void vldc_uart_config_port(struct uart_port *port,
+				  int flags)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+static int vldc_uart_verify_port(struct uart_port *port,
+				 struct serial_struct *ser)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return -EINVAL;
+}
+
+#ifdef CONFIG_SERIAL_POLL_API
+
+static int vldc_receive_chars(vldc_port_t *vldc_port, char *buffer, int bytes_in)
+{
+	int i = 0;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	if (bytes_in <= 0) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s. recv_buff_size[%d] <= 0.\n",
+			   __FUNCTION__, bytes_in);
+		return -EINVAL;
+	}
+	if (buffer == NULL) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s. recv_buffer == NULL.\n",
+			   __FUNCTION__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < bytes_in; i++) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: sending to UART.\n", __FUNCTION__);
+		if (vldc_port->port.info == NULL) {
+			VLDC_DEBUG(KERN_INFO "VLDC: %s: port->info == NULL.\n", __FUNCTION__);
+			return 0;
+		}
+
+		uart_insert_char(&vldc_port->port, UART_LSR_DR,
+				 UART_LSR_OE, buffer[i], TTY_NORMAL);
+	}
+
+	uart_push(&vldc_port->port);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	return 0;
+}
+
+static void vldc_transmit_chars(vldc_port_t *vldc_port)
+{
+	struct uart_port *uart_port = &vldc_port->port;
+	struct circ_buf *xmit;
+	uint64_t size = 0;
+	int64_t err = -1;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	if (!uart_port->info) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: uart_port->info == NULL.\n",
+			   __FUNCTION__);
+		return;
+	}
+
+	xmit = &uart_port->info->xmit;
+	if (uart_circ_empty(xmit) || uart_tx_stopped(uart_port)) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: uart problem.\n", __FUNCTION__);
+		return;
+	}
+
+	while (!uart_circ_empty(xmit)) {
+		size = uart_circ_chars_pending(xmit);
+		err = ldc_write(vldc_port->lp, &xmit->buf[xmit->tail], size);
+		if (err < 0) {
+			VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_write error[%ld].\n",
+				   __FUNCTION__, err);
+			break;
+		}
+
+		xmit->tail = (xmit->tail + size) & (UART_XMIT_SIZE - 1);
+		uart_port->icount.tx += size;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(uart_port);
+	}
+	uart_push(uart_port);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	return;
+}
+
+static void vldc_uart_poll(struct uart_port *port,
+			   unsigned int flags)
+{
+	vldc_port_t *vldc_port = (vldc_port_t *)port;
+	unsigned long spinlock_flags = 0;
+
+	spin_lock_irqsave(&port->lock, spinlock_flags);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: flags[%d].\n", __FUNCTION__, flags);
+
+        if (flags & UART_POLL_FLAGS_TX) {
+		vldc_transmit_chars(vldc_port);
+        }
+        if (flags & UART_POLL_FLAGS_RX) {
+	}
+
+	spin_unlock_irqrestore(&port->lock, spinlock_flags);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	return;
+}
+
+static int vldc_uart_poll_startup(struct uart_port *port,
+				  unsigned long *pstate)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return 0;
+}
+
+static void vldc_uart_poll_shutdown(struct uart_port *port,
+				    unsigned long pstate)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return;
+}
+
+/*
+ * Return reasonable settings for the port; it is primarily
+ * there so firmware can pass console settings for the
+ * console.
+ */
+static int vldc_uart_port_defaults(struct uart_port *port,
+				   int *baud, int *parity,
+				   int *bits, int *flow)
+{
+	/* Do nothing here. */
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: nothing to do.\n", __FUNCTION__);
+
+	return 0;
+}
+
+#endif
+
+static struct uart_ops vldc_uart_ops = {
+	.tx_empty	= vldc_uart_tx_empty,
+	.set_mctrl	= vldc_uart_set_mctrl,
+	.get_mctrl	= vldc_uart_get_mctrl,
+	.stop_tx	= vldc_uart_stop_tx,
+	.start_tx	= vldc_uart_start_tx,
+	.send_xchar	= vldc_uart_send_xchar,
+	.stop_rx	= vldc_uart_stop_rx,
+	.enable_ms	= vldc_uart_enable_ms,
+	.break_ctl	= vldc_uart_break_ctl,
+	.startup	= vldc_uart_startup,
+	.shutdown	= vldc_uart_shutdown,
+	.set_termios	= vldc_uart_set_termios,
+#ifdef CONFIG_SERIAL_POLL_API
+	.poll		= vldc_uart_poll,
+	.poll_startup	= vldc_uart_poll_startup,
+	.poll_shutdown	= vldc_uart_poll_shutdown,
+	.port_defaults	= vldc_uart_port_defaults,
+#endif
+	.type		= vldc_uart_type,
+	.release_port	= vldc_uart_release_port,
+	.request_port	= vldc_uart_request_port,
+	.config_port	= vldc_uart_config_port,
+	.verify_port	= vldc_uart_verify_port,
+};
+
+static struct uart_driver vldc_uart_driver_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "sun4v virtual channel ipmi",
+	.dev_name		= "ttyIPMI",
+};
+
+static void vldc_event(void *arg, int event)
+{
+	vldc_port_t *vldc_port = arg;
+	int err = 0, repeat_count = 5;
+	unsigned long flags = 0;
+	unsigned char buffer[VLDC_DEFAULT_MTU] = {0};
+
+	spin_lock_irqsave(&vldc_port->vldc_lock, flags);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: service[%s].\n", __FUNCTION__, vldc_port->channel_name);
+
+	if (vldc_port->lp == NULL) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: lp == NULL.\n", __FUNCTION__);
+		spin_unlock_irqrestore(&vldc_port->vldc_lock, flags);
+		return;
+	}
+
+	switch(event) {
+	case LDC_EVENT_UP:
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: LDC_EVENT_UP.\n", __FUNCTION__);
+		/* Good. We can now send/receive data. */
+		break;
+	case LDC_EVENT_RESET:
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: LDC_EVENT_RESET.\n", __FUNCTION__);
+		/* Try to reconnect. */
+		err = ldc_connect(vldc_port->lp);
+		if (err) {
+			printk(KERN_ERR "VLDC: %s: connect error[%d]\n", __FUNCTION__, err);
+		}
+		break;
+	case LDC_EVENT_DATA_READY:
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: LDC_EVENT_DATA_READY.\n", __FUNCTION__);
+		while (repeat_count--) {
+			err = ldc_read(vldc_port->lp, buffer, VLDC_DEFAULT_MTU);
+			if (unlikely(err < 0)) {
+				VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_read error[%d].\n", __FUNCTION__, err);
+				if (err == -ECONNRESET) {
+					break;
+				}
+				if (err == -EAGAIN) {
+					continue;
+				}
+				break;
+			}
+			if (err == 0) {
+				VLDC_DEBUG(KERN_INFO "VLDC: %s: no more data to read.\n", __FUNCTION__);
+				break;
+			}
+
+			err = vldc_receive_chars(vldc_port, buffer, err);
+			if (err < 0) {
+				VLDC_DEBUG(KERN_INFO "VLDC: %s: no more data to read.\n", __FUNCTION__);
+				break;
+			}
+			memset(buffer, 0, VLDC_DEFAULT_MTU);
+		}
+		break;
+	default:
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: unknown event.\n", __FUNCTION__);
+	}
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	spin_unlock_irqrestore(&vldc_port->vldc_lock, flags);
+
+	return;
+}
+
+static struct ldc_channel_config vc_cfg = {
+	.event		= vldc_event,
+	.mtu		= VLDC_DEFAULT_MTU,
+	.mode		= LDC_MODE_STREAM,
+};
+
+static int __devinit vldc_probe(struct vio_dev *vdev, const struct vio_device_id *id)
+{
+	struct mdesc_handle *hp;
+	struct ldc_channel *lp;
+	vldc_port_t *vldc_port;
+	struct uart_port *uart_port;
+	const u64 *val;
+	const char *s;
+	int err;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: tx_irq[%d], rx_irq[%d], endpoint_id[%lu].\n",
+		   __FUNCTION__, vdev->tx_irq, vdev->rx_irq, vdev->channel_id);
+
+	hp = mdesc_grab();
+	val = mdesc_get_property(hp, vdev->mp, "id", NULL);
+	s = mdesc_get_property(hp, vdev->mp, "vldc-svc-name", NULL);
+	mdesc_release(hp);
+
+	if ((s == NULL) || (0 != strcmp(s, "ipmi"))) {
+		VLDC_DEBUG(KERN_INFO "VLDC: vldc_probe: no ipmi service.\n");
+		return -ENODEV;
+	}
+
+	/* Found virtual ipmi channel. */
+	vc_cfg.tx_irq = vdev->tx_irq;
+	vc_cfg.rx_irq = vdev->rx_irq;
+
+	vldc_port = kzalloc(sizeof(vldc_port_t), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!vldc_port) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: kzalloc failed[%d].\n", __FUNCTION__, err);
+		return err;
+	}
+
+	vldc_port->channel_name = s;
+
+	/* Virtual ipmi channel configuration. */
+	lp = ldc_alloc(vdev->channel_id, &vc_cfg, vldc_port);
+	if (IS_ERR(lp)) {
+		err = PTR_ERR(lp);
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_alloc failed.\n", __FUNCTION__);
+		goto out_free_vldc;
+	}
+	vldc_port->lp = lp;
+
+	err = ldc_bind(lp, "VLDC-IPMI");
+	if (err) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_bind failed.\n", __FUNCTION__);
+		goto out_free_lp;
+	}
+
+	err = ldc_connect(lp);
+	if (err) {
+		/* If this one fails at the beginning we can try to connect latter. */
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: ldc_connect failed.\n", __FUNCTION__);
+	}
+
+	spin_lock_init(&vldc_port->vldc_lock);
+
+	/* UART registration.*/
+	uart_port = &vldc_port->port;
+
+	uart_port->line = 0;
+	uart_port->ops = &vldc_uart_ops;
+	uart_port->type = PORT_UNKNOWN;
+	uart_port->uartclk = 0;
+	uart_port->membase = 0;
+	uart_port->irq = 0;
+
+	err = sunserial_register_minors(&vldc_uart_driver_reg, 1);
+	if (err) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: sunserial_register_minors failed.\n", __FUNCTION__);
+		goto out_free_lp;
+	}
+	/* Our device will be called ttyIPMI0. */
+	vldc_uart_driver_reg.tty_driver->name_base = 0;
+
+	err = uart_add_one_port(&vldc_uart_driver_reg, uart_port);
+	if (err) {
+		VLDC_DEBUG(KERN_INFO "VLDC: %s: uart_add_one_port failed.\n", __FUNCTION__);
+		goto out_free_minors;
+	}
+
+	/* Register the uart as polling one. */
+	vldc_uart_driver_reg.nr_pollable = 1;
+	vldc_uart_pollable_ports[0] = uart_port;
+	vldc_uart_driver_reg.pollable_ports = vldc_uart_pollable_ports;
+	uart_register_polled(&vldc_uart_driver_reg);
+
+	dev_set_drvdata(&vdev->dev, vldc_port);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s: finished.\n", __FUNCTION__);
+
+	return 0;
+
+out_free_minors:
+	sunserial_unregister_minors(&vldc_uart_driver_reg, 1);
+
+out_free_lp:
+	ldc_free(vldc_port->lp);
+
+out_free_vldc:
+	kfree(vldc_port);
+
+	return -ENODEV;
+}
+
+static int __devexit vldc_remove(struct vio_dev *vdev)
+{
+	vldc_port_t *vldc_port = dev_get_drvdata(&vdev->dev);
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	uart_remove_one_port(&vldc_uart_driver_reg, &vldc_port->port);
+	sunserial_unregister_minors(&vldc_uart_driver_reg, 1);
+	ldc_free(vldc_port->lp);
+	kfree(vldc_port);
+
+	return 0;
+}
+
+static struct vio_device_id vldc_match[] = {
+	{
+		.type = "vldc-port",
+	},
+	{},
+};
+
+static struct vio_driver vc_driver = {
+	.id_table	= vldc_match,
+	.probe		= vldc_probe,
+	.remove		= vldc_remove,
+	.driver		= {
+		.name	= "vldc-ipmi",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init vldc_init(void)
+{
+	if (tlb_type != hypervisor)
+		return -ENODEV;
+
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	return vio_register_driver(&vc_driver);
+}
+
+static void __exit vldc_exit(void)
+{
+	VLDC_DEBUG(KERN_INFO "VLDC: %s.\n", __FUNCTION__);
+
+	vio_unregister_driver(&vc_driver);
+}
+
+module_init(vldc_init);
+module_exit(vldc_exit);
+
+MODULE_AUTHOR("Wind River Systems");
+MODULE_DESCRIPTION("SUN4V virtual channel driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

