From b99ef00745d7e6f7bb0ce06950a34b9e71470996 Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Wed, 3 Sep 2008 18:38:28 -0400
Subject: [PATCH] serial use poll for console

Add code to do most of the serial port console handling in the serial
core layer instead of in each individual driver.  This requires that
the driver implement the poll interface.

Signed-off-by: Corey Minyard <minyard@acm.org>
Integrated-by: Jonathan Fournier <jonathan.fournier@windriver.com>
Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 Documentation/serial/driver  |   57 ++++++++++-
 drivers/serial/serial_core.c |  208 +++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 252 insertions(+), 13 deletions(-)

diff --git a/Documentation/serial/driver b/Documentation/serial/driver
index 7faef42..cf97f39 100644
--- a/Documentation/serial/driver
+++ b/Documentation/serial/driver
@@ -24,14 +24,43 @@ console support.
 Console Support
 ---------------
 
-The serial core provides a few helper functions.  This includes identifing
-the correct port structure (via uart_get_console) and decoding command line
-arguments (uart_parse_options).
+If the driver provides the poll functions, the serial core will
+provide most of the console handling for it.  Beyond the poll
+routines, the driver must do the following:
 
-There is also a helper function (uart_write_console) which performs a
-character by character write, translating newlines to CRLF sequences.
-Driver writers are recommended to use this function rather than implementing
-their own version.
+  * #define SUPPORT_SYSRQ before including serial_core.h if the
+    console is enabled and CONFIG_MAGIC_SYSRQ is defined.
+
+  * Add the following code (replacing xxx with your driver name):
+
+#ifdef CONFIG_SERIAL_xxx_CONSOLE
+static struct console xxx_console = {
+	.name		= "ttyS"
+};
+#define xxx_CONSOLE	&xxx_console
+#else
+#define xxx_CONSOLE	NULL
+#endif
+
+
+static struct uart_driver xxx_reg
+{
+	.....
+	.cons = xxx_CONSOLE
+}
+
+static int __init xxx_polled_init(void)
+{
+	... Set up the ports to work polled at this point in time.
+
+	uart_register_polled(&xxx_reg);
+
+	return 0;
+}
+console_initcall(xxx_polled_init);
+
+This is the preferred method, as it allows the driver to work polled
+and as a console.
 
 
 Locking
@@ -428,6 +457,20 @@ uart_add_one_port()
 
 uart_remove_one_port()
 
+uart_register_polled()
+	Register a driver to work as a polled driver and possibly
+	a console (if configured as such).
+
+	Locking: none
+	Interrupts: enabled
+
+uart_unregister_polled()
+	Remove a polled registration.  If the driver was a console,
+	the next console in line will be used.
+
+	Locking: none
+	Interrupts: enabled
+
 Other notes
 -----------
 
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 82e7439..80064a8 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -53,6 +53,7 @@ static struct lock_class_key port_lock_key;
 #define uart_users(state)	((state)->count + ((state)->info ? (state)->info->port.blocked_open : 0))
 
 #ifdef CONFIG_SERIAL_CORE_CONSOLE
+#include <linux/nmi.h>
 #define uart_console(port)	((port)->cons && (port)->cons->index == (port)->line)
 #else
 #define uart_console(port)	(0)
@@ -463,18 +464,27 @@ uart_change_speed(struct uart_state *state, struct ktermios *old_termios)
 static inline int
 __uart_put_char(struct uart_port *port, struct circ_buf *circ, unsigned char c)
 {
-	unsigned long flags;
 	int ret = 0;
 
-	if (!circ->buf)
-		return 0;
-
-	spin_lock_irqsave(&port->lock, flags);
 	if (uart_circ_chars_free(circ) != 0) {
 		circ->buf[circ->head] = c;
 		circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);
 		ret = 1;
 	}
+	return ret;
+}
+
+static inline int
+_uart_put_char(struct uart_port *port, struct circ_buf *circ, unsigned char c)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	if (!circ->buf)
+		return 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+	ret =  __uart_put_char(port, circ, c);
 	spin_unlock_irqrestore(&port->lock, flags);
 	return ret;
 }
@@ -483,7 +493,7 @@ static int uart_put_char(struct tty_struct *tty, unsigned char ch)
 {
 	struct uart_state *state = tty->driver_data;
 
-	return __uart_put_char(state->port, &state->info->xmit, ch);
+	return _uart_put_char(state->port, &state->info->xmit, ch);
 }
 
 static void uart_flush_chars(struct tty_struct *tty)
@@ -1998,6 +2008,175 @@ uart_set_options(struct uart_port *port, struct console *co,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(uart_set_options);
+
+static void uartdrv_console_write(struct console *co, const char *s,
+				  unsigned count)
+{
+	struct uart_driver *drv = co->data;
+	struct uart_port *port = drv->pollable_ports[co->index];
+	unsigned long flags, pstate;
+	struct circ_buf *circ;
+	int rv;
+	int locked = 1;
+	int tmout;
+	int free;
+
+	touch_nmi_watchdog();
+
+	if (count == 0)
+		return;
+
+	if (port->sysrq || oops_in_progress)
+		locked = spin_trylock_irqsave(&port->lock, flags);
+	else
+		spin_lock_irqsave(&port->lock, flags);
+
+	circ = &port->info->xmit;
+
+	rv = port->ops->poll_startup(port, &pstate);
+	if (rv)
+		goto out_err;
+
+	tmout = 10000;
+	while (count > 0) {
+		port->ops->poll(port, UART_POLL_FLAGS_TX);
+
+		free = uart_circ_chars_free(circ);
+
+		if (free) {
+			if (*s == '\n') {
+				if (free < 2)
+					goto do_timer;
+				__uart_put_char(port, circ, '\r');
+				free--;
+			}
+			__uart_put_char(port, circ, *s);
+			tmout = 10000;
+			count--;
+			free--;
+			s++;
+			continue;
+		}
+
+	do_timer:
+		if (--tmout > 0) {
+			udelay(1);
+			continue;
+		}
+
+		if (port->ops->in_flow_control &&
+					(port->flags & UPF_CONS_FLOW)) {
+			/* Wait up to 1s for flow control. */
+			tmout = 1000000;
+			while (port->ops->in_flow_control(port)) {
+				if (--tmout == 0)
+					break;
+				udelay(1);
+				touch_nmi_watchdog();
+			}
+		}
+
+		port->ops->poll(port, UART_POLL_FLAGS_TX);
+		if (uart_circ_chars_free(circ) == 0) {
+			/*
+			 * We have timed out this character,
+			 * just go on.
+			 */
+			s++;
+			count--;
+		}
+		tmout = 10000;
+	}
+
+	/*
+	 * All the characters are in the buffer, wait for transmit to
+	 * finish.
+	 */
+
+	tmout = 10000;
+	free = uart_circ_chars_free(circ);
+	while ((free > 0) || !port->ops->tx_empty(port)) {
+		port->ops->poll(port, UART_POLL_FLAGS_TX);
+
+		if (free != uart_circ_chars_free(circ)) {
+			tmout = 10000;
+			free = uart_circ_chars_free(circ);
+			continue;
+		}
+		if (--tmout == 0)
+			break;
+		udelay(1);
+	}
+
+	port->ops->poll_shutdown(port, pstate);
+
+ out_err:
+
+	if (locked)
+		spin_unlock_irqrestore(&port->lock, flags);
+
+	/*
+	 * If the port is running something else, we may have opened
+	 * up some transmit space for it while writing the console, so
+	 * tell it that it may be able to write now.
+	 *
+	 * Note that this won't work with a direct serial driver, but
+	 * you shouldn't be running a console on the same port as a
+	 * direct serial driver, anyway.
+	 */
+	if (port->info->flags & UIF_INITIALIZED)
+		uart_write_wakeup(port);
+}
+
+static char console_buffer[UART_XMIT_SIZE];
+static struct uart_info console_info;
+
+static int uartdrv_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	struct uart_info *info;
+	struct uart_driver *drv = co->data;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	int rv;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= drv->nr_pollable)
+		co->index = 0;
+	port = drv->pollable_ports[co->index];
+
+	if (!port || (!port->iobase && !port->membase))
+		return -ENODEV;
+
+	if (port->ops->port_defaults) {
+		rv = port->ops->port_defaults(port, &baud, &parity, &bits,
+					      &flow);
+		if (rv)
+			return rv;
+	}
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	rv = uart_set_options(port, co, baud, parity, bits, flow);
+	if (rv)
+		return rv;
+
+	info = &console_info;
+	port->info = info;
+	info->xmit.buf = console_buffer;
+	info->flags |= UIF_BOOT_ALLOCATED;
+	uart_circ_clear(&info->xmit);
+	init_waitqueue_head(&info->port.open_wait);
+	init_waitqueue_head(&info->delta_msr_wait);
+	return 0;
+}
 #endif /* CONFIG_SERIAL_CORE_CONSOLE */
 
 static void uart_change_pm(struct uart_state *state, int pm_state)
@@ -2361,6 +2540,19 @@ static const struct tty_operations uart_ops = {
  */
 void uart_register_polled(struct uart_driver *drv)
 {
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+	if (drv->nr_pollable && drv->cons &&
+					!(drv->cons->flags & CON_ENABLED)) {
+		/* We manage the consoles for this driver. */
+		drv->cons->write = uartdrv_console_write;
+		drv->cons->device = uart_console_device;
+		drv->cons->setup = uartdrv_console_setup;
+		drv->cons->flags = CON_PRINTBUFFER;
+		drv->cons->data = drv;
+		drv->cons->index = -1;
+		register_console(drv->cons);
+	}
+#endif
 }
 EXPORT_SYMBOL(uart_register_polled);
 
@@ -2371,6 +2563,10 @@ EXPORT_SYMBOL(uart_register_polled);
  */
 void uart_unregister_polled(struct uart_driver *drv)
 {
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+	if (drv->nr_pollable && drv->cons)
+		unregister_console(drv->cons);
+#endif
 }
 EXPORT_SYMBOL(uart_unregister_polled);
 
