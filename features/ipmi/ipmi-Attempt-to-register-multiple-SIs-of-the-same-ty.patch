From e98c74eaf372e2f74f5b4f6253dc5e7d105352a0 Mon Sep 17 00:00:00 2001
From: Matthew Garrett <mjg@redhat.com>
Date: Mon, 3 May 2010 13:37:45 +0000
Subject: [PATCH 7/8] ipmi: Attempt to register multiple SIs of the same type

Some odd systems may have multiple BMCs, and we want to be able to support
them. Let's make the assumption that if a system legitimately has multiple
BMCs then each BMC's SI will be of the same type, and also that we won't
see multiple SIs of the same type unless we have multiple BMCs. If these
hold true then we should register all SIs of the same type.

Signed-off-by: Matthew Garrett <mjg@redhat.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
---
 drivers/char/ipmi/ipmi_si_intf.c |   28 +++++++++++++++++++++-------
 1 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
index 12634d0..d59e331 100644
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -3279,6 +3279,7 @@ static __devinit int init_ipmi_si(void)
 	char *str;
 	int  rv;
 	struct smi_info *e;
+	enum ipmi_addr_src type = SI_INVALID;
 
 	if (initialized)
 		return 0;
@@ -3345,30 +3346,43 @@ static __devinit int init_ipmi_si(void)
 	of_register_platform_driver(&ipmi_of_platform_driver);
 #endif
 
-	/* Try to register something with interrupts first */
+	/* We prefer devices with interrupts, but in the case of a machine
+	   with multiple BMCs we assume that there will be several instances
+	   of a given type so if we succeed in registering a type then also
+	   try to register everything else of the same type */
 
 	mutex_lock(&smi_infos_lock);
 	list_for_each_entry(e, &smi_infos, link) {
-		if (e->irq) {
+		/* Try to register a device if it has an IRQ and we either
+		   haven't successfully registered a device yet or this
+		   device has the same type as one we successfully registered */
+		if (e->irq && (!type || e->addr_source == type)) {
 			if (!try_smi_init(e)) {
-				mutex_unlock(&smi_infos_lock);
-				return 0;
+				type = e->addr_source;
 			}
 		}
 	}
 
+	/* type will only have been set if we successfully registered an si */
+	if (type) {
+		mutex_unlock(&smi_infos_lock);
+		return 0;
+	}
+
 	/* Fall back to the preferred device */
 
 	list_for_each_entry(e, &smi_infos, link) {
-		if (!e->irq) {
+		if (!e->irq && (!type || e->addr_source == type)) {
 			if (!try_smi_init(e)) {
-				mutex_unlock(&smi_infos_lock);
-				return 0;
+				type = e->addr_source;
 			}
 		}
 	}
 	mutex_unlock(&smi_infos_lock);
 
+	if (type)
+		return 0;
+
 	if (si_trydefaults) {
 		mutex_lock(&smi_infos_lock);
 		if (list_empty(&smi_infos)) {
-- 
1.6.5.2

