From 35de76ee4c4f2fda1f38be71d429ebadda347afb Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Thu, 28 Aug 2008 08:25:40 -0400
Subject: [PATCH] serial marvell polled mode

Convert the MPSC serial code to use the polled interface required
by the IPMI serial driver.

Signed-off-by: Corey Minyard <minyard@acm.org>
Integrated-by: Jonathan Fournier <jonathan.fournier@windriver.com>
---
 drivers/serial/mpsc.c |  233 ++++++++++++++++++++++---------------------------
 1 files changed, 104 insertions(+), 129 deletions(-)

diff --git a/drivers/serial/mpsc.c b/drivers/serial/mpsc.c
index 3316fd1..160268c 100644
--- a/drivers/serial/mpsc.c
+++ b/drivers/serial/mpsc.c
@@ -57,8 +57,6 @@
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/console.h>
@@ -936,7 +934,6 @@ static int serial_polled;
 static int mpsc_rx_intr(struct mpsc_port_info *pi)
 {
 	struct mpsc_rx_desc *rxre;
-	struct tty_struct *tty = pi->port.info->port.tty;
 	u32	cmdstat, bytes_in, i;
 	int	rc = 0;
 	u8	*bp;
@@ -966,16 +963,6 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 			return 0;
 		}
 #endif
-		/* Following use of tty struct directly is deprecated */
-		if (unlikely(tty_buffer_request_room(tty, bytes_in)
-					< bytes_in)) {
-			if (tty->low_latency)
-				tty_flip_buffer_push(tty);
-			/*
-			 * If this failed then we will throw away the bytes
-			 * but must do so to clear interrupts.
-			 */
-		}
 
 		bp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);
 		dma_cache_sync(pi->port.dev, (void *)bp, MPSC_RXBE_SIZE,
@@ -1017,8 +1004,6 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 				flag = TTY_BREAK;
 			else if (cmdstat & SDMA_DESC_CMDSTAT_FR)
 				flag = TTY_FRAME;
-			else if (cmdstat & SDMA_DESC_CMDSTAT_OR)
-				flag = TTY_OVERRUN;
 			else if (cmdstat & SDMA_DESC_CMDSTAT_PE)
 				flag = TTY_PARITY;
 		}
@@ -1039,10 +1024,14 @@ static int mpsc_rx_intr(struct mpsc_port_info *pi)
 						| SDMA_DESC_CMDSTAT_FR
 						| SDMA_DESC_CMDSTAT_OR)))
 				&& !(cmdstat & pi->port.ignore_status_mask)) {
-			tty_insert_flip_char(tty, *bp, flag);
+			uart_insert_char(&pi->port, cmdstat,
+					 SDMA_DESC_CMDSTAT_OR,
+					 *bp, flag);
 		} else {
 			for (i=0; i<bytes_in; i++)
-				tty_insert_flip_char(tty, *bp++, TTY_NORMAL);
+				uart_insert_char(&pi->port, cmdstat,
+						 SDMA_DESC_CMDSTAT_OR,
+						 *bp++, flag);
 
 			pi->port.icount.rx += bytes_in;
 		}
@@ -1080,9 +1069,6 @@ next_frame:
 	if ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)
 		mpsc_start_rx(pi);
 
-	spin_unlock(&pi->port.lock);
-	tty_flip_buffer_push(tty);
-	spin_lock(&pi->port.lock);
 	return rc;
 }
 
@@ -1224,8 +1210,12 @@ static irqreturn_t mpsc_sdma_intr(int irq, void *dev_id)
 
 	spin_lock_irqsave(&pi->port.lock, iflags);
 	mpsc_sdma_intr_ack(pi);
-	if (mpsc_rx_intr(pi))
+	if (mpsc_rx_intr(pi)) {
 		rc = IRQ_HANDLED;
+		spin_unlock(&pi->port.lock);
+		uart_push(&pi->port);
+		spin_lock(&pi->port.lock);
+	}
 	if (mpsc_tx_intr(pi))
 		rc = IRQ_HANDLED;
 	spin_unlock_irqrestore(&pi->port.lock, iflags);
@@ -1664,6 +1654,60 @@ static void mpsc_put_poll_char(struct uart_port *port,
 }
 #endif
 
+static void mpsc_poll(struct uart_port *port, unsigned int flags)
+{
+	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
+
+	if (flags & UART_POLL_FLAGS_TX) {
+		mpsc_sdma_intr_ack(pi);
+		mpsc_tx_intr(pi);
+	}
+	if (flags & UART_POLL_FLAGS_RX)
+		mpsc_rx_intr(pi);
+}
+
+static int mpsc_poll_startup(struct uart_port *port, unsigned long *pflags)
+{
+	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
+
+	while (pi->txr_head != pi->txr_tail) {
+		while (mpsc_sdma_tx_active(pi))
+			udelay(100);
+		mpsc_sdma_intr_ack(pi);
+		mpsc_tx_intr(pi);
+	}
+
+	while (mpsc_sdma_tx_active(pi))
+		udelay(100);
+
+	return 0;
+}
+
+static void mpsc_poll_shutdown(struct uart_port *port, unsigned long pflags)
+{
+	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
+
+	mpsc_sdma_intr_ack(pi);
+}
+
+static int mpsc_in_flow_control(struct uart_port *port)
+{
+	return 0;
+}
+
+static int mpsc_port_defaults(struct uart_port *port, int *baud, int *parity,
+			      int *bits, int *flow)
+{
+	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
+
+	*baud = pi->default_baud;
+	*bits = pi->default_bits;
+	*parity = pi->default_parity;
+	*flow = pi->default_flow;
+
+	return 0;
+}
+
 static struct uart_ops mpsc_pops = {
 	.tx_empty	= mpsc_tx_empty,
 	.set_mctrl	= mpsc_set_mctrl,
@@ -1676,6 +1720,11 @@ static struct uart_ops mpsc_pops = {
 	.startup	= mpsc_startup,
 	.shutdown	= mpsc_shutdown,
 	.set_termios	= mpsc_set_termios,
+	.poll		= mpsc_poll,
+	.poll_startup	= mpsc_poll_startup,
+	.poll_shutdown	= mpsc_poll_shutdown,
+	.in_flow_control = mpsc_in_flow_control,
+	.port_defaults	= mpsc_port_defaults,
 	.type		= mpsc_type,
 	.release_port	= mpsc_release_port,
 	.request_port	= mpsc_request_port,
@@ -1696,120 +1745,14 @@ static struct uart_ops mpsc_pops = {
  */
 
 #ifdef CONFIG_SERIAL_MPSC_CONSOLE
-static void mpsc_console_write(struct console *co, const char *s, uint count)
-{
-	struct mpsc_port_info *pi = &mpsc_ports[co->index];
-	u8 *bp, *dp, add_cr = 0;
-	int i;
-	unsigned long iflags;
-
-	spin_lock_irqsave(&pi->tx_lock, iflags);
-
-	while (pi->txr_head != pi->txr_tail) {
-		while (mpsc_sdma_tx_active(pi))
-			udelay(100);
-		mpsc_sdma_intr_ack(pi);
-		mpsc_tx_intr(pi);
-	}
-
-	while (mpsc_sdma_tx_active(pi))
-		udelay(100);
-
-	while (count > 0) {
-		bp = dp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);
-
-		for (i = 0; i < MPSC_TXBE_SIZE; i++) {
-			if (count == 0)
-				break;
-
-			if (add_cr) {
-				*(dp++) = '\r';
-				add_cr = 0;
-			} else {
-				*(dp++) = *s;
-
-				if (*(s++) == '\n') { /* add '\r' after '\n' */
-					add_cr = 1;
-					count++;
-				}
-			}
-
-			count--;
-		}
-
-		dma_cache_sync(pi->port.dev, (void *)bp, MPSC_TXBE_SIZE,
-				DMA_BIDIRECTIONAL);
-#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
-		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
-			flush_dcache_range((ulong)bp,
-					(ulong)bp + MPSC_TXBE_SIZE);
-#endif
-		mpsc_setup_tx_desc(pi, i, 0);
-		pi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);
-		mpsc_sdma_start_tx(pi);
-
-		while (mpsc_sdma_tx_active(pi))
-			udelay(100);
-
-		pi->txr_tail = (pi->txr_tail + 1) & (MPSC_TXR_ENTRIES - 1);
-	}
-
-	spin_unlock_irqrestore(&pi->tx_lock, iflags);
-}
-
-static int __init mpsc_console_setup(struct console *co, char *options)
-{
-	struct mpsc_port_info *pi;
-	int baud, bits, parity, flow;
-
-	pr_debug("mpsc_console_setup[%d]: options: %s\n", co->index, options);
-
-	if (co->index >= MPSC_NUM_CTLRS)
-		co->index = 0;
-
-	pi = &mpsc_ports[co->index];
-
-	baud = pi->default_baud;
-	bits = pi->default_bits;
-	parity = pi->default_parity;
-	flow = pi->default_flow;
-
-	if (!pi->port.ops)
-		return -ENODEV;
-
-	spin_lock_init(&pi->port.lock);	/* Temporary fix--copied from 8250.c */
-
-	if (options)
-		uart_parse_options(options, &baud, &parity, &bits, &flow);
-
-	return uart_set_options(&pi->port, co, baud, parity, bits, flow);
-}
-
 static struct console mpsc_console = {
 	.name	= MPSC_DEV_NAME,
-	.write	= mpsc_console_write,
-	.device	= uart_console_device,
-	.setup	= mpsc_console_setup,
-	.flags	= CON_PRINTBUFFER,
-	.index	= -1,
-	.data	= &mpsc_reg,
 };
-
-static int __init mpsc_late_console_init(void)
-{
-	pr_debug("mpsc_late_console_init: Enter\n");
-
-	if (!(mpsc_console.flags & CON_ENABLED))
-		register_console(&mpsc_console);
-	return 0;
-}
-
-late_initcall(mpsc_late_console_init);
-
 #define MPSC_CONSOLE	&mpsc_console
 #else
 #define MPSC_CONSOLE	NULL
 #endif
+
 /*
  ******************************************************************************
  *
@@ -1942,9 +1885,35 @@ static struct uart_driver mpsc_reg = {
 	.major		= MPSC_MAJOR,
 	.minor		= MPSC_MINOR_START,
 	.nr		= MPSC_NUM_CTLRS,
-	.cons		= MPSC_CONSOLE,
 };
 
+struct mpsc_port_info *pid;
+static struct uart_port *mpsc_pollable_ports[MPSC_NUM_CTLRS];
+
+static void mpsc_polled_init(void)
+{
+	int i;
+
+	pid = &mpsc_ports[0];
+	pr_debug("mpsc_polled_init: Enter\n");
+
+	for (i = 0; i < MPSC_NUM_CTLRS; i++) {
+		/* Temporary fix--copied from 8250.c */
+		spin_lock_init(&mpsc_ports[i].port.lock);
+
+		mpsc_ports[i].port.ops = &mpsc_pops;
+		mpsc_pollable_ports[i] = &mpsc_ports[i].port;
+	}
+	mpsc_reg.pollable_ports = mpsc_pollable_ports;
+	mpsc_reg.nr_pollable = MPSC_NUM_CTLRS;
+	/*
+	 * Wait until here to set cons, so the uart_add_one_port calls
+	 * won't do a console add before we are ready.
+	 */
+	mpsc_reg.cons = MPSC_CONSOLE;
+	uart_register_polled(&mpsc_reg);
+}
+
 static int mpsc_drv_map_regs(struct mpsc_port_info *pi,
 		struct platform_device *pd)
 {
@@ -2037,6 +2006,7 @@ static void mpsc_drv_get_platform_data(struct mpsc_port_info *pi,
 	pi->port.membase = pi->mpsc_base;
 	pi->port.mapbase = (ulong)pi->mpsc_base;
 	pi->port.ops = &mpsc_pops;
+	pi->port.dev = &pd->dev;
 
 	pi->mirror_regs = pdata->mirror_regs;
 	pi->cache_mgmt = pdata->cache_mgmt;
@@ -2089,6 +2059,8 @@ static int mpsc_drv_probe(struct platform_device *dev)
 		}
 	}
 
+	mpsc_polled_init();
+
 	return rc;
 }
 
@@ -2130,9 +2102,11 @@ static int __init mpsc_drv_init(void)
 			if ((rc = platform_driver_register(&mpsc_driver))) {
 				platform_driver_unregister(&mpsc_shared_driver);
 				uart_unregister_driver(&mpsc_reg);
+				uart_unregister_polled(&mpsc_reg);
 			}
 		} else {
 			uart_unregister_driver(&mpsc_reg);
+			uart_unregister_polled(&mpsc_reg);
 		}
 	}
 
@@ -2144,6 +2118,7 @@ static void __exit mpsc_drv_exit(void)
 	platform_driver_unregister(&mpsc_driver);
 	platform_driver_unregister(&mpsc_shared_driver);
 	uart_unregister_driver(&mpsc_reg);
+	uart_unregister_polled(&mpsc_reg);
 	memset(mpsc_ports, 0, sizeof(mpsc_ports));
 	memset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));
 }
-- 
1.5.5.1

