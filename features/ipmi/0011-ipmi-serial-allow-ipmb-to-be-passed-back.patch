From c539cfaaa99927372c3be5ec8d32e46eee881a3b Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Wed, 3 Sep 2008 18:38:35 -0400
Subject: [PATCH] ipmi serial allow ipmb to be passed back

Allow the serial codecs to pass up the IPMI slave address of the
BMC if they know about it.

Signed-off-by: Corey Minyard <minyard@acm.org>
Integrated-by: Jonathan Fournier <jonathan.fournier@windriver.com>
---
 drivers/char/ipmi/ipmi_serial.c               |    9 +++++++--
 drivers/char/ipmi/ipmi_serial_direct.c        |    2 +-
 drivers/char/ipmi/ipmi_serial_radisys_ascii.c |    6 +++---
 drivers/char/ipmi/ipmi_serial_terminal_mode.c |    2 +-
 include/linux/ipmi_serial_sm.h                |    4 +++-
 5 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/char/ipmi/ipmi_serial.c b/drivers/char/ipmi/ipmi_serial.c
index 6126571..4c966e1 100644
--- a/drivers/char/ipmi/ipmi_serial.c
+++ b/drivers/char/ipmi/ipmi_serial.c
@@ -1443,12 +1443,17 @@ static int try_get_dev_id(struct ipmi_serial_info *info)
 	return rv;
 }
 
-void ipmi_serial_ll_init_complete(struct ipmi_serial_info *info, int err)
+void ipmi_serial_ll_init_complete(struct ipmi_serial_info *info,
+				  unsigned char slave_addr,
+				  int err)
 {
 	if (err)
 		info->init_status = err;
-	else
+	else {
+		if (slave_addr)
+			info->slave_addr = slave_addr;
 		info->init_status = 1;
+	}
 }
 EXPORT_SYMBOL(ipmi_serial_ll_init_complete);
 
diff --git a/drivers/char/ipmi/ipmi_serial_direct.c b/drivers/char/ipmi/ipmi_serial_direct.c
index 8d02f19..e59cfca 100644
--- a/drivers/char/ipmi/ipmi_serial_direct.c
+++ b/drivers/char/ipmi/ipmi_serial_direct.c
@@ -387,7 +387,7 @@ static int sd_init(struct ipmi_serial_codec_data *data,
 	 * Nothing to do.  The upper layer will do a message to test
 	 * the interface.
 	 */
-	ipmi_serial_ll_init_complete(data->info, 0);
+	ipmi_serial_ll_init_complete(data->info, 0, 0);
 	return 0;
 }
 
diff --git a/drivers/char/ipmi/ipmi_serial_radisys_ascii.c b/drivers/char/ipmi/ipmi_serial_radisys_ascii.c
index f0474ea..be4f980 100644
--- a/drivers/char/ipmi/ipmi_serial_radisys_ascii.c
+++ b/drivers/char/ipmi/ipmi_serial_radisys_ascii.c
@@ -363,7 +363,7 @@ static void handle_init_getipmbaddr(struct ipmi_serial_codec_data *data,
 			spin_unlock_irqrestore(&data->lock, flags);
 		} else {
 			spin_unlock_irqrestore(&data->lock, flags);
-			ipmi_serial_ll_init_complete(data->info, -EINVAL);
+			ipmi_serial_ll_init_complete(data->info, 0, -EINVAL);
 		}
 		return;
 	}
@@ -372,7 +372,7 @@ static void handle_init_getipmbaddr(struct ipmi_serial_codec_data *data,
 	data->recv_msg_handler = NULL;
 	data->handshake_done = 1;
 	spin_unlock_irqrestore(&data->lock, flags);
-	ipmi_serial_ll_init_complete(data->info, 0);
+	ipmi_serial_ll_init_complete(data->info, data->bmc_i2c_addr, 0);
 }
 
 static int ra_init(struct ipmi_serial_codec_data *data,
@@ -556,7 +556,7 @@ static void ra_timer_tick(struct ipmi_serial_codec_data *data,
 		if (data->handshake_retries_left <= 0) {
 			data->handshake_done = 1;
 			spin_unlock_irqrestore(&data->lock, flags);
-			ipmi_serial_ll_init_complete(data->info, -ETIMEDOUT);
+			ipmi_serial_ll_init_complete(data->info, 0, -ETIMEDOUT);
 			goto out;
 		}
 
diff --git a/drivers/char/ipmi/ipmi_serial_terminal_mode.c b/drivers/char/ipmi/ipmi_serial_terminal_mode.c
index 5b49ce6..b61a547 100644
--- a/drivers/char/ipmi/ipmi_serial_terminal_mode.c
+++ b/drivers/char/ipmi/ipmi_serial_terminal_mode.c
@@ -422,7 +422,7 @@ static void try_to_send_data(struct ipmi_serial_codec_data *data)
 
 static void finish_init(struct ipmi_serial_codec_data *data, int err)
 {
-	ipmi_serial_ll_init_complete(data->info, err);
+	ipmi_serial_ll_init_complete(data->info, 0, err);
 }
 
 /*
diff --git a/include/linux/ipmi_serial_sm.h b/include/linux/ipmi_serial_sm.h
index 4333094..925666c 100644
--- a/include/linux/ipmi_serial_sm.h
+++ b/include/linux/ipmi_serial_sm.h
@@ -193,9 +193,11 @@ struct ipmi_serial_codec {
 };
 
 /*
- * Called by the lower layer when initialization is complete.
+ * Called by the lower layer when initialization is complete.  Pass
+ * in zero as the slave_addr if you are unable to compute it.
  */
 extern void ipmi_serial_ll_init_complete(struct ipmi_serial_info *info,
+					 unsigned char slave_addr,
 					 int err);
 
 /*
-- 
1.5.5.1

