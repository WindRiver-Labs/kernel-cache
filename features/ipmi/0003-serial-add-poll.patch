From 4e2d9d157332e02e1aa043b65bee02beda5fa19b Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Wed, 3 Sep 2008 18:38:27 -0400
Subject: [PATCH] serial add poll

Add a poll interface to the serial code.  The interface is
unfortunately complex (more than just a new "poll" call in the
interface) because of several requirements of the console code.  This
interface adds the following function variables:

 poll_startup, poll_shutdown: Configure and release for polling.
 poll: The actual call to do polling.
 in_flow_control: Check CTS
 port_defaults: Return reasonable defaults.

With these added calls, it should be possible for the serial console,
kgdb, and the IPMI driver to share this interface to the serial port.

This patch adds the interfaces for the individual drivers, more to
come to add the console and upper layer interfaces.

Signed-off-by: Corey Minyard <minyard@acm.org>
Integrated-by: Jonathan Fournier <jonathan.fournier@windriver.com>
---
 Documentation/serial/driver  |   46 ++++++++++++++++++++++++
 drivers/serial/serial_core.c |   81 +++++++++++++++++++++++++++++++++++-------
 include/linux/serial_core.h  |   75 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 187 insertions(+), 15 deletions(-)

diff --git a/Documentation/serial/driver b/Documentation/serial/driver
index 77ba0af..7faef42 100644
--- a/Documentation/serial/driver
+++ b/Documentation/serial/driver
@@ -307,6 +307,52 @@ hardware.
 	Locking: none.
 	Interrupts: caller dependent.
 
+  poll_startup(port,&rstate)
+	Set up the port to do polling.  The driver should go into a
+	state where it can be polled with the poll() call.  It may store
+	state information in rstate (a long value); that will be passed
+	to the corresponding poll_shutdown call.   The caller
+        must call this before calling the poll routine and this is
+	called with the port lock held and interrupts off.  The caller
+	is not allowed to release the port lock or re-enable
+	interrupts until after poll_shutdown is called.
+	If polling is not implemented, this does not need to be supplied.
+
+  poll_shutdown(port,state)
+	The driver will no longer be polled.  The state information is
+	the same value return in the rstate value of poll_startup.
+	If polling is not implemented, this does not need to be supplied.
+
+  poll(port, flags)
+	Poll the device for data.  This should work much like an
+	interrupt routine, except it should only check the flags
+	passed in, not everything.  The flags are:
+		UART_POLL_FLAGS_RX - poll for received data
+		UART_POLL_FLAGS_TX - poll for transmitted data
+		UART_POLL_FLAGS_MCTRL - poll for modem control
+	The poll routine should do the "normal" thing for received
+	data and modem control.  For transmit data, it should only
+	transmit data from the circ buffer and not do any flow
+	control or whatnot.
+	If polling is not implemented, this does not need to be supplied.
+
+  in_flow_control(port)
+	This should return true if the port is in flow control (CTS
+	is not asserted) and false if not.  This is only called from
+	a poll context.
+	If polling is not implemented, this does not need to be supplied.
+
+  port_default(port,&baud,&parity,&bits,&flow)
+	Return defaults for the console serial port.  This is so firmware
+	console settings can be transferred to the serial driver and it
+	can use the same values as the firmware.  baud and bits are number
+	values.  parity is of of the following characters: 'n', 'o', 'e'.
+	flow should be 'r' to turn on cts/rts flow control, or a space
+	to do nothing.
+	If polling or serial console is not implemented, this does not
+	need to be supplied.  It function is optional, if not supplied the
+	console will default to 9600n81.
+
 Other functions
 ---------------
 
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 73e9b8f..82e7439 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -75,7 +75,8 @@ void uart_write_wakeup(struct uart_port *port)
 	 * closed.  No cookie for you.
 	 */
 	BUG_ON(!info);
-	tasklet_schedule(&info->tlet);
+	if (info->flags & UIF_TASKLET_SETUP)
+		tasklet_schedule(&info->tlet);
 }
 
 static void uart_stop(struct tty_struct *tty)
@@ -253,12 +254,15 @@ static void uart_shutdown(struct uart_state *state)
 	/*
 	 * kill off our tasklet
 	 */
-	tasklet_kill(&info->tlet);
+	if (info->flags & UIF_TASKLET_SETUP) {
+		info->flags &= ~UIF_TASKLET_SETUP;
+		tasklet_kill(&info->tlet);
+	}
 
 	/*
 	 * Free the transmit buffer page.
 	 */
-	if (info->xmit.buf) {
+	if (info->xmit.buf && !(info->flags & UIF_BOOT_ALLOCATED)) {
 		free_page((unsigned long)info->xmit.buf);
 		info->xmit.buf = NULL;
 	}
@@ -1568,8 +1572,22 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 	/* We should move this into the uart_state structure and kill off
 	   this whole complexity */
 	if (!state->info) {
-		state->info = kzalloc(sizeof(struct uart_info), GFP_KERNEL);
-		if (state->info) {
+		/*
+		 * This code is convoluted because the console code
+		 * (and other polled users) needs to set up an info
+		 * structure, but it can't set up the tasklet.
+		 */
+		if (state->port->info)
+			/* Already there from the console code. */
+			state->info = state->port->info;
+		else {
+			state->info = kzalloc(sizeof(struct uart_info),
+					      GFP_KERNEL);
+			if (!state->info) {
+				ret = -ENOMEM;
+				goto err_unlock;
+			}
+
 			init_waitqueue_head(&state->info->port.open_wait);
 			init_waitqueue_head(&state->info->delta_msr_wait);
 
@@ -1578,13 +1596,16 @@ static struct uart_state *uart_get(struct uart_driver *drv, int line)
 			 */
 			state->port->info = state->info;
 
-			tasklet_init(&state->info->tlet, uart_tasklet_action,
-				     (unsigned long)state);
-		} else {
-			ret = -ENOMEM;
-			goto err_unlock;
 		}
+
 	}
+
+	if (!(state->info->flags & UIF_TASKLET_SETUP)) {
+		tasklet_init(&state->info->tlet, uart_tasklet_action,
+			     (unsigned long)state);
+		state->info->flags |= UIF_TASKLET_SETUP;
+	}
+
 	return state;
 
  err_unlock:
@@ -2331,6 +2352,29 @@ static const struct tty_operations uart_ops = {
 };
 
 /**
+ *	uart_register_polled - register a driver to be used as a polled device
+ *	@drv: low level driver structure
+ *
+ *	Register a uart driver with the polled driver interface.  This
+ *	means that things that need polled I/O can use the driver at this
+ *	point.
+ */
+void uart_register_polled(struct uart_driver *drv)
+{
+}
+EXPORT_SYMBOL(uart_register_polled);
+
+/**
+ *	uart_unregister_polled - unregister a driver previously registered
+ *      as a polled device
+ *	@drv: low level driver structure
+ */
+void uart_unregister_polled(struct uart_driver *drv)
+{
+}
+EXPORT_SYMBOL(uart_unregister_polled);
+
+/**
  *	uart_register_driver - register a driver with the uart core layer
  *	@drv: low level driver structure
  *
@@ -2459,7 +2503,16 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 	state->pm_state = -1;
 
 	port->cons = drv->cons;
-	port->info = state->info;
+
+	/*
+	 * Don't assign info if it has already been assigned.
+	 *
+	 * FIXME - is this assignment really necessary?  port->info
+	 * doesn't seem to be used until after an open, and that
+	 * assigns the value.
+	 */
+	if (!port->info)
+		port->info = state->info;
 
 	/*
 	 * If this port is a console, then the spinlock is already
@@ -2557,8 +2610,10 @@ int uart_remove_one_port(struct uart_driver *drv, struct uart_port *port)
 	 * Kill the tasklet, and free resources.
 	 */
 	if (info) {
-		tasklet_kill(&info->tlet);
-		kfree(info);
+		if (info->flags & UIF_TASKLET_SETUP)
+			tasklet_kill(&info->tlet);
+		if (!(info->flags & UIF_BOOT_ALLOCATED))
+			kfree(info);
 	}
 
 	state->port = NULL;
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 038764e..b42976a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -171,6 +171,10 @@ struct uart_info;
 struct serial_struct;
 struct device;
 
+#define UART_POLL_FLAGS_RX	(1 << 0)	/* Poll Receiver */
+#define UART_POLL_FLAGS_TX	(1 << 1)	/* Poll Transmitter */
+#define UART_POLL_FLAGS_MCTRL	(1 << 2)	/* Poll modem control */
+
 /*
  * This structure describes all the operations that can be
  * done on the physical hardware.
@@ -195,6 +199,47 @@ struct uart_ops {
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
 
+
+	/*
+	 * Note: Poll routines must be called with the port lock held and
+	 * interrupts off.
+	 */
+
+	/*
+	 * The startup and shutdown routines must be called before
+	 * poll is used and after done calling poll.  You cannot allow
+	 * the driver code to be run by interrupts (or anything else)
+	 * between this.  A state value is returned by the startup
+	 * routine in pstate, you must pass that to the shutdown
+	 * routine.
+	 */
+	int		(*poll_startup)(struct uart_port *,
+					unsigned long *pstate);
+	void		(*poll_shutdown)(struct uart_port *,
+					 unsigned long pstate);
+
+	/*
+	 * Check the serial chip for I/O.  Flags is used to specify
+	 * what to check, see UART_POLL_FLAGS_xxx above.
+	 */
+	void		(*poll)(struct uart_port *, unsigned int flags);
+
+	/*
+	 * Is the port in flow-control (CTS is not asserted).  It is
+	 * optional an may be NULL and is only called if UPF_CONS_FLOW
+	 * is set in port->flags.
+	 */
+	int             (*in_flow_control)(struct uart_port *);
+
+	/*
+	 * Return reasonable settings for the port; it is primarily
+	 * there so firmware can pass console settings for the
+	 * console.
+	 */
+	int		(*port_defaults)(struct uart_port *,
+					 int *baud, int *parity, int *bits,
+					 int *flow);
+
 	/*
 	 * Return a string describing the type of the port
 	 */
@@ -351,6 +396,8 @@ struct uart_info {
  *
  * FIXME: use the ASY_ definitions
  */
+#define UIF_TASKLET_SETUP	((__force uif_t) (1 << 23))
+#define UIF_BOOT_ALLOCATED	((__force uif_t) (1 << 24))
 #define UIF_CHECK_CD		((__force uif_t) (1 << 25))
 #define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
 #define UIF_NORMAL_ACTIVE	((__force uif_t) (1 << 29))
@@ -377,6 +424,18 @@ struct uart_driver {
 	struct console		*cons;
 
 	/*
+	 * If nr_pollable is non-zero, then pollable_ports is an array of uart
+	 * ports that can be used for polling.  The serial_core code
+	 * will assume two things:
+	 *   1) The driver has poll capability in the uart_ops.
+	 *   2) The driver wants the serial_core to manage the console
+	 *      pointed to by "cons" above.  It uses the poll capability
+	 *      to do this.
+	 */
+	int			 nr_pollable;
+	struct uart_port	**pollable_ports;
+
+	/*
 	 * these are private; the low level driver should not
 	 * touch these; they should be initialised to NULL
 	 */
@@ -413,6 +472,8 @@ void uart_console_write(struct uart_port *port, const char *s,
 /*
  * Port/driver registration/removal
  */
+void uart_register_polled(struct uart_driver *uart);
+void uart_unregister_polled(struct uart_driver *uart);
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
@@ -436,8 +497,12 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 #define uart_circ_chars_free(circ)	\
 	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
 
-#define uart_tx_stopped(portp)		\
-	((portp)->info->port.tty->stopped || (portp)->info->port.tty->hw_stopped)
+static inline int uart_tx_stopped(struct uart_port *port)
+{
+	if (!port->info->port.tty)
+		return 0;
+	return port->info->port.tty->stopped || port->info->port.tty->hw_stopped;
+}
 
 /*
  * The following are helper functions for the low level drivers.
@@ -543,6 +608,9 @@ uart_insert_char(struct uart_port *port, unsigned int status,
 {
 	struct tty_struct *tty = port->info->port.tty;
 
+	if (!tty)
+		return;
+
 	if ((status & port->ignore_status_mask & ~overrun) == 0)
 		tty_insert_flip_char(tty, ch, flag);
 
@@ -557,6 +625,9 @@ uart_insert_char(struct uart_port *port, unsigned int status,
 static inline void
 uart_push(struct uart_port *port)
 {
+	if (!port->info->tty)
+		return;
+
 	tty_flip_buffer_push(port->info->tty);
 }
 
-- 
1.5.5.1

