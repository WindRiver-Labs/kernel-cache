From 65e798f8030d9e9e8bcf71217973a864db17a8ea Mon Sep 17 00:00:00 2001
From: weixing shi <Weixing.Shi@windriver.com>
Date: Thu, 8 Sep 2011 17:43:38 +0800
Subject: [PATCH] Unionfs: handle an open-unlink-ftruncate sequence

If someone calls open(), then unlink(), then ftruncate() on a file (rare,
but possible), then it's possible for unionfs to get an unlinked inode which
doesn't have an inode->i_sb and its inode->i_ino is zero.  Don't oops in
that case.

Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
Signed-off-by: weixing shi <Weixing.Shi@windriver.com>
---
 fs/unionfs/inode.c |   26 ++++++++++++++++++++------
 fs/unionfs/union.h |    9 +++++++++
 2 files changed, 29 insertions(+), 6 deletions(-)

diff --git a/fs/unionfs/inode.c b/fs/unionfs/inode.c
index 0bd9fab..68d919d 100644
--- a/fs/unionfs/inode.c
+++ b/fs/unionfs/inode.c
@@ -800,7 +800,8 @@ static int unionfs_permission(struct inode *inode, int mask)
 		err = inode_permission(lower_inode, mask);
 		if (err && bindex > 0) {
 			umode_t mode = lower_inode->i_mode;
-			if (is_robranch_super(inode->i_sb, bindex) &&
+			if ((is_robranch_super(inode->i_sb, bindex) ||
+					__is_rdonly(lower_inode)) &&
 			    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
 				err = 0;
 			if (IS_COPYUP_ERR(err))
@@ -841,6 +842,11 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 	int bstart, bend, bindex;
 	loff_t size;
 
+	/* check if user has permission to change inode */
+	err = inode_change_ok(dentry->d_inode, ia);
+	if (err)
+		goto out_err;
+
 	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
 	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
 
@@ -865,7 +871,7 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 
 	/* copyup if the file is on a read only branch */
 	if (is_robranch_super(dentry->d_sb, bstart)
-	    || IS_RDONLY(lower_dentry->d_inode)) {
+	    || __is_rdonly(lower_dentry->d_inode)) {
 		/* check if we have a branch to copy up to */
 		if (bstart <= 0) {
 			err = -EACCES;
@@ -892,8 +898,10 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 		lower_dentry = unionfs_lower_dentry(dentry);
 	}
 
-	lower_inode = unionfs_lower_inode(inode);
-
+	lower_inode = lower_dentry->d_inode;
+	err = inode_change_ok(lower_inode, ia);
+  if (err)
+      goto out;
 	/*
 	 * If shrinking, first truncate upper level to cancel writing dirty
 	 * pages beyond the new eof; and also if its' maxbytes is more
@@ -913,6 +921,11 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 	}
 
 	/* notify the (possibly copied-up) lower inode */
+	/*
+	 * Note: we use lower_dentry->d_inode, because lower_inode may be
+	 * unlinked (no inode->i_sb and i_ino==0.  This happens if someone
+	 * tries to open(), unlink(), then ftruncate() a file.
+	 */
 	mutex_lock(&lower_dentry->d_inode->i_mutex);
 	err = notify_change(lower_dentry, ia);
 	mutex_unlock(&lower_dentry->d_inode->i_mutex);
@@ -920,7 +933,8 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 		goto out;
 
 	/* get attributes from the first lower inode */
-	unionfs_copy_attr_all(inode, lower_inode);
+	if (ibstart(inode) >= 0)
+		unionfs_copy_attr_all(inode, lower_inode);
 	/*
 	 * unionfs_copy_attr_all will copy the lower times to our inode if
 	 * the lower ones are newer (useful for cache coherency).  However,
@@ -940,7 +954,7 @@ out:
 		unionfs_check_dentry(dentry);
 	unionfs_unlock_dentry(dentry);
 	unionfs_read_unlock(dentry->d_sb);
-
+out_err:
 	return err;
 }
 
diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h
index 4c7b213..3e8d963 100644
--- a/fs/unionfs/union.h
+++ b/fs/unionfs/union.h
@@ -435,6 +435,15 @@ static inline int set_branchperms(struct super_block *sb, int index, int perms)
 	return perms;
 }
 
+/* check if readonly lower inode, but possibly unlinked (no inode->i_sb) */
+static inline int __is_rdonly(const struct inode *inode)
+{
+	/* if unlinked, can't be readonly (?) */
+	if (!inode->i_sb)
+		return 0;
+	return IS_RDONLY(inode);
+
+}
 /* Is this file on a read-only branch? */
 static inline int is_robranch_super(const struct super_block *sb, int index)
 {
-- 
1.7.0.4

