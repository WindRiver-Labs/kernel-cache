GIT b3737f3f9a6badd3afee006aba49df5ff5553be0 git+ssh://master.kernel.org/pub/scm/linux/kernel/git/ezk/unionfs.git

commit b3737f3f9a6badd3afee006aba49df5ff5553be0
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: use new kmem_cache_create constructor prototype
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c7120bfba7d99ab5f585993054e8269a408e2b55
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: LOOKUP_ACCESS intent no longer exists
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ac9510cd9a9922fb043fc40a61b6d37eb90aee79
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: permission no longer takes a nameidata parameter
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 275aaf8210d82e209b49a04b22c8caa30761fdc2
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: symlink no longer takes a mode parameter
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9a3eda592a3a0cb29d10926c3e6377f5856b5b5b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: properly hash newly created inodes
    
    This fixes LTP's syscalls/rename13 test.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 745469873781c0f2e56d09b6f600a68501e3a6ea
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: minor checkpatch fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 5fc792fbe22f01d123a31e96e26d633465be2dc7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: update copyrights
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ebdaf1e848d6d2e95ab3fce7e43e00836348349d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: update maintainers
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 87ed1005e85a7f41eac1b105e6ea7e9efa842578
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: remove old lookup code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 641b2879cd5b45e46368956dea710a279b9aad68
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: cache coherency fixes
    
    Handle unhashed or silly-renamed lower dentries properly.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 40895d4fe50bd7ff05411325ec3f9b7af01f2e8e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: free lower paths array when destroying dentry's private data
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6f3e1c036a26f6aa83cb9f5355f7cdad9d09e2f7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: lookup overhaul using vfs_path_lookup
    
    Rework the lookup code to use vfs_path_lookup as much as possible, to ensure
    that we have a vfsmount at this critical stage.  This is necessary for the
    upcoming VFS API change from vfs_* to path_* methods.  This change also
    allows unionfs to cross bind mounts and other mounts on lower branches.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 937035d7d09a52e16c96035190fb25580cc075dc
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: overhaul whiteout code
    
    Move all whiteout functions and helpers into a separate file, replace all
    embedded whiteout code with calls to helpers.  Cleanup and consolidate the
    code.  This will make it easier to replace the whiteout code with a
    Linux-native whiteout implementation (once available).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 054df086f814c76afd684dbe2536d011a6c7a3df
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: simplify stale-inode detection code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit dedcc7be71f98c256fb0b1e13695efa5ad52d844
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: create and consolidate helpers to path-put lower objects
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 96cbc246ce0038e6bf03134d8c0d59791d6176f1
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: create and consolidate helpers to iput lower objects
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 740e2cbc9803d9dcd7e652dd437bf8d573f0d442
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: move a rename helper closer to rename code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 236b3c5400af8f89f42bca02bab2d49e03ca9518
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: simplify the macros used to get/set the dentry start/end branches
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 30f300d26e8beec6032a09b7221fca40db30b7dc
Author: Hugh Dickins <hugh@veritas.com>
Date:   Mon Jul 28 00:43:29 2008 -0400

    LTP's iogen01 doio tests used to hang nicely on 32-bit SMP when /tmp was a
    unionfs mount of a tmpfs, i_size_read spinning forever, waiting for a lost
    seqcount update: fixed by taking i_lock around i_size_write when 32-bit
    SMP.
    
    But akpm was dissatisfied with the resulting patch: its lack of
    commentary, the #ifs, the nesting around i_size_read, the lack of
    attention to i_blocks.  I promised to redo it with the general
    spin_lock_32bit() he proposed; but disliked the result, partly because
    "32bit" obscures the real constraints, which are best commented within
    fsstack_copy_inode_size itself.
    
    This version adds those comments, and uses sizeof comparisons which the
    compiler can optimize out, instead of CONFIG_SMP, CONFIG_LSF.
    BITS_PER_LONG.
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Cc: Erez Zadok <ezk@cs.sunysb.edu>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Cc: <hooanon05@yahoo.co.jp>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

commit 7f2ede31ec605b8d6296a5768d48c8a9046db6d0
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: move fs/Makefile entry up to minimize merge conflicts
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c41e835981d8c348331318fd2ddbc6fa167391b4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 28 00:43:29 2008 -0400

    Unionfs: use new umount_begin prototype
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 8d08a3b0ba87cacdd2a4b6fe6f10fbe3eb95ea3f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Apr 23 19:05:59 2008 -0400

    Unionfs: lock parent dentry branch config in write
    
    Ensure that branch configuration is available to file_revalidate should a
    copyup be required.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 90c498c8b3b3f34ed6dd7e795e8b9fe731b4666b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Apr 23 19:05:50 2008 -0400

    Unionfs: set lower file to NULL in file_release
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 416d1b514665d5d396d406b607a92c7fe86e950c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Apr 23 19:05:40 2008 -0400

    Unionfs: maintain one-open-file invariant for non-directories
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 7a364f1b7fa06344c650d086840c660c88c33f20
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Apr 23 19:05:22 2008 -0400

    Unionfs: reorganize file_revalidate for un/locking callers
    
    Also clean up deep nesting/indentation.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 1b17cb01f8516e4b96be86d5f776dc00c76dfbab
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Apr 15 13:11:04 2008 -0400

    Unionfs: copyup only if file is being written to
    
    Before, we used to copyup on an open(2) call which used flags implying
    writing (O_RDWR, O_WRONLY, O_APPEND).  This meant that a file being opened
    for writing, then immediately closed (without actually writing to the file),
    will still have been copied up.  Now, we don't copyup such files in ->open,
    but defer the copyup till later. [Bug #591].
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9e4900efb890930be57c0cb78f523c5a33410af5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Apr 10 15:32:26 2008 -0400

    Unionfs: set append offset correctly for copied-up files
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit a287f3d05514c990be28dfa3266c9529e9f21a83
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Apr 15 13:07:44 2008 -0400

    Unionfs: don't dereference dentry without lower branches in d_release
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 5d1db01794288adebc1f9e64c18e6b2786cdca0a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sat Apr 5 21:02:23 2008 -0400

    Unionfs: stop as soon as first writeable branch is found
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f3df5135903dbe25e02206cca69c876844586fc3
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Apr 3 13:56:47 2008 -0400

    Unionfs: lock inode around calls to notify_change()
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit db6030fa3e8b2ec6602bb35105e244f9d39e9dad
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Apr 3 13:15:59 2008 -0400

    Unionfs: copy lower times in fsync/fasync only when needed
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit be90d55aa668e8e309da772c1e166cf80393e378
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Apr 15 13:05:52 2008 -0400

    Unionfs: prevent races in unionfs_fault
    
    vm_ops->fault may be called in parallel.  Because we have to resort to
    temporarily changing the vma->vm_file to point to the lower file, a
    concurrent invocation of unionfs_fault could see a different value.  In this
    workaround, we keep a different copy of the vma structure in our stack, so
    we never expose a different value of the vma->vm_file called to us, even
    temporarily.  A better fix (already tested) would be to change the calling
    semantics of ->fault to take an explicit file pointer.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 912d910563fd2d4babe51df7b88669ebd6026f6d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Apr 15 15:20:03 2008 -0400

    Unionfs: minor code cleanups
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d91c278c7e22e63ea3f8708cd41c7b3b84815797
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 31 19:26:09 2008 -0400

    Unionfs: update lower mnts on rmdir with copyup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 326caa46eb72b487d2a382c8397be8298c89bc5d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 31 19:26:00 2008 -0400

    Unionfs: don't purge lower sb data on remount
    
    This is no longer needed, as we don't have upper and lower pages.  Plus this
    was racy, requiring the unexported inode_lock variable.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 80b83ea42d22094a6c86c6a71ac05c020764a278
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 27 16:34:20 2008 -0400

    Unionfs: do not over-decrement lower superblock refs on remount
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 39a42f51cd01113058bb73afaf334baa7cd7df47
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: display mount point name along with generation number
    
    CC: Dave Miller <justdave@mozilla.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 277f77f07f08056042fb750260f752bcc6f19d0a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: document reasons for opaque directories
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fd15696c164adbc6b098ed7959fd4525a735cdbf
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: use noinline_for_stack
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 0159b1171aec9714385e38b0457f5cd8612caece
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: use __func__ instead of __FUNCTION__
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit a5301da041ba6ae22f0a1fb2d09489c2a21dbf03
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: don't copy parent inode times in setattr
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 460ba1409a20b27fdc7dab42ea314ea2d453b2e3
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: reduce number of whiteouts by deleting all instances of files
    
    Optimize the unlinking of non-dir objects in unionfs by deleting all
    possible lower inode objects from all writable lower branches.  This may
    consume a bit more processing, but on average reduces overall inode
    consumption and further saves a lot by reducing the total number of
    whiteouts needed.  We create a whiteout now only if we could not delete all
    lower objects, or if one of the lower branches was explicitly marked
    read-only.
    
    Signed-off-by: Himanshu Kanda <hkanda@cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 01990fd35d43ee994d86e32737f6acb0a6aa016e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: lock our dentry in file operations
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f67258c7be399d0b79c54ac7ac2284c8f3afd824
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: implement vm_operations->fault
    
    As per recommendations made at LSF'08, a stackable file system which does
    not change the data across layers, should try to use vm_operations instead
    of address_space_operations.  This means we now have to implement out own
    ->read and ->write methods because we cannot rely on VFS helpers which
    require us to have a ->readpage method.  Either way there are two caveats:
    
    (1) It's not possible currently to set inode->i_mapping->a_ops to NULL,
    because too many code paths expect i_mapping to be non-NULL.
    
    (2) a small/dummy ->readpage is still needed because generic_file_mmap,
    which we used in unionfs_mmap, still check for the existence of the
    ->readpage method.  These code paths may have to be changed to remove the
    need for readpage().
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 3913c5f0dbe95422ed4c4cbde5c16793aa08932a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    Unionfs: implement splice_read/write methods directly
    
    Must implement splice_read/write directly, using VFS helpers, because we can
    no longer rely on generic_file_splice_read/write: they need
    address_space_operations implemented, which we no longer have.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 870b82670826243d323fd5a4aa0ce5b99f748a98
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    VFS: rename do_splice_to/from to vfs_splice_* and export symbols
    
    A stackable file system which uses vm_ops->fault, and does not implement
    address_space_operations, cannot use generic_file_splice_read/write, but has
    to implement ->splice_read/write itself.  These two helper functions are
    very useful to such a module.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f6aa545e2cab530f376f759292ea87b82b033d15
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 24 22:10:46 2008 -0400

    VFS: export release_open_intent as GPL symbol, not regular symbol
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ef5a76311a67e1ef79c3689310d59aeb5b92fdff
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:26:35 2008 -0500

    VFS/Unionfs: use generic path_get/path_put functions
    
    Remove unionfs's versions thereof.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d78079fefb64be6bb5bcfb92e2343ab715c4463e
Author: Jan Blunck <jblunck@suse.de>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: use the new path_put
    
    * Add path_put() functions for releasing a reference to the dentry and
      vfsmount of a struct path in the right order
    
    * Switch from path_release(nd) to path_put(&nd->path)
    
    * Rename dput_path() to path_put_conditional()
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit a7f39581d7d27febddf459f0f4611f3be146026c
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: embed a struct path into struct nameidata instead of nd dentrymnt
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit dad38aef4f5258a91e4e043508411b124459e14c
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: stop using iget() and read_inode()
    
    Replace unionfs_read_inode() with unionfs_iget(), and call that instead of
    iget().  unionfs_iget() then uses iget_locked() directly and returns a
    proper error code instead of an inode in the event of an error.
    
    unionfs_fill_super() returns any error incurred when getting the root inode
    instead of EINVAL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d4589a1324199c05bda678a9b227cc8956eab03e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: use dget_parent in revalidation code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c14b2b5ff98f3f3fea44a7a1ea06908485aed9d5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: branch management/configuration fixes
    
    Remove unnecessary calls to update branch m/ctimes, and use them only when
    needed.  Update branch vfsmounts after operations that could cause a copyup.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9c17ac4ada56755cdeff829bc73be6f818c8dcc6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: lock parents' branch configuration fixes
    
    Ensure that we lock the branch configuration of parent and child dentries in
    operations which need it, and in the right order.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ded822fe11edd005591392b5a95171042bfe35fc
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: factor out revalidation routine
    
    To be used by rest of revalidation code, as well a callers who already
    locked the child and parent dentry branch-configurations.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c422768b79bd57e8a2166611af108dbba346259d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: revalidation code cleanup and refactoring
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 08335225e42d6d0a9528b3fa7fdadb48d438420e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: improve debugging in copy_attr_times
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 96250c899acb4f4ac6f749f68a0f835732296e7e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: follow_link locking fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 07747d9f8024b86f804aad989f7b0e55c36ed730
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: extend dentry branch configuration lock in open
    
    Dentry branch configuration "info node" lock should extend to calls to
    copy_attr_times.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2e65a1414bf9ab909015ee4f902d7f1afcfd64bf
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: initialize path_save variable
    
    This is not strictly necessary, but it helps quiet a gcc-4.2 warning (a good
    optimizer may optimize this initialization away).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 6af10406f569a6f97981d60585898e39c7e00923
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: uninline unionfs_copy_attr_times and unionfs_copy_attr_all
    
    This reduces text size by about 6k.
    
    Cc: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 652d49fa3f709fc7e9cbd553cf2a783af7bde58e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: document behavior when the lower topology changes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 481136f5b77998818fbf8cb2526f9c631a89efbb
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: ensure consistent lower inodes types
    
    When looking up a lower object in multiple branches, especially for
    directories, ignore any existing entries whose type is different than the
    type of the first found object (otherwise we'll be trying to, say, call
    readdir on a non-dir inode).
    
    Signed-off-by: Himanshu Kanda <hkanda@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 593122674a6388fed1b0d6159e15e1e0eae696e9
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Feb 15 20:25:41 2008 -0500

    Unionfs: grab lower super_block references
    
    This prevents the lower super_block from being destroyed too early, when a
    lower file system is being unmounted with MNT_FORCE or MNT_DETACH.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit a54c03d89c8f57225b4f218a123456b81d912a4a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jan 25 21:10:35 2008 -0500

    Unionfs: lock_rename related locking fixes
    
    CC: Mike Halcrow <mhalcrow@us.ibm.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 39abfaaf77735f978ff79b66dd7c0b47dc2a79ad
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jan 25 21:10:35 2008 -0500

    Unionfs: d_parent related locking fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2426fb52fad7772646a4b06930c20276f89269ca
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jan 25 21:10:35 2008 -0500

    Unionfs: remove unnecessary call to d_iput
    
    This old code was to fix a bug which has long since been fixed in our
    copyup_permission and unionfs_d_iput.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 48c5dc6f245bf3da75bf6e36ecaf2b1ed27aface
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jan 25 21:10:35 2008 -0500

    Unionfs: use first writable branch (fix/cleanup)
    
    Cleanup code in ->create, ->symlink, and ->mknod: refactor common code into
    helper functions.  Also, this allows writing to multiple branches again,
    which was broken by an earlier patch.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2ba8f677071c3d60d7dd1dc3319454064866f6cd
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Jan 9 19:41:48 2008 -0500

    Unionfs: ensure we have lower dentries in d_iput
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 926c91e3bc4da3f26a1a9d9c3a763c4b5069587e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Jan 9 19:41:48 2008 -0500

    Unionfs: branch-management related locking fixes
    
    Add necessary locking to dentry/inode branch-configuration, so we get
    consistent values during branch-management actions.  In d_revalidate_chain,
    ->permission, and ->create, also lock parent dentry.

commit d63e5afbaa1a3a359a336db1133e4445ef59a025
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Jan 9 19:41:48 2008 -0500

    Unionfs: mmap fixes
    
    Ensure we have lower inodes in prepare/commit_write.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 0ceed0e02179cdf463218a08ea65101b64e3323f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Jan 9 19:41:48 2008 -0500

    Unionfs: merged several printk KERN_CONT together into one pr_debug
    
    CC: Joe Perches <joe@perches.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c9a3a81b49cdf00730654e8d0eb8e98a286b45fa
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Jan 1 22:20:58 2008 -0500

    Unionfs: use VFS helpers to manipulate i_nlink
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 332c18ecaf2c460e9ec6ca3120532941b4171e3d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Jan 1 22:20:58 2008 -0500

    Unionfs: locking fixes
    
    Lock parent dentries during revalidation.
    Reduce total number of lockdep classes used.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit a6cc30cd89f95e84051449c7fa6c244d74e49c26
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Jan 1 22:20:58 2008 -0500

    Unionfs: use printk KERN_CONT for debugging messages
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 86e5cba3b364363546663552425f102dac310778
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:04:54 2007 -0500

    Unionfs: release 2.2
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ab53e9fd588fe273c96eb4fa56ad80518dc1bb1d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: don't check parent dentries
    
    Parent dentries may not be locked and may change, so don't check them.  But
    do check parent inodes if they are passed to the method.  Also, ensure the
    checks are done only if no error occurred.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit b5882a416a7516385ae76b31aca82ad0f089a684
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: implement d_iput method
    
    This is needed to drop lower objects early enough, under certain conditions,
    so the lower objects don't stay behind until umount(). [LTP testing]
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6358b33069bae89dbc65a11dbb4e29306f3e2c55
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: don't check dentry on error
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f11c4ba3e87d7af95980270702bb0a9043d57e90
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: cleanup lower inodes after successful unlink
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit b6bcda1d5b26021e5dcc5221cbe396ecc7be9bba
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: initialize namelist variable in rename
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 15fb687923c27bdb3c8037149573319deab9148f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: minor cleanup in check_empty
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fa4a57a5f373eed5ddc465f7661a2d7b1760d67f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: update inode times after a successful open
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d09ad5ba22f62b6f2deebff0e55453c4e85703d6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: set our superblock a/m/ctime granularity
    
    Set it to 1 ns, because we could be stacked on top of file systems with such
    granularity.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c5913efbde0e3c1ee7e4ef66897b4266a4b6887c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: handle on lower inodes in lookup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 11cf9c739b8a793e0f403c767681e31d030df07a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: minor code rearrangement in rename
    
    To avoid too much code nesting.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 0153c06fc557d5980de4d297e12d2195e1057643
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: implement lockdep classes
    
    Lockdep fixes.  Support locking order/classes (e.g., parent -> child ->
    whiteout).  Remove locking from create_parents: it's enough to just dget the
    dentries in question.  Move parent locking to from lookup_backend to caller,
    unionfs_lookup.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6bfca79b0c5bcf525c2808d5f6a17a08882e9b94
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: prevent false lockdep warnings in stacking
    
    A stackable file system like unionfs often performs an operation on a lower
    file system, by calling a vfs_* method, having been called possibly by the
    very same method from the VFS.  Both calls to the vfs_* method grab a lock
    in the same lock class, and hence lockdep complains.  This warning is a
    false positive in instances where unionfs only calls the vfs_* method on
    lower objects; there's a strict lock ordering here: upper objects first,
    then lower objects.
    
    We want to prevent these false positives so that lockdep will not shutdown
    so it'd still be able to warn us about potentially true locking problems.
    So, we temporarily turn off lockdep ONLY AROUND the calls to vfs methods to
    which we pass lower objects, and only for those instances where lockdep
    complained.  While this solution may seem unclean, it is not without
    precedent: other places in the kernel also do similar temporary disabling,
    of course after carefully having checked that it is the right thing to do.
    
    In the long run, lockdep needs to be taught how to handle about stacking.
    Then this patch can be removed.  It is likely that such lockdep-stacking
    support will do essentially the same as this patch: consider the same
    ordering (upper then lower) and consider upper vs. lower locks to be in
    different classes.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d7550329913ca450eb16da72cb5e086b4611e189
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove unnecessary parent lock in create
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit aa49005f4aeac93ab4e30a3b754d8fe4541ec54d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove unnecessary locking in follow-link
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 76616dfbc153382237f297895b7628057f777665
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove unnecessary lock in read_inode
    
    Our read_inode doesn't need to grab the superblock rwsem because there no
    chance it could be affected by branch management.  But our read_inode was
    called from other places which did grab need to grab that rwsem, and lockdep
    complained.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 051f6df6a520123185320e80a510ec0edbdde102
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove unnecessary lock when deleting whiteouts
    
    Lockdep complained, because we eventually call vfs_unlink which'd grab the
    necessary locks.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 87ae91690ded9aa51246f93ffba4e675e4c15421
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove unnecessary conditional inode lock
    
    This was intended to protect the inode during branch management, but that is
    now done through our superblock rwsem.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit eebad4c6aec86b118fc82e1dcb7975c63c3c9651
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: prevent deadlock in cache coherency
    
    Don't try to truncate_inode_pages in in purge_inode_data, because this could
    lead to a deadlock between some of address_space ops and dentry
    revalidation: the address space op is invoked with a lock on our own page,
    and truncate_inode_pages will block on locked pages.  Instead, it should be
    enough to be gentler and just invalidate_mapping_pages.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 06049f44585739247fb9bd708ccd47a46e543aa7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: remove custom read/write methods
    
    Having them results in lockdep warnings about having locks and grabbing the
    same class locks in do_sync_read/write which were called from
    unionfs_read/write.  All they did was revalidate out file object sooner,
    which will now be deferred till a bit later.  Instead, use generic
    do_sync_read and do_sync_write.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fd1d82934662f0c4dbfa0d53b0a3e5dcd12bda65
Author: Hugh Dickins <hugh@veritas.com>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: restructure unionfs_setattr and fix truncation order
    
    Restructure the code to move the lower notify_change out of the loop in
    unionfs_setattr.  Cleanup and simplify the code.  Then fix the truncation
    order which fsx-linux in a unionfs on tmpfs found.  Then handle copyup
    properly.
    
    When shrinking a file, unionfs_setattr needs to vmtruncate the upper level
    before notifying change to the lower level, to eliminate those dirty pages
    beyond new eof which otherwise drift down to the lower level's writepage,
    writing beyond its eof (and later uncovered when the file is expanded).
    
    Also truncate the upper level first when expanding, in the case when
    the upper level's s_maxbytes is more limiting than the lower level's.
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 58944b9579dc205e3d88007a1565f4646f762f87
Author: Hugh Dickins <hugh@veritas.com>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: mmap fixes
    
    Remove !mapping_cap_writeback_dirty shortcircuit from unionfs_writepages.
    
    It was introduced to avoid the stray AOP_WRITEPAGE_ACTIVATE coming from
    shmem_writepage; but that has since been fixed in shmem_writepage and in
    write_cache_pages.  It stayed because it looked like a good optimization,
    not to waste time calling down to tmpfs when that would serve no purpose.
    
    But in fact this optimization causes hangs when running LTP with unionfs
    over tmpfs.  The problem is that the test comes at the wrong level: unionfs
    has already declared in its default_backing_dev_info that it's playing by
    cap_writeback_dirty rules.  If it does nothing here in its writepages, its
    dirty pages accumulate and choke the system.  What's needed is to carry on
    down and let its pages be cleaned while in turn they dirty the lower level.
    
    And this now has an additional benefit for tmpfs, that a sync or pdflush
    pushes these pages down to shmem_writepage, letting it match the filepage
    coming from unionfs with the swap which may have been allocated earlier,
    so it can free the duplication sooner than waiting for further pressure.
    
    Remove unnecessary locking/code from prepare_write.  Handle if no lower
    inodes in writepage.
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 3e8b32cb58f45bc483b10b8ae41796d326ccf1fa
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: release special files on copyup
    
    If we copyup a special file (char, block, etc.), then dput the source
    object.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit babc29a20eee10684c61e92ed69e897a36a4a33d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: create new symlinks only in first branch
    
    When creating a new symlink, always create it in the first branch, which is
    always writeable, not in the branch which may have a whiteout in it.  This
    makes the policy for the creation of new symlinks consistent with that of
    new files/directories, as well as improves efficiency a bit.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 516db33c38c6982d533be93e2bf76c7134366dae
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: create new special files only in first branch
    
    When creating a new special file, always create it in the first branch,
    which is always writeable, not in the branch which may have a whiteout in
    it.  This makes the policy for the creation of new special files consistent
    with that of new files/directories, as well as improves efficiency a bit.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 50bbbc7c56b133dbe417b8ffa146df743b1d8f8c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: initialize inode times for reused inodes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c57d526cdc36d61e006992d3f35c144c302def8c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: interpose cleanup and fix for spliced dentries
    
    Fix unionfs_interpose to fill lower inode info when d_splice_alias returns
    NULL.  Also cleanup impossible case (d_splice_alias doesn't return ERR_PTR).
    
    Signed-off-by: Rachita Kothiyal <rachita@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 7b29b5817431913f3bc3cc6498a0ab5f23023af1
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:09:32 2007 -0500

    Unionfs: clarify usage.txt read/write behavior
    
    CC: Michael Tokarev <mjt@tls.msk.ru>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit bd707e822b5045589cd744bed24e9bca4675ddba
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    Unionfs: use locking around i_size_write in 32-bit systems
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9379b9f7372693ed58b0088c6518c39e04530902
Author: Hugh Dickins <hugh@veritas.com>
Date:   Fri Dec 28 14:01:46 2007 -0500

    VFS/fs_stack: use locking around i_size_write in 32-bit systems
    
    LTP's iogen01 doio tests hang nicely on 32-bit SMP when /tmp is a unionfs
    mount of a tmpfs.  See the comment on i_size_write in linux/fs.h: it needs
    to be locked, otherwise i_size_read can spin forever waiting for a lost
    seqcount update.
    
    Most filesystems are already holding i_mutex for this, but unionfs calls
    fsstack_copy_inode_size from many places, not necessarily holding i_mutex.
    Use the low-level i_lock within fsstack_copy_inode_size when 32-bit SMP.
    
    Checked the entire unionfs code to ensure this is the right fix for
    i_size_write().
    
    Also compared to what other file systems do when they have to handle inodes,
    esp. not their own inodes (e.g., network file systems have to access the
    exported file system's inodes).  Found out that most such file systems not just
    don't lock around i_size_write, but they don't even use i_size_read or
    i_size_write to access the inode's size.
    
    CC: Mike Halcrow <mhalcrow@us.ibm.com>
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f3a5fe15276466e9adef8ba03b6a4af39833b6d7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 28 14:01:46 2007 -0500

    VFS/fs_stack: drop cast on inode passed to i_size_read
    
    i_size_read() takes 'const struct inode *' already, as of 2.6.20.
    
    CC: Mike Halcrow <mhalcrow@us.ibm.com>
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 53c39ccdc77a5209cd0a31464d43233b879ac8ca
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Dec 13 18:36:32 2007 -0500

    Unionfs: clarify usage.txt mount options
    
    CC: Jim Kissel <jlk@osml.eu>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2d748c0eecf3b327e61569af909b6cd9f81eae24
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Dec 12 22:40:15 2007 -0500

    Unionfs: avoid using drop_pagecache_sb in remount
    
    Exporting drop_pagecache_sb to modules is somewhat risky because one cannot
    sleep inside invalidate_mapping_pages.  This could cause a lot of latency in
    the pre-emption code.  So don't export this symbol to minimize the risk that
    others will use it.
    
    Instead, unionfs will try to directly invalidate as many pages it can from
    the unionfs_remount code.  Invalidating those inode pages is not strictly
    required, but helpful in encouraging a revalidation of inodes sooner than
    waiting for individual f/s ops to access the union.  Since a remount is
    already an expensive but rare operation, this inode pages invalidation
    shouldn't add too much overhead.
    
    CC: Nick Piggin <nickpiggin@yahoo.com.au>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 996644ba023e5c0b418377bcc06acf36effa97f6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 7 19:55:12 2007 -0500

    Unionfs: reduce the amount of cache-coherency debugging messages
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d47416a49775be5700120e014aceb6f979cc77af
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Dec 7 19:54:59 2007 -0500

    Unionfs: cleanup/consolidate branch-mode parsing code
    
    Also a bug fix: disallow unrecognized branch modes at mount time, instead of
    defaulting to "rw".
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 0818c270ac0d62d4777902f3fd44207829a0000b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: use generic_file_aio_read/write
    
    There's no apparent need to define our own aio_read/write methods.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ec5557c09355df4175ad2aa2df0d1701e224edd7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: update our inode size correctly upon partial write
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 468cbfa7251f119dcea4a252e38eeea682766f9d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Nov 26 19:44:04 2007 -0500

    Unionfs: prevent multiple writers to lower_page
    
    Without this patch, the LTP fs test "rwtest04" triggers a
    BUG_ON(PageWriteback(page)) in fs/buffer.c:1706.
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c07af1d4b064c8639a11c955162a741817790c8a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: support splice(2)
    
    Also remove redundant variable from unionfs_readpage (saves a bit on stack
    space).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 8d3e4da7f27f633394e97900cd60df7fc85c394c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: reintroduce a bmap method
    
    This is needed for swapon(2) files in the union.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 305be2c087cc811d1f05c0152c61c6700f7865c6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: update times in setattr
    
    Needed to maintain Unix semantics via utimes(2).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 0deca662ce02e7d74cb8df3a0c409b4453132d07
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 23:39:46 2007 -0500

    Unionfs: create opaque directories' whiteouts unconditionally
    
    Needed to maintain Unix semantics (LTP testing).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 29e183a3b55517803a8e567f1553b0cac6bbb11c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: don't create whiteouts on rightmost branch
    
    If we are unlinking/rmdir'ing an object on the  rightmost branch, there's no
    need to  create a whiteout there: this saves on storage space and inodes.
    Also, in the (degenerate) case of having only one branch, this really saves
    on whiteouts.
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 155bd653fc2b38ba0c037a1d2ce8384c365a2eb8
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: release lower resources on successful rmdir
    
    This patch prevents those resources from lingering around until memory
    pressure would have forced them out.  The patch also properly handles
    directories that have been rmdir'ed which are still some process's cwd.
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 48f378644c37d26fc1ef1c9435005d03e1e83592
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: remove useless debugging messages
    
    These are considered normal behaviour, they don't really reveal any insight
    to the person debugging the code, and they tend to clutter console messages.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit cc5034050852064be87f8ceb30b892e0bfaf10d2
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: handle whiteouts more efficiently in filldir
    
    If we cache a dirent for file "foo", and then it gets deleted, then we look
    for a ".wh.foo" whiteout entry in the same dirent cache.  But our dirent
    cache strips the ".wh." prefix, thus looking for an entry named "foo" whose
    filldir_node->whiteout should be 1 instead of 0.  In that case, don't
    display  an incorrect printk  message that the file system may be corrupt,
    but set that filldir_node->whiteout to 1.
    
    CC: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 3de3d088c7995f451c96e3028a97da6f3898c507
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: set lower mnt after mkdir which resulted in copyup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 745181e570bfa04751f5f5881043e0034aa51838
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: minor cleanup in the debugging infrastructure
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d44692b96872020420c28d554b5f1c9266b96f14
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: minor coding standards applied
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 12f095a2da21ef40c971e1639af4b7635f7e70d2
Author: Hugh Dickins <hugh@veritas.com>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: minor cleanup in writepage
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 699712b790c7fc1a884acc86a958096111203544
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Nov 25 20:01:17 2007 -0500

    Unionfs: use f_path instead of f_dentry/mnt
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6312275f87bcdf7e9fae64eab963e103d8950621
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: move debugging checks inside locks
    
    This is to ensure that the objects we want to check aren't being destroyed
    or changed by another thread.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 46a381d522143837f83d1ddc0837fdeb3f616c98
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: fold do_readpage into unionfs_readpage
    
    Simplify the code and reduce stack pressure a bit.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 80bb33950a0d8070e7b941e90e4623a25f346541
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: remove unnecessary lower atime updates
    
    No need for this because our readpage calls vfs_read on the lower objects,
    which would update the atime as/if needed.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9a18f9f8320aa042d61dd56205dc329437c0f2c4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: debugging updates
    
    Don't perform dentry+inode checks unless both are valid.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit cab75cb523ac166eccf2ad677e3d7320bc673050
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: clear partial read in readpage
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f295ddf7402b0e75176143be95449213972d2a7b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: writepage updates
    
    Don't set/reset the PageUptodate flag on our page.  Call flush_dcache_page
    on the lower page after copy_highpage, and set it uptodate.  Call
    set_page_dirty right before clear_page_dirty_for_io.
    
    CC: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9da16decda05c4232b0fdb8ca37fd3ec69d4e535
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: update cache-coherency detection heuristics
    
    Use a small delay to reduce the number of times unionfs has to detect
    changed mtime's/ctime's, and also reduce the potential for false positives.
    See Documentation/filesystems/unionfs/concepts.txt for a detailed
    discussion.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit e808cb0a0a8573cced6f5799c16face23909af37
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: use i_size wrappers
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 855f4bff658ee7e561e92f2311c6006685355877
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Nov 13 03:12:20 2007 -0500

    Unionfs: flush and release updates
    
    Remove the totalopens counter which was intended to reduce unnecessary
    processing of d_deleted dentries.  Move that processing from file_release to
    flush.
    
    Cc: Hugh Dickins <hugh@veritas.com>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit bd5b8bcab2ee0bd6ffe7acf22c120d57efed1974
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 20:03:21 2007 -0400

    Unionfs/VFS: no need to export 2 symbols in security/security.c
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit c76e3962ee4cc2cb2fe73ad8241e55c102027c3f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:01:54 2007 -0400

    Unionfs: don't printk an error if it's due to common copyup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 4bb5f9d65fea58bbe58cc68e12fb48390109168c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:01:54 2007 -0400

    Unionfs: don't bother validating inode if it has no lower branches
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fedb5d57d26604bd4de9bd5880517f1e0ff7ce16
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:06:09 2007 -0400

    Unionfs: avoid a deadlock during branch-management on a pivot_root'ed union
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Herton Ronaldo Krzesinski <herton@mandriva.com>

commit 8ef0277307d554a9133e47bb2b28d7aad71d3349
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:01:54 2007 -0400

    Unionfs: mmap updates
    
    Rewrite unionfs_writepage to minimize dependence on AOP_WRITEPAGE_ACTIVEATE,
    handle memory pressure better, and update documentation.  Remove
    unionfs_sync_page because it's not needed.
    
    CC: Hugh Dickins <hugh@veritas.com>
    CC: Pekka Enberg <penberg@cs.helsinki.fi>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 35edf71971b30c04fba5f10eca72f0c0c625b0da
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 20:28:18 2007 -0400

    Unionfs: update usage.txt documentation
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit b038e91751e653272829490bd50867ebe2d26f86
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:01:54 2007 -0400

    Unionfs: cleanup permission checking code
    
    Use vfs helpers and avoid redundant checks performed by the VFS already.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 3996302e90e8673d86cb3bf33eca100301242269
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Nov 2 19:01:54 2007 -0400

    Unionfs: delete whiteouts in sticky directories
    
    This is needed to maintain Unix semantics.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit facfa032bf3eb5ca688357d54c2ee31c3eb38512
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Oct 21 16:13:26 2007 -0400

    Unionfs: remove obsolete #define and comment
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fd3499218db9faf1121248a7c33f6ff935de4932
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun Oct 21 16:13:36 2007 -0400

    Unionfs: fix unionfs_setattr to handle ATTR_KILL_S*ID
    
    Don't allow unionfs_setattr to trip the BUG() in notify_change. Clear
    ATTR_MODE if the either ATTR_KILL_S*ID is set. This also allows the
    lower filesystem to interpret these bits in its own way.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Cc: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 56b33443916f6a1235db9ade5b809dc28a290ddb
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Oct 18 17:16:51 2007 -0400

    Unionfs: remove for_writepages nfs workaround
    
    This is no longer necessary since struct writeback_control no longer has a
    fs_private field which lower file systems (esp. nfs) use.  Plus, unionfs now
    defines its own ->writepages method.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6fbf6ed6ed19d6197610a9f10ca4f9b62eb769e4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Oct 18 14:03:16 2007 -0400

    Unionfs: convert a printk to pr_debug in release
    
    This is mostly an informational message, not an error.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 870b507c8d6117692f2e0d7bd154b66d71f8ba63
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Oct 17 17:35:02 2007 -0400

    Unionfs: don't bother validating dentry if it has no lower branches
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 73e1b1cc0d3ea5e5f754cf9e5720ba649243354e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Oct 17 16:37:51 2007 -0400

    Unionfs: don't printk trivial message upon normal rename-copyup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6fe756a952db253a9fbff4a74195f45b7398688d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Oct 16 10:50:16 2007 -0400

    Unionfs: support lower filesystems without writeback capability
    
    Implement unionfs_writepages.  As per
    mm/filemap.c:__filemap_fdatawrite_range(), don't call our writepage if the
    lower mapping has BDI_CAP_NO_WRITEBACK capability set.
    
    Signed-off-by: Pekka J Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f32459b03582333db2dea59aeb38cc728a01c8fa
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Oct 18 15:54:55 2007 -0400

    Unionfs: slab api remove useless ctor parameter and reorder parameters
    
    fs/unionfs/super.c: In function 'unionfs_init_inode_cache':
    fs/unionfs/super.c:874: warning: passing argument 5 of 'kmem_cache_create' from incompatible pointer type
    
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 89c6b8add10ac84d082f88b12d6f5f70dc525f69
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Oct 18 15:50:15 2007 -0400

    Unionfs: security convert lsm into a static interface fix
    
    ERROR: "security_inode_permission" [fs/unionfs/unionfs.ko] undefined!
    ERROR: "security_file_ioctl" [fs/unionfs/unionfs.ko] undefined!
    
    Need these back.
    
    Cc: "Serge E. Hallyn" <serue@us.ibm.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit e8d3e000abc7d603c90ac605bd9884e4b3b2e420
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 16:10:42 2007 -0400

    Unionfs: coding style: avoid lines longer than 80 chars
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 37aeacaceaa83834bc683aad7a353530588b5d2c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 16:10:15 2007 -0400

    Unionfs: coding style: miscellaneous fixes
    
    No braces around single-statement if's.
    No externs in .c files.
    use <linux/mman.h> not <asm/mman.h>.
    Use (foo *) not (foo*).
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 798439665e95c268c8920c29c33948a1e86313ea
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 16:08:35 2007 -0400

    Unionfs: coding style: avoid multiple assignments on same line
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit af298e93a17471c3d345d3d76659434bfb87904a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 15:47:25 2007 -0400

    Unionfs: coding style: take assignments out of "if" conditions
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 467dc9dd2681ff69239c0c1c05ade4eff6e22194
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Sep 30 13:02:36 2007 -0400

    Unionfs: coding style: proper spacing
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 4dc6edc6ae09c952b1c39cbcea775a62416f1115
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 02:26:31 2007 -0400

    Unionfs: use braces in both branches of conditionals
    
    As per CodingStyle, if one branch of an if-then-else has braces because it
    has multiple statements, then the other branch should have braces too, even
    if the other branch has only one statement in it.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 894b3c74d49a22cf7408f315696feed976213ca4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 02:05:21 2007 -0400

    Unionfs: remove periods from the end of printk strings
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 42367807b94f8bdb1d59970338d4d2b31cc3c6ca
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 02:00:56 2007 -0400

    Unionfs: update/assign a KERN_* level to all printk statements
    
    Also use pr_info() instead of printk(KERN_INFO ...)
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 990319eb1e1f7f1790a1a9afe21da96deb5211c7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 01:42:04 2007 -0400

    Unionfs: add missing newlines in printk's
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit be3b3319349e95905dc411c6bc9a452f693391b2
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 01:38:43 2007 -0400

    Unionfs: convert all appropriate printk's to pr_debug calls
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 555e6f86c14edf313fc19bbc2b0f590852399eb6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 01:06:22 2007 -0400

    Unionfs: use pr_debug() instead of custom dprintk()
    
    Also turn on DEBUG if CONFIG_UNION_FS_DEBUG is on
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit d68e258602df2f0eb90819717ef717d1705ef25e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:31:12 2007 -0400

    Unionfs: use page_offset() helper
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 9c6bcb32cbd59acac36da527b03eb519375230cb
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:25:20 2007 -0400

    Unionfs: remove unnecessary if condition
    
    The condition is always true there.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 52158a3629f0b3656990645809071679a6155451
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:23:18 2007 -0400

    Unionfs: properly indent static struct
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6f813338dd998214915dd4f5f1d83c55b08a5489
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:23:56 2007 -0400

    Unionfs: use UNIONFS_NAME macro
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 62430538d9b91fb8112235573d804df7612cce78
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:24:11 2007 -0400

    Unionfs: use consistent printk prefixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit e249d2d54fa218d47463857d271fd8e96df6f51d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:23:45 2007 -0400

    Unionfs: minor comment cleanups
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 02c94235178810acd50fb98003a2263b2771c939
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Sep 28 00:08:03 2007 -0400

    Unionfs: add un/likely on conditionals
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f63f94dd1b3f50639f0b091303a4be30087426ff
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sat Sep 29 01:05:01 2007 -0400

    Unionfs: compile if debug is off
    
    Signed-of-by: John Johansen <jjohansen@suse.de>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit fe342944416e0f5802026a1473198a389f85658c
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Sep 27 22:20:41 2007 -0400

    Unionfs: use poison.h for safe poison pointers
    
    This also fixes a compile warning on 64-bit systems.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 03c09e6881ba6392163c995959a1133700a64c00
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Sep 25 22:59:57 2007 -0400

    Unionfs: lower nameidata support for nfsv4
    
    Pass nameidata structures as needed to the lower file system, support
    LOOKUP_ACCESS/OPEN intents.  This makes unionfs work on top of nfsv4.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit d30c08a0b9d0e65c4f632024b62eee746c55796a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Sep 24 11:38:35 2007 -0400

    Unionfs: add lower nameidata debugging support
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 57b19d0087fe599b9424b101587ba1527799ba82
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Sep 24 11:38:35 2007 -0400

    Unionfs: minor coding style updates
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit cd9766e35a57b29d8848157d20379f3326e538d7
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Sep 25 23:00:22 2007 -0400

    Unionfs: cast page->index loff_t before shifting
    
    Fixes bugs in number promotion/demotion computation, as per
    <http://lkml.org/lkml/2007/9/20/17>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 87b70e7d35cd75f367467761230119ba64505e47
Author: Olivier Blin <blino@mandriva.com>
Date:   Mon Sep 24 22:50:53 2007 -0400

    Unionfs: cache-coherency fixes
    
    Do not update mtime if there is no upper branch for the inode.  This
    prevents from calling unionfs_lower_inode_idx() with a negative index, which
    triggers a bug.
    
    Signed-off-by: Olivier Blin <blino@mandriva.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 4e077c41b97b3fe89d33000a7b990d6b8d899b04
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Sep 25 22:59:31 2007 -0400

    Unionfs: display informational messages only if debug is on
    
    This is to avoid filling the console/logs with messages that are primarily
    of debugging use.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit b51811cc46ed1ddc9ea437d3feaf328e2807ce9a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Sep 24 22:52:51 2007 -0400

    Unionfs: Remove unused #defines
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 554d35d11737d684f7936136fdaee088bbdc53d7
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Sep 24 22:52:51 2007 -0400

    Unionfs: Simplify unionfs_get_nlinks
    
    Since we set the right value for d_type in readdir, there's really no point
    in having to calculate the number of directory links.  Some on-disk
    filesystems don't even store the number of links for directories.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 257cf5c5c41609c64142aebf4f8bdc6526e13158
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 14:48:22 2007 -0400

    Unionfs: cache coherency after lower objects are removed
    
    Prevent an oops if a lower file is deleted and then it is stat'ed from the
    upper layer.  Ensure that we return a negative dentry so the user will get
    an ENOENT.  Properly dput/mntput so we don't leak references at the lower
    file system.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit 6ad69efec95d47c26cbf6271773cdd88633081e5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 14:48:22 2007 -0400

    Unionfs: unionfs_lookup locking consistency
    
    Ensure that our lookup locking is consistent and symmetric: if a lock
    existed before calling lookup_backend, it should remain so; only if
    performing a lookup of a known new dentry, should lookup_backend return a
    newly-locked dentry-inode info (and only if there was no error).  Document
    this behavior.  This cleanup allowed us to remove two unnecessary int
    declarations.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit 4502d84454b59cad439608514d968aee696baad0
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 15:40:42 2007 -0400

    Unionfs: check integrity only if validated dentry successfully
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit 4901a3877b53369c69fc366e3dffff354d820d8d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 14:48:16 2007 -0400

    Unionfs: add missing newlines to printks
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit 1f2e18e945846b2e32992ac2f224cf7ab09338d2
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 14:48:22 2007 -0400

    Unionfs: remove unnecessary comment
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit f7e1224165dc2b9860a9df4ec2ecd60db6dd6764
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed Sep 19 14:48:22 2007 -0400

    Unionfs: use bool type in dentry and file revalidation code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Acked-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>

commit e943b3923b77615faf9d3d2f7dde4dd6cf7de938
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Aug 31 19:31:58 2007 -0400

    Unionfs: unionfs_create rewrite
    
    The code was hard to follow and violated some invariants (e.g., never modify
    a read only branch, and always create on branch 0).
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9555cbf09f6faa44f4bf728115e354f6b4d438de
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Tue Sep 4 18:15:49 2007 -0400

    Unionfs: debugging and validation of fan-out invariants
    
    Introduce debugging functionality, Makefile support to turn it on at compile
    time, and hooks in the main code to verify fan-out invariants.  This is very
    similar to how other file systems provide debugging functionality.  This
    code has been very useful in detecting and fixing problems, especially when
    stacking on top of assorted file systems.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 0d7cbf3123a4f0497506bcc74fcc441c6bd6f220
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Sep 3 19:53:58 2007 -0400

    Unionfs: update unionfs version number
    
    Update version number from 2.0 to 2.1 to reflect the amount of work that had
    gone in since 2.0 was first released, and also to sync up with Unionfs 2.x
    releases for earlier kernels.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit d2e7af712fcc60d0c889b5a789d691031736eacb
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 19:07:34 2007 -0400

    Unionfs: assorted comment and style updates
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 5db866be24b4b3292495574d3404c683793fb7aa
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:59:25 2007 -0400

    Unionfs: use file f_path field
    
    Start using file->f_path.dentry instead of file->f_dentry
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 64ef6fabe1afdcb324da1ba64648ad9fd3f607e9
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:55:36 2007 -0400

    Unionfs: extended attributes fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 03af7d2e7f5c09c7cae7bc13cc85e3dfeb647aa4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:55:08 2007 -0400

    Unionfs: minor remount fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 5eed226e1d725800d3f81dbf00e9e9fae63fc0a8
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:53:43 2007 -0400

    Unionfs: readonly branch test fix
    
    Bug fix to test if a lower branch is readonly, even when given negative
    dentries.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 0dad74fae87418544eaed6610546733d7067c0e1
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:49:51 2007 -0400

    Unionfs: remove old nfsro option
    
    Ensure that a branch set as 'ro' behaves like a real readonly mounted lower
    file system.  This allows us to remove the old 'nfsro' option.  Now unionfs
    handles even an readonly exported NFS file system, which was mounted on the
    client in readwrite mode.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit ec9f04d1a9bd99913854766e3827ff11ea8802d5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:49:29 2007 -0400

    Unionfs: mount-time option parsing fix
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 0d8bea9814d42a055fe0563ed33fd36a30e53e2e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:46:38 2007 -0400

    Unionfs: handling lower vfsmount fixes
    
    Properly increase/release lower vfsmounts.
    Validate proper use of unionfs mntget/put.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 8906dfa7878e8547002a053a4cbf4b14761bc3ff
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:38:58 2007 -0400

    Unionfs: mmap fixes
    
    Most important fixes prevent deadlocks especially under low-memory
    conditions, when one is not supposed to cause more memory pressure; also
    handle AOP_WRITEPAGE_ACTIVATE from lower file systems.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit b54df58edf671d45e026cb10fbd44e0f409de616
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:36:38 2007 -0400

    Unionfs: lower nameidata support
    
    Create and free custom nameidata structures, and pass them to lower file
    systems when needed via vfs_create.  (This code will get updated when/if
    nameidata is split into an intent structure and a VFS-level only structure.)
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9eb5a533c4f01f667a1d6b5eb819c451b5479fda
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:35:08 2007 -0400

    Unionfs: partial_lookup update
    
    Handle new semantics of lookup_backend.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a885e9050156a62f348867d51d025937e15c6634
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:34:36 2007 -0400

    Unionfs: unionfs_ioctl bug fixes
    
    Properly update lower objects, and release lower mnts upon ioctl success or
    failure.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit aeccc83e0913f7172412142a0ba6e2a223b47dfd
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:30:56 2007 -0400

    Unionfs: interpose updates
    
    Update unionfs_interpose to handle spliced dentries, which is important for
    NFS exporting.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 1cc9e978a47707f1d29b378872a942d8bab672fa
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:30:07 2007 -0400

    Unionfs: minor file_release updates
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit bcfada5f685b8333a3d778b5c98ca28c657fe3db
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:28:02 2007 -0400

    Unionfs: implement f/async
    
    Unionfs needs its own fsync and fasync instead of calling the generic
    file_fsync, because it may have to sync multiple writable lower branches
    (not just one).  This also allows Unionfs to compile with CONFIG_BLOCK=n.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 3a2d679b8326d58e64c493afd884880ad5ee3474
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 18:27:14 2007 -0400

    Unionfs: file_revalidate updates
    
    Correctly revalidate a file and account for lower mnts, even when branches
    are updated or inserted.  Better info upon file copyup.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9c23b4b0363a3893cbe8a545384abfd84dc2ad15
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:57:56 2007 -0400

    Unionfs: copyup updates
    
    Fixes, updates, and better documentation for the file-copyup functionality.
    Include two additional utility functions useful for copyup code callers.
    Parent directory copyup updates: create_parents now takes a string name
    instead of the whole dentry.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 869a381f15bbd2bc76a34b6973a1ff9444c5eb4b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Sep 3 19:53:02 2007 -0400

    Unionfs: documentation updates
    
    Details of cache-coherency implementation (as per OLS'07 talk).
    Also explain new incgen support via remount, not ioctl.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a1374dcd7b884dc07d4a63f45abd0838dbcbae5f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:24:35 2007 -0400

    Unionfs: cache-coherency and fixes for unionfs_rename
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a2f713f2e089089a16bba81239b1b38347d8bed4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:17:51 2007 -0400

    Unionfs: cache-coherency - file flush
    
    Update our inode's time after flush.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit cf940be466dab93cf18fdeca6e2968b572651e0e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Sep 6 12:40:28 2007 -0400

    Unionfs: cache-coherency - dentries
    
    Utility functions to check if lower dentries/inodes are newer than upper
    ones, and purging cached data if lower objects are newer.  Also passed flag
    to our d_revalidate_chain, to tell it if the caller may be writing data or
    just reading it.
    
    [jsipek: changed purge_inode_data to take a struct inode]
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 5a468ad2cddb82749000f9e20757f13fa9423abd
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:12:11 2007 -0400

    Unionfs: cache-coherency - update inode times
    
    Part of cache-coherency support (as per OLS'07 talk and
    Documentation/filesystems/unionfs/concepts.txt): update our inode time if
    lower had changed.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 1732a7caf3429ccfae6479d3a1e117fc01707b4e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:04:50 2007 -0400

    Unionfs: cpp endif comments
    
    Add comments to #endif's to help clarify code.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit d01d855768076b468ed6f8b8f643c9980176f275
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:03:58 2007 -0400

    Unionfs: copyright corrections and updates
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 75ca7d165e8015be78d9a361c9f8b85b12150052
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 16:09:20 2007 -0400

    Unionfs: do not use fsstack_copy_attr_all
    
    Unionfs needs a special fan-out version of fsstack_copy_attr_all, which is
    called unionfs_copy_attr_all.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 921546f73d65cd52208d5f26eaf43aee30d5be3e
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Aug 31 16:10:29 2007 -0400

    Unionfs: fixed compilation error
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a22633a8e7e07264389db4390a9dbb5fa8029c21
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 15:47:54 2007 -0400

    VFS/fsstack: remove 3rd argument to fsstack_copy_attr_all
    
    Unionfs needs a special fan-out version of fsstack_copy_attr_all. A
    single-level stackable file systems such as eCryptfs can therefore use a
    simplified fsstack_copy_attr_all function; remove its 3rd argument, which
    was never used by eCryptfs and was only used by Unionfs.
    
    Acked-by: Michael Halcrow <mhalcrow@us.ibm.com>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 57f414f0856cd399f09b98c07eb1ae2cb0325080
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Aug 31 15:34:45 2007 -0400

    VFS: export release_open_intent symbol
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 741ac75a827e75faac918bd055b32c1764af7732
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Jul 23 11:28:40 2007 -0400

    Unionfs: Remove slab destructors from kmem_cache_create()
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9c31d545ee7d3805cd6e78d7fa785d3a096eee09
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jul 20 23:36:11 2007 -0400

    Unionfs: Set copied up open file mode to read-write
    
    When we copyup a file, we used to set the new file's open mode to write
    only.  But we need read permission too.  We need write permission because
    we're creating a new file; and we need read permission because the original
    file had to have been readable.  If we don't set the new files permission to
    BOTH read and write, we get -EBADF when trying calling vfs_read/vfs_write on
    a copied up file.  (This fix is somewhat related to unionfs_readpage fixes
    that use vfs_read instead of calling the lower readpage.)
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit dbf19d99ee96b72ef35ef62b38fee389e99f1dd5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sat Jul 21 21:03:39 2007 -0400

    Unionfs: Rewrite do_unionfs_readpage to use vfs_read
    
    In do_unionfs_readpage, we used to call the lower file system's ->readpage.
    However, some file systems (e.g., tmpfs) don't implement ->readpage, causing
    a NULL pointer dereference under certain conditions, especially under severe
    memory pressure.  This patch reimplements do_unionfs_readpage using
    vfs_read, which makes the code simpler and more reliable, as we depend on
    the VFS to do most of the hard work (even if this implementation might be a
    bit slower).
    
    This fix also makes sense because it makes the mmap code in unionfs more
    symmetric with unionfs_commit_write --- which uses vfs_write().
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit de8237f3530828deb989757f91b5dab93caa9725
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jul 20 23:34:28 2007 -0400

    Unionfs: Fix minor typo in a comment
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit e2019c7536f9b0916b78c04db87be2732b671944
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jul 20 23:34:13 2007 -0400

    Unionfs: Use splice_read file method instead of sendfile
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 625b7b84549428a4a1679c6e61255e5c37a1dbee
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jul 20 23:33:29 2007 -0400

    Unionfs: Fix renaming symlinks on readonly branches bug
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 936a2ffbc7152229d4c45b56a20f28f698386ca9
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jul 20 23:32:49 2007 -0400

    Unionfs: Prevent deadlock with branch-management code
    
    Don't grab the superblock read-lock in unionfs_permission, which prevents a
    deadlock with the branch-management "add branch" code (which grabbed the
    write lock).  It is safe to not grab the read lock here, because even with
    branch management taking place, there is no chance that unionfs_permission,
    or anything it calls, will use stale branch information.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 286cbbb57423a5046e27893a30c7f01d021586c8
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jul 2 14:27:57 2007 -0400

    [PATCH] unionfs: make functions static
    
    This patch makes some needlessly global functions static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 52f62ee808f6c431f0a1ccfeef5140ae227f3de4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jun 29 02:02:11 2007 -0400

    Unionfs: Remove unnecessary BUG_ON in unionfs_follow_link
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4ffb982a9a40038c1763193936d565a3bb81a349
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jun 29 02:03:17 2007 -0400

    Unionfs: Clarification comment for unionfs_lookup
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 0d91a557555d1cc8aae973f0124e6a33f5ab86f9
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jun 29 01:49:08 2007 -0400

    Unionfs: Use file->f_path instead of file->f_dentry
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 67e76cb35cbc1f048157f0e3652b3c6af28853de
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 29 01:53:16 2007 -0400

    Unionfs: Add missing unlock call in unionfs_file_release
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 6ebf2056d4ae671af6f30f4f210f213442e50a98
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 23 15:26:18 2007 -0400

    Unionfs: Convert all instances of "hidden" to "lower"
    
    The Unionfs code contained many references to symbols whose name had the
    string "hidden" in it, referring to, for example, a "hidden inode" below the
    Unionfs inode.  The term "hidden" was there for historical reasons and was a
    misnomer, implying that the objects at Unionfs's lower branches were somehow
    hidden or unavailable.  This was not just incorrect, but confusing.  The
    lower objects are just that: lower.  They are not hidden from users.  In
    fact, users can 'cd' to lower branches and manipulate files directly there.
    This long patch renames all such mis-named symbols, and re-indents the code
    as needed to comply with coding standards.
    
    [jsipek: fixed up few rejects]
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 76cffa3bf4a1228b124005f06738fbb095de33bd
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 8 11:08:33 2007 -0400

    Unionfs: Remove superfluous check for NULL pointer
    
    Since we use containers and the struct inode is _inside_ the
    unionfs_inode_info structure, UNIONFS_I will always (given a non-NULL inode
    pointer), return a valid non-NULL pointer.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 2fc6fcefee671af41993843b48918d34bc1566c5
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 8 17:04:40 2007 -0400

    Unionfs: Change the semantics of sb info's rwsem
    
    This rw semaphore is used to make sure that a branch management operation...
    
    1) will not begin before all currently in-flight operations complete
    
    2) any new operations do not execute until the currently running branch
    management operation completes
    
    TODO: rename the functions unionfs_{read,write}_{,un}lock() to something
    more descriptive.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit f857ba196763096ad16f6031e222c1a6c39f639d
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 8 10:58:21 2007 -0400

    Unionfs: Add BUG_ONs to unionfs_lower_*
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 7ba0626e9c7346a9076851a038c698765ece5207
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 8 10:58:22 2007 -0400

    Unionfs: Change free_dentry_private_info to take a struct dentry
    
    This makes it more symmetric with new_dentry_private_info.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 8a98cb8d1a0ad4000adb2e9ab659ca632fc8f65f
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Jun 8 10:58:24 2007 -0400

    Unionfs: Cleanup new_dentry_private_data
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9d89eeeaa81f002dd450e7f85852a4aa5a16b6ad
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jun 8 10:39:11 2007 -0400

    Unionfs: Revalidate dentries passed to all inode/super operations
    
    Be sure to properly revalidate all dentry chains passed to all inode and
    super_block operations.  Remove the older BUG_ON test is_valid_dentry().
    This should help improve cache-coherency.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 906d84e7e985639f278636c1f995027bee3fe8d6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Jun 8 10:36:23 2007 -0400

    Unionfs: merge find_new_branch_index and branch_id_to_idx into one function
    
    Useful code cleanup and consolidation between the ODF code and non-ODF code.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 546ce91dbcb07499619dac1cbe8dd2cb000117c4
Author: Yiannis Pericleous <yiannos@fsl.cs.sunysb.edu>
Date:   Fri Jun 8 10:29:29 2007 -0400

    Unionfs: mmap implementation
    
    Signed-off-by: Shaya Potter <spotter@cs.columbia.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Yiannis Pericleous <yiannos@fsl.cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 9dd4836c0df02961e095ecdedb896906ae6808d1
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:42:59 2007 -0400

    Unionfs: Remove unnecessary #define
    
    UNIONFS_TMPNAM_LEN is used in only one place, and we have calculate the
    length of the string to begin with.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 2309064534878013c290b569fb2cc4040beb35fc
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:41:10 2007 -0400

    Unionfs: Add standard copyright comment to include/linux/union_fs.h
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 04ae0ef6b89c921617a0103962655fadc9fd73cc
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:40:22 2007 -0400

    MAINTAINERS: Add Erez Zadok as a maintainer of Unionfs
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 43ea6c27c7d6a73d7d4f1439cec5e4c0302824d5
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:28:37 2007 -0400

    Unionfs: call statfs on lower file system properly
    
    Get the correct lower dentry to use to statfs the first branch (always),
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a97c20a783f8b02ce468551a26273a010118a852
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:45:12 2007 -0400

    Unionfs: Set lower inodes correctly after branch management succeeds
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 070b36e6300c0cf48c2f900d34db753dbfb487d3
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:05:07 2007 -0400

    Unionfs: Retry lookup for different silly-renamed files
    
    When we have to copyup an open-but-unlinked file, we have to give it a
    temporary name, similar to NFS's silly-renamed files.  So we generate
    temporary file names until we find one that doesn't exist, and use it.  The
    code had a bug where if the silly-renamed file name already existed, Unionfs
    would oops upon copyup to that temp name.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 1d92c329097952733b65f417e7d7b878cfac0f31
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Jun 7 17:05:00 2007 -0400

    Unionfs: Don't revalidate dropped dentries
    
    This fixes a harmless but annoying message that unionfs prints if a dropped
    dentry is being revalidated, which could happen if you unlink open files.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit b64cbb4d63e13e0a96f2fad7d09859c3889b8881
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jun 6 20:38:19 2007 -0400

    [PATCH] unionfs section mismatch
    
    Fix section marker in header file:
    
    WARNING: fs/unionfs/unionfs.o(.init.text+0x56): Section mismatch: reference to .exit.text:stop_sioq (between 'init_module' and 'init_sioq')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 2724489cfceabe266eea1f981f4f81f716fd7e99
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jun 3 22:06:33 2007 -0400

    Unionfs: Fix lock leak in unionfs_ioctl
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 02099e8e7d59f995fa8226c06f31b7451afee67a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 18:27:24 2007 -0400

    Unionfs: Correctly decrement refcounts of mnt's upon branch management
    
    The old logic was broken in one place, which another place tried to "fix"
    incorrectly.  Also added detailed comments to explain the new/correct logic.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 935b5e85f439b87d6af113383699d0d58e157951
Author: Yiannis Pericleous <yiannos@fsl.cs.sunysb.edu>
Date:   Wed May 23 18:25:47 2007 -0400

    Unionfs: Removed a trailing whitespace
    
    Signed-off-by: Yiannis Pericleous <yiannos@fsl.cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 5e29a7334ea0645c912e511cac4a1c005d3a7d06
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Wed May 23 19:51:47 2007 -0400

    Unionfs: Actually catch bad use of unionfs_mnt{get,put}
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 90a43ef3682062d8f87d25be175fe6d143f2c35e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 17:57:31 2007 -0400

    Unionfs: Remove defunct unionfs_put_inode super op
    
    Removed old workaround code that was needed to get mmap working, is no
    longer needed with recent kernels.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 496792492e160cc67f4a3d880f2af20445ff1c09
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 17:55:28 2007 -0400

    Unionfs: Documentation update regarding overlapping branches and new lookup code
    
    Added detailed comment and updated documentation to explain why overlapping
    branches are disallowed, and better explain the cache coherency issues.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit cb6004bb44a72265bfbb97c0092c946b1cda3181
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 17:48:11 2007 -0400

    Unionfs: Disallow setting leftmost branch to readonly
    
    Unionfs requires the leftmost branch to be writeable for copyup to work
    properly and simply.  If, through branch-management commands (add, delete,
    or mode change), the leftmost branch will becomes readonly, then return an
    error (and tell the user to use "remount,ro" if they want a readonly union).
    
    [jsipek: fixed up to apply cleanly]
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 6f333a7128189a21220ef235c9c429c926244d5b
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Wed May 23 17:17:31 2007 -0400

    Unionfs: Use krealloc instead of open-coding the functionality
    
    Change the branch management code to use krealloc instead of playing tricks
    with kmalloc/memcpy/kfree.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 34d1900a89b3f5330772875a98c5ba357b6c86b2
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Wed May 23 17:06:08 2007 -0400

    Unionfs: Call realloc unconditionally
    
    krealloc already checks if the new size is greater than the old size.
    Therefore, we can call realloc unconditionally - making the code simpler and
    cleaner.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 086e3dd16979e9a3033c5145ebacf775dce5d8b1
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Wed May 23 16:44:54 2007 -0400

    Unionfs: Don't leak resources when copyup fails partially
    
    Original-patch-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit abe277fe83d6275b41cc37ebaa7adecd79bfe8d4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 16:33:24 2007 -0400

    Unionfs: Prefix external functions with 'extern' properly
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 962b81f9f9180ca365fe79404d5eed5bb6bf322c
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Wed May 23 16:25:21 2007 -0400

    Unionfs: Combine unionfs_write with __unionfs_write.
    
    The __unionfs_write helper function was used only by unionfs_write, and
    there is really no reason why they should not be combined.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit febd84bba0110558dcfd54f13125d993faf60a88
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun May 20 17:12:48 2007 -0400

    Unionfs: Move unionfs_query_file to commonfops.c
    
    Moved unionfs_query_file closer to its one user in commonfops.c.
    Additionally, it can now become static, and branchman.c can be removed as it
    is empty.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4f7d7f62fa03fac0d210245a589ca9ab0527b790
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 16:44:52 2007 -0400

    Unionfs: Rename our "do_rename" to __unionfs_rename
    
    To avoid confusion with the VFS function do_rename, and to help ctags,
    rename our utility (static) function do_rename to __unionfs_rename.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 82c98b2b8247e5f6416307dda03f574448d7a229
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 16:23:01 2007 -0400

    Unionfs: Rename Unionfs's double_lock_dentry to avoid confusion
    
    To avoid potential confusion with a VFS function, rename our version of
    double_lock_dentry to unionfs_double_lock_dentry.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 91bd334a1209d552cf8fe146e815b7411869f34b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 16:03:00 2007 -0400

    Unionfs: Consistent pointer declaration spacing
    
    Change instances of "foo * var" to "foo *var" for consistency.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4311e792cbd1706044bd52fd2239f818fe3d2332
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 16:46:21 2007 -0400

    Unionfs: Added numerous comments
    
    Audited entire code for documentation.  Added comments at top of functions
    where it felt necessary (i.e., function's name and size don't make it clear
    what it may be doing precisely).  Reformatted some long comments.  Fixed a
    few comment typos and spelling errors.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit fc7fb970cc55d5fd968c7a8a222166263bdada3d
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 23 15:19:58 2007 -0400

    Unionfs: Cleanup of strings and comments
    
    Includes:
    	- consistent style for multi-line comments
    	- spell-check of all strings and comments
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 69a56145fb9cc9bcbc27990ae2bb152c52e59b14
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 15:21:08 2007 -0400

    Unionfs: Add missing copyright notices
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4509f4ecd29af39cc0f1f532ec77585f31717772
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 15:36:32 2007 -0400

    Unionfs: Every printk should prefix with "unionfs: " consistently
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit f21b3ca00aad3fc2c40db68bc312eaeae04e8122
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Jul 23 15:18:35 2007 -0400

    Unionfs: Coding style fixes
    
    Includes:
    	- indentation fixes
    	- 80 column wrapping
    	- removing unnecessary braces
    	- removing trailing whitespace
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 70acc7138fd68f8eff494ce3a63a29d53a45a181
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun May 20 15:18:38 2007 -0400

    Unionfs: Tiny documentation fixups
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit fe06ad0f55f14bd6236ce39187f0adb0f966b1ac
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sat May 19 03:14:30 2007 -0400

    Unionfs: SLAB_CTOR_CONSTRUCTOR has been removed from vanilla
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 888e646128eecf9f7bdfb5b9427a604f5d7f9841
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Sun May 13 12:55:44 2007 -0400

    [PATCH] unionfs: fix slab abuses with krealloc
    
    This changes unionfs to use krealloc() for reallocating memory so that we
    don't need to play tricks with slab internals.
    
    Cc: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4898444eff5ff58d0a1ee976189539f5e72f5143
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat May 5 15:28:33 2007 -0400

    [PATCH] fix unionfs compilation
    
    On Sat, May 05, 2007 at 01:49:55AM -0700, Andrew Morton wrote:
    >...
    > Changes since 2.6.21-rc7-mm2:
    >...
    >  git-unionfs.patch
    >...
    >  git trees
    >...
    
    <--  snip  -->
    
    ...
      CC      fs/unionfs/super.o
    /home/bunk/linux/kernel-2.6/linux-2.6.21-mm1/fs/unionfs/super.c: In function ‘init_once’:
    /home/bunk/linux/kernel-2.6/linux-2.6.21-mm1/fs/unionfs/super.c:822: error: ‘SLAB_CTOR_VERIFY’ undeclared (first use in this function)
    /home/bunk/linux/kernel-2.6/linux-2.6.21-mm1/fs/unionfs/super.c:822: error: (Each undeclared identifier is reported only once
    /home/bunk/linux/kernel-2.6/linux-2.6.21-mm1/fs/unionfs/super.c:822: error: for each function it appears in.)
    make[3]: *** [fs/unionfs/super.o] Error 1
    
    <--  snip  -->
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4b99f5d51f5830e18caef1a1fad25f7f6fefcefb
Author: Adrian Brunyate <abrunyate@yahoo.com>
Date:   Thu Apr 26 18:51:16 2007 -0400

    Unionfs: Check remount options for being NULL
    
    Signed-off-by: Adrian Brunyate <abrunyate@yahoo.com>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 2226cbeb3022d45868316e5729ee9671bffc0bd0
Author: Adrian Brunyate <abrunyate@yahoo.com>
Date:   Thu Apr 26 18:51:09 2007 -0400

    Unionfs: Accept MS_SILENT during remount
    
    [jsipek: whitespace cleanup]
    Signed-off-by: Adrian Brunyate <abrunyate@yahoo.com>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 91f2d8a12b7e66c536a7a41e70312b25d1ff8bd0
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 23 13:10:46 2007 -0400

    Unionfs: Don't inline do_remount_{add,del,mode}_option
    
    gcc4 decided to inline do_remount_{add,del,mode}_option creating an 600 byte
    stack abuser on a x86_64 test box.
    
    Reported by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit bb1f93d2d36e0489e83c069108da7bf9de08e233
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 23 13:07:14 2007 -0400

    Unionfs: Added several BUG_ONs to assert dentry validity
    
    This should help catch races between the VFS and the branch-management code.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit e94a9ae40900ba7743ec1eb01f6c10f2b0880564
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 20:17:48 2007 -0400

    Unionfs: Properly handle stale inodes passed to unionfs_permission
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 5089ee09eeb70917f74da982dc9a8d6bb735b221
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 20:09:07 2007 -0400

    Unionfs: Pass lowernd to lower ->revalidate function
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 05549238f8505d6a31722713edac841440d43837
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 20:08:30 2007 -0400

    Unionfs: vfsmount reference counting fixes
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 21d2c180e138e066995e681c2cfdbe89104bf997
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 20:01:56 2007 -0400

    Unionfs: unionfs_create needs to revalidate the dentry
    
    We have to read-lock the superblock rwsem, and we have to revalidate the
    parent dentry and this one.  A branch-management operation could have taken
    place, mid-way through a VFS operation that eventually reaches
    unionfs_create().  So we have to ensure consistency, just as we do with the
    file operations.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 1321aa049bb073a564d95284f2c6e461c3ac2058
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 19:47:43 2007 -0400

    Unionfs: Decrement totalopens counter on error in unionfs_open
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a09dddc449224ff17661fc3537f92dca7823f5cd
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Mar 18 16:30:45 2007 -0400

    Unionfs: Document unionfs_d_release locking
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit b3a8cee7d28aa11fec3dbf5806616a768b44561a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Mar 18 16:22:03 2007 -0400

    Unionfs: Remove the older incgen ioctl
    
    The new remount code now has the "incgen" functionality.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 69961f4e54fc5a8eacf405c4b3b68c38a82dfe87
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 19:32:40 2007 -0400

    Unionfs: Grab the unionfs sb private data lock around branch info users
    
    Locking/concurrency/race fixes.  Use the unionfs superblock rwsem, and grab
    the read lock around every op that uses branch-related information, such as
    branch counters.  Grab the write rwsem lock in operations which attempt to
    change branch information, such as when adding/deleting branches.  This
    will, for example, cause branch-management remount commands (which are
    infrequent) to block a bit until all in-progress file operations on open
    files are done.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    [jsipek: whitespace fixes & more locks/unlocks]
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 573eb8f61176a48f813f0e528bc5c8a57d5b8f7e
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 19 21:02:55 2007 -0400

    Unionfs: Rewrite unionfs_d_revalidate
    
    Rewrite unionfs_d_revalidate code to avoid stack-unfriendly recursion: split
    into a call to revalidate just one dentry, and an interative driver function
    to revalidate an entire dentry-parent chain.
    
    Fix vfsmount ref leaks which prevented lower f/s from being unmounted after
    generation increment, esp. during heavy loads.
    
    Fix one deadlock between revalidation code and VFS.
    
    Better documentation of what the code does.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    [jsipek: compile & whitespace fixes]
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 70c09a8979259897a634b0fc249fe3a2b72751ce
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 19 20:57:49 2007 -0400

    Unionfs: Introduce unionfs_mnt{get,put}
    
    Helper inline functions to perform Unionfs's mntget/put ops on lower
    branches.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    [jsipek: cleanup branching in unionfs_mnt{get,put} and compile fixes]
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 7177383a4318350651f3e9aa41e21ce252b1f15a
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 19 20:44:12 2007 -0400

    Unionfs: Bulk of branch-management remount code
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 89a86b6db8c5f003a0fc92387ba879c5208d4512
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Mar 22 19:43:29 2007 -0400

    Unionfs: Introduce branch-id code
    
    Each branch gets a unique ID, which helps during branch additions,
    deletions, and changes, to locate where branches were moved to, and perform
    proper reference-counting.  This is useful even if the same directory was
    added more than once to union.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 38486c24bb3e8fe9d975bfa67c553cdb82c32ef6
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Apr 9 09:57:51 2007 -0400

    Unionfs: Actually verify if dentry's info node is locked
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4710da41d1929772896a32063e1d6c512f4bf07b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 19 03:01:49 2007 -0400

    Unionfs: Provide more helpful info on branch leaks during unmount
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    [jsipek: no need to take a read lock on the superblock private data]
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit e4a68f42e61ca972b1806db2f31c9511961d10ce
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Mar 19 00:46:03 2007 -0400

    Unionfs: Rename unionfs_data sbcount field to more appropriate open_files
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 37cb6d28c706ba1ad41762390f590d48b6c57f74
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Mar 18 19:37:51 2007 -0400

    Unionfs: Proper comment on rwsem field
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 73c0671e9795c72415169a0f9106a21f46f96934
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 23 17:17:07 2007 -0400

    Unionfs: Documentation updates for branch-management
    
    Describe dynamic branch-management introduced by subsequent patches.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 672d6069d99dd72d3a5e452090e00f5a77186884
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 20:39:35 2007 -0400

    fs: Export drop_pagecache_sb symbol
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 1ed14c8899c9acd90004fdbb33c117be9db9e3c4
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Wed May 23 20:42:50 2007 -0400

    fs: Introduce path{get,put}
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 6e7a72534ce150e190da9cd0842ae3adf7ec26e3
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Mar 19 19:15:22 2007 -0400

    [PATCH] Unionfs: sioq not __exit
    
    stop_sioq() is called from both __init and __exit functions, so it
    shouldn't be marked __exit.
    
    Reported on the kernelnewbies mailing list, but no patch offered there.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 56df0d0867e4477005b1fd2d0d0f354f6be93925
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sat Mar 17 19:42:25 2007 -0400

    MAINTAINERS: Unionfs URL update
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit e5a862e4d8338d30e0d037ec42ae3e9c149ffdac
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Mar 4 18:02:11 2007 -0500

    fs/unionfs/: Fix unlocking in error paths
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit aec7bc83f16fa4f98c22915cfa7acca4dabc7a25
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Mar 4 15:21:14 2007 -0500

    fs/unionfs/: Fix dentry leak in copyup_named_dentry
    
    When we chmod a directory on a readonly branch, and have to copy it up, we
    forget to dput(). If this was a file, it gets dput indirectly through other
    functions we call, but not if it was a directory.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 184f28b1d73f61225404f1781dc5ccf4ee849fba
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 2 13:10:56 2007 -0500

    fs/unionfs/: mntput in __cleanup_dentry
    
    This fixes a mnt refleak which occured during copyup when directory
    hierarchy was recreated on a writable branch.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 6ff0d3b80542baa4cda4ae94bef3d5d8408d7350
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Sun Mar 4 00:41:51 2007 -0500

    fs/unionfs/: Fix copyup_deleted_file dentry leak
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 112d4db82f24df8260111ef4838bf141dfe9864a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Mar 2 13:14:01 2007 -0500

    fs/unionfs/: Miscellaneous coding style fixes
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 8de83fb799760660b77fa001f62e9d8279cb9741
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Tue Feb 27 14:27:25 2007 -0500

    fs/unionfs/: Check return value of d_path
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 727d0a3b85763d9dc4a034972d65eba388ff8171
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Feb 25 17:32:46 2007 -0500

    fs/unionfs/: Use SEEK_{SET,CUR} instead of hardcoded values
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 14e87a0ae41b3f1bfd7398d3f276ea8bf3128d0a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Feb 25 17:30:34 2007 -0500

    fs/unionfs/: Remove alloc_filldir_node
    
    alloc_filldir_node was used only once. Additionally, all the arguments
    passed to it were ignored wasting stack space for no reason whatsoever.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 318c983a7965759c215e1c56b94464b067d16fae
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sat Feb 24 16:47:45 2007 -0500

    fs/unionfs/: Rename unionfs_d_revalidate_wrap
    
    Follow the convention of "foo" calling "__foo".
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 8b84a0d7e61cfd331d88990d750ac180ff81aabd
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sat Feb 24 16:46:08 2007 -0500

    fs/unionfs/: Several small cleanups in unionfs_interpose
    
    1) No need to lock the inode - lockdep was complaining about potential
    circular dependency
    
    2) No need to use temporary variable for iunique() inode number
    
    3) Removed unneeded comment
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit e5c1f0eb9cdc92e0a9b122f9ac86162cdb8eaedc
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Feb 23 01:04:09 2007 -0500

    fs/unionfs/: Don't grab dentry private data mutex in unionfs_d_release
    
    Grabbing the UNIONFS_D(dentry)->lock is completely unnecessary and there are
    no other references; we are about to free the object anyway. Additionally,
    grabbing the mutex produces warning when the slab object is reused - as it
    was freed while there still was a reference to it.
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4070cf0252b321188759001b7780fb8a67ec2544
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 2 13:35:33 2007 -0500

    fs/unionfs/: Fix a memory leak in unionfs_read_super
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit d5782cf88e73943f91cc81b108e0ad0d62087b1f
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Fri Mar 2 13:00:57 2007 -0500

    fs/unionfs: Fix a memory leak & null pointer dereference
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4251259d7ad56c99aade94c728a88529811fe8f0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed Feb 21 01:30:10 2007 -0500

    [PATCH] UNION_FS must depend on SLAB
    
    On Sat, Feb 17, 2007 at 09:51:46PM -0800, Andrew Morton wrote:
    >...
    > Changes since 2.6.20-mm1:
    >...
    >  git-unionfs.patch
    >...
    >  git trees
    >...
    
    <--  snip  -->
    
    ...
      CC      fs/unionfs/copyup.o
    /home/bunk/linux/kernel-2.6/linux-2.6.20-mm2/fs/unionfs/copyup.c: In function 'create_parents_named':
    /home/bunk/linux/kernel-2.6/linux-2.6.20-mm2/fs/unionfs/copyup.c:620: error: 'malloc_sizes' undeclared (first use in this function)
    /home/bunk/linux/kernel-2.6/linux-2.6.20-mm2/fs/unionfs/copyup.c:620: error: (Each undeclared identifier is reported only once
    /home/bunk/linux/kernel-2.6/linux-2.6.20-mm2/fs/unionfs/copyup.c:620: error: for each function it appears in.)
    make[3]: *** [fs/unionfs/copyup.o] Error 1
    
    <--  snip  -->
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 94719260b13f0e9cac3646e1b089ffb0806e8942
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sat Feb 17 03:25:15 2007 -0500

    fs/unionfs/: Remove unused structure members & macros
    
    This patch removes:
    - hidden_mnt pointer from struct unionfs_data
    - mount_flag from struct unionfs_sb_info
    - mount_flag related macros
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 924eb67fc77f6bf5987c46fd1bda49a136982b1b
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Mon Feb 12 12:36:38 2007 -0500

    Unionfs: Documentation update
    
    Be little gentler & updated the URLs
    
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit a05d4c454503f716d074737ca893db15143a2612
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Feb 19 23:35:32 2007 -0500

    fs/: Move eCryptfs & Unionfs config options into a sub-menu
    
    Using The Misc filesystems sub-menu for layered/stackable filesystems only
    makes it harder for users to find eCryptfs/Unionfs.
    
    Additionally, the menu can be easily turned into a menuconfig, which could
    be used to turn on any VFS/VM functionality required by layered filesystems
    (there is none at the moment).
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Michael Halcrow <mhalcrow@us.ibm.com>

commit 2248a562aba7a7d9a86b35c6d7a879c96dc0a7ae
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Thu Feb 1 12:14:03 2007 -0500

    fs/unionfs/: Use __roundup_pow_of_two instead of custom rounding code
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 61ca9b3f4e848d4269dc359b25db23763f51fc52
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 14:20:19 2007 -0500

    fs/unionfs/: Don't duplicate the struct nameidata
    
    The only fields that we have to watch out for are the dentry and vfsmount.
    Additionally, this makes Unionfs gentler on the stack as nameidata is rather
    large.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 25c4ddb16fb3808ccde98016ec932f32c5ee4e2d
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 14:20:49 2007 -0500

    fs/unionfs/: Andrew Morton's comments
    
    - rename {,un}lock_dentry to unionfs_{,un}lock_dentry
    - few minor coding style fixes
    - removed prototypes from .c files
    - replaced dbstart macros etc with static inlines
    - replaced UNIONFS_D(d)->sem semaphore with a mutex
    - renamed sioq struct workqueue to superio_workqueue
    - made unionfs_get_nlinks and alloc_whname not inlined
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 636e4f0e83afa10146c90155eec4da1b87f07c33
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jan 25 03:15:59 2007 -0500

    fs/unionfs/: possible cleanups
    
    This patch contains the following possible cleanups:
    - every function should #include the headers containing the prototypes
      of it's global functions
    - static functions in C files shouldn't be marked "inline", gcc should
      know best when to inline them
    - make needlessly global code static
    - #if 0 the following unused global function:
      - stale_inode.c: is_stale_inode()
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    [removed stale inode related fixes as stale_inode.c is gone]
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 499e79fb448f591ac8abb10c588b10ff25e3dfe1
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:52:43 2007 -0500

    fs/unionfs/: Remove stale_inode.c
    
    The stale inode operations were heavily based on bad inode operations. This
    patch removes stale_inode.c and converts all users of stale_inode_ops to
    bad_inode_ops as there seems to be no reason to return ESTALE instead of
    EIO.
    
    This is the more appropriate than porting the bad_inode.c fix (commit
    be6aab0e9fa6d3c6d75aa1e38ac972d8b4ee82b8) to stale_inode.c.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>

commit 4acdeec49cfeb1260f8d94d3f149409c80391c12
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:11:23 2007 -0500

    Unionfs: Extended Attributes support
    
    Extended attribute support.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 07a665ad873ab5c66217cb96107149e958d6fa83
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:10:20 2007 -0500

    Unionfs: Kconfig and Makefile
    
    This patch contains the changes to fs Kconfig file, Makefiles, and Maintainers
    file for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit e8fcaca301e4d9419324925e2fdda573d31c9609
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:47:57 2007 -0500

    Unionfs: Unlink
    
    This patch provides unlink functionality for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 6de8748e3abc3a8840726dde1ac924dedefdea1b
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:47:43 2007 -0500

    Unionfs: Include file
    
    Global include file - can be included from userspace by utilities.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f360fbdfb09a08269a2200319efc5b15869c6d3a
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:05:29 2007 -0500

    Unionfs: Internal include file
    
    This patch contains an internal Unionfs include file. The include file is
    specific to kernel code only, and therefore is separate from
    include/linux/unionfs.h.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit eeda0e2866d2a90ed798f6338b726c9399935a00
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:46:56 2007 -0500

    Unionfs: Helper macros/inlines
    
    This patch contains many macros and inline functions used thoughout Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit b57266735ee50e6f29362c0c3a05a01af1b54198
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:05:07 2007 -0500

    Unionfs: Handling of stale inodes
    
    Provides nicer handling of stale inodes.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit cde77c25ce5daf6636cc83e92ba56cbb50d3603a
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:46:47 2007 -0500

    Unionfs: Superblock operations
    
    This patch contains the superblock operations for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 56bd4d6c86169e12450942184aea4fca85c99f6c
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:46:39 2007 -0500

    Unionfs: Miscellaneous helper functions
    
    This patch contains miscellaneous helper functions used thoughout Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 284806839673d035cb7fa7d0ca5499e008875166
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:46:11 2007 -0500

    Unionfs: Privileged operations workqueue
    
    Workqueue & helper functions used to perform privileged operations on
    behalf of the user process.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit cec268a60ae0a0f1366b75456f233bc8033e8a0c
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:45:56 2007 -0500

    Unionfs: Rename
    
    This patch provides rename functionality for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit abfb0491f5cdb56215195c0a12102a0ab464faf6
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:45:48 2007 -0500

    Unionfs: Readdir state
    
    This file contains the routines for maintaining readdir state.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit ff9ef2bb954ce33d6757854a5fa5e48fa9874a66
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:45:28 2007 -0500

    Unionfs: Main module functions
    
    Module init & cleanup code, as well as interposition functions.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 4156de55caba984c7c1666e356fe4a0c8abb044c
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Jul 23 15:13:25 2007 -0400

    Unionfs: Lookup helper functions
    
    This patch provides helper functions for the lookup operations in Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit e89e8816862c60ba6a0242f93ab8f5f169325ab8
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:44:54 2007 -0500

    Unionfs: Inode operations
    
    This patch provides the inode operations for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2c7fe6068a98fdfde1807cef5d33e3880c5b382b
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:44:35 2007 -0500

    Unionfs: Directory manipulation helper functions
    
    This patch contains directory manipulation helper functions.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 24d2b42a1aadf1d4c18ab0159dde11837c2b2a78
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:44:24 2007 -0500

    Unionfs: Directory file operations
    
    This patch provides directory file operations.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 7d12ef68b5ef573872115b22dab78009f55cfca7
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:44:05 2007 -0500

    Unionfs: File operations
    
    This patch provides the file operations for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit db0de21bb0054c619934461c0a646b05c241dab7
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 28 15:05:21 2007 -0500

    Unionfs: Dentry operations
    
    This patch contains the dentry operations for Unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 944443161310119f7ca0f68e000644b06b4eb13e
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:42:32 2007 -0500

    Unionfs: Copyup Functionality
    
    This patch contains the functions used to perform copyup operations in unionfs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit 2f95cf12412ecaa942ad2eb3a4648ad1f4b91695
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:42:16 2007 -0500

    Unionfs: Common file operations
    
    This patch contains helper functions used through the rest of the code which
    pertains to files.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit f34faca1f327156b0a30b7685024ed4e6b545f17
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Sun Jan 21 18:42:01 2007 -0500

    Unionfs: Branch management functionality
    
    This patch contains the ioctls to increase the union generation and to query
    which branch a file exists on.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>

commit bbeaf0165067f0ffce3e20df880630c2ce3a5e80
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Feb 19 23:31:35 2007 -0500

    Unionfs: Documentation
    
    This patch contains documentation for Unionfs. You will find several files
    outlining basic unification concepts and rename semantics.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: David Quigley <dquigley@fsl.cs.sunysb.edu>
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
 Documentation/filesystems/00-INDEX             |    2 +
 Documentation/filesystems/unionfs/00-INDEX     |   10 +
 Documentation/filesystems/unionfs/concepts.txt |  287 +++++++
 Documentation/filesystems/unionfs/issues.txt   |   28 +
 Documentation/filesystems/unionfs/rename.txt   |   31 +
 Documentation/filesystems/unionfs/usage.txt    |  134 +++
 MAINTAINERS                                    |    8 +
 fs/Kconfig                                     |   53 +-
 fs/Makefile                                    |    1 +
 fs/ecryptfs/dentry.c                           |    2 +-
 fs/ecryptfs/inode.c                            |    6 +-
 fs/ecryptfs/main.c                             |    2 +-
 fs/namei.c                                     |    1 +
 fs/splice.c                                    |   20 +-
 fs/stack.c                                     |   82 ++-
 fs/unionfs/Makefile                            |   13 +
 fs/unionfs/commonfops.c                        |  905 ++++++++++++++++++++
 fs/unionfs/copyup.c                            |  879 ++++++++++++++++++++
 fs/unionfs/debug.c                             |  533 ++++++++++++
 fs/unionfs/dentry.c                            |  570 +++++++++++++
 fs/unionfs/dirfops.c                           |  292 +++++++
 fs/unionfs/dirhelper.c                         |  157 ++++
 fs/unionfs/fanout.h                            |  384 +++++++++
 fs/unionfs/file.c                              |  341 ++++++++
 fs/unionfs/inode.c                             |  984 ++++++++++++++++++++++
 fs/unionfs/lookup.c                            |  570 +++++++++++++
 fs/unionfs/main.c                              |  777 ++++++++++++++++++
 fs/unionfs/mmap.c                              |   89 ++
 fs/unionfs/rdstate.c                           |  285 +++++++
 fs/unionfs/rename.c                            |  478 +++++++++++
 fs/unionfs/sioq.c                              |  101 +++
 fs/unionfs/sioq.h                              |   91 ++
 fs/unionfs/subr.c                              |   95 +++
 fs/unionfs/super.c                             | 1042 ++++++++++++++++++++++++
 fs/unionfs/union.h                             |  600 ++++++++++++++
 fs/unionfs/unlink.c                            |  277 +++++++
 fs/unionfs/whiteout.c                          |  577 +++++++++++++
 fs/unionfs/xattr.c                             |  153 ++++
 include/linux/fs_stack.h                       |   20 +-
 include/linux/magic.h                          |    2 +
 include/linux/splice.h                         |    5 +
 include/linux/union_fs.h                       |   24 +
 42 files changed, 10864 insertions(+), 47 deletions(-)

diff --git a/Documentation/filesystems/00-INDEX b/Documentation/filesystems/00-INDEX
index 52cd611..bc6b437 100644
--- a/Documentation/filesystems/00-INDEX
+++ b/Documentation/filesystems/00-INDEX
@@ -106,6 +106,8 @@ udf.txt
 	- info and mount options for the UDF filesystem.
 ufs.txt
 	- info on the ufs filesystem.
+unionfs/
+	- info on the unionfs filesystem
 vfat.txt
 	- info on using the VFAT filesystem used in Windows NT and Windows 95
 vfs.txt
diff --git a/Documentation/filesystems/unionfs/00-INDEX b/Documentation/filesystems/unionfs/00-INDEX
new file mode 100644
index 0000000..96fdf67
--- /dev/null
+++ b/Documentation/filesystems/unionfs/00-INDEX
@@ -0,0 +1,10 @@
+00-INDEX
+	- this file.
+concepts.txt
+	- A brief introduction of concepts.
+issues.txt
+	- A summary of known issues with unionfs.
+rename.txt
+	- Information regarding rename operations.
+usage.txt
+	- Usage information and examples.
diff --git a/Documentation/filesystems/unionfs/concepts.txt b/Documentation/filesystems/unionfs/concepts.txt
new file mode 100644
index 0000000..b853788
--- /dev/null
+++ b/Documentation/filesystems/unionfs/concepts.txt
@@ -0,0 +1,287 @@
+Unionfs 2.x CONCEPTS:
+=====================
+
+This file describes the concepts needed by a namespace unification file
+system.
+
+
+Branch Priority:
+================
+
+Each branch is assigned a unique priority - starting from 0 (highest
+priority).  No two branches can have the same priority.
+
+
+Branch Mode:
+============
+
+Each branch is assigned a mode - read-write or read-only. This allows
+directories on media mounted read-write to be used in a read-only manner.
+
+
+Whiteouts:
+==========
+
+A whiteout removes a file name from the namespace. Whiteouts are needed when
+one attempts to remove a file on a read-only branch.
+
+Suppose we have a two-branch union, where branch 0 is read-write and branch
+1 is read-only. And a file 'foo' on branch 1:
+
+./b0/
+./b1/
+./b1/foo
+
+The unified view would simply be:
+
+./union/
+./union/foo
+
+Since 'foo' is stored on a read-only branch, it cannot be removed. A
+whiteout is used to remove the name 'foo' from the unified namespace. Again,
+since branch 1 is read-only, the whiteout cannot be created there. So, we
+try on a higher priority (lower numerically) branch and create the whiteout
+there.
+
+./b0/
+./b0/.wh.foo
+./b1/
+./b1/foo
+
+Later, when Unionfs traverses branches (due to lookup or readdir), it
+eliminate 'foo' from the namespace (as well as the whiteout itself.)
+
+
+Opaque Directories:
+===================
+
+Assume we have a unionfs mount comprising of two branches.  Branch 0 is
+empty; branch 1 has the directory /a and file /a/f.  Let's say we mount a
+union of branch 0 as read-write and branch 1 as read-only.  Now, let's say
+we try to perform the following operation in the union:
+
+	rm -fr a
+
+Because branch 1 is not writable, we cannot physically remove the file /a/f
+or the directory /a.  So instead, we will create a whiteout in branch 0
+named /.wh.a, masking out the name "a" from branch 1.  Next, let's say we
+try to create a directory named "a" as follows:
+
+	mkdir a
+
+Because we have a whiteout for "a" already, Unionfs behaves as if "a"
+doesn't exist, and thus will delete the whiteout and replace it with an
+actual directory named "a".
+
+The problem now is that if you try to "ls" in the union, Unionfs will
+perform is normal directory name unification, for *all* directories named
+"a" in all branches.  This will cause the file /a/f from branch 1 to
+re-appear in the union's namespace, which violates Unix semantics.
+
+To avoid this problem, we have a different form of whiteouts for
+directories, called "opaque directories" (same as BSD Union Mount does).
+Whenever we replace a whiteout with a directory, that directory is marked as
+opaque.  In Unionfs 2.x, it means that we create a file named
+/a/.wh.__dir_opaque in branch 0, after having created directory /a there.
+When unionfs notices that a directory is opaque, it stops all namespace
+operations (including merging readdir contents) at that opaque directory.
+This prevents re-exposing names from masked out directories.
+
+
+Duplicate Elimination:
+======================
+
+It is possible for files on different branches to have the same name.
+Unionfs then has to select which instance of the file to show to the user.
+Given the fact that each branch has a priority associated with it, the
+simplest solution is to take the instance from the highest priority
+(numerically lowest value) and "hide" the others.
+
+
+Unlinking:
+=========
+
+Unlink operation on non-directory instances is optimized to remove the
+maximum possible objects in case multiple underlying branches have the same
+file name.  The unlink operation will first try to delete file instances
+from highest priority branch and then move further to delete from remaining
+branches in order of their decreasing priority.  Consider a case (F..D..F),
+where F is a file and D is a directory of the same name; here, some
+intermediate branch could have an empty directory instance with the same
+name, so this operation also tries to delete this directory instance and
+proceed further to delete from next possible lower priority branch.  The
+unionfs unlink operation will smoothly delete the files with same name from
+all possible underlying branches.  In case if some error occurs, it creates
+whiteout in highest priority branch that will hide file instance in rest of
+the branches.  An error could occur either if an unlink operations in any of
+the underlying branch failed or if a branch has no write permission.
+
+This unlinking policy is known as "delete all" and it has the benefit of
+overall reducing the number of inodes used by duplicate files, and further
+reducing the total number of inodes consumed by whiteouts.  The cost is of
+extra processing, but testing shows this extra processing is well worth the
+savings.
+
+
+Copyup:
+=======
+
+When a change is made to the contents of a file's data or meta-data, they
+have to be stored somewhere.  The best way is to create a copy of the
+original file on a branch that is writable, and then redirect the write
+though to this copy.  The copy must be made on a higher priority branch so
+that lookup and readdir return this newer "version" of the file rather than
+the original (see duplicate elimination).
+
+An entire unionfs mount can be read-only or read-write.  If it's read-only,
+then none of the branches will be written to, even if some of the branches
+are physically writeable.  If the unionfs mount is read-write, then the
+leftmost (highest priority) branch must be writeable (for copyup to take
+place); the remaining branches can be any mix of read-write and read-only.
+
+In a writeable mount, unionfs will create new files/dir in the leftmost
+branch.  If one tries to modify a file in a read-only branch/media, unionfs
+will copyup the file to the leftmost branch and modify it there.  If you try
+to modify a file from a writeable branch which is not the leftmost branch,
+then unionfs will modify it in that branch; this is useful if you, say,
+unify differnet packages (e.g., apache, sendmail, ftpd, etc.) and you want
+changes to specific package files to remain logically in the directory where
+they came from.
+
+Cache Coherency:
+================
+
+Unionfs users often want to be able to modify files and directories directly
+on the lower branches, and have those changes be visible at the Unionfs
+level.  This means that data (e.g., pages) and meta-data (dentries, inodes,
+open files, etc.) have to be synchronized between the upper and lower
+layers.  In other words, the newest changes from a layer below have to be
+propagated to the Unionfs layer above.  If the two layers are not in sync, a
+cache incoherency ensues, which could lead to application failures and even
+oopses.  The Linux kernel, however, has a rather limited set of mechanisms
+to ensure this inter-layer cache coherency---so Unionfs has to do most of
+the hard work on its own.
+
+Maintaining Invariants:
+
+The way Unionfs ensures cache coherency is as follows.  At each entry point
+to a Unionfs file system method, we call a utility function to validate the
+primary objects of this method.  Generally, we call unionfs_file_revalidate
+on open files, and __unionfs_d_revalidate_chain on dentries (which also
+validates inodes).  These utility functions check to see whether the upper
+Unionfs object is in sync with any of the lower objects that it represents.
+The checks we perform include whether the Unionfs superblock has a newer
+generation number, or if any of the lower objects mtime's or ctime's are
+newer.  (Note: generation numbers change when branch-management commands are
+issued, so in a way, maintaining cache coherency is also very important for
+branch-management.)  If indeed we determine that any Unionfs object is no
+longer in sync with its lower counterparts, then we rebuild that object
+similarly to how we do so for branch-management.
+
+While rebuilding Unionfs's objects, we also purge any page mappings and
+truncate inode pages (see fs/unionfs/dentry.c:purge_inode_data).  This is to
+ensure that Unionfs will re-get the newer data from the lower branches.  We
+perform this purging only if the Unionfs operation in question is a reading
+operation; if Unionfs is performing a data writing operation (e.g., ->write,
+->commit_write, etc.) then we do NOT flush the lower mappings/pages: this is
+because (1) a self-deadlock could occur and (2) the upper Unionfs pages are
+considered more authoritative anyway, as they are newer and will overwrite
+any lower pages.
+
+Unionfs maintains the following important invariant regarding mtime's,
+ctime's, and atime's: the upper inode object's times are the max() of all of
+the lower ones.  For non-directory objects, there's only one object below,
+so the mapping is simple; for directory objects, there could me multiple
+lower objects and we have to sync up with the newest one of all the lower
+ones.  This invariant is important to maintain, especially for directories
+(besides, we need this to be POSIX compliant).  A union could comprise
+multiple writable branches, each of which could change.  If we don't reflect
+the newest possible mtime/ctime, some applications could fail.  For example,
+NFSv2/v3 exports check for newer directory mtimes on the server to determine
+if the client-side attribute cache should be purged.
+
+To maintain these important invariants, of course, Unionfs carefully
+synchronizes upper and lower times in various places.  For example, if we
+copy-up a file to a top-level branch, the parent directory where the file
+was copied up to will now have a new mtime: so after a successful copy-up,
+we sync up with the new top-level branch's parent directory mtime.
+
+Implementation:
+
+This cache-coherency implementation is efficient because it defers any
+synchronizing between the upper and lower layers until absolutely needed.
+Consider the example a common situation where users perform a lot of lower
+changes, such as untarring a whole package.  While these take place,
+typically the user doesn't access the files via Unionfs; only after the
+lower changes are done, does the user try to access the lower files.  With
+our cache-coherency implementation, the entirety of the changes to the lower
+branches will not result in a single CPU cycle spent at the Unionfs level
+until the user invokes a system call that goes through Unionfs.
+
+We have considered two alternate cache-coherency designs.  (1) Using the
+dentry/inode notify functionality to register interest in finding out about
+any lower changes.  This is a somewhat limited and also a heavy-handed
+approach which could result in many notifications to the Unionfs layer upon
+each small change at the lower layer (imagine a file being modified multiple
+times in rapid succession).  (2) Rewriting the VFS to support explicit
+callbacks from lower objects to upper objects.  We began exploring such an
+implementation, but found it to be very complicated--it would have resulted
+in massive VFS/MM changes which are unlikely to be accepted by the LKML
+community.  We therefore believe that our current cache-coherency design and
+implementation represent the best approach at this time.
+
+Limitations:
+
+Our implementation works in that as long as a user process will have caused
+Unionfs to be called, directly or indirectly, even to just do
+->d_revalidate; then we will have purged the current Unionfs data and the
+process will see the new data.  For example, a process that continually
+re-reads the same file's data will see the NEW data as soon as the lower
+file had changed, upon the next read(2) syscall (even if the file is still
+open!)  However, this doesn't work when the process re-reads the open file's
+data via mmap(2) (unless the user unmaps/closes the file and remaps/reopens
+it).  Once we respond to ->readpage(s), then the kernel maps the page into
+the process's address space and there doesn't appear to be a way to force
+the kernel to invalidate those pages/mappings, and force the process to
+re-issue ->readpage.  If there's a way to invalidate active mappings and
+force a ->readpage, let us know please (invalidate_inode_pages2 doesn't do
+the trick).
+
+Our current Unionfs code has to perform many file-revalidation calls.  It
+would be really nice if the VFS would export an optional file system hook
+->file_revalidate (similarly to dentry->d_revalidate) that will be called
+before each VFS op that has a "struct file" in it.
+
+Certain file systems have micro-second granularity (or better) for inode
+times, and asynchronous actions could cause those times to change with some
+small delay.  In such cases, Unionfs may see a changed inode time that only
+differs by a tiny fraction of a second: such a change may be a false
+positive indication that the lower object has changed, whereas if unionfs
+waits a little longer, that false indication will not be seen.  (These false
+positives are harmless, because they would at most cause unionfs to
+re-validate an object that may need no revalidation, and print a debugging
+message that clutters the console/logs.)  Therefore, to minimize the chances
+of these situations, we delay the detection of changed times by a small
+factor of a few seconds, called UNIONFS_MIN_CC_TIME (which defaults to 3
+seconds, as does NFS).  This means that we will detect the change, only a
+couple of seconds later, if indeed the time change persists in the lower
+file object.  This delayed detection has an added performance benefit: we
+reduce the number of times that unionfs has to revalidate objects, in case
+there's a lot of concurrent activity on both the upper and lower objects,
+for the same file(s).  Lastly, this delayed time attribute detection is
+similar to how NFS clients operate (e.g., acregmin).
+
+Finally, there is no way currently in Linux to prevent lower directories
+from being moved around (i.e., topology changes); there's no way to prevent
+modifications to directory sub-trees of whole file systems which are mounted
+read-write.  It is therefore possible for in-flight operations in unionfs to
+take place, while a lower directory is being moved around.  Therefore, if
+you try to, say, create a new file in a directory through unionfs, while the
+directory is being moved around directly, then the new file may get created
+in the new location where that directory was moved to.  This is a somewhat
+similar behaviour in NFS: an NFS client could be creating a new file while
+th NFS server is moving th directory around; the file will get successfully
+created in the new location.  (The one exception in unionfs is that if the
+branch is marked read-only by unionfs, then a copyup will take place.)
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/Documentation/filesystems/unionfs/issues.txt b/Documentation/filesystems/unionfs/issues.txt
new file mode 100644
index 0000000..f4b7e7e
--- /dev/null
+++ b/Documentation/filesystems/unionfs/issues.txt
@@ -0,0 +1,28 @@
+KNOWN Unionfs 2.x ISSUES:
+=========================
+
+1. Unionfs should not use lookup_one_len() on the underlying f/s as it
+   confuses NFSv4.  Currently, unionfs_lookup() passes lookup intents to the
+   lower file-system, this eliminates part of the problem.  The remaining
+   calls to lookup_one_len may need to be changed to pass an intent.  We are
+   currently introducing VFS changes to fs/namei.c's do_path_lookup() to
+   allow proper file lookup and opening in stackable file systems.
+
+2. Lockdep (a debugging feature) isn't aware of stacking, and so it
+   incorrectly complains about locking problems.  The problem boils down to
+   this: Lockdep considers all objects of a certain type to be in the same
+   class, for example, all inodes.  Lockdep doesn't like to see a lock held
+   on two inodes within the same task, and warns that it could lead to a
+   deadlock.  However, stackable file systems do precisely that: they lock
+   an upper object, and then a lower object, in a strict order to avoid
+   locking problems; in addition, Unionfs, as a fan-out file system, may
+   have to lock several lower inodes.  We are currently looking into Lockdep
+   to see how to make it aware of stackable file systems.  For now, we
+   temporarily disable lockdep when calling vfs methods on lower objects,
+   but only for those places where lockdep complained.  While this solution
+   may seem unclean, it is not without precedent: other places in the kernel
+   also do similar temporary disabling, of course after carefully having
+   checked that it is the right thing to do.  Anyway, you get any warnings
+   from Lockdep, please report them to the Unionfs maintainers.
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/Documentation/filesystems/unionfs/rename.txt b/Documentation/filesystems/unionfs/rename.txt
new file mode 100644
index 0000000..e20bb82
--- /dev/null
+++ b/Documentation/filesystems/unionfs/rename.txt
@@ -0,0 +1,31 @@
+Rename is a complex beast. The following table shows which rename(2) operations
+should succeed and which should fail.
+
+o: success
+E: error (either unionfs or vfs)
+X: EXDEV
+
+none = file does not exist
+file = file is a file
+dir  = file is a empty directory
+child= file is a non-empty directory
+wh   = file is a directory containing only whiteouts; this makes it logically
+		empty
+
+                      none    file    dir     child   wh
+file                  o       o       E       E       E
+dir                   o       E       o       E       o
+child                 X       E       X       E       X
+wh                    o       E       o       E       o
+
+
+Renaming directories:
+=====================
+
+Whenever a empty (either physically or logically) directory is being renamed,
+the following sequence of events should take place:
+
+1) Remove whiteouts from both source and destination directory
+2) Rename source to destination
+3) Make destination opaque to prevent anything under it from showing up
+
diff --git a/Documentation/filesystems/unionfs/usage.txt b/Documentation/filesystems/unionfs/usage.txt
new file mode 100644
index 0000000..1adde69
--- /dev/null
+++ b/Documentation/filesystems/unionfs/usage.txt
@@ -0,0 +1,134 @@
+Unionfs is a stackable unification file system, which can appear to merge
+the contents of several directories (branches), while keeping their physical
+content separate.  Unionfs is useful for unified source tree management,
+merged contents of split CD-ROM, merged separate software package
+directories, data grids, and more.  Unionfs allows any mix of read-only and
+read-write branches, as well as insertion and deletion of branches anywhere
+in the fan-out.  To maintain Unix semantics, Unionfs handles elimination of
+duplicates, partial-error conditions, and more.
+
+GENERAL SYNTAX
+==============
+
+# mount -t unionfs -o <OPTIONS>,<BRANCH-OPTIONS> none MOUNTPOINT
+
+OPTIONS can be any legal combination of:
+
+- ro		# mount file system read-only
+- rw		# mount file system read-write
+- remount	# remount the file system (see Branch Management below)
+- incgen	# increment generation no. (see Cache Consistency below)
+
+BRANCH-OPTIONS can be either (1) a list of branches given to the "dirs="
+option, or (2) a list of individual branch manipulation commands, combined
+with the "remount" option, and is further described in the "Branch
+Management" section below.
+
+The syntax for the "dirs=" mount option is:
+
+	dirs=branch[=ro|=rw][:...]
+
+The "dirs=" option takes a colon-delimited list of directories to compose
+the union, with an optional branch mode for each of those directories.
+Directories that come earlier (specified first, on the left) in the list
+have a higher precedence than those which come later.  Additionally,
+read-only or read-write permissions of the branch can be specified by
+appending =ro or =rw (default) to each directory.  See the Copyup section in
+concepts.txt, for a description of Unionfs's behavior when mixing read-only
+and read-write branches and mounts.
+
+Syntax:
+
+	dirs=/branch1[=ro|=rw]:/branch2[=ro|=rw]:...:/branchN[=ro|=rw]
+
+Example:
+
+	dirs=/writable_branch=rw:/read-only_branch=ro
+
+
+BRANCH MANAGEMENT
+=================
+
+Once you mount your union for the first time, using the "dirs=" option, you
+can then change the union's overall mode or reconfigure the branches, using
+the remount option, as follows.
+
+To downgrade a union from read-write to read-only:
+
+# mount -t unionfs -o remount,ro none MOUNTPOINT
+
+To upgrade a union from read-only to read-write:
+
+# mount -t unionfs -o remount,rw none MOUNTPOINT
+
+To delete a branch /foo, regardless where it is in the current union:
+
+# mount -t unionfs -o remount,del=/foo none MOUNTPOINT
+
+To insert (add) a branch /foo before /bar:
+
+# mount -t unionfs -o remount,add=/bar:/foo none MOUNTPOINT
+
+To insert (add) a branch /foo (with the "rw" mode flag) before /bar:
+
+# mount -t unionfs -o remount,add=/bar:/foo=rw none MOUNTPOINT
+
+To insert (add) a branch /foo (in "rw" mode) at the very beginning (i.e., a
+new highest-priority branch), you can use the above syntax, or use a short
+hand version as follows:
+
+# mount -t unionfs -o remount,add=/foo none MOUNTPOINT
+
+To append a branch to the very end (new lowest-priority branch):
+
+# mount -t unionfs -o remount,add=:/foo none MOUNTPOINT
+
+To append a branch to the very end (new lowest-priority branch), in
+read-only mode:
+
+# mount -t unionfs -o remount,add=:/foo=ro none MOUNTPOINT
+
+Finally, to change the mode of one existing branch, say /foo, from read-only
+to read-write, and change /bar from read-write to read-only:
+
+# mount -t unionfs -o remount,mode=/foo=rw,mode=/bar=ro none MOUNTPOINT
+
+Note: in Unionfs 2.x, you cannot set the leftmost branch to readonly because
+then Unionfs won't have any writable place for copyups to take place.
+Moreover, the VFS can get confused when it tries to modify something in a
+file system mounted read-write, but isn't permitted to write to it.
+Instead, you should set the whole union as readonly, as described above.
+If, however, you must set the leftmost branch as readonly, perhaps so you
+can get a snapshot of it at a point in time, then you should insert a new
+writable top-level branch, and mark the one you want as readonly.  This can
+be accomplished as follows, assuming that /foo is your current leftmost
+branch:
+
+# mount -t tmpfs -o size=NNN /new
+# mount -t unionfs -o remount,add=/new,mode=/foo=ro none MOUNTPOINT
+<do what you want safely in /foo>
+# mount -t unionfs -o remount,del=/new,mode=/foo=rw none MOUNTPOINT
+<check if there's anything in /new you want to preserve>
+# umount /new
+
+CACHE CONSISTENCY
+=================
+
+If you modify any file on any of the lower branches directly, while there is
+a Unionfs 2.x mounted above any of those branches, you should tell Unionfs
+to purge its caches and re-get the objects.  To do that, you have to
+increment the generation number of the superblock using the following
+command:
+
+# mount -t unionfs -o remount,incgen none MOUNTPOINT
+
+Note that the older way of incrementing the generation number using an
+ioctl, is no longer supported in Unionfs 2.0 and newer.  Ioctls in general
+are not encouraged.  Plus, an ioctl is per-file concept, whereas the
+generation number is a per-file-system concept.  Worse, such an ioctl
+requires an open file, which then has to be invalidated by the very nature
+of the generation number increase (read: the old generation increase ioctl
+was pretty racy).
+
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/MAINTAINERS b/MAINTAINERS
index deedc0d..c722f8e 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -4173,6 +4173,14 @@ L:	linux-kernel@vger.kernel.org
 W:	http://www.kernel.dk
 S:	Maintained
 
+UNIONFS
+P:	Erez Zadok
+M:	ezk@cs.sunysb.edu
+L:	unionfs@filesystems.org
+W:	http://unionfs.filesystems.org
+T:	git git.kernel.org/pub/scm/linux/kernel/git/ezk/unionfs.git
+S:	Maintained
+
 USB ACM DRIVER
 P:	Oliver Neukum
 M:	oliver@neukum.name
diff --git a/fs/Kconfig b/fs/Kconfig
index d387358..31610a2 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -981,6 +981,47 @@ config CONFIGFS_FS
 
 endmenu
 
+menu "Layered filesystems"
+
+config ECRYPT_FS
+	tristate "eCrypt filesystem layer support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && KEYS && CRYPTO && NET
+	help
+	  Encrypted filesystem that operates on the VFS layer.  See
+	  <file:Documentation/filesystems/ecryptfs.txt> to learn more about
+	  eCryptfs.  Userspace components are required and can be
+	  obtained from <http://ecryptfs.sf.net>.
+
+	  To compile this file system support as a module, choose M here: the
+	  module will be called ecryptfs.
+
+config UNION_FS
+	tristate "Union file system (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  Unionfs is a stackable unification file system, which appears to
+	  merge the contents of several directories (branches), while keeping
+	  their physical content separate.
+
+	  See <http://unionfs.filesystems.org> for details
+
+config UNION_FS_XATTR
+	bool "Unionfs extended attributes"
+	depends on UNION_FS
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page).
+
+	  If unsure, say N.
+
+config UNION_FS_DEBUG
+	bool "Debug Unionfs"
+	depends on UNION_FS
+	help
+	  If you say Y here, you can turn on debugging output from Unionfs.
+
+endmenu
+
 menu "Miscellaneous filesystems"
 
 config ADFS_FS
@@ -1033,18 +1074,6 @@ config AFFS_FS
 	  To compile this file system support as a module, choose M here: the
 	  module will be called affs.  If unsure, say N.
 
-config ECRYPT_FS
-	tristate "eCrypt filesystem layer support (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && KEYS && CRYPTO && NET
-	help
-	  Encrypted filesystem that operates on the VFS layer.  See
-	  <file:Documentation/filesystems/ecryptfs.txt> to learn more about
-	  eCryptfs.  Userspace components are required and can be
-	  obtained from <http://ecryptfs.sf.net>.
-
-	  To compile this file system support as a module, choose M here: the
-	  module will be called ecryptfs.
-
 config HFS_FS
 	tristate "Apple Macintosh file system support (EXPERIMENTAL)"
 	depends on BLOCK && EXPERIMENTAL
diff --git a/fs/Makefile b/fs/Makefile
index a1482a5..9bf3915 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
 obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
+obj-$(CONFIG_UNION_FS)		+= unionfs/
 obj-$(CONFIG_VXFS_FS)		+= freevxfs/
 obj-$(CONFIG_NFS_FS)		+= nfs/
 obj-$(CONFIG_EXPORTFS)		+= exportfs/
diff --git a/fs/ecryptfs/dentry.c b/fs/ecryptfs/dentry.c
index 5e59658..4621f89 100644
--- a/fs/ecryptfs/dentry.c
+++ b/fs/ecryptfs/dentry.c
@@ -62,7 +62,7 @@ static int ecryptfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
 		struct inode *lower_inode =
 			ecryptfs_inode_to_lower(dentry->d_inode);
 
-		fsstack_copy_attr_all(dentry->d_inode, lower_inode, NULL);
+		fsstack_copy_attr_all(dentry->d_inode, lower_inode);
 	}
 out:
 	return rc;
diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index 89209f0..d99a83e 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -589,9 +589,9 @@ ecryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			lower_new_dir_dentry->d_inode, lower_new_dentry);
 	if (rc)
 		goto out_lock;
-	fsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode, NULL);
+	fsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);
 	if (new_dir != old_dir)
-		fsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode, NULL);
+		fsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);
 out_lock:
 	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
 	dput(lower_new_dentry->d_parent);
@@ -913,7 +913,7 @@ static int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)
 	rc = notify_change(lower_dentry, ia);
 	mutex_unlock(&lower_dentry->d_inode->i_mutex);
 out:
-	fsstack_copy_attr_all(inode, lower_inode, NULL);
+	fsstack_copy_attr_all(inode, lower_inode);
 	return rc;
 }
 
diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index 448dfd5..db2db5d 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -197,7 +197,7 @@ int ecryptfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,
 		d_add(dentry, inode);
 	else
 		d_instantiate(dentry, inode);
-	fsstack_copy_attr_all(inode, lower_inode, NULL);
+	fsstack_copy_attr_all(inode, lower_inode);
 	/* This size will be overwritten for real files w/ headers and
 	 * other metadata */
 	fsstack_copy_inode_size(inode, lower_inode);
diff --git a/fs/namei.c b/fs/namei.c
index a7b0a0b..d05ee31 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -392,6 +392,7 @@ void release_open_intent(struct nameidata *nd)
 	else
 		fput(nd->intent.open.file);
 }
+EXPORT_SYMBOL_GPL(release_open_intent);
 
 static inline struct dentry *
 do_revalidate(struct dentry *dentry, struct nameidata *nd)
diff --git a/fs/splice.c b/fs/splice.c
index b30311b..204bb3c 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -887,8 +887,8 @@ EXPORT_SYMBOL(generic_splice_sendpage);
 /*
  * Attempt to initiate a splice from pipe to file.
  */
-static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
-			   loff_t *ppos, size_t len, unsigned int flags)
+long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		     loff_t *ppos, size_t len, unsigned int flags)
 {
 	int ret;
 
@@ -904,13 +904,14 @@ static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
 
 	return out->f_op->splice_write(pipe, out, ppos, len, flags);
 }
+EXPORT_SYMBOL_GPL(vfs_splice_from);
 
 /*
  * Attempt to initiate a splice from a file to a pipe.
  */
-static long do_splice_to(struct file *in, loff_t *ppos,
-			 struct pipe_inode_info *pipe, size_t len,
-			 unsigned int flags)
+long vfs_splice_to(struct file *in, loff_t *ppos,
+		   struct pipe_inode_info *pipe, size_t len,
+		   unsigned int flags)
 {
 	int ret;
 
@@ -926,6 +927,7 @@ static long do_splice_to(struct file *in, loff_t *ppos,
 
 	return in->f_op->splice_read(in, ppos, pipe, len, flags);
 }
+EXPORT_SYMBOL_GPL(vfs_splice_to);
 
 /**
  * splice_direct_to_actor - splices data directly between two non-pipes
@@ -995,7 +997,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 		size_t read_len;
 		loff_t pos = sd->pos, prev_pos = pos;
 
-		ret = do_splice_to(in, &pos, pipe, len, flags);
+		ret = vfs_splice_to(in, &pos, pipe, len, flags);
 		if (unlikely(ret <= 0))
 			goto out_release;
 
@@ -1054,7 +1056,7 @@ static int direct_splice_actor(struct pipe_inode_info *pipe,
 {
 	struct file *file = sd->u.file;
 
-	return do_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);
+	return vfs_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);
 }
 
 /**
@@ -1128,7 +1130,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 		} else
 			off = &out->f_pos;
 
-		ret = do_splice_from(pipe, out, off, len, flags);
+		ret = vfs_splice_from(pipe, out, off, len, flags);
 
 		if (off_out && copy_to_user(off_out, off, sizeof(loff_t)))
 			ret = -EFAULT;
@@ -1149,7 +1151,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 		} else
 			off = &in->f_pos;
 
-		ret = do_splice_to(in, off, pipe, len, flags);
+		ret = vfs_splice_to(in, off, pipe, len, flags);
 
 		if (off_in && copy_to_user(off_in, off, sizeof(loff_t)))
 			ret = -EFAULT;
diff --git a/fs/stack.c b/fs/stack.c
index 67716f6..a66ff6c 100644
--- a/fs/stack.c
+++ b/fs/stack.c
@@ -1,24 +1,82 @@
+/*
+ * Copyright (c) 2006-2007 Erez Zadok
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006-2007 Stony Brook University
+ * Copyright (c) 2006-2007 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/fs_stack.h>
 
-/* does _NOT_ require i_mutex to be held.
+/*
+ * does _NOT_ require i_mutex to be held.
  *
  * This function cannot be inlined since i_size_{read,write} is rather
  * heavy-weight on 32-bit systems
  */
-void fsstack_copy_inode_size(struct inode *dst, const struct inode *src)
+void fsstack_copy_inode_size(struct inode *dst, struct inode *src)
 {
-	i_size_write(dst, i_size_read((struct inode *)src));
-	dst->i_blocks = src->i_blocks;
+	loff_t i_size;
+	blkcnt_t i_blocks;
+
+	/*
+	 * i_size_read() includes its own seqlocking and protection from
+	 * preemption (see include/linux/fs.h): we need nothing extra for
+	 * that here, and prefer to avoid nesting locks than attempt to
+	 * keep i_size and i_blocks in synch together.
+	 */
+	i_size = i_size_read(src);
+
+	/*
+	 * But if CONFIG_LSF (on 32-bit), we ought to make an effort to keep
+	 * the two halves of i_blocks in synch despite SMP or PREEMPT - though
+	 * stat's generic_fillattr() doesn't bother, and we won't be applying
+	 * quotas (where i_blocks does become important) at the upper level.
+	 *
+	 * We don't actually know what locking is used at the lower level; but
+	 * if it's a filesystem that supports quotas, it will be using i_lock
+	 * as in inode_add_bytes().  tmpfs uses other locking, and its 32-bit
+	 * is (just) able to exceed 2TB i_size with the aid of holes; but its
+	 * i_blocks cannot carry into the upper long without almost 2TB swap -
+	 * let's ignore that case.
+	 */
+	if (sizeof(i_blocks) > sizeof(long))
+		spin_lock(&src->i_lock);
+	i_blocks = src->i_blocks;
+	if (sizeof(i_blocks) > sizeof(long))
+		spin_unlock(&src->i_lock);
+
+	/*
+	 * If CONFIG_SMP on 32-bit, it's vital for fsstack_copy_inode_size()
+	 * to hold some lock around i_size_write(), otherwise i_size_read()
+	 * may spin forever (see include/linux/fs.h).  We don't necessarily
+	 * hold i_mutex when this is called, so take i_lock for that case.
+	 *
+	 * And if CONFIG_LSF (on 32-bit), continue our effort to keep the
+	 * two halves of i_blocks in synch despite SMP or PREEMPT: use i_lock
+	 * for that case too, and do both at once by combining the tests.
+	 *
+	 * There is none of this locking overhead in the 64-bit case.
+	 */
+	if (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))
+		spin_lock(&dst->i_lock);
+	i_size_write(dst, i_size);
+	dst->i_blocks = i_blocks;
+	if (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))
+		spin_unlock(&dst->i_lock);
 }
 EXPORT_SYMBOL_GPL(fsstack_copy_inode_size);
 
-/* copy all attributes; get_nlinks is optional way to override the i_nlink
+/*
+ * copy all attributes; get_nlinks is optional way to override the i_nlink
  * copying
  */
-void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,
-				int (*get_nlinks)(struct inode *))
+void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)
 {
 	dest->i_mode = src->i_mode;
 	dest->i_uid = src->i_uid;
@@ -29,14 +87,6 @@ void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,
 	dest->i_ctime = src->i_ctime;
 	dest->i_blkbits = src->i_blkbits;
 	dest->i_flags = src->i_flags;
-
-	/*
-	 * Update the nlinks AFTER updating the above fields, because the
-	 * get_links callback may depend on them.
-	 */
-	if (!get_nlinks)
-		dest->i_nlink = src->i_nlink;
-	else
-		dest->i_nlink = (*get_nlinks)(dest);
+	dest->i_nlink = src->i_nlink;
 }
 EXPORT_SYMBOL_GPL(fsstack_copy_attr_all);
diff --git a/fs/unionfs/Makefile b/fs/unionfs/Makefile
new file mode 100644
index 0000000..0dc28c1
--- /dev/null
+++ b/fs/unionfs/Makefile
@@ -0,0 +1,13 @@
+obj-$(CONFIG_UNION_FS) += unionfs.o
+
+unionfs-y := subr.o dentry.o file.o inode.o main.o super.o \
+	rdstate.o copyup.o dirhelper.o rename.o unlink.o \
+	lookup.o commonfops.o dirfops.o sioq.o mmap.o whiteout.o
+
+unionfs-$(CONFIG_UNION_FS_XATTR) += xattr.o
+
+unionfs-$(CONFIG_UNION_FS_DEBUG) += debug.o
+
+ifeq ($(CONFIG_UNION_FS_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c
new file mode 100644
index 0000000..5861970
--- /dev/null
+++ b/fs/unionfs/commonfops.c
@@ -0,0 +1,905 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * 1) Copyup the file
+ * 2) Rename the file to '.unionfs<original inode#><counter>' - obviously
+ * stolen from NFS's silly rename
+ */
+static int copyup_deleted_file(struct file *file, struct dentry *dentry,
+			       int bstart, int bindex)
+{
+	static unsigned int counter;
+	const int i_inosize = sizeof(dentry->d_inode->i_ino) * 2;
+	const int countersize = sizeof(counter) * 2;
+	const int nlen = sizeof(".unionfs") + i_inosize + countersize - 1;
+	char name[nlen + 1];
+	int err;
+	struct dentry *tmp_dentry = NULL;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bstart);
+
+	sprintf(name, ".unionfs%*.*lx",
+		i_inosize, i_inosize, lower_dentry->d_inode->i_ino);
+
+	/*
+	 * Loop, looking for an unused temp name to copyup to.
+	 *
+	 * It's somewhat silly that we look for a free temp tmp name in the
+	 * source branch (bstart) instead of the dest branch (bindex), where
+	 * the final name will be created.  We _will_ catch it if somehow
+	 * the name exists in the dest branch, but it'd be nice to catch it
+	 * sooner than later.
+	 */
+retry:
+	tmp_dentry = NULL;
+	do {
+		char *suffix = name + nlen - countersize;
+
+		dput(tmp_dentry);
+		counter++;
+		sprintf(suffix, "%*.*x", countersize, countersize, counter);
+
+		pr_debug("unionfs: trying to rename %s to %s\n",
+			 dentry->d_name.name, name);
+
+		tmp_dentry = lookup_one_len(name, lower_dentry->d_parent,
+					    nlen);
+		if (IS_ERR(tmp_dentry)) {
+			err = PTR_ERR(tmp_dentry);
+			goto out;
+		}
+	} while (tmp_dentry->d_inode != NULL);	/* need negative dentry */
+	dput(tmp_dentry);
+
+	err = copyup_named_file(dentry->d_parent->d_inode, file, name, bstart,
+				bindex,
+				i_size_read(file->f_path.dentry->d_inode));
+	if (err) {
+		if (unlikely(err == -EEXIST))
+			goto retry;
+		goto out;
+	}
+
+	/* bring it to the same state as an unlinked file */
+	lower_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));
+	if (!unionfs_lower_inode_idx(dentry->d_inode, bindex)) {
+		atomic_inc(&lower_dentry->d_inode->i_count);
+		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+					    lower_dentry->d_inode);
+	}
+	lower_dir_dentry = lock_parent(lower_dentry);
+	err = vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
+	unlock_dir(lower_dir_dentry);
+
+out:
+	if (!err)
+		unionfs_check_dentry(dentry);
+	return err;
+}
+
+/*
+ * put all references held by upper struct file and free lower file pointer
+ * array
+ */
+static void cleanup_file(struct file *file)
+{
+	int bindex, bstart, bend;
+	struct file **lower_files;
+	struct file *lower_file;
+	struct super_block *sb = file->f_path.dentry->d_sb;
+
+	lower_files = UNIONFS_F(file)->lower_files;
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		int i;	/* holds (possibly) updated branch index */
+		int old_bid;
+
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		if (!lower_file)
+			continue;
+
+		/*
+		 * Find new index of matching branch with an open
+		 * file, since branches could have been added or
+		 * deleted causing the one with open files to shift.
+		 */
+		old_bid = UNIONFS_F(file)->saved_branch_ids[bindex];
+		i = branch_id_to_idx(sb, old_bid);
+		if (unlikely(i < 0)) {
+			printk(KERN_ERR "unionfs: no superblock for "
+			       "file %p\n", file);
+			continue;
+		}
+
+		/* decrement count of open files */
+		branchput(sb, i);
+		/*
+		 * fput will perform an mntput for us on the correct branch.
+		 * Although we're using the file's old branch configuration,
+		 * bindex, which is the old index, correctly points to the
+		 * right branch in the file's branch list.  In other words,
+		 * we're going to mntput the correct branch even if branches
+		 * have been added/removed.
+		 */
+		fput(lower_file);
+		UNIONFS_F(file)->lower_files[bindex] = NULL;
+		UNIONFS_F(file)->saved_branch_ids[bindex] = -1;
+	}
+
+	UNIONFS_F(file)->lower_files = NULL;
+	kfree(lower_files);
+	kfree(UNIONFS_F(file)->saved_branch_ids);
+	/* set to NULL because caller needs to know if to kfree on error */
+	UNIONFS_F(file)->saved_branch_ids = NULL;
+}
+
+/* open all lower files for a given file */
+static int open_all_files(struct file *file)
+{
+	int bindex, bstart, bend, err = 0;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct dentry *dentry = file->f_path.dentry;
+	struct super_block *sb = dentry->d_sb;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		dget(lower_dentry);
+		unionfs_mntget(dentry, bindex);
+		branchget(sb, bindex);
+
+		lower_file =
+			dentry_open(lower_dentry,
+				    unionfs_lower_mnt_idx(dentry, bindex),
+				    file->f_flags);
+		if (IS_ERR(lower_file)) {
+			err = PTR_ERR(lower_file);
+			goto out;
+		} else {
+			unionfs_set_lower_file_idx(file, bindex, lower_file);
+		}
+	}
+out:
+	return err;
+}
+
+/* open the highest priority file for a given upper file */
+static int open_highest_file(struct file *file, bool willwrite)
+{
+	int bindex, bstart, bend, err = 0;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *parent_inode = dentry->d_parent->d_inode;
+	struct super_block *sb = dentry->d_sb;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+	if (willwrite && IS_WRITE_FLAG(file->f_flags) && is_robranch(dentry)) {
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_file(parent_inode, file, bstart, bindex,
+					  i_size_read(dentry->d_inode));
+			if (!err)
+				break;
+		}
+		atomic_set(&UNIONFS_F(file)->generation,
+			   atomic_read(&UNIONFS_I(dentry->d_inode)->
+				       generation));
+		goto out;
+	}
+
+	dget(lower_dentry);
+	unionfs_mntget(dentry, bstart);
+	lower_file = dentry_open(lower_dentry,
+				 unionfs_lower_mnt_idx(dentry, bstart),
+				 file->f_flags);
+	if (IS_ERR(lower_file)) {
+		err = PTR_ERR(lower_file);
+		goto out;
+	}
+	branchget(sb, bstart);
+	unionfs_set_lower_file(file, lower_file);
+	/* Fix up the position. */
+	lower_file->f_pos = file->f_pos;
+
+	memcpy(&lower_file->f_ra, &file->f_ra, sizeof(struct file_ra_state));
+out:
+	return err;
+}
+
+/* perform a delayed copyup of a read-write file on a read-only branch */
+static int do_delayed_copyup(struct file *file)
+{
+	int bindex, bstart, bend, err = 0;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *parent_inode = dentry->d_parent->d_inode;
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	BUG_ON(!S_ISREG(dentry->d_inode->i_mode));
+
+	unionfs_check_file(file);
+	for (bindex = bstart - 1; bindex >= 0; bindex--) {
+		if (!d_deleted(dentry))
+			err = copyup_file(parent_inode, file, bstart,
+					  bindex,
+					  i_size_read(dentry->d_inode));
+		else
+			err = copyup_deleted_file(file, dentry, bstart,
+						  bindex);
+		/* if succeeded, set lower open-file flags and break */
+		if (!err) {
+			struct file *lower_file;
+			lower_file = unionfs_lower_file_idx(file, bindex);
+			lower_file->f_flags = file->f_flags;
+			break;
+		}
+	}
+	if (err || (bstart <= fbstart(file)))
+		goto out;
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		if (unionfs_lower_file_idx(file, bindex)) {
+			branchput(dentry->d_sb, bindex);
+			fput(unionfs_lower_file_idx(file, bindex));
+			unionfs_set_lower_file_idx(file, bindex, NULL);
+		}
+	}
+	path_put_lowers(dentry, bstart, bend, false);
+	iput_lowers(dentry->d_inode, bstart, bend, false);
+	/* for reg file, we only open it "once" */
+	fbend(file) = fbstart(file);
+	dbend(dentry) = dbstart(dentry);
+	ibend(dentry->d_inode) = ibstart(dentry->d_inode);
+
+out:
+	unionfs_check_file(file);
+	return err;
+}
+
+/*
+ * Helper function for unionfs_file_revalidate/locked.
+ * Expects dentry/parent to be locked already, and revalidated.
+ */
+static int __unionfs_file_revalidate(struct file *file, struct dentry *dentry,
+				     struct super_block *sb, int sbgen,
+				     int dgen, bool willwrite)
+{
+	int fgen;
+	int bstart, bend, orig_brid;
+	int size;
+	int err = 0;
+
+	fgen = atomic_read(&UNIONFS_F(file)->generation);
+
+	/*
+	 * There are two cases we are interested in.  The first is if the
+	 * generation is lower than the super-block.  The second is if
+	 * someone has copied up this file from underneath us, we also need
+	 * to refresh things.
+	 */
+	if (d_deleted(dentry) ||
+	    (sbgen <= fgen &&
+	     dbstart(dentry) == fbstart(file) &&
+	     unionfs_lower_file(file)))
+		goto out_may_copyup;
+
+	/* save orig branch ID */
+	orig_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];
+
+	/* First we throw out the existing files. */
+	cleanup_file(file);
+
+	/* Now we reopen the file(s) as in unionfs_open. */
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	size = sizeof(struct file *) * sbmax(sb);
+	UNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->lower_files)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(int) * sbmax(sb);
+	UNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (S_ISDIR(dentry->d_inode->i_mode)) {
+		/* We need to open all the files. */
+		err = open_all_files(file);
+		if (err)
+			goto out;
+	} else {
+		int new_brid;
+		/* We only open the highest priority branch. */
+		err = open_highest_file(file, willwrite);
+		if (err)
+			goto out;
+		new_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];
+		if (unlikely(new_brid != orig_brid && sbgen > fgen)) {
+			/*
+			 * If we re-opened the file on a different branch
+			 * than the original one, and this was due to a new
+			 * branch inserted, then update the mnt counts of
+			 * the old and new branches accordingly.
+			 */
+			unionfs_mntget(dentry, bstart);
+			unionfs_mntput(sb->s_root,
+				       branch_id_to_idx(sb, orig_brid));
+		}
+		/* regular files have only one open lower file */
+		fbend(file) = fbstart(file);
+	}
+	atomic_set(&UNIONFS_F(file)->generation,
+		   atomic_read(&UNIONFS_I(dentry->d_inode)->generation));
+
+out_may_copyup:
+	/* Copyup on the first write to a file on a readonly branch. */
+	if (willwrite && IS_WRITE_FLAG(file->f_flags) &&
+	    !IS_WRITE_FLAG(unionfs_lower_file(file)->f_flags) &&
+	    is_robranch(dentry)) {
+		pr_debug("unionfs: do delay copyup of \"%s\"\n",
+			 dentry->d_name.name);
+		err = do_delayed_copyup(file);
+		/* regular files have only one open lower file */
+		if (!err && !S_ISDIR(dentry->d_inode->i_mode))
+			fbend(file) = fbstart(file);
+	}
+
+out:
+	if (err) {
+		kfree(UNIONFS_F(file)->lower_files);
+		kfree(UNIONFS_F(file)->saved_branch_ids);
+	} else {
+		unionfs_check_file(file);
+	}
+	return err;
+}
+
+/*
+ * Revalidate the struct file
+ * @file: file to revalidate
+ * @willwrite: true if caller may cause changes to the file; false otherwise.
+ * Caller must lock/unlock dentry's branch configuration.
+ */
+int unionfs_file_revalidate(struct file *file, bool willwrite)
+{
+	struct super_block *sb;
+	struct dentry *dentry;
+	int sbgen, dgen;
+	int err = 0;
+
+	dentry = file->f_path.dentry;
+	sb = dentry->d_sb;
+	verify_locked(dentry);
+
+	/*
+	 * First revalidate the dentry inside struct file,
+	 * but not unhashed dentries.
+	 */
+reval_dentry:
+	if (!d_deleted(dentry) &&
+	    !__unionfs_d_revalidate_chain(dentry, NULL, willwrite)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	sbgen = atomic_read(&UNIONFS_SB(sb)->generation);
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+
+	if (unlikely(sbgen > dgen)) {
+		pr_debug("unionfs: retry dentry %s revalidation\n",
+			 dentry->d_name.name);
+		schedule();
+		goto reval_dentry;
+	}
+	BUG_ON(sbgen > dgen);
+
+	err = __unionfs_file_revalidate(file, dentry, sb,
+					sbgen, dgen, willwrite);
+out:
+	return err;
+}
+
+/* same as unionfs_file_revalidate, but parent dentry must be locked too */
+int unionfs_file_revalidate_locked(struct file *file, bool willwrite)
+{
+	struct super_block *sb;
+	struct dentry *dentry;
+	int sbgen, dgen;
+	int err = 0, valid;
+
+	dentry = file->f_path.dentry;
+	sb = dentry->d_sb;
+	verify_locked(dentry);
+	verify_locked(dentry->d_parent);
+
+	/* first revalidate (locked) parent, then child */
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;	/* same as what real_lookup does */
+		goto out;
+	}
+
+reval_dentry:
+	if (!d_deleted(dentry) &&
+	    !__unionfs_d_revalidate_one_locked(dentry, NULL, willwrite)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	sbgen = atomic_read(&UNIONFS_SB(sb)->generation);
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+
+	if (unlikely(sbgen > dgen)) {
+		pr_debug("unionfs: retry (locked) dentry %s revalidation\n",
+			 dentry->d_name.name);
+		schedule();
+		goto reval_dentry;
+	}
+	BUG_ON(sbgen > dgen);
+
+	err = __unionfs_file_revalidate(file, dentry, sb,
+					sbgen, dgen, willwrite);
+out:
+	return err;
+}
+
+/* unionfs_open helper function: open a directory */
+static int __open_dir(struct inode *inode, struct file *file)
+{
+	struct dentry *lower_dentry;
+	struct file *lower_file;
+	int bindex, bstart, bend;
+	struct vfsmount *mnt;
+
+	bstart = fbstart(file) = dbstart(file->f_path.dentry);
+	bend = fbend(file) = dbend(file->f_path.dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry =
+			unionfs_lower_dentry_idx(file->f_path.dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		dget(lower_dentry);
+		unionfs_mntget(file->f_path.dentry, bindex);
+		mnt = unionfs_lower_mnt_idx(file->f_path.dentry, bindex);
+		lower_file = dentry_open(lower_dentry, mnt, file->f_flags);
+		if (IS_ERR(lower_file))
+			return PTR_ERR(lower_file);
+
+		unionfs_set_lower_file_idx(file, bindex, lower_file);
+
+		/*
+		 * The branchget goes after the open, because otherwise
+		 * we would miss the reference on release.
+		 */
+		branchget(inode->i_sb, bindex);
+	}
+
+	return 0;
+}
+
+/* unionfs_open helper function: open a file */
+static int __open_file(struct inode *inode, struct file *file)
+{
+	struct dentry *lower_dentry;
+	struct file *lower_file;
+	int lower_flags;
+	int bindex, bstart, bend;
+
+	lower_dentry = unionfs_lower_dentry(file->f_path.dentry);
+	lower_flags = file->f_flags;
+
+	bstart = fbstart(file) = dbstart(file->f_path.dentry);
+	bend = fbend(file) = dbend(file->f_path.dentry);
+
+	/*
+	 * check for the permission for lower file.  If the error is
+	 * COPYUP_ERR, copyup the file.
+	 */
+	if (lower_dentry->d_inode && is_robranch(file->f_path.dentry)) {
+		/*
+		 * if the open will change the file, copy it up otherwise
+		 * defer it.
+		 */
+		if (lower_flags & O_TRUNC) {
+			int size = 0;
+			int err = -EROFS;
+
+			/* copyup the file */
+			for (bindex = bstart - 1; bindex >= 0; bindex--) {
+				err = copyup_file(
+					file->f_path.dentry->d_parent->d_inode,
+					file, bstart, bindex, size);
+				if (!err)
+					break;
+			}
+			return err;
+		} else {
+			/*
+			 * turn off writeable flags, to force delayed copyup
+			 * by caller.
+			 */
+			lower_flags &= ~(OPEN_WRITE_FLAGS);
+		}
+	}
+
+	dget(lower_dentry);
+
+	/*
+	 * dentry_open will decrement mnt refcnt if err.
+	 * otherwise fput() will do an mntput() for us upon file close.
+	 */
+	unionfs_mntget(file->f_path.dentry, bstart);
+	lower_file =
+		dentry_open(lower_dentry,
+			    unionfs_lower_mnt_idx(file->f_path.dentry, bstart),
+			    lower_flags);
+	if (IS_ERR(lower_file))
+		return PTR_ERR(lower_file);
+
+	unionfs_set_lower_file(file, lower_file);
+	branchget(inode->i_sb, bstart);
+
+	return 0;
+}
+
+int unionfs_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	int bindex = 0, bstart = 0, bend = 0;
+	int size;
+	int valid = 0;
+
+	unionfs_read_lock(inode->i_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	if (dentry != dentry->d_parent)
+		unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out_nofree;
+	}
+
+	file->private_data =
+		kzalloc(sizeof(struct unionfs_file_info), GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file))) {
+		err = -ENOMEM;
+		goto out_nofree;
+	}
+	fbstart(file) = -1;
+	fbend(file) = -1;
+	atomic_set(&UNIONFS_F(file)->generation,
+		   atomic_read(&UNIONFS_I(inode)->generation));
+
+	size = sizeof(struct file *) * sbmax(inode->i_sb);
+	UNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->lower_files)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(int) * sbmax(inode->i_sb);
+	UNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	/*
+	 * open all directories and make the unionfs file struct point to
+	 * these lower file structs
+	 */
+	if (S_ISDIR(inode->i_mode))
+		err = __open_dir(inode, file);	/* open a dir */
+	else
+		err = __open_file(inode, file);	/* open a file */
+
+	/* freeing the allocated resources, and fput the opened files */
+	if (err) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			lower_file = unionfs_lower_file_idx(file, bindex);
+			if (!lower_file)
+				continue;
+
+			branchput(dentry->d_sb, bindex);
+			/* fput calls dput for lower_dentry */
+			fput(lower_file);
+		}
+	}
+
+out:
+	if (err) {
+		kfree(UNIONFS_F(file)->lower_files);
+		kfree(UNIONFS_F(file)->saved_branch_ids);
+		kfree(UNIONFS_F(file));
+	}
+out_nofree:
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_copy_attr_times(inode);
+		unionfs_check_file(file);
+		unionfs_check_inode(inode);
+	}
+	if (dentry != dentry->d_parent)
+		unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(inode->i_sb);
+	return err;
+}
+
+/*
+ * release all lower object references & free the file info structure
+ *
+ * No need to grab sb info's rwsem.
+ */
+int unionfs_file_release(struct inode *inode, struct file *file)
+{
+	struct file *lower_file = NULL;
+	struct unionfs_file_info *fileinfo;
+	struct unionfs_inode_info *inodeinfo;
+	struct super_block *sb = inode->i_sb;
+	struct dentry *dentry = file->f_path.dentry;
+	int bindex, bstart, bend;
+	int fgen, err = 0;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/*
+	 * Yes, we have to revalidate this file even if it's being released.
+	 * This is important for open-but-unlinked files, as well as mmap
+	 * support.
+	 */
+	err = unionfs_file_revalidate(file, UNIONFS_F(file)->wrote_to_file);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+	fileinfo = UNIONFS_F(file);
+	BUG_ON(file->f_path.dentry->d_inode != inode);
+	inodeinfo = UNIONFS_I(inode);
+
+	/* fput all the lower files */
+	fgen = atomic_read(&fileinfo->generation);
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+
+		if (lower_file) {
+			unionfs_set_lower_file_idx(file, bindex, NULL);
+			fput(lower_file);
+			branchput(sb, bindex);
+		}
+
+		/* if there are no more refs to the dentry, dput it */
+		if (d_deleted(dentry)) {
+			dput(unionfs_lower_dentry_idx(dentry, bindex));
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+		}
+	}
+
+	kfree(fileinfo->lower_files);
+	kfree(fileinfo->saved_branch_ids);
+
+	if (fileinfo->rdstate) {
+		fileinfo->rdstate->access = jiffies;
+		spin_lock(&inodeinfo->rdlock);
+		inodeinfo->rdcount++;
+		list_add_tail(&fileinfo->rdstate->cache,
+			      &inodeinfo->readdircache);
+		mark_inode_dirty(inode);
+		spin_unlock(&inodeinfo->rdlock);
+		fileinfo->rdstate = NULL;
+	}
+	kfree(fileinfo);
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(sb);
+	return err;
+}
+
+/* pass the ioctl to the lower fs */
+static long do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct file *lower_file;
+	int err;
+
+	lower_file = unionfs_lower_file(file);
+
+	err = -ENOTTY;
+	if (!lower_file || !lower_file->f_op)
+		goto out;
+	if (lower_file->f_op->unlocked_ioctl) {
+		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);
+	} else if (lower_file->f_op->ioctl) {
+		lock_kernel();
+		err = lower_file->f_op->ioctl(
+			lower_file->f_path.dentry->d_inode,
+			lower_file, cmd, arg);
+		unlock_kernel();
+	}
+
+out:
+	return err;
+}
+
+/*
+ * return to user-space the branch indices containing the file in question
+ *
+ * We use fd_set and therefore we are limited to the number of the branches
+ * to FD_SETSIZE, which is currently 1024 - plenty for most people
+ */
+static int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	int err = 0;
+	fd_set branchlist;
+	int bstart = 0, bend = 0, bindex = 0;
+	int orig_bstart, orig_bend;
+	struct dentry *dentry, *lower_dentry;
+	struct vfsmount *mnt;
+
+	dentry = file->f_path.dentry;
+	orig_bstart = dbstart(dentry);
+	orig_bend = dbend(dentry);
+	err = unionfs_partial_lookup(dentry);
+	if (err)
+		goto out;
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	FD_ZERO(&branchlist);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (likely(lower_dentry->d_inode))
+			FD_SET(bindex, &branchlist);
+		/* purge any lower objects after partial_lookup */
+		if (bindex < orig_bstart || bindex > orig_bend) {
+			dput(lower_dentry);
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+			iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
+			unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+						    NULL);
+			mnt = unionfs_lower_mnt_idx(dentry, bindex);
+			if (!mnt)
+				continue;
+			unionfs_mntput(dentry, bindex);
+			unionfs_set_lower_mnt_idx(dentry, bindex, NULL);
+		}
+	}
+	/* restore original dentry's offsets */
+	dbstart(dentry) = orig_bstart;
+	dbend(dentry) = orig_bend;
+	ibstart(dentry->d_inode) = orig_bstart;
+	ibend(dentry->d_inode) = orig_bend;
+
+	err = copy_to_user((void __user *)arg, &branchlist, sizeof(fd_set));
+	if (unlikely(err))
+		err = -EFAULT;
+
+out:
+	return err < 0 ? err : bend;
+}
+
+long unionfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long err;
+	struct dentry *dentry = file->f_path.dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, true);
+	if (unlikely(err))
+		goto out;
+
+	/* check if asked for local commands */
+	switch (cmd) {
+	case UNIONFS_IOCTL_INCGEN:
+		/* Increment the superblock generation count */
+		pr_info("unionfs: incgen ioctl deprecated; "
+			"use \"-o remount,incgen\"\n");
+		err = -ENOSYS;
+		break;
+
+	case UNIONFS_IOCTL_QUERYFILE:
+		/* Return list of branches containing the given file */
+		err = unionfs_ioctl_queryfile(file, cmd, arg);
+		break;
+
+	default:
+		/* pass the ioctl down */
+		err = do_ioctl(file, cmd, arg);
+		break;
+	}
+
+out:
+	unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+int unionfs_flush(struct file *file, fl_owner_t id)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	int bindex, bstart, bend;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, UNIONFS_F(file)->wrote_to_file);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+
+		if (lower_file && lower_file->f_op &&
+		    lower_file->f_op->flush) {
+			err = lower_file->f_op->flush(lower_file, id);
+			if (err)
+				goto out;
+		}
+
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c
new file mode 100644
index 0000000..ae6ea2b
--- /dev/null
+++ b/fs/unionfs/copyup.c
@@ -0,0 +1,879 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * For detailed explanation of copyup see:
+ * Documentation/filesystems/unionfs/concepts.txt
+ */
+
+#ifdef CONFIG_UNION_FS_XATTR
+/* copyup all extended attrs for a given dentry */
+static int copyup_xattrs(struct dentry *old_lower_dentry,
+			 struct dentry *new_lower_dentry)
+{
+	int err = 0;
+	ssize_t list_size = -1;
+	char *name_list = NULL;
+	char *attr_value = NULL;
+	char *name_list_buf = NULL;
+
+	/* query the actual size of the xattr list */
+	list_size = vfs_listxattr(old_lower_dentry, NULL, 0);
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	/* allocate space for the actual list */
+	name_list = unionfs_xattr_alloc(list_size + 1, XATTR_LIST_MAX);
+	if (unlikely(!name_list || IS_ERR(name_list))) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+
+	name_list_buf = name_list; /* save for kfree at end */
+
+	/* now get the actual xattr list of the source file */
+	list_size = vfs_listxattr(old_lower_dentry, name_list, list_size);
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	/* allocate space to hold each xattr's value */
+	attr_value = unionfs_xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);
+	if (unlikely(!attr_value || IS_ERR(attr_value))) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+
+	/* in a loop, get and set each xattr from src to dst file */
+	while (*name_list) {
+		ssize_t size;
+
+		/* Lock here since vfs_getxattr doesn't lock for us */
+		mutex_lock(&old_lower_dentry->d_inode->i_mutex);
+		size = vfs_getxattr(old_lower_dentry, name_list,
+				    attr_value, XATTR_SIZE_MAX);
+		mutex_unlock(&old_lower_dentry->d_inode->i_mutex);
+		if (size < 0) {
+			err = size;
+			goto out;
+		}
+		if (size > XATTR_SIZE_MAX) {
+			err = -E2BIG;
+			goto out;
+		}
+		/* Don't lock here since vfs_setxattr does it for us. */
+		err = vfs_setxattr(new_lower_dentry, name_list, attr_value,
+				   size, 0);
+		/*
+		 * Selinux depends on "security.*" xattrs, so to maintain
+		 * the security of copied-up files, if Selinux is active,
+		 * then we must copy these xattrs as well.  So we need to
+		 * temporarily get FOWNER privileges.
+		 * XXX: move entire copyup code to SIOQ.
+		 */
+		if (err == -EPERM && !capable(CAP_FOWNER)) {
+			cap_raise(current->cap_effective, CAP_FOWNER);
+			err = vfs_setxattr(new_lower_dentry, name_list,
+					   attr_value, size, 0);
+			cap_lower(current->cap_effective, CAP_FOWNER);
+		}
+		if (err < 0)
+			goto out;
+		name_list += strlen(name_list) + 1;
+	}
+out:
+	unionfs_xattr_kfree(name_list_buf);
+	unionfs_xattr_kfree(attr_value);
+	/* Ignore if xattr isn't supported */
+	if (err == -ENOTSUPP || err == -EOPNOTSUPP)
+		err = 0;
+	return err;
+}
+#endif /* CONFIG_UNION_FS_XATTR */
+
+/*
+ * Determine the mode based on the copyup flags, and the existing dentry.
+ *
+ * Handle file systems which may not support certain options.  For example
+ * jffs2 doesn't allow one to chmod a symlink.  So we ignore such harmless
+ * errors, rather than propagating them up, which results in copyup errors
+ * and errors returned back to users.
+ */
+static int copyup_permissions(struct super_block *sb,
+			      struct dentry *old_lower_dentry,
+			      struct dentry *new_lower_dentry)
+{
+	struct inode *i = old_lower_dentry->d_inode;
+	struct iattr newattrs;
+	int err;
+
+	newattrs.ia_atime = i->i_atime;
+	newattrs.ia_mtime = i->i_mtime;
+	newattrs.ia_ctime = i->i_ctime;
+	newattrs.ia_gid = i->i_gid;
+	newattrs.ia_uid = i->i_uid;
+	newattrs.ia_valid = ATTR_CTIME | ATTR_ATIME | ATTR_MTIME |
+		ATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_FORCE |
+		ATTR_GID | ATTR_UID;
+	mutex_lock(&new_lower_dentry->d_inode->i_mutex);
+	err = notify_change(new_lower_dentry, &newattrs);
+	if (err)
+		goto out;
+
+	/* now try to change the mode and ignore EOPNOTSUPP on symlinks */
+	newattrs.ia_mode = i->i_mode;
+	newattrs.ia_valid = ATTR_MODE | ATTR_FORCE;
+	err = notify_change(new_lower_dentry, &newattrs);
+	if (err == -EOPNOTSUPP &&
+	    S_ISLNK(new_lower_dentry->d_inode->i_mode)) {
+		printk(KERN_WARNING
+		       "unionfs: changing \"%s\" symlink mode unsupported\n",
+		       new_lower_dentry->d_name.name);
+		err = 0;
+	}
+
+out:
+	mutex_unlock(&new_lower_dentry->d_inode->i_mutex);
+	return err;
+}
+
+/*
+ * create the new device/file/directory - use copyup_permission to copyup
+ * times, and mode
+ *
+ * if the object being copied up is a regular file, the file is only created,
+ * the contents have to be copied up separately
+ */
+static int __copyup_ndentry(struct dentry *old_lower_dentry,
+			    struct dentry *new_lower_dentry,
+			    struct dentry *new_lower_parent_dentry,
+			    char *symbuf)
+{
+	int err = 0;
+	umode_t old_mode = old_lower_dentry->d_inode->i_mode;
+	struct sioq_args args;
+
+	if (S_ISDIR(old_mode)) {
+		args.mkdir.parent = new_lower_parent_dentry->d_inode;
+		args.mkdir.dentry = new_lower_dentry;
+		args.mkdir.mode = old_mode;
+
+		run_sioq(__unionfs_mkdir, &args);
+		err = args.err;
+	} else if (S_ISLNK(old_mode)) {
+		args.symlink.parent = new_lower_parent_dentry->d_inode;
+		args.symlink.dentry = new_lower_dentry;
+		args.symlink.symbuf = symbuf;
+
+		run_sioq(__unionfs_symlink, &args);
+		err = args.err;
+	} else if (S_ISBLK(old_mode) || S_ISCHR(old_mode) ||
+		   S_ISFIFO(old_mode) || S_ISSOCK(old_mode)) {
+		args.mknod.parent = new_lower_parent_dentry->d_inode;
+		args.mknod.dentry = new_lower_dentry;
+		args.mknod.mode = old_mode;
+		args.mknod.dev = old_lower_dentry->d_inode->i_rdev;
+
+		run_sioq(__unionfs_mknod, &args);
+		err = args.err;
+	} else if (S_ISREG(old_mode)) {
+		struct nameidata nd;
+		err = init_lower_nd(&nd, LOOKUP_CREATE);
+		if (unlikely(err < 0))
+			goto out;
+		args.create.nd = &nd;
+		args.create.parent = new_lower_parent_dentry->d_inode;
+		args.create.dentry = new_lower_dentry;
+		args.create.mode = old_mode;
+
+		run_sioq(__unionfs_create, &args);
+		err = args.err;
+		release_lower_nd(&nd, err);
+	} else {
+		printk(KERN_CRIT "unionfs: unknown inode type %d\n",
+		       old_mode);
+		BUG();
+	}
+
+out:
+	return err;
+}
+
+static int __copyup_reg_data(struct dentry *dentry,
+			     struct dentry *new_lower_dentry, int new_bindex,
+			     struct dentry *old_lower_dentry, int old_bindex,
+			     struct file **copyup_file, loff_t len)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct file *input_file;
+	struct file *output_file;
+	struct vfsmount *output_mnt;
+	mm_segment_t old_fs;
+	char *buf = NULL;
+	ssize_t read_bytes, write_bytes;
+	loff_t size;
+	int err = 0;
+
+	/* open old file */
+	unionfs_mntget(dentry, old_bindex);
+	branchget(sb, old_bindex);
+	/* dentry_open calls dput and mntput if it returns an error */
+	input_file = dentry_open(old_lower_dentry,
+				 unionfs_lower_mnt_idx(dentry, old_bindex),
+				 O_RDONLY | O_LARGEFILE);
+	if (IS_ERR(input_file)) {
+		dput(old_lower_dentry);
+		err = PTR_ERR(input_file);
+		goto out;
+	}
+	if (unlikely(!input_file->f_op || !input_file->f_op->read)) {
+		err = -EINVAL;
+		goto out_close_in;
+	}
+
+	/* open new file */
+	dget(new_lower_dentry);
+	output_mnt = unionfs_mntget(sb->s_root, new_bindex);
+	branchget(sb, new_bindex);
+	output_file = dentry_open(new_lower_dentry, output_mnt,
+				  O_RDWR | O_LARGEFILE);
+	if (IS_ERR(output_file)) {
+		err = PTR_ERR(output_file);
+		goto out_close_in2;
+	}
+	if (unlikely(!output_file->f_op || !output_file->f_op->write)) {
+		err = -EINVAL;
+		goto out_close_out;
+	}
+
+	/* allocating a buffer */
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out_close_out;
+	}
+
+	input_file->f_pos = 0;
+	output_file->f_pos = 0;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	size = len;
+	err = 0;
+	do {
+		if (len >= PAGE_SIZE)
+			size = PAGE_SIZE;
+		else if ((len < PAGE_SIZE) && (len > 0))
+			size = len;
+
+		len -= PAGE_SIZE;
+
+		read_bytes =
+			input_file->f_op->read(input_file,
+					       (char __user *)buf, size,
+					       &input_file->f_pos);
+		if (read_bytes <= 0) {
+			err = read_bytes;
+			break;
+		}
+
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		write_bytes =
+			output_file->f_op->write(output_file,
+						 (char __user *)buf,
+						 read_bytes,
+						 &output_file->f_pos);
+		lockdep_on();
+		if ((write_bytes < 0) || (write_bytes < read_bytes)) {
+			err = write_bytes;
+			break;
+		}
+	} while ((read_bytes > 0) && (len > 0));
+
+	set_fs(old_fs);
+
+	kfree(buf);
+
+	if (!err)
+		err = output_file->f_op->fsync(output_file,
+					       new_lower_dentry, 0);
+
+	if (err)
+		goto out_close_out;
+
+	if (copyup_file) {
+		*copyup_file = output_file;
+		goto out_close_in;
+	}
+
+out_close_out:
+	fput(output_file);
+
+out_close_in2:
+	branchput(sb, new_bindex);
+
+out_close_in:
+	fput(input_file);
+
+out:
+	branchput(sb, old_bindex);
+
+	return err;
+}
+
+/*
+ * dput the lower references for old and new dentry & clear a lower dentry
+ * pointer
+ */
+static void __clear(struct dentry *dentry, struct dentry *old_lower_dentry,
+		    int old_bstart, int old_bend,
+		    struct dentry *new_lower_dentry, int new_bindex)
+{
+	/* get rid of the lower dentry and all its traces */
+	unionfs_set_lower_dentry_idx(dentry, new_bindex, NULL);
+	dbstart(dentry) = old_bstart;
+	dbend(dentry) = old_bend;
+
+	dput(new_lower_dentry);
+	dput(old_lower_dentry);
+}
+
+/*
+ * Copy up a dentry to a file of specified name.
+ *
+ * @dir: used to pull the ->i_sb to access other branches
+ * @dentry: the non-negative dentry whose lower_inode we should copy
+ * @bstart: the branch of the lower_inode to copy from
+ * @new_bindex: the branch to create the new file in
+ * @name: the name of the file to create
+ * @namelen: length of @name
+ * @copyup_file: the "struct file" to return (optional)
+ * @len: how many bytes to copy-up?
+ */
+int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
+		  int new_bindex, const char *name, int namelen,
+		  struct file **copyup_file, loff_t len)
+{
+	struct dentry *new_lower_dentry;
+	struct dentry *old_lower_dentry = NULL;
+	struct super_block *sb;
+	int err = 0;
+	int old_bindex;
+	int old_bstart;
+	int old_bend;
+	struct dentry *new_lower_parent_dentry = NULL;
+	mm_segment_t oldfs;
+	char *symbuf = NULL;
+
+	verify_locked(dentry);
+
+	old_bindex = bstart;
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	BUG_ON(new_bindex < 0);
+	BUG_ON(new_bindex >= old_bindex);
+
+	sb = dir->i_sb;
+
+	err = is_robranch_super(sb, new_bindex);
+	if (err)
+		goto out;
+
+	/* Create the directory structure above this dentry. */
+	new_lower_dentry = create_parents(dir, dentry, name, new_bindex);
+	if (IS_ERR(new_lower_dentry)) {
+		err = PTR_ERR(new_lower_dentry);
+		goto out;
+	}
+
+	old_lower_dentry = unionfs_lower_dentry_idx(dentry, old_bindex);
+	/* we conditionally dput this old_lower_dentry at end of function */
+	dget(old_lower_dentry);
+
+	/* For symlinks, we must read the link before we lock the directory. */
+	if (S_ISLNK(old_lower_dentry->d_inode->i_mode)) {
+
+		symbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+		if (unlikely(!symbuf)) {
+			__clear(dentry, old_lower_dentry,
+				old_bstart, old_bend,
+				new_lower_dentry, new_bindex);
+			err = -ENOMEM;
+			goto out_free;
+		}
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		err = old_lower_dentry->d_inode->i_op->readlink(
+			old_lower_dentry,
+			(char __user *)symbuf,
+			PATH_MAX);
+		set_fs(oldfs);
+		if (err < 0) {
+			__clear(dentry, old_lower_dentry,
+				old_bstart, old_bend,
+				new_lower_dentry, new_bindex);
+			goto out_free;
+		}
+		symbuf[err] = '\0';
+	}
+
+	/* Now we lock the parent, and create the object in the new branch. */
+	new_lower_parent_dentry = lock_parent(new_lower_dentry);
+
+	/* create the new inode */
+	err = __copyup_ndentry(old_lower_dentry, new_lower_dentry,
+			       new_lower_parent_dentry, symbuf);
+
+	if (err) {
+		__clear(dentry, old_lower_dentry,
+			old_bstart, old_bend,
+			new_lower_dentry, new_bindex);
+		goto out_unlock;
+	}
+
+	/* We actually copyup the file here. */
+	if (S_ISREG(old_lower_dentry->d_inode->i_mode))
+		err = __copyup_reg_data(dentry, new_lower_dentry, new_bindex,
+					old_lower_dentry, old_bindex,
+					copyup_file, len);
+	if (err)
+		goto out_unlink;
+
+	/* Set permissions. */
+	err = copyup_permissions(sb, old_lower_dentry, new_lower_dentry);
+	if (err)
+		goto out_unlink;
+
+#ifdef CONFIG_UNION_FS_XATTR
+	/* Selinux uses extended attributes for permissions. */
+	err = copyup_xattrs(old_lower_dentry, new_lower_dentry);
+	if (err)
+		goto out_unlink;
+#endif /* CONFIG_UNION_FS_XATTR */
+
+	/* do not allow files getting deleted to be re-interposed */
+	if (!d_deleted(dentry))
+		unionfs_reinterpose(dentry);
+
+	goto out_unlock;
+
+out_unlink:
+	/*
+	 * copyup failed, because we possibly ran out of space or
+	 * quota, or something else happened so let's unlink; we don't
+	 * really care about the return value of vfs_unlink
+	 */
+	vfs_unlink(new_lower_parent_dentry->d_inode, new_lower_dentry);
+
+	if (copyup_file) {
+		/* need to close the file */
+
+		fput(*copyup_file);
+		branchput(sb, new_bindex);
+	}
+
+	/*
+	 * TODO: should we reset the error to something like -EIO?
+	 *
+	 * If we don't reset, the user may get some nonsensical errors, but
+	 * on the other hand, if we reset to EIO, we guarantee that the user
+	 * will get a "confusing" error message.
+	 */
+
+out_unlock:
+	unlock_dir(new_lower_parent_dentry);
+
+out_free:
+	/*
+	 * If old_lower_dentry was not a file, then we need to dput it.  If
+	 * it was a file, then it was already dput indirectly by other
+	 * functions we call above which operate on regular files.
+	 */
+	if (old_lower_dentry && old_lower_dentry->d_inode &&
+	    !S_ISREG(old_lower_dentry->d_inode->i_mode))
+		dput(old_lower_dentry);
+	kfree(symbuf);
+
+	if (err)
+		goto out;
+	if (!S_ISDIR(dentry->d_inode->i_mode)) {
+		unionfs_postcopyup_release(dentry);
+		if (!unionfs_lower_inode(dentry->d_inode)) {
+			/*
+			 * If we got here, then we copied up to an
+			 * unlinked-open file, whose name is .unionfsXXXXX.
+			 */
+			struct inode *inode = new_lower_dentry->d_inode;
+			atomic_inc(&inode->i_count);
+			unionfs_set_lower_inode_idx(dentry->d_inode,
+						    ibstart(dentry->d_inode),
+						    inode);
+		}
+	}
+	unionfs_postcopyup_setmnt(dentry);
+	/* sync inode times from copied-up inode to our inode */
+	unionfs_copy_attr_times(dentry->d_inode);
+	unionfs_check_inode(dir);
+	unionfs_check_dentry(dentry);
+out:
+	return err;
+}
+
+/*
+ * This function creates a copy of a file represented by 'file' which
+ * currently resides in branch 'bstart' to branch 'new_bindex.'  The copy
+ * will be named "name".
+ */
+int copyup_named_file(struct inode *dir, struct file *file, char *name,
+		      int bstart, int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	err = copyup_dentry(dir, file->f_path.dentry, bstart, new_bindex,
+			    name, strlen(name), &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		unionfs_set_lower_file_idx(file, new_bindex, output_file);
+	}
+
+	return err;
+}
+
+/*
+ * This function creates a copy of a file represented by 'file' which
+ * currently resides in branch 'bstart' to branch 'new_bindex'.
+ */
+int copyup_file(struct inode *dir, struct file *file, int bstart,
+		int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+
+	err = copyup_dentry(dir, dentry, bstart, new_bindex,
+			    dentry->d_name.name, dentry->d_name.len,
+			    &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		unionfs_set_lower_file_idx(file, new_bindex, output_file);
+	}
+
+	return err;
+}
+
+/* purge a dentry's lower-branch states (dput/mntput, etc.) */
+static void __cleanup_dentry(struct dentry *dentry, int bindex,
+			     int old_bstart, int old_bend)
+{
+	int loop_start;
+	int loop_end;
+	int new_bstart = -1;
+	int new_bend = -1;
+	int i;
+
+	loop_start = min(old_bstart, bindex);
+	loop_end = max(old_bend, bindex);
+
+	/*
+	 * This loop sets the bstart and bend for the new dentry by
+	 * traversing from left to right.  It also dputs all negative
+	 * dentries except bindex
+	 */
+	for (i = loop_start; i <= loop_end; i++) {
+		if (!unionfs_lower_dentry_idx(dentry, i))
+			continue;
+
+		if (i == bindex) {
+			new_bend = i;
+			if (new_bstart < 0)
+				new_bstart = i;
+			continue;
+		}
+
+		if (!unionfs_lower_dentry_idx(dentry, i)->d_inode) {
+			dput(unionfs_lower_dentry_idx(dentry, i));
+			unionfs_set_lower_dentry_idx(dentry, i, NULL);
+
+			unionfs_mntput(dentry, i);
+			unionfs_set_lower_mnt_idx(dentry, i, NULL);
+		} else {
+			if (new_bstart < 0)
+				new_bstart = i;
+			new_bend = i;
+		}
+	}
+
+	if (new_bstart < 0)
+		new_bstart = bindex;
+	if (new_bend < 0)
+		new_bend = bindex;
+	dbstart(dentry) = new_bstart;
+	dbend(dentry) = new_bend;
+
+}
+
+/* set lower inode ptr and update bstart & bend if necessary */
+static void __set_inode(struct dentry *upper, struct dentry *lower,
+			int bindex)
+{
+	unionfs_set_lower_inode_idx(upper->d_inode, bindex,
+				    igrab(lower->d_inode));
+	if (likely(ibstart(upper->d_inode) > bindex))
+		ibstart(upper->d_inode) = bindex;
+	if (likely(ibend(upper->d_inode) < bindex))
+		ibend(upper->d_inode) = bindex;
+
+}
+
+/* set lower dentry ptr and update bstart & bend if necessary */
+static void __set_dentry(struct dentry *upper, struct dentry *lower,
+			 int bindex)
+{
+	unionfs_set_lower_dentry_idx(upper, bindex, lower);
+	if (likely(dbstart(upper) > bindex))
+		dbstart(upper) = bindex;
+	if (likely(dbend(upper) < bindex))
+		dbend(upper) = bindex;
+}
+
+/*
+ * This function replicates the directory structure up-to given dentry
+ * in the bindex branch.
+ */
+struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+			      const char *name, int bindex)
+{
+	int err;
+	struct dentry *child_dentry;
+	struct dentry *parent_dentry;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
+	const char *childname;
+	unsigned int childnamelen;
+	int nr_dentry;
+	int count = 0;
+	int old_bstart;
+	int old_bend;
+	struct dentry **path = NULL;
+	struct super_block *sb;
+
+	verify_locked(dentry);
+
+	err = is_robranch_super(dir->i_sb, bindex);
+	if (err) {
+		lower_dentry = ERR_PTR(err);
+		goto out;
+	}
+
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	lower_dentry = ERR_PTR(-ENOMEM);
+
+	/* There is no sense allocating any less than the minimum. */
+	nr_dentry = 1;
+	path = kmalloc(nr_dentry * sizeof(struct dentry *), GFP_KERNEL);
+	if (unlikely(!path))
+		goto out;
+
+	/* assume the negative dentry of unionfs as the parent dentry */
+	parent_dentry = dentry;
+
+	/*
+	 * This loop finds the first parent that exists in the given branch.
+	 * We start building the directory structure from there.  At the end
+	 * of the loop, the following should hold:
+	 *  - child_dentry is the first nonexistent child
+	 *  - parent_dentry is the first existent parent
+	 *  - path[0] is the = deepest child
+	 *  - path[count] is the first child to create
+	 */
+	do {
+		child_dentry = parent_dentry;
+
+		/* find the parent directory dentry in unionfs */
+		parent_dentry = dget_parent(child_dentry);
+
+		/* find out the lower_parent_dentry in the given branch */
+		lower_parent_dentry =
+			unionfs_lower_dentry_idx(parent_dentry, bindex);
+
+		/* grow path table */
+		if (count == nr_dentry) {
+			void *p;
+
+			nr_dentry *= 2;
+			p = krealloc(path, nr_dentry * sizeof(struct dentry *),
+				     GFP_KERNEL);
+			if (unlikely(!p)) {
+				lower_dentry = ERR_PTR(-ENOMEM);
+				goto out;
+			}
+			path = p;
+		}
+
+		/* store the child dentry */
+		path[count++] = child_dentry;
+	} while (!lower_parent_dentry);
+	count--;
+
+	sb = dentry->d_sb;
+
+	/*
+	 * This code goes between the begin/end labels and basically
+	 * emulates a while(child_dentry != dentry), only cleaner and
+	 * shorter than what would be a much longer while loop.
+	 */
+begin:
+	/* get lower parent dir in the current branch */
+	lower_parent_dentry = unionfs_lower_dentry_idx(parent_dentry, bindex);
+	dput(parent_dentry);
+
+	/* init the values to lookup */
+	childname = child_dentry->d_name.name;
+	childnamelen = child_dentry->d_name.len;
+
+	if (child_dentry != dentry) {
+		/* lookup child in the underlying file system */
+		lower_dentry = lookup_one_len(childname, lower_parent_dentry,
+					      childnamelen);
+		if (IS_ERR(lower_dentry))
+			goto out;
+	} else {
+		/*
+		 * Is the name a whiteout of the child name ?  lookup the
+		 * whiteout child in the underlying file system
+		 */
+		lower_dentry = lookup_one_len(name, lower_parent_dentry,
+					      strlen(name));
+		if (IS_ERR(lower_dentry))
+			goto out;
+
+		/* Replace the current dentry (if any) with the new one */
+		dput(unionfs_lower_dentry_idx(dentry, bindex));
+		unionfs_set_lower_dentry_idx(dentry, bindex,
+					     lower_dentry);
+
+		__cleanup_dentry(dentry, bindex, old_bstart, old_bend);
+		goto out;
+	}
+
+	if (lower_dentry->d_inode) {
+		/*
+		 * since this already exists we dput to avoid
+		 * multiple references on the same dentry
+		 */
+		dput(lower_dentry);
+	} else {
+		struct sioq_args args;
+
+		/* it's a negative dentry, create a new dir */
+		lower_parent_dentry = lock_parent(lower_dentry);
+
+		args.mkdir.parent = lower_parent_dentry->d_inode;
+		args.mkdir.dentry = lower_dentry;
+		args.mkdir.mode = child_dentry->d_inode->i_mode;
+
+		run_sioq(__unionfs_mkdir, &args);
+		err = args.err;
+
+		if (!err)
+			err = copyup_permissions(dir->i_sb, child_dentry,
+						 lower_dentry);
+		unlock_dir(lower_parent_dentry);
+		if (err) {
+			dput(lower_dentry);
+			lower_dentry = ERR_PTR(err);
+			goto out;
+		}
+
+	}
+
+	__set_inode(child_dentry, lower_dentry, bindex);
+	__set_dentry(child_dentry, lower_dentry, bindex);
+	/*
+	 * update times of this dentry, but also the parent, because if
+	 * we changed, the parent may have changed too.
+	 */
+	fsstack_copy_attr_times(parent_dentry->d_inode,
+				lower_parent_dentry->d_inode);
+	unionfs_copy_attr_times(child_dentry->d_inode);
+
+	parent_dentry = child_dentry;
+	child_dentry = path[--count];
+	goto begin;
+out:
+	/* cleanup any leftover locks from the do/while loop above */
+	if (IS_ERR(lower_dentry))
+		while (count)
+			dput(path[count--]);
+	kfree(path);
+	return lower_dentry;
+}
+
+/*
+ * Post-copyup helper to ensure we have valid mnts: set lower mnt of
+ * dentry+parents to the first parent node that has an mnt.
+ */
+void unionfs_postcopyup_setmnt(struct dentry *dentry)
+{
+	struct dentry *parent, *hasone;
+	int bindex = dbstart(dentry);
+
+	if (unionfs_lower_mnt_idx(dentry, bindex))
+		return;
+	hasone = dentry->d_parent;
+	/* this loop should stop at root dentry */
+	while (!unionfs_lower_mnt_idx(hasone, bindex))
+		hasone = hasone->d_parent;
+	parent = dentry;
+	while (!unionfs_lower_mnt_idx(parent, bindex)) {
+		unionfs_set_lower_mnt_idx(parent, bindex,
+					  unionfs_mntget(hasone, bindex));
+		parent = parent->d_parent;
+	}
+}
+
+/*
+ * Post-copyup helper to release all non-directory source objects of a
+ * copied-up file.  Regular files should have only one lower object.
+ */
+void unionfs_postcopyup_release(struct dentry *dentry)
+{
+	int bstart, bend;
+
+	BUG_ON(S_ISDIR(dentry->d_inode->i_mode));
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	path_put_lowers(dentry, bstart + 1, bend, false);
+	iput_lowers(dentry->d_inode, bstart + 1, bend, false);
+
+	dbend(dentry) = bstart;
+	ibend(dentry->d_inode) = ibstart(dentry->d_inode) = bstart;
+}
diff --git a/fs/unionfs/debug.c b/fs/unionfs/debug.c
new file mode 100644
index 0000000..db62d22
--- /dev/null
+++ b/fs/unionfs/debug.c
@@ -0,0 +1,533 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Helper debugging functions for maintainers (and for users to report back
+ * useful information back to maintainers)
+ */
+
+/* it's always useful to know what part of the code called us */
+#define PRINT_CALLER(fname, fxn, line)					\
+	do {								\
+		if (!printed_caller) {					\
+			pr_debug("PC:%s:%s:%d\n", (fname), (fxn), (line)); \
+			printed_caller = 1;				\
+		}							\
+	} while (0)
+
+/*
+ * __unionfs_check_{inode,dentry,file} perform exhaustive sanity checking on
+ * the fan-out of various Unionfs objects.  We check that no lower objects
+ * exist  outside the start/end branch range; that all objects within are
+ * non-NULL (with some allowed exceptions); that for every lower file
+ * there's a lower dentry+inode; that the start/end ranges match for all
+ * corresponding lower objects; that open files/symlinks have only one lower
+ * objects, but directories can have several; and more.
+ */
+void __unionfs_check_inode(const struct inode *inode,
+			   const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int istart, iend;
+	struct inode *lower_inode;
+	struct super_block *sb;
+	int printed_caller = 0;
+	void *poison_ptr;
+
+	/* for inodes now */
+	BUG_ON(!inode);
+	sb = inode->i_sb;
+	istart = ibstart(inode);
+	iend = ibend(inode);
+	/* don't check inode if no lower branches */
+	if (istart < 0 && iend < 0)
+		return;
+	if (unlikely(istart > iend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci0: inode=%p istart/end=%d:%d\n",
+			 inode, istart, iend);
+	}
+	if (unlikely((istart == -1 && iend != -1) ||
+		     (istart != -1 && iend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci1: inode=%p istart/end=%d:%d\n",
+			 inode, istart, iend);
+	}
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(iend != istart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci2: inode=%p istart=%d iend=%d\n",
+				 inode, istart, iend);
+		}
+	}
+
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		if (unlikely(!UNIONFS_I(inode))) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci3: no inode_info %p\n", inode);
+			return;
+		}
+		if (unlikely(!UNIONFS_I(inode)->lower_inodes)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci4: no lower_inodes %p\n", inode);
+			return;
+		}
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			memset(&poison_ptr, POISON_INUSE, sizeof(void *));
+			if (unlikely(bindex < istart || bindex > iend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Ci5: inode/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", inode,
+					 lower_inode, bindex, istart, iend);
+			} else if (unlikely(lower_inode == poison_ptr)) {
+				/* freed inode! */
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Ci6: inode/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", inode,
+					 lower_inode, bindex, istart, iend);
+			}
+			continue;
+		}
+		/* if we get here, then lower_inode == NULL */
+		if (bindex < istart || bindex > iend)
+			continue;
+		/*
+		 * directories can have NULL lower inodes in b/t start/end,
+		 * but NOT if at the start/end range.
+		 */
+		if (unlikely(S_ISDIR(inode->i_mode) &&
+			     bindex > istart && bindex < iend))
+			continue;
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci7: inode/linode=%p:%p "
+			 "bindex=%d istart/end=%d:%d\n",
+			 inode, lower_inode, bindex, istart, iend);
+	}
+}
+
+void __unionfs_check_dentry(const struct dentry *dentry,
+			    const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int dstart, dend, istart, iend;
+	struct dentry *lower_dentry;
+	struct inode *inode, *lower_inode;
+	struct super_block *sb;
+	struct vfsmount *lower_mnt;
+	int printed_caller = 0;
+	void *poison_ptr;
+
+	BUG_ON(!dentry);
+	sb = dentry->d_sb;
+	inode = dentry->d_inode;
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	/* don't check dentry/mnt if no lower branches */
+	if (dstart < 0 && dend < 0)
+		goto check_inode;
+	BUG_ON(dstart > dend);
+
+	if (unlikely((dstart == -1 && dend != -1) ||
+		     (dstart != -1 && dend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CD0: dentry=%p dstart/end=%d:%d\n",
+			 dentry, dstart, dend);
+	}
+	/*
+	 * check for NULL dentries inside the start/end range, or
+	 * non-NULL dentries outside the start/end range.
+	 */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (lower_dentry) {
+			if (unlikely(bindex < dstart || bindex > dend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CD1: dentry/lower=%p:%p(%p) "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_dentry,
+					 (lower_dentry ? lower_dentry->d_inode :
+					  (void *) -1L),
+					 bindex, dstart, dend);
+			}
+		} else {	/* lower_dentry == NULL */
+			if (bindex < dstart || bindex > dend)
+				continue;
+			/*
+			 * Directories can have NULL lower inodes in b/t
+			 * start/end, but NOT if at the start/end range.
+			 * Ignore this rule, however, if this is a NULL
+			 * dentry or a deleted dentry.
+			 */
+			if (unlikely(!d_deleted((struct dentry *) dentry) &&
+				     inode &&
+				     !(inode && S_ISDIR(inode->i_mode) &&
+				       bindex > dstart && bindex < dend))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CD2: dentry/lower=%p:%p(%p) "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_dentry,
+					 (lower_dentry ?
+					  lower_dentry->d_inode :
+					  (void *) -1L),
+					 bindex, dstart, dend);
+			}
+		}
+	}
+
+	/* check for vfsmounts same as for dentries */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+		if (lower_mnt) {
+			if (unlikely(bindex < dstart || bindex > dend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CM0: dentry/lmnt=%p:%p bindex=%d "
+					 "dstart/end=%d:%d\n", dentry,
+					 lower_mnt, bindex, dstart, dend);
+			}
+		} else {	/* lower_mnt == NULL */
+			if (bindex < dstart || bindex > dend)
+				continue;
+			/*
+			 * Directories can have NULL lower inodes in b/t
+			 * start/end, but NOT if at the start/end range.
+			 * Ignore this rule, however, if this is a NULL
+			 * dentry.
+			 */
+			if (unlikely(inode &&
+				     !(inode && S_ISDIR(inode->i_mode) &&
+				       bindex > dstart && bindex < dend))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CM1: dentry/lmnt=%p:%p "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_mnt, bindex,
+					 dstart, dend);
+			}
+		}
+	}
+
+check_inode:
+	/* for inodes now */
+	if (!inode)
+		return;
+	istart = ibstart(inode);
+	iend = ibend(inode);
+	/* don't check inode if no lower branches */
+	if (istart < 0 && iend < 0)
+		return;
+	BUG_ON(istart > iend);
+	if (unlikely((istart == -1 && iend != -1) ||
+		     (istart != -1 && iend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI0: dentry/inode=%p:%p istart/end=%d:%d\n",
+			 dentry, inode, istart, iend);
+	}
+	if (unlikely(istart != dstart)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI1: dentry/inode=%p:%p istart=%d dstart=%d\n",
+			 dentry, inode, istart, dstart);
+	}
+	if (unlikely(iend != dend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI2: dentry/inode=%p:%p iend=%d dend=%d\n",
+			 dentry, inode, iend, dend);
+	}
+
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(dend != dstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CI3: dentry/inode=%p:%p dstart=%d dend=%d\n",
+				 dentry, inode, dstart, dend);
+		}
+		if (unlikely(iend != istart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CI4: dentry/inode=%p:%p istart=%d iend=%d\n",
+				 dentry, inode, istart, iend);
+		}
+	}
+
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			memset(&poison_ptr, POISON_INUSE, sizeof(void *));
+			if (unlikely(bindex < istart || bindex > iend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CI5: dentry/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", dentry,
+					 lower_inode, bindex, istart, iend);
+			} else if (unlikely(lower_inode == poison_ptr)) {
+				/* freed inode! */
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CI6: dentry/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", dentry,
+					 lower_inode, bindex, istart, iend);
+			}
+			continue;
+		}
+		/* if we get here, then lower_inode == NULL */
+		if (bindex < istart || bindex > iend)
+			continue;
+		/*
+		 * directories can have NULL lower inodes in b/t start/end,
+		 * but NOT if at the start/end range.
+		 */
+		if (unlikely(S_ISDIR(inode->i_mode) &&
+			     bindex > istart && bindex < iend))
+			continue;
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI7: dentry/linode=%p:%p "
+			 "bindex=%d istart/end=%d:%d\n",
+			 dentry, lower_inode, bindex, istart, iend);
+	}
+
+	/*
+	 * If it's a directory, then intermediate objects b/t start/end can
+	 * be NULL.  But, check that all three are NULL: lower dentry, mnt,
+	 * and inode.
+	 */
+	if (dstart >= 0 && dend >= 0 && S_ISDIR(inode->i_mode))
+		for (bindex = dstart+1; bindex < dend; bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			lower_dentry = unionfs_lower_dentry_idx(dentry,
+								bindex);
+			lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+			if (unlikely(!((lower_inode && lower_dentry &&
+					lower_mnt) ||
+				       (!lower_inode &&
+					!lower_dentry && !lower_mnt)))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Cx: lmnt/ldentry/linode=%p:%p:%p "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 lower_mnt, lower_dentry, lower_inode,
+					 bindex, dstart, dend);
+			}
+		}
+	/* check if lower inode is newer than upper one (it shouldn't) */
+	if (unlikely(is_newer_lower(dentry) && !is_negative_lower(dentry))) {
+		PRINT_CALLER(fname, fxn, line);
+		for (bindex = ibstart(inode); bindex <= ibend(inode);
+		     bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			if (unlikely(!lower_inode))
+				continue;
+			pr_debug(" CI8: bindex=%d mtime/lmtime=%lu.%lu/%lu.%lu "
+				 "ctime/lctime=%lu.%lu/%lu.%lu\n",
+				 bindex,
+				 inode->i_mtime.tv_sec,
+				 inode->i_mtime.tv_nsec,
+				 lower_inode->i_mtime.tv_sec,
+				 lower_inode->i_mtime.tv_nsec,
+				 inode->i_ctime.tv_sec,
+				 inode->i_ctime.tv_nsec,
+				 lower_inode->i_ctime.tv_sec,
+				 lower_inode->i_ctime.tv_nsec);
+		}
+	}
+}
+
+void __unionfs_check_file(const struct file *file,
+			  const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int dstart, dend, fstart, fend;
+	struct dentry *dentry;
+	struct file *lower_file;
+	struct inode *inode;
+	struct super_block *sb;
+	int printed_caller = 0;
+
+	BUG_ON(!file);
+	dentry = file->f_path.dentry;
+	sb = dentry->d_sb;
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	BUG_ON(dstart > dend);
+	fstart = fbstart(file);
+	fend = fbend(file);
+	BUG_ON(fstart > fend);
+
+	if (unlikely((fstart == -1 && fend != -1) ||
+		     (fstart != -1 && fend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF0: file/dentry=%p:%p fstart/end=%d:%d\n",
+			 file, dentry, fstart, fend);
+	}
+	if (unlikely(fstart != dstart)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF1: file/dentry=%p:%p fstart=%d dstart=%d\n",
+			 file, dentry, fstart, dstart);
+	}
+	if (unlikely(fend != dend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF2: file/dentry=%p:%p fend=%d dend=%d\n",
+			 file, dentry, fend, dend);
+	}
+	inode = dentry->d_inode;
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(fend != fstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CF3: file/inode=%p:%p fstart=%d fend=%d\n",
+				 file, inode, fstart, fend);
+		}
+		if (unlikely(dend != dstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CF4: file/dentry=%p:%p dstart=%d dend=%d\n",
+				 file, dentry, dstart, dend);
+		}
+	}
+
+	/*
+	 * check for NULL dentries inside the start/end range, or
+	 * non-NULL dentries outside the start/end range.
+	 */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		if (lower_file) {
+			if (unlikely(bindex < fstart || bindex > fend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CF5: file/lower=%p:%p bindex=%d "
+					 "fstart/end=%d:%d\n", file,
+					 lower_file, bindex, fstart, fend);
+			}
+		} else {	/* lower_file == NULL */
+			if (bindex >= fstart && bindex <= fend) {
+				/*
+				 * directories can have NULL lower inodes in
+				 * b/t start/end, but NOT if at the
+				 * start/end range.
+				 */
+				if (unlikely(!(S_ISDIR(inode->i_mode) &&
+					       bindex > fstart &&
+					       bindex < fend))) {
+					PRINT_CALLER(fname, fxn, line);
+					pr_debug(" CF6: file/lower=%p:%p "
+						 "bindex=%d fstart/end=%d:%d\n",
+						 file, lower_file, bindex,
+						 fstart, fend);
+				}
+			}
+		}
+	}
+
+	__unionfs_check_dentry(dentry, fname, fxn, line);
+}
+
+void __unionfs_check_nd(const struct nameidata *nd,
+			const char *fname, const char *fxn, int line)
+{
+	struct file *file;
+	int printed_caller = 0;
+
+	if (unlikely(!nd))
+		return;
+	if (nd->flags & LOOKUP_OPEN) {
+		file = nd->intent.open.file;
+		if (unlikely(file->f_path.dentry &&
+			     strcmp(file->f_path.dentry->d_sb->s_type->name,
+				    UNIONFS_NAME))) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CND1: lower_file of type %s\n",
+				 file->f_path.dentry->d_sb->s_type->name);
+			BUG();
+		}
+	}
+}
+
+/* useful to track vfsmount leaks that could cause EBUSY on unmount */
+void __show_branch_counts(const struct super_block *sb,
+			  const char *file, const char *fxn, int line)
+{
+	int i;
+	struct vfsmount *mnt;
+
+	pr_debug("BC:");
+	for (i = 0; i < sbmax(sb); i++) {
+		if (likely(sb->s_root))
+			mnt = UNIONFS_D(sb->s_root)->lower_paths[i].mnt;
+		else
+			mnt = NULL;
+		printk(KERN_CONT "%d:",
+		       (mnt ? atomic_read(&mnt->mnt_count) : -99));
+	}
+	printk(KERN_CONT "%s:%s:%d\n", file, fxn, line);
+}
+
+void __show_inode_times(const struct inode *inode,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (unlikely(!lower_inode))
+			continue;
+		pr_debug("IT(%lu:%d): %s:%s:%d "
+			 "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\n",
+			 inode->i_ino, bindex,
+			 file, fxn, line,
+			 inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
+			 lower_inode->i_mtime.tv_sec,
+			 lower_inode->i_mtime.tv_nsec,
+			 inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
+			 lower_inode->i_ctime.tv_sec,
+			 lower_inode->i_ctime.tv_nsec);
+	}
+}
+
+void __show_dinode_times(const struct dentry *dentry,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode *lower_inode;
+	int bindex;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+		pr_debug("DT(%s:%lu:%d): %s:%s:%d "
+			 "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\n",
+			 dentry->d_name.name, inode->i_ino, bindex,
+			 file, fxn, line,
+			 inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
+			 lower_inode->i_mtime.tv_sec,
+			 lower_inode->i_mtime.tv_nsec,
+			 inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
+			 lower_inode->i_ctime.tv_sec,
+			 lower_inode->i_ctime.tv_nsec);
+	}
+}
+
+void __show_inode_counts(const struct inode *inode,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	if (unlikely(!inode)) {
+		pr_debug("SiC: Null inode\n");
+		return;
+	}
+	for (bindex = sbstart(inode->i_sb); bindex <= sbend(inode->i_sb);
+	     bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (unlikely(!lower_inode))
+			continue;
+		pr_debug("SIC(%lu:%d:%d): lc=%d %s:%s:%d\n",
+			 inode->i_ino, bindex,
+			 atomic_read(&(inode)->i_count),
+			 atomic_read(&(lower_inode)->i_count),
+			 file, fxn, line);
+	}
+}
diff --git a/fs/unionfs/dentry.c b/fs/unionfs/dentry.c
new file mode 100644
index 0000000..7f0c7f7
--- /dev/null
+++ b/fs/unionfs/dentry.c
@@ -0,0 +1,570 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+bool is_negative_lower(const struct dentry *dentry)
+{
+	int bindex;
+	struct dentry *lower_dentry;
+
+	BUG_ON(!dentry);
+	/* cache coherency: check if file was deleted on lower branch */
+	if (dbstart(dentry) < 0)
+		return true;
+	for (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		/* unhashed (i.e., unlinked) lower dentries don't count */
+		if (lower_dentry && lower_dentry->d_inode &&
+		    !d_deleted(lower_dentry) &&
+		    !(lower_dentry->d_flags & DCACHE_NFSFS_RENAMED))
+			return false;
+	}
+	return true;
+}
+
+static inline void __dput_lowers(struct dentry *dentry, int start, int end)
+{
+	struct dentry *lower_dentry;
+	int bindex;
+
+	if (start < 0)
+		return;
+	for (bindex = start; bindex <= end; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+		dput(lower_dentry);
+	}
+}
+
+/*
+ * Revalidate a single dentry.
+ * Assume that dentry's info node is locked.
+ * Assume that parent(s) are all valid already, but
+ * the child may not yet be valid.
+ * Returns true if valid, false otherwise.
+ */
+static bool __unionfs_d_revalidate_one(struct dentry *dentry,
+				       struct nameidata *nd)
+{
+	bool valid = true;	/* default is valid */
+	struct dentry *lower_dentry;
+	int bindex, bstart, bend;
+	int sbgen, dgen;
+	int positive = 0;
+	int interpose_flag;
+	struct nameidata lowernd; /* TODO: be gentler to the stack */
+
+	if (nd)
+		memcpy(&lowernd, nd, sizeof(struct nameidata));
+	else
+		memset(&lowernd, 0, sizeof(struct nameidata));
+
+	verify_locked(dentry);
+	verify_locked(dentry->d_parent);
+
+	sbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);
+	/* if the dentry is unhashed, do NOT revalidate */
+	if (d_deleted(dentry))
+		goto out;
+
+	BUG_ON(dbstart(dentry) == -1);
+	if (dentry->d_inode)
+		positive = 1;
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+	/*
+	 * If we are working on an unconnected dentry, then there is no
+	 * revalidation to be done, because this file does not exist within
+	 * the namespace, and Unionfs operates on the namespace, not data.
+	 */
+	if (unlikely(sbgen != dgen)) {
+		struct dentry *result;
+		int pdgen;
+
+		/* The root entry should always be valid */
+		BUG_ON(IS_ROOT(dentry));
+
+		/* We can't work correctly if our parent isn't valid. */
+		pdgen = atomic_read(&UNIONFS_D(dentry->d_parent)->generation);
+		BUG_ON(pdgen != sbgen);	/* should never happen here */
+
+		/* Free the pointers for our inodes and this dentry. */
+		bstart = dbstart(dentry);
+		bend = dbend(dentry);
+
+		/*
+		 * mntput unhashed lower dentries, because those files got
+		 * deleted or rmdir'ed.
+		 */
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+			if (!lower_dentry)
+				continue;
+			if (!d_deleted(lower_dentry) &&
+			    !(lower_dentry->d_flags & DCACHE_NFSFS_RENAMED))
+			    continue;
+			unionfs_mntput(dentry, bindex);
+		}
+
+		__dput_lowers(dentry, bstart, bend);
+		dbstart(dentry) = dbend(dentry) = -1;
+
+		interpose_flag = INTERPOSE_REVAL_NEG;
+		if (positive) {
+			interpose_flag = INTERPOSE_REVAL;
+			iput_lowers_all(dentry->d_inode, true);
+		}
+
+		if (realloc_dentry_private_data(dentry) != 0) {
+			valid = false;
+			goto out;
+		}
+
+		result = unionfs_lookup_full(dentry, &lowernd, interpose_flag);
+		if (result) {
+			if (IS_ERR(result)) {
+				valid = false;
+				goto out;
+			}
+			/*
+			 * current unionfs_lookup_backend() doesn't return
+			 * a valid dentry
+			 */
+			dput(dentry);
+			dentry = result;
+		}
+
+		if (unlikely(positive && is_negative_lower(dentry))) {
+			make_bad_inode(dentry->d_inode);
+			d_drop(dentry);
+			valid = false;
+			goto out;
+		}
+		goto out;
+	}
+
+	/* The revalidation must occur across all branches */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart == -1);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry || !lower_dentry->d_op
+		    || !lower_dentry->d_op->d_revalidate)
+			continue;
+		/*
+		 * Don't pass nameidata to lower file system, because we
+		 * don't want an arbitrary lower file being opened or
+		 * returned to us: it may be useless to us because of the
+		 * fanout nature of unionfs (cf. file/directory open-file
+		 * invariants).  We will open lower files as and when needed
+		 * later on.
+		 */
+		if (!lower_dentry->d_op->d_revalidate(lower_dentry, NULL))
+			valid = false;
+	}
+
+	if (!dentry->d_inode ||
+	    ibstart(dentry->d_inode) < 0 ||
+	    ibend(dentry->d_inode) < 0) {
+		valid = false;
+		goto out;
+	}
+
+	if (valid) {
+		/*
+		 * If we get here, and we copy the meta-data from the lower
+		 * inode to our inode, then it is vital that we have already
+		 * purged all unionfs-level file data.  We do that in the
+		 * caller (__unionfs_d_revalidate_chain) by calling
+		 * purge_inode_data.
+		 */
+		unionfs_copy_attr_all(dentry->d_inode,
+				      unionfs_lower_inode(dentry->d_inode));
+		fsstack_copy_inode_size(dentry->d_inode,
+					unionfs_lower_inode(dentry->d_inode));
+	}
+
+out:
+	if (valid)
+		atomic_set(&UNIONFS_D(dentry)->generation, sbgen);
+
+	return valid;
+}
+
+/*
+ * Determine if the lower inode objects have changed from below the unionfs
+ * inode.  Return true if changed, false otherwise.
+ *
+ * We check if the mtime or ctime have changed.  However, the inode times
+ * can be changed by anyone without much protection, including
+ * asynchronously.  This can sometimes cause unionfs to find that the lower
+ * file system doesn't change its inode times quick enough, resulting in a
+ * false positive indication (which is harmless, it just makes unionfs do
+ * extra work in re-validating the objects).  To minimize the chances of
+ * these situations, we still consider such small time changes valid, but we
+ * don't print debugging messages unless the time changes are greater than
+ * UNIONFS_MIN_CC_TIME (which defaults to 3 seconds, as with NFS's acregmin)
+ * because significant changes are more likely due to users manually
+ * touching lower files.
+ */
+bool is_newer_lower(const struct dentry *dentry)
+{
+	int bindex;
+	struct inode *inode;
+	struct inode *lower_inode;
+
+	/* ignore if we're called on semi-initialized dentries/inodes */
+	if (!dentry || !UNIONFS_D(dentry))
+		return false;
+	inode = dentry->d_inode;
+	if (!inode || !UNIONFS_I(inode)->lower_inodes ||
+	    ibstart(inode) < 0 || ibend(inode) < 0)
+		return false;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		/* check if mtime/ctime have changed */
+		if (unlikely(timespec_compare(&inode->i_mtime,
+					      &lower_inode->i_mtime) < 0)) {
+			if ((lower_inode->i_mtime.tv_sec -
+			     inode->i_mtime.tv_sec) > UNIONFS_MIN_CC_TIME) {
+				pr_info("unionfs: new lower inode mtime "
+					"(bindex=%d, name=%s)\n", bindex,
+					dentry->d_name.name);
+				show_dinode_times(dentry);
+			}
+			return true;
+		}
+		if (unlikely(timespec_compare(&inode->i_ctime,
+					      &lower_inode->i_ctime) < 0)) {
+			if ((lower_inode->i_ctime.tv_sec -
+			     inode->i_ctime.tv_sec) > UNIONFS_MIN_CC_TIME) {
+				pr_info("unionfs: new lower inode ctime "
+					"(bindex=%d, name=%s)\n", bindex,
+					dentry->d_name.name);
+				show_dinode_times(dentry);
+			}
+			return true;
+		}
+	}
+
+	/*
+	 * Last check: if this is a positive dentry, but somehow all lower
+	 * dentries are negative or unhashed, then this dentry needs to be
+	 * revalidated, because someone probably deleted the objects from
+	 * the lower branches directly.
+	 */
+	if (is_negative_lower(dentry))
+		return true;
+
+	return false;		/* default: lower is not newer */
+}
+
+/*
+ * Purge and invalidate as many data pages of a unionfs inode.  This is
+ * called when the lower inode has changed, and we want to force processes
+ * to re-get the new data.
+ */
+static inline void purge_inode_data(struct inode *inode)
+{
+	/* remove all non-private mappings */
+	unmap_mapping_range(inode->i_mapping, 0, 0, 0);
+	/* invalidate as many pages as possible */
+	invalidate_mapping_pages(inode->i_mapping, 0, -1);
+	/*
+	 * Don't try to truncate_inode_pages here, because this could lead
+	 * to a deadlock between some of address_space ops and dentry
+	 * revalidation: the address space op is invoked with a lock on our
+	 * own page, and truncate_inode_pages will block on locked pages.
+	 */
+}
+
+/*
+ * Revalidate a single file/symlink/special dentry.  Assume that info nodes
+ * of the dentry and its parent are locked.  Assume that parent(s) are all
+ * valid already, but the child may not yet be valid.  Returns true if
+ * valid, false otherwise.
+ */
+bool __unionfs_d_revalidate_one_locked(struct dentry *dentry,
+				       struct nameidata *nd,
+				       bool willwrite)
+{
+	bool valid = false;	/* default is invalid */
+	int sbgen, dgen, bindex;
+
+	verify_locked(dentry);
+	verify_locked(dentry->d_parent);
+
+	sbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+
+	if (unlikely(is_newer_lower(dentry))) {
+		/* root dentry special case as aforementioned */
+		if (IS_ROOT(dentry)) {
+			unionfs_copy_attr_times(dentry->d_inode);
+		} else {
+			/*
+			 * reset generation number to zero, guaranteed to be
+			 * "old"
+			 */
+			dgen = 0;
+			atomic_set(&UNIONFS_D(dentry)->generation, dgen);
+		}
+		if (!willwrite)
+			purge_inode_data(dentry->d_inode);
+	}
+	valid = __unionfs_d_revalidate_one(dentry, nd);
+
+	/*
+	 * If __unionfs_d_revalidate_one() succeeded above, then it will
+	 * have incremented the refcnt of the mnt's, but also the branch
+	 * indices of the dentry will have been updated (to take into
+	 * account any branch insertions/deletion.  So the current
+	 * dbstart/dbend match the current, and new, indices of the mnts
+	 * which __unionfs_d_revalidate_one has incremented.  Note: the "if"
+	 * test below does not depend on whether chain_len was 0 or greater.
+	 */
+	if (!valid || sbgen == dgen)
+		goto out;
+	for (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++)
+		unionfs_mntput(dentry, bindex);
+out:
+	return valid;
+}
+
+/*
+ * Revalidate a parent chain of dentries, then the actual node.
+ * Assumes that dentry is locked, but will lock all parents if/when needed.
+ *
+ * If 'willwrite' is true, and the lower inode times are not in sync, then
+ * *don't* purge_inode_data, as it could deadlock if ->write calls us and we
+ * try to truncate a locked page.  Besides, if unionfs is about to write
+ * data to a file, then there's the data unionfs is about to write is more
+ * authoritative than what's below, therefore we can safely overwrite the
+ * lower inode times and data.
+ */
+bool __unionfs_d_revalidate_chain(struct dentry *dentry, struct nameidata *nd,
+				  bool willwrite)
+{
+	bool valid = false;	/* default is invalid */
+	struct dentry **chain = NULL; /* chain of dentries to reval */
+	int chain_len = 0;
+	struct dentry *dtmp;
+	int sbgen, dgen, i;
+	int saved_bstart, saved_bend, bindex;
+
+	/* find length of chain needed to revalidate */
+	/* XXX: should I grab some global (dcache?) lock? */
+	chain_len = 0;
+	sbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);
+	dtmp = dentry->d_parent;
+	verify_locked(dentry);
+	if (dentry != dtmp)
+		unionfs_lock_dentry(dtmp, UNIONFS_DMUTEX_REVAL_PARENT);
+	dgen = atomic_read(&UNIONFS_D(dtmp)->generation);
+	/* XXX: should we check if is_newer_lower all the way up? */
+	if (unlikely(is_newer_lower(dtmp))) {
+		/*
+		 * Special case: the root dentry's generation number must
+		 * always be valid, but its lower inode times don't have to
+		 * be, so sync up the times only.
+		 */
+		if (IS_ROOT(dtmp)) {
+			unionfs_copy_attr_times(dtmp->d_inode);
+		} else {
+			/*
+			 * reset generation number to zero, guaranteed to be
+			 * "old"
+			 */
+			dgen = 0;
+			atomic_set(&UNIONFS_D(dtmp)->generation, dgen);
+		}
+		purge_inode_data(dtmp->d_inode);
+	}
+	if (dentry != dtmp)
+		unionfs_unlock_dentry(dtmp);
+	while (sbgen != dgen) {
+		/* The root entry should always be valid */
+		BUG_ON(IS_ROOT(dtmp));
+		chain_len++;
+		dtmp = dtmp->d_parent;
+		dgen = atomic_read(&UNIONFS_D(dtmp)->generation);
+	}
+	if (chain_len == 0)
+		goto out_this;	/* shortcut if parents are OK */
+
+	/*
+	 * Allocate array of dentries to reval.  We could use linked lists,
+	 * but the number of entries we need to alloc here is often small,
+	 * and short lived, so locality will be better.
+	 */
+	chain = kzalloc(chain_len * sizeof(struct dentry *), GFP_KERNEL);
+	if (unlikely(!chain)) {
+		printk(KERN_CRIT "unionfs: no more memory in %s\n",
+		       __func__);
+		goto out;
+	}
+
+	/* grab all dentries in chain, in child to parent order */
+	dtmp = dentry;
+	for (i = chain_len-1; i >= 0; i--)
+		dtmp = chain[i] = dget_parent(dtmp);
+
+	/*
+	 * call __unionfs_d_revalidate_one() on each dentry, but in parent
+	 * to child order.
+	 */
+	for (i = 0; i < chain_len; i++) {
+		unionfs_lock_dentry(chain[i], UNIONFS_DMUTEX_REVAL_CHILD);
+		if (chain[i] != chain[i]->d_parent)
+			unionfs_lock_dentry(chain[i]->d_parent,
+					    UNIONFS_DMUTEX_REVAL_PARENT);
+		saved_bstart = dbstart(chain[i]);
+		saved_bend = dbend(chain[i]);
+		sbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);
+		dgen = atomic_read(&UNIONFS_D(chain[i])->generation);
+
+		valid = __unionfs_d_revalidate_one(chain[i], nd);
+		/* XXX: is this the correct mntput condition?! */
+		if (valid && chain_len > 0 &&
+		    sbgen != dgen && chain[i]->d_inode &&
+		    S_ISDIR(chain[i]->d_inode->i_mode)) {
+			for (bindex = saved_bstart; bindex <= saved_bend;
+			     bindex++)
+				unionfs_mntput(chain[i], bindex);
+		}
+		if (chain[i] != chain[i]->d_parent)
+			unionfs_unlock_dentry(chain[i]->d_parent);
+		unionfs_unlock_dentry(chain[i]);
+
+		if (unlikely(!valid))
+			goto out_free;
+	}
+
+
+out_this:
+	/* finally, lock this dentry and revalidate it */
+	verify_locked(dentry);	/* verify child is locked */
+	if (dentry != dentry->d_parent)
+		unionfs_lock_dentry(dentry->d_parent,
+				    UNIONFS_DMUTEX_REVAL_PARENT);
+	valid = __unionfs_d_revalidate_one_locked(dentry, nd, willwrite);
+	if (dentry != dentry->d_parent)
+		unionfs_unlock_dentry(dentry->d_parent);
+
+out_free:
+	/* unlock/dput all dentries in chain and return status */
+	if (chain_len > 0) {
+		for (i = 0; i < chain_len; i++)
+			dput(chain[i]);
+		kfree(chain);
+	}
+out:
+	return valid;
+}
+
+static int unionfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+{
+	int err;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = __unionfs_d_revalidate_chain(dentry, nd, false);
+	if (likely(err > 0)) { /* true==1: dentry is valid */
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_dentry(dentry);
+		unionfs_check_nd(nd);
+	}
+	unionfs_unlock_dentry(dentry);
+
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+static void unionfs_d_release(struct dentry *dentry)
+{
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	if (unlikely(!UNIONFS_D(dentry)))
+		goto out;	/* skip if no lower branches */
+	/* must lock our branch configuration here */
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	unionfs_check_dentry(dentry);
+	/* this could be a negative dentry, so check first */
+	if (dbstart(dentry) < 0) {
+		unionfs_unlock_dentry(dentry);
+		goto out;	/* due to a (normal) failed lookup */
+	}
+
+	/* Release all the lower dentries */
+	path_put_lowers_all(dentry, true);
+
+	unionfs_unlock_dentry(dentry);
+
+out:
+	free_dentry_private_data(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return;
+}
+
+/*
+ * Called when we're removing the last reference to our dentry.  So we
+ * should drop all lower references too.
+ */
+static void unionfs_d_iput(struct dentry *dentry, struct inode *inode)
+{
+	int rc;
+
+	BUG_ON(!dentry);
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (!UNIONFS_D(dentry) || dbstart(dentry) < 0)
+		goto drop_lower_inodes;
+	path_put_lowers_all(dentry, false);
+
+drop_lower_inodes:
+	rc = atomic_read(&inode->i_count);
+	if (rc == 1 && inode->i_nlink == 1 && ibstart(inode) >= 0) {
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		iput(unionfs_lower_inode(inode));
+		lockdep_on();
+		unionfs_set_lower_inode(inode, NULL);
+		/* XXX: may need to set start/end to -1? */
+	}
+
+	iput(inode);
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+}
+
+struct dentry_operations unionfs_dops = {
+	.d_revalidate	= unionfs_d_revalidate,
+	.d_release	= unionfs_d_release,
+	.d_iput		= unionfs_d_iput,
+};
diff --git a/fs/unionfs/dirfops.c b/fs/unionfs/dirfops.c
new file mode 100644
index 0000000..14ca7d3
--- /dev/null
+++ b/fs/unionfs/dirfops.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* Make sure our rdstate is playing by the rules. */
+static void verify_rdstate_offset(struct unionfs_dir_state *rdstate)
+{
+	BUG_ON(rdstate->offset >= DIREOF);
+	BUG_ON(rdstate->cookie >= MAXRDCOOKIE);
+}
+
+struct unionfs_getdents_callback {
+	struct unionfs_dir_state *rdstate;
+	void *dirent;
+	int entries_written;
+	int filldir_called;
+	int filldir_error;
+	filldir_t filldir;
+	struct super_block *sb;
+};
+
+/* based on generic filldir in fs/readir.c */
+static int unionfs_filldir(void *dirent, const char *oname, int namelen,
+			   loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct unionfs_getdents_callback *buf = dirent;
+	struct filldir_node *found = NULL;
+	int err = 0;
+	int is_whiteout;
+	char *name = (char *) oname;
+
+	buf->filldir_called++;
+
+	is_whiteout = is_whiteout_name(&name, &namelen);
+
+	found = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);
+
+	if (found) {
+		/*
+		 * If we had non-whiteout entry in dir cache, then mark it
+		 * as a whiteout and but leave it in the dir cache.
+		 */
+		if (is_whiteout && !found->whiteout)
+			found->whiteout = is_whiteout;
+		goto out;
+	}
+
+	/* if 'name' isn't a whiteout, filldir it. */
+	if (!is_whiteout) {
+		off_t pos = rdstate2offset(buf->rdstate);
+		u64 unionfs_ino = ino;
+
+		err = buf->filldir(buf->dirent, name, namelen, pos,
+				   unionfs_ino, d_type);
+		buf->rdstate->offset++;
+		verify_rdstate_offset(buf->rdstate);
+	}
+	/*
+	 * If we did fill it, stuff it in our hash, otherwise return an
+	 * error.
+	 */
+	if (err) {
+		buf->filldir_error = err;
+		goto out;
+	}
+	buf->entries_written++;
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->bindex, is_whiteout);
+	if (err)
+		buf->filldir_error = err;
+
+out:
+	return err;
+}
+
+static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *inode = NULL;
+	struct unionfs_getdents_callback buf;
+	struct unionfs_dir_state *uds;
+	int bend;
+	loff_t offset;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, false);
+	if (unlikely(err))
+		goto out;
+
+	inode = dentry->d_inode;
+
+	uds = UNIONFS_F(file)->rdstate;
+	if (!uds) {
+		if (file->f_pos == DIREOF) {
+			goto out;
+		} else if (file->f_pos > 0) {
+			uds = find_rdstate(inode, file->f_pos);
+			if (unlikely(!uds)) {
+				err = -ESTALE;
+				goto out;
+			}
+			UNIONFS_F(file)->rdstate = uds;
+		} else {
+			init_rdstate(file);
+			uds = UNIONFS_F(file)->rdstate;
+		}
+	}
+	bend = fbend(file);
+
+	while (uds->bindex <= bend) {
+		lower_file = unionfs_lower_file_idx(file, uds->bindex);
+		if (!lower_file) {
+			uds->bindex++;
+			uds->dirpos = 0;
+			continue;
+		}
+
+		/* prepare callback buffer */
+		buf.filldir_called = 0;
+		buf.filldir_error = 0;
+		buf.entries_written = 0;
+		buf.dirent = dirent;
+		buf.filldir = filldir;
+		buf.rdstate = uds;
+		buf.sb = inode->i_sb;
+
+		/* Read starting from where we last left off. */
+		offset = vfs_llseek(lower_file, uds->dirpos, SEEK_SET);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		err = vfs_readdir(lower_file, unionfs_filldir, &buf);
+
+		/* Save the position for when we continue. */
+		offset = vfs_llseek(lower_file, 0, SEEK_CUR);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		uds->dirpos = offset;
+
+		/* Copy the atime. */
+		fsstack_copy_attr_atime(inode,
+					lower_file->f_path.dentry->d_inode);
+
+		if (err < 0)
+			goto out;
+
+		if (buf.filldir_error)
+			break;
+
+		if (!buf.entries_written) {
+			uds->bindex++;
+			uds->dirpos = 0;
+		}
+	}
+
+	if (!buf.filldir_error && uds->bindex >= bend) {
+		/* Save the number of hash entries for next time. */
+		UNIONFS_I(inode)->hashsize = uds->hashentries;
+		free_rdstate(uds);
+		UNIONFS_F(file)->rdstate = NULL;
+		file->f_pos = DIREOF;
+	} else {
+		file->f_pos = rdstate2offset(uds);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * This is not meant to be a generic repositioning function.  If you do
+ * things that aren't supported, then we return EINVAL.
+ *
+ * What is allowed:
+ *  (1) seeking to the same position that you are currently at
+ *	This really has no effect, but returns where you are.
+ *  (2) seeking to the beginning of the file
+ *	This throws out all state, and lets you begin again.
+ */
+static loff_t unionfs_dir_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct unionfs_dir_state *rdstate;
+	struct dentry *dentry = file->f_path.dentry;
+	loff_t err;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, false);
+	if (unlikely(err))
+		goto out;
+
+	rdstate = UNIONFS_F(file)->rdstate;
+
+	/*
+	 * we let users seek to their current position, but not anywhere
+	 * else.
+	 */
+	if (!offset) {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				free_rdstate(rdstate);
+				UNIONFS_F(file)->rdstate = NULL;
+			}
+			init_rdstate(file);
+			err = 0;
+			break;
+		case SEEK_CUR:
+			err = file->f_pos;
+			break;
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	} else {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				if (offset == rdstate2offset(rdstate))
+					err = offset;
+				else if (file->f_pos == DIREOF)
+					err = DIREOF;
+				else
+					err = -EINVAL;
+			} else {
+				struct inode *inode;
+				inode = dentry->d_inode;
+				rdstate = find_rdstate(inode, offset);
+				if (rdstate) {
+					UNIONFS_F(file)->rdstate = rdstate;
+					err = rdstate->offset;
+				} else {
+					err = -EINVAL;
+				}
+			}
+			break;
+		case SEEK_CUR:
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * Trimmed directory options, we shouldn't pass everything down since
+ * we don't want to operate on partial directories.
+ */
+struct file_operations unionfs_dir_fops = {
+	.llseek		= unionfs_dir_llseek,
+	.read		= generic_read_dir,
+	.readdir	= unionfs_readdir,
+	.unlocked_ioctl	= unionfs_ioctl,
+	.open		= unionfs_open,
+	.release	= unionfs_file_release,
+	.flush		= unionfs_flush,
+	.fsync		= unionfs_fsync,
+	.fasync		= unionfs_fasync,
+};
diff --git a/fs/unionfs/dirhelper.c b/fs/unionfs/dirhelper.c
new file mode 100644
index 0000000..d936f03
--- /dev/null
+++ b/fs/unionfs/dirhelper.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+#define RD_NONE 0
+#define RD_CHECK_EMPTY 1
+/* The callback structure for check_empty. */
+struct unionfs_rdutil_callback {
+	int err;
+	int filldir_called;
+	struct unionfs_dir_state *rdstate;
+	int mode;
+};
+
+/* This filldir function makes sure only whiteouts exist within a directory. */
+static int readdir_util_callback(void *dirent, const char *oname, int namelen,
+				 loff_t offset, u64 ino, unsigned int d_type)
+{
+	int err = 0;
+	struct unionfs_rdutil_callback *buf = dirent;
+	int is_whiteout;
+	struct filldir_node *found;
+	char *name = (char *) oname;
+
+	buf->filldir_called = 1;
+
+	if (name[0] == '.' && (namelen == 1 ||
+			       (name[1] == '.' && namelen == 2)))
+		goto out;
+
+	is_whiteout = is_whiteout_name(&name, &namelen);
+
+	found = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);
+	/* If it was found in the table there was a previous whiteout. */
+	if (found)
+		goto out;
+
+	/*
+	 * if it wasn't found and isn't a whiteout, the directory isn't
+	 * empty.
+	 */
+	err = -ENOTEMPTY;
+	if ((buf->mode == RD_CHECK_EMPTY) && !is_whiteout)
+		goto out;
+
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->bindex, is_whiteout);
+
+out:
+	buf->err = err;
+	return err;
+}
+
+/* Is a directory logically empty? */
+int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct vfsmount *mnt;
+	struct super_block *sb;
+	struct file *lower_file;
+	struct unionfs_rdutil_callback *buf = NULL;
+	int bindex, bstart, bend, bopaque;
+
+	sb = dentry->d_sb;
+
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+
+	err = unionfs_partial_lookup(dentry);
+	if (err)
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	bopaque = dbopaque(dentry);
+	if (0 <= bopaque && bopaque < bend)
+		bend = bopaque;
+
+	buf = kmalloc(sizeof(struct unionfs_rdutil_callback), GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	buf->err = 0;
+	buf->mode = RD_CHECK_EMPTY;
+	buf->rdstate = alloc_rdstate(dentry->d_inode, bstart);
+	if (unlikely(!buf->rdstate)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Process the lower directories with rdutil_callback as a filldir. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (!lower_dentry->d_inode)
+			continue;
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+			continue;
+
+		dget(lower_dentry);
+		mnt = unionfs_mntget(dentry, bindex);
+		branchget(sb, bindex);
+		lower_file = dentry_open(lower_dentry, mnt, O_RDONLY);
+		if (IS_ERR(lower_file)) {
+			err = PTR_ERR(lower_file);
+			branchput(sb, bindex);
+			goto out;
+		}
+
+		do {
+			buf->filldir_called = 0;
+			buf->rdstate->bindex = bindex;
+			err = vfs_readdir(lower_file,
+					  readdir_util_callback, buf);
+			if (buf->err)
+				err = buf->err;
+		} while ((err >= 0) && buf->filldir_called);
+
+		/* fput calls dput for lower_dentry */
+		fput(lower_file);
+		branchput(sb, bindex);
+
+		if (err < 0)
+			goto out;
+	}
+
+out:
+	if (buf) {
+		if (namelist && !err)
+			*namelist = buf->rdstate;
+		else if (buf->rdstate)
+			free_rdstate(buf->rdstate);
+		kfree(buf);
+	}
+
+
+	return err;
+}
diff --git a/fs/unionfs/fanout.h b/fs/unionfs/fanout.h
new file mode 100644
index 0000000..4f264de
--- /dev/null
+++ b/fs/unionfs/fanout.h
@@ -0,0 +1,384 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _FANOUT_H_
+#define _FANOUT_H_
+
+/*
+ * Inode to private data
+ *
+ * Since we use containers and the struct inode is _inside_ the
+ * unionfs_inode_info structure, UNIONFS_I will always (given a non-NULL
+ * inode pointer), return a valid non-NULL pointer.
+ */
+static inline struct unionfs_inode_info *UNIONFS_I(const struct inode *inode)
+{
+	return container_of(inode, struct unionfs_inode_info, vfs_inode);
+}
+
+#define ibstart(ino) (UNIONFS_I(ino)->bstart)
+#define ibend(ino) (UNIONFS_I(ino)->bend)
+
+/* Dentry to private data */
+#define UNIONFS_D(dent) ((struct unionfs_dentry_info *)(dent)->d_fsdata)
+#define dbstart(dent) (UNIONFS_D(dent)->bstart)
+#define dbend(dent) (UNIONFS_D(dent)->bend)
+#define dbopaque(dent) (UNIONFS_D(dent)->bopaque)
+
+/* Superblock to private data */
+#define UNIONFS_SB(super) ((struct unionfs_sb_info *)(super)->s_fs_info)
+#define sbstart(sb) 0
+#define sbend(sb) (UNIONFS_SB(sb)->bend)
+#define sbmax(sb) (UNIONFS_SB(sb)->bend + 1)
+#define sbhbid(sb) (UNIONFS_SB(sb)->high_branch_id)
+
+/* File to private Data */
+#define UNIONFS_F(file) ((struct unionfs_file_info *)((file)->private_data))
+#define fbstart(file) (UNIONFS_F(file)->bstart)
+#define fbend(file) (UNIONFS_F(file)->bend)
+
+/* macros to manipulate branch IDs in stored in our superblock */
+static inline int branch_id(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	return UNIONFS_SB(sb)->data[index].branch_id;
+}
+
+static inline void set_branch_id(struct super_block *sb, int index, int val)
+{
+	BUG_ON(!sb || index < 0);
+	UNIONFS_SB(sb)->data[index].branch_id = val;
+}
+
+static inline void new_branch_id(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	set_branch_id(sb, index, ++UNIONFS_SB(sb)->high_branch_id);
+}
+
+/*
+ * Find new index of matching branch with an existing superblock of a known
+ * (possibly old) id.  This is needed because branches could have been
+ * added/deleted causing the branches of any open files to shift.
+ *
+ * @sb: the new superblock which may have new/different branch IDs
+ * @id: the old/existing id we're looking for
+ * Returns index of newly found branch (0 or greater), -1 otherwise.
+ */
+static inline int branch_id_to_idx(struct super_block *sb, int id)
+{
+	int i;
+	for (i = 0; i < sbmax(sb); i++) {
+		if (branch_id(sb, i) == id)
+			return i;
+	}
+	/* in the non-ODF code, this should really never happen */
+	printk(KERN_WARNING "unionfs: cannot find branch with id %d\n", id);
+	return -1;
+}
+
+/* File to lower file. */
+static inline struct file *unionfs_lower_file(const struct file *f)
+{
+	BUG_ON(!f);
+	return UNIONFS_F(f)->lower_files[fbstart(f)];
+}
+
+static inline struct file *unionfs_lower_file_idx(const struct file *f,
+						  int index)
+{
+	BUG_ON(!f || index < 0);
+	return UNIONFS_F(f)->lower_files[index];
+}
+
+static inline void unionfs_set_lower_file_idx(struct file *f, int index,
+					      struct file *val)
+{
+	BUG_ON(!f || index < 0);
+	UNIONFS_F(f)->lower_files[index] = val;
+	/* save branch ID (may be redundant?) */
+	UNIONFS_F(f)->saved_branch_ids[index] =
+		branch_id((f)->f_path.dentry->d_sb, index);
+}
+
+static inline void unionfs_set_lower_file(struct file *f, struct file *val)
+{
+	BUG_ON(!f);
+	unionfs_set_lower_file_idx((f), fbstart(f), (val));
+}
+
+/* Inode to lower inode. */
+static inline struct inode *unionfs_lower_inode(const struct inode *i)
+{
+	BUG_ON(!i);
+	return UNIONFS_I(i)->lower_inodes[ibstart(i)];
+}
+
+static inline struct inode *unionfs_lower_inode_idx(const struct inode *i,
+						    int index)
+{
+	BUG_ON(!i || index < 0);
+	return UNIONFS_I(i)->lower_inodes[index];
+}
+
+static inline void unionfs_set_lower_inode_idx(struct inode *i, int index,
+					       struct inode *val)
+{
+	BUG_ON(!i || index < 0);
+	UNIONFS_I(i)->lower_inodes[index] = val;
+}
+
+static inline void unionfs_set_lower_inode(struct inode *i, struct inode *val)
+{
+	BUG_ON(!i);
+	UNIONFS_I(i)->lower_inodes[ibstart(i)] = val;
+}
+
+/* Superblock to lower superblock. */
+static inline struct super_block *unionfs_lower_super(
+					const struct super_block *sb)
+{
+	BUG_ON(!sb);
+	return UNIONFS_SB(sb)->data[sbstart(sb)].sb;
+}
+
+static inline struct super_block *unionfs_lower_super_idx(
+					const struct super_block *sb,
+					int index)
+{
+	BUG_ON(!sb || index < 0);
+	return UNIONFS_SB(sb)->data[index].sb;
+}
+
+static inline void unionfs_set_lower_super_idx(struct super_block *sb,
+					       int index,
+					       struct super_block *val)
+{
+	BUG_ON(!sb || index < 0);
+	UNIONFS_SB(sb)->data[index].sb = val;
+}
+
+static inline void unionfs_set_lower_super(struct super_block *sb,
+					   struct super_block *val)
+{
+	BUG_ON(!sb);
+	UNIONFS_SB(sb)->data[sbstart(sb)].sb = val;
+}
+
+/* Branch count macros. */
+static inline int branch_count(const struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	return atomic_read(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+static inline void set_branch_count(struct super_block *sb, int index, int val)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_set(&UNIONFS_SB(sb)->data[index].open_files, val);
+}
+
+static inline void branchget(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_inc(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+static inline void branchput(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_dec(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+/* Dentry macros */
+static inline void unionfs_set_lower_dentry_idx(struct dentry *dent, int index,
+						struct dentry *val)
+{
+	BUG_ON(!dent || index < 0);
+	UNIONFS_D(dent)->lower_paths[index].dentry = val;
+}
+
+static inline struct dentry *unionfs_lower_dentry_idx(
+				const struct dentry *dent,
+				int index)
+{
+	BUG_ON(!dent || index < 0);
+	return UNIONFS_D(dent)->lower_paths[index].dentry;
+}
+
+static inline struct dentry *unionfs_lower_dentry(const struct dentry *dent)
+{
+	BUG_ON(!dent);
+	return unionfs_lower_dentry_idx(dent, dbstart(dent));
+}
+
+static inline void unionfs_set_lower_mnt_idx(struct dentry *dent, int index,
+					     struct vfsmount *mnt)
+{
+	BUG_ON(!dent || index < 0);
+	UNIONFS_D(dent)->lower_paths[index].mnt = mnt;
+}
+
+static inline struct vfsmount *unionfs_lower_mnt_idx(
+					const struct dentry *dent,
+					int index)
+{
+	BUG_ON(!dent || index < 0);
+	return UNIONFS_D(dent)->lower_paths[index].mnt;
+}
+
+static inline struct vfsmount *unionfs_lower_mnt(const struct dentry *dent)
+{
+	BUG_ON(!dent);
+	return unionfs_lower_mnt_idx(dent, dbstart(dent));
+}
+
+/* Macros for locking a dentry. */
+enum unionfs_dentry_lock_class {
+	UNIONFS_DMUTEX_NORMAL,
+	UNIONFS_DMUTEX_ROOT,
+	UNIONFS_DMUTEX_PARENT,
+	UNIONFS_DMUTEX_CHILD,
+	UNIONFS_DMUTEX_WHITEOUT,
+	UNIONFS_DMUTEX_REVAL_PARENT, /* for file/dentry revalidate */
+	UNIONFS_DMUTEX_REVAL_CHILD,   /* for file/dentry revalidate */
+};
+
+static inline void unionfs_lock_dentry(struct dentry *d,
+				       unsigned int subclass)
+{
+	BUG_ON(!d);
+	mutex_lock_nested(&UNIONFS_D(d)->lock, subclass);
+}
+
+static inline void unionfs_unlock_dentry(struct dentry *d)
+{
+	BUG_ON(!d);
+	mutex_unlock(&UNIONFS_D(d)->lock);
+}
+
+static inline void verify_locked(struct dentry *d)
+{
+	BUG_ON(!d);
+	BUG_ON(!mutex_is_locked(&UNIONFS_D(d)->lock));
+}
+
+/* macros to put lower objects */
+
+/*
+ * iput lower inodes of an unionfs dentry, from bstart to bend.  If
+ * @free_lower is true, then also kfree the memory used to hold the lower
+ * object pointers.
+ */
+static inline void iput_lowers(struct inode *inode,
+			       int bstart, int bend, bool free_lower)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	BUG_ON(!inode);
+	BUG_ON(!UNIONFS_I(inode));
+	BUG_ON(bstart < 0);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			iput(lower_inode);
+			lockdep_on();
+		}
+	}
+
+	if (free_lower) {
+		kfree(UNIONFS_I(inode)->lower_inodes);
+		UNIONFS_I(inode)->lower_inodes = NULL;
+	}
+}
+
+/* iput all lower inodes, and reset start/end branch indices to -1 */
+static inline void iput_lowers_all(struct inode *inode, bool free_lower)
+{
+	int bstart, bend;
+
+	BUG_ON(!inode);
+	BUG_ON(!UNIONFS_I(inode));
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	BUG_ON(bstart < 0);
+
+	iput_lowers(inode, bstart, bend, free_lower);
+	ibstart(inode) = ibend(inode) = -1;
+}
+
+/*
+ * dput/mntput all lower dentries and vfsmounts of an unionfs dentry, from
+ * bstart to bend.  If @free_lower is true, then also kfree the memory used
+ * to hold the lower object pointers.
+ *
+ * XXX: implement using path_put VFS macros
+ */
+static inline void path_put_lowers(struct dentry *dentry,
+				   int bstart, int bend, bool free_lower)
+{
+	struct dentry *lower_dentry;
+	struct vfsmount *lower_mnt;
+	int bindex;
+
+	BUG_ON(!dentry);
+	BUG_ON(!UNIONFS_D(dentry));
+	BUG_ON(bstart < 0);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (lower_dentry) {
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+			dput(lower_dentry);
+		}
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+		if (lower_mnt) {
+			unionfs_set_lower_mnt_idx(dentry, bindex, NULL);
+			mntput(lower_mnt);
+		}
+	}
+
+	if (free_lower) {
+		kfree(UNIONFS_D(dentry)->lower_paths);
+		UNIONFS_D(dentry)->lower_paths = NULL;
+	}
+}
+
+/*
+ * dput/mntput all lower dentries and vfsmounts, and reset start/end branch
+ * indices to -1.
+ */
+static inline void path_put_lowers_all(struct dentry *dentry, bool free_lower)
+{
+	int bstart, bend;
+
+	BUG_ON(!dentry);
+	BUG_ON(!UNIONFS_D(dentry));
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart < 0);
+
+	path_put_lowers(dentry, bstart, bend, free_lower);
+	dbstart(dentry) = dbend(dentry) = -1;
+}
+
+#endif	/* not _FANOUT_H */
diff --git a/fs/unionfs/file.c b/fs/unionfs/file.c
new file mode 100644
index 0000000..965d071
--- /dev/null
+++ b/fs/unionfs/file.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+static ssize_t unionfs_read(struct file *file, char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	int err;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = unionfs_file_revalidate(file, false);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_read(lower_file, buf, count, ppos);
+	/* update our inode atime upon a successful lower read */
+	if (err >= 0) {
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_write(struct file *file, const char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	int err = 0;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	if (dentry != dentry->d_parent)
+		unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+	err = unionfs_file_revalidate_locked(file, true);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_write(lower_file, buf, count, ppos);
+	/* update our inode times+sizes upon a successful lower write */
+	if (err >= 0) {
+		fsstack_copy_inode_size(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		fsstack_copy_attr_times(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		UNIONFS_F(file)->wrote_to_file = true; /* for delayed copyup */
+		unionfs_check_file(file);
+	}
+
+out:
+	if (dentry != dentry->d_parent)
+		unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_file_readdir(struct file *file, void *dirent,
+				filldir_t filldir)
+{
+	return -ENOTDIR;
+}
+
+static int unionfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err = 0;
+	bool willwrite;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct vm_operations_struct *saved_vm_ops = NULL;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/* This might be deferred to mmap's writepage */
+	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);
+	err = unionfs_file_revalidate(file, willwrite);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	/*
+	 * File systems which do not implement ->writepage may use
+	 * generic_file_readonly_mmap as their ->mmap op.  If you call
+	 * generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
+	 * But we cannot call the lower ->mmap op, so we can't tell that
+	 * writeable mappings won't work.  Therefore, our only choice is to
+	 * check if the lower file system supports the ->writepage, and if
+	 * not, return EINVAL (the same error that
+	 * generic_file_readonly_mmap returns in that case).
+	 */
+	lower_file = unionfs_lower_file(file);
+	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
+		err = -EINVAL;
+		printk(KERN_ERR "unionfs: branch %d file system does not "
+		       "support writeable mmap\n", fbstart(file));
+		goto out;
+	}
+
+	/*
+	 * find and save lower vm_ops.
+	 *
+	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
+	 */
+	if (!UNIONFS_F(file)->lower_vm_ops) {
+		err = lower_file->f_op->mmap(lower_file, vma);
+		if (err) {
+			printk(KERN_ERR "unionfs: lower mmap failed %d\n", err);
+			goto out;
+		}
+		saved_vm_ops = vma->vm_ops;
+		err = do_munmap(current->mm, vma->vm_start,
+				vma->vm_end - vma->vm_start);
+		if (err) {
+			printk(KERN_ERR "unionfs: do_munmap failed %d\n", err);
+			goto out;
+		}
+	}
+
+	file->f_mapping->a_ops = &unionfs_dummy_aops;
+	err = generic_file_mmap(file, vma);
+	file->f_mapping->a_ops = &unionfs_aops;
+	if (err) {
+		printk(KERN_ERR "unionfs: generic_file_mmap failed %d\n", err);
+		goto out;
+	}
+	vma->vm_ops = &unionfs_vm_ops;
+	if (!UNIONFS_F(file)->lower_vm_ops)
+		UNIONFS_F(file)->lower_vm_ops = saved_vm_ops;
+
+out:
+	if (!err) {
+		/* copyup could cause parent dir times to change */
+		unionfs_copy_attr_times(dentry->d_parent->d_inode);
+		unionfs_check_file(file);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+int unionfs_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	int bindex, bstart, bend;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct inode *lower_inode, *inode;
+	int err = -EINVAL;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = unionfs_file_revalidate(file, true);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	if (bstart < 0 || bend < 0)
+		goto out;
+
+	inode = dentry->d_inode;
+	if (unlikely(!inode)) {
+		printk(KERN_ERR
+		       "unionfs: null lower inode in unionfs_fsync\n");
+		goto out;
+	}
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode || !lower_inode->i_fop->fsync)
+			continue;
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		mutex_lock(&lower_inode->i_mutex);
+		err = lower_inode->i_fop->fsync(lower_file,
+						lower_dentry,
+						datasync);
+		if (!err && bindex == bstart)
+			fsstack_copy_attr_times(inode, lower_inode);
+		mutex_unlock(&lower_inode->i_mutex);
+		if (err)
+			goto out;
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+int unionfs_fasync(int fd, struct file *file, int flag)
+{
+	int bindex, bstart, bend;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *lower_inode, *inode;
+	int err = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = unionfs_file_revalidate(file, true);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	if (bstart < 0 || bend < 0)
+		goto out;
+
+	inode = dentry->d_inode;
+	if (unlikely(!inode)) {
+		printk(KERN_ERR
+		       "unionfs: null lower inode in unionfs_fasync\n");
+		goto out;
+	}
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode || !lower_inode->i_fop->fasync)
+			continue;
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		mutex_lock(&lower_inode->i_mutex);
+		err = lower_inode->i_fop->fasync(fd, lower_file, flag);
+		if (!err && bindex == bstart)
+			fsstack_copy_attr_times(inode, lower_inode);
+		mutex_unlock(&lower_inode->i_mutex);
+		if (err)
+			goto out;
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_splice_read(struct file *file, loff_t *ppos,
+				   struct pipe_inode_info *pipe, size_t len,
+				   unsigned int flags)
+{
+	ssize_t err;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = unionfs_file_revalidate(file, false);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_splice_to(lower_file, ppos, pipe, len, flags);
+	/* update our inode atime upon a successful lower splice-read */
+	if (err >= 0) {
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_splice_write(struct pipe_inode_info *pipe,
+				    struct file *file, loff_t *ppos,
+				    size_t len, unsigned int flags)
+{
+	ssize_t err = 0;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	err = unionfs_file_revalidate(file, true);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_splice_from(pipe, lower_file, ppos, len, flags);
+	/* update our inode times+sizes upon a successful lower write */
+	if (err >= 0) {
+		fsstack_copy_inode_size(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		fsstack_copy_attr_times(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+struct file_operations unionfs_main_fops = {
+	.llseek		= generic_file_llseek,
+	.read		= unionfs_read,
+	.write		= unionfs_write,
+	.readdir	= unionfs_file_readdir,
+	.unlocked_ioctl	= unionfs_ioctl,
+	.mmap		= unionfs_mmap,
+	.open		= unionfs_open,
+	.flush		= unionfs_flush,
+	.release	= unionfs_file_release,
+	.fsync		= unionfs_fsync,
+	.fasync		= unionfs_fasync,
+	.splice_read	= unionfs_splice_read,
+	.splice_write	= unionfs_splice_write,
+};
diff --git a/fs/unionfs/inode.c b/fs/unionfs/inode.c
new file mode 100644
index 0000000..0bd9fab
--- /dev/null
+++ b/fs/unionfs/inode.c
@@ -0,0 +1,984 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Find a writeable branch to create new object in.  Checks all writeble
+ * branches of the parent inode, from istart to iend order; if none are
+ * suitable, also tries branch 0 (which may require a copyup).
+ *
+ * Return a lower_dentry we can use to create object in, or ERR_PTR.
+ */
+static struct dentry *find_writeable_branch(struct inode *parent,
+					    struct dentry *dentry)
+{
+	int err = -EINVAL;
+	int bindex, istart, iend;
+	struct dentry *lower_dentry = NULL;
+
+	istart = ibstart(parent);
+	iend = ibend(parent);
+	if (istart < 0)
+		goto out;
+
+begin:
+	for (bindex = istart; bindex <= iend; bindex++) {
+		/* skip non-writeable branches */
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (err) {
+			err = -EROFS;
+			continue;
+		}
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		/*
+		 * check for whiteouts in writeable branch, and remove them
+		 * if necessary.
+		 */
+		err = check_unlink_whiteout(dentry, lower_dentry, bindex);
+		if (err > 0)	/* ignore if whiteout found and removed */
+			err = 0;
+		if (err)
+			continue;
+		/* if get here, we can write to the branch */
+		break;
+	}
+	/*
+	 * If istart wasn't already branch 0, and we got any error, then try
+	 * branch 0 (which may require copyup)
+	 */
+	if (err && istart > 0) {
+		istart = iend = 0;
+		goto begin;
+	}
+
+	/*
+	 * If we tried even branch 0, and still got an error, abort.  But if
+	 * the error was an EROFS, then we should try to copyup.
+	 */
+	if (err && err != -EROFS)
+		goto out;
+
+	/*
+	 * If we get here, then check if copyup needed.  If lower_dentry is
+	 * NULL, create the entire dentry directory structure in branch 0.
+	 */
+	if (!lower_dentry) {
+		bindex = 0;
+		lower_dentry = create_parents(parent, dentry,
+					      dentry->d_name.name, bindex);
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out;
+		}
+	}
+	err = 0;		/* all's well */
+out:
+	if (err)
+		return ERR_PTR(err);
+	return lower_dentry;
+}
+
+static int unionfs_create(struct inode *parent, struct dentry *dentry,
+			  int mode, struct nameidata *nd)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	int valid = 0;
+	struct nameidata lower_nd;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, nd, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;	/* same as what real_lookup does */
+		goto out;
+	}
+
+	valid = __unionfs_d_revalidate_one_locked(dentry, nd, false);
+	/*
+	 * It's only a bug if this dentry was not negative and couldn't be
+	 * revalidated (shouldn't happen).
+	 */
+	BUG_ON(!valid && dentry->d_inode);
+
+	lower_dentry = find_writeable_branch(parent, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out;
+	}
+
+	err = init_lower_nd(&lower_nd, LOOKUP_CREATE);
+	if (unlikely(err < 0))
+		goto out;
+	err = vfs_create(lower_parent_dentry->d_inode, lower_dentry, mode,
+			 &lower_nd);
+	release_lower_nd(&lower_nd, err);
+
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, parent->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(parent);
+			fsstack_copy_inode_size(parent,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			parent->i_nlink = unionfs_get_nlinks(parent);
+		}
+	}
+
+	unlock_dir(lower_parent_dentry);
+
+out:
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(parent);
+		unionfs_check_dentry(dentry);
+		unionfs_check_nd(nd);
+	}
+	unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * unionfs_lookup is the only special function which takes a dentry, yet we
+ * do NOT want to call __unionfs_d_revalidate_chain because by definition,
+ * we don't have a valid dentry here yet.
+ */
+static struct dentry *unionfs_lookup(struct inode *parent,
+				     struct dentry *dentry,
+				     struct nameidata *nd)
+{
+	struct path path_save = {NULL, NULL};
+	struct dentry *ret;
+	int err = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	if (dentry != dentry->d_parent)
+		unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_ROOT);
+
+	/* save the dentry & vfsmnt from namei */
+	if (nd) {
+		path_save.dentry = nd->path.dentry;
+		path_save.mnt = nd->path.mnt;
+	}
+
+	/*
+	 * unionfs_lookup_backend returns a locked dentry upon success,
+	 * so we'll have to unlock it below.
+	 */
+
+	/* allocate dentry private data.  We free it in ->d_release */
+	err = new_dentry_private_data(dentry, UNIONFS_DMUTEX_CHILD);
+	if (unlikely(err)) {
+		ret = ERR_PTR(err);
+		goto out;
+	}
+	ret = unionfs_lookup_full(dentry, nd, INTERPOSE_LOOKUP);
+
+	/* restore the dentry & vfsmnt in namei */
+	if (nd) {
+		nd->path.dentry = path_save.dentry;
+		nd->path.mnt = path_save.mnt;
+	}
+	if (!IS_ERR(ret)) {
+		if (ret)
+			dentry = ret;
+		/* lookup_full can return multiple positive dentries */
+		if (dentry->d_inode && !S_ISDIR(dentry->d_inode->i_mode)) {
+			BUG_ON(dbstart(dentry) < 0);
+			unionfs_postcopyup_release(dentry);
+		}
+		unionfs_copy_attr_times(dentry->d_inode);
+		/* parent times may have changed */
+		unionfs_copy_attr_times(dentry->d_parent->d_inode);
+	}
+
+	unionfs_check_inode(parent);
+	if (!IS_ERR(ret)) {
+		unionfs_check_dentry(dentry);
+		unionfs_check_nd(nd);
+	}
+	unionfs_unlock_dentry(dentry);
+
+out:
+	if (dentry != dentry->d_parent) {
+		unionfs_check_dentry(dentry->d_parent);
+		unionfs_unlock_dentry(dentry->d_parent);
+	}
+	unionfs_read_unlock(dentry->d_sb);
+
+	return ret;
+}
+
+static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *lower_old_dentry = NULL;
+	struct dentry *lower_new_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+	char *name = NULL;
+
+	unionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_double_lock_dentry(new_dentry, old_dentry);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(old_dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (unlikely(new_dentry->d_inode &&
+		     !__unionfs_d_revalidate_chain(new_dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
+
+	/* check for a whiteout in new dentry branch, and delete it */
+	err = check_unlink_whiteout(new_dentry, lower_new_dentry,
+				    dbstart(new_dentry));
+	if (err > 0) {	       /* whiteout found and removed successfully */
+		lower_dir_dentry = dget_parent(lower_new_dentry);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+		dput(lower_dir_dentry);
+		dir->i_nlink = unionfs_get_nlinks(dir);
+		err = 0;
+	}
+	if (err)
+		goto out;
+
+	/* check if parent hierachy is needed, then link in same branch */
+	if (dbstart(old_dentry) != dbstart(new_dentry)) {
+		lower_new_dentry = create_parents(dir, new_dentry,
+						  new_dentry->d_name.name,
+						  dbstart(old_dentry));
+		err = PTR_ERR(lower_new_dentry);
+		if (IS_COPYUP_ERR(err))
+			goto docopyup;
+		if (!lower_new_dentry || IS_ERR(lower_new_dentry))
+			goto out;
+	}
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
+	lower_old_dentry = unionfs_lower_dentry(old_dentry);
+
+	BUG_ON(dbstart(old_dentry) != dbstart(new_dentry));
+	lower_dir_dentry = lock_parent(lower_new_dentry);
+	err = is_robranch(old_dentry);
+	if (!err) {
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		err = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
+			       lower_new_dentry);
+		lockdep_on();
+	}
+	unlock_dir(lower_dir_dentry);
+
+docopyup:
+	if (IS_COPYUP_ERR(err)) {
+		int old_bstart = dbstart(old_dentry);
+		int bindex;
+
+		for (bindex = old_bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_dentry(old_dentry->d_parent->d_inode,
+					    old_dentry, old_bstart,
+					    bindex, old_dentry->d_name.name,
+					    old_dentry->d_name.len, NULL,
+					    i_size_read(old_dentry->d_inode));
+			if (err)
+				continue;
+			lower_new_dentry =
+				create_parents(dir, new_dentry,
+					       new_dentry->d_name.name,
+					       bindex);
+			lower_old_dentry = unionfs_lower_dentry(old_dentry);
+			lower_dir_dentry = lock_parent(lower_new_dentry);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			/* do vfs_link */
+			err = vfs_link(lower_old_dentry,
+				       lower_dir_dentry->d_inode,
+				       lower_new_dentry);
+			lockdep_on();
+			unlock_dir(lower_dir_dentry);
+			goto check_link;
+		}
+		goto out;
+	}
+
+check_link:
+	if (err || !lower_new_dentry->d_inode)
+		goto out;
+
+	/* Its a hard link, so use the same inode */
+	new_dentry->d_inode = igrab(old_dentry->d_inode);
+	d_add(new_dentry, new_dentry->d_inode);
+	unionfs_copy_attr_all(dir, lower_new_dentry->d_parent->d_inode);
+	fsstack_copy_inode_size(dir, lower_new_dentry->d_parent->d_inode);
+
+	/* propagate number of hard-links */
+	old_dentry->d_inode->i_nlink = unionfs_get_nlinks(old_dentry->d_inode);
+	/* new dentry's ctime may have changed due to hard-link counts */
+	unionfs_copy_attr_times(new_dentry->d_inode);
+
+out:
+	if (!new_dentry->d_inode)
+		d_drop(new_dentry);
+
+	kfree(name);
+	if (!err)
+		unionfs_postcopyup_setmnt(new_dentry);
+
+	unionfs_check_inode(dir);
+	unionfs_check_dentry(new_dentry);
+	unionfs_check_dentry(old_dentry);
+
+	unionfs_unlock_dentry(new_dentry);
+	unionfs_unlock_dentry(old_dentry);
+	unionfs_read_unlock(old_dentry->d_sb);
+
+	return err;
+}
+
+static int unionfs_symlink(struct inode *parent, struct dentry *dentry,
+			   const char *symname)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	char *name = NULL;
+	int valid = 0;
+	umode_t mode;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (unlikely(dentry->d_inode &&
+		     !__unionfs_d_revalidate_one_locked(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	/*
+	 * It's only a bug if this dentry was not negative and couldn't be
+	 * revalidated (shouldn't happen).
+	 */
+	BUG_ON(!valid && dentry->d_inode);
+
+	lower_dentry = find_writeable_branch(parent, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out;
+	}
+
+	mode = S_IALLUGO;
+	err = vfs_symlink(lower_parent_dentry->d_inode, lower_dentry, symname);
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, parent->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(parent);
+			fsstack_copy_inode_size(parent,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			parent->i_nlink = unionfs_get_nlinks(parent);
+		}
+	}
+
+	unlock_dir(lower_parent_dentry);
+
+out:
+	dput(wh_dentry);
+	kfree(name);
+
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(parent);
+		unionfs_check_dentry(dentry);
+	}
+	unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;	/* same as what real_lookup does */
+		goto out;
+	}
+	if (unlikely(dentry->d_inode &&
+		     !__unionfs_d_revalidate_one_locked(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	bstart = dbstart(dentry);
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	/* check for a whiteout in new dentry branch, and delete it */
+	err = check_unlink_whiteout(dentry, lower_dentry, bstart);
+	if (err > 0)	       /* whiteout found and removed successfully */
+		err = 0;
+	if (err) {
+		/* exit if the error returned was NOT -EROFS */
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+		bstart--;
+	}
+
+	/* check if copyup's needed, and mkdir */
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		int i;
+		int bend = dbend(dentry);
+
+		if (is_robranch_super(dentry->d_sb, bindex))
+			continue;
+
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			lower_dentry = create_parents(parent, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				printk(KERN_ERR "unionfs: lower dentry "
+				       " NULL for bindex = %d\n", bindex);
+				continue;
+			}
+		}
+
+		lower_parent_dentry = lock_parent(lower_dentry);
+
+		if (IS_ERR(lower_parent_dentry)) {
+			err = PTR_ERR(lower_parent_dentry);
+			goto out;
+		}
+
+		err = vfs_mkdir(lower_parent_dentry->d_inode, lower_dentry,
+				mode);
+
+		unlock_dir(lower_parent_dentry);
+
+		/* did the mkdir succeed? */
+		if (err)
+			break;
+
+		for (i = bindex + 1; i < bend; i++) {
+			if (unionfs_lower_dentry_idx(dentry, i)) {
+				dput(unionfs_lower_dentry_idx(dentry, i));
+				unionfs_set_lower_dentry_idx(dentry, i, NULL);
+			}
+		}
+		dbend(dentry) = bindex;
+
+		/*
+		 * Only INTERPOSE_LOOKUP can return a value other than 0 on
+		 * err.
+		 */
+		err = PTR_ERR(unionfs_interpose(dentry, parent->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(parent);
+			fsstack_copy_inode_size(parent,
+						lower_parent_dentry->d_inode);
+
+			/* update number of links on parent directory */
+			parent->i_nlink = unionfs_get_nlinks(parent);
+		}
+
+		err = make_dir_opaque(dentry, dbstart(dentry));
+		if (err) {
+			printk(KERN_ERR "unionfs: mkdir: error creating "
+			       ".wh.__dir_opaque: %d\n", err);
+			goto out;
+		}
+
+		/* we are done! */
+		break;
+	}
+
+out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	kfree(name);
+
+	if (!err) {
+		unionfs_copy_attr_times(dentry->d_inode);
+		unionfs_postcopyup_setmnt(dentry);
+	}
+	unionfs_check_inode(parent);
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+static int unionfs_mknod(struct inode *parent, struct dentry *dentry, int mode,
+			 dev_t dev)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	char *name = NULL;
+	int valid = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (unlikely(dentry->d_inode &&
+		     !__unionfs_d_revalidate_one_locked(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	/*
+	 * It's only a bug if this dentry was not negative and couldn't be
+	 * revalidated (shouldn't happen).
+	 */
+	BUG_ON(!valid && dentry->d_inode);
+
+	lower_dentry = find_writeable_branch(parent, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out;
+	}
+
+	err = vfs_mknod(lower_parent_dentry->d_inode, lower_dentry, mode, dev);
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, parent->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(parent);
+			fsstack_copy_inode_size(parent,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			parent->i_nlink = unionfs_get_nlinks(parent);
+		}
+	}
+
+	unlock_dir(lower_parent_dentry);
+
+out:
+	dput(wh_dentry);
+	kfree(name);
+
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(parent);
+		unionfs_check_dentry(dentry);
+	}
+	unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_readlink(struct dentry *dentry, char __user *buf,
+			    int bufsiz)
+{
+	int err;
+	struct dentry *lower_dentry;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	if (!lower_dentry->d_inode->i_op ||
+	    !lower_dentry->d_inode->i_op->readlink) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+						    buf, bufsiz);
+	if (err > 0)
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_dentry->d_inode);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+/*
+ * unionfs_follow_link takes a dentry, but it is simple.  It only needs to
+ * allocate some memory and then call our ->readlink method.  Our
+ * unionfs_readlink *does* lock our dentry and revalidate the dentry.
+ * Therefore, we do not have to lock our dentry here, to prevent a deadlock;
+ * nor do we need to revalidate it either.  It is safe to not lock our
+ * dentry here, nor revalidate it, because unionfs_follow_link does not do
+ * anything (prior to calling ->readlink) which could become inconsistent
+ * due to branch management.  We also don't need to lock our super because
+ * this function isn't affected by branch-management.
+ */
+static void *unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	char *buf;
+	int len = PAGE_SIZE, err;
+	mm_segment_t old_fs;
+
+	/* This is freed by the put_link method assuming a successful call. */
+	buf = kmalloc(len, GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* read the symlink, and then we will follow it */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	set_fs(old_fs);
+	if (err < 0) {
+		kfree(buf);
+		buf = NULL;
+		goto out;
+	}
+	buf[err] = 0;
+	nd_set_link(nd, buf);
+	err = 0;
+
+out:
+	if (!err) {
+		unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+		unionfs_check_dentry(dentry);
+		unionfs_unlock_dentry(dentry);
+	}
+	unionfs_check_nd(nd);
+	return ERR_PTR(err);
+}
+
+/* FIXME: We may not have to lock here */
+static void unionfs_put_link(struct dentry *dentry, struct nameidata *nd,
+			     void *cookie)
+{
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, nd, false)))
+		printk(KERN_ERR
+		       "unionfs: put_link failed to revalidate dentry\n");
+
+	unionfs_check_dentry(dentry);
+	unionfs_check_nd(nd);
+	kfree(nd_get_link(nd));
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+}
+
+/*
+ * Don't grab the superblock read-lock in unionfs_permission, which prevents
+ * a deadlock with the branch-management "add branch" code (which grabbed
+ * the write lock).  It is safe to not grab the read lock here, because even
+ * with branch management taking place, there is no chance that
+ * unionfs_permission, or anything it calls, will use stale branch
+ * information.
+ */
+static int unionfs_permission(struct inode *inode, int mask)
+{
+	struct inode *lower_inode = NULL;
+	int err = 0;
+	int bindex, bstart, bend;
+	const int is_file = !S_ISDIR(inode->i_mode);
+	const int write_mask = (mask & MAY_WRITE) && !(mask & MAY_READ);
+
+	if (!UNIONFS_I(inode)->lower_inodes) {
+		if (is_file)	/* dirs can be unlinked but chdir'ed to */
+			err = -ESTALE;	/* force revalidate */
+		goto out;
+	}
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (unlikely(bstart < 0 || bend < 0)) {
+		/*
+		 * With branch-management, we can get a stale inode here.
+		 * If so, we return ESTALE back to link_path_walk, which
+		 * would discard the dcache entry and re-lookup the
+		 * dentry+inode.  This should be equivalent to issuing
+		 * __unionfs_d_revalidate_chain on nd.dentry here.
+		 */
+		if (is_file)	/* dirs can be unlinked but chdir'ed to */
+			err = -ESTALE;	/* force revalidate */
+		goto out;
+	}
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		/*
+		 * check the condition for D-F-D underlying files/directories,
+		 * we don't have to check for files, if we are checking for
+		 * directories.
+		 */
+		if (!is_file && !S_ISDIR(lower_inode->i_mode))
+			continue;
+
+		/*
+		 * We check basic permissions, but we ignore any conditions
+		 * such as readonly file systems or branches marked as
+		 * readonly, because those conditions should lead to a
+		 * copyup taking place later on.
+		 */
+		err = inode_permission(lower_inode, mask);
+		if (err && bindex > 0) {
+			umode_t mode = lower_inode->i_mode;
+			if (is_robranch_super(inode->i_sb, bindex) &&
+			    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+				err = 0;
+			if (IS_COPYUP_ERR(err))
+				err = 0;
+		}
+
+		/*
+		 * The permissions are an intersection of the overall directory
+		 * permissions, so we fail if one fails.
+		 */
+		if (err)
+			goto out;
+
+		/* only the leftmost file matters. */
+		if (is_file || write_mask) {
+			if (is_file && write_mask) {
+				err = get_write_access(lower_inode);
+				if (!err)
+					put_write_access(lower_inode);
+			}
+			break;
+		}
+	}
+	/* sync times which may have changed (asynchronously) below */
+	unionfs_copy_attr_times(inode);
+
+out:
+	unionfs_check_inode(inode);
+	return err;
+}
+
+static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int err = 0;
+	struct dentry *lower_dentry;
+	struct inode *inode;
+	struct inode *lower_inode;
+	int bstart, bend, bindex;
+	loff_t size;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	inode = dentry->d_inode;
+
+	/*
+	 * mode change is for clearing setuid/setgid. Allow lower filesystem
+	 * to reinterpret it in its own way.
+	 */
+	if (ia->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))
+		ia->ia_valid &= ~ATTR_MODE;
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+	BUG_ON(!lower_dentry);	/* should never happen after above revalidate */
+
+	/* copyup if the file is on a read only branch */
+	if (is_robranch_super(dentry->d_sb, bstart)
+	    || IS_RDONLY(lower_dentry->d_inode)) {
+		/* check if we have a branch to copy up to */
+		if (bstart <= 0) {
+			err = -EACCES;
+			goto out;
+		}
+
+		if (ia->ia_valid & ATTR_SIZE)
+			size = ia->ia_size;
+		else
+			size = i_size_read(inode);
+		/* copyup to next available branch */
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_dentry(dentry->d_parent->d_inode,
+					    dentry, bstart, bindex,
+					    dentry->d_name.name,
+					    dentry->d_name.len,
+					    NULL, size);
+			if (!err)
+				break;
+		}
+		if (err)
+			goto out;
+		/* get updated lower_dentry after copyup */
+		lower_dentry = unionfs_lower_dentry(dentry);
+	}
+
+	lower_inode = unionfs_lower_inode(inode);
+
+	/*
+	 * If shrinking, first truncate upper level to cancel writing dirty
+	 * pages beyond the new eof; and also if its' maxbytes is more
+	 * limiting (fail with -EFBIG before making any change to the lower
+	 * level).  There is no need to vmtruncate the upper level
+	 * afterwards in the other cases: we fsstack_copy_inode_size from
+	 * the lower level.
+	 */
+	if (ia->ia_valid & ATTR_SIZE) {
+		size = i_size_read(inode);
+		if (ia->ia_size < size || (ia->ia_size > size &&
+		    inode->i_sb->s_maxbytes < lower_inode->i_sb->s_maxbytes)) {
+			err = vmtruncate(inode, ia->ia_size);
+			if (err)
+				goto out;
+		}
+	}
+
+	/* notify the (possibly copied-up) lower inode */
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	err = notify_change(lower_dentry, ia);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	if (err)
+		goto out;
+
+	/* get attributes from the first lower inode */
+	unionfs_copy_attr_all(inode, lower_inode);
+	/*
+	 * unionfs_copy_attr_all will copy the lower times to our inode if
+	 * the lower ones are newer (useful for cache coherency).  However,
+	 * ->setattr is the only place in which we may have to copy the
+	 * lower inode times absolutely, to support utimes(2).
+	 */
+	if (ia->ia_valid & ATTR_MTIME_SET)
+		inode->i_mtime = lower_inode->i_mtime;
+	if (ia->ia_valid & ATTR_CTIME)
+		inode->i_ctime = lower_inode->i_ctime;
+	if (ia->ia_valid & ATTR_ATIME_SET)
+		inode->i_atime = lower_inode->i_atime;
+	fsstack_copy_inode_size(inode, lower_inode);
+
+out:
+	if (!err)
+		unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+struct inode_operations unionfs_symlink_iops = {
+	.readlink	= unionfs_readlink,
+	.permission	= unionfs_permission,
+	.follow_link	= unionfs_follow_link,
+	.setattr	= unionfs_setattr,
+	.put_link	= unionfs_put_link,
+};
+
+struct inode_operations unionfs_dir_iops = {
+	.create		= unionfs_create,
+	.lookup		= unionfs_lookup,
+	.link		= unionfs_link,
+	.unlink		= unionfs_unlink,
+	.symlink	= unionfs_symlink,
+	.mkdir		= unionfs_mkdir,
+	.rmdir		= unionfs_rmdir,
+	.mknod		= unionfs_mknod,
+	.rename		= unionfs_rename,
+	.permission	= unionfs_permission,
+	.setattr	= unionfs_setattr,
+#ifdef CONFIG_UNION_FS_XATTR
+	.setxattr	= unionfs_setxattr,
+	.getxattr	= unionfs_getxattr,
+	.removexattr	= unionfs_removexattr,
+	.listxattr	= unionfs_listxattr,
+#endif /* CONFIG_UNION_FS_XATTR */
+};
+
+struct inode_operations unionfs_main_iops = {
+	.permission	= unionfs_permission,
+	.setattr	= unionfs_setattr,
+#ifdef CONFIG_UNION_FS_XATTR
+	.setxattr	= unionfs_setxattr,
+	.getxattr	= unionfs_getxattr,
+	.removexattr	= unionfs_removexattr,
+	.listxattr	= unionfs_listxattr,
+#endif /* CONFIG_UNION_FS_XATTR */
+};
diff --git a/fs/unionfs/lookup.c b/fs/unionfs/lookup.c
new file mode 100644
index 0000000..0a9602a
--- /dev/null
+++ b/fs/unionfs/lookup.c
@@ -0,0 +1,570 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Lookup one path component @name relative to a <base,mnt> path pair.
+ * Behaves nearly the same as lookup_one_len (i.e., return negative dentry
+ * on ENOENT), but uses the @mnt passed, so it can cross bind mounts and
+ * other lower mounts properly.  If @new_mnt is non-null, will fill in the
+ * new mnt there.  Caller is responsible to dput/mntput/path_put returned
+ * @dentry and @new_mnt.
+ */
+struct dentry *__lookup_one(struct dentry *base, struct vfsmount *mnt,
+			    const char *name, struct vfsmount **new_mnt)
+{
+	struct dentry *dentry = NULL;
+	struct nameidata lower_nd;
+	int err;
+
+	/* we use flags=0 to get basic lookup */
+	err = vfs_path_lookup(base, mnt, name, 0, &lower_nd);
+
+	switch (err) {
+	case 0: /* no error */
+		dentry = lower_nd.path.dentry;
+		if (new_mnt)
+			*new_mnt = lower_nd.path.mnt; /* rc already inc'ed */
+		break;
+	case -ENOENT:
+		 /*
+		  * We don't consider ENOENT an error, and we want to return
+		  * a negative dentry (ala lookup_one_len).  As we know
+		  * there was no inode for this name before (-ENOENT), then
+		  * it's safe to call lookup_one_len (which doesn't take a
+		  * vfsmount).
+		  */
+		dentry = lookup_one_len(name, base, strlen(name));
+		if (new_mnt)
+			*new_mnt = mntget(lower_nd.path.mnt);
+		break;
+	default: /* all other real errors */
+		dentry = ERR_PTR(err);
+		break;
+	}
+
+	return dentry;
+}
+
+/*
+ * This is a utility function that fills in a unionfs dentry.
+ * Caller must lock this dentry with unionfs_lock_dentry.
+ *
+ * Returns: 0 (ok), or -ERRNO if an error occurred.
+ * XXX: get rid of _partial_lookup and make callers call _lookup_full directly
+ */
+int unionfs_partial_lookup(struct dentry *dentry)
+{
+	struct dentry *tmp;
+	struct nameidata nd = { .flags = 0 };
+	int err = -ENOSYS;
+
+	tmp = unionfs_lookup_full(dentry, &nd, INTERPOSE_PARTIAL);
+
+	if (!tmp) {
+		err = 0;
+		goto out;
+	}
+	if (IS_ERR(tmp)) {
+		err = PTR_ERR(tmp);
+		goto out;
+	}
+	/* XXX: need to change the interface */
+	BUG_ON(tmp != dentry);
+out:
+	return err;
+}
+
+/* The dentry cache is just so we have properly sized dentries. */
+static struct kmem_cache *unionfs_dentry_cachep;
+int unionfs_init_dentry_cache(void)
+{
+	unionfs_dentry_cachep =
+		kmem_cache_create("unionfs_dentry",
+				  sizeof(struct unionfs_dentry_info),
+				  0, SLAB_RECLAIM_ACCOUNT, NULL);
+
+	return (unionfs_dentry_cachep ? 0 : -ENOMEM);
+}
+
+void unionfs_destroy_dentry_cache(void)
+{
+	if (unionfs_dentry_cachep)
+		kmem_cache_destroy(unionfs_dentry_cachep);
+}
+
+void free_dentry_private_data(struct dentry *dentry)
+{
+	if (!dentry || !dentry->d_fsdata)
+		return;
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	UNIONFS_D(dentry)->lower_paths = NULL;
+	kmem_cache_free(unionfs_dentry_cachep, dentry->d_fsdata);
+	dentry->d_fsdata = NULL;
+}
+
+static inline int __realloc_dentry_private_data(struct dentry *dentry)
+{
+	struct unionfs_dentry_info *info = UNIONFS_D(dentry);
+	void *p;
+	int size;
+
+	BUG_ON(!info);
+
+	size = sizeof(struct path) * sbmax(dentry->d_sb);
+	p = krealloc(info->lower_paths, size, GFP_ATOMIC);
+	if (unlikely(!p))
+		return -ENOMEM;
+
+	info->lower_paths = p;
+
+	info->bstart = -1;
+	info->bend = -1;
+	info->bopaque = -1;
+	info->bcount = sbmax(dentry->d_sb);
+	atomic_set(&info->generation,
+			atomic_read(&UNIONFS_SB(dentry->d_sb)->generation));
+
+	memset(info->lower_paths, 0, size);
+
+	return 0;
+}
+
+/* UNIONFS_D(dentry)->lock must be locked */
+int realloc_dentry_private_data(struct dentry *dentry)
+{
+	if (!__realloc_dentry_private_data(dentry))
+		return 0;
+
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	free_dentry_private_data(dentry);
+	return -ENOMEM;
+}
+
+/* allocate new dentry private data */
+int new_dentry_private_data(struct dentry *dentry, int subclass)
+{
+	struct unionfs_dentry_info *info = UNIONFS_D(dentry);
+
+	BUG_ON(info);
+
+	info = kmem_cache_alloc(unionfs_dentry_cachep, GFP_ATOMIC);
+	if (unlikely(!info))
+		return -ENOMEM;
+
+	mutex_init(&info->lock);
+	mutex_lock_nested(&info->lock, subclass);
+
+	info->lower_paths = NULL;
+
+	dentry->d_fsdata = info;
+
+	if (!__realloc_dentry_private_data(dentry))
+		return 0;
+
+	mutex_unlock(&info->lock);
+	free_dentry_private_data(dentry);
+	return -ENOMEM;
+}
+
+/*
+ * scan through the lower dentry objects, and set bstart to reflect the
+ * starting branch
+ */
+void update_bstart(struct dentry *dentry)
+{
+	int bindex;
+	int bstart = dbstart(dentry);
+	int bend = dbend(dentry);
+	struct dentry *lower_dentry;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (lower_dentry->d_inode) {
+			dbstart(dentry) = bindex;
+			break;
+		}
+		dput(lower_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+	}
+}
+
+
+/*
+ * Initialize a nameidata structure (the intent part) we can pass to a lower
+ * file system.  Returns 0 on success or -error (only -ENOMEM possible).
+ * Inside that nd structure, this function may also return an allocated
+ * struct file (for open intents).  The caller, when done with this nd, must
+ * kfree the intent file (using release_lower_nd).
+ *
+ * XXX: this code, and the callers of this code, should be redone using
+ * vfs_path_lookup() when (1) the nameidata structure is refactored into a
+ * separate intent-structure, and (2) open_namei() is broken into a VFS-only
+ * function and a method that other file systems can call.
+ */
+int init_lower_nd(struct nameidata *nd, unsigned int flags)
+{
+	int err = 0;
+#ifdef ALLOC_LOWER_ND_FILE
+	/*
+	 * XXX: one day we may need to have the lower return an open file
+	 * for us.  It is not needed in 2.6.23-rc1 for nfs2/nfs3, but may
+	 * very well be needed for nfs4.
+	 */
+	struct file *file;
+#endif /* ALLOC_LOWER_ND_FILE */
+
+	memset(nd, 0, sizeof(struct nameidata));
+	if (!flags)
+		return err;
+
+	switch (flags) {
+	case LOOKUP_CREATE:
+		nd->intent.open.flags |= O_CREAT;
+		/* fall through: shared code for create/open cases */
+	case LOOKUP_OPEN:
+		nd->flags = flags;
+		nd->intent.open.flags |= (FMODE_READ | FMODE_WRITE);
+#ifdef ALLOC_LOWER_ND_FILE
+		file = kzalloc(sizeof(struct file), GFP_KERNEL);
+		if (unlikely(!file)) {
+			err = -ENOMEM;
+			break; /* exit switch statement and thus return */
+		}
+		nd->intent.open.file = file;
+#endif /* ALLOC_LOWER_ND_FILE */
+		break;
+	default:
+		/*
+		 * We should never get here, for now.
+		 * We can add new cases here later on.
+		 */
+		pr_debug("unionfs: unknown nameidata flag 0x%x\n", flags);
+		BUG();
+		break;
+	}
+
+	return err;
+}
+
+void release_lower_nd(struct nameidata *nd, int err)
+{
+	if (!nd->intent.open.file)
+		return;
+	else if (!err)
+		release_open_intent(nd);
+#ifdef ALLOC_LOWER_ND_FILE
+	kfree(nd->intent.open.file);
+#endif /* ALLOC_LOWER_ND_FILE */
+}
+
+/*
+ * Main (and complex) driver function for Unionfs's lookup
+ *
+ * Returns: NULL (ok), ERR_PTR if an error occurred, or a non-null non-error
+ * PTR if d_splice returned a different dentry.
+ *
+ * If lookupmode is INTERPOSE_PARTIAL/REVAL/REVAL_NEG, the passed dentry's
+ * inode info must be locked.  If lookupmode is INTERPOSE_LOOKUP (i.e., a
+ * newly looked-up dentry), then unionfs_lookup_backend will return a locked
+ * dentry's info, which the caller must unlock.
+ */
+struct dentry *unionfs_lookup_full(struct dentry *dentry,
+				   struct nameidata *nd_unused, int lookupmode)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct vfsmount *lower_mnt;
+	struct vfsmount *lower_dir_mnt;
+	struct dentry *wh_lower_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *parent_dentry = NULL;
+	struct dentry *d_interposed = NULL;
+	int bindex, bstart, bend, bopaque;
+	int opaque, num_positive = 0;
+	const char *name;
+	int namelen;
+	int pos_start, pos_end;
+
+	/*
+	 * We should already have a lock on this dentry in the case of a
+	 * partial lookup, or a revalidation.  Otherwise it is returned from
+	 * new_dentry_private_data already locked.
+	 */
+	verify_locked(dentry);
+
+	/* must initialize dentry operations */
+	dentry->d_op = &unionfs_dops;
+
+	/* We never partial lookup the root directory. */
+	if (IS_ROOT(dentry))
+		goto out;
+	parent_dentry = dget_parent(dentry);
+
+	name = dentry->d_name.name;
+	namelen = dentry->d_name.len;
+
+	/* No dentries should get created for possible whiteout names. */
+	if (!is_validname(name)) {
+		err = -EPERM;
+		goto out_free;
+	}
+
+	/* Now start the actual lookup procedure. */
+	bstart = dbstart(parent_dentry);
+	bend = dbend(parent_dentry);
+	bopaque = dbopaque(parent_dentry);
+	BUG_ON(bstart < 0);
+
+	/* adjust bend to bopaque if needed */
+	if ((bopaque >= 0) && (bopaque < bend))
+		bend = bopaque;
+
+	/* lookup all possible dentries */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+
+		/* skip if we already have a positive lower dentry */
+		if (lower_dentry) {
+			if (dbstart(dentry) < 0)
+				dbstart(dentry) = bindex;
+			if (bindex > dbend(dentry))
+				dbend(dentry) = bindex;
+			if (lower_dentry->d_inode)
+				num_positive++;
+			continue;
+		}
+
+		lower_dir_dentry =
+			unionfs_lower_dentry_idx(parent_dentry, bindex);
+		/* if the lower dentry's parent does not exist, skip this */
+		if (!lower_dir_dentry || !lower_dir_dentry->d_inode)
+			continue;
+
+		/* also skip it if the parent isn't a directory. */
+		if (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))
+			continue; /* XXX: should be BUG_ON */
+
+		/* check for whiteouts: stop lookup if found */
+		wh_lower_dentry = lookup_whiteout(name, lower_dir_dentry);
+		if (IS_ERR(wh_lower_dentry)) {
+			err = PTR_ERR(wh_lower_dentry);
+			goto out_free;
+		}
+		if (wh_lower_dentry->d_inode) {
+			dbend(dentry) = dbopaque(dentry) = bindex;
+			if (dbstart(dentry) < 0)
+				dbstart(dentry) = bindex;
+			dput(wh_lower_dentry);
+			break;
+		}
+		dput(wh_lower_dentry);
+
+		/* Now do regular lookup; lookup @name */
+		lower_dir_mnt = unionfs_lower_mnt_idx(parent_dentry, bindex);
+		lower_mnt = NULL; /* XXX: needed? */
+
+		lower_dentry = __lookup_one(lower_dir_dentry, lower_dir_mnt,
+					    name, &lower_mnt);
+
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out_free;
+		}
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		BUG_ON(!lower_mnt);
+		unionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);
+
+		/* adjust dbstart/end */
+		if (dbstart(dentry) < 0)
+			dbstart(dentry) = bindex;
+		if (bindex > dbend(dentry))
+			dbend(dentry) = bindex;
+		/*
+		 * We always store the lower dentries above, and update
+		 * dbstart/dbend, even if the whole unionfs dentry is
+		 * negative (i.e., no lower inodes).
+		 */
+		if (!lower_dentry->d_inode)
+			continue;
+		num_positive++;
+
+		/*
+		 * check if we just found an opaque directory, if so, stop
+		 * lookups here.
+		 */
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+			continue;
+		opaque = is_opaque_dir(dentry, bindex);
+		if (opaque < 0) {
+			err = opaque;
+			goto out_free;
+		} else if (opaque) {
+			dbend(dentry) = dbopaque(dentry) = bindex;
+			break;
+		}
+		dbend(dentry) = bindex;
+
+		/* update parent directory's atime with the bindex */
+		fsstack_copy_attr_atime(parent_dentry->d_inode,
+					lower_dir_dentry->d_inode);
+	}
+
+	/* sanity checks, then decide if to process a negative dentry */
+	BUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);
+	BUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);
+
+	if (num_positive > 0)
+		goto out_positive;
+
+	/*** handle NEGATIVE dentries ***/
+
+	/*
+	 * If negative, keep only first lower negative dentry, to save on
+	 * memory.
+	 */
+	if (dbstart(dentry) < dbend(dentry)) {
+		path_put_lowers(dentry, dbstart(dentry) + 1,
+				dbend(dentry), false);
+		dbend(dentry) = dbstart(dentry);
+	}
+	if (lookupmode == INTERPOSE_PARTIAL)
+		goto out;
+	if (lookupmode == INTERPOSE_LOOKUP) {
+		/*
+		 * If all we found was a whiteout in the first available
+		 * branch, then create a negative dentry for a possibly new
+		 * file to be created.
+		 */
+		if (dbopaque(dentry) < 0)
+			goto out;
+		/* XXX: need to get mnt here */
+		bindex = dbstart(dentry);
+		if (unionfs_lower_dentry_idx(dentry, bindex))
+			goto out;
+		lower_dir_dentry =
+			unionfs_lower_dentry_idx(parent_dentry, bindex);
+		if (!lower_dir_dentry || !lower_dir_dentry->d_inode)
+			goto out;
+		if (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))
+			goto out; /* XXX: should be BUG_ON */
+		/* XXX: do we need to cross bind mounts here? */
+		lower_dentry = lookup_one_len(name, lower_dir_dentry, namelen);
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out;
+		}
+		/* XXX: need to mntget/mntput as needed too! */
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		/* XXX: wrong mnt for crossing bind mounts! */
+		lower_mnt = unionfs_mntget(dentry->d_sb->s_root, bindex);
+		unionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);
+
+		goto out;
+	}
+
+	/* if we're revalidating a positive dentry, don't make it negative */
+	if (lookupmode != INTERPOSE_REVAL)
+		d_add(dentry, NULL);
+
+	goto out;
+
+out_positive:
+	/*** handle POSITIVE dentries ***/
+
+	/*
+	 * This unionfs dentry is positive (at least one lower inode
+	 * exists), so scan entire dentry from beginning to end, and remove
+	 * any negative lower dentries, if any.  Then, update dbstart/dbend
+	 * to reflect the start/end of positive dentries.
+	 */
+	pos_start = pos_end = -1;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry,
+							bindex);
+		if (lower_dentry && lower_dentry->d_inode) {
+			if (pos_start < 0)
+				pos_start = bindex;
+			if (bindex > pos_end)
+				pos_end = bindex;
+			continue;
+		}
+		path_put_lowers(dentry, bindex, bindex, false);
+	}
+	if (pos_start >= 0)
+		dbstart(dentry) = pos_start;
+	if (pos_end >= 0)
+		dbend(dentry) = pos_end;
+
+	/* Partial lookups need to re-interpose, or throw away older negs. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		if (dentry->d_inode) {
+			unionfs_reinterpose(dentry);
+			goto out;
+		}
+
+		/*
+		 * This dentry was positive, so it is as if we had a
+		 * negative revalidation.
+		 */
+		lookupmode = INTERPOSE_REVAL_NEG;
+		update_bstart(dentry);
+	}
+
+	/*
+	 * Interpose can return a dentry if d_splice returned a different
+	 * dentry.
+	 */
+	d_interposed = unionfs_interpose(dentry, dentry->d_sb, lookupmode);
+	if (IS_ERR(d_interposed))
+		err = PTR_ERR(d_interposed);
+	else if (d_interposed)
+		dentry = d_interposed;
+
+	if (!err)
+		goto out;
+	d_drop(dentry);
+
+out_free:
+	/* should dput/mntput all the underlying dentries on error condition */
+	if (dbstart(dentry) >= 0)
+		path_put_lowers_all(dentry, false);
+	/* free lower_paths unconditionally */
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	UNIONFS_D(dentry)->lower_paths = NULL;
+
+out:
+	if (dentry && UNIONFS_D(dentry)) {
+		BUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);
+		BUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);
+	}
+	if (d_interposed && UNIONFS_D(d_interposed)) {
+		BUG_ON(dbstart(d_interposed) < 0 && dbend(d_interposed) >= 0);
+		BUG_ON(dbstart(d_interposed) >= 0 && dbend(d_interposed) < 0);
+	}
+
+	dput(parent_dentry);
+	if (!err && d_interposed)
+		return d_interposed;
+	return ERR_PTR(err);
+}
diff --git a/fs/unionfs/main.c b/fs/unionfs/main.c
new file mode 100644
index 0000000..fea670b
--- /dev/null
+++ b/fs/unionfs/main.c
@@ -0,0 +1,777 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+static void unionfs_fill_inode(struct dentry *dentry,
+			       struct inode *inode)
+{
+	struct inode *lower_inode;
+	struct dentry *lower_dentry;
+	int bindex, bstart, bend;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			continue;
+		}
+
+		/* Initialize the lower inode to the new lower inode. */
+		if (!lower_dentry->d_inode)
+			continue;
+
+		unionfs_set_lower_inode_idx(inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	/* Use attributes from the first branch. */
+	lower_inode = unionfs_lower_inode(inode);
+
+	/* Use different set of inode ops for symlinks & directories */
+	if (S_ISLNK(lower_inode->i_mode))
+		inode->i_op = &unionfs_symlink_iops;
+	else if (S_ISDIR(lower_inode->i_mode))
+		inode->i_op = &unionfs_dir_iops;
+
+	/* Use different set of file ops for directories */
+	if (S_ISDIR(lower_inode->i_mode))
+		inode->i_fop = &unionfs_dir_fops;
+
+	/* properly initialize special inodes */
+	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
+	    S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode))
+		init_special_inode(inode, lower_inode->i_mode,
+				   lower_inode->i_rdev);
+
+	/* all well, copy inode attributes */
+	unionfs_copy_attr_all(inode, lower_inode);
+	fsstack_copy_inode_size(inode, lower_inode);
+}
+
+/*
+ * Connect a unionfs inode dentry/inode with several lower ones.  This is
+ * the classic stackable file system "vnode interposition" action.
+ *
+ * @sb: unionfs's super_block
+ */
+struct dentry *unionfs_interpose(struct dentry *dentry, struct super_block *sb,
+				 int flag)
+{
+	int err = 0;
+	struct inode *inode;
+	int need_fill_inode = 1;
+	struct dentry *spliced = NULL;
+
+	verify_locked(dentry);
+
+	/*
+	 * We allocate our new inode below by calling unionfs_iget,
+	 * which will initialize some of the new inode's fields
+	 */
+
+	/*
+	 * On revalidate we've already got our own inode and just need
+	 * to fix it up.
+	 */
+	if (flag == INTERPOSE_REVAL) {
+		inode = dentry->d_inode;
+		UNIONFS_I(inode)->bstart = -1;
+		UNIONFS_I(inode)->bend = -1;
+		atomic_set(&UNIONFS_I(inode)->generation,
+			   atomic_read(&UNIONFS_SB(sb)->generation));
+
+		UNIONFS_I(inode)->lower_inodes =
+			kcalloc(sbmax(sb), sizeof(struct inode *), GFP_KERNEL);
+		if (unlikely(!UNIONFS_I(inode)->lower_inodes)) {
+			err = -ENOMEM;
+			goto out;
+		}
+	} else {
+		/* get unique inode number for unionfs */
+		inode = unionfs_iget(sb, iunique(sb, UNIONFS_ROOT_INO));
+		if (IS_ERR(inode)) {
+			err = PTR_ERR(inode);
+			goto out;
+		}
+		if (atomic_read(&inode->i_count) > 1)
+			goto skip;
+	}
+
+	need_fill_inode = 0;
+	unionfs_fill_inode(dentry, inode);
+
+skip:
+	/* only (our) lookup wants to do a d_add */
+	switch (flag) {
+	case INTERPOSE_DEFAULT:
+		/* for operations which create new inodes */
+		d_add(dentry, inode);
+		break;
+	case INTERPOSE_REVAL_NEG:
+		d_instantiate(dentry, inode);
+		break;
+	case INTERPOSE_LOOKUP:
+		spliced = d_splice_alias(inode, dentry);
+		if (spliced && spliced != dentry) {
+			/*
+			 * d_splice can return a dentry if it was
+			 * disconnected and had to be moved.  We must ensure
+			 * that the private data of the new dentry is
+			 * correct and that the inode info was filled
+			 * properly.  Finally we must return this new
+			 * dentry.
+			 */
+			spliced->d_op = &unionfs_dops;
+			spliced->d_fsdata = dentry->d_fsdata;
+			dentry->d_fsdata = NULL;
+			dentry = spliced;
+			if (need_fill_inode) {
+				need_fill_inode = 0;
+				unionfs_fill_inode(dentry, inode);
+			}
+			goto out_spliced;
+		} else if (!spliced) {
+			if (need_fill_inode) {
+				need_fill_inode = 0;
+				unionfs_fill_inode(dentry, inode);
+				goto out_spliced;
+			}
+		}
+		break;
+	case INTERPOSE_REVAL:
+		/* Do nothing. */
+		break;
+	default:
+		printk(KERN_CRIT "unionfs: invalid interpose flag passed!\n");
+		BUG();
+	}
+	goto out;
+
+out_spliced:
+	if (!err)
+		return spliced;
+out:
+	return ERR_PTR(err);
+}
+
+/* like interpose above, but for an already existing dentry */
+void unionfs_reinterpose(struct dentry *dentry)
+{
+	struct dentry *lower_dentry;
+	struct inode *inode;
+	int bindex, bstart, bend;
+
+	verify_locked(dentry);
+
+	/* This is pre-allocated inode */
+	inode = dentry->d_inode;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		if (!lower_dentry->d_inode)
+			continue;
+		if (unionfs_lower_inode_idx(inode, bindex))
+			continue;
+		unionfs_set_lower_inode_idx(inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+}
+
+/*
+ * make sure the branch we just looked up (nd) makes sense:
+ *
+ * 1) we're not trying to stack unionfs on top of unionfs
+ * 2) it exists
+ * 3) is a directory
+ */
+int check_branch(struct nameidata *nd)
+{
+	/* XXX: remove in ODF code -- stacking unions allowed there */
+	if (!strcmp(nd->path.dentry->d_sb->s_type->name, UNIONFS_NAME))
+		return -EINVAL;
+	if (!nd->path.dentry->d_inode)
+		return -ENOENT;
+	if (!S_ISDIR(nd->path.dentry->d_inode->i_mode))
+		return -ENOTDIR;
+	return 0;
+}
+
+/* checks if two lower_dentries have overlapping branches */
+static int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)
+{
+	struct dentry *dent = NULL;
+
+	dent = dent1;
+	while ((dent != dent2) && (dent->d_parent != dent))
+		dent = dent->d_parent;
+
+	if (dent == dent2)
+		return 1;
+
+	dent = dent2;
+	while ((dent != dent1) && (dent->d_parent != dent))
+		dent = dent->d_parent;
+
+	return (dent == dent1);
+}
+
+/*
+ * Parse "ro" or "rw" options, but default to "rw" if no mode options was
+ * specified.  Fill the mode bits in @perms.  If encounter an unknown
+ * string, return -EINVAL.  Otherwise return 0.
+ */
+int parse_branch_mode(const char *name, int *perms)
+{
+	if (!name || !strcmp(name, "rw")) {
+		*perms = MAY_READ | MAY_WRITE;
+		return 0;
+	}
+	if (!strcmp(name, "ro")) {
+		*perms = MAY_READ;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * parse the dirs= mount argument
+ *
+ * We don't need to lock the superblock private data's rwsem, as we get
+ * called only by unionfs_read_super - it is still a long time before anyone
+ * can even get a reference to us.
+ */
+static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
+			     *lower_root_info, char *options)
+{
+	struct nameidata nd;
+	char *name;
+	int err = 0;
+	int branches = 1;
+	int bindex = 0;
+	int i = 0;
+	int j = 0;
+	struct dentry *dent1;
+	struct dentry *dent2;
+
+	if (options[0] == '\0') {
+		printk(KERN_ERR "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Each colon means we have a separator, this is really just a rough
+	 * guess, since strsep will handle empty fields for us.
+	 */
+	for (i = 0; options[i]; i++)
+		if (options[i] == ':')
+			branches++;
+
+	/* allocate space for underlying pointers to lower dentry */
+	UNIONFS_SB(sb)->data =
+		kcalloc(branches, sizeof(struct unionfs_data), GFP_KERNEL);
+	if (unlikely(!UNIONFS_SB(sb)->data)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	lower_root_info->lower_paths =
+		kcalloc(branches, sizeof(struct path), GFP_KERNEL);
+	if (unlikely(!lower_root_info->lower_paths)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* now parsing a string such as "b1:b2=rw:b3=ro:b4" */
+	branches = 0;
+	while ((name = strsep(&options, ":")) != NULL) {
+		int perms;
+		char *mode = strchr(name, '=');
+
+		if (!name)
+			continue;
+		if (!*name) {	/* bad use of ':' (extra colons) */
+			err = -EINVAL;
+			goto out;
+		}
+
+		branches++;
+
+		/* strip off '=' if any */
+		if (mode)
+			*mode++ = '\0';
+
+		err = parse_branch_mode(mode, &perms);
+		if (err) {
+			printk(KERN_ERR "unionfs: invalid mode \"%s\" for "
+			       "branch %d\n", mode, bindex);
+			goto out;
+		}
+		/* ensure that leftmost branch is writeable */
+		if (!bindex && !(perms & MAY_WRITE)) {
+			printk(KERN_ERR "unionfs: leftmost branch cannot be "
+			       "read-only (use \"-o ro\" to create a "
+			       "read-only union)\n");
+			err = -EINVAL;
+			goto out;
+		}
+
+		err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+		if (err) {
+			printk(KERN_ERR "unionfs: error accessing "
+			       "lower directory '%s' (error %d)\n",
+			       name, err);
+			goto out;
+		}
+
+		err = check_branch(&nd);
+		if (err) {
+			printk(KERN_ERR "unionfs: lower directory "
+			       "'%s' is not a valid branch\n", name);
+			path_put(&nd.path);
+			goto out;
+		}
+
+		lower_root_info->lower_paths[bindex].dentry = nd.path.dentry;
+		lower_root_info->lower_paths[bindex].mnt = nd.path.mnt;
+
+		set_branchperms(sb, bindex, perms);
+		set_branch_count(sb, bindex, 0);
+		new_branch_id(sb, bindex);
+
+		if (lower_root_info->bstart < 0)
+			lower_root_info->bstart = bindex;
+		lower_root_info->bend = bindex;
+		bindex++;
+	}
+
+	if (branches == 0) {
+		printk(KERN_ERR "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	BUG_ON(branches != (lower_root_info->bend + 1));
+
+	/*
+	 * Ensure that no overlaps exist in the branches.
+	 *
+	 * This test is required because the Linux kernel has no support
+	 * currently for ensuring coherency between stackable layers and
+	 * branches.  If we were to allow overlapping branches, it would be
+	 * possible, for example, to delete a file via one branch, which
+	 * would not be reflected in another branch.  Such incoherency could
+	 * lead to inconsistencies and even kernel oopses.  Rather than
+	 * implement hacks to work around some of these cache-coherency
+	 * problems, we prevent branch overlapping, for now.  A complete
+	 * solution will involve proper kernel/VFS support for cache
+	 * coherency, at which time we could safely remove this
+	 * branch-overlapping test.
+	 */
+	for (i = 0; i < branches; i++) {
+		dent1 = lower_root_info->lower_paths[i].dentry;
+		for (j = i + 1; j < branches; j++) {
+			dent2 = lower_root_info->lower_paths[j].dentry;
+			if (is_branch_overlap(dent1, dent2)) {
+				printk(KERN_ERR "unionfs: branches %d and "
+				       "%d overlap\n", i, j);
+				err = -EINVAL;
+				goto out;
+			}
+		}
+	}
+
+out:
+	if (err) {
+		for (i = 0; i < branches; i++)
+			if (lower_root_info->lower_paths[i].dentry) {
+				dput(lower_root_info->lower_paths[i].dentry);
+				/* initialize: can't use unionfs_mntput here */
+				mntput(lower_root_info->lower_paths[i].mnt);
+			}
+
+		kfree(lower_root_info->lower_paths);
+		kfree(UNIONFS_SB(sb)->data);
+
+		/*
+		 * MUST clear the pointers to prevent potential double free if
+		 * the caller dies later on
+		 */
+		lower_root_info->lower_paths = NULL;
+		UNIONFS_SB(sb)->data = NULL;
+	}
+	return err;
+}
+
+/*
+ * Parse mount options.  See the manual page for usage instructions.
+ *
+ * Returns the dentry object of the lower-level (lower) directory;
+ * We want to mount our stackable file system on top of that lower directory.
+ */
+static struct unionfs_dentry_info *unionfs_parse_options(
+					 struct super_block *sb,
+					 char *options)
+{
+	struct unionfs_dentry_info *lower_root_info;
+	char *optname;
+	int err = 0;
+	int bindex;
+	int dirsfound = 0;
+
+	/* allocate private data area */
+	err = -ENOMEM;
+	lower_root_info =
+		kzalloc(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
+	if (unlikely(!lower_root_info))
+		goto out_error;
+	lower_root_info->bstart = -1;
+	lower_root_info->bend = -1;
+	lower_root_info->bopaque = -1;
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+
+		/*
+		 * All of our options take an argument now. Insert ones that
+		 * don't, above this check.
+		 */
+		if (!optarg) {
+			printk(KERN_ERR "unionfs: %s requires an argument\n",
+			       optname);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("dirs", optname)) {
+			if (++dirsfound > 1) {
+				printk(KERN_ERR
+				       "unionfs: multiple dirs specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err = parse_dirs_option(sb, lower_root_info, optarg);
+			if (err)
+				goto out_error;
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_ERR
+		       "unionfs: unrecognized option '%s'\n", optname);
+		goto out_error;
+	}
+	if (dirsfound != 1) {
+		printk(KERN_ERR "unionfs: dirs option required\n");
+		err = -EINVAL;
+		goto out_error;
+	}
+	goto out;
+
+out_error:
+	if (lower_root_info && lower_root_info->lower_paths) {
+		for (bindex = lower_root_info->bstart;
+		     bindex >= 0 && bindex <= lower_root_info->bend;
+		     bindex++) {
+			struct dentry *d;
+			struct vfsmount *m;
+
+			d = lower_root_info->lower_paths[bindex].dentry;
+			m = lower_root_info->lower_paths[bindex].mnt;
+
+			dput(d);
+			/* initializing: can't use unionfs_mntput here */
+			mntput(m);
+		}
+	}
+
+	kfree(lower_root_info->lower_paths);
+	kfree(lower_root_info);
+
+	kfree(UNIONFS_SB(sb)->data);
+	UNIONFS_SB(sb)->data = NULL;
+
+	lower_root_info = ERR_PTR(err);
+out:
+	return lower_root_info;
+}
+
+/*
+ * our custom d_alloc_root work-alike
+ *
+ * we can't use d_alloc_root if we want to use our own interpose function
+ * unchanged, so we simply call our own "fake" d_alloc_root
+ */
+static struct dentry *unionfs_d_alloc_root(struct super_block *sb)
+{
+	struct dentry *ret = NULL;
+
+	if (sb) {
+		static const struct qstr name = {
+			.name = "/",
+			.len = 1
+		};
+
+		ret = d_alloc(NULL, &name);
+		if (likely(ret)) {
+			ret->d_op = &unionfs_dops;
+			ret->d_sb = sb;
+			ret->d_parent = ret;
+		}
+	}
+	return ret;
+}
+
+/*
+ * There is no need to lock the unionfs_super_info's rwsem as there is no
+ * way anyone can have a reference to the superblock at this point in time.
+ */
+static int unionfs_read_super(struct super_block *sb, void *raw_data,
+			      int silent)
+{
+	int err = 0;
+	struct unionfs_dentry_info *lower_root_info = NULL;
+	int bindex, bstart, bend;
+
+	if (!raw_data) {
+		printk(KERN_ERR
+		       "unionfs: read_super: missing data argument\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Allocate superblock private data */
+	sb->s_fs_info = kzalloc(sizeof(struct unionfs_sb_info), GFP_KERNEL);
+	if (unlikely(!UNIONFS_SB(sb))) {
+		printk(KERN_CRIT "unionfs: read_super: out of memory\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	UNIONFS_SB(sb)->bend = -1;
+	atomic_set(&UNIONFS_SB(sb)->generation, 1);
+	init_rwsem(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->high_branch_id = -1; /* -1 == invalid branch ID */
+
+	lower_root_info = unionfs_parse_options(sb, raw_data);
+	if (IS_ERR(lower_root_info)) {
+		printk(KERN_ERR
+		       "unionfs: read_super: error while parsing options "
+		       "(err = %ld)\n", PTR_ERR(lower_root_info));
+		err = PTR_ERR(lower_root_info);
+		lower_root_info = NULL;
+		goto out_free;
+	}
+	if (lower_root_info->bstart == -1) {
+		err = -ENOENT;
+		goto out_free;
+	}
+
+	/* set the lower superblock field of upper superblock */
+	bstart = lower_root_info->bstart;
+	BUG_ON(bstart != 0);
+	sbend(sb) = bend = lower_root_info->bend;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d = lower_root_info->lower_paths[bindex].dentry;
+		atomic_inc(&d->d_sb->s_active);
+		unionfs_set_lower_super_idx(sb, bindex, d->d_sb);
+	}
+
+	/* max Bytes is the maximum bytes from highest priority branch */
+	sb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;
+
+	/*
+	 * Our c/m/atime granularity is 1 ns because we may stack on file
+	 * systems whose granularity is as good.  This is important for our
+	 * time-based cache coherency.
+	 */
+	sb->s_time_gran = 1;
+
+	sb->s_op = &unionfs_sops;
+
+	/* See comment next to the definition of unionfs_d_alloc_root */
+	sb->s_root = unionfs_d_alloc_root(sb);
+	if (unlikely(!sb->s_root)) {
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	/* link the upper and lower dentries */
+	sb->s_root->d_fsdata = NULL;
+	err = new_dentry_private_data(sb->s_root, UNIONFS_DMUTEX_ROOT);
+	if (unlikely(err))
+		goto out_freedpd;
+
+	/* Set the lower dentries for s_root */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+		struct vfsmount *m;
+
+		d = lower_root_info->lower_paths[bindex].dentry;
+		m = lower_root_info->lower_paths[bindex].mnt;
+
+		unionfs_set_lower_dentry_idx(sb->s_root, bindex, d);
+		unionfs_set_lower_mnt_idx(sb->s_root, bindex, m);
+	}
+	dbstart(sb->s_root) = bstart;
+	dbend(sb->s_root) = bend;
+
+	/* Set the generation number to one, since this is for the mount. */
+	atomic_set(&UNIONFS_D(sb->s_root)->generation, 1);
+
+	/*
+	 * Call interpose to create the upper level inode.  Only
+	 * INTERPOSE_LOOKUP can return a value other than 0 on err.
+	 */
+	err = PTR_ERR(unionfs_interpose(sb->s_root, sb, 0));
+	unionfs_unlock_dentry(sb->s_root);
+	if (!err)
+		goto out;
+	/* else fall through */
+
+out_freedpd:
+	if (UNIONFS_D(sb->s_root)) {
+		kfree(UNIONFS_D(sb->s_root)->lower_paths);
+		free_dentry_private_data(sb->s_root);
+	}
+	dput(sb->s_root);
+
+out_dput:
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		for (bindex = lower_root_info->bstart;
+		     bindex <= lower_root_info->bend; bindex++) {
+			struct dentry *d;
+			struct vfsmount *m;
+
+			d = lower_root_info->lower_paths[bindex].dentry;
+			m = lower_root_info->lower_paths[bindex].mnt;
+
+			dput(d);
+			/* initializing: can't use unionfs_mntput here */
+			mntput(m);
+			/* drop refs we took earlier */
+			atomic_dec(&d->d_sb->s_active);
+		}
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
+		lower_root_info = NULL;
+	}
+
+out_free:
+	kfree(UNIONFS_SB(sb)->data);
+	kfree(UNIONFS_SB(sb));
+	sb->s_fs_info = NULL;
+
+out:
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
+	}
+	return err;
+}
+
+static int unionfs_get_sb(struct file_system_type *fs_type,
+			  int flags, const char *dev_name,
+			  void *raw_data, struct vfsmount *mnt)
+{
+	int err;
+	err = get_sb_nodev(fs_type, flags, raw_data, unionfs_read_super, mnt);
+	if (!err)
+		UNIONFS_SB(mnt->mnt_sb)->dev_name =
+			kstrdup(dev_name, GFP_KERNEL);
+	return err;
+}
+
+static struct file_system_type unionfs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= UNIONFS_NAME,
+	.get_sb		= unionfs_get_sb,
+	.kill_sb	= generic_shutdown_super,
+	.fs_flags	= FS_REVAL_DOT,
+};
+
+static int __init init_unionfs_fs(void)
+{
+	int err;
+
+	pr_info("Registering unionfs " UNIONFS_VERSION "\n");
+
+	err = unionfs_init_filldir_cache();
+	if (unlikely(err))
+		goto out;
+	err = unionfs_init_inode_cache();
+	if (unlikely(err))
+		goto out;
+	err = unionfs_init_dentry_cache();
+	if (unlikely(err))
+		goto out;
+	err = init_sioq();
+	if (unlikely(err))
+		goto out;
+	err = register_filesystem(&unionfs_fs_type);
+out:
+	if (unlikely(err)) {
+		stop_sioq();
+		unionfs_destroy_filldir_cache();
+		unionfs_destroy_inode_cache();
+		unionfs_destroy_dentry_cache();
+	}
+	return err;
+}
+
+static void __exit exit_unionfs_fs(void)
+{
+	stop_sioq();
+	unionfs_destroy_filldir_cache();
+	unionfs_destroy_inode_cache();
+	unionfs_destroy_dentry_cache();
+	unregister_filesystem(&unionfs_fs_type);
+	pr_info("Completed unionfs module unload\n");
+}
+
+MODULE_AUTHOR("Erez Zadok, Filesystems and Storage Lab, Stony Brook University"
+	      " (http://www.fsl.cs.sunysb.edu)");
+MODULE_DESCRIPTION("Unionfs " UNIONFS_VERSION
+		   " (http://unionfs.filesystems.org)");
+MODULE_LICENSE("GPL");
+
+module_init(init_unionfs_fs);
+module_exit(exit_unionfs_fs);
diff --git a/fs/unionfs/mmap.c b/fs/unionfs/mmap.c
new file mode 100644
index 0000000..b7d4713
--- /dev/null
+++ b/fs/unionfs/mmap.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2006      Shaya Potter
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+
+/*
+ * XXX: we need a dummy readpage handler because generic_file_mmap (which we
+ * use in unionfs_mmap) checks for the existence of
+ * mapping->a_ops->readpage, else it returns -ENOEXEC.  The VFS will need to
+ * be fixed to allow a file system to define vm_ops->fault without any
+ * address_space_ops whatsoever.
+ *
+ * Otherwise, we don't want to use our readpage method at all.
+ */
+static int unionfs_readpage(struct file *file, struct page *page)
+{
+	BUG();
+	return -EINVAL;
+}
+
+static int unionfs_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	int err;
+	struct file *file, *lower_file;
+	struct vm_operations_struct *lower_vm_ops;
+	struct vm_area_struct lower_vma;
+
+	BUG_ON(!vma);
+	memcpy(&lower_vma, vma, sizeof(struct vm_area_struct));
+	file = lower_vma.vm_file;
+	lower_vm_ops = UNIONFS_F(file)->lower_vm_ops;
+	BUG_ON(!lower_vm_ops);
+
+	lower_file = unionfs_lower_file(file);
+	BUG_ON(!lower_file);
+	/*
+	 * XXX: vm_ops->fault may be called in parallel.  Because we have to
+	 * resort to temporarily changing the vma->vm_file to point to the
+	 * lower file, a concurrent invocation of unionfs_fault could see a
+	 * different value.  In this workaround, we keep a different copy of
+	 * the vma structure in our stack, so we never expose a different
+	 * value of the vma->vm_file called to us, even temporarily.  A
+	 * better fix would be to change the calling semantics of ->fault to
+	 * take an explicit file pointer.
+	 */
+	lower_vma.vm_file = lower_file;
+	err = lower_vm_ops->fault(&lower_vma, vmf);
+	return err;
+}
+
+/*
+ * XXX: the default address_space_ops for unionfs is empty.  We cannot set
+ * our inode->i_mapping->a_ops to NULL because too many code paths expect
+ * the a_ops vector to be non-NULL.
+ */
+struct address_space_operations unionfs_aops = {
+	/* empty on purpose */
+};
+
+/*
+ * XXX: we need a second, dummy address_space_ops vector, to be used
+ * temporarily during unionfs_mmap, because the latter calls
+ * generic_file_mmap, which checks if ->readpage exists, else returns
+ * -ENOEXEC.
+ */
+struct address_space_operations unionfs_dummy_aops = {
+	.readpage	= unionfs_readpage,
+};
+
+struct vm_operations_struct unionfs_vm_ops = {
+	.fault		= unionfs_fault,
+};
diff --git a/fs/unionfs/rdstate.c b/fs/unionfs/rdstate.c
new file mode 100644
index 0000000..06d5374
--- /dev/null
+++ b/fs/unionfs/rdstate.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* This file contains the routines for maintaining readdir state. */
+
+/*
+ * There are two structures here, rdstate which is a hash table
+ * of the second structure which is a filldir_node.
+ */
+
+/*
+ * This is a struct kmem_cache for filldir nodes, because we allocate a lot
+ * of them and they shouldn't waste memory.  If the node has a small name
+ * (as defined by the dentry structure), then we use an inline name to
+ * preserve kmalloc space.
+ */
+static struct kmem_cache *unionfs_filldir_cachep;
+
+int unionfs_init_filldir_cache(void)
+{
+	unionfs_filldir_cachep =
+		kmem_cache_create("unionfs_filldir",
+				  sizeof(struct filldir_node), 0,
+				  SLAB_RECLAIM_ACCOUNT, NULL);
+
+	return (unionfs_filldir_cachep ? 0 : -ENOMEM);
+}
+
+void unionfs_destroy_filldir_cache(void)
+{
+	if (unionfs_filldir_cachep)
+		kmem_cache_destroy(unionfs_filldir_cachep);
+}
+
+/*
+ * This is a tuning parameter that tells us roughly how big to make the
+ * hash table in directory entries per page.  This isn't perfect, but
+ * at least we get a hash table size that shouldn't be too overloaded.
+ * The following averages are based on my home directory.
+ * 14.44693	Overall
+ * 12.29	Single Page Directories
+ * 117.93	Multi-page directories
+ */
+#define DENTPAGE 4096
+#define DENTPERONEPAGE 12
+#define DENTPERPAGE 118
+#define MINHASHSIZE 1
+static int guesstimate_hash_size(struct inode *inode)
+{
+	struct inode *lower_inode;
+	int bindex;
+	int hashsize = MINHASHSIZE;
+
+	if (UNIONFS_I(inode)->hashsize > 0)
+		return UNIONFS_I(inode)->hashsize;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		if (i_size_read(lower_inode) == DENTPAGE)
+			hashsize += DENTPERONEPAGE;
+		else
+			hashsize += (i_size_read(lower_inode) / DENTPAGE) *
+				DENTPERPAGE;
+	}
+
+	return hashsize;
+}
+
+int init_rdstate(struct file *file)
+{
+	BUG_ON(sizeof(loff_t) !=
+	       (sizeof(unsigned int) + sizeof(unsigned int)));
+	BUG_ON(UNIONFS_F(file)->rdstate != NULL);
+
+	UNIONFS_F(file)->rdstate = alloc_rdstate(file->f_path.dentry->d_inode,
+						 fbstart(file));
+
+	return (UNIONFS_F(file)->rdstate ? 0 : -ENOMEM);
+}
+
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos)
+{
+	struct unionfs_dir_state *rdstate = NULL;
+	struct list_head *pos;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	list_for_each(pos, &UNIONFS_I(inode)->readdircache) {
+		struct unionfs_dir_state *r =
+			list_entry(pos, struct unionfs_dir_state, cache);
+		if (fpos == rdstate2offset(r)) {
+			UNIONFS_I(inode)->rdcount--;
+			list_del(&r->cache);
+			rdstate = r;
+			break;
+		}
+	}
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+	return rdstate;
+}
+
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex)
+{
+	int i = 0;
+	int hashsize;
+	unsigned long mallocsize = sizeof(struct unionfs_dir_state);
+	struct unionfs_dir_state *rdstate;
+
+	hashsize = guesstimate_hash_size(inode);
+	mallocsize += hashsize * sizeof(struct list_head);
+	mallocsize = __roundup_pow_of_two(mallocsize);
+
+	/* This should give us about 500 entries anyway. */
+	if (mallocsize > PAGE_SIZE)
+		mallocsize = PAGE_SIZE;
+
+	hashsize = (mallocsize - sizeof(struct unionfs_dir_state)) /
+		sizeof(struct list_head);
+
+	rdstate = kmalloc(mallocsize, GFP_KERNEL);
+	if (unlikely(!rdstate))
+		return NULL;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	if (UNIONFS_I(inode)->cookie >= (MAXRDCOOKIE - 1))
+		UNIONFS_I(inode)->cookie = 1;
+	else
+		UNIONFS_I(inode)->cookie++;
+
+	rdstate->cookie = UNIONFS_I(inode)->cookie;
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+	rdstate->offset = 1;
+	rdstate->access = jiffies;
+	rdstate->bindex = bindex;
+	rdstate->dirpos = 0;
+	rdstate->hashentries = 0;
+	rdstate->size = hashsize;
+	for (i = 0; i < rdstate->size; i++)
+		INIT_LIST_HEAD(&rdstate->list[i]);
+
+	return rdstate;
+}
+
+static void free_filldir_node(struct filldir_node *node)
+{
+	if (node->namelen >= DNAME_INLINE_LEN_MIN)
+		kfree(node->name);
+	kmem_cache_free(unionfs_filldir_cachep, node);
+}
+
+void free_rdstate(struct unionfs_dir_state *state)
+{
+	struct filldir_node *tmp;
+	int i;
+
+	for (i = 0; i < state->size; i++) {
+		struct list_head *head = &(state->list[i]);
+		struct list_head *pos, *n;
+
+		/* traverse the list and deallocate space */
+		list_for_each_safe(pos, n, head) {
+			tmp = list_entry(pos, struct filldir_node, file_list);
+			list_del(&tmp->file_list);
+			free_filldir_node(tmp);
+		}
+	}
+
+	kfree(state);
+}
+
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen,
+				       int is_whiteout)
+{
+	int index;
+	unsigned int hash;
+	struct list_head *head;
+	struct list_head *pos;
+	struct filldir_node *cursor = NULL;
+	int found = 0;
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->size;
+
+	head = &(rdstate->list[index]);
+	list_for_each(pos, head) {
+		cursor = list_entry(pos, struct filldir_node, file_list);
+
+		if (cursor->namelen == namelen && cursor->hash == hash &&
+		    !strncmp(cursor->name, name, namelen)) {
+			/*
+			 * a duplicate exists, and hence no need to create
+			 * entry to the list
+			 */
+			found = 1;
+
+			/*
+			 * if a duplicate is found in this branch, and is
+			 * not due to the caller looking for an entry to
+			 * whiteout, then the file system may be corrupted.
+			 */
+			if (unlikely(!is_whiteout &&
+				     cursor->bindex == rdstate->bindex))
+				printk(KERN_ERR "unionfs: filldir: possible "
+				       "I/O error: a file is duplicated "
+				       "in the same branch %d: %s\n",
+				       rdstate->bindex, cursor->name);
+			break;
+		}
+	}
+
+	if (!found)
+		cursor = NULL;
+
+	return cursor;
+}
+
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout)
+{
+	struct filldir_node *new;
+	unsigned int hash;
+	int index;
+	int err = 0;
+	struct list_head *head;
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->size;
+	head = &(rdstate->list[index]);
+
+	new = kmem_cache_alloc(unionfs_filldir_cachep, GFP_KERNEL);
+	if (unlikely(!new)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&new->file_list);
+	new->namelen = namelen;
+	new->hash = hash;
+	new->bindex = bindex;
+	new->whiteout = whiteout;
+
+	if (namelen < DNAME_INLINE_LEN_MIN) {
+		new->name = new->iname;
+	} else {
+		new->name = kmalloc(namelen + 1, GFP_KERNEL);
+		if (unlikely(!new->name)) {
+			kmem_cache_free(unionfs_filldir_cachep, new);
+			new = NULL;
+			goto out;
+		}
+	}
+
+	memcpy(new->name, name, namelen);
+	new->name[namelen] = '\0';
+
+	rdstate->hashentries++;
+
+	list_add(&(new->file_list), head);
+out:
+	return err;
+}
diff --git a/fs/unionfs/rename.c b/fs/unionfs/rename.c
new file mode 100644
index 0000000..da7d589
--- /dev/null
+++ b/fs/unionfs/rename.c
@@ -0,0 +1,478 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * This is a helper function for rename, used when rename ends up with hosed
+ * over dentries and we need to revert.
+ */
+static int unionfs_refresh_lower_dentry(struct dentry *dentry, int bindex)
+{
+	struct dentry *lower_dentry;
+	struct dentry *lower_parent;
+	int err = 0;
+
+	verify_locked(dentry);
+
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_CHILD);
+	lower_parent = unionfs_lower_dentry_idx(dentry->d_parent, bindex);
+	unionfs_unlock_dentry(dentry->d_parent);
+
+	BUG_ON(!S_ISDIR(lower_parent->d_inode->i_mode));
+
+	lower_dentry = lookup_one_len(dentry->d_name.name, lower_parent,
+				      dentry->d_name.len);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	dput(unionfs_lower_dentry_idx(dentry, bindex));
+	iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
+	unionfs_set_lower_inode_idx(dentry->d_inode, bindex, NULL);
+
+	if (!lower_dentry->d_inode) {
+		dput(lower_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+	} else {
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+
+out:
+	return err;
+}
+
+static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			    struct inode *new_dir, struct dentry *new_dentry,
+			    int bindex)
+{
+	int err = 0;
+	struct dentry *lower_old_dentry;
+	struct dentry *lower_new_dentry;
+	struct dentry *lower_old_dir_dentry;
+	struct dentry *lower_new_dir_dentry;
+	struct dentry *trap;
+
+	lower_new_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
+	lower_old_dentry = unionfs_lower_dentry_idx(old_dentry, bindex);
+
+	if (!lower_new_dentry) {
+		lower_new_dentry =
+			create_parents(new_dentry->d_parent->d_inode,
+				       new_dentry, new_dentry->d_name.name,
+				       bindex);
+		if (IS_ERR(lower_new_dentry)) {
+			err = PTR_ERR(lower_new_dentry);
+			if (IS_COPYUP_ERR(err))
+				goto out;
+			printk(KERN_ERR "unionfs: error creating directory "
+			       "tree for rename, bindex=%d err=%d\n",
+			       bindex, err);
+			goto out;
+		}
+	}
+
+	/* check for and remove whiteout, if any */
+	err = check_unlink_whiteout(new_dentry, lower_new_dentry, bindex);
+	if (err > 0) /* ignore if whiteout found and successfully removed */
+		err = 0;
+	if (err)
+		goto out;
+
+	/* check of old_dentry branch is writable */
+	err = is_robranch_super(old_dentry->d_sb, bindex);
+	if (err)
+		goto out;
+
+	dget(lower_old_dentry);
+	dget(lower_new_dentry);
+	lower_old_dir_dentry = dget_parent(lower_old_dentry);
+	lower_new_dir_dentry = dget_parent(lower_new_dentry);
+
+	/* see Documentation/filesystems/unionfs/issues.txt */
+	lockdep_off();
+	trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	/* source should not be ancenstor of target */
+	if (trap == lower_old_dentry) {
+		err = -EINVAL;
+		goto out_err_unlock;
+	}
+	/* target should not be ancenstor of source */
+	if (trap == lower_new_dentry) {
+		err = -ENOTEMPTY;
+		goto out_err_unlock;
+	}
+	err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
+			 lower_new_dir_dentry->d_inode, lower_new_dentry);
+out_err_unlock:
+	if (!err) {
+		/* update parent dir times */
+		fsstack_copy_attr_times(old_dir, lower_old_dir_dentry->d_inode);
+		fsstack_copy_attr_times(new_dir, lower_new_dir_dentry->d_inode);
+	}
+	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	lockdep_on();
+
+	dput(lower_old_dir_dentry);
+	dput(lower_new_dir_dentry);
+	dput(lower_old_dentry);
+	dput(lower_new_dentry);
+
+out:
+	if (!err) {
+		/* Fixup the new_dentry. */
+		if (bindex < dbstart(new_dentry))
+			dbstart(new_dentry) = bindex;
+		else if (bindex > dbend(new_dentry))
+			dbend(new_dentry) = bindex;
+	}
+
+	return err;
+}
+
+/*
+ * Main rename code.  This is sufficiently complex, that it's documented in
+ * Documentation/filesystems/unionfs/rename.txt.  This routine calls
+ * __unionfs_rename() above to perform some of the work.
+ */
+static int do_unionfs_rename(struct inode *old_dir,
+			     struct dentry *old_dentry,
+			     struct inode *new_dir,
+			     struct dentry *new_dentry)
+{
+	int err = 0;
+	int bindex, bwh_old;
+	int old_bstart, old_bend;
+	int new_bstart, new_bend;
+	int do_copyup = -1;
+	struct dentry *parent_dentry;
+	int local_err = 0;
+	int eio = 0;
+	int revert = 0;
+
+	old_bstart = dbstart(old_dentry);
+	bwh_old = old_bstart;
+	old_bend = dbend(old_dentry);
+	parent_dentry = old_dentry->d_parent;
+
+	new_bstart = dbstart(new_dentry);
+	new_bend = dbend(new_dentry);
+
+	/* Rename source to destination. */
+	err = __unionfs_rename(old_dir, old_dentry, new_dir, new_dentry,
+			       old_bstart);
+	if (err) {
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+		do_copyup = old_bstart - 1;
+	} else {
+		revert = 1;
+	}
+
+	/*
+	 * Unlink all instances of destination that exist to the left of
+	 * bstart of source. On error, revert back, goto out.
+	 */
+	for (bindex = old_bstart - 1; bindex >= new_bstart; bindex--) {
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		BUG_ON(bindex < 0);
+		unlink_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
+		if (!unlink_dentry)
+			continue;
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		err = is_robranch_super(old_dir->i_sb, bindex);
+		if (!err)
+			err = vfs_unlink(unlink_dir_dentry->d_inode,
+					 unlink_dentry);
+
+		fsstack_copy_attr_times(new_dentry->d_parent->d_inode,
+					unlink_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		new_dentry->d_parent->d_inode->i_nlink =
+			unionfs_get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+		if (!err) {
+			if (bindex != new_bstart) {
+				dput(unlink_dentry);
+				unionfs_set_lower_dentry_idx(new_dentry,
+							     bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			do_copyup = bindex - 1;
+		} else if (revert) {
+			goto revert;
+		}
+	}
+
+	if (do_copyup != -1) {
+		for (bindex = do_copyup; bindex >= 0; bindex--) {
+			/*
+			 * copyup the file into some left directory, so that
+			 * you can rename it
+			 */
+			err = copyup_dentry(old_dentry->d_parent->d_inode,
+					    old_dentry, old_bstart, bindex,
+					    old_dentry->d_name.name,
+					    old_dentry->d_name.len, NULL,
+					    i_size_read(old_dentry->d_inode));
+			/* if copyup failed, try next branch to the left */
+			if (err)
+				continue;
+			bwh_old = bindex;
+			err = __unionfs_rename(old_dir, old_dentry,
+					       new_dir, new_dentry,
+					       bindex);
+			break;
+		}
+	}
+
+	/* make it opaque */
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+		err = make_dir_opaque(old_dentry, dbstart(old_dentry));
+		if (err)
+			goto revert;
+	}
+
+	/*
+	 * Create whiteout for source, only if:
+	 * (1) There is more than one underlying instance of source.
+	 * (2) We did a copy_up
+	 */
+	if ((old_bstart != old_bend) || (do_copyup != -1)) {
+		if (bwh_old < 0) {
+			printk(KERN_ERR "unionfs: rename error (bwh_old=%d)\n",
+			       bwh_old);
+			err = -EIO;
+			goto out;
+		}
+		err = create_whiteout(old_dentry, bwh_old);
+		if (err) {
+			/* can't fix anything now, so we exit with -EIO */
+			printk(KERN_ERR "unionfs: can't create a whiteout for "
+			       "%s in rename!\n", old_dentry->d_name.name);
+			err = -EIO;
+		}
+	}
+
+out:
+	return err;
+
+revert:
+	/* Do revert here. */
+	local_err = unionfs_refresh_lower_dentry(new_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the new refresh failed\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_lower_dentry(old_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the old refresh failed\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (!unionfs_lower_dentry_idx(new_dentry, bindex) ||
+	    !unionfs_lower_dentry_idx(new_dentry, bindex)->d_inode) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the object disappeared from under us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (unionfs_lower_dentry_idx(old_dentry, bindex) &&
+	    unionfs_lower_dentry_idx(old_dentry, bindex)->d_inode) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the object was created underneath us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	local_err = __unionfs_rename(new_dir, new_dentry,
+				     old_dir, old_dentry, old_bstart);
+
+	/* If we can't fix it, then we cop-out with -EIO. */
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename!\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_lower_dentry(new_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+	local_err = unionfs_refresh_lower_dentry(old_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+
+revert_out:
+	if (eio)
+		err = eio;
+	return err;
+}
+
+/*
+ * We can't copyup a directory, because it may involve huge numbers of
+ * children, etc.  Doing that in the kernel would be bad, so instead we
+ * return EXDEV to the user-space utility that caused this, and let the
+ * user-space recurse and ask us to copy up each file separately.
+ */
+static int may_rename_dir(struct dentry *dentry)
+{
+	int err, bstart;
+
+	err = check_empty(dentry, NULL);
+	if (err == -ENOTEMPTY) {
+		if (is_robranch(dentry))
+			return -EXDEV;
+	} else if (err) {
+		return err;
+	}
+
+	bstart = dbstart(dentry);
+	if (dbend(dentry) == bstart || dbopaque(dentry) == bstart)
+		return 0;
+
+	dbstart(dentry) = bstart + 1;
+	err = check_empty(dentry, NULL);
+	dbstart(dentry) = bstart;
+	if (err == -ENOTEMPTY)
+		err = -EXDEV;
+	return err;
+}
+
+int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *wh_dentry;
+
+	unionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_double_lock_dentry(old_dentry, new_dentry);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(old_dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (unlikely(!d_deleted(new_dentry) && new_dentry->d_inode &&
+		     !__unionfs_d_revalidate_chain(new_dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	if (!S_ISDIR(old_dentry->d_inode->i_mode))
+		err = unionfs_partial_lookup(old_dentry);
+	else
+		err = may_rename_dir(old_dentry);
+
+	if (err)
+		goto out;
+
+	err = unionfs_partial_lookup(new_dentry);
+	if (err)
+		goto out;
+
+	/*
+	 * if new_dentry is already lower because of whiteout,
+	 * simply override it even if the whited-out dir is not empty.
+	 */
+	wh_dentry = find_first_whiteout(new_dentry);
+	if (!IS_ERR(wh_dentry)) {
+		dput(wh_dentry);
+	} else if (new_dentry->d_inode) {
+		if (S_ISDIR(old_dentry->d_inode->i_mode) !=
+		    S_ISDIR(new_dentry->d_inode->i_mode)) {
+			err = S_ISDIR(old_dentry->d_inode->i_mode) ?
+				-ENOTDIR : -EISDIR;
+			goto out;
+		}
+
+		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
+			struct unionfs_dir_state *namelist = NULL;
+			/* check if this unionfs directory is empty or not */
+			err = check_empty(new_dentry, &namelist);
+			if (err)
+				goto out;
+
+			if (!is_robranch(new_dentry))
+				err = delete_whiteouts(new_dentry,
+						       dbstart(new_dentry),
+						       namelist);
+
+			free_rdstate(namelist);
+
+			if (err)
+				goto out;
+		}
+	}
+
+	err = do_unionfs_rename(old_dir, old_dentry, new_dir, new_dentry);
+	if (err)
+		goto out;
+
+	/*
+	 * force re-lookup since the dir on ro branch is not renamed, and
+	 * lower dentries still indicate the un-renamed ones.
+	 */
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		atomic_dec(&UNIONFS_D(old_dentry)->generation);
+	else
+		unionfs_postcopyup_release(old_dentry);
+	if (new_dentry->d_inode && !S_ISDIR(new_dentry->d_inode->i_mode)) {
+		unionfs_postcopyup_release(new_dentry);
+		unionfs_postcopyup_setmnt(new_dentry);
+		if (!unionfs_lower_inode(new_dentry->d_inode)) {
+			/*
+			 * If we get here, it means that no copyup was
+			 * needed, and that a file by the old name already
+			 * existing on the destination branch; that file got
+			 * renamed earlier in this function, so all we need
+			 * to do here is set the lower inode.
+			 */
+			struct inode *inode;
+			inode = unionfs_lower_inode(old_dentry->d_inode);
+			igrab(inode);
+			unionfs_set_lower_inode_idx(new_dentry->d_inode,
+						    dbstart(new_dentry),
+						    inode);
+		}
+	}
+	/* if all of this renaming succeeded, update our times */
+	unionfs_copy_attr_times(old_dentry->d_inode);
+	unionfs_copy_attr_times(new_dentry->d_inode);
+	unionfs_check_inode(old_dir);
+	unionfs_check_inode(new_dir);
+	unionfs_check_dentry(old_dentry);
+	unionfs_check_dentry(new_dentry);
+
+out:
+	if (err)		/* clear the new_dentry stuff created */
+		d_drop(new_dentry);
+	unionfs_unlock_dentry(new_dentry);
+	unionfs_unlock_dentry(old_dentry);
+	unionfs_read_unlock(old_dentry->d_sb);
+	return err;
+}
diff --git a/fs/unionfs/sioq.c b/fs/unionfs/sioq.c
new file mode 100644
index 0000000..dd45e39
--- /dev/null
+++ b/fs/unionfs/sioq.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2006-2008 Erez Zadok
+ * Copyright (c) 2006      Charles P. Wright
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006      Junjiro Okajima
+ * Copyright (c) 2006      David P. Quigley
+ * Copyright (c) 2006-2008 Stony Brook University
+ * Copyright (c) 2006-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Super-user IO work Queue - sometimes we need to perform actions which
+ * would fail due to the unix permissions on the parent directory (e.g.,
+ * rmdir a directory which appears empty, but in reality contains
+ * whiteouts).
+ */
+
+static struct workqueue_struct *superio_workqueue;
+
+int __init init_sioq(void)
+{
+	int err;
+
+	superio_workqueue = create_workqueue("unionfs_siod");
+	if (!IS_ERR(superio_workqueue))
+		return 0;
+
+	err = PTR_ERR(superio_workqueue);
+	printk(KERN_ERR "unionfs: create_workqueue failed %d\n", err);
+	superio_workqueue = NULL;
+	return err;
+}
+
+void stop_sioq(void)
+{
+	if (superio_workqueue)
+		destroy_workqueue(superio_workqueue);
+}
+
+void run_sioq(work_func_t func, struct sioq_args *args)
+{
+	INIT_WORK(&args->work, func);
+
+	init_completion(&args->comp);
+	while (!queue_work(superio_workqueue, &args->work)) {
+		/* TODO: do accounting if needed */
+		schedule();
+	}
+	wait_for_completion(&args->comp);
+}
+
+void __unionfs_create(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct create_args *c = &args->create;
+
+	args->err = vfs_create(c->parent, c->dentry, c->mode, c->nd);
+	complete(&args->comp);
+}
+
+void __unionfs_mkdir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct mkdir_args *m = &args->mkdir;
+
+	args->err = vfs_mkdir(m->parent, m->dentry, m->mode);
+	complete(&args->comp);
+}
+
+void __unionfs_mknod(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct mknod_args *m = &args->mknod;
+
+	args->err = vfs_mknod(m->parent, m->dentry, m->mode, m->dev);
+	complete(&args->comp);
+}
+
+void __unionfs_symlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct symlink_args *s = &args->symlink;
+
+	args->err = vfs_symlink(s->parent, s->dentry, s->symbuf);
+	complete(&args->comp);
+}
+
+void __unionfs_unlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct unlink_args *u = &args->unlink;
+
+	args->err = vfs_unlink(u->parent, u->dentry);
+	complete(&args->comp);
+}
diff --git a/fs/unionfs/sioq.h b/fs/unionfs/sioq.h
new file mode 100644
index 0000000..679a0df
--- /dev/null
+++ b/fs/unionfs/sioq.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2006-2008 Erez Zadok
+ * Copyright (c) 2006      Charles P. Wright
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006      Junjiro Okajima
+ * Copyright (c) 2006      David P. Quigley
+ * Copyright (c) 2006-2008 Stony Brook University
+ * Copyright (c) 2006-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _SIOQ_H
+#define _SIOQ_H
+
+struct deletewh_args {
+	struct unionfs_dir_state *namelist;
+	struct dentry *dentry;
+	int bindex;
+};
+
+struct is_opaque_args {
+	struct dentry *dentry;
+};
+
+struct create_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	struct nameidata *nd;
+};
+
+struct mkdir_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+};
+
+struct mknod_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	dev_t dev;
+};
+
+struct symlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	char *symbuf;
+};
+
+struct unlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+};
+
+
+struct sioq_args {
+	struct completion comp;
+	struct work_struct work;
+	int err;
+	void *ret;
+
+	union {
+		struct deletewh_args deletewh;
+		struct is_opaque_args is_opaque;
+		struct create_args create;
+		struct mkdir_args mkdir;
+		struct mknod_args mknod;
+		struct symlink_args symlink;
+		struct unlink_args unlink;
+	};
+};
+
+/* Extern definitions for SIOQ functions */
+extern int __init init_sioq(void);
+extern void stop_sioq(void);
+extern void run_sioq(work_func_t func, struct sioq_args *args);
+
+/* Extern definitions for our privilege escalation helpers */
+extern void __unionfs_create(struct work_struct *work);
+extern void __unionfs_mkdir(struct work_struct *work);
+extern void __unionfs_mknod(struct work_struct *work);
+extern void __unionfs_symlink(struct work_struct *work);
+extern void __unionfs_unlink(struct work_struct *work);
+extern void __delete_whiteouts(struct work_struct *work);
+extern void __is_opaque_dir(struct work_struct *work);
+
+#endif /* not _SIOQ_H */
diff --git a/fs/unionfs/subr.c b/fs/unionfs/subr.c
new file mode 100644
index 0000000..8747d20
--- /dev/null
+++ b/fs/unionfs/subr.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * returns the right n_link value based on the inode type
+ */
+int unionfs_get_nlinks(const struct inode *inode)
+{
+	/* don't bother to do all the work since we're unlinked */
+	if (inode->i_nlink == 0)
+		return 0;
+
+	if (!S_ISDIR(inode->i_mode))
+		return unionfs_lower_inode(inode)->i_nlink;
+
+	/*
+	 * For directories, we return 1. The only place that could cares
+	 * about links is readdir, and there's d_type there so even that
+	 * doesn't matter.
+	 */
+	return 1;
+}
+
+/* copy a/m/ctime from the lower branch with the newest times */
+void unionfs_copy_attr_times(struct inode *upper)
+{
+	int bindex;
+	struct inode *lower;
+
+	if (!upper)
+		return;
+	if (ibstart(upper) < 0) {
+#ifdef CONFIG_UNION_FS_DEBUG
+		WARN_ON(ibstart(upper) < 0);
+#endif /* CONFIG_UNION_FS_DEBUG */
+		return;
+	}
+	for (bindex = ibstart(upper); bindex <= ibend(upper); bindex++) {
+		lower = unionfs_lower_inode_idx(upper, bindex);
+		if (!lower)
+			continue; /* not all lower dir objects may exist */
+		if (unlikely(timespec_compare(&upper->i_mtime,
+					      &lower->i_mtime) < 0))
+			upper->i_mtime = lower->i_mtime;
+		if (unlikely(timespec_compare(&upper->i_ctime,
+					      &lower->i_ctime) < 0))
+			upper->i_ctime = lower->i_ctime;
+		if (unlikely(timespec_compare(&upper->i_atime,
+					      &lower->i_atime) < 0))
+			upper->i_atime = lower->i_atime;
+	}
+}
+
+/*
+ * A unionfs/fanout version of fsstack_copy_attr_all.  Uses a
+ * unionfs_get_nlinks to properly calcluate the number of links to a file.
+ * Also, copies the max() of all a/m/ctimes for all lower inodes (which is
+ * important if the lower inode is a directory type)
+ */
+void unionfs_copy_attr_all(struct inode *dest,
+			   const struct inode *src)
+{
+	dest->i_mode = src->i_mode;
+	dest->i_uid = src->i_uid;
+	dest->i_gid = src->i_gid;
+	dest->i_rdev = src->i_rdev;
+
+	unionfs_copy_attr_times(dest);
+
+	dest->i_blkbits = src->i_blkbits;
+	dest->i_flags = src->i_flags;
+
+	/*
+	 * Update the nlinks AFTER updating the above fields, because the
+	 * get_links callback may depend on them.
+	 */
+	dest->i_nlink = unionfs_get_nlinks(dest);
+}
diff --git a/fs/unionfs/super.c b/fs/unionfs/super.c
new file mode 100644
index 0000000..e774ef3
--- /dev/null
+++ b/fs/unionfs/super.c
@@ -0,0 +1,1042 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * The inode cache is used with alloc_inode for both our inode info and the
+ * vfs inode.
+ */
+static struct kmem_cache *unionfs_inode_cachep;
+
+struct inode *unionfs_iget(struct super_block *sb, unsigned long ino)
+{
+	int size;
+	struct unionfs_inode_info *info;
+	struct inode *inode;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	info = UNIONFS_I(inode);
+	memset(info, 0, offsetof(struct unionfs_inode_info, vfs_inode));
+	info->bstart = -1;
+	info->bend = -1;
+	atomic_set(&info->generation,
+		   atomic_read(&UNIONFS_SB(inode->i_sb)->generation));
+	spin_lock_init(&info->rdlock);
+	info->rdcount = 1;
+	info->hashsize = -1;
+	INIT_LIST_HEAD(&info->readdircache);
+
+	size = sbmax(inode->i_sb) * sizeof(struct inode *);
+	info->lower_inodes = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!info->lower_inodes)) {
+		printk(KERN_CRIT "unionfs: no kernel memory when allocating "
+		       "lower-pointer array!\n");
+		iget_failed(inode);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	inode->i_version++;
+	inode->i_op = &unionfs_main_iops;
+	inode->i_fop = &unionfs_main_fops;
+
+	inode->i_mapping->a_ops = &unionfs_aops;
+
+	/*
+	 * reset times so unionfs_copy_attr_all can keep out time invariants
+	 * right (upper inode time being the max of all lower ones).
+	 */
+	inode->i_atime.tv_sec = inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_sec = inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_sec = inode->i_ctime.tv_nsec = 0;
+	unlock_new_inode(inode);
+	return inode;
+}
+
+/*
+ * we now define delete_inode, because there are two VFS paths that may
+ * destroy an inode: one of them calls clear inode before doing everything
+ * else that's needed, and the other is fine.  This way we truncate the inode
+ * size (and its pages) and then clear our own inode, which will do an iput
+ * on our and the lower inode.
+ *
+ * No need to lock sb info's rwsem.
+ */
+static void unionfs_delete_inode(struct inode *inode)
+{
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	spin_lock(&inode->i_lock);
+#endif
+	i_size_write(inode, 0);	/* every f/s seems to do that */
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	spin_unlock(&inode->i_lock);
+#endif
+
+	if (inode->i_data.nrpages)
+		truncate_inode_pages(&inode->i_data, 0);
+
+	clear_inode(inode);
+}
+
+/*
+ * final actions when unmounting a file system
+ *
+ * No need to lock rwsem.
+ */
+static void unionfs_put_super(struct super_block *sb)
+{
+	int bindex, bstart, bend;
+	struct unionfs_sb_info *spd;
+	int leaks = 0;
+
+	spd = UNIONFS_SB(sb);
+	if (!spd)
+		return;
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	/* Make sure we have no leaks of branchget/branchput. */
+	for (bindex = bstart; bindex <= bend; bindex++)
+		if (unlikely(branch_count(sb, bindex) != 0)) {
+			printk(KERN_CRIT
+			       "unionfs: branch %d has %d references left!\n",
+			       bindex, branch_count(sb, bindex));
+			leaks = 1;
+		}
+	BUG_ON(leaks != 0);
+
+	/* decrement lower super references */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct super_block *s;
+		s = unionfs_lower_super_idx(sb, bindex);
+		unionfs_set_lower_super_idx(sb, bindex, NULL);
+		atomic_dec(&s->s_active);
+	}
+
+	kfree(spd->dev_name);
+	kfree(spd->data);
+	kfree(spd);
+	sb->s_fs_info = NULL;
+}
+
+/*
+ * Since people use this to answer the "How big of a file can I write?"
+ * question, we report the size of the highest priority branch as the size of
+ * the union.
+ */
+static int unionfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	int err	= 0;
+	struct super_block *sb;
+	struct dentry *lower_dentry;
+
+	sb = dentry->d_sb;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	lower_dentry = unionfs_lower_dentry(sb->s_root);
+	err = vfs_statfs(lower_dentry, buf);
+
+	/* set return buf to our f/s to avoid confusing user-level utils */
+	buf->f_type = UNIONFS_SUPER_MAGIC;
+	/*
+	 * Our maximum file name can is shorter by a few bytes because every
+	 * file name could potentially be whited-out.
+	 *
+	 * XXX: this restriction goes away with ODF.
+	 */
+	unionfs_set_max_namelen(&buf->f_namelen);
+
+	/*
+	 * reset two fields to avoid confusing user-land.
+	 * XXX: is this still necessary?
+	 */
+	memset(&buf->f_fsid, 0, sizeof(__kernel_fsid_t));
+	memset(&buf->f_spare, 0, sizeof(buf->f_spare));
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(sb);
+	return err;
+}
+
+/* handle mode changing during remount */
+static noinline_for_stack int do_remount_mode_option(
+					char *optarg,
+					int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths)
+{
+	int err = -EINVAL;
+	int perms, idx;
+	char *modename = strchr(optarg, '=');
+	struct nameidata nd;
+
+	/* by now, optarg contains the branch name */
+	if (!*optarg) {
+		printk(KERN_ERR
+		       "unionfs: no branch specified for mode change\n");
+		goto out;
+	}
+	if (!modename) {
+		printk(KERN_ERR "unionfs: branch \"%s\" requires a mode\n",
+		       optarg);
+		goto out;
+	}
+	*modename++ = '\0';
+	err = parse_branch_mode(modename, &perms);
+	if (err) {
+		printk(KERN_ERR "unionfs: invalid mode \"%s\" for \"%s\"\n",
+		       modename, optarg);
+		goto out;
+	}
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		err = -ENOENT;	/* err may have been reset above */
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		goto out;
+	}
+	/* check/change mode for existing branch */
+	/* we don't warn if perms==branchperms */
+	new_data[idx].branchperms = perms;
+	err = 0;
+out:
+	return err;
+}
+
+/* handle branch deletion during remount */
+static noinline_for_stack int do_remount_del_option(
+					char *optarg, int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths)
+{
+	int err = -EINVAL;
+	int idx;
+	struct nameidata nd;
+
+	/* optarg contains the branch name to delete */
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		err = -ENOENT;
+		goto out;
+	}
+	/* check if there are any open files on the branch to be deleted */
+	if (atomic_read(&new_data[idx].open_files) > 0) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * Now we have to delete the branch.  First, release any handles it
+	 * has.  Then, move the remaining array indexes past "idx" in
+	 * new_data and new_lower_paths one to the left.  Finally, adjust
+	 * cur_branches.
+	 */
+	path_put(&new_lower_paths[idx]);
+
+	if (idx < cur_branches - 1) {
+		/* if idx==cur_branches-1, we delete last branch: easy */
+		memmove(&new_data[idx], &new_data[idx+1],
+			(cur_branches - 1 - idx) *
+			sizeof(struct unionfs_data));
+		memmove(&new_lower_paths[idx], &new_lower_paths[idx+1],
+			(cur_branches - 1 - idx) * sizeof(struct path));
+	}
+
+	err = 0;
+out:
+	return err;
+}
+
+/* handle branch insertion during remount */
+static noinline_for_stack int do_remount_add_option(
+					char *optarg, int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths,
+					int *high_branch_id)
+{
+	int err = -EINVAL;
+	int perms;
+	int idx = 0;		/* default: insert at beginning */
+	char *new_branch , *modename = NULL;
+	struct nameidata nd;
+
+	/*
+	 * optarg can be of several forms:
+	 *
+	 * /bar:/foo		insert /foo before /bar
+	 * /bar:/foo=ro		insert /foo in ro mode before /bar
+	 * /foo			insert /foo in the beginning (prepend)
+	 * :/foo		insert /foo at the end (append)
+	 */
+	if (*optarg == ':') {	/* append? */
+		new_branch = optarg + 1; /* skip ':' */
+		idx = cur_branches;
+		goto found_insertion_point;
+	}
+	new_branch = strchr(optarg, ':');
+	if (!new_branch) {	/* prepend? */
+		new_branch = optarg;
+		goto found_insertion_point;
+	}
+	*new_branch++ = '\0';	/* holds path+mode of new branch */
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		err = -ENOENT;
+		goto out;
+	}
+
+	/*
+	 * At this point idx will hold the index where the new branch should
+	 * be inserted before.
+	 */
+found_insertion_point:
+	/* find the mode for the new branch */
+	if (new_branch)
+		modename = strchr(new_branch, '=');
+	if (modename)
+		*modename++ = '\0';
+	if (!new_branch || !*new_branch) {
+		printk(KERN_ERR "unionfs: null new branch\n");
+		err = -EINVAL;
+		goto out;
+	}
+	err = parse_branch_mode(modename, &perms);
+	if (err) {
+		printk(KERN_ERR "unionfs: invalid mode \"%s\" for "
+		       "branch \"%s\"\n", modename, new_branch);
+		goto out;
+	}
+	err = path_lookup(new_branch, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       new_branch, err);
+		goto out;
+	}
+	/*
+	 * It's probably safe to check_mode the new branch to insert.  Note:
+	 * we don't allow inserting branches which are unionfs's by
+	 * themselves (check_branch returns EINVAL in that case).  This is
+	 * because this code base doesn't support stacking unionfs: the ODF
+	 * code base supports that correctly.
+	 */
+	err = check_branch(&nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: lower directory "
+		       "\"%s\" is not a valid branch\n", optarg);
+		path_put(&nd.path);
+		goto out;
+	}
+
+	/*
+	 * Now we have to insert the new branch.  But first, move the bits
+	 * to make space for the new branch, if needed.  Finally, adjust
+	 * cur_branches.
+	 * We don't release nd here; it's kept until umount/remount.
+	 */
+	if (idx < cur_branches) {
+		/* if idx==cur_branches, we append: easy */
+		memmove(&new_data[idx+1], &new_data[idx],
+			(cur_branches - idx) * sizeof(struct unionfs_data));
+		memmove(&new_lower_paths[idx+1], &new_lower_paths[idx],
+			(cur_branches - idx) * sizeof(struct path));
+	}
+	new_lower_paths[idx].dentry = nd.path.dentry;
+	new_lower_paths[idx].mnt = nd.path.mnt;
+
+	new_data[idx].sb = nd.path.dentry->d_sb;
+	atomic_set(&new_data[idx].open_files, 0);
+	new_data[idx].branchperms = perms;
+	new_data[idx].branch_id = ++*high_branch_id; /* assign new branch ID */
+
+	err = 0;
+out:
+	return err;
+}
+
+
+/*
+ * Support branch management options on remount.
+ *
+ * See Documentation/filesystems/unionfs/ for details.
+ *
+ * @flags: numeric mount options
+ * @options: mount options string
+ *
+ * This function can rearrange a mounted union dynamically, adding and
+ * removing branches, including changing branch modes.  Clearly this has to
+ * be done safely and atomically.  Luckily, the VFS already calls this
+ * function with lock_super(sb) and lock_kernel() held, preventing
+ * concurrent mixing of new mounts, remounts, and unmounts.  Moreover,
+ * do_remount_sb(), our caller function, already called shrink_dcache_sb(sb)
+ * to purge dentries/inodes from our superblock, and also called
+ * fsync_super(sb) to purge any dirty pages.  So we're good.
+ *
+ * XXX: however, our remount code may also need to invalidate mapped pages
+ * so as to force them to be re-gotten from the (newly reconfigured) lower
+ * branches.  This has to wait for proper mmap and cache coherency support
+ * in the VFS.
+ *
+ */
+static int unionfs_remount_fs(struct super_block *sb, int *flags,
+			      char *options)
+{
+	int err = 0;
+	int i;
+	char *optionstmp, *tmp_to_free;	/* kstrdup'ed of "options" */
+	char *optname;
+	int cur_branches = 0;	/* no. of current branches */
+	int new_branches = 0;	/* no. of branches actually left in the end */
+	int add_branches;	/* est. no. of branches to add */
+	int del_branches;	/* est. no. of branches to del */
+	int max_branches;	/* max possible no. of branches */
+	struct unionfs_data *new_data = NULL, *tmp_data = NULL;
+	struct path *new_lower_paths = NULL, *tmp_lower_paths = NULL;
+	struct inode **new_lower_inodes = NULL;
+	int new_high_branch_id;	/* new high branch ID */
+	int size;		/* memory allocation size, temp var */
+	int old_ibstart, old_ibend;
+
+	unionfs_write_lock(sb);
+
+	/*
+	 * The VFS will take care of "ro" and "rw" flags, and we can safely
+	 * ignore MS_SILENT, but anything else left over is an error.  So we
+	 * need to check if any other flags may have been passed (none are
+	 * allowed/supported as of now).
+	 */
+	if ((*flags & ~(MS_RDONLY | MS_SILENT)) != 0) {
+		printk(KERN_ERR
+		       "unionfs: remount flags 0x%x unsupported\n", *flags);
+		err = -EINVAL;
+		goto out_error;
+	}
+
+	/*
+	 * If 'options' is NULL, it's probably because the user just changed
+	 * the union to a "ro" or "rw" and the VFS took care of it.  So
+	 * nothing to do and we're done.
+	 */
+	if (!options || options[0] == '\0')
+		goto out_error;
+
+	/*
+	 * Find out how many branches we will have in the end, counting
+	 * "add" and "del" commands.  Copy the "options" string because
+	 * strsep modifies the string and we need it later.
+	 */
+	tmp_to_free = kstrdup(options, GFP_KERNEL);
+	optionstmp = tmp_to_free;
+	if (unlikely(!optionstmp)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	cur_branches = sbmax(sb); /* current no. branches */
+	new_branches = sbmax(sb);
+	del_branches = 0;
+	add_branches = 0;
+	new_high_branch_id = sbhbid(sb); /* save current high_branch_id */
+	while ((optname = strsep(&optionstmp, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+
+		if (!strcmp("add", optname))
+			add_branches++;
+		else if (!strcmp("del", optname))
+			del_branches++;
+	}
+	kfree(tmp_to_free);
+	/* after all changes, will we have at least one branch left? */
+	if ((new_branches + add_branches - del_branches) < 1) {
+		printk(KERN_ERR
+		       "unionfs: no branches left after remount\n");
+		err = -EINVAL;
+		goto out_free;
+	}
+
+	/*
+	 * Since we haven't actually parsed all the add/del options, nor
+	 * have we checked them for errors, we don't know for sure how many
+	 * branches we will have after all changes have taken place.  In
+	 * fact, the total number of branches left could be less than what
+	 * we have now.  So we need to allocate space for a temporary
+	 * placeholder that is at least as large as the maximum number of
+	 * branches we *could* have, which is the current number plus all
+	 * the additions.  Once we're done with these temp placeholders, we
+	 * may have to re-allocate the final size, copy over from the temp,
+	 * and then free the temps (done near the end of this function).
+	 */
+	max_branches = cur_branches + add_branches;
+	/* allocate space for new pointers to lower dentry */
+	tmp_data = kcalloc(max_branches,
+			   sizeof(struct unionfs_data), GFP_KERNEL);
+	if (unlikely(!tmp_data)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	/* allocate space for new pointers to lower paths */
+	tmp_lower_paths = kcalloc(max_branches,
+				  sizeof(struct path), GFP_KERNEL);
+	if (unlikely(!tmp_lower_paths)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	/* copy current info into new placeholders, incrementing refcnts */
+	memcpy(tmp_data, UNIONFS_SB(sb)->data,
+	       cur_branches * sizeof(struct unionfs_data));
+	memcpy(tmp_lower_paths, UNIONFS_D(sb->s_root)->lower_paths,
+	       cur_branches * sizeof(struct path));
+	for (i = 0; i < cur_branches; i++)
+		path_get(&tmp_lower_paths[i]); /* drop refs at end of fxn */
+
+	/*******************************************************************
+	 * For each branch command, do path_lookup on the requested branch,
+	 * and apply the change to a temp branch list.  To handle errors, we
+	 * already dup'ed the old arrays (above), and increased the refcnts
+	 * on various f/s objects.  So now we can do all the path_lookups
+	 * and branch-management commands on the new arrays.  If it fail mid
+	 * way, we free the tmp arrays and *put all objects.  If we succeed,
+	 * then we free old arrays and *put its objects, and then replace
+	 * the arrays with the new tmp list (we may have to re-allocate the
+	 * memory because the temp lists could have been larger than what we
+	 * actually needed).
+	 *******************************************************************/
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+		/*
+		 * At this stage optname holds a comma-delimited option, but
+		 * without the commas.  Next, we need to break the string on
+		 * the '=' symbol to separate CMD=ARG, where ARG itself can
+		 * be KEY=VAL.  For example, in mode=/foo=rw, CMD is "mode",
+		 * KEY is "/foo", and VAL is "rw".
+		 */
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+		/* incgen remount option (instead of old ioctl) */
+		if (!strcmp("incgen", optname)) {
+			err = 0;
+			goto out_no_change;
+		}
+
+		/*
+		 * All of our options take an argument now.  (Insert ones
+		 * that don't above this check.)  So at this stage optname
+		 * contains the CMD part and optarg contains the ARG part.
+		 */
+		if (!optarg || !*optarg) {
+			printk(KERN_ERR "unionfs: all remount options require "
+			       "an argument (%s)\n", optname);
+			err = -EINVAL;
+			goto out_release;
+		}
+
+		if (!strcmp("add", optname)) {
+			err = do_remount_add_option(optarg, new_branches,
+						    tmp_data,
+						    tmp_lower_paths,
+						    &new_high_branch_id);
+			if (err)
+				goto out_release;
+			new_branches++;
+			if (new_branches > UNIONFS_MAX_BRANCHES) {
+				printk(KERN_ERR "unionfs: command exceeds "
+				       "%d branches\n", UNIONFS_MAX_BRANCHES);
+				err = -E2BIG;
+				goto out_release;
+			}
+			continue;
+		}
+		if (!strcmp("del", optname)) {
+			err = do_remount_del_option(optarg, new_branches,
+						    tmp_data,
+						    tmp_lower_paths);
+			if (err)
+				goto out_release;
+			new_branches--;
+			continue;
+		}
+		if (!strcmp("mode", optname)) {
+			err = do_remount_mode_option(optarg, new_branches,
+						     tmp_data,
+						     tmp_lower_paths);
+			if (err)
+				goto out_release;
+			continue;
+		}
+
+		/*
+		 * When you use "mount -o remount,ro", mount(8) will
+		 * reportedly pass the original dirs= string from
+		 * /proc/mounts.  So for now, we have to ignore dirs= and
+		 * not consider it an error, unless we want to allow users
+		 * to pass dirs= in remount.  Note that to allow the VFS to
+		 * actually process the ro/rw remount options, we have to
+		 * return 0 from this function.
+		 */
+		if (!strcmp("dirs", optname)) {
+			printk(KERN_WARNING
+			       "unionfs: remount ignoring option \"%s\"\n",
+			       optname);
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_ERR
+		       "unionfs: unrecognized option \"%s\"\n", optname);
+		goto out_release;
+	}
+
+out_no_change:
+
+	/******************************************************************
+	 * WE'RE ALMOST DONE: check if leftmost branch might be read-only,
+	 * see if we need to allocate a small-sized new vector, copy the
+	 * vectors to their correct place, release the refcnt of the older
+	 * ones, and return.  Also handle invalidating any pages that will
+	 * have to be re-read.
+	 *******************************************************************/
+
+	if (!(tmp_data[0].branchperms & MAY_WRITE)) {
+		printk(KERN_ERR "unionfs: leftmost branch cannot be read-only "
+		       "(use \"remount,ro\" to create a read-only union)\n");
+		err = -EINVAL;
+		goto out_release;
+	}
+
+	/* (re)allocate space for new pointers to lower dentry */
+	size = new_branches * sizeof(struct unionfs_data);
+	new_data = krealloc(tmp_data, size, GFP_KERNEL);
+	if (unlikely(!new_data)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/* allocate space for new pointers to lower paths */
+	size = new_branches * sizeof(struct path);
+	new_lower_paths = krealloc(tmp_lower_paths, size, GFP_KERNEL);
+	if (unlikely(!new_lower_paths)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/* allocate space for new pointers to lower inodes */
+	new_lower_inodes = kcalloc(new_branches,
+				   sizeof(struct inode *), GFP_KERNEL);
+	if (unlikely(!new_lower_inodes)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/*
+	 * OK, just before we actually put the new set of branches in place,
+	 * we need to ensure that our own f/s has no dirty objects left.
+	 * Luckily, do_remount_sb() already calls shrink_dcache_sb(sb) and
+	 * fsync_super(sb), taking care of dentries, inodes, and dirty
+	 * pages.  So all that's left is for us to invalidate any leftover
+	 * (non-dirty) pages to ensure that they will be re-read from the
+	 * new lower branches (and to support mmap).
+	 */
+
+	/*
+	 * Once we finish the remounting successfully, our superblock
+	 * generation number will have increased.  This will be detected by
+	 * our dentry-revalidation code upon subsequent f/s operations
+	 * through unionfs.  The revalidation code will rebuild the union of
+	 * lower inodes for a given unionfs inode and invalidate any pages
+	 * of such "stale" inodes (by calling our purge_inode_data
+	 * function).  This revalidation will happen lazily and
+	 * incrementally, as users perform operations on cached inodes.  We
+	 * would like to encourage this revalidation to happen sooner if
+	 * possible, so we like to try to invalidate as many other pages in
+	 * our superblock as we can.  We used to call drop_pagecache_sb() or
+	 * a variant thereof, but either method was racy (drop_caches alone
+	 * is known to be racy).  So now we let the revalidation happen on a
+	 * per file basis in ->d_revalidate.
+	 */
+
+	/* grab new lower super references; release old ones */
+	for (i = 0; i < new_branches; i++)
+		atomic_inc(&new_data[i].sb->s_active);
+	for (i = 0; i < sbmax(sb); i++)
+		atomic_dec(&UNIONFS_SB(sb)->data[i].sb->s_active);
+
+	/* copy new vectors into their correct place */
+	tmp_data = UNIONFS_SB(sb)->data;
+	UNIONFS_SB(sb)->data = new_data;
+	new_data = NULL;	/* so don't free good pointers below */
+	tmp_lower_paths = UNIONFS_D(sb->s_root)->lower_paths;
+	UNIONFS_D(sb->s_root)->lower_paths = new_lower_paths;
+	new_lower_paths = NULL;	/* so don't free good pointers below */
+
+	/* update our unionfs_sb_info and root dentry index of last branch */
+	i = sbmax(sb);		/* save no. of branches to release at end */
+	sbend(sb) = new_branches - 1;
+	dbend(sb->s_root) = new_branches - 1;
+	old_ibstart = ibstart(sb->s_root->d_inode);
+	old_ibend = ibend(sb->s_root->d_inode);
+	ibend(sb->s_root->d_inode) = new_branches - 1;
+	UNIONFS_D(sb->s_root)->bcount = new_branches;
+	new_branches = i; /* no. of branches to release below */
+
+	/*
+	 * Update lower inodes: 3 steps
+	 * 1. grab ref on all new lower inodes
+	 */
+	for (i = dbstart(sb->s_root); i <= dbend(sb->s_root); i++) {
+		struct dentry *lower_dentry =
+			unionfs_lower_dentry_idx(sb->s_root, i);
+		igrab(lower_dentry->d_inode);
+		new_lower_inodes[i] = lower_dentry->d_inode;
+	}
+	/* 2. release reference on all older lower inodes */
+	iput_lowers(sb->s_root->d_inode, old_ibstart, old_ibend, true);
+	/* 3. update root dentry's inode to new lower_inodes array */
+	UNIONFS_I(sb->s_root->d_inode)->lower_inodes = new_lower_inodes;
+	new_lower_inodes = NULL;
+
+	/* maxbytes may have changed */
+	sb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;
+	/* update high branch ID */
+	sbhbid(sb) = new_high_branch_id;
+
+	/* update our sb->generation for revalidating objects */
+	i = atomic_inc_return(&UNIONFS_SB(sb)->generation);
+	atomic_set(&UNIONFS_D(sb->s_root)->generation, i);
+	atomic_set(&UNIONFS_I(sb->s_root->d_inode)->generation, i);
+	if (!(*flags & MS_SILENT))
+		pr_info("unionfs: %s: new generation number %d\n",
+			UNIONFS_SB(sb)->dev_name, i);
+	/* finally, update the root dentry's times */
+	unionfs_copy_attr_times(sb->s_root->d_inode);
+	err = 0;		/* reset to success */
+
+	/*
+	 * The code above falls through to the next label, and releases the
+	 * refcnts of the older ones (stored in tmp_*): if we fell through
+	 * here, it means success.  However, if we jump directly to this
+	 * label from any error above, then an error occurred after we
+	 * grabbed various refcnts, and so we have to release the
+	 * temporarily constructed structures.
+	 */
+out_release:
+	/* no need to cleanup/release anything in tmp_data */
+	if (tmp_lower_paths)
+		for (i = 0; i < new_branches; i++)
+			path_put(&tmp_lower_paths[i]);
+out_free:
+	kfree(tmp_lower_paths);
+	kfree(tmp_data);
+	kfree(new_lower_paths);
+	kfree(new_data);
+	kfree(new_lower_inodes);
+out_error:
+	unionfs_check_dentry(sb->s_root);
+	unionfs_write_unlock(sb);
+	return err;
+}
+
+/*
+ * Called by iput() when the inode reference count reached zero
+ * and the inode is not hashed anywhere.  Used to clear anything
+ * that needs to be, before the inode is completely destroyed and put
+ * on the inode free list.
+ *
+ * No need to lock sb info's rwsem.
+ */
+static void unionfs_clear_inode(struct inode *inode)
+{
+	int bindex, bstart, bend;
+	struct inode *lower_inode;
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	list_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, cache);
+		list_del(&rdstate->cache);
+		free_rdstate(rdstate);
+	}
+
+	/*
+	 * Decrement a reference to a lower_inode, which was incremented
+	 * by our read_inode when it was created initially.
+	 */
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (bstart >= 0) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			if (!lower_inode)
+				continue;
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			iput(lower_inode);
+			lockdep_on();
+		}
+	}
+
+	kfree(UNIONFS_I(inode)->lower_inodes);
+	UNIONFS_I(inode)->lower_inodes = NULL;
+}
+
+static struct inode *unionfs_alloc_inode(struct super_block *sb)
+{
+	struct unionfs_inode_info *i;
+
+	i = kmem_cache_alloc(unionfs_inode_cachep, GFP_KERNEL);
+	if (unlikely(!i))
+		return NULL;
+
+	/* memset everything up to the inode to 0 */
+	memset(i, 0, offsetof(struct unionfs_inode_info, vfs_inode));
+
+	i->vfs_inode.i_version = 1;
+	return &i->vfs_inode;
+}
+
+static void unionfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(unionfs_inode_cachep, UNIONFS_I(inode));
+}
+
+/* unionfs inode cache constructor */
+static void init_once(void *obj)
+{
+	struct unionfs_inode_info *i = obj;
+
+	inode_init_once(&i->vfs_inode);
+}
+
+int unionfs_init_inode_cache(void)
+{
+	int err = 0;
+
+	unionfs_inode_cachep =
+		kmem_cache_create("unionfs_inode_cache",
+				  sizeof(struct unionfs_inode_info), 0,
+				  SLAB_RECLAIM_ACCOUNT, init_once);
+	if (unlikely(!unionfs_inode_cachep))
+		err = -ENOMEM;
+	return err;
+}
+
+/* unionfs inode cache destructor */
+void unionfs_destroy_inode_cache(void)
+{
+	if (unionfs_inode_cachep)
+		kmem_cache_destroy(unionfs_inode_cachep);
+}
+
+/*
+ * Called when we have a dirty inode, right here we only throw out
+ * parts of our readdir list that are too old.
+ *
+ * No need to grab sb info's rwsem.
+ */
+static int unionfs_write_inode(struct inode *inode, int sync)
+{
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	list_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, cache);
+		/* We keep this list in LRU order. */
+		if ((rdstate->access + RDCACHE_JIFFIES) > jiffies)
+			break;
+		UNIONFS_I(inode)->rdcount--;
+		list_del(&rdstate->cache);
+		free_rdstate(rdstate);
+	}
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+
+	return 0;
+}
+
+/*
+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent
+ * code can actually succeed and won't leave tasks that need handling.
+ */
+static void unionfs_umount_begin(struct super_block *sb)
+{
+	struct super_block *lower_sb;
+	int bindex, bstart, bend;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_sb = unionfs_lower_super_idx(sb, bindex);
+
+		if (lower_sb && lower_sb->s_op &&
+		    lower_sb->s_op->umount_begin)
+			lower_sb->s_op->umount_begin(lower_sb);
+	}
+
+	unionfs_read_unlock(sb);
+}
+
+static int unionfs_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct super_block *sb = mnt->mnt_sb;
+	int ret = 0;
+	char *tmp_page;
+	char *path;
+	int bindex, bstart, bend;
+	int perms;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+
+	unionfs_lock_dentry(sb->s_root, UNIONFS_DMUTEX_CHILD);
+
+	tmp_page = (char *) __get_free_page(GFP_KERNEL);
+	if (unlikely(!tmp_page)) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	seq_printf(m, ",dirs=");
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct path p;
+		p.dentry = unionfs_lower_dentry_idx(sb->s_root, bindex);
+		p.mnt = unionfs_lower_mnt_idx(sb->s_root, bindex);
+		path = d_path(&p, tmp_page, PAGE_SIZE);
+		if (IS_ERR(path)) {
+			ret = PTR_ERR(path);
+			goto out;
+		}
+
+		perms = branchperms(sb, bindex);
+
+		seq_printf(m, "%s=%s", path,
+			   perms & MAY_WRITE ? "rw" : "ro");
+		if (bindex != bend)
+			seq_printf(m, ":");
+	}
+
+out:
+	free_page((unsigned long) tmp_page);
+
+	unionfs_unlock_dentry(sb->s_root);
+
+	unionfs_read_unlock(sb);
+
+	return ret;
+}
+
+struct super_operations unionfs_sops = {
+	.delete_inode	= unionfs_delete_inode,
+	.put_super	= unionfs_put_super,
+	.statfs		= unionfs_statfs,
+	.remount_fs	= unionfs_remount_fs,
+	.clear_inode	= unionfs_clear_inode,
+	.umount_begin	= unionfs_umount_begin,
+	.show_options	= unionfs_show_options,
+	.write_inode	= unionfs_write_inode,
+	.alloc_inode	= unionfs_alloc_inode,
+	.destroy_inode	= unionfs_destroy_inode,
+};
diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h
new file mode 100644
index 0000000..4c7b213
--- /dev/null
+++ b/fs/unionfs/union.h
@@ -0,0 +1,600 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _UNION_H_
+#define _UNION_H_
+
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/namei.h>
+#include <linux/page-flags.h>
+#include <linux/pagemap.h>
+#include <linux/poll.h>
+#include <linux/security.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/statfs.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/writeback.h>
+#include <linux/buffer_head.h>
+#include <linux/xattr.h>
+#include <linux/fs_stack.h>
+#include <linux/magic.h>
+#include <linux/log2.h>
+#include <linux/poison.h>
+#include <linux/mman.h>
+#include <linux/backing-dev.h>
+#include <linux/splice.h>
+
+#include <asm/system.h>
+
+#include <linux/union_fs.h>
+
+/* the file system name */
+#define UNIONFS_NAME "unionfs"
+
+/* unionfs root inode number */
+#define UNIONFS_ROOT_INO     1
+
+/* number of times we try to get a unique temporary file name */
+#define GET_TMPNAM_MAX_RETRY	5
+
+/* maximum number of branches we support, to avoid memory blowup */
+#define UNIONFS_MAX_BRANCHES	128
+
+/* minimum time (seconds) required for time-based cache-coherency */
+#define UNIONFS_MIN_CC_TIME	3
+
+/* Operations vectors defined in specific files. */
+extern struct file_operations unionfs_main_fops;
+extern struct file_operations unionfs_dir_fops;
+extern struct inode_operations unionfs_main_iops;
+extern struct inode_operations unionfs_dir_iops;
+extern struct inode_operations unionfs_symlink_iops;
+extern struct super_operations unionfs_sops;
+extern struct dentry_operations unionfs_dops;
+extern struct address_space_operations unionfs_aops, unionfs_dummy_aops;
+extern struct vm_operations_struct unionfs_vm_ops;
+
+/* How long should an entry be allowed to persist */
+#define RDCACHE_JIFFIES	(5*HZ)
+
+/* file private data. */
+struct unionfs_file_info {
+	int bstart;
+	int bend;
+	atomic_t generation;
+
+	struct unionfs_dir_state *rdstate;
+	struct file **lower_files;
+	int *saved_branch_ids; /* IDs of branches when file was opened */
+	struct vm_operations_struct *lower_vm_ops;
+	bool wrote_to_file;	/* for delayed copyup */
+};
+
+/* unionfs inode data in memory */
+struct unionfs_inode_info {
+	int bstart;
+	int bend;
+	atomic_t generation;
+	/* Stuff for readdir over NFS. */
+	spinlock_t rdlock;
+	struct list_head readdircache;
+	int rdcount;
+	int hashsize;
+	int cookie;
+
+	/* The lower inodes */
+	struct inode **lower_inodes;
+
+	struct inode vfs_inode;
+};
+
+/* unionfs dentry data in memory */
+struct unionfs_dentry_info {
+	/*
+	 * The semaphore is used to lock the dentry as soon as we get into a
+	 * unionfs function from the VFS.  Our lock ordering is that children
+	 * go before their parents.
+	 */
+	struct mutex lock;
+	int bstart;
+	int bend;
+	int bopaque;
+	int bcount;
+	atomic_t generation;
+	struct path *lower_paths;
+};
+
+/* These are the pointers to our various objects. */
+struct unionfs_data {
+	struct super_block *sb;	/* lower super_block */
+	atomic_t open_files;	/* number of open files on branch */
+	int branchperms;
+	int branch_id;		/* unique branch ID at re/mount time */
+};
+
+/* unionfs super-block data in memory */
+struct unionfs_sb_info {
+	int bend;
+
+	atomic_t generation;
+
+	/*
+	 * This rwsem is used to make sure that a branch management
+	 * operation...
+	 *   1) will not begin before all currently in-flight operations
+	 *      complete.
+	 *   2) any new operations do not execute until the currently
+	 *      running branch management operation completes.
+	 *
+	 * The write_lock_owner records the PID of the task which grabbed
+	 * the rw_sem for writing.  If the same task also tries to grab the
+	 * read lock, we allow it.  This prevents a self-deadlock when
+	 * branch-management is used on a pivot_root'ed union, because we
+	 * have to ->lookup paths which belong to the same union.
+	 */
+	struct rw_semaphore rwsem;
+	pid_t write_lock_owner;	/* PID of rw_sem owner (write lock) */
+	int high_branch_id;	/* last unique branch ID given */
+	char *dev_name;		/* to identify different unions in pr_debug */
+	struct unionfs_data *data;
+};
+
+/*
+ * structure for making the linked list of entries by readdir on left branch
+ * to compare with entries on right branch
+ */
+struct filldir_node {
+	struct list_head file_list;	/* list for directory entries */
+	char *name;		/* name entry */
+	int hash;		/* name hash */
+	int namelen;		/* name len since name is not 0 terminated */
+
+	/*
+	 * we can check for duplicate whiteouts and files in the same branch
+	 * in order to return -EIO.
+	 */
+	int bindex;
+
+	/* is this a whiteout entry? */
+	int whiteout;
+
+	/* Inline name, so we don't need to separately kmalloc small ones */
+	char iname[DNAME_INLINE_LEN_MIN];
+};
+
+/* Directory hash table. */
+struct unionfs_dir_state {
+	unsigned int cookie;	/* the cookie, based off of rdversion */
+	unsigned int offset;	/* The entry we have returned. */
+	int bindex;
+	loff_t dirpos;		/* offset within the lower level directory */
+	int size;		/* How big is the hash table? */
+	int hashentries;	/* How many entries have been inserted? */
+	unsigned long access;
+
+	/* This cache list is used when the inode keeps us around. */
+	struct list_head cache;
+	struct list_head list[0];
+};
+
+/* externs needed for fanout.h or sioq.h */
+extern int unionfs_get_nlinks(const struct inode *inode);
+extern void unionfs_copy_attr_times(struct inode *upper);
+extern void unionfs_copy_attr_all(struct inode *dest, const struct inode *src);
+
+/* include miscellaneous macros */
+#include "fanout.h"
+#include "sioq.h"
+
+/* externs for cache creation/deletion routines */
+extern void unionfs_destroy_filldir_cache(void);
+extern int unionfs_init_filldir_cache(void);
+extern int unionfs_init_inode_cache(void);
+extern void unionfs_destroy_inode_cache(void);
+extern int unionfs_init_dentry_cache(void);
+extern void unionfs_destroy_dentry_cache(void);
+
+/* Initialize and free readdir-specific  state. */
+extern int init_rdstate(struct file *file);
+extern struct unionfs_dir_state *alloc_rdstate(struct inode *inode,
+					       int bindex);
+extern struct unionfs_dir_state *find_rdstate(struct inode *inode,
+					      loff_t fpos);
+extern void free_rdstate(struct unionfs_dir_state *state);
+extern int add_filldir_node(struct unionfs_dir_state *rdstate,
+			    const char *name, int namelen, int bindex,
+			    int whiteout);
+extern struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+					      const char *name, int namelen,
+					      int is_whiteout);
+
+extern struct dentry **alloc_new_dentries(int objs);
+extern struct unionfs_data *alloc_new_data(int objs);
+
+/* We can only use 32-bits of offset for rdstate --- blech! */
+#define DIREOF (0xfffff)
+#define RDOFFBITS 20		/* This is the number of bits in DIREOF. */
+#define MAXRDCOOKIE (0xfff)
+/* Turn an rdstate into an offset. */
+static inline off_t rdstate2offset(struct unionfs_dir_state *buf)
+{
+	off_t tmp;
+
+	tmp = ((buf->cookie & MAXRDCOOKIE) << RDOFFBITS)
+		| (buf->offset & DIREOF);
+	return tmp;
+}
+
+/* Macros for locking a super_block. */
+enum unionfs_super_lock_class {
+	UNIONFS_SMUTEX_NORMAL,
+	UNIONFS_SMUTEX_PARENT,	/* when locking on behalf of file */
+	UNIONFS_SMUTEX_CHILD,	/* when locking on behalf of dentry */
+};
+static inline void unionfs_read_lock(struct super_block *sb, int subclass)
+{
+	if (UNIONFS_SB(sb)->write_lock_owner &&
+	    UNIONFS_SB(sb)->write_lock_owner == current->pid)
+		return;
+	down_read_nested(&UNIONFS_SB(sb)->rwsem, subclass);
+}
+static inline void unionfs_read_unlock(struct super_block *sb)
+{
+	if (UNIONFS_SB(sb)->write_lock_owner &&
+	    UNIONFS_SB(sb)->write_lock_owner == current->pid)
+		return;
+	up_read(&UNIONFS_SB(sb)->rwsem);
+}
+static inline void unionfs_write_lock(struct super_block *sb)
+{
+	down_write(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->write_lock_owner = current->pid;
+}
+static inline void unionfs_write_unlock(struct super_block *sb)
+{
+	up_write(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->write_lock_owner = 0;
+}
+
+static inline void unionfs_double_lock_dentry(struct dentry *d1,
+					      struct dentry *d2)
+{
+	BUG_ON(d1 == d2);
+	if (d1 < d2) {
+		unionfs_lock_dentry(d2, UNIONFS_DMUTEX_CHILD);
+		unionfs_lock_dentry(d1, UNIONFS_DMUTEX_PARENT);
+	} else {
+		unionfs_lock_dentry(d1, UNIONFS_DMUTEX_CHILD);
+		unionfs_lock_dentry(d2, UNIONFS_DMUTEX_PARENT);
+	}
+}
+
+extern int new_dentry_private_data(struct dentry *dentry, int subclass);
+extern int realloc_dentry_private_data(struct dentry *dentry);
+extern void free_dentry_private_data(struct dentry *dentry);
+extern void update_bstart(struct dentry *dentry);
+extern int init_lower_nd(struct nameidata *nd, unsigned int flags);
+extern void release_lower_nd(struct nameidata *nd, int err);
+
+/*
+ * EXTERNALS:
+ */
+
+/* replicates the directory structure up to given dentry in given branch */
+extern struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+				     const char *name, int bindex);
+
+/* partial lookup */
+extern int unionfs_partial_lookup(struct dentry *dentry);
+extern struct dentry *unionfs_lookup_full(struct dentry *dentry,
+					  struct nameidata *nd_unused,
+					  int lookupmode);
+
+/* copies a file from dbstart to newbindex branch */
+extern int copyup_file(struct inode *dir, struct file *file, int bstart,
+		       int newbindex, loff_t size);
+extern int copyup_named_file(struct inode *dir, struct file *file,
+			     char *name, int bstart, int new_bindex,
+			     loff_t len);
+/* copies a dentry from dbstart to newbindex branch */
+extern int copyup_dentry(struct inode *dir, struct dentry *dentry,
+			 int bstart, int new_bindex, const char *name,
+			 int namelen, struct file **copyup_file, loff_t len);
+/* helper functions for post-copyup actions */
+extern void unionfs_postcopyup_setmnt(struct dentry *dentry);
+extern void unionfs_postcopyup_release(struct dentry *dentry);
+
+/* Is this directory empty: 0 if it is empty, -ENOTEMPTY if not. */
+extern int check_empty(struct dentry *dentry,
+		       struct unionfs_dir_state **namelist);
+/* whiteout and opaque directory helpers */
+extern char *alloc_whname(const char *name, int len);
+extern bool is_whiteout_name(char **namep, int *namelenp);
+extern bool is_validname(const char *name);
+extern struct dentry *lookup_whiteout(const char *name,
+				      struct dentry *lower_parent);
+extern struct dentry *find_first_whiteout(struct dentry *dentry);
+extern int unlink_whiteout(struct dentry *wh_dentry);
+extern int check_unlink_whiteout(struct dentry *dentry,
+				 struct dentry *lower_dentry, int bindex);
+extern int create_whiteout(struct dentry *dentry, int start);
+extern int delete_whiteouts(struct dentry *dentry, int bindex,
+			    struct unionfs_dir_state *namelist);
+extern int is_opaque_dir(struct dentry *dentry, int bindex);
+extern int make_dir_opaque(struct dentry *dir, int bindex);
+extern void unionfs_set_max_namelen(long *namelen);
+
+extern void unionfs_reinterpose(struct dentry *this_dentry);
+extern struct super_block *unionfs_duplicate_super(struct super_block *sb);
+
+/* Locking functions. */
+extern int unionfs_setlk(struct file *file, int cmd, struct file_lock *fl);
+extern int unionfs_getlk(struct file *file, struct file_lock *fl);
+
+/* Common file operations. */
+extern int unionfs_file_revalidate(struct file *file, bool willwrite);
+extern int unionfs_file_revalidate_locked(struct file *file, bool willwrite);
+extern int unionfs_open(struct inode *inode, struct file *file);
+extern int unionfs_file_release(struct inode *inode, struct file *file);
+extern int unionfs_flush(struct file *file, fl_owner_t id);
+extern long unionfs_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg);
+extern int unionfs_fsync(struct file *file, struct dentry *dentry,
+			 int datasync);
+extern int unionfs_fasync(int fd, struct file *file, int flag);
+
+/* Inode operations */
+extern struct inode *unionfs_iget(struct super_block *sb, unsigned long ino);
+extern int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry);
+extern int unionfs_unlink(struct inode *dir, struct dentry *dentry);
+extern int unionfs_rmdir(struct inode *dir, struct dentry *dentry);
+
+extern bool __unionfs_d_revalidate_one_locked(struct dentry *dentry,
+					      struct nameidata *nd,
+					      bool willwrite);
+extern bool __unionfs_d_revalidate_chain(struct dentry *dentry,
+					 struct nameidata *nd, bool willwrite);
+extern bool is_negative_lower(const struct dentry *dentry);
+extern bool is_newer_lower(const struct dentry *dentry);
+extern void purge_sb_data(struct super_block *sb);
+
+/* The values for unionfs_interpose's flag. */
+#define INTERPOSE_DEFAULT	0
+#define INTERPOSE_LOOKUP	1
+#define INTERPOSE_REVAL		2
+#define INTERPOSE_REVAL_NEG	3
+#define INTERPOSE_PARTIAL	4
+
+extern struct dentry *unionfs_interpose(struct dentry *this_dentry,
+					struct super_block *sb, int flag);
+
+#ifdef CONFIG_UNION_FS_XATTR
+/* Extended attribute functions. */
+extern void *unionfs_xattr_alloc(size_t size, size_t limit);
+static inline void unionfs_xattr_kfree(const void *p)
+{
+	kfree(p);
+}
+extern ssize_t unionfs_getxattr(struct dentry *dentry, const char *name,
+				void *value, size_t size);
+extern int unionfs_removexattr(struct dentry *dentry, const char *name);
+extern ssize_t unionfs_listxattr(struct dentry *dentry, char *list,
+				 size_t size);
+extern int unionfs_setxattr(struct dentry *dentry, const char *name,
+			    const void *value, size_t size, int flags);
+#endif /* CONFIG_UNION_FS_XATTR */
+
+/* The root directory is unhashed, but isn't deleted. */
+static inline int d_deleted(struct dentry *d)
+{
+	return d_unhashed(d) && (d != d->d_sb->s_root);
+}
+
+/* unionfs_permission, check if we should bypass error to facilitate copyup */
+#define IS_COPYUP_ERR(err) ((err) == -EROFS)
+
+/* unionfs_open, check if we need to copyup the file */
+#define OPEN_WRITE_FLAGS (O_WRONLY | O_RDWR | O_APPEND)
+#define IS_WRITE_FLAG(flag) ((flag) & OPEN_WRITE_FLAGS)
+
+static inline int branchperms(const struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+	return UNIONFS_SB(sb)->data[index].branchperms;
+}
+
+static inline int set_branchperms(struct super_block *sb, int index, int perms)
+{
+	BUG_ON(index < 0);
+	UNIONFS_SB(sb)->data[index].branchperms = perms;
+	return perms;
+}
+
+/* Is this file on a read-only branch? */
+static inline int is_robranch_super(const struct super_block *sb, int index)
+{
+	int ret;
+
+	ret = (!(branchperms(sb, index) & MAY_WRITE)) ? -EROFS : 0;
+	return ret;
+}
+
+/* Is this file on a read-only branch? */
+static inline int is_robranch_idx(const struct dentry *dentry, int index)
+{
+	struct super_block *lower_sb;
+
+	BUG_ON(index < 0);
+
+	if (!(branchperms(dentry->d_sb, index) & MAY_WRITE))
+		return -EROFS;
+
+	lower_sb = unionfs_lower_super_idx(dentry->d_sb, index);
+	BUG_ON(lower_sb == NULL);
+	/*
+	 * test sb flags directly, not IS_RDONLY(lower_inode) because the
+	 * lower_dentry could be a negative.
+	 */
+	if (lower_sb->s_flags & MS_RDONLY)
+		return -EROFS;
+
+	return 0;
+}
+
+static inline int is_robranch(const struct dentry *dentry)
+{
+	int index;
+
+	index = UNIONFS_D(dentry)->bstart;
+	BUG_ON(index < 0);
+
+	return is_robranch_idx(dentry, index);
+}
+
+/*
+ * EXTERNALS:
+ */
+extern int check_branch(struct nameidata *nd);
+extern int parse_branch_mode(const char *name, int *perms);
+
+/* locking helpers */
+static inline struct dentry *lock_parent(struct dentry *dentry)
+{
+	struct dentry *dir = dget_parent(dentry);
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	return dir;
+}
+static inline struct dentry *lock_parent_wh(struct dentry *dentry)
+{
+	struct dentry *dir = dget_parent(dentry);
+
+	mutex_lock_nested(&dir->d_inode->i_mutex, UNIONFS_DMUTEX_WHITEOUT);
+	return dir;
+}
+
+static inline void unlock_dir(struct dentry *dir)
+{
+	mutex_unlock(&dir->d_inode->i_mutex);
+	dput(dir);
+}
+
+static inline struct vfsmount *unionfs_mntget(struct dentry *dentry,
+					      int bindex)
+{
+	struct vfsmount *mnt;
+
+	BUG_ON(!dentry || bindex < 0);
+
+	mnt = mntget(unionfs_lower_mnt_idx(dentry, bindex));
+#ifdef CONFIG_UNION_FS_DEBUG
+	if (!mnt)
+		pr_debug("unionfs: mntget: mnt=%p bindex=%d\n",
+			 mnt, bindex);
+#endif /* CONFIG_UNION_FS_DEBUG */
+
+	return mnt;
+}
+
+static inline void unionfs_mntput(struct dentry *dentry, int bindex)
+{
+	struct vfsmount *mnt;
+
+	if (!dentry && bindex < 0)
+		return;
+	BUG_ON(!dentry || bindex < 0);
+
+	mnt = unionfs_lower_mnt_idx(dentry, bindex);
+#ifdef CONFIG_UNION_FS_DEBUG
+	/*
+	 * Directories can have NULL lower objects in between start/end, but
+	 * NOT if at the start/end range.  We cannot verify that this dentry
+	 * is a type=DIR, because it may already be a negative dentry.  But
+	 * if dbstart is greater than dbend, we know that this couldn't have
+	 * been a regular file: it had to have been a directory.
+	 */
+	if (!mnt && !(bindex > dbstart(dentry) && bindex < dbend(dentry)))
+		pr_debug("unionfs: mntput: mnt=%p bindex=%d\n", mnt, bindex);
+#endif /* CONFIG_UNION_FS_DEBUG */
+	mntput(mnt);
+}
+
+#ifdef CONFIG_UNION_FS_DEBUG
+
+/* useful for tracking code reachability */
+#define UDBG pr_debug("DBG:%s:%s:%d\n", __FILE__, __func__, __LINE__)
+
+#define unionfs_check_inode(i)	__unionfs_check_inode((i),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_dentry(d)	__unionfs_check_dentry((d),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_file(f)	__unionfs_check_file((f),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_nd(n)	__unionfs_check_nd((n),		\
+	__FILE__, __func__, __LINE__)
+#define show_branch_counts(sb)	__show_branch_counts((sb),	\
+	__FILE__, __func__, __LINE__)
+#define show_inode_times(i)	__show_inode_times((i),		\
+	__FILE__, __func__, __LINE__)
+#define show_dinode_times(d)	__show_dinode_times((d),	\
+	__FILE__, __func__, __LINE__)
+#define show_inode_counts(i)	__show_inode_counts((i),	\
+	__FILE__, __func__, __LINE__)
+
+extern void __unionfs_check_inode(const struct inode *inode, const char *fname,
+				  const char *fxn, int line);
+extern void __unionfs_check_dentry(const struct dentry *dentry,
+				   const char *fname, const char *fxn,
+				   int line);
+extern void __unionfs_check_file(const struct file *file,
+				 const char *fname, const char *fxn, int line);
+extern void __unionfs_check_nd(const struct nameidata *nd,
+			       const char *fname, const char *fxn, int line);
+extern void __show_branch_counts(const struct super_block *sb,
+				 const char *file, const char *fxn, int line);
+extern void __show_inode_times(const struct inode *inode,
+			       const char *file, const char *fxn, int line);
+extern void __show_dinode_times(const struct dentry *dentry,
+				const char *file, const char *fxn, int line);
+extern void __show_inode_counts(const struct inode *inode,
+				const char *file, const char *fxn, int line);
+
+#else /* not CONFIG_UNION_FS_DEBUG */
+
+/* we leave useful hooks for these check functions throughout the code */
+#define unionfs_check_inode(i)		do { } while (0)
+#define unionfs_check_dentry(d)		do { } while (0)
+#define unionfs_check_file(f)		do { } while (0)
+#define unionfs_check_nd(n)		do { } while (0)
+#define show_branch_counts(sb)		do { } while (0)
+#define show_inode_times(i)		do { } while (0)
+#define show_dinode_times(d)		do { } while (0)
+#define show_inode_counts(i)		do { } while (0)
+
+#endif /* not CONFIG_UNION_FS_DEBUG */
+
+#endif	/* not _UNION_H_ */
diff --git a/fs/unionfs/unlink.c b/fs/unionfs/unlink.c
new file mode 100644
index 0000000..623f68d
--- /dev/null
+++ b/fs/unionfs/unlink.c
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Helper function for Unionfs's unlink operation.
+ *
+ * The main goal of this function is to optimize the unlinking of non-dir
+ * objects in unionfs by deleting all possible lower inode objects from the
+ * underlying branches having same dentry name as the non-dir dentry on
+ * which this unlink operation is called.  This way we delete as many lower
+ * inodes as possible, and save space.  Whiteouts need to be created in
+ * branch0 only if unlinking fails on any of the lower branch other than
+ * branch0, or if a lower branch is marked read-only.
+ *
+ * Also, while unlinking a file, if we encounter any dir type entry in any
+ * intermediate branch, then we remove the directory by calling vfs_rmdir.
+ * The following special cases are also handled:
+
+ * (1) If an error occurs in branch0 during vfs_unlink, then we return
+ *     appropriate error.
+ *
+ * (2) If we get an error during unlink in any of other lower branch other
+ *     than branch0, then we create a whiteout in branch0.
+ *
+ * (3) If a whiteout already exists in any intermediate branch, we delete
+ *     all possible inodes only up to that branch (this is an "opaqueness"
+ *     as as per Documentation/filesystems/unionfs/concepts.txt).
+ *
+ */
+static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+	int bindex;
+	int err = 0;
+
+	err = unionfs_partial_lookup(dentry);
+	if (err)
+		goto out;
+
+	/* trying to unlink all possible valid instances */
+	for (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry || !lower_dentry->d_inode)
+			continue;
+
+		lower_dir_dentry = lock_parent(lower_dentry);
+
+		/* avoid destroying the lower inode if the object is in use */
+		dget(lower_dentry);
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (!err) {
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+				err = vfs_unlink(lower_dir_dentry->d_inode,
+								lower_dentry);
+			else
+				err = vfs_rmdir(lower_dir_dentry->d_inode,
+								lower_dentry);
+			lockdep_on();
+		}
+
+		/* if lower object deletion succeeds, update inode's times */
+		if (!err)
+			unionfs_copy_attr_times(dentry->d_inode);
+		dput(lower_dentry);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+		unlock_dir(lower_dir_dentry);
+
+		if (err)
+			break;
+	}
+
+	/*
+	 * Create the whiteout in branch 0 (highest priority) only if (a)
+	 * there was an error in any intermediate branch other than branch 0
+	 * due to failure of vfs_unlink/vfs_rmdir or (b) a branch marked or
+	 * mounted read-only.
+	 */
+	if (err) {
+		if ((bindex == 0) ||
+		    ((bindex == dbstart(dentry)) &&
+		     (!IS_COPYUP_ERR(err))))
+			goto out;
+		else {
+			if (!IS_COPYUP_ERR(err))
+				pr_debug("unionfs: lower object deletion "
+					     "failed in branch:%d\n", bindex);
+			err = create_whiteout(dentry, sbstart(dentry->d_sb));
+		}
+	}
+
+out:
+	if (!err)
+		inode_dec_link_count(dentry->d_inode);
+
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	return err;
+}
+
+int unionfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct inode *inode = dentry->d_inode;
+	int valid;
+
+	BUG_ON(S_ISDIR(inode->i_mode));
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+	unionfs_lock_dentry(dentry->d_parent, UNIONFS_DMUTEX_PARENT);
+
+	valid = __unionfs_d_revalidate_chain(dentry->d_parent, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	valid = __unionfs_d_revalidate_one_locked(dentry, NULL, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	err = unionfs_unlink_whiteout(dir, dentry);
+	/* call d_drop so the system "forgets" about us */
+	if (!err) {
+		unionfs_postcopyup_release(dentry);
+		if (inode->i_nlink == 0) /* drop lower inodes */
+			iput_lowers_all(inode, false);
+		d_drop(dentry);
+		/*
+		 * if unlink/whiteout succeeded, parent dir mtime has
+		 * changed
+		 */
+		unionfs_copy_attr_times(dir);
+	}
+
+out:
+	if (!err) {
+		unionfs_check_dentry(dentry);
+		unionfs_check_inode(dir);
+	}
+	unionfs_unlock_dentry(dentry->d_parent);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,
+			       struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
+
+	/* Here we need to remove whiteout entries. */
+	err = delete_whiteouts(dentry, dbstart(dentry), namelist);
+	if (err)
+		goto out;
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	lower_dir_dentry = lock_parent(lower_dentry);
+
+	/* avoid destroying the lower inode if the file is in use */
+	dget(lower_dentry);
+	err = is_robranch(dentry);
+	if (!err) {
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+		lockdep_on();
+	}
+	dput(lower_dentry);
+
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = unionfs_get_nlinks(dentry->d_inode);
+
+out:
+	if (lower_dir_dentry)
+		unlock_dir(lower_dir_dentry);
+	return err;
+}
+
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct unionfs_dir_state *namelist = NULL;
+	int dstart, dend;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	/* check if this unionfs directory is empty or not */
+	err = check_empty(dentry, &namelist);
+	if (err)
+		goto out;
+
+	err = unionfs_rmdir_first(dir, dentry, namelist);
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	/*
+	 * We create a whiteout for the directory if there was an error to
+	 * rmdir the first directory entry in the union.  Otherwise, we
+	 * create a whiteout only if there is no chance that a lower
+	 * priority branch might also have the same named directory.  IOW,
+	 * if there is not another same-named directory at a lower priority
+	 * branch, then we don't need to create a whiteout for it.
+	 */
+	if (!err) {
+		if (dstart < dend)
+			err = create_whiteout(dentry, dstart);
+	} else {
+		int new_err;
+
+		if (dstart == 0)
+			goto out;
+
+		/* exit if the error returned was NOT -EROFS */
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+
+		new_err = create_whiteout(dentry, dstart - 1);
+		if (new_err != -EEXIST)
+			err = new_err;
+	}
+
+out:
+	/*
+	 * Drop references to lower dentry/inode so storage space for them
+	 * can be reclaimed.  Then, call d_drop so the system "forgets"
+	 * about us.
+	 */
+	if (!err) {
+		iput_lowers_all(dentry->d_inode, false);
+		dput(unionfs_lower_dentry_idx(dentry, dstart));
+		unionfs_set_lower_dentry_idx(dentry, dstart, NULL);
+		d_drop(dentry);
+		/* update our lower vfsmnts, in case a copyup took place */
+		unionfs_postcopyup_setmnt(dentry);
+	}
+
+	if (namelist)
+		free_rdstate(namelist);
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/fs/unionfs/whiteout.c b/fs/unionfs/whiteout.c
new file mode 100644
index 0000000..db7a21e
--- /dev/null
+++ b/fs/unionfs/whiteout.c
@@ -0,0 +1,577 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * whiteout and opaque directory helpers
+ */
+
+/* What do we use for whiteouts. */
+#define UNIONFS_WHPFX ".wh."
+#define UNIONFS_WHLEN 4
+/*
+ * If a directory contains this file, then it is opaque.  We start with the
+ * .wh. flag so that it is blocked by lookup.
+ */
+#define UNIONFS_DIR_OPAQUE_NAME "__dir_opaque"
+#define UNIONFS_DIR_OPAQUE UNIONFS_WHPFX UNIONFS_DIR_OPAQUE_NAME
+
+/* construct whiteout filename */
+char *alloc_whname(const char *name, int len)
+{
+	char *buf;
+
+	buf = kmalloc(len + UNIONFS_WHLEN + 1, GFP_KERNEL);
+	if (unlikely(!buf))
+		return ERR_PTR(-ENOMEM);
+
+	strcpy(buf, UNIONFS_WHPFX);
+	strlcat(buf, name, len + UNIONFS_WHLEN + 1);
+
+	return buf;
+}
+
+/*
+ * XXX: this can be inline or CPP macro, but is here to keep all whiteout
+ * code in one place.
+ */
+void unionfs_set_max_namelen(long *namelen)
+{
+	*namelen -= UNIONFS_WHLEN;
+}
+
+/* check if @namep is a whiteout, update @namep and @namelenp accordingly */
+bool is_whiteout_name(char **namep, int *namelenp)
+{
+	if (*namelenp > UNIONFS_WHLEN &&
+	    !strncmp(*namep, UNIONFS_WHPFX, UNIONFS_WHLEN)) {
+		*namep += UNIONFS_WHLEN;
+		*namelenp -= UNIONFS_WHLEN;
+		return true;
+	}
+	return false;
+}
+
+/* is the filename valid == !(whiteout for a file or opaque dir marker) */
+bool is_validname(const char *name)
+{
+	if (!strncmp(name, UNIONFS_WHPFX, UNIONFS_WHLEN))
+		return false;
+	if (!strncmp(name, UNIONFS_DIR_OPAQUE_NAME,
+		     sizeof(UNIONFS_DIR_OPAQUE_NAME) - 1))
+		return false;
+	return true;
+}
+
+/*
+ * Look for a whiteout @name in @lower_parent directory.  If error, return
+ * ERR_PTR.  Caller must dput() the returned dentry if not an error.
+ *
+ * XXX: some callers can reuse the whname allocated buffer to avoid repeated
+ * free then re-malloc calls.  Need to provide a different API for those
+ * callers.
+ */
+struct dentry *lookup_whiteout(const char *name, struct dentry *lower_parent)
+{
+	char *whname = NULL;
+	int err = 0, namelen;
+	struct dentry *wh_dentry = NULL;
+
+	namelen = strlen(name);
+	whname = alloc_whname(name, namelen);
+	if (unlikely(IS_ERR(whname))) {
+		err = PTR_ERR(whname);
+		goto out;
+	}
+
+	/* check if whiteout exists in this branch: lookup .wh.foo */
+	wh_dentry = lookup_one_len(whname, lower_parent, strlen(whname));
+	if (IS_ERR(wh_dentry)) {
+		err = PTR_ERR(wh_dentry);
+		goto out;
+	}
+
+	/* check if negative dentry (ENOENT) */
+	if (!wh_dentry->d_inode)
+		goto out;
+
+	/* whiteout found: check if valid type */
+	if (!S_ISREG(wh_dentry->d_inode->i_mode)) {
+		printk(KERN_ERR "unionfs: invalid whiteout %s entry type %d\n",
+		       whname, wh_dentry->d_inode->i_mode);
+		dput(wh_dentry);
+		err = -EIO;
+		goto out;
+	}
+
+out:
+	kfree(whname);
+	if (err)
+		wh_dentry = ERR_PTR(err);
+	return wh_dentry;
+}
+
+/* find and return first whiteout in parent directory, else ENOENT */
+struct dentry *find_first_whiteout(struct dentry *dentry)
+{
+	int bindex, bstart, bend;
+	struct dentry *parent, *lower_parent, *wh_dentry;
+
+	parent = dget_parent(dentry);
+	unionfs_lock_dentry(parent, UNIONFS_DMUTEX_WHITEOUT);
+	bstart = dbstart(parent);
+	bend = dbend(parent);
+	wh_dentry = ERR_PTR(-ENOENT);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_parent = unionfs_lower_dentry_idx(parent, bindex);
+		if (!lower_parent)
+			continue;
+		wh_dentry = lookup_whiteout(dentry->d_name.name, lower_parent);
+		if (IS_ERR(wh_dentry))
+			continue;
+		if (wh_dentry->d_inode)
+			break;
+		dput(wh_dentry);
+		wh_dentry = ERR_PTR(-ENOENT);
+	}
+	unionfs_unlock_dentry(parent);
+	dput(parent);
+
+	return wh_dentry;
+}
+
+/*
+ * Unlink a whiteout dentry.  Returns 0 or -errno.  Caller must hold and
+ * release dentry reference.
+ */
+int unlink_whiteout(struct dentry *wh_dentry)
+{
+	int err;
+	struct dentry *lower_dir_dentry;
+
+	/* dget and lock parent dentry */
+	lower_dir_dentry = lock_parent_wh(wh_dentry);
+
+	/* see Documentation/filesystems/unionfs/issues.txt */
+	lockdep_off();
+	err = vfs_unlink(lower_dir_dentry->d_inode, wh_dentry);
+	lockdep_on();
+	unlock_dir(lower_dir_dentry);
+
+	/*
+	 * Whiteouts are special files and should be deleted no matter what
+	 * (as if they never existed), in order to allow this create
+	 * operation to succeed.  This is especially important in sticky
+	 * directories: a whiteout may have been created by one user, but
+	 * the newly created file may be created by another user.
+	 * Therefore, in order to maintain Unix semantics, if the vfs_unlink
+	 * above failed, then we have to try to directly unlink the
+	 * whiteout.  Note: in the ODF version of unionfs, whiteout are
+	 * handled much more cleanly.
+	 */
+	if (err == -EPERM) {
+		struct inode *inode = lower_dir_dentry->d_inode;
+		err = inode->i_op->unlink(inode, wh_dentry);
+	}
+	if (err)
+		printk(KERN_ERR "unionfs: could not unlink whiteout %s, "
+		       "err = %d\n", wh_dentry->d_name.name, err);
+
+	return err;
+
+}
+
+/*
+ * Helper function when creating new objects (create, symlink, mknod, etc.).
+ * Checks to see if there's a whiteout in @lower_dentry's parent directory,
+ * whose name is taken from @dentry.  Then tries to remove that whiteout, if
+ * found.  If <dentry,bindex> is a branch marked readonly, return -EROFS.
+ * If it finds both a regular file and a whiteout, return -EIO (this should
+ * never happen).
+ *
+ * Return 0 if no whiteout was found.  Return 1 if one was found and
+ * successfully removed.  Therefore a value >= 0 tells the caller that
+ * @lower_dentry belongs to a good branch to create the new object in).
+ * Return -ERRNO if an error occurred during whiteout lookup or in trying to
+ * unlink the whiteout.
+ */
+int check_unlink_whiteout(struct dentry *dentry, struct dentry *lower_dentry,
+			  int bindex)
+{
+	int err;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+
+	/* look for whiteout dentry first */
+	lower_dir_dentry = dget_parent(lower_dentry);
+	wh_dentry = lookup_whiteout(dentry->d_name.name, lower_dir_dentry);
+	dput(lower_dir_dentry);
+	if (IS_ERR(wh_dentry)) {
+		err = PTR_ERR(wh_dentry);
+		goto out;
+	}
+
+	if (!wh_dentry->d_inode) { /* no whiteout exists*/
+		err = 0;
+		goto out_dput;
+	}
+
+	/* check if regular file and whiteout were both found */
+	if (unlikely(lower_dentry->d_inode)) {
+		err = -EIO;
+		printk(KERN_ERR "unionfs: found both whiteout and regular "
+		       "file in directory %s (branch %d)\n",
+		       lower_dentry->d_parent->d_name.name, bindex);
+		goto out_dput;
+	}
+
+	/* check if branch is writeable */
+	err = is_robranch_super(dentry->d_sb, bindex);
+	if (err)
+		goto out_dput;
+
+	/* .wh.foo has been found, so let's unlink it */
+	err = unlink_whiteout(wh_dentry);
+	if (!err)
+		err = 1; /* a whiteout was found and successfully removed */
+out_dput:
+	dput(wh_dentry);
+out:
+	return err;
+}
+
+/*
+ * Pass an unionfs dentry and an index.  It will try to create a whiteout
+ * for the filename in dentry, and will try in branch 'index'.  On error,
+ * it will proceed to a branch to the left.
+ */
+int create_whiteout(struct dentry *dentry, int start)
+{
+	int bstart, bend, bindex;
+	struct dentry *lower_dir_dentry;
+	struct dentry *lower_dentry;
+	struct dentry *lower_wh_dentry;
+	struct nameidata nd;
+	char *name = NULL;
+	int err = -EINVAL;
+
+	verify_locked(dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* create dentry's whiteout equivalent */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (unlikely(IS_ERR(name))) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	for (bindex = start; bindex >= 0; bindex--) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+
+		if (!lower_dentry) {
+			/*
+			 * if lower dentry is not present, create the
+			 * entire lower dentry directory structure and go
+			 * ahead.  Since we want to just create whiteout, we
+			 * only want the parent dentry, and hence get rid of
+			 * this dentry.
+			 */
+			lower_dentry = create_parents(dentry->d_inode,
+						      dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				int ret = PTR_ERR(lower_dentry);
+				if (!IS_COPYUP_ERR(ret))
+					printk(KERN_ERR
+					       "unionfs: create_parents for "
+					       "whiteout failed: bindex=%d "
+					       "err=%d\n", bindex, ret);
+				continue;
+			}
+		}
+
+		lower_wh_dentry =
+			lookup_one_len(name, lower_dentry->d_parent,
+				       dentry->d_name.len + UNIONFS_WHLEN);
+		if (IS_ERR(lower_wh_dentry))
+			continue;
+
+		/*
+		 * The whiteout already exists. This used to be impossible,
+		 * but now is possible because of opaqueness.
+		 */
+		if (lower_wh_dentry->d_inode) {
+			dput(lower_wh_dentry);
+			err = 0;
+			goto out;
+		}
+
+		err = init_lower_nd(&nd, LOOKUP_CREATE);
+		if (unlikely(err < 0))
+			goto out;
+		lower_dir_dentry = lock_parent_wh(lower_wh_dentry);
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (!err)
+			err = vfs_create(lower_dir_dentry->d_inode,
+					 lower_wh_dentry,
+					 ~current->fs->umask & S_IRUGO,
+					 &nd);
+		unlock_dir(lower_dir_dentry);
+		dput(lower_wh_dentry);
+		release_lower_nd(&nd, err);
+
+		if (!err || !IS_COPYUP_ERR(err))
+			break;
+	}
+
+	/* set dbopaque so that lookup will not proceed after this branch */
+	if (!err)
+		dbopaque(dentry) = bindex;
+
+out:
+	kfree(name);
+	return err;
+}
+
+/*
+ * Delete all of the whiteouts in a given directory for rmdir.
+ *
+ * lower directory inode should be locked
+ */
+static int do_delete_whiteouts(struct dentry *dentry, int bindex,
+			       struct unionfs_dir_state *namelist)
+{
+	int err = 0;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *lower_dentry;
+	char *name = NULL, *p;
+	struct inode *lower_dir;
+	int i;
+	struct list_head *pos;
+	struct filldir_node *cursor;
+
+	/* Find out lower parent dentry */
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
+
+	err = -ENOMEM;
+	name = __getname();
+	if (unlikely(!name))
+		goto out;
+	strcpy(name, UNIONFS_WHPFX);
+	p = name + UNIONFS_WHLEN;
+
+	err = 0;
+	for (i = 0; !err && i < namelist->size; i++) {
+		list_for_each(pos, &namelist->list[i]) {
+			cursor =
+				list_entry(pos, struct filldir_node,
+					   file_list);
+			/* Only operate on whiteouts in this branch. */
+			if (cursor->bindex != bindex)
+				continue;
+			if (!cursor->whiteout)
+				continue;
+
+			strlcpy(p, cursor->name, PATH_MAX - UNIONFS_WHLEN);
+			lower_dentry =
+				lookup_one_len(name, lower_dir_dentry,
+					       cursor->namelen +
+					       UNIONFS_WHLEN);
+			if (IS_ERR(lower_dentry)) {
+				err = PTR_ERR(lower_dentry);
+				break;
+			}
+			if (lower_dentry->d_inode)
+				err = vfs_unlink(lower_dir, lower_dentry);
+			dput(lower_dentry);
+			if (err)
+				break;
+		}
+	}
+
+	__putname(name);
+
+	/* After all of the removals, we should copy the attributes once. */
+	fsstack_copy_attr_times(dentry->d_inode, lower_dir_dentry->d_inode);
+
+out:
+	return err;
+}
+
+
+void __delete_whiteouts(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct deletewh_args *d = &args->deletewh;
+
+	args->err = do_delete_whiteouts(d->dentry, d->bindex, d->namelist);
+	complete(&args->comp);
+}
+
+/* delete whiteouts in a dir (for rmdir operation) using sioq if necessary */
+int delete_whiteouts(struct dentry *dentry, int bindex,
+		     struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct super_block *sb;
+	struct dentry *lower_dir_dentry;
+	struct inode *lower_dir;
+	struct sioq_args args;
+
+	sb = dentry->d_sb;
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+	BUG_ON(bindex < dbstart(dentry));
+	BUG_ON(bindex > dbend(dentry));
+	err = is_robranch_super(sb, bindex);
+	if (err)
+		goto out;
+
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
+
+	if (!inode_permission(lower_dir, MAY_WRITE | MAY_EXEC)) {
+		err = do_delete_whiteouts(dentry, bindex, namelist);
+	} else {
+		args.deletewh.namelist = namelist;
+		args.deletewh.dentry = dentry;
+		args.deletewh.bindex = bindex;
+		run_sioq(__delete_whiteouts, &args);
+		err = args.err;
+	}
+
+out:
+	return err;
+}
+
+/****************************************************************************
+ * Opaque directory helpers                                                 *
+ ****************************************************************************/
+
+/*
+ * is_opaque_dir: returns 0 if it is NOT an opaque dir, 1 if it is, and
+ * -errno if an error occurred trying to figure this out.
+ */
+int is_opaque_dir(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *lower_dentry;
+	struct dentry *wh_lower_dentry;
+	struct inode *lower_inode;
+	struct sioq_args args;
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_inode = lower_dentry->d_inode;
+
+	BUG_ON(!S_ISDIR(lower_inode->i_mode));
+
+	mutex_lock(&lower_inode->i_mutex);
+
+	if (!inode_permission(lower_inode, MAY_EXEC)) {
+		wh_lower_dentry =
+			lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
+				       sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	} else {
+		args.is_opaque.dentry = lower_dentry;
+		run_sioq(__is_opaque_dir, &args);
+		wh_lower_dentry = args.ret;
+	}
+
+	mutex_unlock(&lower_inode->i_mutex);
+
+	if (IS_ERR(wh_lower_dentry)) {
+		err = PTR_ERR(wh_lower_dentry);
+		goto out;
+	}
+
+	/* This is an opaque dir iff wh_lower_dentry is positive */
+	err = !!wh_lower_dentry->d_inode;
+
+	dput(wh_lower_dentry);
+out:
+	return err;
+}
+
+void __is_opaque_dir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+
+	args->ret = lookup_one_len(UNIONFS_DIR_OPAQUE, args->is_opaque.dentry,
+				   sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	complete(&args->comp);
+}
+
+int make_dir_opaque(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *lower_dentry, *diropq;
+	struct inode *lower_dir;
+	struct nameidata nd;
+	kernel_cap_t orig_cap;
+
+	/*
+	 * Opaque directory whiteout markers are special files (like regular
+	 * whiteouts), and should appear to the users as if they don't
+	 * exist.  They should be created/deleted regardless of directory
+	 * search/create permissions, but only for the duration of this
+	 * creation of the .wh.__dir_opaque: file.  Note, this does not
+	 * circumvent normal ->permission).
+	 */
+	orig_cap = current->cap_effective;
+	cap_raise(current->cap_effective, CAP_DAC_READ_SEARCH);
+	cap_raise(current->cap_effective, CAP_DAC_OVERRIDE);
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_dir = lower_dentry->d_inode;
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode) ||
+	       !S_ISDIR(lower_dir->i_mode));
+
+	mutex_lock(&lower_dir->i_mutex);
+	diropq = lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
+				sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	if (IS_ERR(diropq)) {
+		err = PTR_ERR(diropq);
+		goto out;
+	}
+
+	err = init_lower_nd(&nd, LOOKUP_CREATE);
+	if (unlikely(err < 0))
+		goto out;
+	if (!diropq->d_inode)
+		err = vfs_create(lower_dir, diropq, S_IRUGO, &nd);
+	if (!err)
+		dbopaque(dentry) = bindex;
+	release_lower_nd(&nd, err);
+
+	dput(diropq);
+
+out:
+	mutex_unlock(&lower_dir->i_mutex);
+	current->cap_effective = orig_cap;
+	return err;
+}
diff --git a/fs/unionfs/xattr.c b/fs/unionfs/xattr.c
new file mode 100644
index 0000000..93a8fce
--- /dev/null
+++ b/fs/unionfs/xattr.c
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* This is lifted from fs/xattr.c */
+void *unionfs_xattr_alloc(size_t size, size_t limit)
+{
+	void *ptr;
+
+	if (size > limit)
+		return ERR_PTR(-E2BIG);
+
+	if (!size)		/* size request, no buffer is needed */
+		return NULL;
+
+	ptr = kmalloc(size, GFP_KERNEL);
+	if (unlikely(!ptr))
+		return ERR_PTR(-ENOMEM);
+	return ptr;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,
+			 size_t size)
+{
+	struct dentry *lower_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_getxattr(lower_dentry, (char *) name, value, size);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int unionfs_setxattr(struct dentry *dentry, const char *name,
+		     const void *value, size_t size, int flags)
+{
+	struct dentry *lower_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_setxattr(lower_dentry, (char *) name, (void *) value,
+			   size, flags);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int unionfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct dentry *lower_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_removexattr(lower_dentry, (char *) name);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+ssize_t unionfs_listxattr(struct dentry *dentry, char *list, size_t size)
+{
+	struct dentry *lower_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_list = NULL;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate_chain(dentry, NULL, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	encoded_list = list;
+	err = vfs_listxattr(lower_dentry, encoded_list, size);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/include/linux/fs_stack.h b/include/linux/fs_stack.h
index bb516ce..6615a52 100644
--- a/include/linux/fs_stack.h
+++ b/include/linux/fs_stack.h
@@ -1,17 +1,27 @@
+/*
+ * Copyright (c) 2006-2007 Erez Zadok
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006-2007 Stony Brook University
+ * Copyright (c) 2006-2007 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
 #ifndef _LINUX_FS_STACK_H
 #define _LINUX_FS_STACK_H
 
-/* This file defines generic functions used primarily by stackable
+/*
+ * This file defines generic functions used primarily by stackable
  * filesystems; none of these functions require i_mutex to be held.
  */
 
 #include <linux/fs.h>
 
 /* externs for fs/stack.c */
-extern void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,
-				int (*get_nlinks)(struct inode *));
-
-extern void fsstack_copy_inode_size(struct inode *dst, const struct inode *src);
+extern void fsstack_copy_attr_all(struct inode *dest, const struct inode *src);
+extern void fsstack_copy_inode_size(struct inode *dst, struct inode *src);
 
 /* inlines */
 static inline void fsstack_copy_attr_atime(struct inode *dest,
diff --git a/include/linux/magic.h b/include/linux/magic.h
index 1fa0c2c..67043ed 100644
--- a/include/linux/magic.h
+++ b/include/linux/magic.h
@@ -35,6 +35,8 @@
 #define REISER2FS_SUPER_MAGIC_STRING	"ReIsEr2Fs"
 #define REISER2FS_JR_SUPER_MAGIC_STRING	"ReIsEr3Fs"
 
+#define UNIONFS_SUPER_MAGIC 0xf15f083d
+
 #define SMB_SUPER_MAGIC		0x517B
 #define USBDEVICE_SUPER_MAGIC	0x9fa2
 #define CGROUP_SUPER_MAGIC	0x27e0eb
diff --git a/include/linux/splice.h b/include/linux/splice.h
index 528dcb9..4b5727c 100644
--- a/include/linux/splice.h
+++ b/include/linux/splice.h
@@ -70,5 +70,10 @@ extern ssize_t splice_to_pipe(struct pipe_inode_info *,
 			      struct splice_pipe_desc *);
 extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
 				      splice_direct_actor *);
+extern long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			    loff_t *ppos, size_t len, unsigned int flags);
+extern long vfs_splice_to(struct file *in, loff_t *ppos,
+			  struct pipe_inode_info *pipe, size_t len,
+			  unsigned int flags);
 
 #endif
diff --git a/include/linux/union_fs.h b/include/linux/union_fs.h
new file mode 100644
index 0000000..7199458
--- /dev/null
+++ b/include/linux/union_fs.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2003-2008 Erez Zadok
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2003-2008 Stony Brook University
+ * Copyright (c) 2003-2008 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_UNION_FS_H
+#define _LINUX_UNION_FS_H
+
+#define UNIONFS_VERSION  "2.2-mm"
+
+/*
+ * DEFINITIONS FOR USER AND KERNEL CODE:
+ */
+# define UNIONFS_IOCTL_INCGEN		_IOR(0x15, 11, int)
+# define UNIONFS_IOCTL_QUERYFILE	_IOR(0x15, 15, int)
+
+#endif /* _LINUX_UNIONFS_H */
+
