From eaa388508395166d3f9a7d780b3a9f6019b8a8e1 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 14 Aug 2008 18:12:38 +0800
Subject: [PATCH 1/1] Supply CMOS-RTC device to be used via the hwtimer API 


Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/rtc/rtc-cmos.c |   79 +++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 78 insertions(+), 1 deletions(-)

diff --git a/drivers/rtc/rtc-cmos.c b/drivers/rtc/rtc-cmos.c
index 6ea349a..e726a61 100644
--- a/drivers/rtc/rtc-cmos.c
+++ b/drivers/rtc/rtc-cmos.c
@@ -39,6 +39,21 @@
 /* this is for "generic access to PC-style RTC" using CMOS_READ/CMOS_WRITE */
 #include <asm-generic/rtc.h>
 
+/* RTC IRQ handler isn't suitable for use with IRQF_TIMER on
+ * RT without a significant restructuring */
+#ifdef CONFIG_PREEMPT_RT
+#undef CONFIG_HWTIMER_HOOKS
+#define RTC_IRQFLAGS   IRQF_DISABLED
+#else
+#define RTC_IRQFLAGS   (IRQF_DISABLED|IRQF_TIMER)
+#endif
+
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+#endif
+
 struct cmos_rtc {
 	struct rtc_device	*rtc;
 	struct device		*dev;
@@ -582,6 +597,13 @@ static irqreturn_t cmos_interrupt(int irq, void *p)
 
 		CMOS_READ(RTC_INTR_FLAGS);
 	}
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (rtc_hwtimer.hook != NULL) {
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	spin_unlock(&rtc_lock);
 
 	if (is_intr(irqstat)) {
@@ -598,6 +620,33 @@ static irqreturn_t cmos_interrupt(int irq, void *p)
 #define	INITSECTION	__init
 #endif
 
+#ifdef CONFIG_HWTIMER_HOOKS
+static int rtc_get_freq(void)
+{
+	return cmos_rtc.rtc->irq_freq;
+}
+
+static int rtc_set_freq(int freq)
+{
+	unsigned long newfreq;
+	/* Note - assumes freq is power of 2.  Should
+	 * round freq up to nearest power of 2 */
+	newfreq = freq;
+	return cmos_irq_set_freq(cmos_rtc.dev, newfreq);
+}
+
+static int rtc_start(void)
+{
+	return cmos_irq_set_state(cmos_rtc.dev, 1);
+}
+
+static int rtc_stop(void)
+{
+	return cmos_irq_set_state(cmos_rtc.dev, 0);
+}
+
+#endif	/* CONFIG_HWTIMER_HOOKS */
+
 static int INITSECTION
 cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
 {
@@ -722,7 +771,7 @@ cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
 			rtc_cmos_int_handler = cmos_interrupt;
 
 		retval = request_irq(rtc_irq, rtc_cmos_int_handler,
-				IRQF_DISABLED, cmos_rtc.rtc->dev.bus_id,
+				RTC_IRQFLAGS, cmos_rtc.rtc->dev.bus_id,
 				cmos_rtc.rtc);
 		if (retval < 0) {
 			dev_dbg(dev, "IRQ %d is already in use\n", rtc_irq);
@@ -750,6 +799,30 @@ cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
 			cmos_rtc.century ? ", y3k" : "",
 			is_hpet_enabled() ? ", hpet irqs" : "");
 
+#ifdef CONFIG_HWTIMER_HOOKS
+        spin_lock_irq(&rtc_lock);
+        if (!hpet_set_periodic_freq(cmos_rtc.rtc->irq_freq)) 
+                /* Initialize periodic freq. to CMOS reset default, which is 1024Hz */
+                CMOS_WRITE(((CMOS_READ(RTC_FREQ_SELECT) & 0xF0) | 0x06), RTC_FREQ_SELECT);
+        spin_unlock_irq(&rtc_lock);
+
+	rtc_hwtimer_data.name = "rtc";
+	rtc_hwtimer_data.desc = "Generic PC style RTC";
+	rtc_hwtimer_data.def_freq = 1024;
+	rtc_hwtimer_data.min_freq = 2;
+	rtc_hwtimer_data.max_freq = 8192;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = rtc_set_freq;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+#endif
+
 	return 0;
 
 cleanup2:
@@ -775,6 +848,10 @@ static void __exit cmos_do_remove(struct device *dev)
 	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
 	struct resource *ports;
 
+#ifdef CONFIG_HWTIMER_HOOKS
+       unregister_hwtimer(&rtc_hwtimer);
+#endif
+
 	cmos_do_shutdown();
 
 	sysfs_remove_bin_file(&dev->kobj, &nvram);
-- 
1.5.5.1

