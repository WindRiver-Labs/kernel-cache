From af185f1350e1448f7dfaa51e8d0497778b40d524 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Thu, 3 Jul 2008 22:59:54 -0400
Subject: [PATCH] This patch supports hwclock API on MPC5121e ADS board,

wrs_severity: new_functionality
wrs_scope: driver

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/Makefile          |    1 +
 arch/powerpc/platforms/512x/mpc512x_hwtimer.c |  225 +++++++++++++++++++++++++
 2 files changed, 226 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/mpc512x_hwtimer.c

diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index 90be2f5..4c9309e 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -4,3 +4,4 @@
 obj-y				+= clock.o mpc512x_shared.o
 obj-$(CONFIG_MPC5121_ADS)	+= mpc5121_ads.o mpc5121_ads_cpld.o
 obj-$(CONFIG_MPC5121_GENERIC)	+= mpc5121_generic.o
+obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
diff --git a/arch/powerpc/platforms/512x/mpc512x_hwtimer.c b/arch/powerpc/platforms/512x/mpc512x_hwtimer.c
new file mode 100644
index 0000000..3b18656
--- /dev/null
+++ b/arch/powerpc/platforms/512x/mpc512x_hwtimer.c
@@ -0,0 +1,225 @@
+/*
+* Hardware timers API driver for mpc512x.
+*
+* Copyright (c) 2007 Wind River Systems, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irqreturn.h>
+#include <asm/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/mpc512x.h>
+#include <linux/interrupt.h>
+#include <linux/hwtimer.h>
+
+#define GPT_MODE_CE		(1<<12)
+#define GPT_MODE_IntE		(1<<8)
+#define GPT_MODE_CONT		(1<<10)
+#define GPT_MODE_MS_TIMER	(0x4)
+#define COUNTER_MAXIMUM		(0xffffUL)
+/* GPT */
+struct mpc512x_gpt {
+	u32 mode;		/* GPTx + 0x00 */
+	u32 count;		/* GPTx + 0x04 */
+	u32 pwm;		/* GPTx + 0x08 */
+	u32 status;		/* GPTx + 0X0c */
+};
+
+struct mpc5121e_gpt	{
+	unsigned short count;	/* timer ticks before gpt kicks in */
+	unsigned int prescaler;
+	long ipb_freq;
+	int irq;
+	struct mpc512x_gpt __iomem *regs;
+};
+
+static struct mpc5121e_gpt *gpt_hwtimer;
+
+#define HWTIMER_DEF_FREQ 1024
+
+static DECLARE_HWTIMER_LOCK(mpc512x_hwtimer_lock);
+static int mpc512x_freq = HWTIMER_DEF_FREQ;
+
+/*
+ * Theoretically, for 512x gpt,
+ * The min_freq is 0, when counter equals COUNTER_MAXIMUM and prescaler equals
+ * COUNTER_MAXIMUM, about 43 seconds elasped, a gpt interrupt can produce.
+ * The max_freq is ipb_freq, that's to day, equals bus-frequency, when counter
+ * equals 0x1 and prescaler equals 0x1.
+ */
+static struct hwtimer_data mpc512x_hwtimer_data = {
+	.name		= "mpc512x hwtimer",
+	.desc		= "MPC512x General-purpose timer",
+	.def_freq	= HWTIMER_DEF_FREQ,
+};
+
+static int mpc512x_hwtimer_get_freq(void)
+{
+	return mpc512x_freq;
+}
+
+static int mpc512x_hwtimer_set_freq(int freq)
+{
+	unsigned long flags;
+	unsigned int counter;
+	unsigned int prescaler = 0x1;
+
+	if (freq <=  0)	{
+		counter = COUNTER_MAXIMUM;
+		prescaler = COUNTER_MAXIMUM;
+	} else if (freq >= gpt_hwtimer->ipb_freq) {
+		counter = 0xff;	/* This is an experiment value */
+		prescaler = 0x1;
+	} else {
+		counter = gpt_hwtimer->ipb_freq / freq;
+		while (counter > COUNTER_MAXIMUM) {
+			prescaler =  prescaler << 1;
+			counter = counter >> 1;
+		}
+	}
+	spin_lock_irqsave(&mpc512x_hwtimer_lock, flags);
+	gpt_hwtimer->count = counter;
+	gpt_hwtimer->prescaler = prescaler << 16;
+	mpc512x_freq = freq;
+	spin_unlock_irqrestore(&mpc512x_hwtimer_lock, flags);
+
+	return 0;
+}
+
+int mpc512x_hwtimer_start(void)
+{
+	unsigned long flags;
+	int gpt_mode  = in_be32(&gpt_hwtimer->regs->mode);
+
+	spin_lock_irqsave(&mpc512x_hwtimer_lock, flags);
+	/* disable */
+	out_be32(&gpt_hwtimer->regs->mode, (~GPT_MODE_CE) & gpt_mode);
+	/* set timeout, with maximum prescaler */
+	out_be32(&gpt_hwtimer->regs->count, \
+		gpt_hwtimer->prescaler | gpt_hwtimer->count);
+	/* enable gpt */
+	out_be32(&gpt_hwtimer->regs->mode, \
+		GPT_MODE_CE | GPT_MODE_IntE | gpt_mode);
+
+	spin_unlock_irqrestore(&mpc512x_hwtimer_lock, flags);
+	return 0;
+}
+
+static int mpc512x_hwtimer_stop(void)
+{
+	unsigned long flags;
+	int gpt_mode  = in_be32(&gpt_hwtimer->regs->mode);
+
+	/* Stop timer */
+	spin_lock_irqsave(&mpc512x_hwtimer_lock, flags);
+	out_be32(&gpt_hwtimer->regs->mode, (~(GPT_MODE_CE)) & gpt_mode);
+	spin_unlock_irqrestore(&mpc512x_hwtimer_lock, flags);
+	return 0;
+}
+
+static struct hwtimer mpc512x_hwtimer = {
+	.data		= &mpc512x_hwtimer_data,
+	.set_freq	= mpc512x_hwtimer_set_freq,
+	.get_freq	= mpc512x_hwtimer_get_freq,
+	.start		= mpc512x_hwtimer_start,
+	.stop		= mpc512x_hwtimer_stop,
+	.lock		= &mpc512x_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/*
+ * IRQ handler for the clock API hwtimer
+ */
+static int mpc512x_hwtimer_interrupt(int irq, void *dev_id)
+{
+	out_be32(&gpt_hwtimer->regs->status, 0xff);
+
+	spin_lock(mpc512x_hwtimer.lock);
+	if (mpc512x_hwtimer.hook != NULL) {
+		(mpc512x_hwtimer.hook) (mpc512x_hwtimer.hook_data);
+	}
+	spin_unlock(mpc512x_hwtimer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static int __init  mpc512x_hwtimer_init(void)
+{
+	struct mpc5121e_gpt *gpt = NULL;
+	struct device_node *hwtimer = NULL;
+	struct resource res ;
+	int err;
+
+	hwtimer = of_find_node_by_type(NULL, "gpt-hwtimer");
+	if (of_address_to_resource(hwtimer, 0, &res)) {
+		return -EINVAL;
+	}
+
+	gpt = kzalloc(sizeof(struct mpc5121e_gpt), GFP_KERNEL);
+	if (!gpt)
+		return -ENOMEM;
+
+	gpt->ipb_freq = mpc512x_find_ips_freq(hwtimer);
+
+	gpt->irq = irq_of_parse_and_map(hwtimer, 0);
+
+	if (gpt->irq < 0) {
+		err = -ENXIO;
+		goto out_free;
+	}
+
+	gpt->regs = ioremap((phys_addr_t)res.start, (res.end - res.start + 1));
+
+	if (!gpt->regs) {
+		printk(KERN_ERR "mpc512x - failed to map gpt controller\n");
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	err = request_irq(gpt->irq, mpc512x_hwtimer_interrupt, 0, \
+			"mpc512x-hwtimer", (void *)gpt);
+	if (err != 0) {
+		printk(KERN_ERR "mpc512x-hwtimer: cannot register \
+			IRQ %d, ret:%d\n", gpt->irq, err);
+		err =  -EIO;
+		goto out_release;
+	}
+
+	out_be32(&gpt->regs->mode, \
+		GPT_MODE_CONT | GPT_MODE_MS_TIMER | in_be32(&gpt->regs->mode));
+
+	gpt_hwtimer = gpt;
+
+	spin_lock_init(&mpc512x_hwtimer_lock);
+	mpc512x_hwtimer_set_freq(HWTIMER_DEF_FREQ);
+	mpc512x_hwtimer_data.min_freq
+			 = (gpt->ipb_freq / COUNTER_MAXIMUM) / COUNTER_MAXIMUM;
+	mpc512x_hwtimer_data.max_freq = gpt->ipb_freq;
+	register_hwtimer(&mpc512x_hwtimer);
+	return 0;
+
+ out_release:
+	iounmap(gpt->regs);
+ out_free:
+	kfree(gpt);
+	return err;
+}
+
+arch_initcall(mpc512x_hwtimer_init);
-- 
1.5.5.1

