Add clock API support for broadcom1x80.

wrs_severity: critical
wrs_scope: bsp

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 b/arch/mips/sibyte/bcm1480/time.c |   42 ++++++++++++++++++++++++++++++++++++++
 1 files changed, 42 insertions(+)
---

--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -55,6 +55,36 @@
 
 extern int bcm1480_steal_irq(int irq);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+
+int sb1480_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data sb1480_timer_data = {
+	.name = "SB1480 timer",
+	.desc = "SB1480 Kernel jiffy timer",
+	.def_freq = HZ,
+	.min_freq = HZ,
+	.max_freq = HZ
+};
+
+static DECLARE_HWTIMER_LOCK(sb1480_timer_lock);
+
+static struct hwtimer sb1480_timer = {
+	.data = &sb1480_timer_data,
+	.set_freq = NULL,
+	.get_freq = sb1480_timer_get_freq,
+	.start = NULL,
+	.stop = NULL,
+	.lock = &sb1480_timer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 void bcm1480_time_init(void)
 {
 	int cpu = smp_processor_id();
@@ -65,6 +95,11 @@ void bcm1480_time_init(void)
 		BUG();
 	}
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (cpu == 0)
+		register_hwtimer(&sb1480_timer);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	bcm1480_mask_irq(cpu, irq);
 
 	/* Map the timer interrupt to ip[4] of this cpu */
@@ -104,6 +139,13 @@ void bcm1480_timer_interrupt(void)
 	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	if (cpu == 0) {
+#ifdef CONFIG_HWTIMER_HOOKS
+		spin_lock(sb1480_timer.lock);
+		if (sb1480_timer.hook != NULL)
+			(sb1480_timer.hook)(sb1480_timer.hook_data);
+		spin_unlock(sb1480_timer.lock);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 		/*
 		 * CPU 0 handles the global timer interrupt job
 		 */
