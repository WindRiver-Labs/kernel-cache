From: Paul Gortmaker <paul.gortmaker@windriver.com>
Subject: [PATCH] interface for arbitrary hardware timer

Add a basic interface that an arbitrary hardware timer device can use
to make its facilities available to other kernel modules.  Used by Scopetools
to abstract out board specific variations in available timer devices.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 include/linux/hwtimer.h |   80 ++++++++++++++
 init/Kconfig            |   10 ++
 kernel/Makefile         |    1 +
 kernel/hwtimer.c        |  275 +++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 366 insertions(+), 0 deletions(-)
 create mode 100644 include/linux/hwtimer.h
 create mode 100644 kernel/hwtimer.c

diff --git a/include/linux/hwtimer.h b/include/linux/hwtimer.h
new file mode 100644
index 0000000..06ce8b5
--- /dev/null
+++ b/include/linux/hwtimer.h
@@ -0,0 +1,80 @@
+/*
+* hwtimer.h, generic interface to access hardware timers in the system
+*
+* Copyright (c) 2006 Wind River Systems, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/list.h>
+#include <linux/ptrace.h>
+#include <linux/spinlock.h>
+
+/*
+ * The unchanging information visible to the users of the timers
+ */
+
+struct hwtimer_data {
+	char* name;		/* Name for human consumption. */
+	char* desc;		/* Description for human consumption. */
+	unsigned int def_freq;	/* Default timer frequency (Hz). */
+	unsigned int min_freq;	/* Minimum frequency API can set (Hz) */
+	unsigned int max_freq;	/* Maximum frequency API can set (Hz) */
+};
+
+/*
+ * Functions for the users of the timer(s).
+ */
+extern int max_hwtimer_index(void);
+extern int get_hwtimer_info(unsigned int index, struct hwtimer_data **data);
+extern int get_hwtimer_freq(unsigned int index);
+extern int set_hwtimer_freq(unsigned int index, int new_freq);
+extern int start_hwtimer(unsigned int index);
+extern int stop_hwtimer(unsigned int index);
+extern int add_hwtimer_hook(unsigned int index,
+	void (*hook_function) (void *), void *hook_data);
+extern int del_hwtimer_hook(unsigned int index,
+	void (*hook_function) (void *));
+
+/*
+ * Functions etc. for the suppliers of the timer resource.  Not to be
+ * monkeyed with by the consumers of the timer resource.
+ */
+
+struct hwtimer {
+	struct hwtimer_data *data;
+	int (*set_freq)(int freq);
+	int (*get_freq)(void);
+	int (*start)(void);
+	int (*stop)(void);
+	void (*hook)(void *data);
+	void *hook_data;
+#ifdef CONFIG_PREEMPT_RT
+	raw_spinlock_t *lock;
+#else
+	spinlock_t *lock;
+#endif
+	int index;
+	struct list_head list;
+};
+
+#ifdef CONFIG_PREEMPT_RT
+#define DECLARE_HWTIMER_LOCK(x) raw_spinlock_t x = RAW_SPIN_LOCK_UNLOCKED(x)
+#else
+#define DECLARE_HWTIMER_LOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+
+int register_hwtimer(struct hwtimer *hwtimer);
+int unregister_hwtimer(struct hwtimer *hwtimer);
diff --git a/init/Kconfig b/init/Kconfig
index 7e6dae1..9d5bd8c 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -515,6 +515,16 @@ source "usr/Kconfig"
 
 endif
 
+config HWTIMER_HOOKS
+	bool "Generic hardware timer hooks"
+	default y
+	help
+	  This provides a mechanism where any device that provides
+	  timer functionality can register itself as available for other
+	  parts of the kernel to use through a standard API that allows
+	  querying its cababilities, changing the frequency, and hooking
+	  a function to a timer event.
+
 config CC_OPTIMIZE_FOR_SIZE
 	bool "Optimize for size"
 	default y
diff --git a/kernel/Makefile b/kernel/Makefile
index 4e1d7df..06df80b 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_PM) += power/
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
 obj-$(CONFIG_KEXEC) += kexec.o
 obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
+obj-$(CONFIG_HWTIMER_HOOKS) += hwtimer.o
 obj-$(CONFIG_COMPAT) += compat.o
 obj-$(CONFIG_CGROUPS) += cgroup.o
 obj-$(CONFIG_CGROUP_DEBUG) += cgroup_debug.o
diff --git a/kernel/hwtimer.c b/kernel/hwtimer.c
new file mode 100644
index 0000000..943635e
--- /dev/null
+++ b/kernel/hwtimer.c
@@ -0,0 +1,275 @@
+/*
+* hwtimer.c, generic interface to access hardware timers in the system
+*
+* Copyright (c) 2006 Wind River Systems, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+
+#include <linux/hwtimer.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+
+
+static LIST_HEAD(hwtimer_list);
+static spinlock_t hwtimer_list_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * Assumes there will never be more than MAXINT timer devices installed
+ * on a system....
+ */
+
+static int next_index = 0;
+
+static int assign_hwtimer_index(void)
+{
+	return next_index++;
+}
+
+static struct hwtimer *find_hwtimer(int index)
+{
+	struct list_head *pos;
+	struct hwtimer *hwt;
+
+	spin_lock(&hwtimer_list_lock);
+	list_for_each(pos, &hwtimer_list) {
+		hwt = list_entry(pos, struct hwtimer, list);
+		if (hwt->index == index) {
+			spin_unlock(&hwtimer_list_lock);
+			return hwt;
+		}
+	}
+
+	spin_unlock(&hwtimer_list_lock);
+	return NULL;
+}
+
+/*********************************************************************
+ *  Functions that are exported for the users of the timers
+ *********************************************************************/
+
+int max_hwtimer_index(void)
+{
+	return next_index;
+}
+EXPORT_SYMBOL(max_hwtimer_index);
+
+int get_hwtimer_info(unsigned int index, struct hwtimer_data **data)
+{
+	struct hwtimer *hwtimer;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	*data = hwtimer->data;
+
+	return 0;
+}
+EXPORT_SYMBOL(get_hwtimer_info);
+
+int get_hwtimer_freq(unsigned int index)
+{
+	struct hwtimer *hwtimer;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	return hwtimer->get_freq();
+}
+EXPORT_SYMBOL(get_hwtimer_freq);
+
+int set_hwtimer_freq(unsigned int index, int freq)
+{
+	struct hwtimer *hwtimer;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	if (hwtimer->set_freq == NULL)
+		return -ENOSYS;
+
+	if (freq > hwtimer->data->max_freq || freq < hwtimer->data->min_freq)
+		return -EINVAL;
+
+	return hwtimer->set_freq(freq);
+}
+EXPORT_SYMBOL(set_hwtimer_freq);
+
+/*
+ * Start a timer device creating periodic events.  May not be supported
+ * on all devices.
+ */
+int start_hwtimer(unsigned int index)
+{
+	struct hwtimer *hwtimer;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	if (hwtimer->start == NULL)
+		return -EINVAL;
+
+	return hwtimer->start();
+}
+EXPORT_SYMBOL(start_hwtimer);
+
+/*
+ * Stop a timer device creating periodic events.  May not be supported
+ * on all devices.
+ */
+int stop_hwtimer(unsigned int index)
+{
+	struct hwtimer *hwtimer;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	if (hwtimer->stop == NULL)
+		return -EINVAL;
+
+	return hwtimer->stop();
+}
+EXPORT_SYMBOL(stop_hwtimer);
+
+int add_hwtimer_hook(unsigned int index,
+       	void (*hook_function) (void *), void *hook_data)
+{
+	struct hwtimer *hwtimer;
+	unsigned long flags;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	spin_lock_irqsave(hwtimer->lock, flags);
+
+	if (hwtimer->hook != NULL) {
+		spin_unlock_irqrestore(hwtimer->lock, flags);
+		return -EBUSY;
+	}
+
+	hwtimer->hook_data = hook_data;
+	mb();
+	hwtimer->hook = hook_function;
+
+	spin_unlock_irqrestore(hwtimer->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(add_hwtimer_hook);
+
+int del_hwtimer_hook(unsigned int index,
+	       void (*hook_function) (void *data))
+{
+	struct hwtimer *hwtimer;
+	unsigned long flags;
+
+	hwtimer = find_hwtimer(index);
+
+	if (hwtimer == NULL)
+		return -ENODEV;
+
+	spin_lock_irqsave(hwtimer->lock, flags);
+
+	if (hwtimer->hook == NULL) {
+		spin_unlock_irqrestore(hwtimer->lock, flags);
+		return -EINVAL;
+	}
+
+	hwtimer->hook = NULL;
+	spin_unlock_irqrestore(hwtimer->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(del_hwtimer_hook);
+
+/*********************************************************************
+ * Functions that the providers of the timer resources make use of
+ *********************************************************************/
+
+/*
+ * Called by a timer device that is willing to share its facilities
+ */
+int register_hwtimer(struct hwtimer* hwtimer)
+{
+
+	if (hwtimer == NULL) {
+		printk(KERN_WARNING "hwtimer: Timer to reg is NULL\n");
+		return -EINVAL;
+	}
+
+	if (hwtimer->data == NULL) {
+		printk(KERN_WARNING "Timer has no data\n");
+		return -EINVAL;
+	}
+
+	if (hwtimer->data->name == NULL) {
+		printk(KERN_WARNING "Timer has no name\n");
+		return -EINVAL;
+	}
+
+	if (hwtimer->data->desc == NULL) {
+		printk(KERN_WARNING "Timer has no description\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&hwtimer_list_lock);
+	hwtimer->index = assign_hwtimer_index();
+	list_add(&(hwtimer->list), &hwtimer_list);
+	spin_unlock(&hwtimer_list_lock);
+
+	printk(KERN_INFO "hwtimer: Added %s (%s) at index=%d\n",
+	       	hwtimer->data->name, hwtimer->data->desc, hwtimer->index);
+
+	return 0;
+}
+EXPORT_SYMBOL(register_hwtimer);
+
+int unregister_hwtimer(struct hwtimer *hwtimer)
+{
+	if (hwtimer == NULL) {
+		printk(KERN_WARNING "hwtimer: Timer to unreg is NULL\n");
+		return -EINVAL;
+	}
+
+	/* Warn on any remaining hook functions here */
+
+	if (hwtimer->hook != NULL)
+		printk(KERN_WARNING "hwtimer: hook present on dead timer %s\n",
+				hwtimer->data->name);
+
+	printk(KERN_INFO "hwtimer: removing timer %s\n", hwtimer->data->name);
+
+	spin_lock(&hwtimer_list_lock);
+	list_del(&(hwtimer->list));
+	spin_unlock(&hwtimer_list_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(unregister_hwtimer);
+
-- 
1.5.5.1

