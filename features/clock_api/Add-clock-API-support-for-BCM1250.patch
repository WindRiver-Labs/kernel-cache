From c3991be36c026732dad28f26ab5941ac8e2c6dc5 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 30 Oct 2008 09:11:42 +0800
Subject: [PATCH] Add clock API support for BCM1250

The BCM1250 doesn't have a free hardware clock source for this API,
so we have to piggy-back on the kernel jiffy timer.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/mips/kernel/cevt-sb1250.c |   56 ++++++++++++++++++++++++++++++++++++++++
 1 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/cevt-sb1250.c b/arch/mips/kernel/cevt-sb1250.c
index 63ac3ad..b965dd1 100644
--- a/arch/mips/kernel/cevt-sb1250.c
+++ b/arch/mips/kernel/cevt-sb1250.c
@@ -32,6 +32,42 @@
 #define IMR_IP3_VAL	K_INT_MAP_I1
 #define IMR_IP4_VAL	K_INT_MAP_I2
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+
+int sb1250_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data sb1250_timer_data = {
+	.name = "SB1250 timer",
+	.desc = "SB1250 Kernel jiffy timer",
+	.def_freq = HZ,
+	.min_freq = HZ,
+	.max_freq = HZ
+};
+
+static DECLARE_HWTIMER_LOCK(sb1250_timer_lock);
+
+static struct hwtimer sb1250_timer = {
+	.data = &sb1250_timer_data,
+	.set_freq = NULL,
+	.get_freq = sb1250_timer_get_freq,
+	.start = NULL,
+	.stop = NULL,
+	.lock = &sb1250_timer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+
+/* the hwtimer callbacks are meant to be triggered once per tick, and in a
+   round-robin fashion across the active cpus.  We accomplish this by keeping
+   a per-cpu count of how many ticks are left until the given cpu should
+   activate the hwtimer callback. */
+static atomic_t hwtimer_cpu_trigger[NR_CPUS];
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 /*
  * The general purpose timer ticks at 1MHz independent if
  * the rest of the system
@@ -98,6 +134,17 @@ static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
 
 	cd->event_handler(cd);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (atomic_dec_and_test(&hwtimer_cpu_trigger[smp_processor_id()])) {
+		atomic_set(&hwtimer_cpu_trigger[smp_processor_id()],
+			   num_online_cpus());
+		spin_lock(sb1250_timer.lock);
+		if (sb1250_timer.hook != NULL)
+			(sb1250_timer.hook)(sb1250_timer.hook_data);
+		spin_unlock(sb1250_timer.lock);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	return IRQ_HANDLED;
 }
 
@@ -116,6 +163,15 @@ void __cpuinit sb1250_clockevent_init(void)
 	/* Only have 4 general purpose timers, and we use last one as hpt */
 	BUG_ON(cpu > 2);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (smp_processor_id() == 0) {
+		unsigned int i;
+		for_each_possible_cpu(i)
+			atomic_set(&hwtimer_cpu_trigger[i], i + 1);
+		register_hwtimer(&sb1250_timer);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	sprintf(name, "sb1250-counter-%d", cpu);
 	cd->name		= name;
 	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
-- 
1.6.0.90.g436ed

