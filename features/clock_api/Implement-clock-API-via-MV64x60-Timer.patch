From cf7b17b4eeab1942ba7755d7b571e3ba6b805ee2 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 25 Dec 2008 18:25:34 +0800
Subject: [PATCH] Implement clock API via MV64x60 Timer

Add the required hooks and support to implment a clock API
driver via the MV64x60

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/misc/Kconfig           |    5 ++
 drivers/misc/Makefile          |    1 +
 drivers/misc/mv64x60_hwtimer.c |  137 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 143 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/mv64x60_hwtimer.c

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index e332c69..2ff71e5 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -495,4 +495,9 @@ config MV64X60_TIMER
         help
           This option enables the marvell timers support.
 
+config MV64X60_HWTIMER
+        bool
+        depends on MV64X60_TIMER && HWTIMER_HOOKS
+        default y
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 4755564..06cceb5 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -32,3 +32,4 @@ obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_MV64X60_TIMER)     += mv64460_timer.o
+obj-$(CONFIG_MV64X60_HWTIMER)   += mv64x60_hwtimer.o
diff --git a/drivers/misc/mv64x60_hwtimer.c b/drivers/misc/mv64x60_hwtimer.c
new file mode 100644
index 0000000..81a2a38
--- /dev/null
+++ b/drivers/misc/mv64x60_hwtimer.c
@@ -0,0 +1,137 @@
+/*
+ * drivers/misc/timer_clockapi.c
+ * Clock API inmplementation based on Marvel MV64X60 timer driver.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include "mv64460_timer.h"
+
+#include <linux/hwtimer.h>
+
+#define HWTIMER_MIN_FREQ 2
+#define HWTIMER_MAX_FREQ 8192
+#define HWTIMER_DEF_FREQ 1024
+
+#define HWTIMER_NUMBER	0
+
+static DECLARE_HWTIMER_LOCK(mv64x60_hwtimer_lock);
+static int mv64x60_freq = HWTIMER_DEF_FREQ;
+static int mv64x60_start = 0;
+
+static struct hwtimer mv64x60_hwtimer;
+
+static struct hwtimer_data mv64x60_hwtimer_data = {
+	.name		= "MV64x60 hwtimer",
+	.desc		= "MV64x60 timer 0",
+	.def_freq	= HWTIMER_DEF_FREQ,
+	.min_freq	= HWTIMER_MIN_FREQ,
+	.max_freq	= HWTIMER_MAX_FREQ 
+};
+
+/*
+ * Timer callback function for the clock API hwtimer
+ */
+static void mv64x60_hwtimer_callback(void *data)
+{
+	spin_lock(mv64x60_hwtimer.lock);
+
+	if (mv64x60_hwtimer.hook != NULL) {
+		(mv64x60_hwtimer.hook) (mv64x60_hwtimer.hook_data);
+	}
+
+	spin_unlock(mv64x60_hwtimer.lock);
+}
+
+static int mv64x60_hwtimer_get_freq(void)
+{
+	return mv64x60_freq;
+}
+
+static int mv64x60_hwtimer_set_freq(int freq)
+{
+	unsigned long flags;
+
+	if ((freq < HWTIMER_MIN_FREQ) || (freq > HWTIMER_MAX_FREQ))
+		return -EINVAL;
+
+	spin_lock_irqsave(&mv64x60_hwtimer_lock, flags);
+
+	mv64x60_freq = freq;
+
+	if (mv64x60_start) {
+		mv64x60_timer_stop(HWTIMER_NUMBER);
+		mv64x60_timer_start(HWTIMER_NUMBER, (1000000L + freq/2) / freq,
+			 	    mv64x60_hwtimer_callback, NULL, 1);
+	}
+
+
+	spin_unlock_irqrestore(&mv64x60_hwtimer_lock, flags);
+	return 0;
+}
+
+static int mv64x60_hwtimer_start(void)
+{
+	unsigned long flags;
+
+	/* Start timer */
+	spin_lock_irqsave(&mv64x60_hwtimer_lock, flags);
+	if (!mv64x60_start) {
+		mv64x60_timer_start(HWTIMER_NUMBER, (1000000L + mv64x60_freq/2) / mv64x60_freq,
+			 	    mv64x60_hwtimer_callback, NULL, 1);
+		mv64x60_start = 1;
+	}
+	spin_unlock_irqrestore(&mv64x60_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static int mv64x60_hwtimer_stop(void)
+{
+	unsigned long flags;
+
+	/* Stop timer */
+	spin_lock_irqsave(&mv64x60_hwtimer_lock, flags);
+	if (mv64x60_start) {
+		mv64x60_timer_stop(HWTIMER_NUMBER);
+		mv64x60_start = 0;
+	}
+	spin_unlock_irqrestore(&mv64x60_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static struct hwtimer mv64x60_hwtimer = {
+	.data		= &mv64x60_hwtimer_data,
+	.set_freq	= mv64x60_hwtimer_set_freq,
+	.get_freq	= mv64x60_hwtimer_get_freq,
+	.start		= mv64x60_hwtimer_start,
+	.stop		= mv64x60_hwtimer_stop,
+	.lock		= &mv64x60_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+
+static int  __init mv64x60_hwtimer_init (void)
+{
+	return register_hwtimer(&mv64x60_hwtimer);
+}
+
+static void __exit mv64x60_hwtimer_exit (void)
+{
+	unregister_hwtimer(&mv64x60_hwtimer);
+}
+
+module_init(mv64x60_hwtimer_init);
+module_exit(mv64x60_hwtimer_exit);
+
+MODULE_LICENSE("GPL");
+
-- 
1.6.0.3

