From: Xiaopeng Yang <xiaopeng.yang@windriver.com>
Subject: clock API for intel_ixdp4xx.

Add clock API support for intel_ixdp4xx.

Signed-off-by: Xiaopeng Yang <xiaopeng.yang@windriver.com>
---
 arch/arm/mach-ixp4xx/common.c |  121 +++++++++++++++++++++++++++++++++++++++++
 1 files changed, 121 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f6d66dc..09f1115 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -41,6 +41,10 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 static int __init ixp4xx_clocksource_init(void);
 static int __init ixp4xx_clockevent_init(void);
 static struct clock_event_device clockevent_ixp4xx;
@@ -283,6 +287,113 @@ static struct irqaction ixp4xx_timer_irq = {
 	.handler	= ixp4xx_timer_interrupt,
 };
 
+#ifdef CONFIG_HWTIMER_HOOKS
+
+#define HWTIMER_MIN_FREQ 2
+#define HWTIMER_MAX_FREQ 8192
+#define HWTIMER_DEF_FREQ 1024
+
+static DECLARE_HWTIMER_LOCK(ixp4xx_hwtimer_lock);
+static int ixp4xx_freq = HWTIMER_DEF_FREQ;
+
+static struct hwtimer_data ixp4xx_hwtimer_data = {
+	.name		= "IXP4xx hwtimer",
+	.desc		= "IXP465 General-Purpose timer2",
+	.def_freq	= HWTIMER_DEF_FREQ,
+	.min_freq	= HWTIMER_MIN_FREQ,
+	.max_freq	= HWTIMER_MAX_FREQ 
+};
+
+static int ixp4xx_hwtimer_get_freq(void)
+{
+	return ixp4xx_freq;
+}
+
+static int ixp4xx_hwtimer_set_freq(int freq)
+{
+	unsigned long reload;
+	unsigned long flags;
+
+	if ((freq < HWTIMER_MIN_FREQ) || (freq > HWTIMER_MAX_FREQ))
+		return -EINVAL;
+
+	spin_lock_irqsave(&ixp4xx_hwtimer_lock, flags);
+
+	reload = *IXP4XX_OSRT2;
+
+	/* Stop timer before writing a new value */
+	*IXP4XX_OSRT2 = reload & ~IXP4XX_OST_ENABLE;
+
+	*IXP4XX_OSRT2 = ((FREQ / freq - 1 + 2) & ~IXP4XX_OST_RELOAD_MASK) |
+	       		(reload & IXP4XX_OST_RELOAD_MASK);
+
+	ixp4xx_freq = freq;
+
+	spin_unlock_irqrestore(&ixp4xx_hwtimer_lock, flags);
+	return 0;
+}
+
+static int ixp4xx_hwtimer_start(void)
+{
+	unsigned long flags;
+
+	/* Start timer */
+	spin_lock_irqsave(&ixp4xx_hwtimer_lock, flags);
+	*IXP4XX_OSRT2 |= IXP4XX_OST_ENABLE;
+	spin_unlock_irqrestore(&ixp4xx_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static int ixp4xx_hwtimer_stop(void)
+{
+	unsigned long flags;
+
+	/* Stop timer */
+	spin_lock_irqsave(&ixp4xx_hwtimer_lock, flags);
+	*IXP4XX_OSRT2 &= ~IXP4XX_OST_ENABLE;
+	spin_unlock_irqrestore(&ixp4xx_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static struct hwtimer ixp4xx_hwtimer = {
+	.data		= &ixp4xx_hwtimer_data,
+	.set_freq	= ixp4xx_hwtimer_set_freq,
+	.get_freq	= ixp4xx_hwtimer_get_freq,
+	.start		= ixp4xx_hwtimer_start,
+	.stop		= ixp4xx_hwtimer_stop,
+	.lock		= &ixp4xx_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/*
+ * IRQ handler for the clock API hwtimer
+ */
+static irqreturn_t ixp4xx_hwtimer_interrupt(int irq, void *dev_id)
+{
+	/* Clear Pending Interrupt by writing '1' to it */
+	*IXP4XX_OSST = IXP4XX_OSST_TIMER_2_PEND;
+
+	spin_lock(ixp4xx_hwtimer.lock);
+
+	if (ixp4xx_hwtimer.hook != NULL) {
+		(ixp4xx_hwtimer.hook) (ixp4xx_hwtimer.hook_data);
+	}
+
+	spin_unlock(ixp4xx_hwtimer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ixp4xx_hwtimer_irq = {
+	.name		= "IXP4xx HWTimer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= ixp4xx_hwtimer_interrupt,
+};
+#endif  /* CONFIG_HWTIMER_HOOKS */
+
 void __init ixp4xx_timer_init(void)
 {
 	/* Reset/disable counter */
@@ -297,6 +408,16 @@ void __init ixp4xx_timer_init(void)
 	/* Connect the interrupt handler and enable the interrupt */
 	setup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);
 
+#ifdef  CONFIG_HWTIMER_HOOKS
+	*IXP4XX_OSST = IXP4XX_OSST_TIMER_2_PEND;
+
+	*IXP4XX_OSRT2 = (FREQ / HWTIMER_DEF_FREQ - 1 + 2) & ~IXP4XX_OST_RELOAD_MASK;
+
+	setup_irq(IRQ_IXP4XX_TIMER2, &ixp4xx_hwtimer_irq);
+
+	register_hwtimer(&ixp4xx_hwtimer);
+#endif  /*  CONFIG_HWTIMER_HOOKS */
+
 	ixp4xx_clocksource_init();
 	ixp4xx_clockevent_init();
 }
-- 
1.5.5.1

