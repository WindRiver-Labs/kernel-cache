From b39258b9b9f216a60848b8be882d804863fdb4eb Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Thu, 3 Jul 2008 16:27:07 -0400
Subject: [PATCH] clock API drivers for mpc832x_mds, mpc8349emitx, mpc836x_mds

and mpc8313e_rdb.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/powerpc/boot/dts/mpc832x_mds.dts     |    8 ++
 arch/powerpc/boot/dts/mpc8349emitx.dts    |    8 ++
 arch/powerpc/boot/dts/mpc836x_mds.dts     |    8 ++
 arch/powerpc/platforms/83xx/Makefile      |    1 +
 arch/powerpc/platforms/83xx/pit_hwtimer.c |  142 +++++++++++++++++++++++++++++
 5 files changed, 167 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/83xx/pit_hwtimer.c

diff --git a/arch/powerpc/boot/dts/mpc832x_mds.dts b/arch/powerpc/boot/dts/mpc832x_mds.dts
index fbc9304..27b55f9 100644
--- a/arch/powerpc/boot/dts/mpc832x_mds.dts
+++ b/arch/powerpc/boot/dts/mpc832x_mds.dts
@@ -79,6 +79,14 @@
 			reg = <0x200 0x100>;
 		};
 
+		pit@400 {
+			device_type = "pit";
+			compatible = "mpc_pit";
+			reg = <400 100>;
+			interrupts = <41 8>;
+			interrupt-parent = < &ipic >;
+		};
+
 		i2c@3000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
diff --git a/arch/powerpc/boot/dts/mpc8349emitx.dts b/arch/powerpc/boot/dts/mpc8349emitx.dts
index 700e076..f616fde 100644
--- a/arch/powerpc/boot/dts/mpc8349emitx.dts
+++ b/arch/powerpc/boot/dts/mpc8349emitx.dts
@@ -63,6 +63,14 @@
 			reg = <0x200 0x100>;
 		};
 
+		pit@400 {
+			device_type = "pit";
+			compatible = "mpc_pit";
+			reg = <400 100>;
+			interrupts = <41 8>;
+			interrupt-parent = < &ipic >;
+		};
+
 		i2c@3000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
diff --git a/arch/powerpc/boot/dts/mpc836x_mds.dts b/arch/powerpc/boot/dts/mpc836x_mds.dts
index a3b76a7..948ee22 100644
--- a/arch/powerpc/boot/dts/mpc836x_mds.dts
+++ b/arch/powerpc/boot/dts/mpc836x_mds.dts
@@ -72,6 +72,14 @@
 			reg = <0x200 0x100>;
 		};
 
+		pit@400 {
+			device_type = "pit";
+			compatible = "mpc_pit";
+			reg = <400 100>;
+			interrupts = <41 8>;
+			interrupt-parent = < &ipic >;
+		};
+
 		i2c@3000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
diff --git a/arch/powerpc/platforms/83xx/Makefile b/arch/powerpc/platforms/83xx/Makefile
index ba5028e..1d939b6 100644
--- a/arch/powerpc/platforms/83xx/Makefile
+++ b/arch/powerpc/platforms/83xx/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_MPC834x_ITX)	+= mpc834x_itx.o
 obj-$(CONFIG_MPC836x_MDS)	+= mpc836x_mds.o
 obj-$(CONFIG_MPC836x_RDK)	+= mpc836x_rdk.o
 obj-$(CONFIG_MPC832x_MDS)	+= mpc832x_mds.o
+obj-$(CONFIG_HWTIMER_HOOKS)	+= pit_hwtimer.o
 obj-$(CONFIG_MPC837x_MDS)	+= mpc837x_mds.o
 obj-$(CONFIG_SBC834x)		+= sbc834x.o
 obj-$(CONFIG_MPC837x_RDB)	+= mpc837x_rdb.o
diff --git a/arch/powerpc/platforms/83xx/pit_hwtimer.c b/arch/powerpc/platforms/83xx/pit_hwtimer.c
new file mode 100644
index 0000000..04186f4
--- /dev/null
+++ b/arch/powerpc/platforms/83xx/pit_hwtimer.c
@@ -0,0 +1,142 @@
+/*
+ * MPC83xx clock API driver.
+ *
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/hwtimer.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <sysdev/fsl_soc.h>
+
+#define PIT_OFFSET      0x00000400
+#define PIT_PTCNR       0x00000000
+#define PIT_PTLDR       0x00000004
+#define PIT_PTPSR       0x00000008
+#define PIT_PTCTR       0x0000000C
+#define PIT_PTEVR       0x00000010
+
+
+#if defined(CONFIG_MPC832x_MDS) || defined (CONFIG_MPC832x_RDB)
+#define	PIT_INTERNAL_CLOCK	(66666666 * 2)
+#elif defined(CONFIG_MPC834x_ITX) || defined(CONFIG_MPC836x_MDS) || defined(CONFIG_SBC834x)
+#define	PIT_INTERNAL_CLOCK	(66666666 * 4)
+#elif defined(CONFIG_MPC8313_RDB)
+#define	PIT_INTERNAL_CLOCK	166666660
+#endif
+#define	PIT_EXTERNAL_CLOCK	(32768)
+#define	PIT_DEFAULT_CLOCK	PIT_INTERNAL_CLOCK
+
+
+#define PIT_CLIN_INTERNAL	0x00
+#define PIT_CLIN_EXTERNAL	0x40
+#define PIT_CLIN_DEFAULT	PIT_CLIN_INTERNAL
+
+static struct hwtimer pit_hwtimer;
+static struct hwtimer_data pit_hwtimer_data;
+static unsigned long pit_freq = 0;
+
+static DECLARE_HWTIMER_LOCK(pit_timer_lock);
+
+static void __iomem *reg_base;
+
+static int pit_irq;
+
+static int pit_get_freq(void)
+{
+	return pit_freq;
+}
+
+static int pit_set_freq(int freq)
+{
+	pit_freq = freq;
+	out_be32(reg_base + PIT_PTCNR, 0x0 );
+	out_be32(reg_base + PIT_PTLDR, PIT_DEFAULT_CLOCK / pit_freq );
+	out_be32(reg_base + PIT_PTCNR, 0x1 | 0x00000080 | PIT_CLIN_DEFAULT );
+	return 0;
+}
+irqreturn_t pit_interrupt(int irq, void *dev_id)
+{
+	out_be32(reg_base + PIT_PTEVR, 0x1);
+	spin_lock (pit_hwtimer.lock);
+	if (pit_hwtimer.hook != NULL) {
+		pit_hwtimer.hook(pit_hwtimer.hook_data);
+	}
+	spin_unlock (pit_hwtimer.lock);
+	return IRQ_HANDLED;
+}
+
+static int pit_start(void)
+{
+	out_be32(reg_base + PIT_PTLDR, PIT_DEFAULT_CLOCK / pit_freq );
+	/* enable PIT.*/
+	out_be32(reg_base + PIT_PTCNR, 0x1 | 0x00000080 | PIT_CLIN_DEFAULT );
+	return 0;
+}
+
+static int pit_stop(void)
+{
+	/* Disable PIT.*/
+	out_be32(reg_base + PIT_PTCNR, 0x0 );
+	return 0;
+}
+
+static int __init pit_init(void)
+{
+	int ret = 0;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, "pit", "mpc_pit");
+	if (!np) {
+		printk(KERN_ERR "pit_hwtimer: cannot find devices\n");
+		return -ENODEV;
+	}
+	pit_irq = irq_of_parse_and_map(np, 0);
+
+	pit_hwtimer_data.name = "pit";
+	pit_hwtimer_data.desc = "PowerPC kernel 83xx PIT";
+	pit_hwtimer_data.def_freq = HZ;
+	pit_hwtimer_data.min_freq = 2;
+	pit_hwtimer_data.max_freq = 8192;
+
+	pit_hwtimer.data = &pit_hwtimer_data;
+	pit_hwtimer.set_freq = pit_set_freq;
+	pit_hwtimer.get_freq = pit_get_freq;
+	pit_hwtimer.start = pit_start;
+	pit_hwtimer.stop = pit_stop;
+	pit_hwtimer.lock = &pit_timer_lock;
+	pit_hwtimer.hook = NULL;
+
+	pit_freq = pit_hwtimer_data.def_freq;
+	if ((ret = request_irq(pit_irq, pit_interrupt, IRQF_TIMER, "pit_hwtimer", NULL)) != 0)
+	{
+		printk(KERN_ERR "pit_hwtimer: cannot register IRQ %d, ret:%d\n", pit_irq, ret);
+		return -EIO;
+	}
+	reg_base = ioremap(get_immrbase() + PIT_OFFSET, 0x100);
+	if (reg_base == NULL)
+		return -ENOMEM;
+	ret = register_hwtimer(&pit_hwtimer);
+	if (ret)
+		iounmap(reg_base);
+	return ret;
+}
+
+static void __exit pit_exit (void)
+{
+	free_irq(pit_irq, NULL);
+	unregister_hwtimer(&pit_hwtimer);
+	iounmap(reg_base);
+}
+module_init(pit_init);
+module_exit(pit_exit);
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

