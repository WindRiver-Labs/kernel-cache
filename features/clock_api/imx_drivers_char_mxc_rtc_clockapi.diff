Add Clock API Support to RTC driver on iMX series board.

Signed-off-by: Xiaopeng Yang <xiaopeng.yang@windriver.com>
--- a/drivers/char/mxc_rtc.c
+++ b/drivers/char/mxc_rtc.c
@@ -22,6 +22,10 @@
 #include <asm/uaccess.h>
 #include "mxc_rtc.h"
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 /*!
  * @file mxc_rtc.c
  * @brief Real Time Clock interface
@@ -110,6 +114,38 @@
 
 static DEFINE_SPINLOCK(rtc_lock);
 
+static int mxc_rtc_ioctl(unsigned int cmd, unsigned long arg);
+
+#ifdef CONFIG_HWTIMER_HOOKS
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+
+static int rtc_get_freq(void)
+{
+	return rtc_freq;
+}
+
+static int rtc_set_freq(int freq)
+{
+	unsigned long newfreq;
+	/* Note - assumes freq is power of 2.  Should
+	 * round freq up to nearest power of 2 */
+	newfreq = freq;
+	return mxc_rtc_ioctl(RTC_IRQP_SET, newfreq);
+}
+
+static int rtc_start(void)
+{
+	return mxc_rtc_ioctl(RTC_PIE_ON, 0);
+}
+
+static int rtc_stop(void)
+{
+	return mxc_rtc_ioctl(RTC_PIE_OFF, 0);
+}
+
+#endif	/* CONFIG_HWTIMER_HOOKS */
+
 /*!
  * This function is used to obtain the RTC time or the alarm value in
  * second.
@@ -240,6 +276,12 @@
 		rtc_update_alarm(&g_rtc_alarm);
 	}
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (rtc_hwtimer.hook != NULL) {
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	spin_unlock(&rtc_lock);
 
 	rtc_update(1, events);
@@ -531,7 +573,7 @@ static int __init mxc_rtc_probe(struct p
 	mxc_clks_enable(RTC_CLK);
 	/* Configure and enable the RTC */
 	if ((ret =
-	     request_irq(INT_RTC, mxc_rtc_interrupt, 0, "rtc", NULL)) != 0) {
+	     request_irq(INT_RTC, mxc_rtc_interrupt, IRQF_TIMER, "rtc", NULL)) != 0) {
 		printk(KERN_ERR "rtc: IRQ%d already in use. \n", INT_RTC);
 		return ret;
 	}
@@ -562,10 +604,32 @@ static int __init mxc_rtc_probe(struct p
 		return -1;
 	}
 	printk("Real TIme clock Driver v%s \n", RTC_VERSION);
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	rtc_hwtimer_data.name = "mxc_rtc";
+	rtc_hwtimer_data.desc = "Freescale MXC Real Time Clock";
+	rtc_hwtimer_data.def_freq = 2;
+	rtc_hwtimer_data.min_freq = 2;
+	rtc_hwtimer_data.max_freq = MAX_PIE_FREQ;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = rtc_set_freq;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+#endif
+
 	return 0;//ret;
 }
 static int __exit mxc_rtc_remove(struct device *dev)
 {
+#ifdef CONFIG_HWTIMER_HOOKS
+	unregister_hwtimer(&rtc_hwtimer);
+#endif
 	unregister_rtc(&mxc_rtc_ops);
 	free_irq(INT_RTC, NULL);
 	mxc_rtc_release();
