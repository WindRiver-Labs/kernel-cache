From 5cf9295bb56d5437a968529abb202f3a6cbeedb7 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Thu, 3 Jul 2008 22:59:49 -0400
Subject: [PATCH] Add clock API support for OMAP2430sdp.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 arch/arm/mach-omap2/timer-gp.c |  109 ++++++++++++++++++++++++++++++++++++++++
 1 files changed, 109 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/timer-gp.c b/arch/arm/mach-omap2/timer-gp.c
index 557603f..1eeabf3 100644
--- a/arch/arm/mach-omap2/timer-gp.c
+++ b/arch/arm/mach-omap2/timer-gp.c
@@ -36,6 +36,110 @@
 #include <asm/mach/time.h>
 #include <asm/arch/dmtimer.h>
 
+#ifdef  CONFIG_HWTIMER_HOOKS 
+#include <linux/hwtimer.h>
+
+static struct omap_dm_timer *gp_timer_4_clockapi;
+
+static struct hwtimer_data clockapi_timer_data = {
+	name: "OMAP2 timer",
+	desc: "TI_OMAP2430SDP GP timer 3",
+	def_freq: 1024,
+	min_freq: 2,
+	max_freq: 8192
+};
+
+static int clockapi_timer_get_freq(void);
+static int clockapi_timer_set_freq(int freq);
+static int clockapi_timer_start(void);
+static int clockapi_timer_stop(void);
+
+static DECLARE_HWTIMER_LOCK(clockapi_timer_lock);
+static unsigned int current_freq;
+
+static struct hwtimer clockapi_timer = {
+	data: &clockapi_timer_data,
+	set_freq: clockapi_timer_set_freq,
+	get_freq: clockapi_timer_get_freq,
+	start: clockapi_timer_start,
+	stop: clockapi_timer_stop,
+	lock: &clockapi_timer_lock,
+	hook: NULL,
+	hook_data: NULL
+};
+
+static irqreturn_t omap2_clockapi_timer_interrupt(int irq, void *dev_id)
+{
+	omap_dm_timer_write_status(gp_timer_4_clockapi, OMAP_TIMER_INT_OVERFLOW);
+
+	spin_lock(clockapi_timer.lock);
+	if(clockapi_timer.hook != NULL)
+		clockapi_timer.hook(clockapi_timer.hook_data);
+	spin_unlock(clockapi_timer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction clockapi_gp_timer_irq = {
+	.name		= "clock api timer",
+	.flags		= IRQF_DISABLED,
+	.handler	= omap2_clockapi_timer_interrupt,
+};
+
+static int clockapi_timer_get_freq(void)
+{
+	return current_freq;
+}
+
+static int clockapi_timer_set_freq(int freq)
+{
+	u32 tick_period;
+
+	if ((freq < clockapi_timer.data->min_freq) || 
+		(freq > clockapi_timer.data->max_freq))
+		return -EINVAL;
+
+	tick_period = clk_get_rate(omap_dm_timer_get_fclk(gp_timer_4_clockapi)) / freq;
+	tick_period -= 1;
+	
+	omap_dm_timer_set_load(gp_timer_4_clockapi, 1, 0xffffffff - tick_period);
+
+	current_freq = freq;
+	return 0;
+}
+
+static int clockapi_timer_start(void)
+{
+	omap_dm_timer_start(gp_timer_4_clockapi);
+	return 0;	
+}
+
+static int clockapi_timer_stop(void)
+{
+	omap_dm_timer_stop(gp_timer_4_clockapi);
+	return 0;
+}
+
+static void clockapi_timer_init(void)
+{
+	u32 tick_period;
+
+	gp_timer_4_clockapi = omap_dm_timer_request_specific(3);
+	BUG_ON(gp_timer_4_clockapi == NULL);
+
+	omap_dm_timer_set_source(gp_timer_4_clockapi, OMAP_TIMER_SRC_SYS_CLK);
+	tick_period = clk_get_rate(omap_dm_timer_get_fclk(gp_timer_4_clockapi)) /
+				  clockapi_timer.data->def_freq;
+	tick_period -= 1;
+	omap_dm_timer_set_load(gp_timer_4_clockapi, 1, 0xffffffff - tick_period);
+	omap_dm_timer_set_int_enable(gp_timer_4_clockapi, OMAP_TIMER_INT_OVERFLOW);
+
+	setup_irq(omap_dm_timer_get_irq(gp_timer_4_clockapi), &clockapi_gp_timer_irq);
+	current_freq = clockapi_timer.data->def_freq;
+}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
+
 static struct omap_dm_timer *gptimer;
 static struct clock_event_device clockevent_gpt;
 
@@ -113,6 +217,11 @@ static void __init omap2_gp_clockevent_init(void)
 	setup_irq(omap_dm_timer_get_irq(gptimer), &omap2_gp_timer_irq);
 	omap_dm_timer_set_int_enable(gptimer, OMAP_TIMER_INT_OVERFLOW);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	clockapi_timer_init();
+	register_hwtimer(&clockapi_timer);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	clockevent_gpt.mult = div_sc(tick_rate, NSEC_PER_SEC,
 				     clockevent_gpt.shift);
 	clockevent_gpt.max_delta_ns =
-- 
1.5.5.1

