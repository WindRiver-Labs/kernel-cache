Date: Thu, 3 Jul 2008 16:29:53 -0400
Subject: [PATCH] rivers for all PICs compliant with the OpenPIC architecture.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/powerpc/sysdev/mpic.c |  200 ++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 200 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index 7680001..09c3bef 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -265,6 +265,131 @@ static inline void _mpic_irq_write(struct mpic *mpic, unsigned int src_no,
 #define mpic_irq_write(s,r,v)	_mpic_irq_write(mpic,(s),(r),(v))
 
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#include <linux/delay.h>
+
+#define TIMER_DEFAULT_DIVISOR 8
+#define PROC_PLL_RATIO 2/5
+
+static unsigned long mpic_hwtimer_freq = 0;
+
+static int mpic_hwtimer_index = 0;
+static int mpic_hwtimer_irq = 0;
+static DECLARE_HWTIMER_LOCK(mpic_hwtimer_lock);
+static struct hwtimer_data mpic_hwtimer_data;
+
+extern unsigned long ppc_proc_freq;
+
+int mpic_hwtimer_get_freq(void)
+{
+	return mpic_hwtimer_freq;
+}
+
+static int mpic_hwtimer_set_freq(int freq)
+{
+	struct mpic *mpic = mpic_primary;
+
+	if ((freq < mpic_hwtimer_data.min_freq) || (freq > mpic_hwtimer_data.max_freq))
+		return -EINVAL;
+	mpic_hwtimer_freq = freq;
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_BASE_CNT),
+		   ppc_proc_freq * PROC_PLL_RATIO / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
+	return 0;
+}
+
+irqreturn_t mpic_hwtimer_interrupt(int irq, void *dev_id);
+
+static int mpic_hwtimer_start(void)
+{
+	u32 tmp = 0;
+	int ret = 0;
+	struct mpic *mpic = mpic_primary;
+
+	mpic_hwtimer_irq = irq_create_mapping(mpic->irqhost,
+						mpic->timer_vecs[mpic_hwtimer_index]);
+	if ((ret = request_irq(mpic_hwtimer_irq, mpic_hwtimer_interrupt, IRQF_TIMER, "openpic_hwtimer", NULL)) != 0)
+	{
+		printk(KERN_ERR "openpic_hwtimer: cannot register IRQ %d, ret:%d\n", mpic_hwtimer_irq, ret);
+		return -EIO;
+	}
+
+	/* Dispatch interrupt to processor 0. Set to "1" means to processor 0.*/
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_DESTINATION),
+		   1);
+
+	/* Set ticks. */
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_BASE_CNT),
+		   ppc_proc_freq * PROC_PLL_RATIO / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
+	tmp = mpic_read(mpic->tmregs, mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   	MPIC_INFO(TIMER_VECTOR_PRI));
+
+	/* Priority level must not be 0, otherwise interrupt disabled.*/
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_VECTOR_PRI),
+		   (tmp | 0x10000) & (~MPIC_VECPRI_MASK));
+	return 0;
+}
+
+static int mpic_hwtimer_stop(void)
+{
+	u32 tmp = 0;
+	struct mpic *mpic = mpic_primary;
+
+	free_irq(mpic_hwtimer_irq, NULL);
+	/* Counting inhibited */
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_BASE_CNT),
+		   0x80000000);
+	/* Disable interrupt */
+	tmp = mpic_read(mpic->tmregs, mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   	MPIC_INFO(TIMER_VECTOR_PRI));
+	mpic_write(mpic->tmregs,
+		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
+		   MPIC_INFO(TIMER_VECTOR_PRI),
+		   tmp | (MPIC_VECPRI_MASK));
+	return 0;
+}
+
+static struct hwtimer_data mpic_hwtimer_data = {
+	.name = "openpic_timer",
+	.desc = "PowerPC kernel OpenPIC timer",
+	.def_freq = HZ,
+	.min_freq = 2,
+	.max_freq = 8192,
+};
+
+static struct hwtimer mpic_hwtimer = {
+	.data = &mpic_hwtimer_data,
+	.set_freq = mpic_hwtimer_set_freq,
+	.get_freq = mpic_hwtimer_get_freq,
+	.start = mpic_hwtimer_start,
+	.stop = mpic_hwtimer_stop,
+	.lock = &mpic_hwtimer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+
+irqreturn_t mpic_hwtimer_interrupt(int irq, void *dev_id)
+{
+	spin_lock (mpic_hwtimer.lock);
+	if (mpic_hwtimer.hook != NULL) {
+		mpic_hwtimer.hook(mpic_hwtimer.hook_data);
+	}
+	spin_unlock (mpic_hwtimer.lock);
+	return IRQ_HANDLED;
+}
+
+#endif
+
 /*
  * Low level utility functions
  */
@@ -890,6 +1015,63 @@ static struct irq_chip mpic_irq_ht_chip = {
 };
 #endif /* CONFIG_MPIC_U3_HT_IRQS */
 
+#ifdef CONFIG_HWTIMER_HOOKS
+
+static void mpic_unmask_timer_irq(unsigned int irq)
+{
+	unsigned int loops = 50;
+	struct mpic *mpic = mpic_from_irq(irq);
+	unsigned int src = irq - mpic->timer_vecs[0] ;
+	u32 vector_reg =  src * MPIC_INFO(TIMER_STRIDE) + MPIC_INFO(TIMER_VECTOR_PRI);
+
+	mpic_write(mpic->tmregs, vector_reg,
+		   mpic_read(mpic->tmregs, vector_reg) & ~(MPIC_VECPRI_MASK));
+
+	/* make sure mask gets to controller before we return to user */
+	while ((mpic_read(mpic->tmregs, vector_reg) & MPIC_VECPRI_MASK)) {
+		if (!loops--) {
+			printk(KERN_ERR "mpic_unmask_timer_irq timeout\n");
+			break;
+		}
+		mdelay(1);
+	}
+}
+
+static void mpic_mask_timer_irq(unsigned int irq)
+{
+	unsigned int loops = 50;
+	struct mpic *mpic = mpic_from_irq(irq);
+	unsigned int src = irq - mpic->timer_vecs[0] ;
+	u32 vector_reg =  src * MPIC_INFO(TIMER_STRIDE) + MPIC_INFO(TIMER_VECTOR_PRI);
+
+	mpic_write(mpic->tmregs, vector_reg,
+		   mpic_read(mpic->tmregs, vector_reg) | (MPIC_VECPRI_MASK));
+
+	/* make sure mask gets to controller before we return to user */
+	while (!(mpic_read(mpic->tmregs, vector_reg) & MPIC_VECPRI_MASK)) {
+		if (!loops--) {
+			printk(KERN_ERR "mpic_mask_timer_irq timeout\n");
+			break;
+		}
+		mdelay(1);
+	}
+}
+
+static void mpic_end_timer_irq(unsigned int irq)
+{
+	struct mpic *mpic = mpic_from_irq(irq);
+	mpic_eoi(mpic);
+}
+
+static struct irq_chip mpic_timer_chip = {
+	.mask		= mpic_mask_timer_irq,
+	.ack		= mpic_end_timer_irq,
+	.unmask		= mpic_unmask_timer_irq,
+	.eoi		= mpic_end_timer_irq,
+};
+
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 
 static int mpic_host_match(struct irq_host *h, struct device_node *node)
 {
@@ -922,6 +1104,16 @@ static int mpic_host_map(struct irq_host *h, unsigned int virq,
 	}
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (hw >= mpic->timer_vecs[0]) {
+		DBG("mpic: mapping as OpenPIC global timer\n");
+		set_irq_chip_data(virq, mpic);
+		set_irq_chip_and_handler(virq, &mpic_timer_chip,
+					 handle_fasteoi_irq);
+		return 0;
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	if (hw >= mpic->irq_count)
 		return -EINVAL;
 
@@ -1296,6 +1488,14 @@ void __init mpic_init(struct mpic *mpic)
 	mpic->save_data = alloc_bootmem(mpic->num_sources * sizeof(struct mpic_irq_save));
 	BUG_ON(mpic->save_data == NULL);
 #endif
+
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	mpic_timer_chip.typename = mpic->name;
+	mpic_hwtimer_freq = mpic_hwtimer_data.def_freq;
+	register_hwtimer(&mpic_hwtimer);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 }
 
 void __init mpic_set_clk_ratio(struct mpic *mpic, u32 clock_ratio)
-- 
1.5.5.1

