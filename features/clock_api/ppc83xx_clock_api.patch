From: Liming Wang <liming.wang@windriver.com>
Subject: PPC 83xx clock API drivers for wrs_sbc834x.

Add PPC 83xx clock API drivers for wrs_sbc834x.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/ppc/platforms/83xx/Makefile      |    1 
 arch/ppc/platforms/83xx/pit_hwtimer.c |  129 ++++++++++++++++++++++++++++++++++
 2 files changed, 130 insertions(+)

--- a/arch/ppc/platforms/83xx/Makefile
+++ b/arch/ppc/platforms/83xx/Makefile
@@ -3,3 +3,4 @@
 #
 obj-$(CONFIG_MPC834x_SYS)	+= mpc834x_sys.o
 obj-$(CONFIG_SBC834x)		+= sbc834x.o
+obj-$(CONFIG_HWTIMER_HOOKS)	+= pit_hwtimer.o
--- /dev/null
+++ b/arch/ppc/platforms/83xx/pit_hwtimer.c
@@ -0,0 +1,129 @@
+/*
+ * MPC83xx clock API driver.
+ *
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/hwtimer.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/mpc83xx.h>
+
+#define PIT_OFFSET      0x00000400
+#define PIT_PTCNR       0x00000000
+#define PIT_PTLDR       0x00000004
+#define PIT_PTPSR       0x00000008
+#define PIT_PTCTR       0x0000000C
+#define PIT_PTEVR       0x00000010
+
+#if defined(CONFIG_SBC834x)
+#define	PIT_INTERNAL_CLOCK	(66666666 * 2)
+#define	PIT_EXTERNAL_CLOCK	(32768)
+#endif
+#define	PIT_DEFAULT_CLOCK	PIT_EXTERNAL_CLOCK
+
+
+#define	PIT_CLIN_INTERNAL	0x00
+#define	PIT_CLIN_EXTERNAL	0x40
+#define PIT_CLIN_DEFAULT	PIT_CLIN_EXTERNAL
+
+static struct hwtimer pit_hwtimer;
+static struct hwtimer_data pit_hwtimer_data;
+static unsigned long pit_freq = 0;
+
+static DECLARE_HWTIMER_LOCK(pit_timer_lock);
+
+static void __iomem *reg_base;
+
+static int pit_irq = 65;
+
+static int pit_get_freq(void)
+{
+	return pit_freq;
+}
+
+static int pit_set_freq(int freq)
+{
+	pit_freq = freq;
+	out_be32(reg_base + PIT_PTCNR, 0x0 );
+	out_be32(reg_base + PIT_PTLDR, PIT_DEFAULT_CLOCK / pit_freq );
+	out_be32(reg_base + PIT_PTCNR, 0x1 | 0x00000080 | PIT_CLIN_DEFAULT );
+	return 0;
+}
+
+irqreturn_t pit_interrupt(int irq, void *dev_id)
+{
+	out_be32(reg_base + PIT_PTEVR, 0x1);
+	spin_lock (pit_hwtimer.lock);
+	if (pit_hwtimer.hook != NULL) {
+		pit_hwtimer.hook(pit_hwtimer.hook_data);
+	}
+	spin_unlock (pit_hwtimer.lock);
+	return IRQ_HANDLED;
+}
+
+static int pit_start(void)
+{
+	out_be32(reg_base + PIT_PTLDR, PIT_DEFAULT_CLOCK / pit_freq );
+	/* Enable PIT.*/
+	out_be32(reg_base + PIT_PTCNR, 0x1 | 0x00000080 | PIT_CLIN_DEFAULT );
+	return 0;
+}
+
+static int pit_stop(void)
+{
+	/* Disable PIT.*/
+	out_be32(reg_base + PIT_PTCNR, 0x0 );
+	return 0;
+}
+
+static int __init pit_init(void)
+{
+	int ret = 0;
+
+	pit_hwtimer_data.name = "pit";
+	pit_hwtimer_data.desc = "PPC kernel 83xx PIT";
+	pit_hwtimer_data.def_freq = HZ;
+	pit_hwtimer_data.min_freq = 2;
+	pit_hwtimer_data.max_freq = 8192;
+
+	pit_hwtimer.data = &pit_hwtimer_data;
+	pit_hwtimer.set_freq = pit_set_freq;
+	pit_hwtimer.get_freq = pit_get_freq;
+	pit_hwtimer.start = pit_start;
+	pit_hwtimer.stop = pit_stop;
+	pit_hwtimer.lock = &pit_timer_lock;
+	pit_hwtimer.hook = NULL;
+
+	pit_freq = pit_hwtimer_data.def_freq;
+	if ((ret = request_irq(pit_irq, pit_interrupt, IRQF_TIMER, "pit_hwtimer", NULL)) != 0)
+	{
+		printk(KERN_ERR "pit_hwtimer: cannot register IRQ %d, ret:%d\n", pit_irq, ret);
+		return -EIO;
+	}
+	reg_base = ioremap(immrbar + PIT_OFFSET, 0x100);
+	if (reg_base == NULL)
+		return -ENOMEM;
+	ret = register_hwtimer(&pit_hwtimer);
+	if (ret)
+		iounmap(reg_base);
+	return ret;
+}
+
+static void __exit pit_exit (void)
+{
+	free_irq(pit_irq, NULL);
+	unregister_hwtimer(&pit_hwtimer);
+	iounmap(reg_base);
+}
+module_init(pit_init);
+module_exit(pit_exit);
+MODULE_LICENSE("GPL");
