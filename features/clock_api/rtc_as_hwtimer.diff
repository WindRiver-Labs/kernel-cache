From caf78240474fa61f41316572f6c1864713a2f3bf Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Thu, 3 Jul 2008 16:20:27 -0400
Subject: [PATCH] ure to RTC device so that it can be used via the hwtimer API

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 drivers/char/rtc.c |   74 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 73 insertions(+), 1 deletions(-)

diff --git a/drivers/char/rtc.c b/drivers/char/rtc.c
index d9799e2..d489e56 100644
--- a/drivers/char/rtc.c
+++ b/drivers/char/rtc.c
@@ -81,6 +81,19 @@
 #include <linux/smp_lock.h>
 #include <linux/uaccess.h>
 
+/* RTC IRQ handler isn't suitable for use with IRQF_TIMER on
+ * RT without a significant restructuring */
+#ifdef CONFIG_PREEMPT_RT
+#undef CONFIG_HWTIMER_HOOKS
+#define RTC_IRQFLAGS	IRQF_DISABLED
+#else
+#define RTC_IRQFLAGS	(IRQF_DISABLED|IRQF_TIMER)
+#endif
+
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 #include <asm/current.h>
 #include <asm/system.h>
 
@@ -174,6 +187,8 @@ static void mask_rtc_irq_bit(unsigned char bit)
 static int rtc_proc_open(struct inode *inode, struct file *file);
 #endif
 
+static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel);
+
 /*
  *	Bits in rtc_status. (6 bits of room for future expansion)
  */
@@ -211,6 +226,36 @@ static unsigned long epoch = 1900;	/* year corresponding to 0x00	*/
 static const unsigned char days_in_mo[] =
 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 
+#ifdef CONFIG_HWTIMER_HOOKS
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+
+static int rtc_get_freq(void)
+{
+	return rtc_freq;
+}
+
+static int rtc_set_freq(int freq)
+{
+	unsigned long newfreq;
+	/* Note - assumes freq is power of 2.  Should
+	 * round freq up to nearest power of 2 */
+	newfreq = freq;
+	return rtc_do_ioctl(RTC_IRQP_SET, newfreq, 1);
+}
+
+static int rtc_start(void)
+{
+	return rtc_do_ioctl(RTC_PIE_ON, 0, 1);
+}
+
+static int rtc_stop(void)
+{
+	return rtc_do_ioctl(RTC_PIE_OFF, 0, 1);
+}
+
+#endif	/* CONFIG_HWTIMER_HOOKS */
+
 /*
  * Returns true if a clock update is in progress
  */
@@ -262,6 +307,12 @@ static irqreturn_t rtc_interrupt(int irq, void *dev_id)
 	if (rtc_status & RTC_TIMER_ON)
 		mod_timer(&rtc_irq_timer, jiffies + HZ/rtc_freq + 2*HZ/100);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (rtc_hwtimer.hook != NULL) {
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	spin_unlock(&rtc_lock);
 
 	/* Now do the rest of the actions */
@@ -1050,7 +1101,7 @@ no_irq:
 		rtc_int_handler_ptr = rtc_interrupt;
 	}
 
-	if (request_irq(RTC_IRQ, rtc_int_handler_ptr, IRQF_DISABLED,
+	if (request_irq(RTC_IRQ, rtc_int_handler_ptr, RTC_IRQFLAGS,
 			"rtc", NULL)) {
 		/* Yeah right, seeing as irq 8 doesn't even hit the bus. */
 		rtc_has_irq = 0;
@@ -1143,11 +1194,32 @@ no_irq2:
 
 	printk(KERN_INFO "Real Time Clock Driver v" RTC_VERSION "\n");
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	rtc_hwtimer_data.name = "rtc";
+	rtc_hwtimer_data.desc = "Generic PC style RTC";
+	rtc_hwtimer_data.def_freq = 1024;
+	rtc_hwtimer_data.min_freq = 2;
+	rtc_hwtimer_data.max_freq = 8192;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = rtc_set_freq;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+#endif
+
 	return 0;
 }
 
 static void __exit rtc_exit(void)
 {
+#ifdef CONFIG_HWTIMER_HOOKS
+	unregister_hwtimer(&rtc_hwtimer);
+#endif
 	cleanup_sysctl();
 	remove_proc_entry("driver/rtc", NULL);
 	misc_deregister(&rtc_dev);
-- 
1.5.5.1

