From b4be0e16be7b4d910eee1c8a9e367c977ede9dc8 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Thu, 3 Jul 2008 22:56:39 -0400
Subject: [PATCH] Add clock API support for arm_versatile_926ejs.

wrs_severity: critical
wrs_scope: bsp

Signed-off-by: Xiaopeng Yang <xiaopeng.yang@windriver.com>
---
 arch/arm/mach-versatile/core.c |  150 ++++++++++++++++++++++++++++++++++++++++
 1 files changed, 150 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-versatile/core.c b/arch/arm/mach-versatile/core.c
index a7dd094..acb39e0 100644
--- a/arch/arm/mach-versatile/core.c
+++ b/arch/arm/mach-versatile/core.c
@@ -50,6 +50,10 @@
 #include "core.h"
 #include "clock.h"
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 /*
  * All IO addresses are mapped onto VA 0xFFFx.xxxx, where x.xxxx
  * is the (PA >> 12).
@@ -925,12 +929,137 @@ static int __init versatile_clocksource_init(void)
  	return 0;
 }
 
+
+#ifdef CONFIG_HWTIMER_HOOKS
+
+#define HWTIMER_MIN_FREQ 2
+#define HWTIMER_MAX_FREQ 8192
+#define HWTIMER_DEF_FREQ 1024
+
+static DECLARE_HWTIMER_LOCK(versatile_hwtimer_lock);
+static int versatile_freq = HWTIMER_DEF_FREQ;
+
+static struct hwtimer_data versatile_hwtimer_data = {
+	.name		= "Versatile hwtimer",
+	.desc		= "Versatile on-chip timer2",
+	.def_freq	= HWTIMER_DEF_FREQ,
+	.min_freq	= HWTIMER_MIN_FREQ,
+	.max_freq	= HWTIMER_MAX_FREQ 
+};
+
+static int versatile_hwtimer_get_freq(void)
+{
+	return versatile_freq;
+}
+
+static int versatile_hwtimer_set_freq(int freq)
+{
+	unsigned long reload;
+	unsigned int ctrl;
+	unsigned long flags;
+
+	if ((freq < HWTIMER_MIN_FREQ) || (freq > HWTIMER_MAX_FREQ))
+		return -EINVAL;
+
+	spin_lock_irqsave(&versatile_hwtimer_lock, flags);
+
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) & ~(3 << 2);
+
+	reload = (TICKS_PER_uSEC * 1000000 + freq/2) / freq;
+
+	if (reload >= 0x100000) {
+		reload >>= 8;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (reload >= 0x10000) {
+		reload >>= 4;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+
+	writel(reload, TIMER2_VA_BASE + TIMER_LOAD);
+	writel(reload, TIMER2_VA_BASE + TIMER_VALUE);
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+
+	versatile_freq = freq;
+
+	spin_unlock_irqrestore(&versatile_hwtimer_lock, flags);
+	return 0;
+}
+
+static int versatile_hwtimer_start(void)
+{
+	unsigned long flags;
+	unsigned int ctrl;
+
+	/* Start timer */
+	spin_lock_irqsave(&versatile_hwtimer_lock, flags);
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) | TIMER_CTRL_ENABLE;
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+	spin_unlock_irqrestore(&versatile_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static int versatile_hwtimer_stop(void)
+{
+	unsigned long flags;
+	unsigned int ctrl;
+
+	/* Stop timer */
+	spin_lock_irqsave(&versatile_hwtimer_lock, flags);
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+	spin_unlock_irqrestore(&versatile_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static struct hwtimer versatile_hwtimer = {
+	.data		= &versatile_hwtimer_data,
+	.set_freq	= versatile_hwtimer_set_freq,
+	.get_freq	= versatile_hwtimer_get_freq,
+	.start		= versatile_hwtimer_start,
+	.stop		= versatile_hwtimer_stop,
+	.lock		= &versatile_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/*
+ * IRQ handler for the clock API hwtimer
+ */
+static irqreturn_t versatile_hwtimer_interrupt(int irq, void *dev_id)
+{
+	// ...clear the interrupt
+	writel(1, TIMER2_VA_BASE + TIMER_INTCLR);
+
+	spin_lock(versatile_hwtimer.lock);
+
+	if (versatile_hwtimer.hook != NULL) {
+		(versatile_hwtimer.hook) (versatile_hwtimer.hook_data);
+	}
+
+	spin_unlock(versatile_hwtimer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction versatile_hwtimer_irq = {
+	.name		= "Versatile HWTimer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= versatile_hwtimer_interrupt,
+};
+#endif  /* CONFIG_HWTIMER_HOOKS */
+
 /*
  * Set up timer interrupt, and return the current time in seconds.
  */
 static void __init versatile_timer_init(void)
 {
 	u32 val;
+#ifdef  CONFIG_HWTIMER_HOOKS
+	unsigned long reload;
+	unsigned int ctrl;
+#endif
 
 	/* 
 	 * set clock frequency: 
@@ -957,6 +1086,27 @@ static void __init versatile_timer_init(void)
 	 */
 	setup_irq(IRQ_TIMERINT0_1, &versatile_timer_irq);
 
+#ifdef  CONFIG_HWTIMER_HOOKS
+	reload = (TICKS_PER_uSEC * 1000000 + HWTIMER_DEF_FREQ/2) / HWTIMER_DEF_FREQ;
+	ctrl = TIMER_CTRL_PERIODIC | TIMER_CTRL_IE;
+
+	if (reload > 0x100000) {
+		reload >>= 8;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (reload > 0x010000) {
+		reload >>= 4;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+
+	writel(reload, TIMER2_VA_BASE + TIMER_LOAD);
+	writel(reload, TIMER2_VA_BASE + TIMER_VALUE);
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+
+	setup_irq(IRQ_TIMERINT2_3, &versatile_hwtimer_irq);
+
+	register_hwtimer(&versatile_hwtimer);
+#endif  /*  CONFIG_HWTIMER_HOOKS */
+
 	versatile_clocksource_init();
 
 	timer0_clockevent.mult =
-- 
1.5.5.1

