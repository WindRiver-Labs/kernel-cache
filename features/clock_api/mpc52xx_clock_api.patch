From: Zumeng Chen <zumeng.chen@windriver.com>
Subject: add hardware timer api to mpc52xx

This patch adds hardware timer api to mpc52xx

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/powerpc/platforms/52xx/Makefile          |    3 +
 arch/powerpc/platforms/52xx/mpc52xx_hwtimer.c |  203 +++++++++++++++++++++++++
 2 files changed, 206 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/52xx/mpc52xx_hwtimer.c

diff --git a/arch/powerpc/platforms/52xx/Makefile b/arch/powerpc/platforms/52xx/Makefile
index b8a5206..2fb3177 100644
--- a/arch/powerpc/platforms/52xx/Makefile
+++ b/arch/powerpc/platforms/52xx/Makefile
@@ -4,7 +4,10 @@
 obj-y				+= mpc52xx_pic.o mpc52xx_common.o
 obj-$(CONFIG_PCI)		+= mpc52xx_pci.o
 
+
 obj-$(CONFIG_PPC_MPC5200_SIMPLE) += mpc5200_simple.o
+obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc52xx_hwtimer.o
+
 obj-$(CONFIG_PPC_EFIKA)		+= efika.o
 obj-$(CONFIG_PPC_LITE5200)	+= lite5200.o
 
diff --git a/arch/powerpc/platforms/52xx/mpc52xx_hwtimer.c b/arch/powerpc/platforms/52xx/mpc52xx_hwtimer.c
new file mode 100644
index 0000000..38bc830
--- /dev/null
+++ b/arch/powerpc/platforms/52xx/mpc52xx_hwtimer.c
@@ -0,0 +1,203 @@
+/*
+* Hardware timers API driver for mpc52xx.
+*
+* Copyright (c) 2007 Wind River Systems, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irqreturn.h>
+#include <asm/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/mpc52xx.h>
+#include <linux/interrupt.h>
+#include <linux/hwtimer.h>
+
+#define GPT_MODE_CE		(1<<12)
+#define GPT_MODE_IntE		(1<<8)
+#define GPT_MODE_CONT		(1<<10)
+#define GPT_MODE_MS_TIMER	(0x4)
+
+struct mpc5200_gpt {
+	unsigned short count;	/* timer ticks before gpt kicks in */
+	unsigned int prescaler;
+	long ipb_freq;
+	int irq;
+	struct mpc52xx_gpt __iomem *regs;
+};
+
+static struct mpc5200_gpt *gpt_hwtimer;
+
+#define HWTIMER_MIN_FREQ 2
+#define HWTIMER_MAX_FREQ 8192
+#define HWTIMER_DEF_FREQ 1024
+
+static DECLARE_HWTIMER_LOCK(mpc52xx_hwtimer_lock);
+static int mpc52xx_freq = HWTIMER_DEF_FREQ;
+
+/*
+ * The 52xx gpt should be able to do 1/32Hz -> 133MHz but we've limited
+ * the range to be the same as the x86 PC RTC for consistency.  The main
+ * use of this API will not need values outside of this range.
+ */
+static struct hwtimer_data mpc52xx_hwtimer_data = {
+	.name		= "mpc52xx hwtimer",
+	.desc		= "MPC52xx General-purpose timer",
+	.def_freq	= HWTIMER_DEF_FREQ,
+	.min_freq	= HWTIMER_MIN_FREQ,
+	.max_freq	= HWTIMER_MAX_FREQ 
+};
+
+static int mpc52xx_hwtimer_get_freq(void)
+{
+	return mpc52xx_freq;
+}
+
+static int mpc52xx_hwtimer_set_freq(int freq)
+{
+	unsigned long flags;
+
+	if ((freq < HWTIMER_MIN_FREQ) || (freq > HWTIMER_MAX_FREQ))
+		return -EINVAL;
+
+	spin_lock_irqsave(&mpc52xx_hwtimer_lock, flags);
+	if(freq < 2048) {
+		gpt_hwtimer->count = 32768/freq;
+		gpt_hwtimer->prescaler = (0xfb0 << 16); /* ~= 32KHZ */
+	}else{ 
+		gpt_hwtimer->count = 0x1;
+		gpt_hwtimer->prescaler = (((gpt_hwtimer->ipb_freq + 1000000)/freq) << 16);
+	}
+	mpc52xx_freq = freq;
+	spin_unlock_irqrestore(&mpc52xx_hwtimer_lock, flags);
+	return 0;
+}
+
+int mpc52xx_hwtimer_start(void)
+{
+	unsigned long flags;
+	int gpt_mode  = in_be32(&gpt_hwtimer->regs->mode);
+
+	spin_lock_irqsave(&mpc52xx_hwtimer_lock,flags);
+	/* disable */
+	out_be32(&gpt_hwtimer->regs->mode, (~GPT_MODE_CE) & gpt_mode);
+	/* set timeout, with maximum prescaler */
+	out_be32(&gpt_hwtimer->regs->count, gpt_hwtimer->prescaler |gpt_hwtimer->count);
+	/* enable gpt */
+	out_be32(&gpt_hwtimer->regs->mode, GPT_MODE_CE | GPT_MODE_IntE | gpt_mode );
+
+	spin_unlock_irqrestore(&mpc52xx_hwtimer_lock,flags);
+	return 0;
+}
+
+static int mpc52xx_hwtimer_stop(void)
+{
+	unsigned long flags;
+	int gpt_mode  = in_be32(&gpt_hwtimer->regs->mode);	
+
+	/* Stop timer */
+	spin_lock_irqsave(&mpc52xx_hwtimer_lock, flags);
+	out_be32(&gpt_hwtimer->regs->mode, (~(GPT_MODE_CE )) & gpt_mode);	
+	spin_unlock_irqrestore(&mpc52xx_hwtimer_lock, flags);
+	return 0;
+}
+
+static struct hwtimer mpc52xx_hwtimer = {
+	.data		= &mpc52xx_hwtimer_data,
+	.set_freq	= mpc52xx_hwtimer_set_freq,
+	.get_freq	= mpc52xx_hwtimer_get_freq,
+	.start		= mpc52xx_hwtimer_start,
+	.stop		= mpc52xx_hwtimer_stop,
+	.lock		= &mpc52xx_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/*
+ * IRQ handler for the clock API hwtimer
+ */
+static int mpc52xx_hwtimer_interrupt(int irq, void *dev_id)
+{
+	out_be32(&gpt_hwtimer->regs->status,0xff);
+
+	spin_lock(mpc52xx_hwtimer.lock);
+	if (mpc52xx_hwtimer.hook != NULL ) {
+		(mpc52xx_hwtimer.hook) (mpc52xx_hwtimer.hook_data);
+	}
+	spin_unlock(mpc52xx_hwtimer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static int __init  mpc5200_hwtimer_init(void)
+{
+	struct mpc5200_gpt *gpt = NULL;
+	struct device_node *hwtimer = NULL;
+	struct resource res ;
+	int err;
+
+	hwtimer = of_find_node_by_type(NULL, "gpt-hwtimer");
+
+	if (of_address_to_resource(hwtimer, 0, &res)) {
+		return -EINVAL;
+	}
+
+	gpt = kzalloc(sizeof(struct mpc5200_gpt ), GFP_KERNEL);
+	if (!gpt)
+		return -ENOMEM;
+
+	gpt->ipb_freq = mpc52xx_find_ipb_freq(hwtimer);
+
+	gpt->irq = irq_of_parse_and_map(hwtimer, 0);
+
+	if(gpt->irq < 0) {
+		err = -ENXIO;
+		goto out_free;
+	}
+
+	gpt->regs = ioremap((phys_addr_t)res.start, (res.end - res.start + 1));
+
+	if (!gpt->regs) {
+		printk(KERN_ERR "mpc52xx - failed to map gpt controller\n");
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	if ((err = request_irq(gpt->irq, mpc52xx_hwtimer_interrupt,0, "mpc52xx-hwtimer", (void *)gpt)) != 0)
+	{
+		printk(KERN_ERR "mpc52xx-hwtimer: cannot register IRQ %d, ret:%d\n", gpt->irq, err);
+		err =  -EIO;
+		goto out_release;
+	}
+	
+	out_be32(&gpt->regs->mode,GPT_MODE_CONT|GPT_MODE_MS_TIMER| in_be32(&gpt->regs->mode));
+	gpt_hwtimer = gpt;
+	
+	spin_lock_init(&mpc52xx_hwtimer_lock);
+	mpc52xx_hwtimer_set_freq(HWTIMER_DEF_FREQ);
+	register_hwtimer(&mpc52xx_hwtimer);
+	return 0;
+
+ out_release:
+	iounmap(gpt->regs);
+ out_free:
+	kfree(gpt);
+	return err;
+}
+
+arch_initcall(mpc5200_hwtimer_init);
-- 
1.5.5.1

