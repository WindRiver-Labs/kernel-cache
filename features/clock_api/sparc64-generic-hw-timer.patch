From 44d2ef04893b9c301990b90ab5b7e9ebe0f9de3f Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Wed, 5 Nov 2008 18:48:33 -0500
Subject: [PATCH] SPARC64 generic HW timer

Generic HWTimer implementation for the SPARC64 architecture.  The jiffy
timer is used as the clock source.

Signed-off-by: Dengyi Wang <dengyi.wang@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc64/kernel/time.c |   47 ++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 47 insertions(+), 0 deletions(-)

diff --git a/arch/sparc64/kernel/time.c b/arch/sparc64/kernel/time.c
index cc16fdc..5e53201 100644
--- a/arch/sparc64/kernel/time.c
+++ b/arch/sparc64/kernel/time.c
@@ -45,16 +45,52 @@
 #include <asm/smp.h>
 #include <asm/sections.h>
 #include <asm/cpudata.h>
 #include <asm/uaccess.h>
 #include <asm/irq_regs.h>
 
 #include "entry.h"
 
+#if defined(CONFIG_HWTIMER_HOOKS) && defined(CONFIG_SPARC64)
+#define HWTIMER_USE_JIFFY 1
+#endif
+
+#ifdef HWTIMER_USE_JIFFY
+
+#include <linux/hwtimer.h>
+
+static int sparc64_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data sparc64_timer_data = {
+	name: "SPARC64 Generic Timer",
+	desc: "SPARC64 generic kernel jiffy timer",
+	def_freq: HZ,
+	min_freq: HZ,
+	max_freq: HZ
+};
+
+static DECLARE_HWTIMER_LOCK(sparc64_timer_lock);
+
+static struct hwtimer sparc64_timer = {
+	data: &sparc64_timer_data,
+	set_freq: NULL,
+	get_freq: sparc64_timer_get_freq,
+	start: NULL,
+	stop: NULL,
+	lock: &sparc64_timer_lock,
+	hook: NULL,
+	hook_data: NULL
+};
+
+#endif 	/* USE JIFFY */
+
 DEFINE_SPINLOCK(mostek_lock);
 DEFINE_SPINLOCK(rtc_lock);
 void __iomem *mstk48t02_regs = NULL;
 #ifdef CONFIG_PCI
 unsigned long ds1287_regs = 0UL;
 static void __iomem *bq4802_regs;
 #endif
 
@@ -945,16 +981,23 @@ void timer_interrupt(int irq, struct pt_regs *regs)
 	kstat_this_cpu.irqs[0]++;
 
 	if (unlikely(!evt->event_handler)) {
 		printk(KERN_WARNING
 		       "Spurious SPARC64 timer interrupt on cpu %d\n", cpu);
 	} else
 		evt->event_handler(evt);
 
+#if defined(HWTIMER_USE_JIFFY) 
+	spin_lock(sparc64_timer.lock);
+	if (sparc64_timer.hook != NULL)
+		(sparc64_timer.hook) (sparc64_timer.hook_data);
+	spin_unlock(sparc64_timer.lock);
+#endif
+
 	irq_exit();
 
 	set_irq_regs(old_regs);
 }
 
 void __devinit setup_sparc64_timer(void)
 {
 	struct clock_event_device *sevt;
@@ -1055,16 +1098,20 @@ void __init time_init(void)
 		clockevent_delta2ns(0x7fffffffffffffffUL, &sparc64_clockevent);
 	sparc64_clockevent.min_delta_ns =
 		clockevent_delta2ns(0xF, &sparc64_clockevent);
 
 	printk("clockevent: mult[%lx] shift[%d]\n",
 	       sparc64_clockevent.mult, sparc64_clockevent.shift);
 
 	setup_sparc64_timer();
+
+#if defined(HWTIMER_USE_JIFFY)
+	 register_hwtimer(&sparc64_timer);
+#endif
 }
 
 unsigned long long sched_clock(void)
 {
 	unsigned long ticks = tick_ops->get_tick();
 
 	return (ticks * timer_ticks_per_nsec_quotient)
 		>> SPARC64_NSEC_PER_CYC_SHIFT;
-- 
1.5.5.1

