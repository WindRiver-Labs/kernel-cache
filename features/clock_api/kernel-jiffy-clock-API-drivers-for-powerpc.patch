From ce90501f19dab93418d8b911295e0d6120694fd7 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 3 Nov 2008 16:31:33 +0800
Subject: [PATCH] kernel jiffy clock API drivers for powerpc

wrs_sbc405gp, wrs_sbc85x0, amcc_yosemite_440ep,xilinx_ml300,
xilinx_ml403, mot_atca6101, fsl_hpcii will use jiffy clock API.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/powerpc/kernel/time.c |   61 ++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 61 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 3a89b3e..c496d59 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -545,6 +545,46 @@ void __init iSeries_time_init_early(void)
 }
 #endif /* CONFIG_PPC_ISERIES */
 
+
+#if defined(HWTIMER_USE_JIFFY)
+
+#include <linux/hwtimer.h>
+
+static int powerpc_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data powerpc_timer_data = {
+	.name		= "PowerPC timer",
+	.desc		= "PowerPC kernel jiffy timer",
+	.def_freq	= HZ,
+	.min_freq	= HZ,
+	.max_freq	= HZ
+};
+
+static DECLARE_HWTIMER_LOCK(powerpc_timer_lock);
+
+static struct hwtimer powerpc_timer = {
+	.data		= &powerpc_timer_data,
+	.set_freq	= NULL,
+	.get_freq	= powerpc_timer_get_freq,
+	.start		= NULL,
+	.stop		= NULL,
+	.lock		= &powerpc_timer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/* the hwtimer callbacks are meant to be triggered once per tick, and in a
+   round-robin fashion across the active cpus.  We accomplish this by keeping
+   a per-cpu count of how many ticks are left until the given cpu should
+   activate the hwtimer callback. */
+
+static atomic_t hwtimer_cpu_trigger[NR_CPUS];
+
+#endif  /*  CONFIG_HWTIMER_HOOKS */
+
 /*
  * For iSeries shared processors, we have to let the hypervisor
  * set the hardware decrementer.  We set a virtual decrementer
@@ -596,6 +636,17 @@ void timer_interrupt(struct pt_regs * regs)
 		get_lppaca()->int_dword.fields.decr_int = 0;
 #endif
 
+#if defined(HWTIMER_USE_JIFFY)
+	if (atomic_dec_and_test(&hwtimer_cpu_trigger[smp_processor_id()])) {
+		atomic_set(&hwtimer_cpu_trigger[smp_processor_id()],
+			   num_online_cpus());
+		spin_lock(powerpc_timer.lock);
+		if (powerpc_timer.hook != NULL)
+			(powerpc_timer.hook) (powerpc_timer.hook_data);
+		spin_unlock(powerpc_timer.lock);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	if (evt->event_handler)
 		evt->event_handler(evt);
 
@@ -886,6 +937,16 @@ static void __init init_decrementer_clockevent(void)
 {
 	int cpu = smp_processor_id();
 
+#if defined(HWTIMER_USE_JIFFY)
+	if (smp_processor_id() == 0) {
+		unsigned int i;
+		for_each_possible_cpu(i)
+			atomic_set(&hwtimer_cpu_trigger[i], i + 1);
+
+	register_hwtimer(&powerpc_timer);
+	}
+#endif  /*  CONFIG_HWTIMER_HOOKS */
+
 	decrementer_clockevent.mult = div_sc(ppc_tb_freq, NSEC_PER_SEC,
 					     decrementer_clockevent.shift);
 	decrementer_clockevent.max_delta_ns =
-- 
1.5.5.1

