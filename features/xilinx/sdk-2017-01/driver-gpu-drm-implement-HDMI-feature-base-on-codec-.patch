From 56f0b0913453d0665351b7e264a33e5f4cc2b938 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Sun, 19 Nov 2017 15:13:02 +0800
Subject: [PATCH 2/2] driver: gpu: drm: implement HDMI feature base on codec
 adv7511

HDMI includes video and audio features, detail implement as below:
- update adv7511 node in dts file
- update HDMI video and audio node in dts file.
- update adv7511 codec driver
- add HDMI video driver
- add HDMI audio driver

All about modification refers to
https://github.com/analogdevicesinc/linux.git
This kernel tree is an open source fora avnet mini-itx board.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/boot/dts/zynq-mini-itx-adv7511.dts     |   73 +++-
 drivers/dma/xilinx/Makefile                     |    1 -
 drivers/dma/xilinx/xilinx_dma.c                 |    1 +
 drivers/gpu/drm/Kconfig                         |    1 +
 drivers/gpu/drm/Makefile                        |    1 +
 drivers/gpu/drm/adi_axi_hdmi/Kconfig            |    7 +
 drivers/gpu/drm/adi_axi_hdmi/Makefile           |    7 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c    |  240 +++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c     |  241 +++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h     |   45 ++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c |  506 +++++++++++++++++++++++
 drivers/gpu/drm/bridge/adv7511/Kconfig          |    8 +
 drivers/gpu/drm/bridge/adv7511/Makefile         |    1 +
 drivers/gpu/drm/bridge/adv7511/adv7511.h        |   16 +
 drivers/gpu/drm/bridge/adv7511/adv7511_audio.c  |  216 ++++++++++
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c    |   83 ++--
 drivers/gpu/drm/drm_atomic_helper.c             |    5 +-
 drivers/gpu/drm/drm_platform.c                  |    4 +-
 include/drm/drm_edid.h                          |   46 ++
 include/drm/drm_modeset_helper_vtables.h        |   57 +++-
 20 files changed, 1501 insertions(+), 58 deletions(-)
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Kconfig
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Makefile
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
 create mode 100644 drivers/gpu/drm/bridge/adv7511/adv7511_audio.c

diff --git a/arch/arm/boot/dts/zynq-mini-itx-adv7511.dts b/arch/arm/boot/dts/zynq-mini-itx-adv7511.dts
index dcd0d46..9c52f71 100644
--- a/arch/arm/boot/dts/zynq-mini-itx-adv7511.dts
+++ b/arch/arm/boot/dts/zynq-mini-itx-adv7511.dts
@@ -53,20 +53,39 @@
 				};
 
 				i2c@1 {
-					#size-cells = <0>;
 					#address-cells = <1>;
+					#size-cells = <0>;
 					reg = <1>;
 
-					adv7511: adv7511@39 {
+					adv7511: adv7511 {
 						compatible = "adi,adv7511";
-						reg = <0x39>;
+						reg = <0x39>, <0x3f>;
+						reg-names = "primary", "edid";
 
 						adi,input-depth = <8>;
 						adi,input-colorspace = "yuv422";
 						adi,input-clock = "1x";
-						adi,input-style = <3>;
+						adi,input-style = <1>;
 						adi,input-justification = "right";
-						adi,clock-delay = <0x03>;
+						adi,clock-delay = <0>;
+
+						#sound-dai-cells = <0>;
+
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								adv7511_in: endpoint {
+									remote-endpoint = <&axi_hdmi_out>;
+								};
+							};
+
+							port@1 {
+								reg = <1>;
+							};
+						};
 					};
 				};
 
@@ -103,16 +122,20 @@
 			#address-cells = <1>;
 			#size-cells = <1>;
 			#dma-cells = <1>;
-			compatible = "xlnx,axi-vdma";
+                        clock-names = "s_axi_lite_aclk", "m_axi_mm2s_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk", "m_axi_s2mm_aclk";
+                        clocks = <&clkc 15>, <&clkc 15>, <&clkc 15>, <&clkc 15>, <&clkc 15>;
+			compatible = "xlnx,axi-vdma-1.00.a";
 			reg = <0x43000000 0x1000>;
-			xlnx,include-sg = <0x0>;
+			xlnx,flush-fsync = <0x1>;
 			xlnx,num-fstores = <0x3>;
+			interrupt-parent = <&intc>;
 			dma-channel@43000000 {
 				compatible = "xlnx,axi-vdma-mm2s-channel";
 				interrupts = <0 59 0x4>;
 				xlnx,datawidth = <0x40>;
 				xlnx,genlock-mode = <0x0>;
 				xlnx,include-dre = <0x0>;
+				xlnx,fstore-enable = <0x1>;
 			};
 		};
 
@@ -126,26 +149,27 @@
 		axi_hdmi@70e00000 {
 			compatible = "adi,axi-hdmi-tx-1.00.a";
 			reg = <0x70e00000 0x10000>;
-			encoder-slave = <&adv7511>;
 			dmas = <&axi_vdma_0 0>;
 			dma-names = "video";
 			clocks = <&hdmi_clock>;
 			adi,is-rgb;
+
+			port {
+				axi_hdmi_out: endpoint {
+					remote-endpoint = <&adv7511_in>;
+				};
+			};
 		};
 
-		axi_spdif_tx_0: axi-spdif-tx@0x75c00000 {
+		axi_spdif_tx_0: axi-spdif-tx@75c00000 {
 			compatible = "adi,axi-spdif-tx-1.00.a";
 			reg = <0x75c00000 0x1000>;
 			dmas = <&dmac_s 0>;
 			dma-names = "tx";
 			clocks = <&clkc 15>, <&audio_clock>, <&audio_clock>;
 			clock-names = "axi", "ref", "spdif";
-		};
 
-		adv7511_hdmi_snd: adv7511_hdmi_snd {
-			compatible = "adv7511-hdmi-snd";
-			audio-codec = <&adv7511>;
-			cpu-dai = <&axi_spdif_tx_0>;
+			#sound-dai-cells = <0>;
 		};
 
 		axi_i2s_0: axi-i2s@77600000 {
@@ -166,6 +190,27 @@
 		clock-frequency = <12288000>;
 	};
 
+	adv7511_hdmi_snd {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "HDMI monitor";
+		simple-audio-card,widgets =
+			"Speaker", "Speaker";
+		simple-audio-card,routing =
+			"Speaker", "TX";
+
+		simple-audio-card,dai-link@0 {
+			format = "spdif";
+			cpu {
+				sound-dai = <&axi_spdif_tx_0>;
+				frame-master;
+				bitclock-master;
+			};
+			codec {
+				sound-dai = <&adv7511>;
+			};
+		};
+	};
+
 	zed_sound {
 		compatible = "simple-audio-card";
 		simple-audio-card,name = "ZED ADAU1761";
diff --git a/drivers/dma/xilinx/Makefile b/drivers/dma/xilinx/Makefile
index 9c0a2bc..2b728f01 100644
--- a/drivers/dma/xilinx/Makefile
+++ b/drivers/dma/xilinx/Makefile
@@ -1,7 +1,6 @@
 obj-$(CONFIG_XILINX_DMATEST) += axidmatest.o
 obj-$(CONFIG_XILINX_VDMATEST) += vdmatest.o
 obj-$(CONFIG_XILINX_CDMATEST) += cdmatest.o
-obj-$(CONFIG_XILINX_VDMA) += xilinx_vdma.o
 obj-$(CONFIG_XILINX_DMA) += xilinx_dma.o
 obj-$(CONFIG_XILINX_ZYNQMP_DMA) += zynqmp_dma.o
 obj-$(CONFIG_XILINX_FRMBUF) += xilinx_frmbuf.o
diff --git a/drivers/dma/xilinx/xilinx_dma.c b/drivers/dma/xilinx/xilinx_dma.c
index 283b765..cb3f10f 100644
--- a/drivers/dma/xilinx/xilinx_dma.c
+++ b/drivers/dma/xilinx/xilinx_dma.c
@@ -2628,6 +2628,7 @@ static int xilinx_dma_probe(struct platform_device *pdev)
 	if (!(xdev->dma_config->dmatype == XDMA_TYPE_CDMA)) {
 		dma_cap_set(DMA_SLAVE, xdev->common.cap_mask);
 		dma_cap_set(DMA_PRIVATE, xdev->common.cap_mask);
+		dma_cap_set(DMA_INTERLEAVE, xdev->common.cap_mask);
 	}
 
 	xdev->common.device_alloc_chan_resources =
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 2e9262c..548c34e 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -228,6 +228,7 @@ config DRM_VGEM
 	  as used by Mesa's software renderer for enhanced performance.
 	  If M is selected the module will be called vgem.
 
+source "drivers/gpu/drm/adi_axi_hdmi/Kconfig"
 
 source "drivers/gpu/drm/exynos/Kconfig"
 
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index d1ef721..9ba30e7 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -65,6 +65,7 @@ obj-$(CONFIG_DRM_ARMADA) += armada/
 obj-$(CONFIG_DRM_ATMEL_HLCDC)	+= atmel-hlcdc/
 obj-$(CONFIG_DRM_RCAR_DU) += rcar-du/
 obj-$(CONFIG_DRM_SHMOBILE) +=shmobile/
+obj-$(CONFIG_DRM_ADI_AXI_HDMI) += adi_axi_hdmi/
 obj-y			+= omapdrm/
 obj-$(CONFIG_DRM_SUN4I) += sun4i/
 obj-y			+= tilcdc/
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Kconfig b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
new file mode 100644
index 0000000..cf78722
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
@@ -0,0 +1,7 @@
+config DRM_ADI_AXI_HDMI
+	tristate "DRM Support for Analog Devices HDMI FPGA platforms"
+	depends on DRM
+	default	n
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select VT_HW_CONSOLE_BINDING if FRAMEBUFFER_CONSOLE
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Makefile b/drivers/gpu/drm/adi_axi_hdmi/Makefile
new file mode 100644
index 0000000..5a889bd
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the drm device driver.  This driver provides support for the
+# Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
+
+adi_axi_hdmi-y := axi_hdmi_encoder.o axi_hdmi_crtc.o axi_hdmi_drv.o
+
+obj-$(CONFIG_DRM_ADI_AXI_HDMI) += adi_axi_hdmi.o
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
new file mode 100644
index 0000000..57375c7
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
@@ -0,0 +1,240 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/dma/xilinx_dma.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "axi_hdmi_drv.h"
+
+struct axi_hdmi_crtc {
+	struct drm_crtc drm_crtc;
+	struct drm_plane plane;
+
+	struct dma_chan *dma;
+	struct dma_interleaved_template *dma_template;
+};
+
+static struct axi_hdmi_crtc *plane_to_axi_hdmi_crtc(struct drm_plane *plane)
+{
+	return container_of(plane, struct axi_hdmi_crtc, plane);
+}
+
+static struct axi_hdmi_crtc *to_axi_hdmi_crtc(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct axi_hdmi_crtc, drm_crtc);
+}
+
+static struct dma_async_tx_descriptor *axi_hdmi_vdma_prep_interleaved_desc(
+	struct drm_plane *plane)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = plane_to_axi_hdmi_crtc(plane);
+	struct drm_framebuffer *fb = plane->state->fb;
+	struct xilinx_vdma_config vdma_config;
+	size_t offset, hw_row_size;
+	struct drm_gem_cma_object *obj;
+
+	obj = drm_fb_cma_get_gem_obj(plane->state->fb, 0);
+
+	memset(&vdma_config, 0, sizeof(vdma_config));
+	vdma_config.park = 1;
+	vdma_config.coalesc = 0xff;
+	xilinx_vdma_channel_set_config(axi_hdmi_crtc->dma, &vdma_config);
+
+	offset = plane->state->crtc_x * fb->bits_per_pixel / 8 +
+		plane->state->crtc_y * fb->pitches[0];
+
+	/* Interleaved DMA is used that way:
+	 * Each interleaved frame is a row (hsize) implemented in ONE
+	 * chunk (sgl has len 1).
+	 * The number of interleaved frames is the number of rows (vsize).
+	 * The icg in used to pack data to the HW, so that the buffer len
+	 * is fb->piches[0], but the actual size for the hw is somewhat less
+	 */
+	axi_hdmi_crtc->dma_template->dir = DMA_MEM_TO_DEV;
+	axi_hdmi_crtc->dma_template->src_start = obj->paddr + offset;
+	/* sgl list have just one entry (each interleaved frame have 1 chunk) */
+	axi_hdmi_crtc->dma_template->frame_size = 1;
+	/* the number of interleaved frame, each has the size specified in sgl */
+	axi_hdmi_crtc->dma_template->numf = plane->state->crtc_h;
+	axi_hdmi_crtc->dma_template->src_sgl = 1;
+	axi_hdmi_crtc->dma_template->src_inc = 1;
+
+	/* vdma IP does not provide any addr to the hdmi IP, so dst_inc
+	 * and dst_sgl should make no any difference.
+	 */
+	axi_hdmi_crtc->dma_template->dst_inc = 0;
+	axi_hdmi_crtc->dma_template->dst_sgl = 0;
+
+	hw_row_size = plane->state->crtc_w * fb->bits_per_pixel / 8;
+	axi_hdmi_crtc->dma_template->sgl[0].size = hw_row_size;
+
+	/* the vdma driver seems to look at icg, and not src_icg */
+	axi_hdmi_crtc->dma_template->sgl[0].icg =
+		fb->pitches[0] - hw_row_size;
+
+	return dmaengine_prep_interleaved_dma(axi_hdmi_crtc->dma,
+						axi_hdmi_crtc->dma_template, 0);
+}
+
+static void axi_hdmi_plane_atomic_update(struct drm_plane *plane,
+	struct drm_plane_state *old_state)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = plane_to_axi_hdmi_crtc(plane);
+	struct dma_async_tx_descriptor *desc;
+
+	if (!plane->state->crtc || !plane->state->fb)
+		return;
+
+	dmaengine_terminate_all(axi_hdmi_crtc->dma);
+
+	desc = axi_hdmi_vdma_prep_interleaved_desc(plane);
+	if (!desc) {
+		pr_err("Failed to prepare DMA descriptor\n");
+		return;
+	}
+
+	dmaengine_submit(desc);
+	dma_async_issue_pending(axi_hdmi_crtc->dma);
+}
+
+static void axi_hdmi_crtc_enable(struct drm_crtc *crtc)
+{
+}
+
+static void axi_hdmi_crtc_disable(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	dmaengine_terminate_all(axi_hdmi_crtc->dma);
+}
+
+static void axi_hdmi_crtc_atomic_begin(struct drm_crtc *crtc,
+	struct drm_crtc_state *state)
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+static const struct drm_crtc_helper_funcs axi_hdmi_crtc_helper_funcs = {
+	.enable = axi_hdmi_crtc_enable,
+	.disable = axi_hdmi_crtc_disable,
+	.atomic_begin = axi_hdmi_crtc_atomic_begin,
+};
+
+static void axi_hdmi_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	drm_crtc_cleanup(crtc);
+	kfree(axi_hdmi_crtc->dma_template);
+	kfree(axi_hdmi_crtc);
+}
+
+static const struct drm_crtc_funcs axi_hdmi_crtc_funcs = {
+	.destroy = axi_hdmi_crtc_destroy,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+};
+
+static const struct drm_plane_helper_funcs axi_hdmi_plane_helper_funcs = {
+	.atomic_update = axi_hdmi_plane_atomic_update,
+};
+
+static void axi_hdmi_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_helper_disable(plane);
+	drm_plane_cleanup(plane);
+}
+
+static const struct drm_plane_funcs axi_hdmi_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = axi_hdmi_plane_destroy,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static const u32 axi_hdmi_supported_formats[] = {
+	DRM_FORMAT_XRGB8888,
+};
+
+struct drm_crtc *axi_hdmi_crtc_create(struct drm_device *dev)
+{
+	struct axi_hdmi_private *p = dev->dev_private;
+	struct axi_hdmi_crtc *axi_hdmi_crtc;
+	struct drm_crtc *crtc;
+	struct drm_plane *plane;
+	int ret;
+
+	if (!dma_has_cap(DMA_INTERLEAVE, p->dma->device->cap_mask)) {
+		DRM_ERROR("DMA needs to support interleaved transfers\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	axi_hdmi_crtc = kzalloc(sizeof(*axi_hdmi_crtc), GFP_KERNEL);
+	if (!axi_hdmi_crtc)
+		return ERR_PTR(-ENOMEM);
+
+	crtc = &axi_hdmi_crtc->drm_crtc;
+	plane = &axi_hdmi_crtc->plane;
+
+	/* we know we'll always use only one data chunk */
+	axi_hdmi_crtc->dma_template = kzalloc(
+		sizeof(struct dma_interleaved_template) +
+		sizeof(struct data_chunk), GFP_KERNEL);
+	if (!axi_hdmi_crtc->dma_template) {
+		ret = -ENOMEM;
+		goto err_free_crtc;
+	}
+
+	ret = drm_universal_plane_init(dev, plane, 0xff, &axi_hdmi_plane_funcs,
+		axi_hdmi_supported_formats,
+		ARRAY_SIZE(axi_hdmi_supported_formats),
+		DRM_PLANE_TYPE_PRIMARY, NULL);
+	if (ret)
+		goto err_free_dma_template;
+
+	drm_plane_helper_add(plane, &axi_hdmi_plane_helper_funcs);
+
+	axi_hdmi_crtc->dma = p->dma;
+
+	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
+		&axi_hdmi_crtc_funcs, NULL);
+	if (ret)
+		goto err_plane_destroy;
+	drm_crtc_helper_add(crtc, &axi_hdmi_crtc_helper_funcs);
+
+	return crtc;
+
+err_plane_destroy:
+	axi_hdmi_plane_destroy(plane);
+err_free_dma_template:
+	kfree(axi_hdmi_crtc->dma_template);
+err_free_crtc:
+	kfree(axi_hdmi_crtc);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
new file mode 100644
index 0000000..0cc1037
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
@@ -0,0 +1,241 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/of_address.h>
+#include <linux/of_dma.h>
+#include <linux/of_graph.h>
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_atomic_helper.h>
+
+#include "axi_hdmi_drv.h"
+
+#define DRIVER_NAME	"axi_hdmi_drm"
+#define DRIVER_DESC	"AXI HDMI DRM"
+#define DRIVER_DATE	"20120930"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static void axi_hdmi_output_poll_changed(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_hotplug_event(private->fbdev);
+}
+
+static struct drm_mode_config_funcs axi_hdmi_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = axi_hdmi_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void axi_hdmi_mode_config_init(struct drm_device *dev)
+{
+	drm_mode_config_init(dev);
+
+	dev->mode_config.min_width = 0;
+	dev->mode_config.min_height = 0;
+
+	dev->mode_config.max_width = 4096;
+	dev->mode_config.max_height = 4096;
+
+	dev->mode_config.funcs = &axi_hdmi_mode_config_funcs;
+}
+
+static int axi_hdmi_load(struct drm_device *dev, unsigned long flags)
+{
+	struct axi_hdmi_private *private = dev_get_drvdata(dev->dev);
+	struct drm_encoder *encoder;
+	int ret;
+
+	private->drm_dev = dev;
+
+	dev->dev_private = private;
+
+	axi_hdmi_mode_config_init(dev);
+
+	private->crtc = axi_hdmi_crtc_create(dev);
+	if (IS_ERR(private->crtc)) {
+		ret = PTR_ERR(private->crtc);
+		goto err_crtc;
+	}
+
+	encoder = axi_hdmi_encoder_create(dev);
+	if (IS_ERR(encoder)) {
+	    ret = PTR_ERR(encoder);
+	    goto err_crtc;
+	}
+
+	drm_mode_config_reset(dev);
+
+	private->fbdev = drm_fbdev_cma_init(dev, 32, 1, 1);
+	if (IS_ERR(private->fbdev)) {
+		DRM_ERROR("failed to initialize drm fbdev\n");
+		ret = PTR_ERR(private->fbdev);
+		goto err_crtc;
+	}
+
+	/* init kms poll for handling hpd */
+	drm_kms_helper_poll_init(dev);
+
+	return 0;
+
+err_crtc:
+	drm_mode_config_cleanup(dev);
+	return ret;
+}
+
+static int axi_hdmi_unload(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+
+	drm_fbdev_cma_fini(private->fbdev);
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+
+	return 0;
+}
+
+static void axi_hdmi_lastclose(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_restore_mode(private->fbdev);
+}
+
+static const struct file_operations axi_hdmi_driver_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.mmap		= drm_gem_cma_mmap,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.unlocked_ioctl	= drm_ioctl,
+	.release	= drm_release,
+};
+
+static struct drm_driver axi_hdmi_driver = {
+	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,
+	.load			= axi_hdmi_load,
+	.unload			= axi_hdmi_unload,
+	.lastclose		= axi_hdmi_lastclose,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_dumb_destroy,
+	.fops			= &axi_hdmi_driver_fops,
+	.name			= DRIVER_NAME,
+	.desc			= DRIVER_DESC,
+	.date			= DRIVER_DATE,
+	.major			= DRIVER_MAJOR,
+	.minor			= DRIVER_MINOR,
+};
+
+static const struct of_device_id adv7511_encoder_of_match[] = {
+	{
+		.compatible = "adi,axi-hdmi-tx-1.00.a",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, adv7511_encoder_of_match);
+
+static int axi_hdmi_platform_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+	struct device_node *np = pdev->dev.of_node;
+	struct axi_hdmi_private *private;
+	struct device_node *slave_node, *ep_node;
+	struct of_endpoint ep;
+	struct resource *res;
+	int ret;
+
+	private = devm_kzalloc(&pdev->dev, sizeof(*private), GFP_KERNEL);
+	if (!private)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	private->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(private->base))
+		return PTR_ERR(private->base);
+
+	private->hdmi_clock = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(private->hdmi_clock)) {
+		return -EPROBE_DEFER;
+	}
+
+	ep_node = of_graph_get_next_endpoint(np, NULL);
+	if (ep_node) {
+		ret = of_graph_parse_endpoint(ep_node, &ep);
+		if (ret) {
+			of_node_put(ep_node);
+			return ret;
+		}
+		if (ep.port != 0 && ep.id != 0) {
+			of_node_put(ep_node);
+			return -EINVAL;
+		}
+		slave_node = of_graph_get_remote_port_parent(ep_node);
+		of_node_put(ep_node);
+	} else {
+		slave_node = of_parse_phandle(np, "encoder-slave", 0);
+	}
+	
+	if (!slave_node)
+		return -EINVAL;
+
+	private->is_rgb = of_property_read_bool(np, "adi,is-rgb");
+
+	id = of_match_node(adv7511_encoder_of_match, np);
+
+	private->encoder_slave = of_find_i2c_device_by_node(slave_node);
+	of_node_put(slave_node);
+
+	if (!private->encoder_slave || !private->encoder_slave->dev.driver)
+		return -EPROBE_DEFER;
+
+	private->dma = dma_request_slave_channel(&pdev->dev, "video");
+	if (private->dma == NULL)
+		return -EPROBE_DEFER;
+
+	platform_set_drvdata(pdev, private);
+	
+	return drm_platform_init(&axi_hdmi_driver, pdev);
+}
+
+static int axi_hdmi_platform_remove(struct platform_device *pdev)
+{
+	struct axi_hdmi_private *private = platform_get_drvdata(pdev);
+
+	drm_put_dev(private->drm_dev);
+	dma_release_channel(private->dma);
+	return 0;
+}
+
+static struct platform_driver adv7511_encoder_driver = {
+	.driver = {
+		.name = "axi-hdmi",
+		.owner = THIS_MODULE,
+		.of_match_table = adv7511_encoder_of_match,
+	},
+	.probe = axi_hdmi_platform_probe,
+	.remove = axi_hdmi_platform_remove,
+};
+module_platform_driver(adv7511_encoder_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("");
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
new file mode 100644
index 0000000..bc2ca02
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
@@ -0,0 +1,45 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_DRV_H_
+#define _AXI_HDMI_DRV_H_
+
+#include <drm/drm.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+
+struct xlnx_pcm_dma_params {
+	struct device_node *of_node;
+	int chan_id;
+};
+
+struct axi_hdmi_encoder;
+
+struct axi_hdmi_private {
+	struct drm_device *drm_dev;
+	struct drm_fbdev_cma *fbdev;
+	struct drm_crtc *crtc;
+	struct axi_hdmi_encoder *encoder;
+	struct i2c_client *encoder_slave;
+
+	void __iomem *base;
+
+	struct clk *hdmi_clock;
+	bool clk_enabled;
+
+	struct dma_chan *dma;
+
+	bool is_rgb;
+};
+
+struct drm_crtc* axi_hdmi_crtc_create(struct drm_device *dev);
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
new file mode 100644
index 0000000..f2c4e0b
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
@@ -0,0 +1,506 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/clk.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_edid.h>
+
+#include "axi_hdmi_drv.h"
+
+#include "../i2c/adv7511.h"
+
+#define AXI_HDMI_STATUS_VMDA_UNDERFLOW	BIT(4)
+#define AXI_HDMI_STATUS_VMDA_OVERFLOW	BIT(3)
+#define AXI_HDMI_STATUS_VMDA_BE_ERROR	BIT(2)
+#define AXI_HDMI_STATUS_VMDA_TPM_OOS	BIT(1)
+#define AXI_HDMI_STATUS_HDMI_TPM_OOS	BIT(0)
+
+#define AXI_HDMI_COLOR_PATTERN_ENABLE	BIT(24)
+
+#define AXI_HDMI_REG_RESET		0x040
+#define AXI_HDMI_REG_CTRL		0x044
+#define AXI_HDMI_REG_SOURCE_SEL		0x048
+#define AXI_HDMI_REG_COLORPATTERN	0x04c
+#define AXI_HDMI_REG_STATUS		0x05c
+#define AXI_HDMI_REG_VDMA_STATUS	0x060
+#define AXI_HDMI_REG_TPM_STATUS		0x064
+#define AXI_HDMI_REG_HTIMING1		0x400
+#define AXI_HDMI_REG_HTIMING2		0x404
+#define AXI_HDMI_REG_HTIMING3		0x408
+#define AXI_HDMI_REG_VTIMING1		0x440
+#define AXI_HDMI_REG_VTIMING2		0x444
+#define AXI_HDMI_REG_VTIMING3		0x448
+
+#define AXI_HDMI_RESET_ENABLE		BIT(0)
+
+#define AXI_HDMI_CTRL_SS_BYPASS		BIT(2)
+#define AXI_HDMI_CTRL_FULL_RANGE	BIT(1)
+#define AXI_HDMI_CTRL_CSC_BYPASS	BIT(0)
+
+#define AXI_HDMI_SOURCE_SEL_COLORPATTERN	0x3
+#define AXI_HDMI_SOURCE_SEL_TESTPATTERN		0x2
+#define AXI_HDMI_SOURCE_SEL_NORMAL		0x1
+#define AXI_HDMI_SOURCE_SEL_NONE		0x0
+
+static const struct debugfs_reg32 axi_hdmi_encoder_debugfs_regs[] = {
+	{ "Reset", AXI_HDMI_REG_RESET },
+	{ "Control", AXI_HDMI_REG_CTRL },
+	{ "Source select", AXI_HDMI_REG_SOURCE_SEL },
+	{ "Colorpattern", AXI_HDMI_REG_COLORPATTERN },
+	{ "Status", AXI_HDMI_REG_STATUS },
+	{ "VDMA status", AXI_HDMI_REG_VDMA_STATUS },
+	{ "TPM status", AXI_HDMI_REG_TPM_STATUS },
+	{ "HTiming1", AXI_HDMI_REG_HTIMING1 },
+	{ "HTiming2", AXI_HDMI_REG_HTIMING2 },
+	{ "HTiming3", AXI_HDMI_REG_HTIMING3 },
+	{ "VTiming1", AXI_HDMI_REG_VTIMING1 },
+	{ "VTiming2", AXI_HDMI_REG_VTIMING2 },
+	{ "VTiming3", AXI_HDMI_REG_VTIMING3 },
+};
+
+static const uint16_t adv7511_csc_ycbcr_to_rgb[] = {
+	0x0734, 0x04ad, 0x0000, 0x1c1b,
+	0x1ddc, 0x04ad, 0x1f24, 0x0135,
+	0x0000, 0x04ad, 0x087c, 0x1b77,
+};
+
+struct axi_hdmi_encoder {
+	struct drm_encoder_slave encoder;
+	struct drm_connector connector;
+
+#ifdef CONFIG_DEBUG_FS
+	struct debugfs_regset32 regset;
+#endif
+};
+
+static inline struct axi_hdmi_encoder *to_axi_hdmi_encoder(struct drm_encoder *enc)
+{
+	return container_of(enc, struct axi_hdmi_encoder, encoder.base);
+}
+
+static inline struct drm_encoder *connector_to_encoder(struct drm_connector *connector)
+{
+	struct axi_hdmi_encoder *enc = container_of(connector, struct axi_hdmi_encoder, connector);
+	return &enc->encoder.base;
+}
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder);
+
+static const struct drm_encoder_slave_funcs *get_slave_funcs(
+	struct drm_encoder *enc)
+{
+	if (enc->bridge)
+		return NULL;
+
+	return to_encoder_slave(enc)->slave_funcs;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static int axi_hdmi_debugfs_cp_get(void *data, u64 *val)
+{
+	struct axi_hdmi_private *private = data;
+	*val = readl(private->base + AXI_HDMI_REG_COLORPATTERN);
+	return 0;
+}
+
+static int axi_hdmi_debugfs_cp_set(void *data, u64 val)
+{
+	struct axi_hdmi_private *private = data;
+
+	writel(val, private->base + AXI_HDMI_REG_COLORPATTERN);
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(axi_hdmi_cp_fops, axi_hdmi_debugfs_cp_get,
+	axi_hdmi_debugfs_cp_set, "0x%06llx\n");
+
+static const char * const axi_hdmi_mode_text[] = {
+	[AXI_HDMI_SOURCE_SEL_NONE] = "none",
+	[AXI_HDMI_SOURCE_SEL_NORMAL] = "normal",
+	[AXI_HDMI_SOURCE_SEL_TESTPATTERN] = "testpattern",
+	[AXI_HDMI_SOURCE_SEL_COLORPATTERN] = "colorpattern",
+};
+
+static ssize_t axi_hdmi_read_mode(struct file *file, char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	uint32_t src;
+	const char *fmt;
+	size_t len = 0;
+	char buf[50];
+	int i;
+
+	src = readl(private->base + AXI_HDMI_REG_SOURCE_SEL);
+
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (src == i)
+			fmt = "[%s] ";
+		else
+			fmt = "%s ";
+		len += scnprintf(buf + len, sizeof(buf) - len, fmt,
+				axi_hdmi_mode_text[i]);
+	}
+
+	buf[len - 1] = '\n';
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+
+static ssize_t axi_hdmi_set_mode(struct file *file, const char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	char buf[20];
+	unsigned int ctrl;
+	unsigned int i;
+
+	count = min_t(size_t, count, sizeof(buf) - 1);
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (sysfs_streq(axi_hdmi_mode_text[i], buf))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(axi_hdmi_mode_text))
+		return -EINVAL;
+
+	writel(i, private->base + AXI_HDMI_REG_SOURCE_SEL);
+
+	if (i == AXI_HDMI_SOURCE_SEL_TESTPATTERN) {
+		ctrl = AXI_HDMI_CTRL_CSC_BYPASS | AXI_HDMI_CTRL_SS_BYPASS |
+			AXI_HDMI_CTRL_FULL_RANGE;
+	} else {
+		if (private->is_rgb)
+			ctrl = AXI_HDMI_CTRL_CSC_BYPASS;
+		else
+			ctrl = 0;
+	}
+
+	writel(ctrl, private->base + AXI_HDMI_REG_CTRL);
+
+	return count;
+}
+
+static const struct file_operations axi_hdmi_mode_fops = {
+	.open = simple_open,
+	.read = axi_hdmi_read_mode,
+	.write = axi_hdmi_set_mode,
+};
+
+static void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *encoder)
+{
+	struct axi_hdmi_private *priv = encoder->encoder.base.dev->dev_private;
+
+	encoder->regset.base = priv->base;
+	encoder->regset.regs = axi_hdmi_encoder_debugfs_regs;
+	encoder->regset.nregs = ARRAY_SIZE(axi_hdmi_encoder_debugfs_regs);
+
+	debugfs_create_regset32(dev_name(encoder->encoder.base.dev->dev), S_IRUGO, NULL, &encoder->regset);
+	debugfs_create_file("color_pattern", 0600, NULL, priv, &axi_hdmi_cp_fops);
+	debugfs_create_file("mode", 0600, NULL, priv, &axi_hdmi_mode_fops);
+}
+
+#else
+
+static inline void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *enc)
+{
+}
+
+#endif
+
+static void axi_hdmi_encoder_enable(struct drm_encoder *encoder)
+{
+	struct axi_hdmi_encoder *axi_hdmi_encoder = to_axi_hdmi_encoder(encoder);
+	struct drm_connector *connector;
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct adv7511_video_config config;
+	struct edid *edid;
+
+	if (!private->clk_enabled) {
+		clk_prepare_enable(private->hdmi_clock);
+		private->clk_enabled = true;
+	}
+	writel(AXI_HDMI_RESET_ENABLE, private->base + AXI_HDMI_REG_RESET);
+
+	if (!sfuncs)
+		return;
+
+	connector = &axi_hdmi_encoder->connector;
+	edid = drm_connector_get_edid(connector);
+
+	if (edid)
+		config.hdmi_mode = drm_detect_hdmi_monitor(edid);
+	else
+		config.hdmi_mode = false;
+
+	hdmi_avi_infoframe_init(&config.avi_infoframe);
+
+	config.avi_infoframe.scan_mode = HDMI_SCAN_MODE_UNDERSCAN;
+
+	if (private->is_rgb) {
+			config.csc_enable = false;
+			config.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;
+	} else {
+		config.csc_scaling_factor = ADV7511_CSC_SCALING_4;
+		config.csc_coefficents = adv7511_csc_ycbcr_to_rgb;
+
+		if ((connector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB422) &&
+			config.hdmi_mode) {
+			config.csc_enable = false;
+			config.avi_infoframe.colorspace = HDMI_COLORSPACE_YUV422;
+		} else {
+			config.csc_enable = true;
+			config.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;
+		}
+	}
+
+	if (sfuncs->set_config)
+		sfuncs->set_config(encoder, &config);
+
+	if (sfuncs->dpms)
+		sfuncs->dpms(encoder, DRM_MODE_DPMS_ON);
+}
+
+static void axi_hdmi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	writel(0, private->base + AXI_HDMI_REG_RESET);
+	if (private->clk_enabled) {
+		clk_disable_unprepare(private->hdmi_clock);
+		private->clk_enabled = false;
+	}
+
+	if (sfuncs && sfuncs->dpms)
+		sfuncs->dpms(encoder, DRM_MODE_DPMS_OFF);
+}
+
+static void axi_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+	struct drm_crtc_state *crtc_state,
+	struct drm_connector_state *conn_state)
+{
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	struct drm_display_mode *mode = &crtc_state->mode;
+	unsigned int h_de_min, h_de_max;
+	unsigned int v_de_min, v_de_max;
+	unsigned int val;
+
+	if (sfuncs && sfuncs->mode_set)
+		sfuncs->mode_set(encoder, mode, &crtc_state->adjusted_mode);
+
+	h_de_min = mode->htotal - mode->hsync_start;
+	h_de_max = h_de_min + mode->hdisplay;
+	v_de_min = mode->vtotal - mode->vsync_start;
+	v_de_max = v_de_min + mode->vdisplay;
+
+	val = (mode->hdisplay << 16) | mode->htotal;
+	writel(val,  private->base + AXI_HDMI_REG_HTIMING1);
+	val = mode->hsync_end - mode->hsync_start;
+	writel(val,  private->base + AXI_HDMI_REG_HTIMING2);
+	val = (h_de_max << 16) | h_de_min;
+	writel(val,  private->base + AXI_HDMI_REG_HTIMING3);
+
+	val = (mode->vdisplay << 16) | mode->vtotal;
+	writel(val,  private->base + AXI_HDMI_REG_VTIMING1);
+	val = mode->vsync_end - mode->vsync_start;
+	writel(val,  private->base + AXI_HDMI_REG_VTIMING2);
+	val = (v_de_max << 16) | v_de_min;
+	writel(val,  private->base + AXI_HDMI_REG_VTIMING3);
+
+	clk_set_rate(private->hdmi_clock, mode->clock * 1000);
+}
+
+static const struct drm_encoder_helper_funcs axi_hdmi_encoder_helper_funcs = {
+	.enable = axi_hdmi_encoder_enable,
+	.disable = axi_hdmi_encoder_disable,
+	.atomic_mode_set = axi_hdmi_encoder_mode_set,
+};
+
+static void axi_hdmi_encoder_destroy(struct drm_encoder *encoder)
+{
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_encoder *axi_hdmi_encoder =
+		to_axi_hdmi_encoder(encoder);
+
+	if (sfuncs && sfuncs->destroy)
+		sfuncs->destroy(encoder);
+
+	drm_encoder_cleanup(encoder);
+	kfree(axi_hdmi_encoder);
+}
+
+static const struct drm_encoder_funcs axi_hdmi_encoder_funcs = {
+	.destroy = axi_hdmi_encoder_destroy,
+};
+
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	struct axi_hdmi_encoder *axi_hdmi_encoder;
+	struct axi_hdmi_private *priv = dev->dev_private;
+	struct drm_bridge *bridge;
+	int ret;
+
+	axi_hdmi_encoder = kzalloc(sizeof(*axi_hdmi_encoder), GFP_KERNEL);
+	if (!axi_hdmi_encoder)
+		return NULL;
+
+	encoder = &axi_hdmi_encoder->encoder.base;
+	encoder->possible_crtcs = 1;
+
+	drm_encoder_init(dev, encoder, &axi_hdmi_encoder_funcs,
+			DRM_MODE_ENCODER_TMDS, NULL);
+	drm_encoder_helper_add(encoder, &axi_hdmi_encoder_helper_funcs);
+
+	bridge = of_drm_find_bridge(priv->encoder_slave->dev.of_node);
+	if (bridge) {
+		bridge->encoder = encoder;
+		encoder->bridge = bridge;
+		ret = drm_bridge_attach(dev, bridge);
+		if (ret) {
+		    drm_encoder_cleanup(encoder);
+		    return NULL;
+		}
+	} else {
+		struct drm_connector *connector;
+		struct drm_i2c_encoder_driver *encoder_drv;
+
+		/* For backwards compatibility, drop it eventually. */
+		encoder_drv = to_drm_i2c_encoder_driver(to_i2c_driver(priv->encoder_slave->dev.driver));
+		encoder_drv->encoder_init(priv->encoder_slave, dev, &axi_hdmi_encoder->encoder);
+
+		connector = &axi_hdmi_encoder->connector;
+		axi_hdmi_connector_init(dev, connector, encoder);
+	}
+
+
+	axi_hdmi_debugfs_init(axi_hdmi_encoder);
+
+	writel(AXI_HDMI_SOURCE_SEL_NORMAL, priv->base + AXI_HDMI_REG_SOURCE_SEL);
+	if (priv->is_rgb)
+		writel(AXI_HDMI_CTRL_CSC_BYPASS, priv->base + AXI_HDMI_REG_CTRL);
+
+	return encoder;
+}
+
+static int axi_hdmi_connector_get_modes(struct drm_connector *connector)
+{
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	int count = 0;
+
+	if (sfuncs && sfuncs->get_modes)
+		count += sfuncs->get_modes(encoder, connector);
+
+	return count;
+}
+
+static int axi_hdmi_connector_mode_valid(struct drm_connector *connector,
+	struct drm_display_mode *mode)
+{
+	if (mode->clock > 165000)
+		return MODE_CLOCK_HIGH;
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	return MODE_OK;
+}
+
+static struct drm_encoder *axi_hdmi_best_encoder(struct drm_connector *connector)
+{
+	return connector_to_encoder(connector);
+}
+
+static struct drm_connector_helper_funcs axi_hdmi_connector_helper_funcs = {
+	.get_modes	= axi_hdmi_connector_get_modes,
+	.mode_valid	= axi_hdmi_connector_mode_valid,
+	.best_encoder	= axi_hdmi_best_encoder,
+};
+
+static enum drm_connector_status axi_hdmi_connector_detect(
+	struct drm_connector *connector, bool force)
+{
+	enum drm_connector_status status = connector_status_unknown;
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	const struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	if (sfuncs && sfuncs->detect)
+		status = sfuncs->detect(encoder, connector);
+
+	return status;
+}
+
+static void axi_hdmi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static struct drm_connector_funcs axi_hdmi_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = axi_hdmi_connector_detect,
+	.destroy = axi_hdmi_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder)
+{
+	int type;
+	int err;
+
+	type = DRM_MODE_CONNECTOR_HDMIA;
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+				DRM_CONNECTOR_POLL_DISCONNECT;
+
+	drm_connector_init(dev, connector, &axi_hdmi_connector_funcs, type);
+	drm_connector_helper_add(connector, &axi_hdmi_connector_helper_funcs);
+
+	err = drm_connector_register(connector);
+	if (err)
+		goto err_connector;
+
+	err = drm_mode_connector_attach_encoder(connector, encoder);
+	if (err) {
+		DRM_ERROR("failed to attach a connector to a encoder\n");
+		goto err_sysfs;
+	}
+
+	return 0;
+
+err_sysfs:
+	drm_connector_unregister(connector);
+err_connector:
+	drm_connector_cleanup(connector);
+	return err;
+}
diff --git a/drivers/gpu/drm/bridge/adv7511/Kconfig b/drivers/gpu/drm/bridge/adv7511/Kconfig
index d2b0499..642d591 100644
--- a/drivers/gpu/drm/bridge/adv7511/Kconfig
+++ b/drivers/gpu/drm/bridge/adv7511/Kconfig
@@ -6,6 +6,14 @@ config DRM_I2C_ADV7511
 	help
 	  Support for the Analog Device ADV7511(W) and ADV7513 HDMI encoders.
 
+config DRM_I2C_ADV7511_AUDIO
+       bool "ADV7511 HDMI Audio driver"
+       depends on DRM_I2C_ADV7511 && SND_SOC
+       select SND_SOC_HDMI_CODEC
+       help
+         Support the ADV7511 HDMI Audio interface. This is used in
+         conjunction with the AV7511  HDMI driver.
+
 config DRM_I2C_ADV7533
 	bool "ADV7533 encoder"
 	depends on DRM_I2C_ADV7511
diff --git a/drivers/gpu/drm/bridge/adv7511/Makefile b/drivers/gpu/drm/bridge/adv7511/Makefile
index 9019327..5ba6755 100644
--- a/drivers/gpu/drm/bridge/adv7511/Makefile
+++ b/drivers/gpu/drm/bridge/adv7511/Makefile
@@ -1,3 +1,4 @@
 adv7511-y := adv7511_drv.o
+adv7511-$(CONFIG_DRM_I2C_ADV7511_AUDIO) += adv7511_audio.o
 adv7511-$(CONFIG_DRM_I2C_ADV7533) += adv7533.o
 obj-$(CONFIG_DRM_I2C_ADV7511) += adv7511.o
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511.h b/drivers/gpu/drm/bridge/adv7511/adv7511.h
index 161c923..992d76c 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511.h
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511.h
@@ -309,6 +309,8 @@ struct adv7511 {
 	struct drm_display_mode curr_mode;
 
 	unsigned int f_tmds;
+	unsigned int f_audio;
+	unsigned int audio_source;
 
 	unsigned int current_edid_segment;
 	uint8_t edid_buf[256];
@@ -334,6 +336,7 @@ struct adv7511 {
 	bool use_timing_gen;
 
 	enum adv7511_type type;
+	struct platform_device *audio_pdev;
 };
 
 #ifdef CONFIG_DRM_I2C_ADV7533
@@ -389,4 +392,17 @@ static inline int adv7533_parse_dt(struct device_node *np, struct adv7511 *adv)
 }
 #endif
 
+#ifdef CONFIG_DRM_I2C_ADV7511_AUDIO
+int adv7511_audio_init(struct device *dev, struct adv7511 *adv7511);
+void adv7511_audio_exit(struct adv7511 *adv7511);
+#else /*CONFIG_DRM_I2C_ADV7511_AUDIO */
+static inline int adv7511_audio_init(struct device *dev, struct adv7511 *adv7511)
+{
+	return 0;
+}
+static inline void adv7511_audio_exit(struct adv7511 *adv7511)
+{
+}
+#endif /* CONFIG_DRM_I2C_ADV7511_AUDIO */
+
 #endif /* __DRM_I2C_ADV7511_H__ */
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c b/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c
new file mode 100644
index 0000000..a2f2168
--- /dev/null
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c
@@ -0,0 +1,216 @@
+/*
+ * Analog Devices ADV7511 HDMI transmitter driver
+ *
+ * Copyright 2012 Analog Devices Inc.
+ * Copyright (c) 2016, Linaro Limited
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <sound/core.h>
+#include <sound/hdmi-codec.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#include "adv7511.h"
+
+static void adv7511_calc_cts_n(unsigned int f_tmds, unsigned int fs,
+			       unsigned int *cts, unsigned int *n)
+{
+	switch (fs) {
+	case 32000:
+		*n = 4096;
+		break;
+	case 44100:
+		*n = 6272;
+		break;
+	case 48000:
+		*n = 6144;
+		break;
+	}
+
+	*cts = ((f_tmds * *n) / (128 * fs)) * 1000;
+}
+
+static int adv7511_update_cts_n(struct adv7511 *adv7511)
+{
+	unsigned int cts = 0;
+	unsigned int n = 0;
+
+	adv7511_calc_cts_n(adv7511->f_tmds, adv7511->f_audio, &cts, &n);
+
+	regmap_write(adv7511->regmap, ADV7511_REG_N0, (n >> 16) & 0xf);
+	regmap_write(adv7511->regmap, ADV7511_REG_N1, (n >> 8) & 0xff);
+	regmap_write(adv7511->regmap, ADV7511_REG_N2, n & 0xff);
+
+	regmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL0,
+		     (cts >> 16) & 0xf);
+	regmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL1,
+		     (cts >> 8) & 0xff);
+	regmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL2,
+		     cts & 0xff);
+
+	return 0;
+}
+
+int adv7511_hdmi_hw_params(struct device *dev, void *data,
+			   struct hdmi_codec_daifmt *fmt,
+			   struct hdmi_codec_params *hparms)
+{
+	struct adv7511 *adv7511 = dev_get_drvdata(dev);
+	unsigned int audio_source, i2s_format = 0;
+	unsigned int invert_clock;
+	unsigned int rate;
+	unsigned int len;
+
+	switch (hparms->sample_rate) {
+	case 32000:
+		rate = ADV7511_SAMPLE_FREQ_32000;
+		break;
+	case 44100:
+		rate = ADV7511_SAMPLE_FREQ_44100;
+		break;
+	case 48000:
+		rate = ADV7511_SAMPLE_FREQ_48000;
+		break;
+	case 88200:
+		rate = ADV7511_SAMPLE_FREQ_88200;
+		break;
+	case 96000:
+		rate = ADV7511_SAMPLE_FREQ_96000;
+		break;
+	case 176400:
+		rate = ADV7511_SAMPLE_FREQ_176400;
+		break;
+	case 192000:
+		rate = ADV7511_SAMPLE_FREQ_192000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (hparms->sample_width) {
+	case 16:
+		len = ADV7511_I2S_SAMPLE_LEN_16;
+		break;
+	case 18:
+		len = ADV7511_I2S_SAMPLE_LEN_18;
+		break;
+	case 20:
+		len = ADV7511_I2S_SAMPLE_LEN_20;
+		break;
+	case 24:
+		len = ADV7511_I2S_SAMPLE_LEN_24;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt->fmt) {
+	case HDMI_I2S:
+		audio_source = ADV7511_AUDIO_SOURCE_I2S;
+		i2s_format = ADV7511_I2S_FORMAT_I2S;
+		break;
+	case HDMI_RIGHT_J:
+		audio_source = ADV7511_AUDIO_SOURCE_I2S;
+		i2s_format = ADV7511_I2S_FORMAT_RIGHT_J;
+		break;
+	case HDMI_LEFT_J:
+		audio_source = ADV7511_AUDIO_SOURCE_I2S;
+		i2s_format = ADV7511_I2S_FORMAT_LEFT_J;
+		break;
+	case HDMI_SPDIF:
+		audio_source = ADV7511_AUDIO_SOURCE_SPDIF;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	invert_clock = fmt->bit_clk_inv;
+
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_SOURCE, 0x70,
+			   audio_source << 4);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(6),
+			   invert_clock << 6);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_I2S_CONFIG, 0x03,
+			   i2s_format);
+
+	adv7511->audio_source = audio_source;
+
+	adv7511->f_audio = hparms->sample_rate;
+
+	adv7511_update_cts_n(adv7511);
+
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG3,
+			   ADV7511_AUDIO_CFG3_LEN_MASK, len);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG,
+			   ADV7511_I2C_FREQ_ID_CFG_RATE_MASK, rate << 4);
+	regmap_write(adv7511->regmap, 0x73, 0x1);
+
+	return 0;
+}
+
+static int audio_startup(struct device *dev, void *data)
+{
+	struct adv7511 *adv7511 = dev_get_drvdata(dev);
+
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG,
+				BIT(7), 0);
+
+	/* hide Audio infoframe updates */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_INFOFRAME_UPDATE,
+				BIT(5), BIT(5));
+	/* enable N/CTS, enable Audio sample packets */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,
+				BIT(5), BIT(5));
+	/* enable N/CTS */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,
+				BIT(6), BIT(6));
+	/* not copyrighted */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG1,
+				BIT(5), BIT(5));
+	/* enable audio infoframes */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,
+				BIT(3), BIT(3));
+	/* AV mute disable */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_GC(0),
+				BIT(7) | BIT(6), BIT(7));
+	/* use Audio infoframe updated info */
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_GC(1),
+				BIT(5), 0);
+	return 0;
+}
+
+static void audio_shutdown(struct device *dev, void *data)
+{
+}
+
+static const struct hdmi_codec_ops adv7511_codec_ops = {
+	.hw_params	= adv7511_hdmi_hw_params,
+	.audio_shutdown = audio_shutdown,
+	.audio_startup	= audio_startup,
+};
+
+static const struct hdmi_codec_pdata codec_data = {
+	.ops = &adv7511_codec_ops,
+	.max_i2s_channels = 2,
+	.spdif = 1,
+};
+
+int adv7511_audio_init(struct device *dev, struct adv7511 *adv7511)
+{
+	adv7511->audio_pdev = platform_device_register_data(dev,
+					HDMI_CODEC_DRV_NAME,
+					PLATFORM_DEVID_AUTO,
+					&codec_data,
+					sizeof(codec_data));
+	return PTR_ERR_OR_ZERO(adv7511->audio_pdev);
+}
+
+void adv7511_audio_exit(struct adv7511 *adv7511)
+{
+	if (adv7511->audio_pdev) {
+		platform_device_unregister(adv7511->audio_pdev);
+		adv7511->audio_pdev = NULL;
+	}
+}
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index ec8fb2e..3167cf9 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -199,17 +199,14 @@ static const uint16_t adv7511_csc_ycbcr_to_rgb[] = {
 
 static void adv7511_set_config_csc(struct adv7511 *adv7511,
 				   struct drm_connector *connector,
-				   bool rgb)
+				   bool rgb, bool hdmi_mode)
 {
 	struct adv7511_video_config config;
 	bool output_format_422, output_format_ycbcr;
 	unsigned int mode;
 	uint8_t infoframe[17];
 
-	if (adv7511->edid)
-		config.hdmi_mode = drm_detect_hdmi_monitor(adv7511->edid);
-	else
-		config.hdmi_mode = false;
+	config.hdmi_mode = hdmi_mode;
 
 	hdmi_avi_infoframe_init(&config.avi_infoframe);
 
@@ -325,10 +322,9 @@ static void adv7511_set_link_config(struct adv7511 *adv7511,
 	adv7511->rgb = config->input_colorspace == HDMI_COLORSPACE_RGB;
 }
 
-static void adv7511_power_on(struct adv7511 *adv7511)
+static void __adv7511_power_on(struct adv7511 *adv7511)
 {
 	adv7511->current_edid_segment = -1;
-
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
 			   ADV7511_POWER_POWER_DOWN, 0);
 	if (adv7511->i2c_main->irq) {
@@ -354,6 +350,11 @@ static void adv7511_power_on(struct adv7511 *adv7511)
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
 			   ADV7511_REG_POWER2_HPD_SRC_MASK,
 			   ADV7511_REG_POWER2_HPD_SRC_NONE);
+}
+
+static void adv7511_power_on(struct adv7511 *adv7511)
+{
+	__adv7511_power_on(adv7511);
 
 	/*
 	 * Most of the registers are reset during power down or when HPD is low.
@@ -362,21 +363,23 @@ static void adv7511_power_on(struct adv7511 *adv7511)
 
 	if (adv7511->type == ADV7533)
 		adv7533_dsi_power_on(adv7511);
-
 	adv7511->powered = true;
 }
 
-static void adv7511_power_off(struct adv7511 *adv7511)
+static void __adv7511_power_off(struct adv7511 *adv7511)
 {
 	/* TODO: setup additional power down modes */
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
 			   ADV7511_POWER_POWER_DOWN,
 			   ADV7511_POWER_POWER_DOWN);
 	regcache_mark_dirty(adv7511->regmap);
+}
 
+static void adv7511_power_off(struct adv7511 *adv7511)
+{
+	__adv7511_power_off(adv7511);
 	if (adv7511->type == ADV7533)
 		adv7533_dsi_power_off(adv7511);
-
 	adv7511->powered = false;
 }
 
@@ -546,33 +549,28 @@ static int adv7511_get_modes(struct adv7511 *adv7511,
 
 	/* Reading the EDID only works if the device is powered */
 	if (!adv7511->powered) {
-		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
-				   ADV7511_POWER_POWER_DOWN, 0);
-		if (adv7511->i2c_main->irq) {
-			regmap_write(adv7511->regmap, ADV7511_REG_INT_ENABLE(0),
-				     ADV7511_INT0_EDID_READY);
-			regmap_write(adv7511->regmap, ADV7511_REG_INT_ENABLE(1),
-				     ADV7511_INT1_DDC_ERROR);
-		}
-		adv7511->current_edid_segment = -1;
+		unsigned int edid_i2c_addr = adv7511->i2c_edid->addr << 1;
+
+		__adv7511_power_on(adv7511);
+
+		/* Reset the EDID_I2C_ADDR register as it might be cleared */
+		regmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR,
+			     edid_i2c_addr);
 	}
 
 	edid = drm_do_get_edid(connector, adv7511_get_edid_block, adv7511);
 
 	if (!adv7511->powered)
-		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
-				   ADV7511_POWER_POWER_DOWN,
-				   ADV7511_POWER_POWER_DOWN);
+		__adv7511_power_off(adv7511);
 
-	kfree(adv7511->edid);
-	adv7511->edid = edid;
-	if (!edid)
-		return 0;
 
 	drm_mode_connector_update_edid_property(connector, edid);
 	count = drm_add_edid_modes(connector, edid);
 
-	adv7511_set_config_csc(adv7511, connector, adv7511->rgb);
+	adv7511_set_config_csc(adv7511, connector, adv7511->rgb,
+			       drm_detect_hdmi_monitor(edid));
+
+	kfree(edid);
 
 	return count;
 }
@@ -809,7 +807,11 @@ static int adv7511_bridge_attach(struct drm_bridge *bridge)
 		return -ENODEV;
 	}
 
-	adv->connector.polled = DRM_CONNECTOR_POLL_HPD;
+	if (adv->i2c_main->irq)
+		adv->connector.polled = DRM_CONNECTOR_POLL_HPD;
+	else
+		adv->connector.polled = DRM_CONNECTOR_POLL_CONNECT |
+				DRM_CONNECTOR_POLL_DISCONNECT;
 
 	ret = drm_connector_init(bridge->dev, &adv->connector,
 				 &adv7511_connector_funcs,
@@ -922,15 +924,13 @@ static int adv7511_parse_dt(struct device_node *np,
 	return 0;
 }
 
-static const int edid_i2c_addr = 0x7e;
-static const int packet_i2c_addr = 0x70;
-static const int cec_i2c_addr = 0x78;
-
 static int adv7511_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 {
 	struct adv7511_link_config link_config;
 	struct adv7511 *adv7511;
 	struct device *dev = &i2c->dev;
+	unsigned int main_i2c_addr = i2c->addr << 1;
+	unsigned int edid_i2c_addr = main_i2c_addr + 4;
 	unsigned int val;
 	int ret;
 
@@ -989,17 +989,22 @@ static int adv7511_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 	if (ret)
 		return ret;
 
-	regmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR, edid_i2c_addr);
 	regmap_write(adv7511->regmap, ADV7511_REG_PACKET_I2C_ADDR,
-		     packet_i2c_addr);
-	regmap_write(adv7511->regmap, ADV7511_REG_CEC_I2C_ADDR, cec_i2c_addr);
+		     main_i2c_addr - 0xa);
+	regmap_write(adv7511->regmap, ADV7511_REG_CEC_I2C_ADDR,
+		     main_i2c_addr - 2);
+
 	adv7511_packet_disable(adv7511, 0xffff);
 
 	adv7511->i2c_main = i2c;
-	adv7511->i2c_edid = i2c_new_dummy(i2c->adapter, edid_i2c_addr >> 1);
+	adv7511->i2c_edid = i2c_new_secondary_device(i2c, "edid",
+						     edid_i2c_addr >> 1);
 	if (!adv7511->i2c_edid)
 		return -ENOMEM;
 
+	regmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR,
+		     adv7511->i2c_edid->addr << 1);
+
 	if (adv7511->type == ADV7533) {
 		ret = adv7533_init_cec(adv7511);
 		if (ret)
@@ -1037,6 +1042,8 @@ static int adv7511_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 		goto err_unregister_cec;
 	}
 
+	adv7511_audio_init(dev, adv7511);
+
 	return 0;
 
 err_unregister_cec:
@@ -1058,9 +1065,9 @@ static int adv7511_remove(struct i2c_client *i2c)
 
 	drm_bridge_remove(&adv7511->bridge);
 
-	i2c_unregister_device(adv7511->i2c_edid);
+	adv7511_audio_exit(adv7511);
 
-	kfree(adv7511->edid);
+	i2c_unregister_device(adv7511->i2c_edid);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c
index 66dc275..9e8dbb2 100644
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@ -886,7 +886,10 @@ crtc_set_mode(struct drm_device *dev, struct drm_atomic_state *old_state)
 		 * Each encoder has at most one connector (since we always steal
 		 * it away), so we won't call mode_set hooks twice.
 		 */
-		if (funcs && funcs->mode_set)
+               if (funcs && funcs->atomic_mode_set)
+			funcs->atomic_mode_set(encoder, new_crtc_state,
+                                                          connector->state);
+               else if (funcs && funcs->mode_set)
 			funcs->mode_set(encoder, mode, adjusted_mode);
 
 		drm_bridge_mode_set(encoder->bridge, mode, adjusted_mode);
diff --git a/drivers/gpu/drm/drm_platform.c b/drivers/gpu/drm/drm_platform.c
index 2c819ef..0262698 100644
--- a/drivers/gpu/drm/drm_platform.c
+++ b/drivers/gpu/drm/drm_platform.c
@@ -48,8 +48,8 @@ static int drm_get_platform_dev(struct platform_device *platdev,
 	DRM_DEBUG("\n");
 
 	dev = drm_dev_alloc(driver, &platdev->dev);
-	if (!dev)
-		return -ENOMEM;
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
 
 	dev->platformdev = platdev;
 
diff --git a/include/drm/drm_edid.h b/include/drm/drm_edid.h
index 919933d..9f89470 100644
--- a/include/drm/drm_edid.h
+++ b/include/drm/drm_edid.h
@@ -24,6 +24,10 @@
 #define __DRM_EDID_H__
 
 #include <linux/types.h>
+#include <drm/drm_crtc.h>
+
+struct drm_device;
+struct i2c_adapter;
 
 #define EDID_LENGTH 128
 #define DDC_ADDR 0x50
@@ -412,6 +416,21 @@ static inline int drm_eld_size(const uint8_t *eld)
 }
 
 /**
+ * drm_connector_get_edid - Get current EDID from the given connector
+ * @connector: pointer to the connector stucture
+ *
+ * This is a helper for accessing the drm blob buffered in the connector
+ * struct (if any)
+ */
+static inline struct edid *drm_connector_get_edid(struct drm_connector *connector)
+{
+	if (!connector->edid_blob_ptr)
+		return NULL;
+
+	return (struct edid *)connector->edid_blob_ptr->data;
+}
+
+/**
  * drm_eld_get_conn_type - Get device type hdmi/dp connected
  * @eld: pointer to an ELD memory structure
  *
@@ -423,9 +442,36 @@ static inline u8 drm_eld_get_conn_type(const uint8_t *eld)
 	return eld[DRM_ELD_SAD_COUNT_CONN_TYPE] & DRM_ELD_CONN_TYPE_MASK;
 }
 
+bool drm_probe_ddc(struct i2c_adapter *adapter);
 struct edid *drm_do_get_edid(struct drm_connector *connector,
 	int (*get_edid_block)(void *data, u8 *buf, unsigned int block,
 			      size_t len),
 	void *data);
+struct edid *drm_get_edid(struct drm_connector *connector,
+			  struct i2c_adapter *adapter);
+struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
+				     struct i2c_adapter *adapter);
+struct edid *drm_edid_duplicate(const struct edid *edid);
+int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
+
+u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
+enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
+bool drm_detect_hdmi_monitor(struct edid *edid);
+bool drm_detect_monitor_audio(struct edid *edid);
+bool drm_rgb_quant_range_selectable(struct edid *edid);
+int drm_add_modes_noedid(struct drm_connector *connector,
+			 int hdisplay, int vdisplay);
+void drm_set_preferred_mode(struct drm_connector *connector,
+			    int hpref, int vpref);
+
+int drm_edid_header_is_valid(const u8 *raw_edid);
+bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
+			  bool *edid_corrupt);
+bool drm_edid_is_valid(struct edid *edid);
+void drm_edid_get_monitor_name(struct edid *edid, char *name,
+			       int buflen);
+struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
+					   int hsize, int vsize, int fresh,
+					   bool rb);
 
 #endif /* __DRM_EDID_H__ */
diff --git a/include/drm/drm_modeset_helper_vtables.h b/include/drm/drm_modeset_helper_vtables.h
index b55f218..10e449c 100644
--- a/include/drm/drm_modeset_helper_vtables.h
+++ b/include/drm/drm_modeset_helper_vtables.h
@@ -266,6 +266,8 @@ struct drm_crtc_helper_funcs {
 	 * disable anything at the CRTC level. To ensure that runtime PM
 	 * handling (using either DPMS or the new "ACTIVE" property) works
 	 * @disable must be the inverse of @enable for atomic drivers.
+	 * Atomic drivers should consider to use @atomic_disable instead of
+	 * this one.
 	 *
 	 * NOTE:
 	 *
@@ -391,6 +393,28 @@ struct drm_crtc_helper_funcs {
 	 */
 	void (*atomic_flush)(struct drm_crtc *crtc,
 			     struct drm_crtc_state *old_crtc_state);
+
+	/**
+	 * @atomic_disable:
+	 *
+	 * This callback should be used to disable the CRTC. With the atomic
+	 * drivers it is called after all encoders connected to this CRTC have
+	 * been shut off already using their own ->disable hook. If that
+	 * sequence is too simple drivers can just add their own hooks and call
+	 * it from this CRTC callback here by looping over all encoders
+	 * connected to it using for_each_encoder_on_crtc().
+	 *
+	 * This hook is used only by atomic helpers. Atomic drivers don't
+	 * need to implement it if there's no need to disable anything at the
+	 * CRTC level.
+	 *
+	 * Comparing to @disable, this one provides the additional input
+	 * parameter @old_crtc_state which could be used to access the old
+	 * state. Atomic drivers should consider to use this one instead
+	 * of @disable.
+	 */
+	void (*atomic_disable)(struct drm_crtc *crtc,
+			       struct drm_crtc_state *old_crtc_state);
 };
 
 /**
@@ -523,12 +547,41 @@ struct drm_encoder_helper_funcs {
 	 *
 	 * This callback is used both by the legacy CRTC helpers and the atomic
 	 * modeset helpers. It is optional in the atomic helpers.
+	 *
+	 * NOTE:
+	 *
+	 * If the driver uses the atomic modeset helpers and needs to inspect
+	 * the connector state or connector display info during mode setting,
+	 * @atomic_mode_set can be used instead.
 	 */
 	void (*mode_set)(struct drm_encoder *encoder,
 			 struct drm_display_mode *mode,
 			 struct drm_display_mode *adjusted_mode);
 
 	/**
+	 * @atomic_mode_set:
+	 *
+	 * This callback is used to update the display mode of an encoder.
+	 *
+	 * Note that the display pipe is completely off when this function is
+	 * called. Drivers which need hardware to be running before they program
+	 * the new display mode (because they implement runtime PM) should not
+	 * use this hook, because the helper library calls it only once and not
+	 * every time the display pipeline is suspended using either DPMS or the
+	 * new "ACTIVE" property. Such drivers should instead move all their
+	 * encoder setup into the ->enable() callback.
+	 *
+	 * This callback is used by the atomic modeset helpers in place of the
+	 * @mode_set callback, if set by the driver. It is optional and should
+	 * be used instead of @mode_set if the driver needs to inspect the
+	 * connector state or display info, since there is no direct way to
+	 * go from the encoder to the current connector.
+	 */
+	void (*atomic_mode_set)(struct drm_encoder *encoder,
+				struct drm_crtc_state *crtc_state,
+				struct drm_connector_state *conn_state);
+
+	/**
 	 * @get_crtc:
 	 *
 	 * This callback is used by the legacy CRTC helpers to work around
@@ -826,7 +879,7 @@ struct drm_plane_helper_funcs {
 	 * everything else must complete successfully.
 	 */
 	int (*prepare_fb)(struct drm_plane *plane,
-			  const struct drm_plane_state *new_state);
+			  struct drm_plane_state *new_state);
 	/**
 	 * @cleanup_fb:
 	 *
@@ -837,7 +890,7 @@ struct drm_plane_helper_funcs {
 	 * transitional plane helpers, but it is optional.
 	 */
 	void (*cleanup_fb)(struct drm_plane *plane,
-			   const struct drm_plane_state *old_state);
+			   struct drm_plane_state *old_state);
 
 	/**
 	 * @atomic_check:
-- 
1.7.5.4

