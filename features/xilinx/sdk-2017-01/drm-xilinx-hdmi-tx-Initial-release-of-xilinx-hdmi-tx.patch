From d9c059ad9c9d289be7c6f70e36729dcd1a591c5c Mon Sep 17 00:00:00 2001
From: Rohit Consul <rohitco@xilinx.com>
Date: Fri, 5 May 2017 11:42:36 -0700
Subject: [PATCH 1542/1566] drm: xilinx-hdmi-tx: Initial release of xilinx
 hdmi-tx soft IP driver

commit  bc5656838144a3f09697dd227b5e8212de5124d6 from
https://github.com/Xilinx/linux-xlnx.git

HDMI Tx subsystem is a feature-rich soft IP incorporating all the necessary
logic to properly interface with xilinx PHY layers and provide HDMI encoding
functionality. The subsystem is a hierarchical IP that bundles a collection of
HDMI TX-related IP sub-cores and outputs them as a single IP. The subsystem
takes incoming video and audio streams and transfers them to an HDMI stream. The
stream is then forwarded to the video PHY layer

Driver is being released in staging area and is in experimental state

Signed-off-by: Rohit Consul <rohitco@xilinx.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/sleep.h |   34 +
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xdebug.h    |   32 +
 .../xilinx/hdmi/xilinx-hdmi-tx/xil_assert.h        |   90 +
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xil_io.h    |   72 +
 .../xilinx/hdmi/xilinx-hdmi-tx/xil_printf.h        |   49 +
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xil_types.h |  200 ++
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xstatus.h   |  519 ++++
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.c | 1625 ++++++++++++
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.h |  921 +++++++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_hw.h      |  323 +++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_intr.c    |  333 +++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_sinit.c   |   93 +
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.c    |  695 ++++++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.h    |  174 ++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.c       | 2184 ++++++++++++++++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.h       |  478 ++++
 .../hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.c     |  432 ++++
 .../hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.h     |   68 +
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_hdcp.c  | 2246 +++++++++++++++++
 .../xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_log.c   |  262 ++
 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc.h |  542 ++++
 .../xilinx/hdmi/xilinx-hdmi-tx/xvidc_edid.h        |  468 ++++
 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.c  | 2615 ++++++++++++++++++++
 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.h  |  948 +++++++
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_hw.h   |  651 +++++
 .../staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_intr.c |  282 +++
 .../xilinx/hdmi/xilinx-hdmi-tx/xvtc_sinit.c        |  106 +
 drivers/staging/xilinx/hdmi/xilinx_drm_hdmi.c      | 1243 ++++++++++
 28 files changed, 17685 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/sleep.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xdebug.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_assert.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_io.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_printf.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_types.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xstatus.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_hw.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_intr.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_sinit.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_hdcp.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_log.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc_edid.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_hw.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_intr.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_sinit.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx_drm_hdmi.c

diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/sleep.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/sleep.h
new file mode 100644
index 0000000..363ab8b
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/sleep.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+
+#ifndef SLEEP_H
+#define SLEEP_H
+
+#include "xil_types.h"
+#include "xil_io.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int usleep(unsigned long useconds);
+unsigned sleep(unsigned int seconds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xdebug.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xdebug.h
new file mode 100644
index 0000000..650946b
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xdebug.h
@@ -0,0 +1,32 @@
+#ifndef XDEBUG  /* prevent circular inclusions */
+#define XDEBUG  /* by using protection macros */
+
+#if defined(DEBUG) && !defined(NDEBUG)
+
+#ifndef XDEBUG_WARNING
+#define XDEBUG_WARNING
+#warning DEBUG is enabled
+#endif
+
+int printf(const char *format, ...);
+
+#define XDBG_DEBUG_ERROR             0x00000001U    /* error  condition messages */
+#define XDBG_DEBUG_GENERAL           0x00000002U    /* general debug  messages */
+#define XDBG_DEBUG_ALL               0xFFFFFFFFU    /* all debugging data */
+
+#define xdbg_current_types (XDBG_DEBUG_GENERAL)
+
+#define xdbg_stmnt(x)  x
+
+#define xdbg_printf(type, ...) (((type) & xdbg_current_types) ? printf (__VA_ARGS__) : 0)
+
+
+#else /* defined(DEBUG) && !defined(NDEBUG) */
+
+#define xdbg_stmnt(x)
+
+#define xdbg_printf(...)
+
+#endif /* defined(DEBUG) && !defined(NDEBUG) */
+
+#endif /* XDEBUG */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_assert.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_assert.h
new file mode 100644
index 0000000..c9c8475
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_assert.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+*
+* Copyright (C) 2009 - 2015 Xilinx, Inc. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* Use of the Software is limited solely to applications:
+* (a) running on a Xilinx device, or
+* (b) that interact with a Xilinx device through a bus or interconnect.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE.
+*
+* Except as contained in this notice, the name of the Xilinx shall not be used
+* in advertising or otherwise to promote the sale, use or other dealings in
+* this Software without prior written authorization from Xilinx.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_assert.h
+*
+* This file contains assert related functions.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_ASSERT_H	/* prevent circular inclusions */
+#define XIL_ASSERT_H	/* by using protection macros */
+
+#include "xil_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+
+/************************** Constant Definitions *****************************/
+
+#define XIL_ASSERT_NONE     0U
+#define XIL_ASSERT_OCCURRED 1U
+#define XNULL NULL
+
+/**
+ * This data type defines a callback to be invoked when an
+ * assert occurs. The callback is invoked only when asserts are enabled
+ */
+//typedef void (*Xil_AssertCallback) (const char8 *File, s32 Line);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+//#define Xil_Assert(const char8 *File, s32 Line)
+//#define Xil_AssertSetCallback(Xil_AssertCallback Routine)
+
+#define Xil_AssertVoid(Expression)
+#define Xil_AssertVoidAlways()
+#define Xil_AssertNonvoid(Expression)
+#define Xil_AssertNonvoidAlways()
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_io.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_io.h
new file mode 100644
index 0000000..3b24af4
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_io.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+*
+* Copyright (C) 2014 - 2015 Xilinx, Inc. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* Use of the Software is limited solely to applications:
+* (a) running on a Xilinx device, or
+* (b) that interact with a Xilinx device through a bus or interconnect.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE.
+*
+* Except as contained in this notice, the name of the Xilinx shall not be used
+* in advertising or otherwise to promote the sale, use or other dealings in
+* this Software without prior written authorization from Xilinx.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_io.h
+*
+* This file contains the interface for the general IO component, which
+* encapsulates the Input/Output functions for processors that do not
+* require any special I/O handling.
+*
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who      Date     Changes
+* ----- -------- -------- -----------------------------------------------
+* 5.00 	pkp  	 05/29/14 First release
+* </pre>
+******************************************************************************/
+
+#ifndef XIL_IO_H           /* prevent circular inclusions */
+#define XIL_IO_H           /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_types.h"
+#include <linux/io.h>
+
+static inline void Xil_Out32(INTPTR Addr, u32 Value)
+{
+	iowrite32(Value, (volatile void *)Addr);
+}
+static inline u32 Xil_In32(INTPTR Addr)
+{
+	return ioread32((const volatile void *)Addr);
+}
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_printf.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_printf.h
new file mode 100644
index 0000000..1529cf6
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_printf.h
@@ -0,0 +1,49 @@
+ #ifndef XIL_PRINTF_H
+ #define XIL_PRINTF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __KERNEL__
+#include <ctype.h>
+#include <string.h>
+#include <stdarg.h>
+#endif
+#include "xil_types.h"
+
+/*----------------------------------------------------*/
+/* Use the following parameter passing structure to   */
+/* make xil_printf re-entrant.                        */
+/*----------------------------------------------------*/
+
+struct params_s;
+
+
+/*---------------------------------------------------*/
+/* The purpose of this routine is to output data the */
+/* same as the standard printf function without the  */
+/* overhead most run-time libraries involve. Usually */
+/* the printf brings in many kilobytes of code and   */
+/* that is unacceptable in most embedded systems.    */
+/*---------------------------------------------------*/
+
+typedef char8* charptr;
+typedef s32 (*func_ptr)(int c);
+
+/*                                                   */
+
+void xil_printf( const char8 *ctrl1, ...);
+void print( const char8 *ptr);
+extern void outbyte (char8 c);
+extern char8 inbyte(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <linux/module.h> 
+#define xil_printf(format, ...) printk(KERN_INFO format, ## __VA_ARGS__) 
+#define print(format) printk(KERN_INFO format)
+
+#endif	/* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_types.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_types.h
new file mode 100644
index 0000000..f1dc072
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xil_types.h
@@ -0,0 +1,200 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_types.h
+*
+* @addtogroup common_types Basic Data types for Xilinx&reg; Software IP
+*
+* The xil_types.h file contains basic types for Xilinx software IP. These data types
+* are applicable for all processors supported by Xilinx.
+* @{
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* 3.03a sdm  05/30/11 Added Xuint64 typedef and XUINT64_MSW/XUINT64_LSW macros
+* 5.00 	pkp  05/29/14 Made changes for 64 bit architecture
+*	srt  07/14/14 Use standard definitions from stdint.h and stddef.h
+*		      Define LONG and ULONG datatypes and mask values
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_TYPES_H	/* prevent circular inclusions */
+#define XIL_TYPES_H	/* by using protection macros */
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#include <stddef.h>
+#endif
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#  define TRUE		1U
+#endif
+
+#ifndef FALSE
+#  define FALSE		0U
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define XIL_COMPONENT_IS_READY     0x11111111U  /**< In device drivers, This macro will be
+                                                 assigend to "IsReady" member of driver
+												 instance to indicate that driver
+												 instance is initialized and ready to use. */
+#define XIL_COMPONENT_IS_STARTED   0x22222222U  /**< In device drivers, This macro will be assigend to
+                                                 "IsStarted" member of driver instance
+												 to indicate that driver instance is
+												 started and it can be enabled. */
+
+/* @name New types
+ * New simple types.
+ * @{
+ */
+#ifndef __KERNEL__
+#ifndef XBASIC_TYPES_H
+/*
+ * guarded against xbasic_types.h.
+ */
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+/** @}*/
+#define __XUINT64__
+typedef struct
+{
+	u32 Upper;
+	u32 Lower;
+} Xuint64;
+
+
+/*****************************************************************************/
+/**
+* @brief    Return the most significant half of the 64 bit data type.
+*
+* @param    x is the 64 bit word.
+*
+* @return   The upper 32 bits of the 64 bit word.
+*
+******************************************************************************/
+#define XUINT64_MSW(x) ((x).Upper)
+
+/*****************************************************************************/
+/**
+* @brief    Return the least significant half of the 64 bit data type.
+*
+* @param    x is the 64 bit word.
+*
+* @return   The lower 32 bits of the 64 bit word.
+*
+******************************************************************************/
+#define XUINT64_LSW(x) ((x).Lower)
+
+#endif /* XBASIC_TYPES_H */
+
+/*
+ * xbasic_types.h does not typedef s* or u64
+ */
+/** @{ */
+typedef char char8;
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+typedef uint64_t u64;
+typedef int sint32;
+
+typedef intptr_t INTPTR;
+typedef uintptr_t UINTPTR;
+typedef ptrdiff_t PTRDIFF;
+/** @}*/
+#if !defined(LONG) || !defined(ULONG)
+typedef long LONG;
+typedef unsigned long ULONG;
+#endif
+
+#define ULONG64_HI_MASK	0xFFFFFFFF00000000U
+#define ULONG64_LO_MASK	~ULONG64_HI_MASK
+
+#else
+#include <linux/types.h>
+// Used by xil_io.h
+typedef char char8;
+typedef long INTPTR;
+typedef uintptr_t UINTPTR;
+typedef ptrdiff_t PTRDIFF;
+#endif
+
+/** @{ */
+/**
+ * This data type defines an interrupt handler for a device.
+ * The argument points to the instance of the component
+ */
+typedef void (*XInterruptHandler) (void *InstancePtr);
+
+/**
+ * This data type defines an exception handler for a processor.
+ * The argument points to the instance of the component
+ */
+typedef void (*XExceptionHandler) (void *InstancePtr);
+
+/**
+ * @brief  Returns 32-63 bits of a number.
+ * @param  n : Number being accessed.
+ * @return Bits 32-63 of number.
+ *
+ * @note    A basic shift-right of a 64- or 32-bit quantity.
+ *          Use this to suppress the "right shift count >= width of type"
+ *          warning when that quantity is 32-bits.
+ */
+#define UPPER_32_BITS(n) ((u32)(((n) >> 16) >> 16))
+
+/**
+ * @brief  Returns 0-31 bits of a number
+ * @param  n : Number being accessed.
+ * @return Bits 0-31 of number
+ */
+#define LOWER_32_BITS(n) ((u32)(n))
+
+
+
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#define TRUE		1U
+#endif
+
+#ifndef FALSE
+#define FALSE		0U
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#endif	/* end of protection macro */
+/**
+* @} End of "addtogroup common_types".
+*/
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xstatus.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xstatus.h
new file mode 100644
index 0000000..5f4835f
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xstatus.h
@@ -0,0 +1,519 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xstatus.h
+*
+* @addtogroup common_status_codes Xilinx&reg; software status codes
+*
+* The xstatus.h file contains the Xilinx&reg; software status codes.These codes are
+* used throughout the Xilinx device drivers.
+*
+* @{
+******************************************************************************/
+
+#ifndef XSTATUS_H		/* prevent circular inclusions */
+#define XSTATUS_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_types.h"
+#include "xil_assert.h"
+
+/************************** Constant Definitions *****************************/
+
+/*********************** Common statuses 0 - 500 *****************************/
+/**
+@name Common Status Codes for All Device Drivers
+@{
+*/
+#define XST_SUCCESS                     0L
+#define XST_FAILURE                     1L
+#define XST_DEVICE_NOT_FOUND            2L
+#define XST_DEVICE_BLOCK_NOT_FOUND      3L
+#define XST_INVALID_VERSION             4L
+#define XST_DEVICE_IS_STARTED           5L
+#define XST_DEVICE_IS_STOPPED           6L
+#define XST_FIFO_ERROR                  7L	/*!< An error occurred during an
+						   operation with a FIFO such as
+						   an underrun or overrun, this
+						   error requires the device to
+						   be reset */
+#define XST_RESET_ERROR                 8L	/*!< An error occurred which requires
+						   the device to be reset */
+#define XST_DMA_ERROR                   9L	/*!< A DMA error occurred, this error
+						   typically requires the device
+						   using the DMA to be reset */
+#define XST_NOT_POLLED                  10L	/*!< The device is not configured for
+						   polled mode operation */
+#define XST_FIFO_NO_ROOM                11L	/*!< A FIFO did not have room to put
+						   the specified data into */
+#define XST_BUFFER_TOO_SMALL            12L	/*!< The buffer is not large enough
+						   to hold the expected data */
+#define XST_NO_DATA                     13L	/*!< There was no data available */
+#define XST_REGISTER_ERROR              14L	/*!< A register did not contain the
+						   expected value */
+#define XST_INVALID_PARAM               15L	/*!< An invalid parameter was passed
+						   into the function */
+#define XST_NOT_SGDMA                   16L	/*!< The device is not configured for
+						   scatter-gather DMA operation */
+#define XST_LOOPBACK_ERROR              17L	/*!< A loopback test failed */
+#define XST_NO_CALLBACK                 18L	/*!< A callback has not yet been
+						   registered */
+#define XST_NO_FEATURE                  19L	/*!< Device is not configured with
+						   the requested feature */
+#define XST_NOT_INTERRUPT               20L	/*!< Device is not configured for
+						   interrupt mode operation */
+#define XST_DEVICE_BUSY                 21L	/*!< Device is busy */
+#define XST_ERROR_COUNT_MAX             22L	/*!< The error counters of a device
+						   have maxed out */
+#define XST_IS_STARTED                  23L	/*!< Used when part of device is
+						   already started i.e.
+						   sub channel */
+#define XST_IS_STOPPED                  24L	/*!< Used when part of device is
+						   already stopped i.e.
+						   sub channel */
+#define XST_DATA_LOST                   26L	/*!< Driver defined error */
+#define XST_RECV_ERROR                  27L	/*!< Generic receive error */
+#define XST_SEND_ERROR                  28L	/*!< Generic transmit error */
+#define XST_NOT_ENABLED                 29L	/*!< A requested service is not
+						   available because it has not
+						   been enabled */
+/** @} */
+/***************** Utility Component statuses 401 - 500  *********************/
+/**
+@name Utility Component Status Codes 401 - 500
+@{
+*/
+#define XST_MEMTEST_FAILED              401L	/*!< Memory test failed */
+
+/** @} */
+/***************** Common Components statuses 501 - 1000 *********************/
+/**
+@name Packet Fifo Status Codes 501 - 510
+@{
+*/
+/********************* Packet Fifo statuses 501 - 510 ************************/
+
+#define XST_PFIFO_LACK_OF_DATA          501L	/*!< Not enough data in FIFO   */
+#define XST_PFIFO_NO_ROOM               502L	/*!< Not enough room in FIFO   */
+#define XST_PFIFO_BAD_REG_VALUE         503L	/*!< Self test, a register value
+						   was invalid after reset */
+#define XST_PFIFO_ERROR                 504L	/*!< Generic packet FIFO error */
+#define XST_PFIFO_DEADLOCK              505L	/*!< Packet FIFO is reporting
+						 * empty and full simultaneously
+						 */
+/** @} */
+/**
+@name DMA Status Codes 511 - 530
+@{
+*/
+/************************** DMA statuses 511 - 530 ***************************/
+
+#define XST_DMA_TRANSFER_ERROR          511L	/*!< Self test, DMA transfer
+						   failed */
+#define XST_DMA_RESET_REGISTER_ERROR    512L	/*!< Self test, a register value
+						   was invalid after reset */
+#define XST_DMA_SG_LIST_EMPTY           513L	/*!< Scatter gather list contains
+						   no buffer descriptors ready
+						   to be processed */
+#define XST_DMA_SG_IS_STARTED           514L	/*!< Scatter gather not stopped */
+#define XST_DMA_SG_IS_STOPPED           515L	/*!< Scatter gather not running */
+#define XST_DMA_SG_LIST_FULL            517L	/*!< All the buffer desciptors of
+						   the scatter gather list are
+						   being used */
+#define XST_DMA_SG_BD_LOCKED            518L	/*!< The scatter gather buffer
+						   descriptor which is to be
+						   copied over in the scatter
+						   list is locked */
+#define XST_DMA_SG_NOTHING_TO_COMMIT    519L	/*!< No buffer descriptors have been
+						   put into the scatter gather
+						   list to be commited */
+#define XST_DMA_SG_COUNT_EXCEEDED       521L	/*!< The packet count threshold
+						   specified was larger than the
+						   total # of buffer descriptors
+						   in the scatter gather list */
+#define XST_DMA_SG_LIST_EXISTS          522L	/*!< The scatter gather list has
+						   already been created */
+#define XST_DMA_SG_NO_LIST              523L	/*!< No scatter gather list has
+						   been created */
+#define XST_DMA_SG_BD_NOT_COMMITTED     524L	/*!< The buffer descriptor which was
+						   being started was not committed
+						   to the list */
+#define XST_DMA_SG_NO_DATA              525L	/*!< The buffer descriptor to start
+						   has already been used by the
+						   hardware so it can't be reused
+						 */
+#define XST_DMA_SG_LIST_ERROR           526L	/*!< General purpose list access
+						   error */
+#define XST_DMA_BD_ERROR                527L	/*!< General buffer descriptor
+						   error */
+/** @} */
+/**
+@name IPIF Status Codes Codes 531 - 550
+@{
+*/
+/************************** IPIF statuses 531 - 550 ***************************/
+
+#define XST_IPIF_REG_WIDTH_ERROR        531L	/*!< An invalid register width
+						   was passed into the function */
+#define XST_IPIF_RESET_REGISTER_ERROR   532L	/*!< The value of a register at
+						   reset was not valid */
+#define XST_IPIF_DEVICE_STATUS_ERROR    533L	/*!< A write to the device interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_DEVICE_ACK_ERROR       534L	/*!< The device interrupt status
+						   register did not reset when
+						   acked */
+#define XST_IPIF_DEVICE_ENABLE_ERROR    535L	/*!< The device interrupt enable
+						   register was not updated when
+						   other registers changed */
+#define XST_IPIF_IP_STATUS_ERROR        536L	/*!< A write to the IP interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_IP_ACK_ERROR           537L	/*!< The IP interrupt status register
+						   did not reset when acked */
+#define XST_IPIF_IP_ENABLE_ERROR        538L	/*!< IP interrupt enable register was
+						   not updated correctly when other
+						   registers changed */
+#define XST_IPIF_DEVICE_PENDING_ERROR   539L	/*!< The device interrupt pending
+						   register did not indicate the
+						   expected value */
+#define XST_IPIF_DEVICE_ID_ERROR        540L	/*!< The device interrupt ID register
+						   did not indicate the expected
+						   value */
+#define XST_IPIF_ERROR                  541L	/*!< Generic ipif error */
+/** @} */
+
+/****************** Device specific statuses 1001 - 4095 *********************/
+/**
+@name Ethernet Status Codes 1001 - 1050
+@{
+*/
+/********************* Ethernet statuses 1001 - 1050 *************************/
+
+#define XST_EMAC_MEMORY_SIZE_ERROR  1001L	/*!< Memory space is not big enough
+						 * to hold the minimum number of
+						 * buffers or descriptors */
+#define XST_EMAC_MEMORY_ALLOC_ERROR 1002L	/*!< Memory allocation failed */
+#define XST_EMAC_MII_READ_ERROR     1003L	/*!< MII read error */
+#define XST_EMAC_MII_BUSY           1004L	/*!< An MII operation is in progress */
+#define XST_EMAC_OUT_OF_BUFFERS     1005L	/*!< Driver is out of buffers */
+#define XST_EMAC_PARSE_ERROR        1006L	/*!< Invalid driver init string */
+#define XST_EMAC_COLLISION_ERROR    1007L	/*!< Excess deferral or late
+						 * collision on polled send */
+/** @} */
+/**
+@name UART Status Codes 1051 - 1075
+@{
+*/
+/*********************** UART statuses 1051 - 1075 ***************************/
+#define XST_UART
+
+#define XST_UART_INIT_ERROR         1051L
+#define XST_UART_START_ERROR        1052L
+#define XST_UART_CONFIG_ERROR       1053L
+#define XST_UART_TEST_FAIL          1054L
+#define XST_UART_BAUD_ERROR         1055L
+#define XST_UART_BAUD_RANGE         1056L
+
+/** @} */
+/**
+@name IIC Status Codes 1076 - 1100
+@{
+*/
+/************************ IIC statuses 1076 - 1100 ***************************/
+
+#define XST_IIC_SELFTEST_FAILED         1076	/*!< self test failed            */
+#define XST_IIC_BUS_BUSY                1077	/*!< bus found busy              */
+#define XST_IIC_GENERAL_CALL_ADDRESS    1078	/*!< mastersend attempted with   */
+					     /* general call address        */
+#define XST_IIC_STAND_REG_RESET_ERROR   1079	/*!< A non parameterizable reg   */
+					     /* value after reset not valid */
+#define XST_IIC_TX_FIFO_REG_RESET_ERROR 1080	/*!< Tx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_RX_FIFO_REG_RESET_ERROR 1081	/*!< Rx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_TBA_REG_RESET_ERROR     1082	/*!< 10 bit addr incl in design  */
+					     /* value after reset not valid */
+#define XST_IIC_CR_READBACK_ERROR       1083	/*!< Read of the control register */
+					     /* didn't return value written */
+#define XST_IIC_DTR_READBACK_ERROR      1084	/*!< Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_DRR_READBACK_ERROR      1085	/*!< Read of the data Receive reg */
+					     /* didn't return value written */
+#define XST_IIC_ADR_READBACK_ERROR      1086	/*!< Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_TBA_READBACK_ERROR      1087	/*!< Read of the 10 bit addr reg */
+					     /* didn't return written value */
+#define XST_IIC_NOT_SLAVE               1088	/*!< The device isn't a slave    */
+/** @} */
+/**
+@name ATMC Status Codes 1101 - 1125
+@{
+*/
+/*********************** ATMC statuses 1101 - 1125 ***************************/
+
+#define XST_ATMC_ERROR_COUNT_MAX    1101L	/*!< the error counters in the ATM
+						   controller hit the max value
+						   which requires the statistics
+						   to be cleared */
+/** @} */
+/**
+@name Flash Status Codes 1126 - 1150
+@{
+*/
+/*********************** Flash statuses 1126 - 1150 **************************/
+
+#define XST_FLASH_BUSY                1126L	/*!< Flash is erasing or programming
+						 */
+#define XST_FLASH_READY               1127L	/*!< Flash is ready for commands */
+#define XST_FLASH_ERROR               1128L	/*!< Flash had detected an internal
+						   error. Use XFlash_DeviceControl
+						   to retrieve device specific codes
+						 */
+#define XST_FLASH_ERASE_SUSPENDED     1129L	/*!< Flash is in suspended erase state
+						 */
+#define XST_FLASH_WRITE_SUSPENDED     1130L	/*!< Flash is in suspended write state
+						 */
+#define XST_FLASH_PART_NOT_SUPPORTED  1131L	/*!< Flash type not supported by
+						   driver */
+#define XST_FLASH_NOT_SUPPORTED       1132L	/*!< Operation not supported */
+#define XST_FLASH_TOO_MANY_REGIONS    1133L	/*!< Too many erase regions */
+#define XST_FLASH_TIMEOUT_ERROR       1134L	/*!< Programming or erase operation
+						   aborted due to a timeout */
+#define XST_FLASH_ADDRESS_ERROR       1135L	/*!< Accessed flash outside its
+						   addressible range */
+#define XST_FLASH_ALIGNMENT_ERROR     1136L	/*!< Write alignment error */
+#define XST_FLASH_BLOCKING_CALL_ERROR 1137L	/*!< Couldn't return immediately from
+						   write/erase function with
+						   XFL_NON_BLOCKING_WRITE/ERASE
+						   option cleared */
+#define XST_FLASH_CFI_QUERY_ERROR     1138L	/*!< Failed to query the device */
+/** @} */
+/**
+@name SPI Status Codes 1151 - 1175
+@{
+*/
+/*********************** SPI statuses 1151 - 1175 ****************************/
+
+#define XST_SPI_MODE_FAULT          1151	/*!< master was selected as slave */
+#define XST_SPI_TRANSFER_DONE       1152	/*!< data transfer is complete */
+#define XST_SPI_TRANSMIT_UNDERRUN   1153	/*!< slave underruns transmit register */
+#define XST_SPI_RECEIVE_OVERRUN     1154	/*!< device overruns receive register */
+#define XST_SPI_NO_SLAVE            1155	/*!< no slave has been selected yet */
+#define XST_SPI_TOO_MANY_SLAVES     1156	/*!< more than one slave is being
+						 * selected */
+#define XST_SPI_NOT_MASTER          1157	/*!< operation is valid only as master */
+#define XST_SPI_SLAVE_ONLY          1158	/*!< device is configured as slave-only
+						 */
+#define XST_SPI_SLAVE_MODE_FAULT    1159	/*!< slave was selected while disabled */
+#define XST_SPI_SLAVE_MODE          1160	/*!< device has been addressed as slave */
+#define XST_SPI_RECEIVE_NOT_EMPTY   1161	/*!< device received data in slave mode */
+
+#define XST_SPI_COMMAND_ERROR       1162	/*!< unrecognised command - qspi only */
+#define XST_SPI_POLL_DONE           1163        /*!< controller completed polling the
+						   device for status */
+/** @} */
+/**
+@name OPB Arbiter Status Codes 1176 - 1200
+@{
+*/
+/********************** OPB Arbiter statuses 1176 - 1200 *********************/
+
+#define XST_OPBARB_INVALID_PRIORITY  1176	/*!< the priority registers have either
+						 * one master assigned to two or more
+						 * priorities, or one master not
+						 * assigned to any priority
+						 */
+#define XST_OPBARB_NOT_SUSPENDED     1177	/*!< an attempt was made to modify the
+						 * priority levels without first
+						 * suspending the use of priority
+						 * levels
+						 */
+#define XST_OPBARB_PARK_NOT_ENABLED  1178	/*!< bus parking by id was enabled but
+						 * bus parking was not enabled
+						 */
+#define XST_OPBARB_NOT_FIXED_PRIORITY 1179	/*!< the arbiter must be in fixed
+						 * priority mode to allow the
+						 * priorities to be changed
+						 */
+/** @} */
+/**
+@name INTC Status Codes 1201 - 1225
+@{
+*/
+/************************ Intc statuses 1201 - 1225 **************************/
+
+#define XST_INTC_FAIL_SELFTEST      1201	/*!< self test failed */
+#define XST_INTC_CONNECT_ERROR      1202	/*!< interrupt already in use */
+/** @} */
+/**
+@name TmrCtr Status Codes 1226 - 1250
+@{
+*/
+/********************** TmrCtr statuses 1226 - 1250 **************************/
+
+#define XST_TMRCTR_TIMER_FAILED     1226	/*!< self test failed */
+/** @} */
+/**
+@name WdtTb Status Codes 1251 - 1275
+@{
+*/
+/********************** WdtTb statuses 1251 - 1275 ***************************/
+
+#define XST_WDTTB_TIMER_FAILED      1251L
+/** @} */
+/**
+@name PlbArb status Codes 1276 - 1300
+@{
+*/
+/********************** PlbArb statuses 1276 - 1300 **************************/
+
+#define XST_PLBARB_FAIL_SELFTEST    1276L
+/** @} */
+/**
+@name Plb2Opb Status Codes 1301 - 1325
+@{
+*/
+/********************** Plb2Opb statuses 1301 - 1325 *************************/
+
+#define XST_PLB2OPB_FAIL_SELFTEST   1301L
+/** @} */
+/**
+@name Opb2Plb Status 1326 - 1350
+@{
+*/
+/********************** Opb2Plb statuses 1326 - 1350 *************************/
+
+#define XST_OPB2PLB_FAIL_SELFTEST   1326L
+/** @} */
+/**
+@name SysAce Status Codes 1351 - 1360
+@{
+*/
+/********************** SysAce statuses 1351 - 1360 **************************/
+
+#define XST_SYSACE_NO_LOCK          1351L	/*!< No MPU lock has been granted */
+/** @} */
+/**
+@name PCI Bridge Status Codes 1361 - 1375
+@{
+*/
+/********************** PCI Bridge statuses 1361 - 1375 **********************/
+
+#define XST_PCI_INVALID_ADDRESS     1361L
+/** @} */
+/**
+@name FlexRay Constants 1400 - 1409
+@{
+*/
+/********************** FlexRay constants 1400 - 1409 *************************/
+
+#define XST_FR_TX_ERROR			1400
+#define XST_FR_TX_BUSY			1401
+#define XST_FR_BUF_LOCKED		1402
+#define XST_FR_NO_BUF			1403
+/** @} */
+/**
+@name USB constants 1410 - 1420
+@{
+*/
+/****************** USB constants 1410 - 1420  *******************************/
+
+#define XST_USB_ALREADY_CONFIGURED	1410
+#define XST_USB_BUF_ALIGN_ERROR		1411
+#define XST_USB_NO_DESC_AVAILABLE	1412
+#define XST_USB_BUF_TOO_BIG		1413
+#define XST_USB_NO_BUF			1414
+/** @} */
+/**
+@name HWICAP constants 1421 - 1429
+@{
+*/
+/****************** HWICAP constants 1421 - 1429  *****************************/
+
+#define XST_HWICAP_WRITE_DONE		1421
+
+/** @} */
+/**
+@name AXI VDMA constants 1430 - 1440
+@{
+*/
+/****************** AXI VDMA constants 1430 - 1440  *****************************/
+
+#define XST_VDMA_MISMATCH_ERROR		1430
+/** @} */
+/**
+@name NAND Flash Status Codes 1441 - 1459
+@{
+*/
+/*********************** NAND Flash statuses 1441 - 1459  *********************/
+
+#define XST_NAND_BUSY			1441L	/*!< Flash is erasing or
+						 * programming
+						 */
+#define XST_NAND_READY			1442L	/*!< Flash is ready for commands
+						 */
+#define XST_NAND_ERROR			1443L	/*!< Flash had detected an
+						 * internal error.
+						 */
+#define XST_NAND_PART_NOT_SUPPORTED	1444L	/*!< Flash type not supported by
+						 * driver
+						 */
+#define XST_NAND_OPT_NOT_SUPPORTED	1445L	/*!< Operation not supported
+						 */
+#define XST_NAND_TIMEOUT_ERROR		1446L	/*!< Programming or erase
+						 * operation aborted due to a
+						 * timeout
+						 */
+#define XST_NAND_ADDRESS_ERROR		1447L	/*!< Accessed flash outside its
+						 * addressible range
+						 */
+#define XST_NAND_ALIGNMENT_ERROR	1448L	/*!< Write alignment error
+						 */
+#define XST_NAND_PARAM_PAGE_ERROR	1449L	/*!< Failed to read parameter
+						 * page of the device
+						 */
+#define XST_NAND_CACHE_ERROR		1450L	/*!< Flash page buffer error
+						 */
+
+#define XST_NAND_WRITE_PROTECTED	1451L	/*!< Flash is write protected
+						 */
+/** @} */
+
+/**************************** Type Definitions *******************************/
+
+typedef s32 XStatus;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
+/**
+* @} End of "addtogroup common_status_codes".
+*/
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.c
new file mode 100644
index 0000000..761538c
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.c
@@ -0,0 +1,1625 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx.c
+*
+* This is the main file for Xilinx HDMI TX core. Please see xv_hdmitx.h for
+* more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.01  yh     15/01/16 Add 3D Support
+* 1.02  MG     09/03/16 Added XV_HdmiTx_SetHdmiMode and XV_HdmiTx_SetDviMode
+* 1.03  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiTx_CfgInitialize
+* 1.04  YH     27/07/16 Remove checking VideoMode<(XVIDC_VM_NUM_SUPPORTED));
+* 1.05  YH     17/08/16 Add XV_HdmiTx_SetAxiClkFreq
+*                       Move XV_HdmiTx_DdcInit to XV_HdmiTx_SetAxiClkFreq
+*                       squash unused variable compiler warning
+* 1.06  MG     07/03/17 Updated XV_HdmiTx_Auxsend with packet ready check
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmitx.h"
+#include "xil_printf.h"
+#include <linux/string.h>
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+/**
+* This table contains the attributes for various standard resolutions.
+* Each entry is of the format:
+* 1) Resolution ID
+* 2) Video Identification Code.
+*/
+static const XV_HdmiTx_VicTable VicTable[34] = {
+    {XVIDC_VM_640x480_60_P, 1},     /**< Vic 1   */
+    {XVIDC_VM_720x480_60_P, 2},     /**< Vic 2   */
+    {XVIDC_VM_1280x720_60_P, 4},    /**< Vic 4   */
+    {XVIDC_VM_1920x1080_60_I, 5},   /**< Vic 5   */
+    {XVIDC_VM_1440x480_60_I, 6},    /**< Vic 6   */
+    {XVIDC_VM_720x576_50_P, 17},    /**< Vic 17  */
+    {XVIDC_VM_1280x720_50_P, 19},   /**< Vic 19  */
+    {XVIDC_VM_1920x1080_50_I, 20},  /**< Vic 20  */
+    {XVIDC_VM_1440x576_50_I, 21},   /**< Vic 21  */
+
+    /**< 1680 x 720 */
+    {XVIDC_VM_1680x720_50_P, 82},   /**< Vic 82  */
+    {XVIDC_VM_1680x720_60_P, 83},   /**< Vic 83  */
+    {XVIDC_VM_1680x720_100_P, 84},  /**< Vic 84  */
+    {XVIDC_VM_1680x720_120_P, 85},  /**< Vic 85  */
+
+    /**< 1920 x 1080 */
+    {XVIDC_VM_1920x1080_24_P, 32},  /**< Vic 32  */
+    {XVIDC_VM_1920x1080_25_P, 33},  /**< Vic 33  */
+    {XVIDC_VM_1920x1080_30_P, 34},  /**< Vic 34  */
+    {XVIDC_VM_1920x1080_50_P, 31},  /**< Vic 31  */
+    {XVIDC_VM_1920x1080_60_P, 16},  /**< Vic 16  */
+    {XVIDC_VM_1920x1080_100_P, 64}, /**< Vic 64  */
+    {XVIDC_VM_1920x1080_120_P, 63}, /**< Vic 63  */
+
+    /**< 2560 x 1080 */
+    {XVIDC_VM_2560x1080_50_P, 89},  /**< Vic 89  */
+    {XVIDC_VM_2560x1080_60_P, 90},  /**< Vic 89  */
+    {XVIDC_VM_2560x1080_100_P, 91}, /**< Vic 91  */
+    {XVIDC_VM_2560x1080_120_P, 92}, /**< Vic 92  */
+
+    /**< 3840 x 2160 */
+    {XVIDC_VM_3840x2160_24_P, 93},  /**< Vic 93  */
+    {XVIDC_VM_3840x2160_25_P, 94},  /**< Vic 94  */
+    {XVIDC_VM_3840x2160_30_P, 95},  /**< Vic 95  */
+    {XVIDC_VM_3840x2160_50_P, 96},  /**< Vic 96  */
+    {XVIDC_VM_3840x2160_60_P, 97},  /**< Vic 97  */
+
+    /**< 4096 x 2160 */
+    {XVIDC_VM_4096x2160_24_P, 98},  /**< Vic 98  */
+    {XVIDC_VM_4096x2160_25_P, 99},  /**< Vic 99  */
+    {XVIDC_VM_4096x2160_30_P, 100}, /**< Vic 100 */
+    {XVIDC_VM_4096x2160_50_P, 101}, /**< Vic 101 */
+    {XVIDC_VM_4096x2160_60_P, 102}  /**< Vic 102 */
+};
+
+/************************** Function Prototypes ******************************/
+
+static void StubCallback(void *Callback);
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function initializes the HDMI TX core. This function must be called
+* prior to using the HDMI TX core. Initialization of the HDMI TX includes
+* setting up the instance data and ensuring the hardware is in a quiescent
+* state.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    CfgPtr points to the configuration structure associated with
+*       the HDMI TX core.
+* @param    EffectiveAddr is the base address of the device. If address
+*       translation is being used, then this parameter must reflect the
+*       virtual base address. Otherwise, the physical address should be
+*       used.
+*
+* @return
+*       - XST_SUCCESS if XV_HdmiTx_CfgInitialize was successful.
+*       - XST_FAILURE if HDMI TX PIO ID mismatched.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_CfgInitialize(XV_HdmiTx *InstancePtr, XV_HdmiTx_Config *CfgPtr,
+    UINTPTR EffectiveAddr)
+{
+    u32 RegValue;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(CfgPtr != NULL);
+    Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)0x0);
+
+    /* Setup the instance */
+    (void)memset((void *)InstancePtr, 0, sizeof(XV_HdmiTx));
+    (void)memcpy((void *)&(InstancePtr->Config), (const void *)CfgPtr,
+        sizeof(XV_HdmiTx_Config));
+    InstancePtr->Config.BaseAddress = EffectiveAddr;
+
+    /* Set all handlers to stub values, let user configure this data later */
+    InstancePtr->ConnectCallback = (XV_HdmiTx_Callback)((void *)StubCallback);
+    InstancePtr->IsConnectCallbackSet = (FALSE);
+
+    InstancePtr->ToggleCallback = (XV_HdmiTx_Callback)((void *)StubCallback);
+    InstancePtr->IsToggleCallbackSet = (FALSE);
+
+    InstancePtr->VsCallback = (XV_HdmiTx_Callback)((void *)StubCallback);
+    InstancePtr->IsVsCallbackSet = (FALSE);
+
+    InstancePtr->StreamDownCallback =(XV_HdmiTx_Callback)((void *)StubCallback);
+    InstancePtr->IsStreamDownCallbackSet = (FALSE);
+
+    InstancePtr->StreamUpCallback = (XV_HdmiTx_Callback)((void *)StubCallback);
+    InstancePtr->IsStreamUpCallbackSet = (FALSE);
+
+    /* Clear HDMI variables */
+    XV_HdmiTx_Clear(InstancePtr);
+
+    // Set stream status
+    InstancePtr->Stream.State = XV_HDMITX_STATE_STREAM_DOWN;
+    // The stream is down
+
+    // Clear connected flag
+    InstancePtr->Stream.IsConnected = (FALSE);
+
+    /* Reset all peripherals */
+    XV_HdmiTx_PioDisable(InstancePtr);
+    XV_HdmiTx_DdcDisable(InstancePtr);
+    XV_HdmiTx_AudioDisable(InstancePtr);
+    XV_HdmiTx_AuxDisable(InstancePtr);
+
+    XV_HdmiTx_PioIntrClear(InstancePtr);
+    XV_HdmiTx_DdcIntrClear(InstancePtr);
+
+    /* Read PIO peripheral Identification register */
+    RegValue = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+    (XV_HDMITX_PIO_ID_OFFSET));
+
+    RegValue = ((RegValue) >> (XV_HDMITX_SHIFT_16)) &
+    (XV_HDMITX_MASK_16);
+    if (RegValue != (XV_HDMITX_PIO_ID)) {
+        return (XST_FAILURE);
+    }
+
+    /* PIO: Set event rising edge masks */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+    (XV_HDMITX_PIO_IN_EVT_RE_OFFSET),
+            (XV_HDMITX_PIO_IN_HPD_TOGGLE_MASK) |
+            (XV_HDMITX_PIO_IN_HPD_MASK) |
+            (XV_HDMITX_PIO_IN_VS_MASK) |
+            (XV_HDMITX_PIO_IN_LNK_RDY_MASK)
+        );
+
+    /* PIO: Set event falling edge masks */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+    (XV_HDMITX_PIO_IN_EVT_FE_OFFSET),
+            (XV_HDMITX_PIO_IN_HPD_MASK) |
+            (XV_HDMITX_PIO_IN_LNK_RDY_MASK)
+        );
+
+    /* Enable the PIO peripheral interrupt */
+    XV_HdmiTx_PioIntrEnable(InstancePtr);
+
+    /* Enable the PIO peripheral */
+    XV_HdmiTx_PioEnable(InstancePtr);
+
+    /* Set HDMI mode */
+    XV_HdmiTx_SetHdmiMode(InstancePtr);
+
+    /* Enable the AUX peripheral */
+    /* The aux peripheral is enabled at stream up */
+    //XV_HdmiTx_AuxEnable(InstancePtr);
+
+    /* Enable audio */
+    /* The audio peripheral is enabled at stream up */
+    //XV_HdmiTx_AudioEnable(InstancePtr);
+
+    /* Reset the hardware and set the flag to indicate the driver is ready */
+    InstancePtr->IsReady = (u32)(XIL_COMPONENT_IS_READY);
+
+    return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the AXI4-Lite Clock Frequency
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    ClkFreq specifies the value that needs to be set.
+*
+* @return
+*
+*
+* @note     This is required after a reset or init.
+*
+******************************************************************************/
+void XV_HdmiTx_SetAxiClkFreq(XV_HdmiTx *InstancePtr, u32 ClkFreq)
+{
+	InstancePtr->CpuClkFreq = ClkFreq;
+
+    /* Initialize DDC */
+    XV_HdmiTx_DdcInit(InstancePtr, InstancePtr->CpuClkFreq);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the core into HDMI mode.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*
+*
+* @note     This is required after a reset or init.
+*
+******************************************************************************/
+void XV_HdmiTx_SetHdmiMode(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Set mode bit in core */
+    XV_HdmiTx_SetMode(InstancePtr);
+
+    /* Set flag in structure */
+    InstancePtr->Stream.IsHdmi = TRUE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the core into DVI mode.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*
+*
+* @note     This is required after a reset or init.
+*
+******************************************************************************/
+void XV_HdmiTx_SetDviMode(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Disable audio peripheral */
+    XV_HdmiTx_AudioDisable(InstancePtr);
+
+    /* Disable aux peripheral */
+    XV_HdmiTx_AuxDisable(InstancePtr);
+
+    /* Clear mode bit in core */
+    XV_HdmiTx_ClearMode(InstancePtr);
+
+    /* Clear flag in structure */
+    InstancePtr->Stream.IsHdmi = FALSE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function clear the HDMI TX variables and sets it to the defaults.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*
+*
+* @note     This is required after a reset or init.
+*
+******************************************************************************/
+void XV_HdmiTx_Clear(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides video identification code of video mode.
+*
+* @param    VideoMode specifies resolution identifier.
+*
+* @return   Video identification code defined in the VIC table.
+*
+* @note     None.
+*
+******************************************************************************/
+u8 XV_HdmiTx_LookupVic(XVidC_VideoMode VideoMode)
+{
+    XV_HdmiTx_VicTable const *Entry;
+    u8 Index;
+
+    for (Index = 0; Index < sizeof(VicTable)/sizeof(XV_HdmiTx_VicTable);
+        Index++) {
+      Entry = &VicTable[Index];
+      if (Entry->VmId == VideoMode)
+        return (Entry->Vic);
+    }
+    return 0;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function controls the scrambler
+*
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - XST_SUCCESS if HDMI 2.0
+*       - XST_FAILURE if HDMI 1.4
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_Scrambler(XV_HdmiTx *InstancePtr) {
+    u8 DdcBuf[2];
+    u32 Status;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Check scrambler flag
+    if (InstancePtr->Stream.IsScrambled) {
+
+        // Check if the sink is HDMI 2.0
+        if (InstancePtr->Stream.IsHdmi20) {
+            XV_HdmiTx_SetScrambler(InstancePtr, (TRUE));
+        }
+        else {
+            XV_HdmiTx_SetScrambler(InstancePtr, (FALSE));
+        }
+    }
+
+    // Clear
+    else
+        XV_HdmiTx_SetScrambler(InstancePtr, (FALSE));
+
+    // Update TMDS configuration
+    // Only when it is a HDMI 2.0 sink device
+    if (InstancePtr->Stream.IsHdmi20) {
+
+        DdcBuf[0] = 0x20;   // Offset scrambler status
+        Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1,
+        (u8*)&DdcBuf, (FALSE));
+
+        // Check if write was successful
+        if (Status == (XST_SUCCESS)) {
+
+            // Read TMDS configuration
+            Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1,
+            (u8*)&DdcBuf, (TRUE));
+
+            // The result is in ddc_buf[0]
+            // Clear scrambling enable bit
+            DdcBuf[0] &= 0xfe;
+
+            // Set scrambler bit if scrambler is enabled
+            if (InstancePtr->Stream.IsScrambled)
+                DdcBuf[0] |= 0x01;
+
+            // Copy buf[0] to buf[1]
+            DdcBuf[1] = DdcBuf[0];
+
+            // Offset
+            DdcBuf[0] = 0x20;   // Offset scrambler status
+
+            // Write back TMDS configuration
+            Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 2,
+            (u8*)&DdcBuf, (TRUE));
+        }
+
+        // Write failed
+        else {
+            return XST_FAILURE;
+        }
+    }
+    return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function controls the TMDS clock ratio
+*
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - XST_SUCCESS if HDMI 2.0
+*       - XST_FAILURE if HDMI 1.4
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_ClockRatio(XV_HdmiTx *InstancePtr) {
+    u8 DdcBuf[2];
+    u32 Status;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Update TMDS configuration
+    // Only when it is a HDMI 2.0 sink device
+    if (InstancePtr->Stream.IsHdmi20) {
+
+        DdcBuf[0] = 0x20;   // Offset scrambler status
+        Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (FALSE));
+
+        // Check if write was successful
+        if (Status == (XST_SUCCESS)) {
+
+            // Read TMDS configuration
+            Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1,
+                (u8*)&DdcBuf, (TRUE));
+
+            // The result is in ddc_buf[0]
+            // Clear TMDS clock ration bit (1)
+            DdcBuf[0] &= 0xfd;
+
+            /* Set the TMDS clock ratio bit if the bandwidth is
+                higher than 3.4 Gbps */
+            if (InstancePtr->Stream.TMDSClockRatio) {
+                DdcBuf[0] |= 0x02;
+            }
+
+            // Copy buf[0] to buf[1]
+            DdcBuf[1] = DdcBuf[0];
+
+            // Offset
+            DdcBuf[0] = 0x20;   // Offset scrambler status
+
+            // Write back TMDS configuration
+            Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 2,
+                (u8*)&DdcBuf, (TRUE));
+        }
+    return XST_SUCCESS;
+    }
+    return XST_FAILURE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function detects connected sink is a HDMI 2.0/HDMI 1.4 sink device
+* and sets appropriate flag in the TX stream.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - XST_SUCCESS if HDMI 2.0
+*       - XST_FAILURE if HDMI 1.4
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_DetectHdmi20(XV_HdmiTx *InstancePtr)
+{
+    u8 DdcBuf[2];
+    u32 Status;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Write source version. Offset (Source version) */
+    DdcBuf[0] = 0x02;
+
+    /* Version 1 */
+    DdcBuf[1] = 0x01;
+    Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 2, (u8*)&DdcBuf, (TRUE));
+
+    /* If the write was successful, then the sink is HDMI 2.0 */
+    if (Status == (XST_SUCCESS)) {
+        InstancePtr->Stream.IsHdmi20 = (TRUE);
+        Status = (XST_SUCCESS);
+    }
+
+    /* Else it is a HDMI 1.4 device */
+    else {
+        InstancePtr->Stream.IsHdmi20 = (FALSE);
+        Status = (XST_FAILURE);
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function shows the sinks SCDC registers.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_ShowSCDC(XV_HdmiTx *InstancePtr)
+{
+    u8 DdcBuf[2];
+    u32 Status;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Sink version. Offset Scrambler status */
+    DdcBuf[0] = 0x01;
+    Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (FALSE));
+
+    /* Check if write was successful */
+    if (Status == (XST_SUCCESS)) {
+        Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (TRUE));
+        xil_printf("HDMI TX: SCDC 0x01 : %0x\r\n", DdcBuf[0]);
+    }
+
+    /* TMDS configuration. Offset Scrambler status */
+    DdcBuf[0] = 0x20;
+    Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (FALSE));
+
+    /* Check if write was successful */
+    if (Status == (XST_SUCCESS)) {
+        Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (TRUE));
+        xil_printf("HDMI TX: SCDC 0x20 : %0x\r\n", DdcBuf[0]);
+    }
+
+    /* Scrambler status. Offset Scrambler status */
+    DdcBuf[0] = 0x21;
+    Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (FALSE));
+
+    /* Check if write was successful */
+    if (Status == (XST_SUCCESS)) {
+        Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (TRUE));
+        xil_printf("HDMI TX: SCDC 0x21 : %0x\r\n", DdcBuf[0]);
+    }
+
+    /* Status flags. Offset Scrambler status */
+    DdcBuf[0] = 0x40;
+    Status = XV_HdmiTx_DdcWrite(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (FALSE));
+
+    /* Check if write was successful */
+    if (Status == (XST_SUCCESS)) {
+        Status = XV_HdmiTx_DdcRead(InstancePtr, 0x54, 1, (u8*)&DdcBuf, (TRUE));
+        xil_printf("HDMI TX: SCDC 0x40 : %0x\r\n", DdcBuf[0]);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the HDMI TX stream parameters.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    VideoMode specifies resolution identifier.
+* @param    ColorFormat specifies the type of color format.
+*       - 0 = XVIDC_CSF_RGB
+*       - 1 = XVIDC_CSF_YCRCB_444
+*       - 2 = XVIDC_CSF_YCRCB_422
+*       - 3 = XVIDC_CSF_YCRCB_420
+* @param    Bpc specifies the color depth/bits per color component.
+*       - 6 = XVIDC_BPC_6
+*       - 8 = XVIDC_BPC_8
+*       - 10 = XVIDC_BPC_10
+*       - 12 = XVIDC_BPC_12
+*       - 16 = XVIDC_BPC_16
+* @param    Ppc specifies the pixel per clock.
+*       - 1 = XVIDC_PPC_1
+*       - 2 = XVIDC_PPC_2
+*       - 4 = XVIDC_PPC_4
+*
+* @return   TmdsClock, reference clock calculated based on the input
+*       parameters.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiTx_SetStream(XV_HdmiTx *InstancePtr, XVidC_VideoMode VideoMode,
+XVidC_ColorFormat ColorFormat, XVidC_ColorDepth Bpc, XVidC_PixelsPerClock Ppc,
+XVidC_3DInfo *Info3D)
+{
+    u32 TmdsClock;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid((ColorFormat == (XVIDC_CSF_RGB))       ||
+                      (ColorFormat == (XVIDC_CSF_YCRCB_444)) ||
+                      (ColorFormat == (XVIDC_CSF_YCRCB_422)) ||
+                      (ColorFormat == (XVIDC_CSF_YCRCB_420)));
+    Xil_AssertNonvoid((Bpc == (XVIDC_BPC_8))  ||
+                      (Bpc == (XVIDC_BPC_10)) ||
+                      (Bpc == (XVIDC_BPC_12)) ||
+                      (Bpc == (XVIDC_BPC_16)));
+    Xil_AssertNonvoid((Ppc == (XVIDC_PPC_1)) ||
+                      (Ppc == (XVIDC_PPC_2)) ||
+                      (Ppc == (XVIDC_PPC_4)));
+
+    if(Info3D == NULL)
+        XVidC_SetVideoStream(&InstancePtr->Stream.Video, VideoMode, ColorFormat, Bpc, Ppc);
+    else
+        XVidC_Set3DVideoStream(&InstancePtr->Stream.Video, VideoMode, ColorFormat, Bpc, Ppc, Info3D);
+
+    /** In HDMI the colordepth in YUV422 is always 12 bits,
+    * although on the link itself it is being transmitted as 8-bits.
+    * Therefore if the colorspace is YUV422, then force the colordepth
+    * to 12 bits. */
+    if (ColorFormat == XVIDC_CSF_YCRCB_422) {
+        InstancePtr->Stream.Video.ColorDepth = XVIDC_BPC_12;
+    }
+
+    InstancePtr->Stream.Vic = XV_HdmiTx_LookupVic(
+        InstancePtr->Stream.Video.VmId);
+
+    // Set TX pixel rate
+    XV_HdmiTx_SetPixelRate(InstancePtr);
+
+    // Set TX color space
+    XV_HdmiTx_SetColorFormat(InstancePtr);
+
+    // Set TX color depth
+    XV_HdmiTx_SetColorDepth(InstancePtr);
+
+    /* Calculate reference clock. First calculate the pixel clock */
+    if (InstancePtr->Stream.Video.VmId != XVIDC_VM_CUSTOM) {
+    TmdsClock = XVidC_GetPixelClockHzByVmId(InstancePtr->Stream.Video.VmId);
+    } else {
+      TmdsClock = XVidC_GetPixelClockHzByHVFr(InstancePtr->Stream.Video.Timing.HTotal,
+                                              InstancePtr->Stream.Video.Timing.F0PVTotal,
+                                              InstancePtr->Stream.Video.FrameRate);
+    }
+
+    /* Store the pixel clock in the structure */
+    InstancePtr->Stream.PixelClk = TmdsClock;
+
+    /* YUV420 */
+    if (ColorFormat == (XVIDC_CSF_YCRCB_420)) {
+        /* In YUV420 the tmds clock is divided by two*/
+        TmdsClock = TmdsClock / 2;
+    }
+
+    /* RGB, YUV444 and YUV420 */
+    if ( ColorFormat != XVIDC_CSF_YCRCB_422 ) {
+
+        switch (Bpc) {
+
+            // 10-bits
+            case XVIDC_BPC_10 :
+                TmdsClock = TmdsClock * 5 / 4;
+                break;
+
+            // 12-bits
+            case XVIDC_BPC_12 :
+                TmdsClock = TmdsClock * 3 / 2;
+                break;
+
+            // 16-bits
+            case XVIDC_BPC_16 :
+                TmdsClock = TmdsClock * 2;
+                break;
+
+            // 8-bits
+            default:
+                TmdsClock = TmdsClock;
+                break;
+        }
+    }
+
+    /* Store TMDS clock for future reference */
+    InstancePtr->Stream.TMDSClock = TmdsClock;
+
+    /* HDMI 2.0 */
+    if (InstancePtr->Stream.IsHdmi20) {
+        if (TmdsClock > 340000000) {
+            InstancePtr->Stream.IsScrambled = (TRUE);
+            InstancePtr->Stream.TMDSClockRatio  = 1;
+        }
+        else {
+            InstancePtr->Stream.IsScrambled = (FALSE);
+            InstancePtr->Stream.TMDSClockRatio  = 0;
+        }
+    }
+
+    /* HDMI 1.4 */
+    else {
+        InstancePtr->Stream.IsScrambled = (FALSE);
+        InstancePtr->Stream.TMDSClockRatio  = 0;
+    }
+
+    XV_HdmiTx_Scrambler(InstancePtr);
+    XV_HdmiTx_ClockRatio(InstancePtr);
+
+    if ((InstancePtr->Stream.IsHdmi20 == (FALSE)) && (TmdsClock > 340000000)) {
+        TmdsClock = 0;
+    }
+
+    return TmdsClock;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the pixel rate at output.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_SetPixelRate(XV_HdmiTx *InstancePtr)
+{
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Mask PIO Out Mask register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_MSK_OFFSET),
+        (XV_HDMITX_PIO_OUT_PIXEL_RATE_MASK));
+
+    /* Check for pixel width */
+    switch (InstancePtr->Stream.Video.PixPerClk) {
+
+        case (XVIDC_PPC_2):
+            RegValue = 1;
+            break;
+
+        case (XVIDC_PPC_4):
+            RegValue = 2;
+            break;
+
+        default:
+            RegValue = 0;
+            break;
+    }
+
+    /* Write pixel rate into PIO Out register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_OFFSET),
+        (RegValue << (XV_HDMITX_PIO_OUT_PIXEL_RATE_SHIFT)));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the sample rate at output.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    SampleRate specifies the value that needs to be set.
+*       - 3 samples per clock.
+*       - 5 samples per clock.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_SetSampleRate(XV_HdmiTx *InstancePtr, u8 SampleRate)
+{
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+    Xil_AssertVoid(SampleRate < 0xFF);
+
+    // Store sample rate in structure
+    InstancePtr->Stream.SampleRate = SampleRate;
+
+    // Mask PIO Out Mask register
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_MSK_OFFSET),
+        (XV_HDMITX_PIO_OUT_SAMPLE_RATE_MASK));
+
+    // Check for sample rate
+    switch (SampleRate) {
+        case 3:
+            RegValue = 1;
+            break;
+
+        case 4:
+            RegValue = 2;
+            break;
+
+        case 5:
+            RegValue = 3;
+            break;
+
+        default:
+            RegValue = 0;
+            break;
+    }
+
+    // Write sample rate into PIO Out register
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_OFFSET),
+        (RegValue << (XV_HDMITX_PIO_OUT_SAMPLE_RATE_SHIFT)));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the color format
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_SetColorFormat(XV_HdmiTx *InstancePtr)
+{
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Mask PIO Out Mask register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_MSK_OFFSET),
+        (XV_HDMITX_PIO_OUT_COLOR_SPACE_MASK));
+
+    /* Check for color format */
+    switch (InstancePtr->Stream.Video.ColorFormatId) {
+        case (XVIDC_CSF_YCRCB_444):
+            RegValue = 1;
+            break;
+
+        case (XVIDC_CSF_YCRCB_422):
+            RegValue = 2;
+            break;
+
+        case (XVIDC_CSF_YCRCB_420):
+            RegValue = 3;
+            break;
+
+        default:
+            RegValue = 0;
+            break;
+    }
+
+    /* Write color space into PIO Out register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_OFFSET),
+        (RegValue << (XV_HDMITX_PIO_OUT_COLOR_SPACE_SHIFT)));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the color depth
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_SetColorDepth(XV_HdmiTx *InstancePtr)
+{
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Mask PIO Out Mask register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_MSK_OFFSET), (XV_HDMITX_PIO_OUT_COLOR_DEPTH_MASK));
+
+    // Color depth
+    switch (InstancePtr->Stream.Video.ColorDepth) {
+        // 10 bits
+        case (XVIDC_BPC_10):
+            RegValue = 1;
+            break;
+
+        // 12 bits
+        case (XVIDC_BPC_12):
+            RegValue = 2;
+            break;
+
+        // 16 bits
+        case (XVIDC_BPC_16):
+            RegValue = 3;
+            break;
+
+        // 8 bits
+        default:
+            RegValue = 0;
+            break;
+    }
+
+    /* Write color depth into PIO Out register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_PIO_OUT_OFFSET),
+        (RegValue << (XV_HDMITX_PIO_OUT_COLOR_DEPTH_SHIFT)));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prepares TX DDC peripheral to use.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    Frequency specifies the value that needs to be set.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_DdcInit(XV_HdmiTx *InstancePtr, u32 Frequency)
+{
+    u32 RegValue;
+
+    /* Verify arguments. */
+    Xil_AssertVoid(InstancePtr != NULL);
+    Xil_AssertVoid(Frequency > 0x0);
+
+    RegValue = (Frequency / 100000) / 2;
+    RegValue = ((RegValue) << (XV_HDMITX_DDC_CTRL_CLK_DIV_SHIFT)) &
+     ((XV_HDMITX_DDC_CTRL_CLK_DIV_MASK) << (XV_HDMITX_DDC_CTRL_CLK_DIV_SHIFT));
+
+    /* Update DDC Control register */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_DDC_CTRL_OFFSET), RegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the acknowledge flag
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_DdcGetAck(XV_HdmiTx *InstancePtr)
+{
+    u32 Status;
+
+    // Read status register
+    Status = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_DDC_STA_OFFSET));
+    return (Status & XV_HDMITX_DDC_STA_ACK_MASK);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function waits for the done flag to be set
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_DdcWaitForDone(XV_HdmiTx *InstancePtr)
+{
+    u32 Data;
+    u32 Status;
+    u32 Exit;
+
+    Exit = (FALSE);
+
+    // Default status, assume failure
+    Status = XST_FAILURE;
+
+    do {
+        // Read control register
+        Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+            (XV_HDMITX_DDC_CTRL_OFFSET));
+
+        if (Data & (XV_HDMITX_DDC_CTRL_RUN_MASK)) {
+
+            // Read status register
+            Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                (XV_HDMITX_DDC_STA_OFFSET));
+
+            // Done
+            if (Data & (XV_HDMITX_DDC_STA_DONE_MASK)) {
+                // Clear done flag
+                XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+                    (XV_HDMITX_DDC_STA_OFFSET), (XV_HDMITX_DDC_STA_DONE_MASK));
+                Exit = (TRUE);
+                Status = XST_SUCCESS;
+            }
+
+            // Time out
+            else if (Data & (XV_HDMITX_DDC_STA_TIMEOUT_MASK)) {
+                // Clear time out flag
+                XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+                    (XV_HDMITX_DDC_STA_OFFSET), (XV_HDMITX_DDC_STA_TIMEOUT_MASK));
+                Exit = (TRUE);
+                Status = XST_FAILURE;
+            }
+        }
+        else {
+            Status = (XST_FAILURE);
+            Exit = (TRUE);
+        }
+
+    } while (!Exit);
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function writes data into the command fifo.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_DdcWriteCommand(XV_HdmiTx *InstancePtr, u32 Cmd)
+{
+    u32 Status;
+    u32 Exit;
+
+    Exit = (FALSE);
+
+    do {
+        // Read control register
+        Status = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+            (XV_HDMITX_DDC_CTRL_OFFSET));
+
+        if (Status & (XV_HDMITX_DDC_CTRL_RUN_MASK)) {
+            // Read status register
+            Status = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                (XV_HDMITX_DDC_STA_OFFSET));
+
+            // Mask command fifo full flag
+            Status &= XV_HDMITX_DDC_STA_CMD_FULL;
+
+            // Check if the command fifo isn't full
+            if (!Status) {
+                XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+                    (XV_HDMITX_DDC_CMD_OFFSET), (Cmd));
+                Exit = (TRUE);
+            }
+        }
+        else {
+            Status = (XST_FAILURE);
+            Exit = (TRUE);
+        }
+    } while (!Exit);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads data from the data fifo.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @note     None.
+*
+******************************************************************************/
+u8 XV_HdmiTx_DdcReadData(XV_HdmiTx *InstancePtr)
+{
+    u32 Status;
+    u32 Exit;
+    u32 Data;
+
+    Exit = (FALSE);
+
+    do {
+        // Read control register
+        Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+            (XV_HDMITX_DDC_CTRL_OFFSET));
+
+        if (Data & (XV_HDMITX_DDC_CTRL_RUN_MASK)) {
+            // Read status register
+            Status = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                (XV_HDMITX_DDC_STA_OFFSET));
+
+            // Mask data fifo empty flag
+            Status &= XV_HDMITX_DDC_STA_DAT_EMPTY;
+
+            // Check if the data fifo has data
+            if (!Status) {
+                Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                    (XV_HDMITX_DDC_DAT_OFFSET));
+                Exit = (TRUE);
+            }
+        }
+        else {
+            Exit = (TRUE);
+            Data = 0;
+        }
+    } while (!Exit);
+
+    return (Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function writes data from DDC peripheral from given slave address.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    Slave specifies the slave address from where data needs to be
+*       read.
+* @param    Length specifies number of bytes to be read.
+* @param    Buffer specifies a pointer to u8 variable that will be
+*       filled with data.
+* @param    Stop specifies the stop flag which is either TRUE/FALSE.
+*
+* @return
+*       - XST_SUCCESS if an acknowledgement received and timeout.
+*       - XST_FAILURE if no acknowledgement received.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_DdcWrite(XV_HdmiTx *InstancePtr, u8 Slave,
+    u16 Length, u8 *Buffer, u8 Stop)
+{
+    u32 Status;
+    u32 Data;
+    u32 Index;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(Slave > 0x0);
+    Xil_AssertNonvoid(Length > 0x0);
+    Xil_AssertNonvoid(Buffer != NULL);
+    Xil_AssertNonvoid((Stop == (TRUE)) || (Stop == (FALSE)));
+
+    // Status default, assume failure
+    Status = XST_FAILURE;
+
+    // Enable DDC peripheral
+    XV_HdmiTx_DdcEnable(InstancePtr);
+
+    // Disable interrupt in DDC peripheral
+    // Polling is used
+    XV_HdmiTx_DdcIntrDisable(InstancePtr);
+
+    // Write start token
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (XV_HDMITX_DDC_CMD_STR_TOKEN));
+
+    // First check if the slave can be addressed
+    // Write write token
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (XV_HDMITX_DDC_CMD_WR_TOKEN));
+
+    // Write length (high)
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, 0);
+
+    // Write length (low)
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, 1);
+
+    // Slave address
+    Data = Slave << 1;
+
+    // Set write bit (low)
+    Data &= 0xFE;
+
+    // Write slave address
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (Data));
+
+    // Wait for done flag
+    if (XV_HdmiTx_DdcWaitForDone(InstancePtr) == XST_SUCCESS) {
+
+        // Check acknowledge
+        if (XV_HdmiTx_DdcGetAck(InstancePtr)) {
+
+            // Now write the data
+            // Write write token
+            XV_HdmiTx_DdcWriteCommand(InstancePtr,
+                (XV_HDMITX_DDC_CMD_WR_TOKEN));
+
+            // Write length (high)
+            Data = ((Length >> 8) & 0xFF);
+            XV_HdmiTx_DdcWriteCommand(InstancePtr, Data);
+
+            // Write length (low)
+            Data = (Length & 0xFF);
+            XV_HdmiTx_DdcWriteCommand(InstancePtr, Data);
+
+            // Write Data
+            for (Index = 0; Index < Length; Index++) {
+                XV_HdmiTx_DdcWriteCommand(InstancePtr, *Buffer++);
+            }
+
+            // Wait for done flag
+            if (XV_HdmiTx_DdcWaitForDone(InstancePtr) == XST_SUCCESS) {
+
+                // Check acknowledge
+                // ACK
+                if (XV_HdmiTx_DdcGetAck(InstancePtr)) {
+
+                    // Stop condition
+                    if (Stop) {
+                        // Write stop token
+                        XV_HdmiTx_DdcWriteCommand(InstancePtr,
+                            (XV_HDMITX_DDC_CMD_STP_TOKEN));
+
+                        // Wait for done flag
+                        XV_HdmiTx_DdcWaitForDone(InstancePtr);
+
+                    }
+
+                // Update status flag
+                Status = XST_SUCCESS;
+                }
+            }
+        }
+    }
+
+    // Disable DDC peripheral
+    XV_HdmiTx_DdcDisable(InstancePtr);
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads data from DDC peripheral from given slave address.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    Slave specifies the slave address from where data needs to be
+*       read.
+* @param    Length specifies number of bytes to be read.
+* @param    Buffer specifies a pointer to u8 variable that will be
+*       filled with data.
+* @param    Stop specifies the stop flag which is either TRUE/FALSE.
+*
+* @return
+*       - XST_SUCCESS if an acknowledgement received and timeout.
+*       - XST_FAILURE if no acknowledgement received.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_DdcRead(XV_HdmiTx *InstancePtr, u8 Slave, u16 Length,
+    u8 *Buffer, u8 Stop)
+{
+    u32 Status;
+    u32 Data;
+    u32 Index;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(Slave > 0x0);
+    Xil_AssertNonvoid(Length > 0x0);
+    Xil_AssertNonvoid(Buffer != NULL);
+    Xil_AssertNonvoid((Stop == (TRUE)) || (Stop == (FALSE)));
+
+    // Status default, assume failure
+    Status = XST_FAILURE;
+
+    // Enable DDC peripheral
+    XV_HdmiTx_DdcEnable(InstancePtr);
+
+    // Disable interrupt in DDC peripheral
+    // Polling is used
+    XV_HdmiTx_DdcIntrDisable(InstancePtr);
+
+    // Write start token
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (XV_HDMITX_DDC_CMD_STR_TOKEN));
+
+    // First check if the slave can be addressed
+    // Write write token
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (XV_HDMITX_DDC_CMD_WR_TOKEN));
+
+    // Write length (high)
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, 0);
+
+    // Write length (low)
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, 1);
+
+    // Slave address
+    Data = Slave << 1;
+
+    // Set read bit (high)
+    Data |= 0x01;
+
+    // Write slave address
+    XV_HdmiTx_DdcWriteCommand(InstancePtr, (Data));
+
+    // Wait for done flag
+    if (XV_HdmiTx_DdcWaitForDone(InstancePtr) == XST_SUCCESS) {
+
+        // Check acknowledge
+        if (XV_HdmiTx_DdcGetAck(InstancePtr)) {
+
+            // Write read token
+            XV_HdmiTx_DdcWriteCommand(InstancePtr,
+                (XV_HDMITX_DDC_CMD_RD_TOKEN));
+
+            // Write read length (high)
+            Data = (Length >> 8) & 0xFF;
+            XV_HdmiTx_DdcWriteCommand(InstancePtr, (Data));
+
+            // Write read length (low)
+            Data = Length & 0xFF;
+            XV_HdmiTx_DdcWriteCommand(InstancePtr, (Data));
+
+            // Read Data
+            for (Index = 0; Index < Length; Index++) {
+                *Buffer++ = XV_HdmiTx_DdcReadData(InstancePtr);
+            }
+
+            // Wait for done flag
+            if (XV_HdmiTx_DdcWaitForDone(InstancePtr) == XST_SUCCESS) {
+
+                // Stop condition
+                if (Stop) {
+                    // Write stop token
+                    XV_HdmiTx_DdcWriteCommand(InstancePtr,
+                        (XV_HDMITX_DDC_CMD_STP_TOKEN));
+
+                    // Wait for done flag
+                    XV_HdmiTx_DdcWaitForDone(InstancePtr);
+
+                }
+
+                // Update status
+                Status = XST_SUCCESS;
+            }
+        }
+    }
+
+    // Disable DDC peripheral
+    XV_HdmiTx_DdcDisable(InstancePtr);
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function transmits the infoframes generated by the processor.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - XST_SUCCESS if infoframes transmitted successfully.
+*       - XST_FAILURE if AUX FIFO is full.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiTx_AuxSend(XV_HdmiTx *InstancePtr)
+{
+    u32 Index;
+    u32 Status;
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Default
+	Status = (XST_FAILURE);
+
+    /* Read the AUX status register */
+    RegValue = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+        (XV_HDMITX_AUX_STA_OFFSET));
+
+    // First check if the AUX packet is ready
+    if (RegValue & (XV_HDMITX_AUX_STA_PKT_RDY_MASK)) {
+
+	// Check if the fifo is full
+		if (RegValue & (XV_HDMITX_AUX_STA_FIFO_FUL_MASK)) {
+			RegValue = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+			        (XV_HDMITX_AUX_STA_OFFSET));
+
+			xdbg_printf((XDBG_DEBUG_GENERAL), "HDMI TX AUX FIFO full\r\n");
+		}
+		else {
+			/* Update AUX with header data */
+			XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+				(XV_HDMITX_AUX_DAT_OFFSET), InstancePtr->Aux.Header.Data);
+
+			/* Update AUX with actual data */
+			for (Index = 0x0; Index < 8; Index++) {
+				XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+					(XV_HDMITX_AUX_DAT_OFFSET), InstancePtr->Aux.Data.Data[Index]);
+			}
+
+			Status = (XST_SUCCESS);
+		}
+    }
+    return Status;
+}
+
+/******************************************************************************/
+/**
+*
+* This function prints stream and timing information on STDIO/Uart console.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_DebugInfo(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Print stream information */
+    XVidC_ReportStreamInfo(&InstancePtr->Stream.Video);
+
+    /* Print timing information */
+    XVidC_ReportTiming(&InstancePtr->Stream.Video.Timing,
+                InstancePtr->Stream.Video.IsInterlaced);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides status of the stream
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - TRUE = Scrambled.
+*       - FALSE = Not scrambled.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_IsStreamScrambled(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    return (InstancePtr->Stream.IsScrambled);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides the stream connected status
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - TRUE = Stream is connected.
+*       - FALSE = Stream is connected.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_IsStreamConnected(XV_HdmiTx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    return (InstancePtr->Stream.IsConnected);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the active audio channels
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return
+*       - XST_SUCCESS if active channels were set.
+*       - XST_FAILURE if no active channles were set.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiTx_SetAudioChannels(XV_HdmiTx *InstancePtr, u8 Value)
+{
+    u32 Data;
+    u32 Status;
+
+    // Stop peripheral
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress,
+        (XV_HDMITX_AUD_CTRL_CLR_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK));
+
+    switch (Value) {
+
+        // 8 Channels
+        case 8:
+            Data = 3 << XV_HDMITX_AUD_CTRL_CH_SHIFT;
+            Status = (XST_SUCCESS);
+            break;
+
+        // 6 Channels
+        case 6:
+            Data = 2 << XV_HDMITX_AUD_CTRL_CH_SHIFT;
+            Status = (XST_SUCCESS);
+            break;
+
+        // 4 Channels
+        case 4:
+            Data = 1 << XV_HDMITX_AUD_CTRL_CH_SHIFT;
+            Status = (XST_SUCCESS);
+            break;
+
+        // 2 Channels
+        case 2:
+            Data = 0 << XV_HDMITX_AUD_CTRL_CH_SHIFT;
+            Status = (XST_SUCCESS);
+            break;
+
+        default :
+            Status = (XST_FAILURE);
+            break;
+    }
+
+    if (Status == (XST_SUCCESS)) {
+        // Set active channels
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress,
+            (XV_HDMITX_AUD_CTRL_OFFSET), (Data));
+
+        // Store active channel in structure
+        (InstancePtr)->Stream.Audio.Channels = Value;
+
+        // Start peripheral
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress,
+            (XV_HDMITX_AUD_CTRL_SET_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK));
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is a stub for the asynchronous callback. The stub is here in
+* case the upper layer forgot to set the handlers. On initialization, all
+* handlers are set to this callback. It is considered an error for this
+* handler to be invoked.
+*
+* @param    CallbackRef is a callback reference passed in by the upper
+*       layer when setting the callback functions, and passed back to
+*       the upper layer when the callback is invoked.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+static void StubCallback(void *Callback)
+{
+    Xil_AssertVoid(Callback != NULL);
+    Xil_AssertVoidAlways();
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.h
new file mode 100644
index 0000000..54b0e47
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx.h
@@ -0,0 +1,921 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx.h
+*
+* This is the main header file for Xilinx HDMI TX core. HDMI TX core is used
+* for transmitting the incoming video and audio streams. It consists of
+* - Transmitter core
+* - AXI4-Stream to Video Bridge
+* - Video Timing Controller and
+* - High-bandwidth Digital Content Protection (HDCP) (Optional).
+*
+* The HDMI TX uses three AXI interfaces for Video, Audio and Processor:
+* - AXI4-Stream interface for Video, can be single, dual or quad pixels per
+* clock and supports 8 and 10 bits per component.
+* - AXI4-Stream interface for Audio, accepts multiple channels uncompressed
+* and compressed audio data.
+* - AXI4-Lite interface for processor, controls the transmitter.
+* Please do refer AXI Reference Guide (UG761) for more information on AXI
+* interfaces.
+*
+* Transmitter core performs following operations:
+* - Converts video data from the video clock domain into the link clock domain.
+* - TMDS (Transition Minimized Differential Signaling) encoding.
+* - Merges encoded video data and packet data into a single HDMI stream.
+* - Optional HDMI stream is encrypted by an external HDCP module.
+* - Over samples HDMI stream if stream bandwidth is too low for the transceiver
+* to handle.
+* - Scrambles encrypted/HDMI stream if data rate is above 3.4 Gbps otherwise
+* bypasses the Scrambler.
+*
+* AXI Video Bridge converts the incoming video AXI-stream to native video.
+*
+* Video Timing Controller (VTC) generates the native video timing.
+*
+* <b>Core Features </b>
+*
+* For a full description of HDMI TX features, please see the hardware
+* specification.
+*
+* <b>Software Initialization & Configuration</b>
+*
+* The application needs to do following steps in order for preparing the
+* HDMI TX core to be ready.
+*
+* - Call XV_HdmiTx_LookupConfig using a device ID to find the core
+*   configuration.
+* - Call XV_HdmiTx_CfgInitialize to initialize the device and the driver
+*   instance associated with it.
+*
+* <b>Interrupts </b>
+*
+* This driver provides interrupt handlers
+* - XV_HdmiTx_IntrHandler, for handling the interrupts from the HDMI TX core
+* PIO and DDC peripheral respectively.
+*
+* Application developer needs to register interrupt handler with the processor,
+* within their examples. Whenever processor calls registered application's
+* interrupt handler associated with interrupt id, application's interrupt
+* handler needs to call appropriate peripheral interrupt handler reading
+* peripheral's Status register.
+
+* This driver provides XV_HdmiTx_SetCallback API to register functions with HDMI
+* TX core instance.
+*
+* <b> Virtual Memory </b>
+*
+* This driver supports Virtual Memory. The RTOS is responsible for calculating
+* the correct device base address in Virtual Memory space.
+*
+* <b> Threads </b>
+*
+* This driver is not thread safe. Any needs for threads or thread mutual
+* exclusion must be satisfied by the layer above this driver.
+*
+* <b> Asserts </b>
+*
+* Asserts are used within all Xilinx drivers to enforce constraints on argument
+* values. Asserts can be turned off on a system-wide basis by defining at
+* compile time, the NDEBUG identifier. By default, asserts are turned on and it
+* is recommended that users leave asserts on during development.
+*
+* <b> Building the driver </b>
+*
+* The HDMI TX driver is composed of several source files. This allows the user
+* to build and link only those parts of the driver that are necessary.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*s
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     15/01/16 Add 3D Support
+* 1.2   MG     09/03/16 Added XV_HdmiTx_SetHdmiMode and XV_HdmiTx_SetDviMode.
+*                       Removed support for reduced blanking
+* 1.3   YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiTx_Config
+*                       XV_HdmiTx_CfgInitialize
+* 1.4   YH     17/08/16 Added XV_HdmiTx_SetAxiClkFreq
+* 1.5   YH     14/11/16 Added XV_HdmiTx_Bridge_yuv420 & XV_HdmiTx_Bridge_pixel
+*                       mode macros
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMITX_H_
+#define XV_HDMITX_H_        /**< Prevent circular inclusions
+                  *  by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmitx_hw.h"
+#include "xil_assert.h"
+#include "xstatus.h"
+#include "xdebug.h"
+#include "xvidc.h"
+
+#include "xv_hdmitx_vsif.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+/** @name Handler Types
+* @{
+*/
+/**
+* These constants specify different types of handler and used to differentiate
+* interrupt requests from peripheral.
+*/
+typedef enum {
+    XV_HDMITX_HANDLER_CONNECT = 1,  // Handler for connect
+    XV_HDMITX_HANDLER_TOGGLE,       // Handler for toggle
+    XV_HDMITX_HANDLER_VS,           // Handler for vsync
+    XV_HDMITX_HANDLER_STREAM_DOWN,  // Handler for stream down
+    XV_HDMITX_HANDLER_STREAM_UP     // Handler for stream up
+} XV_HdmiTx_HandlerType;
+/*@}*/
+
+/** @name HDMI RX stream status
+* @{
+*/
+typedef enum {
+    XV_HDMITX_STATE_STREAM_DOWN,    // Stream down
+    XV_HDMITX_STATE_STREAM_UP       // Stream up
+} XV_HdmiTx_State;
+
+/**
+* This typedef contains configuration information for the HDMI TX core.
+* Each HDMI TX device should have a configuration structure associated.
+*/
+typedef struct {
+    u16 DeviceId;       /**< DeviceId is the unique ID of the HDMI TX core */
+    UINTPTR BaseAddress;    /**< BaseAddress is the physical
+                        * base address of the core's registers */
+} XV_HdmiTx_Config;
+
+/**
+* This typedef contains Video identification information in tabular form.
+*/
+typedef struct {
+    XVidC_VideoMode VmId;   /**< Video mode/Resolution ID */
+    u8 Vic;         /**< Video Identification code */
+} XV_HdmiTx_VicTable;
+
+/**
+* This typedef contains audio stream specific data structure
+*/
+typedef struct {
+    u8 Channels;            //< Video Identification code */
+} XV_HdmiTx_AudioStream;
+
+/**
+* This typedef contains HDMI TX stream specific data structure.
+*/
+typedef struct {
+    XVidC_VideoStream       Video;              /**< Video stream for HDMI TX */
+    XV_HdmiTx_AudioStream   Audio;              /**< Audio stream for HDMI TX */
+    u8                      Vic;                /**< Video Identification code
+                                                flag  */
+    u8                      IsHdmi;             /**< HDMI flag. 1 - HDMI Stream,
+                                                0 - DVI Stream  */
+    u8                      IsHdmi20;           /**< HDMI 2.0 flag  */
+    u8                      IsScrambled;        /**< Scrambler flag
+                                1 - scrambled data , 0 - non scrambled data */
+    u32                     TMDSClock;          /**< TMDS clock */
+    u8                      TMDSClockRatio;     /**< TMDS clock ration
+                                0 - 1/10, 1 - 1/40 */
+    u32                     PixelClk;           /**< Pixel Clock  */
+    XV_HdmiTx_State         State;              /**< State */
+    u8                      IsConnected;        /**< Connected flag.
+                            This flag is set when the cable is connected  */
+    u8                      SampleRate;         /**< Sample rate */
+} XV_HdmiTx_Stream;
+
+/**
+* This typedef contains Auxiliary header information for infoframe.
+*/
+typedef union {
+    u32 Data;   /**< AUX header data field */
+    u8 Byte[4]; /**< AUX header byte field */
+} XV_HdmiTx_AuxHeader;
+
+/**
+* This typedef contains Auxiliary data information for infoframe.
+*/
+typedef union {
+    u32 Data[8];    /**< AUX data field */
+    u8 Byte[32];    /**< AUX data byte field */
+} XV_HdmiTx_AuxData;
+
+/**
+* This typedef holds HDMI TX's Auxiliary peripheral specific data structure.
+*/
+typedef struct {
+    XV_HdmiTx_AuxHeader Header; /**< AUX header field */
+    XV_HdmiTx_AuxData Data;     /**< AUX data field */
+} XV_HdmiTx_Aux;
+
+/**
+* Callback type for Vsync event interrupt.
+*
+* @param    CallbackRef is a callback reference passed in by the upper
+*       layer when setting the callback functions, and passed back to
+*       the upper layer when the callback is invoked.
+*
+* @return   None.
+*
+* @note     None.
+*
+*/
+typedef void (*XV_HdmiTx_Callback)(void *CallbackRef);
+
+/**
+* The XV_HdmiTx driver instance data. An instance must be allocated for each
+* HDMI TX core in use.
+*/
+typedef struct {
+    XV_HdmiTx_Config Config;    /**< Hardware Configuration */
+    u32 IsReady;        /**< Core and the driver instance are initialized */
+
+    /* Callbacks */
+    XV_HdmiTx_Callback ConnectCallback;     /**< Callback for connect event
+                                            interrupt */
+    void *ConnectRef;                       /**< To be passed to the connect
+                                            interrupt callback */
+    u32 IsConnectCallbackSet;               /**< Set flag. This flag is set
+                                to true when the callback has been registered */
+
+    XV_HdmiTx_Callback ToggleCallback;     /**< Callback for toggle event
+                                            interrupt */
+    void *ToggleRef;                       /**< To be passed to the toggle
+                                            interrupt callback */
+    u32 IsToggleCallbackSet;               /**< Set flag. This flag is set
+                                to true when the callback has been registered */
+
+    XV_HdmiTx_Callback VsCallback;          /**< Callback for Vsync event
+                                            interrupt */
+    void *VsRef;                            /**< To be passed to the Vsync
+                                        interrupt callback */
+    u32 IsVsCallbackSet;                    /**< Set flag. This flag is set to
+                                true when the callback has been registered */
+
+    XV_HdmiTx_Callback StreamDownCallback;  /**< Callback for stream down
+                                            callback */
+    void *StreamDownRef;                    /**< To be passed to the stream
+                                            down callback */
+    u32 IsStreamDownCallbackSet;            /**< Set flag. This flag is set to
+                                true when the callback has been registered */
+
+    XV_HdmiTx_Callback StreamUpCallback;    /**< Callback for stream up
+    callback */
+    void *StreamUpRef;                      /**< To be passed to the stream up
+    callback */
+    u32 IsStreamUpCallbackSet;              /**< Set flag. This flag is set to
+    true when the callback has been registered */
+
+    /* Aux peripheral specific */
+    volatile XV_HdmiTx_Aux Aux;     /**< AUX peripheral information */
+
+    /* HDMI TX stream */
+    XV_HdmiTx_Stream Stream;        /**< HDMI TX stream information */
+    u32 CpuClkFreq;                 /* CPU Clock frequency */
+
+} XV_HdmiTx;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* This macro reads the TX version
+*
+* @param  InstancePtr is a pointer to the XV_HdmiTX core instance.
+*
+* @return None.
+*
+*
+******************************************************************************/
+#define XV_HdmiTx_GetVersion(InstancePtr) \
+  XV_HdmiTx_ReadReg((InstancePtr)->Config.BaseAddress, \
+  (XV_HDMITX_VER_VERSION_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This macro asserts or releases the HDMI TX reset.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    Reset specifies TRUE/FALSE value to either assert or
+*       release HDMI TX reset.
+*
+* @return   None.
+*
+* @note     The reset output of the PIO is inverted. When the system is
+*       in reset, the PIO output is cleared and this will reset the
+*       HDMI RX. Therefore, clearing the PIO reset output will assert
+*       the HDMI link and video reset.
+*       C-style signature:
+*       void XV_HdmiTx_Reset(XV_HdmiTx *InstancePtr, u8 Reset)
+*
+******************************************************************************/
+#define XV_HdmiTx_Reset(InstancePtr, Reset) \
+{ \
+    if (Reset) { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_PIO_OUT_CLR_OFFSET), (XV_HDMITX_PIO_OUT_RST_MASK)); \
+    } \
+    else { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_PIO_OUT_SET_OFFSET), (XV_HDMITX_PIO_OUT_RST_MASK)); \
+    } \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the HDMI TX Scrambler.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+* @param    SetClr specifies TRUE/FALSE value to either set ON or clear
+*       Scrambler.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_SetScrambler(XV_HdmiTx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiTx_SetScrambler(InstancePtr, SetClr) \
+{ \
+    if (SetClr) { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_PIO_OUT_SET_OFFSET), (XV_HDMITX_PIO_OUT_SCRM_MASK)); \
+        (InstancePtr)->Stream.IsScrambled = (TRUE); \
+    } \
+    else { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_PIO_OUT_CLR_OFFSET), (XV_HDMITX_PIO_OUT_SCRM_MASK)); \
+        (InstancePtr)->Stream.IsScrambled = (FALSE); \
+    } \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the YUV420 mode for video bridge.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Tx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either enable or disable the
+*		YUV 420 Support.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiTx_Bridge_yuv420(XV_HdmiTx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiTx_Bridge_yuv420(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+		                   (XV_HDMITX_PIO_OUT_SET_OFFSET), \
+						   (XV_HDMITX_PIO_OUT_BRIDGE_YUV420_MASK)); \
+	} \
+	else { \
+		XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+		                   (XV_HDMITX_PIO_OUT_CLR_OFFSET), \
+						   (XV_HDMITX_PIO_OUT_BRIDGE_YUV420_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the Pixel Repeat mode for video bridge.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Tx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either enable or disable the
+*		Pixel Repitition Support.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiTx_Bridge_pixel(XV_HdmiTx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiTx_Bridge_pixel(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+		                   (XV_HDMITX_PIO_OUT_SET_OFFSET), \
+						   (XV_HDMITX_PIO_OUT_BRIDGE_PIXEL_MASK)); \
+	} \
+	else { \
+		XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+		                   (XV_HDMITX_PIO_OUT_CLR_OFFSET), \
+						   (XV_HDMITX_PIO_OUT_BRIDGE_PIXEL_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI TX PIO peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_PioEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_PioEnable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_CTRL_SET_OFFSET), (XV_HDMITX_PIO_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI TX PIO peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_PioDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_PioDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_CTRL_CLR_OFFSET), (XV_HDMITX_PIO_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupt in the HDMI TX PIO peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_PioIntrEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_PioIntrEnable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_CTRL_SET_OFFSET), (XV_HDMITX_PIO_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupt in the HDMI TX PIO peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_PioIntrDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_PioIntrDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_CTRL_CLR_OFFSET), (XV_HDMITX_PIO_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro clears HDMI TX PIO interrupt.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_PioIntrClear(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_PioIntrClear(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_STA_OFFSET), (XV_HDMITX_PIO_STA_IRQ_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI TX Display Data Channel (DDC) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_DdcEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_DdcEnable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_DDC_CTRL_SET_OFFSET), (XV_HDMITX_DDC_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI TX Display Data Channel (DDC) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_DdcDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_DdcDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_DDC_CTRL_CLR_OFFSET), (XV_HDMITX_DDC_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupt in the HDMI TX DDC peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_DdcIntrEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_DdcIntrEnable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_DDC_CTRL_SET_OFFSET), (XV_HDMITX_DDC_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupt in the HDMI TX DDC peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_DdcIntrDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_DdcIntrDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_DDC_CTRL_CLR_OFFSET), (XV_HDMITX_DDC_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro clears HDMI TX DDC interrupt.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_DdcIntrClear(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_DdcIntrClear(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_DDC_STA_OFFSET), (XV_HDMITX_DDC_STA_IRQ_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI TX Auxiliary (AUX) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AuxEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AuxEnable(InstancePtr) \
+{ \
+    if ((InstancePtr)->Stream.IsHdmi) { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_AUX_CTRL_SET_OFFSET), (XV_HDMITX_AUX_CTRL_RUN_MASK)); \
+    } \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI TX Auxiliary (AUX) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AuxDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AuxDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUX_CTRL_CLR_OFFSET), (XV_HDMITX_AUX_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupt in the HDMI TX AUX peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AuxIntrEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AuxIntrEnable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUX_CTRL_SET_OFFSET), (XV_HDMITX_AUX_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupt in the HDMI TX AUX peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AuxIntrDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AuxIntrDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUX_CTRL_CLR_OFFSET), (XV_HDMITX_AUX_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables audio in HDMI TX core.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AudioEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AudioEnable(InstancePtr) \
+{ \
+    if ((InstancePtr)->Stream.IsHdmi) { \
+        XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+        (XV_HDMITX_AUD_CTRL_SET_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK)); \
+    } \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro disables audio in HDMI TX core.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AudioDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AudioDisable(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUD_CTRL_CLR_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro unmutes audio in HDMI TX core.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AudioEnable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AudioUnmute(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUD_CTRL_SET_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro mutes audio in HDMI TX core.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_AudioDisable(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_AudioMute(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_AUD_CTRL_CLR_OFFSET), (XV_HDMITX_AUD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the mode bit.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_SetMode(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_SetMode(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_OUT_SET_OFFSET), (XV_HDMITX_PIO_OUT_MODE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro clears the mode bit.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_ClearMode(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_ClearMode(InstancePtr) \
+    XV_HdmiTx_WriteReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_OUT_CLR_OFFSET), (XV_HDMITX_PIO_OUT_MODE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro provides the current mode.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   Current mode.
+*       0 = DVI
+*       1 = HDMI
+*
+* @note     C-style signature:
+*       u8 XV_HdmiTx_GetMode(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_GetMode(InstancePtr) \
+    XV_HdmiTx_ReadReg((InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_OUT_OFFSET)) & (XV_HDMITX_PIO_OUT_MODE_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This macro provides the current sample rate.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   Sample rate
+*
+* @note     C-style signature:
+*       u8 XV_HdmiTx_GetMode(XV_HdmiTx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiTx_GetSampleRate(InstancePtr) \
+    (InstancePtr)->Stream.SampleRate
+
+/*****************************************************************************/
+/**
+*
+* This macro provides the active audio channels.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   Audio channels
+*
+*
+******************************************************************************/
+#define XV_HdmiTx_GetAudioChannels(InstancePtr) \
+    (InstancePtr)->Stream.Audio.Channels
+
+/*****************************************************************************/
+/**
+*
+* This macro provides the current pixel packing phase.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx core instance.
+*
+* @return   Pixel packing phase.
+*
+*
+******************************************************************************/
+#define XV_HdmiTx_GetPixelPackingPhase(InstancePtr) \
+    ( ( (XV_HdmiTx_ReadReg( (InstancePtr)->Config.BaseAddress, \
+    (XV_HDMITX_PIO_IN_OFFSET) ) ) >> (XV_HDMITX_PIO_IN_PPP_SHIFT)) \
+    & (XV_HDMITX_PIO_IN_PPP_MASK))
+
+/************************** Function Prototypes ******************************/
+
+/* Initialization function in xv_hdmitx_sinit.c */
+XV_HdmiTx_Config *XV_HdmiTx_LookupConfig(u16 DeviceId);
+
+/* Initialization and control functions in xv_hdmitx.c */
+int XV_HdmiTx_CfgInitialize(XV_HdmiTx *InstancePtr,
+    XV_HdmiTx_Config *CfgPtr,
+    UINTPTR EffectiveAddr);
+void XV_HdmiTx_SetHdmiMode(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_SetDviMode(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_Clear(XV_HdmiTx *InstancePtr);
+u8 XV_HdmiTx_GetVic(XVidC_VideoMode VideoMode);
+XVidC_VideoMode XV_HdmiTx_GetVideoModeFromVic(u8 Vic);
+u32 XV_HdmiTx_SetStream(XV_HdmiTx *InstancePtr,
+    XVidC_VideoMode VideoMode,
+    XVidC_ColorFormat ColorFormat,
+    XVidC_ColorDepth Bpc,
+    XVidC_PixelsPerClock Ppc,
+    XVidC_3DInfo *Info3D);
+
+void XV_HdmiTx_SetPixelRate(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_SetSampleRate(XV_HdmiTx *InstancePtr, u8 SampleRate);
+void XV_HdmiTx_SetColorFormat(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_SetColorDepth(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_IsStreamScrambled(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_IsStreamConnected(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_SetAxiClkFreq(XV_HdmiTx *InstancePtr, u32 ClkFreq);
+void XV_HdmiTx_DdcInit(XV_HdmiTx *InstancePtr, u32 Frequency);
+int XV_HdmiTx_DdcWrite(XV_HdmiTx *InstancePtr, u8 Slave, u16 Length,
+    u8 *Buffer, u8 Stop);
+int XV_HdmiTx_DdcRead(XV_HdmiTx *InstancePtr, u8 Slave, u16 Length,
+    u8 *Buffer, u8 Stop);
+u32 XV_HdmiTx_AuxSend(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_Scrambler(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_ClockRatio(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_DetectHdmi20(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_ShowSCDC(XV_HdmiTx *InstancePtr);
+void XV_HdmiTx_DebugInfo(XV_HdmiTx *InstancePtr);
+int XV_HdmiTx_SetAudioChannels(XV_HdmiTx *InstancePtr, u8 Value);
+
+/* Self test function in xv_hdmitx_selftest.c */
+int XV_HdmiTx_SelfTest(XV_HdmiTx *InstancePtr);
+
+/* Interrupt related functions in xv_hdmitx_intr.c */
+void XV_HdmiTx_IntrHandler(void *InstancePtr);
+int XV_HdmiTx_SetCallback(XV_HdmiTx *InstancePtr, u32 HandlerType,
+    void *CallbackFunc, void *CallbackRef);
+
+
+/* Vendor Specific Infomation related functions in xv_hdmitx_vsif.c */
+int XV_HdmiTx_VSIF_GeneratePacket(XV_HdmiTx_VSIF  *VSIFPtr,
+                                  XV_HdmiTx_Aux *AuxPtr);
+void XV_HdmiTx_VSIF_DisplayInfo(XV_HdmiTx_VSIF  *VSIFPtr);
+char* XV_HdmiTx_VSIF_3DStructToString(XV_HdmiTx_3D_Struct_Field Item);
+char* XV_HdmiTx_VSIF_3DSampMethodToString(XV_HdmiTx_3D_Sampling_Method Item);
+char* XV_HdmiTx_VSIF_3DSampPosToString(XV_HdmiTx_3D_Sampling_Position Item);
+
+/************************** Variable Declarations ****************************/
+
+/************************** Variable Declarations ****************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* End of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_hw.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_hw.h
new file mode 100644
index 0000000..eb2a621
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_hw.h
@@ -0,0 +1,323 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx_hw.h
+*
+* This header file contains identifiers and register-level core functions (or
+* macros) that can be used to access the Xilinx HDMI TX core.
+*
+* For more information about the operation of this core see the hardware
+* specification and documentation in the higher level driver xv_hdmitx.h file.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.01  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiTx_WriteReg
+*                       XV_HdmiTx_ReadReg
+* 1.02  YH     14/11/16 Added BRIDGE_YUV420 and BRIDGE_PIXEL mask to PIO Out
+* 1.03  MG     06/03/17 Added XV_HDMITX_AUX_STA_PKT_RDY_MASK
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMITX_HW_H_
+#define XV_HDMITX_HW_H_     /**< Prevent circular inclusions
+                  *  by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_io.h"
+
+/************************** Constant Definitions *****************************/
+
+/**< VER (Version Interface) peripheral register offsets */
+/**< The VER is the first peripheral on the local bus */
+#define XV_HDMITX_VER_BASE              (0*64)
+#define XV_HDMITX_VER_ID_OFFSET         ((XV_HDMITX_VER_BASE)+(0*4))/**<
+                                    * VER Identification *  Register offset */
+#define XV_HDMITX_VER_VERSION_OFFSET    ((XV_HDMITX_VER_BASE)+(1*4))/**<
+                                    * VER Version Register *  offset */
+
+/**< PIO (Parallel Interface) peripheral register offsets */
+/**< The PIO is the first peripheral on the local bus */
+#define XV_HDMITX_PIO_BASE              (1*64)
+#define XV_HDMITX_PIO_ID_OFFSET         ((XV_HDMITX_PIO_BASE)+(0*4))/**< PIO
+                                        * Identification *  Register offset */
+#define XV_HDMITX_PIO_CTRL_OFFSET       ((XV_HDMITX_PIO_BASE)+(1*4))/**< PIO
+                                        * Control Register *  offset */
+#define XV_HDMITX_PIO_CTRL_SET_OFFSET   ((XV_HDMITX_PIO_BASE)+(2*4))/**< PIO
+                                        * Control Register Set *  offset */
+#define XV_HDMITX_PIO_CTRL_CLR_OFFSET   ((XV_HDMITX_PIO_BASE)+(3*4))/**< PIO
+                                        * Control Register Clear *  offset */
+#define XV_HDMITX_PIO_STA_OFFSET        ((XV_HDMITX_PIO_BASE)+(4*4))/**< PIO
+                                        * Status Register *  offset */
+#define XV_HDMITX_PIO_OUT_OFFSET        ((XV_HDMITX_PIO_BASE)+(5*4))/**< PIO
+                                        * Out Register offset */
+#define XV_HDMITX_PIO_OUT_SET_OFFSET    ((XV_HDMITX_PIO_BASE)+(6*4))/**< PIO
+                                        * Out Register Set *  offset */
+#define XV_HDMITX_PIO_OUT_CLR_OFFSET    ((XV_HDMITX_PIO_BASE)+(7*4))/**< PIO
+                                        * Out Register Clear *  offset */
+#define XV_HDMITX_PIO_OUT_MSK_OFFSET    ((XV_HDMITX_PIO_BASE)+(8*4))/**< PIO
+                                        * Out Mask Register *  offset */
+#define XV_HDMITX_PIO_IN_OFFSET         ((XV_HDMITX_PIO_BASE)+(9*4))/**< PIO
+                                        * In Register offset */
+#define XV_HDMITX_PIO_IN_EVT_OFFSET     ((XV_HDMITX_PIO_BASE)+(10*4))/**< PIO
+                                        * In Event Register *  offset */
+#define XV_HDMITX_PIO_IN_EVT_RE_OFFSET  ((XV_HDMITX_PIO_BASE)+(11*4))/**< PIO
+                                    * In Event Rising Edge *  Register offset */
+#define XV_HDMITX_PIO_IN_EVT_FE_OFFSET  ((XV_HDMITX_PIO_BASE)+(12*4))/**< PIO
+                                * In Event Falling Edge *  Register offset */
+
+// PIO peripheral Control register masks
+#define XV_HDMITX_PIO_CTRL_RUN_MASK     (1<<0)  /**< PIO Control Run mask */
+#define XV_HDMITX_PIO_CTRL_IE_MASK      (1<<1)  /**< PIO Control Interrupt
+                                                * Enable mask */
+
+// PIO peripheral Status register masks
+#define XV_HDMITX_PIO_STA_IRQ_MASK      (1<<0) /**< PIO Status Interrupt mask */
+#define XV_HDMITX_PIO_STA_EVT_MASK      (1<<1) /**< PIO Status Event mask */
+
+// PIO peripheral PIO Out register masks and shifts
+#define XV_HDMITX_PIO_OUT_RST_MASK          (1<<0)  /**< PIO Out Reset mask */
+#define XV_HDMITX_PIO_OUT_MODE_MASK         (1<<3)  /**< PIO Out Mode mask */
+#define XV_HDMITX_PIO_OUT_COLOR_DEPTH_MASK  0x30    /**< PIO Out Color Depth
+                                                    * mask */
+#define XV_HDMITX_PIO_OUT_PIXEL_RATE_MASK   0xC0    /**< PIO Out Pixel Rate
+                                                    * mask */
+#define XV_HDMITX_PIO_OUT_SAMPLE_RATE_MASK  0x300   /**< PIO Out Sample Rate
+                                                    * mask */
+#define XV_HDMITX_PIO_OUT_COLOR_SPACE_MASK  0xC00   /**< PIO Out Color Space
+                                                    * mask */
+#define XV_HDMITX_PIO_OUT_SCRM_MASK         (1<<12) /**< PIO Out Scrambler
+                                                    * mask */
+#define XV_HDMITX_PIO_OUT_COLOR_DEPTH_SHIFT 4   /**< PIO Out Color Depth
+                                                    * shift */
+#define XV_HDMITX_PIO_OUT_PIXEL_RATE_SHIFT  6   /**< PIO Out Pixel Rate
+                                                    * shift */
+#define XV_HDMITX_PIO_OUT_SAMPLE_RATE_SHIFT 8   /**< PIO Out Sample Rate
+                                                    * shift */
+#define XV_HDMITX_PIO_OUT_COLOR_SPACE_SHIFT 10  /**< PIO Out Color Space
+                                                    * shift */
+#define XV_HDMITX_PIO_OUT_BRIDGE_YUV420_MASK (1<<29) /**< PIO Out Bridge_YUV420
+                                                         * mask */
+#define XV_HDMITX_PIO_OUT_BRIDGE_PIXEL_MASK  (1<<30) /**< PIO Out Bridge_Pixel
+                                                         * repeat mask */
+
+// PIO peripheral PIO In register masks
+#define XV_HDMITX_PIO_IN_LNK_RDY_MASK       (1<<0)  /**< PIO In link ready
+                                                    * mask */
+#define XV_HDMITX_PIO_IN_VID_RDY_MASK       (1<<1)  /**< PIO In video ready
+                                                    * mask */
+#define XV_HDMITX_PIO_IN_HPD_MASK           (1<<2)  /**< PIO In HPD mask */
+#define XV_HDMITX_PIO_IN_VS_MASK            (1<<3)  /**< PIO In Vsync mask */
+#define XV_HDMITX_PIO_IN_PPP_MASK           0x07    /**< PIO In Pixel packing
+                                                    * phase mask */
+#define XV_HDMITX_PIO_IN_HPD_TOGGLE_MASK    (1<<8)  /**< PIO In HPD toggle mask */
+#define XV_HDMITX_PIO_IN_PPP_SHIFT          5       /**< PIO In Pixel packing
+                                                    * phase shift */
+
+/**< DDC (Display Data Channel) peripheral register offsets */
+/**< The DDC is the second peripheral on the local bus */
+#define XV_HDMITX_DDC_BASE                  (2*64)
+#define XV_HDMITX_DDC_ID_OFFSET             ((XV_HDMITX_DDC_BASE)+(0*4))/**< DDC
+                                * Identification *  Register offset */
+#define XV_HDMITX_DDC_CTRL_OFFSET           ((XV_HDMITX_DDC_BASE)+(1*4))/**< DDC
+                                * Control Register *  offset */
+#define XV_HDMITX_DDC_CTRL_SET_OFFSET       ((XV_HDMITX_DDC_BASE)+(2*4))/**< DDC
+                                * Control Register Set *  offset */
+#define XV_HDMITX_DDC_CTRL_CLR_OFFSET       ((XV_HDMITX_DDC_BASE)+(3*4))/**< DDC
+                                * Control Register Clear *  offset */
+#define XV_HDMITX_DDC_STA_OFFSET            ((XV_HDMITX_DDC_BASE)+(4*4))/**< DDC
+                                * Status Register *  offset */
+#define XV_HDMITX_DDC_CMD_OFFSET            ((XV_HDMITX_DDC_BASE)+(5*4))/**< DDC
+                                * Command Register *  offset */
+#define XV_HDMITX_DDC_DAT_OFFSET            ((XV_HDMITX_DDC_BASE)+(6*4))/**< DDC
+                                * Data Register *  offset */
+
+// DDC peripheral Control register masks and shift
+#define XV_HDMITX_DDC_CTRL_RUN_MASK         (1<<0)  /**< DDC Control Run mask */
+#define XV_HDMITX_DDC_CTRL_IE_MASK          (1<<1)  /**< DDC Control Interrupt
+                                                    *  Enable mask */
+#define XV_HDMITX_DDC_CTRL_CLK_DIV_MASK     0xFFFF  /**< DDC Control Clock
+                                                    * Divider mask */
+#define XV_HDMITX_DDC_CTRL_CLK_DIV_SHIFT    16  /**< DDC Control Clock
+                                                *Divider shift */ /*@}*/
+
+// DDC peripheral Status register masks
+#define XV_HDMITX_DDC_STA_IRQ_MASK      (1<<0)  /**< DDC Status IRQ mask */
+#define XV_HDMITX_DDC_STA_EVT_MASK      (1<<1)  /**< DDC Status Event mask */
+#define XV_HDMITX_DDC_STA_BUSY_MASK     (1<<2)  /**< DDC Status Busy mask */
+#define XV_HDMITX_DDC_STA_DONE_MASK     (1<<3)  /**< DDC Status Busy mask */
+#define XV_HDMITX_DDC_STA_TIMEOUT_MASK  (1<<4)  /**< DDC Status Timeout mask */
+#define XV_HDMITX_DDC_STA_ACK_MASK      (1<<5)  /**< DDC Status ACK mask */
+#define XV_HDMITX_DDC_STA_SCL_MASK      (1<<6)  /**< DDC State of SCL Input
+                                                * mask */
+#define XV_HDMITX_DDC_STA_SDA_MASK      (1<<7)  /**< DDC State of SDA Input
+                                                * mask */
+#define XV_HDMITX_DDC_STA_CMD_FULL      (1<<8)  /**< Command fifo full */
+#define XV_HDMITX_DDC_STA_DAT_EMPTY     (1<<9)  /**< Data fifo empty */
+#define XV_HDMITX_DDC_STA_CMD_WRDS_MASK 0xFF /**< Command fifo words mask*/
+#define XV_HDMITX_DDC_STA_CMD_WRDS_SHIFT    16  /**< Command fifo words shift */
+#define XV_HDMITX_DDC_STA_DAT_WRDS_MASK     0xFF /**< Data fifo words mask */
+#define XV_HDMITX_DDC_STA_DAT_WRDS_SHIFT    24  /**< Data fifo words shift */
+
+// DDC peripheral token
+#define XV_HDMITX_DDC_CMD_STR_TOKEN     (0x100) /**< Start token */
+#define XV_HDMITX_DDC_CMD_STP_TOKEN     (0x101) /**< Stop token */
+#define XV_HDMITX_DDC_CMD_RD_TOKEN      (0x102) /**< Read token */
+#define XV_HDMITX_DDC_CMD_WR_TOKEN      (0x103) /**< Write token */
+
+// Auxiliary (AUX) peripheral register offsets
+// The AUX is the third peripheral on the local bus
+#define XV_HDMITX_AUX_BASE              (3*64)
+#define XV_HDMITX_AUX_ID_OFFSET         ((XV_HDMITX_AUX_BASE)+(0*4)) /**< AUX
+                                * Identification *  Register offset */
+#define XV_HDMITX_AUX_CTRL_OFFSET       ((XV_HDMITX_AUX_BASE)+(1*4)) /**< AUX
+                                * Control Register *  offset */
+#define XV_HDMITX_AUX_CTRL_SET_OFFSET   ((XV_HDMITX_AUX_BASE)+(2*4)) /**< AUX
+                                * Control Register Set *  offset */
+#define XV_HDMITX_AUX_CTRL_CLR_OFFSET   ((XV_HDMITX_AUX_BASE)+(3*4)) /**< AUX
+                                * Control Register Clear *  offset */
+#define XV_HDMITX_AUX_STA_OFFSET        ((XV_HDMITX_AUX_BASE)+(4*4)) /**< AUX
+                                * Status Register *  offset */
+#define XV_HDMITX_AUX_DAT_OFFSET        ((XV_HDMITX_AUX_BASE)+(5*4)) /**< AUX
+                                * Data Register *  offset */
+
+// Auxiliary peripheral Control register masks
+#define XV_HDMITX_AUX_CTRL_RUN_MASK         (1<<0)  /**< AUX Control Run mask */
+#define XV_HDMITX_AUX_CTRL_IE_MASK          (1<<1)  /**< AUX Control Interrupt
+                                                    * Enable mask */
+
+// Auxiliary peripheral Status register masks and shift
+#define XV_HDMITX_AUX_STA_IRQ_MASK          (1<<0)  /**< AUX Status Interrupt
+                                                    *  mask */
+#define XV_HDMITX_AUX_STA_FIFO_EMT_MASK     (1<<1)  /**< AUX Status FIFO Empty
+                                                    *  mask */
+#define XV_HDMITX_AUX_STA_FIFO_FUL_MASK     (1<<2)  /**< AUX Status FIFO Full
+                                                    *  mask */
+#define XV_HDMITX_AUX_STA_PKT_RDY_MASK     (1<<3)  /**< AUX Status FIFO Ready
+                                                    *  mask */
+#define XV_HDMITX_AUX_STA_FREE_PKTS_MASK    0x0F    /**< AUX Status Free Packets
+                                                    *  mask */
+#define XV_HDMITX_AUX_STA_FREE_PKTS_SHIFT   15  /**< AUX Status Free
+                                                    *  Packets shift */
+
+
+// Audio (AUD) peripheral register offsets
+// The AUD is the forth peripheral on the local bus
+#define XV_HDMITX_AUD_BASE              (4*64)
+#define XV_HDMITX_AUD_ID_OFFSET         ((XV_HDMITX_AUD_BASE)+(0*4)) /**< AUD
+                                * Identification *  Register offset */
+#define XV_HDMITX_AUD_CTRL_OFFSET       ((XV_HDMITX_AUD_BASE)+(1*4)) /**< AUD
+                                * Control Register *  offset */
+#define XV_HDMITX_AUD_CTRL_SET_OFFSET   ((XV_HDMITX_AUD_BASE)+(2*4)) /**< AUD
+                                * Control Register Set *  offset */
+#define XV_HDMITX_AUD_CTRL_CLR_OFFSET   ((XV_HDMITX_AUD_BASE)+(3*4)) /**< AUD
+                                * Control Register Clear *  offset */
+#define XV_HDMITX_AUD_STA_OFFSET        ((XV_HDMITX_AUD_BASE)+(4*4)) /**< AUD
+                                * Status Register *  offset */
+#define XV_HDMITX_AUD_ACR_CTS_OFFSET    ((XV_HDMITX_AUD_BASE)+(5*4)) /**< AUD
+                                * Clock Regeneration CTS *  Register offset */
+#define XV_HDMITX_AUD_ACR_N_OFFSET      ((XV_HDMITX_AUD_BASE)+(6*4)) /**< AUD
+                                * Clock Regeneration N *  Register offset */
+
+// Audio peripheral Control register masks
+#define XV_HDMITX_AUD_CTRL_RUN_MASK     (1<<0)  /**< AUD Control Run mask */
+#define XV_HDMITX_AUD_CTRL_IE_MASK      (1<<1)  /**< AUD Control Interrupt
+                                                * Enable mask */
+#define XV_HDMITX_AUD_CTRL_CH_MASK      0x03 /**< AUD Control channels mask */
+#define XV_HDMITX_AUD_CTRL_CH_SHIFT     2   /**< AUD Control channels mask */
+
+// Audio peripheral Status register masks
+#define XV_HDMITX_AUD_STA_IRQ_MASK      (1<<0) /**< AUD Status Interrupt mask */
+
+// Peripheral ID and General shift values.
+#define XV_HDMITX_SHIFT_16  16  /**< 16 shift value */
+#define XV_HDMITX_MASK_16   0xFFFF  /**< 16 bit mask value */
+#define XV_HDMITX_PIO_ID    0x2200  /**< TX's PIO ID */
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+// Register access macro definition
+#define XV_HdmiTx_In32  Xil_In32    /**< Input Operations */
+#define XV_HdmiTx_Out32 Xil_Out32   /**< Output Operations */
+
+/*****************************************************************************/
+/**
+*
+* This macro reads a value from a HDMI TX register. A 32 bit read is performed.
+* If the component is implemented in a smaller width, only the least
+* significant data is read from the register. The most significant data
+* will be read as 0.
+*
+* @param    BaseAddress is the base address of the HDMI TX core instance.
+* @param    RegOffset is the register offset of the register (defined at
+*       the top of this file).
+*
+* @return   The 32-bit value of the register.
+*
+* @note     C-style signature:
+*       u32 XV_HdmiTx_ReadReg(u32 BaseAddress, u32 RegOffset)
+*
+******************************************************************************/
+#define XV_HdmiTx_ReadReg(BaseAddress, RegOffset) \
+    XV_HdmiTx_In32((BaseAddress) + (RegOffset))
+
+/*****************************************************************************/
+/**
+*
+* This macro writes a value to a HDMI TX register. A 32 bit write is performed.
+* If the component is implemented in a smaller width, only the least
+* significant data is written.
+*
+* @param    BaseAddress is the base address of the HDMI TX core instance.
+* @param    RegOffset is the register offset of the register (defined at
+*       the top of this file) to be written.
+* @param    Data is the 32-bit value to write into the register.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiTx_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+******************************************************************************/
+#define XV_HdmiTx_WriteReg(BaseAddress, RegOffset, Data) \
+    XV_HdmiTx_Out32((BaseAddress) + (RegOffset), (u32)(Data))
+/*@}*/
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Declarations ****************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_intr.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_intr.c
new file mode 100644
index 0000000..ae096ee
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_intr.c
@@ -0,0 +1,333 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx_intr.c
+*
+* This file contains interrupt related functions for Xilinx HDMI TX core.
+* Please see xv_hdmitx.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   YH     18/08/16 squash unused variable compiler warning
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmitx.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+void HdmiTx_PioIntrHandler(XV_HdmiTx *InstancePtr);
+void HdmiTx_DdcIntrHandler(XV_HdmiTx *InstancePtr);
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI TX driver.
+*
+* This handler reads the pending interrupt from PIO and DDC peripheral,
+* determines the source of the interrupts, clears the interrupts and calls
+* callbacks accordingly.
+*
+* The application is responsible for connecting this function to the interrupt
+* system. Application beyond this driver is also responsible for providing
+* callbacks to handle interrupts and installing the callbacks using
+* XV_HdmiTx_SetCallback() during initialization phase. An example delivered
+* with this driver demonstrates how this could be done.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTx instance that just
+*       interrupted.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTx_IntrHandler(void *InstancePtr)
+{
+    u32 Data;
+    XV_HdmiTx *HdmiTxPtr = (XV_HdmiTx *)InstancePtr;
+
+    /* Verify arguments */
+    Xil_AssertVoid(HdmiTxPtr != NULL);
+    Xil_AssertVoid(HdmiTxPtr->IsReady == XIL_COMPONENT_IS_READY);
+
+    /* PIO */
+    Data = XV_HdmiTx_ReadReg(HdmiTxPtr->Config.BaseAddress,
+                            (XV_HDMITX_PIO_STA_OFFSET)) &
+                            (XV_HDMITX_PIO_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to PIO handler */
+        HdmiTx_PioIntrHandler(HdmiTxPtr);
+    }
+
+    /* DDC */
+    Data = XV_HdmiTx_ReadReg(HdmiTxPtr->Config.BaseAddress,
+                            (XV_HDMITX_DDC_STA_OFFSET)) &
+                            (XV_HDMITX_DDC_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to DDC handler */
+        HdmiTx_DdcIntrHandler(HdmiTxPtr);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function installs an asynchronous callback function for the given
+* HandlerType:
+*
+* <pre>
+* HandlerType              Callback Function Type
+* -----------------------  --------------------------------------------------
+* (XV_HDMITX_HANDLER_HPD)   HpdCallback
+* (XV_HDMITX_HANDLER_VS)    VsCallback
+* </pre>
+*
+* @param    InstancePtr is a pointer to the HDMI TX core instance.
+* @param    HandlerType specifies the type of handler.
+* @param    CallbackFunc is the address of the callback function.
+* @param    CallbackRef is a user data item that will be passed to the
+*       callback function when it is invoked.
+*
+* @return
+*       - XST_SUCCESS if callback function installed successfully.
+*       - XST_INVALID_PARAM when HandlerType is invalid.
+*
+* @note     Invoking this function for a handler that already has been
+*       installed replaces it with the new handler.
+*
+******************************************************************************/
+int XV_HdmiTx_SetCallback(XV_HdmiTx *InstancePtr,
+                        u32 HandlerType,
+                        void *CallbackFunc,
+                        void *CallbackRef)
+{
+    u32 Status;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(HandlerType >= (XV_HDMITX_HANDLER_CONNECT));
+    Xil_AssertNonvoid(CallbackFunc != NULL);
+    Xil_AssertNonvoid(CallbackRef != NULL);
+
+    /* Check for handler type */
+    switch (HandlerType) {
+        case (XV_HDMITX_HANDLER_CONNECT):
+            InstancePtr->ConnectCallback = (XV_HdmiTx_Callback)CallbackFunc;
+            InstancePtr->ConnectRef = CallbackRef;
+            InstancePtr->IsConnectCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMITX_HANDLER_TOGGLE):
+            InstancePtr->ToggleCallback = (XV_HdmiTx_Callback)CallbackFunc;
+            InstancePtr->ToggleRef = CallbackRef;
+            InstancePtr->IsToggleCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMITX_HANDLER_VS):
+            InstancePtr->VsCallback = (XV_HdmiTx_Callback)CallbackFunc;
+            InstancePtr->VsRef = CallbackRef;
+            InstancePtr->IsVsCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream down
+        case (XV_HDMITX_HANDLER_STREAM_DOWN):
+            InstancePtr->StreamDownCallback = (XV_HdmiTx_Callback)CallbackFunc;
+            InstancePtr->StreamDownRef = CallbackRef;
+            InstancePtr->IsStreamDownCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream up
+        case (XV_HDMITX_HANDLER_STREAM_UP):
+            InstancePtr->StreamUpCallback = (XV_HdmiTx_Callback)CallbackFunc;
+            InstancePtr->StreamUpRef = CallbackRef;
+            InstancePtr->IsStreamUpCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        default:
+            Status = (XST_INVALID_PARAM);
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the HDMI TX PIO peripheral interrupt handler.
+*
+* This handler reads corresponding event interrupt from the PIO_IN_EVT
+* register. It determines the source of the interrupts and calls according
+* callbacks.
+*
+* @param    InstancePtr is a pointer to the HDMI TX core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiTx_PioIntrHandler(XV_HdmiTx *InstancePtr)
+{
+    u32 Event;
+    u32 Data;
+
+    /* Read PIO IN Event register.*/
+    Event = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                            (XV_HDMITX_PIO_IN_EVT_OFFSET));
+
+    /* Clear event flags */
+    XV_HdmiTx_WriteReg(InstancePtr->Config.BaseAddress,
+                    (XV_HDMITX_PIO_IN_EVT_OFFSET),
+                    (Event));
+
+    /* Read data */
+    Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                            (XV_HDMITX_PIO_IN_OFFSET));
+
+    /* HPD event has occurred */
+    if ((Event) & (XV_HDMITX_PIO_IN_HPD_TOGGLE_MASK)) {
+
+        // Check if user callback has been registered
+        if (InstancePtr->IsToggleCallbackSet) {
+            InstancePtr->ToggleCallback(InstancePtr->ToggleRef);
+        }
+    }
+
+    /* HPD event has occurred */
+    if ((Event) & (XV_HDMITX_PIO_IN_HPD_MASK)) {
+
+        // Check the HPD status
+        if ((Data) & (XV_HDMITX_PIO_IN_HPD_MASK))
+            InstancePtr->Stream.IsConnected = (TRUE);   // Set connected flag
+        else
+            InstancePtr->Stream.IsConnected = (FALSE);  // Clear connected flag
+
+        // Check if user callback has been registered
+        if (InstancePtr->IsConnectCallbackSet) {
+            InstancePtr->ConnectCallback(InstancePtr->ConnectRef);
+        }
+    }
+
+    /* Vsync event has occurred */
+    if ((Event) & (XV_HDMITX_PIO_IN_VS_MASK)) {
+
+        // Check if user callback has been registered
+        if (InstancePtr->IsVsCallbackSet) {
+            InstancePtr->VsCallback(InstancePtr->VsRef);
+        }
+    }
+
+    /* Link ready event has occurred */
+    if ((Event) & (XV_HDMITX_PIO_IN_LNK_RDY_MASK)) {
+
+        // Check the link status
+        if ((Data) & (XV_HDMITX_PIO_IN_LNK_RDY_MASK)) {
+            // Set stream status to up
+            InstancePtr->Stream.State = XV_HDMITX_STATE_STREAM_UP;
+
+            /* Enable the AUX peripheral */
+            XV_HdmiTx_AuxEnable(InstancePtr);
+
+            /* Enable the AUX peripheral interrupt */
+            XV_HdmiTx_AuxIntrEnable(InstancePtr);
+
+            /* Enable audio */
+            //XV_HdmiTx_AudioEnable(InstancePtr);
+
+            // Check if user callback has been registered
+            if (InstancePtr->IsStreamUpCallbackSet) {
+                InstancePtr->StreamUpCallback(InstancePtr->StreamUpRef);
+            }
+        }
+
+        // Link down
+        else {
+            // Set stream status to down
+            InstancePtr->Stream.State = XV_HDMITX_STATE_STREAM_DOWN;
+
+            /* Disable Audio */
+            XV_HdmiTx_AudioDisable(InstancePtr);
+
+            /* Disable AUX */
+            XV_HdmiTx_AuxDisable(InstancePtr);
+
+            // Check if user callback has been registered
+            if (InstancePtr->IsStreamDownCallbackSet) {
+                InstancePtr->StreamDownCallback(InstancePtr->StreamDownRef);
+            }
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the HDMI TX DDC peripheral interrupt handler.
+*
+* This handler reads DDC Status register and determines the timeout. It also
+* determines the state and based on that performs required operation.
+*
+*
+* @param    InstancePtr is a pointer to the HDMI TX core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiTx_DdcIntrHandler(XV_HdmiTx *InstancePtr)
+{
+    u32 Data;
+
+    /* Read DDC Status register */
+    Data = XV_HdmiTx_ReadReg(InstancePtr->Config.BaseAddress,
+                            (XV_HDMITX_DDC_STA_OFFSET));
+    Data = Data; //squash unused variable compiler warning
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_sinit.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_sinit.c
new file mode 100644
index 0000000..6a8aa3e
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_sinit.c
@@ -0,0 +1,93 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx_sinit.c
+*
+* This file contains static initialization method for Xilinx HDMI TX core.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00         10/07/15 Initial release.
+
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmitx.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function returns a reference to an XV_HdmiTx_Config structure based
+* on the core id, <i>DeviceId</i>. The return value will refer to an entry in
+* the device configuration table defined in the xv_hdmitx_g.c file.
+*
+* @param    DeviceId is the unique core ID of the HDMI TX core for the
+*       lookup operation.
+*
+* @return   XV_HdmiTx_LookupConfig returns a reference to a config record
+*       in the configuration table (in xv_hdmitx_g.c) corresponding
+*       to <i>DeviceId</i>, or NULL if no match is found.
+*
+* @note     None.
+*
+******************************************************************************/
+XV_HdmiTx_Config *XV_HdmiTx_LookupConfig(u16 DeviceId)
+{
+    extern XV_HdmiTx_Config
+            XV_HdmiTx_ConfigTable[XPAR_XV_HDMITX_NUM_INSTANCES];
+    XV_HdmiTx_Config *CfgPtr = NULL;
+    u32 Index;
+
+    /* Checking for device id for which instance it is matching */
+    for (Index = (u32)0x0; Index < (u32)(XPAR_XV_HDMITX_NUM_INSTANCES);
+                                Index++) {
+
+        /* Assigning address of config table if both device ids
+         * are matched
+         */
+        if (XV_HdmiTx_ConfigTable[Index].DeviceId == DeviceId) {
+            CfgPtr = &XV_HdmiTx_ConfigTable[Index];
+            break;
+        }
+    }
+
+    return (XV_HdmiTx_Config *)CfgPtr;
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.c
new file mode 100644
index 0000000..481fb6a
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.c
@@ -0,0 +1,695 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx_vsif.c
+*
+* Contains function definitions related to Vendor Specific InfoFrames used
+* in HDMI. Please see xv_hdmitx_vsif.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  yh     15/01/15 Initial release for 3D video support
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include <linux/string.h>
+#include "xv_hdmitx_vsif.h"
+#include "xv_hdmitx.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions *****************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/**************************** Type Definitions *******************************/
+
+/*************************** Function Prototypes *****************************/
+static int XV_HdmiTx_VSIF_Extract3DInfo(u8 *VSIFRaw, XV_HdmiTx_3D_Info *InstancePtr);
+static XV_HdmiTx_3D_Struct_Field XV_HdmiTx_VSIF_Conv3DInfoTo3DStruct(XVidC_3DInfo *InfoPtr);
+static XV_HdmiTx_3D_Sampling_Method XV_HdmiTx_VSIF_Conv3DInfoTo3DSampMethod(XVidC_3DInfo *InfoPtr);
+static XV_HdmiTx_3D_Sampling_Position XV_HdmiTx_VSIF_Conv3DInfoTo3DSampPos(XVidC_3DInfo *InfoPtr);
+static XVidC_3DFormat XV_HdmiTx_VSIF_Conv3DStructTo3DFormat(XV_HdmiTx_3D_Struct_Field Value);
+static XVidC_3DSamplingMethod XV_HdmiTx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HdmiTx_3D_Sampling_Method Value);
+static XVidC_3DSamplingPosition XV_HdmiTx_VSIF_Conv3DSampPosTo3DSampPos(XV_HdmiTx_3D_Sampling_Position Value);
+
+/************************** Variable Definitions *****************************/
+
+/*************************** Function Definitions ****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the 3D format from XVidC_3DInfo
+* and returns a XV_HdmiTx_3D_Struct_Field type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiTx_3D_Struct_Field XV_HdmiTx_VSIF_Conv3DInfoTo3DStruct(XVidC_3DInfo *InfoPtr)
+{
+    switch(InfoPtr->Format) {
+        case XVIDC_3D_FRAME_PACKING :
+            return XV_HDMITX_3D_STRUCT_FRAME_PACKING;
+            break;
+
+        case XVIDC_3D_FIELD_ALTERNATIVE :
+            return XV_HDMITX_3D_STRUCT_FIELD_ALTERNATIVE;
+            break;
+
+        case XVIDC_3D_LINE_ALTERNATIVE :
+            return XV_HDMITX_3D_STRUCT_LINE_ALTERNATIVE;
+            break;
+
+        case XVIDC_3D_SIDE_BY_SIDE_FULL :
+            return XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_FULL;
+            break;
+
+        case XVIDC_3D_TOP_AND_BOTTOM_HALF :
+            return XV_HDMITX_3D_STRUCT_TOP_AND_BOTTOM;
+            break;
+
+        case XVIDC_3D_SIDE_BY_SIDE_HALF :
+            return XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF;
+            break;
+
+        default :
+            return XV_HDMITX_3D_STRUCT_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the sampling method info from XVidC_3DInfo
+* and returns a XV_HdmiTx_3D_Sampling_Method type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiTx_3D_Sampling_Method XV_HdmiTx_VSIF_Conv3DInfoTo3DSampMethod(XVidC_3DInfo *InfoPtr)
+{
+    switch(InfoPtr->Sampling.Method) {
+        case XVIDC_3D_SAMPLING_HORIZONTAL :
+            return XV_HDMITX_3D_SAMPLING_HORIZONTAL;
+            break;
+
+        case XVIDC_3D_SAMPLING_QUINCUNX :
+            return XV_HDMITX_3D_SAMPLING_QUINCUNX;
+            break;
+
+        default :
+            return XV_HDMITX_3D_SAMPLING_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the sampling position info from XVidC_3DInfo
+* and returns a XV_HdmiTx_3D_Sampling_Position type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiTx_3D_Sampling_Position XV_HdmiTx_VSIF_Conv3DInfoTo3DSampPos(XVidC_3DInfo *InfoPtr)
+{
+    switch(InfoPtr->Sampling.Position) {
+        case XVIDC_3D_SAMPPOS_OLOR :
+            return XV_HDMITX_3D_SAMPPOS_OLOR;
+            break;
+
+        case XVIDC_3D_SAMPPOS_OLER :
+            return XV_HDMITX_3D_SAMPPOS_OLER;
+            break;
+
+        case XVIDC_3D_SAMPPOS_ELOR :
+            return XV_HDMITX_3D_SAMPPOS_ELOR;
+            break;
+
+        case XVIDC_3D_SAMPPOS_ELER :
+            return XV_HDMITX_3D_SAMPPOS_ELER;
+            break;
+
+        default :
+            return XV_HDMITX_3D_SAMPPOS_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiTx_3D_Struct_Field type
+* to a XVidC_3DFormat type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DFormat XV_HdmiTx_VSIF_Conv3DStructTo3DFormat(XV_HdmiTx_3D_Struct_Field Value)
+{
+    switch(Value) {
+        case XV_HDMITX_3D_STRUCT_FRAME_PACKING :
+            return XVIDC_3D_FRAME_PACKING;
+            break;
+
+        case XV_HDMITX_3D_STRUCT_FIELD_ALTERNATIVE :
+            return XVIDC_3D_FIELD_ALTERNATIVE;
+            break;
+
+        case XV_HDMITX_3D_STRUCT_LINE_ALTERNATIVE :
+            return XVIDC_3D_LINE_ALTERNATIVE;
+            break;
+
+        case XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_FULL :
+            return XVIDC_3D_SIDE_BY_SIDE_FULL;
+            break;
+
+        case XV_HDMITX_3D_STRUCT_TOP_AND_BOTTOM :
+            return XVIDC_3D_TOP_AND_BOTTOM_HALF;
+            break;
+
+        case XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF :
+            return XVIDC_3D_SIDE_BY_SIDE_HALF;
+            break;
+
+        default :
+            return XVIDC_3D_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiTx_3D_Sampling_Method type
+* to a XVidC_3DSamplingMethod type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DSamplingMethod XV_HdmiTx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HdmiTx_3D_Sampling_Method Value)
+{
+    switch(Value) {
+        case XV_HDMITX_3D_SAMPLING_HORIZONTAL :
+            return XVIDC_3D_SAMPLING_HORIZONTAL;
+            break;
+
+        case XV_HDMITX_3D_SAMPLING_QUINCUNX :
+            return XVIDC_3D_SAMPLING_QUINCUNX;
+            break;
+
+        default :
+            return XVIDC_3D_SAMPLING_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiTx_3D_Sampling_Position type
+* to a XVidC_3DSamplingPosition type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DSamplingPosition XV_HdmiTx_VSIF_Conv3DSampPosTo3DSampPos(XV_HdmiTx_3D_Sampling_Position Value)
+{
+    switch(Value) {
+        case XV_HDMITX_3D_SAMPPOS_OLOR :
+            return XVIDC_3D_SAMPPOS_OLOR;
+            break;
+
+        case XV_HDMITX_3D_SAMPPOS_OLER :
+            return XVIDC_3D_SAMPPOS_OLER;
+            break;
+
+        case XV_HDMITX_3D_SAMPPOS_ELOR :
+            return XVIDC_3D_SAMPPOS_ELOR;
+            break;
+
+        case XV_HDMITX_3D_SAMPPOS_ELER :
+            return XVIDC_3D_SAMPPOS_ELER;
+            break;
+
+        default :
+            return XVIDC_3D_SAMPPOS_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function parses a Vendor Specific InfoFrame (VSIF).
+*
+* @param AuxPtr is a pointer to the XV_HdmiTx_Rx_Aux instance.
+*
+* @param VSIFPtr is a pointer to the XV_HdmiTx_VSIF instance.
+*
+* @return
+*  - XST_SUCCESS if operation was successful
+*  - XST_FAILURE if an error was detected during parsing
+*
+******************************************************************************/
+int XV_HdmiTx_VSIF_ParsePacket(XV_HdmiTx_Aux *AuxPtr, XV_HdmiTx_VSIF  *VSIFPtr)
+{
+    u8 *pData;
+    u32 temp;
+    int Index;
+    int Status = XST_FAILURE;
+
+    /* Verify arguments */
+    Xil_AssertNonvoid(AuxPtr != NULL);
+    Xil_AssertNonvoid(VSIFPtr != NULL);
+
+    pData = &AuxPtr->Data.Byte[0];
+
+    /* Clear the instance */
+    (void)memset((void *)VSIFPtr, 0, sizeof(XV_HdmiTx_VSIF));
+
+    /* Set packet version */
+    VSIFPtr->Version = AuxPtr->Header.Byte[1];
+
+    /* IEEE Registration Identifier */
+    for (Index = 0; Index < 3; Index++){
+        temp = pData[Index+1];
+        VSIFPtr->IEEE_ID |= (temp << (Index * 8));
+    }
+
+    /* HDMI Video Format */
+    temp = (pData[4] & XV_HDMITX_VSIF_VIDEO_FORMAT_MASK) >> XV_HDMITX_VSIF_VIDEO_FORMAT_SHIFT;
+    if (temp >= XV_HDMITX_VSIF_VF_UNKNOWN) {
+        VSIFPtr->Format = XV_HDMITX_VSIF_VF_UNKNOWN;
+    }
+    else {
+        VSIFPtr->Format = (XV_HdmiTx_VSIF_Video_Format)temp;
+    }
+
+    switch(VSIFPtr->Format) {
+        /* HDMI VIC */
+        case XV_HDMITX_VSIF_VF_EXTRES :
+            VSIFPtr->HDMI_VIC = pData[5];
+            Status = XST_SUCCESS;
+            break;
+
+        /* 3D Information */
+        case XV_HDMITX_VSIF_VF_3D :
+            Status = XV_HdmiTx_VSIF_Extract3DInfo(pData, &VSIFPtr->Info_3D);
+            break;
+
+        /* No additional information */
+        case XV_HDMITX_VSIF_VF_NOINFO :
+            Status = XST_SUCCESS;
+            break;
+
+        default :
+
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the 3D information from the
+* Vendor Specific InfoFrame (VSIF).
+*
+* @param VSIFRaw is a pointer to the VSIF payload.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTx_3D_Info instance.
+*
+* @return
+*  - XST_SUCCESS if operation was successful
+*  - XST_FAILURE if an error was detected during parsing
+*
+******************************************************************************/
+int XV_HdmiTx_VSIF_Extract3DInfo(u8 *VSIFRaw, XV_HdmiTx_3D_Info *InstancePtr)
+{
+    u8 *pData;
+    u8 temp;
+
+    /* Verify arguments */
+    Xil_AssertNonvoid(VSIFRaw != NULL);
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* 3D info starts at byte PB5 */
+    pData = &VSIFRaw[5];
+
+    /* Clear the instance */
+    (void)memset((void *)InstancePtr, 0, sizeof(XV_HdmiTx_3D_Info));
+
+    /* Set default values for the items that are not always set */
+    InstancePtr->Stream.Sampling.Method = XV_HdmiTx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HDMITX_3D_SAMPLING_UNKNOWN);
+    InstancePtr->Stream.Sampling.Position = XV_HdmiTx_VSIF_Conv3DSampPosTo3DSampPos(XV_HDMITX_3D_SAMPPOS_UNKNOWN);
+
+    /* Detect 3D Metadata presence */
+    if (*pData & XV_HDMITX_3D_META_PRESENT_MASK)
+        InstancePtr->MetaData.IsPresent = TRUE;
+    else
+        InstancePtr->MetaData.IsPresent = FALSE;
+
+    /* Extract the 3D_Structure */
+    temp = (*pData & XV_HDMITX_3D_STRUCT_MASK) >> XV_HDMITX_3D_STRUCT_SHIFT;
+    if (temp >= XV_HDMITX_3D_STRUCT_UNKNOWN || temp == 7) {
+        InstancePtr->Stream.Format = XV_HdmiTx_VSIF_Conv3DStructTo3DFormat(XV_HDMITX_3D_STRUCT_UNKNOWN);
+    }
+    else {
+        InstancePtr->Stream.Format = XV_HdmiTx_VSIF_Conv3DStructTo3DFormat((XV_HdmiTx_3D_Struct_Field)temp);
+    }
+
+    /* Extract the 3D_Ext_Data */
+    if (temp >= XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF) {
+        /* Go to next byte */
+        pData++;
+
+        /* Extract the sampling method */
+        temp = (*pData & XV_HDMITX_3D_SAMP_METHOD_MASK) >> XV_HDMITX_3D_SAMP_METHOD_SHIFT;
+        if (temp >= XV_HDMITX_3D_SAMPLING_UNKNOWN)
+            InstancePtr->Stream.Sampling.Method = XV_HdmiTx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HDMITX_3D_SAMPLING_UNKNOWN);
+        else
+            InstancePtr->Stream.Sampling.Method = XV_HdmiTx_VSIF_Conv3DSampMethodTo3DSampMethod((XV_HdmiTx_3D_Sampling_Method)temp);
+
+        /* Extract the sampling position */
+        temp = (*pData & XV_HDMITX_3D_SAMP_POS_MASK) >> XV_HDMITX_3D_SAMP_POS_SHIFT;
+        if (temp >= XV_HDMITX_3D_SAMPPOS_UNKNOWN)
+            InstancePtr->Stream.Sampling.Position = XV_HdmiTx_VSIF_Conv3DSampPosTo3DSampPos(XV_HDMITX_3D_SAMPPOS_UNKNOWN);
+        else
+            InstancePtr->Stream.Sampling.Position = XV_HdmiTx_VSIF_Conv3DSampPosTo3DSampPos((XV_HdmiTx_3D_Sampling_Position)temp);
+    }
+
+    /* Extract the 3D_Metadata */
+    if (InstancePtr->MetaData.IsPresent) {
+        /* Go to next byte */
+        pData++;
+
+        /* Extract the 3D Metadata type */
+        temp = (*pData & XV_HDMITX_3D_META_TYPE_MASK) >> XV_HDMITX_3D_META_TYPE_SHIFT;
+        if (temp >= XV_HDMITX_3D_META_UNKNOWN)
+            InstancePtr->MetaData.Type = XV_HDMITX_3D_META_UNKNOWN;
+        else
+            InstancePtr->MetaData.Type = (XV_HdmiTx_3D_MetaData_Type)temp;
+
+        /* Extract the 3D Metadata length */
+        InstancePtr->MetaData.Length = (*pData & XV_HDMITX_3D_META_LENGTH_MASK) >> XV_HDMITX_3D_META_LENGTH_SHIFT;
+
+        /* Extract the 3D Metadata */
+        int i;
+        for (i = 0; i<InstancePtr->MetaData.Length; i++){
+            if (i < XV_HDMITX_3D_META_MAX_SIZE)
+                InstancePtr->MetaData.Data[i] = *(++pData);
+            else
+                return XST_FAILURE;
+        }
+    }
+
+    return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function generates a Vendor Specific InfoFrame (VSIF).
+*
+* @param VSIFPtr is a pointer to the XV_HdmiTx_VSIF instance.
+*
+* @param AuxPtr is a pointer to the XV_HdmiTx_Tx_Aux instance.
+*
+* @return
+*  - XST_SUCCESS if operation was successful
+*  - XST_FAILURE if an error was detected during generation
+*
+******************************************************************************/
+int XV_HdmiTx_VSIF_GeneratePacket(XV_HdmiTx_VSIF  *VSIFPtr, XV_HdmiTx_Aux *AuxPtr)
+{
+    u8 Index = 0;
+    u8 ByteCount = 0;
+    u8 Crc = 0;
+
+    XV_HdmiTx_3D_Struct_Field Format;
+    XV_HdmiTx_3D_Sampling_Method SampMethod;
+    XV_HdmiTx_3D_Sampling_Position SampPos;
+
+    /* Verify arguments */
+    Xil_AssertNonvoid(VSIFPtr != NULL);
+    Xil_AssertNonvoid(AuxPtr != NULL);
+
+    /* Header, Packet type*/
+    AuxPtr->Header.Byte[0] = 0x81;
+
+    /* Version */
+    AuxPtr->Header.Byte[1] = VSIFPtr->Version;
+
+    /* Checksum (this will be calculated by the HDMI TX IP) */
+    AuxPtr->Header.Byte[3] = 0;
+
+    /* Data */
+
+    /* IEEE Registration ID */
+    AuxPtr->Data.Byte[++ByteCount] = VSIFPtr->IEEE_ID;
+    AuxPtr->Data.Byte[++ByteCount] = VSIFPtr->IEEE_ID >> 8;
+    AuxPtr->Data.Byte[++ByteCount] = VSIFPtr->IEEE_ID >> 16;
+
+    AuxPtr->Data.Byte[++ByteCount] = (VSIFPtr->Format << XV_HDMITX_VSIF_VIDEO_FORMAT_SHIFT) & XV_HDMITX_VSIF_VIDEO_FORMAT_MASK;
+
+    switch (VSIFPtr->Format) {
+        /* Extended resolution format present */
+        case XV_HDMITX_VSIF_VF_EXTRES :
+            /* HDMI_VIC */
+            AuxPtr->Data.Byte[++ByteCount] = VSIFPtr->HDMI_VIC;
+            break;
+
+        /* 3D format indication present */
+        case XV_HDMITX_VSIF_VF_3D :
+            /* 3D_Structure */
+            Format = XV_HdmiTx_VSIF_Conv3DInfoTo3DStruct(&VSIFPtr->Info_3D.Stream);
+            AuxPtr->Data.Byte[++ByteCount] = (Format << XV_HDMITX_3D_STRUCT_SHIFT) & XV_HDMITX_3D_STRUCT_MASK;
+
+            /* 3D_Meta_present*/
+            AuxPtr->Data.Byte[ByteCount] |= (VSIFPtr->Info_3D.MetaData.IsPresent << XV_HDMITX_3D_META_PRESENT_SHIFT) & XV_HDMITX_3D_META_PRESENT_MASK;
+
+            /* 3D_Ext_Data */
+            if (Format >= XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF) {
+                SampMethod = XV_HdmiTx_VSIF_Conv3DInfoTo3DSampMethod(&VSIFPtr->Info_3D.Stream);
+                AuxPtr->Data.Byte[++ByteCount] = (SampMethod << XV_HDMITX_3D_SAMP_METHOD_SHIFT) & XV_HDMITX_3D_SAMP_METHOD_MASK;
+                SampPos = XV_HdmiTx_VSIF_Conv3DInfoTo3DSampPos(&VSIFPtr->Info_3D.Stream);
+                AuxPtr->Data.Byte[ByteCount] |= (SampPos << XV_HDMITX_3D_SAMP_POS_SHIFT) & XV_HDMITX_3D_SAMP_POS_MASK;
+            }
+
+            /* 3D Metadata */
+            if (VSIFPtr->Info_3D.MetaData.IsPresent) {
+                /* 3D_Metadata_type */
+                AuxPtr->Data.Byte[++ByteCount] = (VSIFPtr->Info_3D.MetaData.Type << XV_HDMITX_3D_META_TYPE_SHIFT) & XV_HDMITX_3D_META_TYPE_MASK;
+                /* 3D_Metadata_length */
+                AuxPtr->Data.Byte[ByteCount] |= (VSIFPtr->Info_3D.MetaData.Length << XV_HDMITX_3D_META_LENGTH_SHIFT) & XV_HDMITX_3D_META_LENGTH_MASK;
+
+                /* 3D_Metadata */
+                for (Index = 0; Index < VSIFPtr->Info_3D.MetaData.Length; Index++) {
+                    AuxPtr->Data.Byte[++ByteCount] = VSIFPtr->Info_3D.MetaData.Data[Index];
+                }
+            }
+
+            break;
+
+        default :
+            break;
+    }
+
+    /* Set the payload length */
+    AuxPtr->Header.Byte[2] = ByteCount;
+
+    /* Calculate checksum */
+    /* Header */
+    for (Index = 0; Index < 3; Index++) {
+        Crc += AuxPtr->Header.Byte[Index];
+    }
+
+    /* Data */
+    for (Index = 1; Index <= ByteCount; Index++) {
+        Crc += AuxPtr->Data.Byte[Index];
+    }
+
+    /* Set the checksum */
+    AuxPtr->Data.Byte[0] = 256 - Crc;
+
+    return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function displays the contents of an XV_HdmiTx_VSIF instance.
+*
+* @param VSIFPtr is a pointer to the XV_HdmiTx_VSIF instance.
+*
+* @return None.
+*
+******************************************************************************/
+void XV_HdmiTx_VSIF_DisplayInfo(XV_HdmiTx_VSIF  *VSIFPtr)
+{
+    switch (VSIFPtr->Format) {
+        /* Extended resolution format present */
+        case XV_HDMITX_VSIF_VF_EXTRES :
+            /* HDMI_VIC */
+            xil_printf("HDMI_VIC : %d\n\r", VSIFPtr->HDMI_VIC);
+            break;
+
+        /* 3D format indication present */
+        case XV_HDMITX_VSIF_VF_3D :
+            /* 3D_Structure */
+            xil_printf("3D Format : %s\n\r", XV_HdmiTx_VSIF_3DStructToString(XV_HdmiTx_VSIF_Conv3DInfoTo3DStruct(&VSIFPtr->Info_3D.Stream)));
+
+            /* 3D_Ext_Data */
+            if (XV_HdmiTx_VSIF_Conv3DInfoTo3DStruct(&VSIFPtr->Info_3D.Stream) >= XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF) {
+                xil_printf("Sampling Method : %s\n\r", XV_HdmiTx_VSIF_3DSampMethodToString(XV_HdmiTx_VSIF_Conv3DInfoTo3DSampMethod(&VSIFPtr->Info_3D.Stream)));
+                xil_printf("Sampling Position : %s\n\r", XV_HdmiTx_VSIF_3DSampPosToString(XV_HdmiTx_VSIF_Conv3DInfoTo3DSampPos(&VSIFPtr->Info_3D.Stream)));
+            }
+
+            /* 3D Metadata */
+            if (VSIFPtr->Info_3D.MetaData.IsPresent) {
+                /* 3D_Metadata_type */
+
+                /* 3D_Metadata */
+            }
+
+            break;
+
+        default :
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiTx_3D_Struct_Field.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiTx_VSIF_3DStructToString(XV_HdmiTx_3D_Struct_Field Item)
+{
+    switch(Item) {
+        case XV_HDMITX_3D_STRUCT_FRAME_PACKING :
+            return (char*) "Frame Packing";
+
+        case XV_HDMITX_3D_STRUCT_FIELD_ALTERNATIVE :
+            return (char*) "Field Alternative";
+
+        case XV_HDMITX_3D_STRUCT_LINE_ALTERNATIVE :
+            return (char*) "Line Alternative";
+
+        case XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_FULL :
+            return (char*) "Side-by-Side(Full)";
+
+        case XV_HDMITX_3D_STRUCT_L_DEPTH :
+            return (char*) "L + Depth";
+
+        case XV_HDMITX_3D_STRUCT_L_DEPTH_GRAPH_GDEPTH :
+            return (char*) "L + Depth + Graphics + Graphics-depth";
+
+        case XV_HDMITX_3D_STRUCT_TOP_AND_BOTTOM :
+            return (char*) "Top-and-Bottom";
+
+        case XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF :
+            return (char*) "Side-by-Side(Half)";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiTx_3D_Sampling_Method.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiTx_VSIF_3DSampMethodToString(XV_HdmiTx_3D_Sampling_Method Item)
+{
+    switch(Item) {
+        case XV_HDMITX_3D_SAMPLING_HORIZONTAL :
+            return (char*) "Horizontal Sub-Sampling";
+
+        case XV_HDMITX_3D_SAMPLING_QUINCUNX :
+            return (char*) "Quincunx Matrix";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiTx_3D_Sampling_Position.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiTx_VSIF_3DSampPosToString(XV_HdmiTx_3D_Sampling_Position Item)
+{
+    switch(Item) {
+        case XV_HDMITX_3D_SAMPPOS_OLOR :
+            return (char*) "Odd/Left, Odd/Right";
+
+        case XV_HDMITX_3D_SAMPPOS_OLER :
+            return (char*) "Odd/Left, Even/Right";
+
+        case XV_HDMITX_3D_SAMPPOS_ELOR :
+            return (char*) "Even/Left, Odd/Right";
+
+        case XV_HDMITX_3D_SAMPPOS_ELER :
+            return (char*) "Even/Left, Even/Right";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.h
new file mode 100644
index 0000000..5e16b1d
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitx_vsif.h
@@ -0,0 +1,174 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitx_vsif.h
+*
+* This is the main header file for Vendor Specific InfoFrames used in HDMI.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  yh     15/01/15 Initial release for 3D video support
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XV_HDMITX_VSIF_H_
+/* Prevent circular inclusions by using protection macros. */
+#define XV_HDMITX_VSIF_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************* Include Files ********************************/
+#include "xil_types.h"
+#include "xil_assert.h"
+#include "xstatus.h"
+
+#include "xvidc.h"
+
+/************************** Constant Definitions ******************************/
+
+/** @name Vendor Specific InfoFrame Field Masks and Shifts.
+ * @{
+ */
+#define XV_HDMITX_VSIF_VIDEO_FORMAT_SHIFT 5
+#define XV_HDMITX_VSIF_VIDEO_FORMAT_MASK (0x7 << XV_HDMITX_VSIF_VIDEO_FORMAT_SHIFT)
+
+#define XV_HDMITX_3D_STRUCT_SHIFT 4
+#define XV_HDMITX_3D_STRUCT_MASK (0xF << XV_HDMITX_3D_STRUCT_SHIFT)
+
+#define XV_HDMITX_3D_SAMP_METHOD_SHIFT 6
+#define XV_HDMITX_3D_SAMP_METHOD_MASK (0x3 << XV_HDMITX_3D_SAMP_METHOD_SHIFT)
+
+#define XV_HDMITX_3D_SAMP_POS_SHIFT 4
+#define XV_HDMITX_3D_SAMP_POS_MASK (0x3 << XV_HDMITX_3D_SAMP_POS_SHIFT)
+
+#define XV_HDMITX_3D_META_PRESENT_SHIFT 3
+#define XV_HDMITX_3D_META_PRESENT_MASK (0x1 << XV_HDMITX_3D_META_PRESENT_SHIFT)
+
+#define XV_HDMITX_3D_META_TYPE_SHIFT 5
+#define XV_HDMITX_3D_META_TYPE_MASK (0x7 << XV_HDMITX_3D_META_TYPE_SHIFT)
+
+#define XV_HDMITX_3D_META_LENGTH_SHIFT 0
+#define XV_HDMITX_3D_META_LENGTH_MASK (0x1F << XV_HDMITX_3D_META_LENGTH_SHIFT)
+/* @} */
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * HDMI Video Format
+ */
+typedef enum {
+    XV_HDMITX_VSIF_VF_NOINFO = 0, /**<No additional HDMI video format is presented */
+    XV_HDMITX_VSIF_VF_EXTRES = 1, /**<Extended resolution format present */
+    XV_HDMITX_VSIF_VF_3D     = 2, /**<3D format indication present */
+    XV_HDMITX_VSIF_VF_UNKNOWN
+} XV_HdmiTx_VSIF_Video_Format;
+
+/**
+ * 3D structure definitions as defined in the HDMI 1.4a specification
+ */
+typedef enum {
+    XV_HDMITX_3D_STRUCT_FRAME_PACKING        = 0, /**<Frame packing */
+    XV_HDMITX_3D_STRUCT_FIELD_ALTERNATIVE    = 1, /**<Field alternative */
+    XV_HDMITX_3D_STRUCT_LINE_ALTERNATIVE     = 2, /**<Line alternative */
+    XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_FULL    = 3, /**<Side-by-side (full) */
+    XV_HDMITX_3D_STRUCT_L_DEPTH              = 4, /**<L + depth */
+    XV_HDMITX_3D_STRUCT_L_DEPTH_GRAPH_GDEPTH = 5, /**<L + depth + graphics + graphics-depth */
+    XV_HDMITX_3D_STRUCT_TOP_AND_BOTTOM       = 6, /**<Top-and-bottom */
+    // 7 is reserved for future use
+    XV_HDMITX_3D_STRUCT_SIDE_BY_SIDE_HALF    = 8, /**<Side-by-side (half) */
+    XV_HDMITX_3D_STRUCT_UNKNOWN
+} XV_HdmiTx_3D_Struct_Field;
+
+/**
+ * Sub-sampling methods for Side-by-side(half)
+ */
+typedef enum {
+    XV_HDMITX_3D_SAMPLING_HORIZONTAL = 0, /**<Horizontal sub-sampling */
+    XV_HDMITX_3D_SAMPLING_QUINCUNX   = 1, /**<Quincunx matrix */
+    XV_HDMITX_3D_SAMPLING_UNKNOWN
+} XV_HdmiTx_3D_Sampling_Method;
+
+/**
+ * Sub-sampling positions for the sub-sampling methods
+ */
+typedef enum {
+    XV_HDMITX_3D_SAMPPOS_OLOR = 0, /**<Odd/Left, Odd/Right */
+    XV_HDMITX_3D_SAMPPOS_OLER = 1, /**<Odd/Left, Even/Right */
+    XV_HDMITX_3D_SAMPPOS_ELOR = 2, /**<Even/Left, Odd/Right */
+    XV_HDMITX_3D_SAMPPOS_ELER = 3, /**<Even/Left, Even/Right */
+    XV_HDMITX_3D_SAMPPOS_UNKNOWN
+} XV_HdmiTx_3D_Sampling_Position;
+
+/**
+ * 3D Metadata types
+ */
+typedef enum {
+    XV_HDMITX_3D_META_PARALLAX = 0, /**<Parallax information */
+    XV_HDMITX_3D_META_UNKNOWN
+} XV_HdmiTx_3D_MetaData_Type;
+
+
+// 8 is the maximum size for currently defined meta types (HDMI 1.4a)
+#define XV_HDMITX_3D_META_MAX_SIZE 8 /**<Maximum 3D Metadata size in bytes */
+
+/**
+ * Structure for 3D meta data
+ */
+typedef struct {
+    u8                     IsPresent;                    /**<Indicates 3D metadata presence */
+    XV_HdmiTx_3D_MetaData_Type Type;                         /**<Type */
+    u8                     Length;                       /**<Length in bytes */
+    u8                     Data[XV_HDMITX_3D_META_MAX_SIZE]; /**<Data */
+} XV_HdmiTx_3D_MetaData;
+
+/**
+ * Structure containing 3D information
+ */
+typedef struct {
+    XVidC_3DInfo               Stream;
+    XV_HdmiTx_3D_MetaData          MetaData;   /**<3D Metadata */
+} XV_HdmiTx_3D_Info;
+
+/**
+ * Structure for holding the VSIF.
+ * Format indicates the used union member.
+ */
+typedef struct {
+    u8                      Version; /**<Version */
+    u32                     IEEE_ID; /**<IEEE Registration Identifier */
+    XV_HdmiTx_VSIF_Video_Format Format;  /**<HDMI Video Format */
+
+    union {
+        u8            HDMI_VIC; /**<XV_HDMITX_VSIF_VF_EXTRES: HDMI Video Format Identification Code */
+        XV_HdmiTx_3D_Info Info_3D;  /**<XV_HDMITX_VSIF_VF_3D: 3D Information */
+    };
+} XV_HdmiTx_VSIF;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* End of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.c
new file mode 100644
index 0000000..baafe3e
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.c
@@ -0,0 +1,2184 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitxss.c
+*
+* This is main code of Xilinx HDMI Transmitter Subsystem device driver.
+* Please see xv_hdmitxss.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.10  MG     17/12/16 Fixed issue in function SetAudioChannels
+*                       Updated function XV_HdmiTxSs_SendAuxInfoframe
+* 1.2   yh     12/01/16 Check vtc existance before configuring it
+* 1.3   yh     15/01/16 Add 3D Support
+* 1.4   yh     20/01/16 Added remapper support
+* 1.5   yh     01/02/16 Added set_ppc api
+* 1.6   yh     01/02/16 Removed xil_print "Cable (dis)connected"
+* 1.7   yh     15/02/16 Added default value to XV_HdmiTxSs_ConfigRemapper
+* 1.8   MG     03/02/16 Added HDCP support
+* 1.9   MG     09/03/16 Added XV_HdmiTxSs_SetHdmiMode and XV_HdmiTxSs_SetDviMode
+*                       Removed reduced blanking support
+* 1.10  MH     03/15/16 Moved HDCP 2.2 reset from stream up/down callback to
+*                       connect callback
+* 1.11  YH     18/03/16 Add XV_HdmiTxSs_SendGenericAuxInfoframe function
+* 1.12  MH     23/04/16 1. HDCP 1.x driver now uses AXI timer 4.1, so updated
+*                       to use AXI Timer config structure to determine timer
+*                       clock frequency
+*                       2. HDCP 1.x driver has fixed the problem where the
+*                       reset for the receiver causes the entire DDC peripheral
+*                       to get reset. Based on this change the driver has been
+*                       updated to use XV_HdmiTxSs_HdcpReset and
+*                       XV_HdmiTxSs_HdcpReset functions directly.
+*                       3. Updated XV_HdmiTxSs_HdcpEnable and
+*                       XV_HdmiTxSs_HdcpEnable functions to ensure that
+*                       HDCP 1.4 and 2.2 are mutually exclusive.
+*                       This fixes the problem where HDCP 1.4 and 2.2
+*                       state machines are running simultaneously.
+* 1.13   MH    23/06/16 Added HDCP repeater support.
+* 1.14   YH    18/07/16 1. Replace xil_print with xdbg_printf.
+*                       2. XV_HdmiTx_VSIF VSIF global variable local to
+*                        XV_HdmiTxSs_SendVSInfoframe
+*                       3. Replace MB_Sleep() with usleep
+*                       4. Remove checking VideoMode < XVIDC_VM_NUM_SUPPORTED in
+*                       XV_HdmiTxSs_SetStream to support customized video format
+* 1.15   YH    25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiTxSs_CfgInitialize
+* 1.16   YH    04/08/16 Remove unused functions
+*                       XV_HdmiTxSs_GetSubSysStruct
+* 1.17   MH    08/08/16 Updates to optimize out HDCP when excluded.
+* 1.18   YH    17/08/16 Remove sleep in XV_HdmiTxSs_ResetRemapper
+*                       Added Event Log
+*                       Combine Report function into one ReportInfo
+* 1.19   YH    27/08/16 Remove unused functions XV_HdmiTxSs_SetUserTimerHandler
+*                       XV_HdmiTxSs_WaitUs
+* 1.20   MH    08/10/16 Update function call sequence in
+*                       XV_HdmiTxSs_StreamUpCallback
+*
+* 1.1x   mmo   04/11/16 Updated the XV_HdmiTxSs_SetAudioChannels API which
+*                       currently calls XV_HdmiTx_SetAudioChannels driver,
+*                       which sets the Audio Channels
+*                       accordingly. This fixed is made during v1.2 (2016.1)
+* 1.21  YH     14/11/16 Added API to enable/disable YUV420/Pixel Repeat Mode
+*                       for video bridge
+* 1.22  YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.23  mmo    03/01/17 Move HDCP Related API to xv_hdmitxss_hdcp.c
+*                       Remove inclusion of the xenv.h and sleep.h as it not
+*                           used
+*                       Replaced "print" with "xil_printf"
+*                       Replace Carriage Return (\r) and Line Feed (\n) order,\
+*                           where the Carriage Return + Line Feed order is used.
+* 1.24  mmo    02/03/17 Added XV_HdmiTxSs_ReadEdidSegment API for Multiple
+*                             Segment Support and HDMI Compliance Test
+*                       Updated the XV_HdmiTxSs_ShowEdid API to have support
+*                             multiple EDID.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include "xv_hdmitxss.h"
+#include "xv_hdmitxss_coreinit.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+/**
+ * This typedef declares the driver instances of all the cores in the subsystem
+ */
+typedef struct
+{
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  XTmrCtr HdcpTimer;
+  XHdcp1x Hdcp14;
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  XHdcp22_Tx  Hdcp22;
+#endif
+  XV_HdmiTx HdmiTx;
+  XVtc Vtc;
+}XV_HdmiTxSs_SubCores;
+
+/**************************** Local Global ***********************************/
+XV_HdmiTxSs_SubCores XV_HdmiTxSs_SubCoreRepo[XPAR_XV_HDMITXSS_NUM_INSTANCES];
+                /**< Define Driver instance of all sub-core
+                                    included in the design */
+
+/************************** Function Prototypes ******************************/
+static void XV_HdmiTxSs_GetIncludedSubcores(XV_HdmiTxSs *HdmiTxSsPtr,
+                                            u16 DevId);
+static int XV_HdmiTxSs_RegisterSubsysCallbacks(XV_HdmiTxSs *InstancePtr);
+static int XV_HdmiTxSs_VtcSetup(XVtc *XVtcPtr, XV_HdmiTx *HdmiTxPtr);
+static void XV_HdmiTxSs_SendAviInfoframe(XV_HdmiTx *HdmiTxPtr);
+static void XV_HdmiTxSs_SendGeneralControlPacket(XV_HdmiTx *HdmiTxPtr);
+static void XV_HdmiTxSs_SendVSInfoframe(XV_HdmiTx *HdmiTxPtr);
+static void XV_HdmiTxSs_ConnectCallback(void *CallbackRef);
+static void XV_HdmiTxSs_ToggleCallback(void *CallbackRef);
+static void XV_HdmiTxSs_VsCallback(void *CallbackRef);
+static void XV_HdmiTxSs_StreamUpCallback(void *CallbackRef);
+static void XV_HdmiTxSs_StreamDownCallback(void *CallbackRef);
+
+static void XV_HdmiTxSs_ReportCoreInfo(XV_HdmiTxSs *InstancePtr);
+static void XV_HdmiTxSs_ReportTiming(XV_HdmiTxSs *InstancePtr);
+static void XV_HdmiTxSs_ReportSubcoreVersion(XV_HdmiTxSs *InstancePtr);
+
+static void XV_HdmiTxSs_ConfigBridgeMode(XV_HdmiTxSs *InstancePtr);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+/*****************************************************************************/
+/**
+* This macro selects the bridge YUV420 mode
+*
+* @param  InstancePtr is a pointer to the HDMI TX Subsystem
+*
+*****************************************************************************/
+#define XV_HdmiTxSs_BridgeYuv420(InstancePtr, Enable) \
+{ \
+    XV_HdmiTx_Bridge_yuv420(InstancePtr->HdmiTxPtr, Enable); \
+}
+
+/*****************************************************************************/
+/**
+* This macro selects the bridge pixel repeat mode
+*
+* @param  InstancePtr is a pointer to the HDMI TX Subsystem
+*
+*****************************************************************************/
+#define XV_HdmiTxSs_BridgePixelRepeat(InstancePtr, Enable) \
+{ \
+    XV_HdmiTx_Bridge_pixel(InstancePtr->HdmiTxPtr, Enable); \
+}
+/************************** Function Definition ******************************/
+
+/*****************************************************************************/
+/**
+ * This function sets the core into HDMI mode
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_SetHdmiMode(XV_HdmiTxSs *InstancePtr)
+{
+    XV_HdmiTx_SetHdmiMode(InstancePtr->HdmiTxPtr);
+}
+
+/*****************************************************************************/
+/**
+ * This function sets the core into DVI mode
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_SetDviMode(XV_HdmiTxSs *InstancePtr)
+{
+    XV_HdmiTx_SetDviMode(InstancePtr->HdmiTxPtr);
+}
+
+/*****************************************************************************/
+/**
+* This function reports list of cores included in Video Processing Subsystem
+*
+* @param  InstancePtr is a pointer to the Subsystem instance.
+*
+* @return None
+*
+******************************************************************************/
+static void XV_HdmiTxSs_ReportCoreInfo(XV_HdmiTxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  xil_printf("\r\n  ->HDMI TX Subsystem Cores\r\n");
+
+  /* Report all the included cores in the subsystem instance */
+  if (InstancePtr->HdmiTxPtr) {
+    xil_printf("    : HDMI TX \r\n");
+  }
+
+  if (InstancePtr->VtcPtr) {
+    xil_printf("    : VTC Core \r\n");
+  }
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (InstancePtr->Hdcp14Ptr) {
+    xil_printf("    : HDCP 1.4 TX \r\n");
+  }
+
+  if (InstancePtr->HdcpTimerPtr) {
+    xil_printf("    : HDCP: AXIS Timer\r\n");
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  if (InstancePtr->Hdcp22Ptr) {
+    xil_printf("    : HDCP 2.2 TX \r\n");
+  }
+#endif
+}
+
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDMI TX
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_HdmiTxIntrHandler(XV_HdmiTxSs *InstancePtr)
+{
+    XV_HdmiTx_IntrHandler(InstancePtr->HdmiTxPtr);
+}
+/*****************************************************************************/
+/**
+ * This function register's all sub-core ISR's with interrupt controller and
+ * any subsystem level call back function with requisite sub-core
+ *
+ * @param  InstancePtr is a pointer to the Subsystem instance to be
+ *       worked on.
+ *
+ *****************************************************************************/
+static int XV_HdmiTxSs_RegisterSubsysCallbacks(XV_HdmiTxSs *InstancePtr)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = InstancePtr;
+
+  /** Register HDMI callbacks */
+  if (HdmiTxSsPtr->HdmiTxPtr) {
+    /*
+     * Register call back for Tx Core Interrupts.
+     */
+    XV_HdmiTx_SetCallback(HdmiTxSsPtr->HdmiTxPtr,
+                          XV_HDMITX_HANDLER_CONNECT,
+						  (void *)XV_HdmiTxSs_ConnectCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiTx_SetCallback(HdmiTxSsPtr->HdmiTxPtr,
+                          XV_HDMITX_HANDLER_TOGGLE,
+						  (void *)XV_HdmiTxSs_ToggleCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiTx_SetCallback(HdmiTxSsPtr->HdmiTxPtr,
+                          XV_HDMITX_HANDLER_VS,
+						  (void *)XV_HdmiTxSs_VsCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiTx_SetCallback(HdmiTxSsPtr->HdmiTxPtr,
+                          XV_HDMITX_HANDLER_STREAM_UP,
+						  (void *)XV_HdmiTxSs_StreamUpCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiTx_SetCallback(HdmiTxSsPtr->HdmiTxPtr,
+                          XV_HDMITX_HANDLER_STREAM_DOWN,
+						  (void *)XV_HdmiTxSs_StreamDownCallback,
+						  (void *)InstancePtr);
+  }
+
+  return(XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* This function queries the subsystem instance configuration to determine
+* the included sub-cores. For each sub-core that is present in the design
+* the sub-core driver instance is binded with the subsystem sub-core driver
+* handle
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+static void XV_HdmiTxSs_GetIncludedSubcores(XV_HdmiTxSs *HdmiTxSsPtr, u16 DevId)
+{
+  HdmiTxSsPtr->HdmiTxPtr     = ((HdmiTxSsPtr->Config.HdmiTx.IsPresent)    \
+                        ? (&XV_HdmiTxSs_SubCoreRepo[DevId].HdmiTx) : NULL);
+  HdmiTxSsPtr->VtcPtr        = ((HdmiTxSsPtr->Config.Vtc.IsPresent)  \
+                        ? (&XV_HdmiTxSs_SubCoreRepo[DevId].Vtc) : NULL);
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  HdmiTxSsPtr->Hdcp14Ptr       = ((HdmiTxSsPtr->Config.Hdcp14.IsPresent) \
+                        ? (&XV_HdmiTxSs_SubCoreRepo[DevId].Hdcp14) : NULL);
+  HdmiTxSsPtr->HdcpTimerPtr  = ((HdmiTxSsPtr->Config.HdcpTimer.IsPresent) \
+                        ? (&XV_HdmiTxSs_SubCoreRepo[DevId].HdcpTimer) : NULL);
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  HdmiTxSsPtr->Hdcp22Ptr       = ((HdmiTxSsPtr->Config.Hdcp22.IsPresent) \
+                        ? (&XV_HdmiTxSs_SubCoreRepo[DevId].Hdcp22) : NULL);
+#endif
+}
+
+/*****************************************************************************/
+/**
+* This function initializes the video subsystem and included sub-cores.
+* This function must be called prior to using the subsystem. Initialization
+* includes setting up the instance data for top level as well as all included
+* sub-core therein, and ensuring the hardware is in a known stable state.
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+* @param  CfgPtr points to the configuration structure associated with the
+*         subsystem instance.
+* @param  EffectiveAddr is the base address of the device. If address
+*         translation is being used, then this parameter must reflect the
+*         virtual base address. Otherwise, the physical address should be
+*         used.
+*
+* @return XST_SUCCESS if initialization is successful else XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_CfgInitialize(XV_HdmiTxSs *InstancePtr,
+                              XV_HdmiTxSs_Config *CfgPtr,
+                              UINTPTR EffectiveAddr)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = InstancePtr;
+
+  /* Verify arguments */
+  Xil_AssertNonvoid(HdmiTxSsPtr != NULL);
+  Xil_AssertNonvoid(CfgPtr != NULL);
+  Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)NULL);
+
+  /* Setup the instance */
+  memcpy((void *)&(HdmiTxSsPtr->Config), (const void *)CfgPtr,
+    sizeof(XV_HdmiTxSs_Config));
+  HdmiTxSsPtr->Config.BaseAddress = EffectiveAddr;
+
+  /* Determine sub-cores included in the provided instance of subsystem */
+  XV_HdmiTxSs_GetIncludedSubcores(HdmiTxSsPtr, CfgPtr->DeviceId);
+
+  /* Initialize all included sub_cores */
+
+  // HDCP 1.4
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (HdmiTxSsPtr->HdcpTimerPtr) {
+    if (XV_HdmiTxSs_SubcoreInitHdcpTimer(HdmiTxSsPtr) != XST_SUCCESS){
+      return(XST_FAILURE);
+    }
+  }
+
+  if (HdmiTxSsPtr->Hdcp14Ptr) {
+    if (XV_HdmiTxSs_SubcoreInitHdcp14(HdmiTxSsPtr) != XST_SUCCESS){
+      return(XST_FAILURE);
+    }
+  }
+#endif
+
+  if (HdmiTxSsPtr->HdmiTxPtr) {
+    if (XV_HdmiTxSs_SubcoreInitHdmiTx(HdmiTxSsPtr) != XST_SUCCESS) {
+      return(XST_FAILURE);
+    }
+    XV_HdmiTx_SetAxiClkFreq(HdmiTxSsPtr->HdmiTxPtr,
+                            HdmiTxSsPtr->Config.AxiLiteClkFreq);
+  }
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  if (HdmiTxSsPtr->Hdcp22Ptr) {
+    if (XV_HdmiTxSs_SubcoreInitHdcp22(HdmiTxSsPtr) != XST_SUCCESS){
+      return(XST_FAILURE);
+    }
+  }
+#endif
+
+  if (HdmiTxSsPtr->VtcPtr) {
+    if (XV_HdmiTxSs_SubcoreInitVtc(HdmiTxSsPtr) != XST_SUCCESS) {
+      return(XST_FAILURE);
+    }
+  }
+
+  /* Register Callbacks */
+  XV_HdmiTxSs_RegisterSubsysCallbacks(HdmiTxSsPtr);
+
+  /* Set default HDCP protocol */
+  HdmiTxSsPtr->HdcpProtocol = XV_HDMITXSS_HDCP_NONE;
+
+  /* HDCP ready flag */
+
+#ifdef USE_HDCP_TX
+  /* Default value */
+  HdmiTxSsPtr->HdcpIsReady = (FALSE);
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES) && defined(XPAR_XHDCP22_TX_NUM_INSTANCES)
+  /* HDCP is ready when both HDCP cores are instantiated and both keys
+     are loaded */
+  if (HdmiTxSsPtr->Hdcp14Ptr && HdmiTxSsPtr->Hdcp22Ptr &&
+      HdmiTxSsPtr->Hdcp22Lc128Ptr && HdmiTxSsPtr->Hdcp22SrmPtr &&
+      HdmiTxSsPtr->Hdcp14KeyPtr) {
+    HdmiTxSsPtr->HdcpIsReady = (TRUE);
+  }
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES)
+  /* HDCP is ready when only the HDCP 1.4 core is instantiated and the key
+     is loaded */
+  if (!HdmiTxSsPtr->HdcpIsReady && HdmiTxSsPtr->Hdcp14Ptr &&
+       HdmiTxSsPtr->Hdcp14KeyPtr) {
+    HdmiTxSsPtr->HdcpIsReady = (TRUE);
+  }
+#endif
+
+#if defined(XPAR_XHDCP22_TX_NUM_INSTANCES)
+  /* HDCP is ready when only the HDCP 2.2 core is instantiated and the key
+     is loaded */
+  if (!HdmiTxSsPtr->HdcpIsReady && HdmiTxSsPtr->Hdcp22Ptr &&
+       HdmiTxSsPtr->Hdcp22Lc128Ptr &&
+      HdmiTxSsPtr->Hdcp22SrmPtr) {
+    HdmiTxSsPtr->HdcpIsReady = (TRUE);
+  }
+#endif
+
+  /* Set the flag to indicate the subsystem is ready */
+  XV_HdmiTxSs_Reset(HdmiTxSsPtr);
+  HdmiTxSsPtr->IsReady = XIL_COMPONENT_IS_READY;
+
+  return(XST_SUCCESS);
+}
+
+/****************************************************************************/
+/**
+* This function starts the HDMI TX subsystem including all sub-cores that are
+* included in the processing pipeline for a given use-case. Video pipe is
+* started from back to front
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+* @note Cores are started only if the corresponding start flag in the scratch
+*       pad memory is set. This allows to selectively start only those cores
+*       included in the processing chain
+******************************************************************************/
+void XV_HdmiTxSs_Start(XV_HdmiTxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_START, 0);
+#endif
+}
+
+/*****************************************************************************/
+/**
+* This function stops the HDMI TX subsystem including all sub-cores
+* Stop the video pipe starting from front to back
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+void XV_HdmiTxSs_Stop(XV_HdmiTxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_STOP, 0);
+#endif
+  if (InstancePtr->VtcPtr) {
+    /* Disable VTC */
+    XVtc_DisableGenerator(InstancePtr->VtcPtr);
+  }
+}
+
+/*****************************************************************************/
+/**
+* This function resets the video subsystem sub-cores. There are 2 reset
+* networks within the subsystem
+*  - For cores that are on AXIS interface
+*  - For cores that are on AXI-MM interface
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+void XV_HdmiTxSs_Reset(XV_HdmiTxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_RESET, 0);
+#endif
+  /* Assert TX reset */
+  XV_HdmiTx_Reset(InstancePtr->HdmiTxPtr, TRUE);
+
+  /* Release TX reset */
+  XV_HdmiTx_Reset(InstancePtr->HdmiTxPtr, FALSE);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function configures Video Timing Controller (VTC).
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiTxSs_VtcSetup(XVtc *XVtcPtr, XV_HdmiTx *HdmiTxPtr)
+{
+  /* Polarity configuration */
+  XVtc_Polarity Polarity;
+  XVtc_SourceSelect SourceSelect;
+  XVtc_Timing VideoTiming;
+  u32 HdmiTx_Hblank;
+  u32 Vtc_Hblank;
+
+  /* Disable Generator */
+  XVtc_Reset(XVtcPtr);
+  XVtc_DisableGenerator(XVtcPtr);
+  XVtc_Disable(XVtcPtr);
+
+  /* Set up source select */
+  memset((void *)&SourceSelect, 0, sizeof(SourceSelect));
+
+  /* 1 = Generator registers, 0 = Detector registers */
+  SourceSelect.VChromaSrc = 1;
+  SourceSelect.VActiveSrc = 1;
+  SourceSelect.VBackPorchSrc = 1;
+  SourceSelect.VSyncSrc = 1;
+  SourceSelect.VFrontPorchSrc = 1;
+  SourceSelect.VTotalSrc = 1;
+  SourceSelect.HActiveSrc = 1;
+  SourceSelect.HBackPorchSrc = 1;
+  SourceSelect.HSyncSrc = 1;
+  SourceSelect.HFrontPorchSrc = 1;
+  SourceSelect.HTotalSrc = 1;
+
+  XVtc_SetSource(XVtcPtr, &SourceSelect);
+
+  VideoTiming.HActiveVideo = HdmiTxPtr->Stream.Video.Timing.HActive;
+  VideoTiming.HFrontPorch = HdmiTxPtr->Stream.Video.Timing.HFrontPorch;
+  VideoTiming.HSyncWidth = HdmiTxPtr->Stream.Video.Timing.HSyncWidth;
+  VideoTiming.HBackPorch = HdmiTxPtr->Stream.Video.Timing.HBackPorch;
+  VideoTiming.HSyncPolarity = HdmiTxPtr->Stream.Video.Timing.HSyncPolarity;
+
+  /* Vertical Timing */
+  VideoTiming.VActiveVideo = HdmiTxPtr->Stream.Video.Timing.VActive;
+
+  VideoTiming.V0FrontPorch = HdmiTxPtr->Stream.Video.Timing.F0PVFrontPorch;
+  VideoTiming.V0BackPorch = HdmiTxPtr->Stream.Video.Timing.F0PVBackPorch;
+  VideoTiming.V0SyncWidth = HdmiTxPtr->Stream.Video.Timing.F0PVSyncWidth;
+
+  VideoTiming.V1FrontPorch = HdmiTxPtr->Stream.Video.Timing.F1VFrontPorch;
+  VideoTiming.V1SyncWidth = HdmiTxPtr->Stream.Video.Timing.F1VSyncWidth;
+  VideoTiming.V1BackPorch = HdmiTxPtr->Stream.Video.Timing.F1VBackPorch;
+
+  VideoTiming.VSyncPolarity = HdmiTxPtr->Stream.Video.Timing.VSyncPolarity;
+
+  VideoTiming.Interlaced = HdmiTxPtr->Stream.Video.IsInterlaced;
+
+    /* 4 pixels per clock */
+    if (HdmiTxPtr->Stream.Video.PixPerClk == XVIDC_PPC_4) {
+      VideoTiming.HActiveVideo = VideoTiming.HActiveVideo/4;
+      VideoTiming.HFrontPorch = VideoTiming.HFrontPorch/4;
+      VideoTiming.HBackPorch = VideoTiming.HBackPorch/4;
+      VideoTiming.HSyncWidth = VideoTiming.HSyncWidth/4;
+    }
+
+    /* 2 pixels per clock */
+    else if (HdmiTxPtr->Stream.Video.PixPerClk == XVIDC_PPC_2) {
+      VideoTiming.HActiveVideo = VideoTiming.HActiveVideo/2;
+      VideoTiming.HFrontPorch = VideoTiming.HFrontPorch/2;
+      VideoTiming.HBackPorch = VideoTiming.HBackPorch/2;
+      VideoTiming.HSyncWidth = VideoTiming.HSyncWidth/2;
+    }
+
+    /* 1 pixels per clock */
+    else {
+      VideoTiming.HActiveVideo = VideoTiming.HActiveVideo;
+      VideoTiming.HFrontPorch = VideoTiming.HFrontPorch;
+      VideoTiming.HBackPorch = VideoTiming.HBackPorch;
+      VideoTiming.HSyncWidth = VideoTiming.HSyncWidth;
+    }
+
+    /* For YUV420 the line width is double there for double the blanking */
+    if (HdmiTxPtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_420) {
+      VideoTiming.HActiveVideo = VideoTiming.HActiveVideo/2;
+      VideoTiming.HFrontPorch = VideoTiming.HFrontPorch/2;
+      VideoTiming.HBackPorch = VideoTiming.HBackPorch/2;
+      VideoTiming.HSyncWidth = VideoTiming.HSyncWidth/2;
+    }
+
+/** When compensating the vtc horizontal timing parameters for the pixel mode
+* (quad or dual) rounding errors might be introduced (due to the divide)
+* If this happens, the vtc total horizontal blanking is less than the hdmi tx
+* horizontal blanking.
+* As a result the hdmi tx vid out bridge is not able to lock to
+* the incoming video stream.
+* This process will check the horizontal blank timing and compensate
+* for this condition.
+* Calculate hdmi tx horizontal blanking */
+
+  HdmiTx_Hblank = HdmiTxPtr->Stream.Video.Timing.HFrontPorch +
+    HdmiTxPtr->Stream.Video.Timing.HSyncWidth +
+    HdmiTxPtr->Stream.Video.Timing.HBackPorch;
+
+  do {
+    // Calculate vtc horizontal blanking
+    Vtc_Hblank = VideoTiming.HFrontPorch +
+        VideoTiming.HBackPorch +
+        VideoTiming.HSyncWidth;
+
+    // Quad pixel mode
+    if (HdmiTxPtr->Stream.Video.PixPerClk == XVIDC_PPC_4) {
+      Vtc_Hblank *= 4;
+    }
+
+    // Dual pixel mode
+    else if (HdmiTxPtr->Stream.Video.PixPerClk == XVIDC_PPC_2) {
+      Vtc_Hblank *= 2;
+    }
+
+    // Single pixel mode
+    else {
+      //Vtc_Hblank *= 1;
+    }
+
+    /* For YUV420 the line width is double there for double the blanking */
+    if (HdmiTxPtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_420) {
+        Vtc_Hblank *= 2;
+    }
+
+    // If the horizontal total blanking differs,
+    // then increment the Vtc horizontal front porch.
+    if (Vtc_Hblank != HdmiTx_Hblank) {
+      VideoTiming.HFrontPorch++;
+    }
+
+  } while (Vtc_Hblank < HdmiTx_Hblank);
+
+  if (Vtc_Hblank != HdmiTx_Hblank) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "Error! Current format with total Hblank (%d) cannot \r\n",
+                  HdmiTx_Hblank);
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "       be transmitted with pixels per clock = %d\r\n",
+                  HdmiTxPtr->Stream.Video.PixPerClk);
+      return (XST_FAILURE);
+  }
+
+  XVtc_SetGeneratorTiming(XVtcPtr, &VideoTiming);
+
+  /* Set up Polarity of all outputs */
+  memset((void *)&Polarity, 0, sizeof(XVtc_Polarity));
+  Polarity.ActiveChromaPol = 1;
+  Polarity.ActiveVideoPol = 1;
+
+  //Polarity.FieldIdPol = 0;
+  if (VideoTiming.Interlaced) {
+    Polarity.FieldIdPol = 1;
+  }
+  else {
+    Polarity.FieldIdPol = 0;
+  }
+
+  Polarity.VBlankPol = VideoTiming.VSyncPolarity;
+  Polarity.VSyncPol = VideoTiming.VSyncPolarity;
+  Polarity.HBlankPol = VideoTiming.HSyncPolarity;
+  Polarity.HSyncPol = VideoTiming.HSyncPolarity;
+
+  XVtc_SetPolarity(XVtcPtr, &Polarity);
+
+  /* VTC driver does not take care of the setting of the VTC in
+   * interlaced operation. As a work around the register
+   * is set manually */
+  if (VideoTiming.Interlaced) {
+    /* Interlaced mode */
+    XVtc_WriteReg(XVtcPtr->Config.BaseAddress, 0x68, 0x42);
+  }
+  else {
+    /* Progressive mode */
+    XVtc_WriteReg(XVtcPtr->Config.BaseAddress, 0x68, 0x2);
+  }
+
+  /* Enable generator module */
+  XVtc_Enable(XVtcPtr);
+  XVtc_EnableGenerator(XVtcPtr);
+  XVtc_RegUpdateEnable(XVtcPtr);
+
+  return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a TX connect event has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_ConnectCallback(void *CallbackRef)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = (XV_HdmiTxSs *)CallbackRef;
+
+  /* Is the cable connected */
+  if (XV_HdmiTx_IsStreamConnected(HdmiTxSsPtr->HdmiTxPtr)) {
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_CONNECT, 0);
+#endif
+    /* Set stream connected flag */
+    HdmiTxSsPtr->IsStreamConnected = (TRUE);
+
+#ifdef USE_HDCP_TX
+    /* Push connect event to the HDCP event queue */
+    XV_HdmiTxSs_HdcpPushEvent(HdmiTxSsPtr, XV_HDMITXSS_HDCP_CONNECT_EVT);
+#endif
+  }
+
+  /* TX cable is disconnected */
+  else {
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_DISCONNECT, 0);
+#endif
+    /* Set stream connected flag */
+    HdmiTxSsPtr->IsStreamConnected = (FALSE);
+
+#ifdef USE_HDCP_TX
+    /* Push disconnect event to the HDCP event queue */
+    XV_HdmiTxSs_HdcpPushEvent(HdmiTxSsPtr, XV_HDMITXSS_HDCP_DISCONNECT_EVT);
+#endif
+  }
+
+  /* Check if user callback has been registered */
+  if (HdmiTxSsPtr->ConnectCallback) {
+    HdmiTxSsPtr->ConnectCallback(HdmiTxSsPtr->ConnectRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a TX toggle event has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_ToggleCallback(void *CallbackRef)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = (XV_HdmiTxSs *)CallbackRef;
+
+  /* Set toggle flag */
+  HdmiTxSsPtr->IsStreamToggled = TRUE;
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_TOGGLE, 0);
+#endif
+  /* Check if user callback has been registered */
+  if (HdmiTxSsPtr->ToggleCallback) {
+    HdmiTxSsPtr->ToggleCallback(HdmiTxSsPtr->ToggleRef);
+  }
+
+  /* Clear toggle flag */
+  HdmiTxSsPtr->IsStreamToggled = FALSE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a TX vsync has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_VsCallback(void *CallbackRef)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = (XV_HdmiTxSs *)CallbackRef;
+
+  // AVI infoframe
+  XV_HdmiTxSs_SendAviInfoframe(HdmiTxSsPtr->HdmiTxPtr);
+
+  // General control packet
+  XV_HdmiTxSs_SendGeneralControlPacket(HdmiTxSsPtr->HdmiTxPtr);
+
+  // Vendor-Specific InfoFrame
+  XV_HdmiTxSs_SendVSInfoframe(HdmiTxSsPtr->HdmiTxPtr);
+
+  // Check if user callback has been registered
+  if (HdmiTxSsPtr->VsCallback) {
+      HdmiTxSsPtr->VsCallback(HdmiTxSsPtr->VsRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sends AVI info frames.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_SendAviInfoframe(XV_HdmiTx *HdmiTx)
+{
+  u8 Index;
+  u8 Data;
+  u8 Crc;
+
+  /* Header, Packet type*/
+  HdmiTx->Aux.Header.Byte[0] = 0x82;
+
+  /* Version */
+  HdmiTx->Aux.Header.Byte[1] = 0x02;
+
+  /* Length */
+  HdmiTx->Aux.Header.Byte[2] = 13;
+
+  /* Checksum (this will be calculated by the HDMI TX IP) */
+  HdmiTx->Aux.Header.Byte[3] = 0;
+
+  /* Data */
+  switch (HdmiTx->Stream.Video.ColorFormatId) {
+    case XVIDC_CSF_YCRCB_422:
+      Data = 1 << 5;
+      break;
+
+    case XVIDC_CSF_YCRCB_444:
+      Data = 2 << 5;
+      break;
+
+    case XVIDC_CSF_YCRCB_420:
+      Data = 3 << 5;
+      break;
+
+    default:
+      Data = 0;
+      break;
+  }
+
+  HdmiTx->Aux.Data.Byte[1] = Data;
+
+  HdmiTx->Aux.Data.Byte[2] = 0;
+  HdmiTx->Aux.Data.Byte[3] = 0;
+
+  if (!XVidC_IsStream3D(&HdmiTx->Stream.Video) &&
+      (HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_24_P ||
+       HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_25_P ||
+       HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_30_P ||
+       HdmiTx->Stream.Video.VmId == XVIDC_VM_4096x2160_24_P)) {
+    HdmiTx->Aux.Data.Byte[4] = 0;
+  }
+  else {
+      HdmiTx->Aux.Data.Byte[4] = HdmiTx->Stream.Vic;
+  }
+
+  for (Index = 5; Index < 32; Index++) {
+    HdmiTx->Aux.Data.Byte[Index] = 0;
+  }
+
+  /* Calculate AVI infoframe checksum */
+  Crc = 0;
+
+  /* Header */
+  for (Index = 0; Index < 3; Index++) {
+    Crc += HdmiTx->Aux.Header.Byte[Index];
+  }
+
+  /* Data */
+  for (Index = 1; Index < 5; Index++) {
+    Crc += HdmiTx->Aux.Data.Byte[Index];
+  }
+
+  Crc = 256 - Crc;
+
+  HdmiTx->Aux.Data.Byte[0] = Crc;
+
+  XV_HdmiTx_AuxSend(HdmiTx);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sends the general control packet.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_SendGeneralControlPacket(XV_HdmiTx *HdmiTx)
+{
+  u8 Index;
+  u8 Data;
+
+  // Pre-Process SB1 data
+  // Pixel Packing Phase
+  switch (XV_HdmiTx_GetPixelPackingPhase(HdmiTx)) {
+
+    case 1 :
+      Data = 1;
+      break;
+
+    case 2 :
+      Data = 2;
+      break;
+
+    case 3 :
+      Data = 3;
+      break;
+
+    default :
+      Data = 0;
+      break;
+  }
+
+  /**< Shift pixel packing phase to the upper nibble */
+  Data <<= 4;
+
+  /** In HDMI the colordepth in YUV422 is always 12 bits,  although on the
+  * link itself it is being transmitted as 8-bits. Therefore if the colorspace
+  * is YUV422, then force the colordepth to 8 bits. */
+  if (HdmiTx->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_422) {
+    Data |= 0;
+  }
+
+  else {
+
+    // Colordepth
+    switch (HdmiTx->Stream.Video.ColorDepth) {
+
+      // 10 bpc
+      case XVIDC_BPC_10:
+        // Color depth
+        Data |= 5;
+        break;
+
+      // 12 bpc
+      case XVIDC_BPC_12:
+        // Color depth
+        Data |= 6;
+        break;
+
+      // 16 bpc
+      case XVIDC_BPC_16:
+        // Color depth
+        Data |= 7;
+        break;
+
+      // Not indicated
+      default:
+        Data = 0;
+        break;
+    }
+  }
+
+  // Packet type
+  HdmiTx->Aux.Header.Byte[0] = 0x3;
+
+  // Reserved
+  HdmiTx->Aux.Header.Byte[1] = 0;
+
+  // Reserved
+  HdmiTx->Aux.Header.Byte[2] = 0;
+
+  // Checksum (this will be calculated by the HDMI TX IP)
+  HdmiTx->Aux.Header.Byte[3] = 0;
+
+  // Data
+  // The packet contains four identical subpackets
+  for (Index = 0; Index < 4; Index++) {
+    // SB0
+    HdmiTx->Aux.Data.Byte[(Index*8)] = 0;
+
+    // SB1
+    HdmiTx->Aux.Data.Byte[(Index*8)+1] = Data;
+
+    // SB2
+    HdmiTx->Aux.Data.Byte[(Index*8)+2] = 0;
+
+    // SB3
+    HdmiTx->Aux.Data.Byte[(Index*8)+3] = 0;
+
+    // SB4
+    HdmiTx->Aux.Data.Byte[(Index*8)+4] = 0;
+
+    // SB5
+    HdmiTx->Aux.Data.Byte[(Index*8)+5] = 0;
+
+    // SB6
+    HdmiTx->Aux.Data.Byte[(Index*8)+6] = 0;
+
+    // SB ECC
+    HdmiTx->Aux.Data.Byte[(Index*8)+7] = 0;
+
+  }
+
+  XV_HdmiTx_AuxSend(HdmiTx);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sends the Vendor Specific Info Frame.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_SendVSInfoframe(XV_HdmiTx *HdmiTx)
+{
+    XV_HdmiTx_VSIF VSIF;
+
+    VSIF.Version = 0x1;
+    VSIF.IEEE_ID = 0xC03;
+
+    if (XVidC_IsStream3D(&HdmiTx->Stream.Video)) {
+        VSIF.Format = XV_HDMITX_VSIF_VF_3D;
+        VSIF.Info_3D.Stream = HdmiTx->Stream.Video.Info_3D;
+        VSIF.Info_3D.MetaData.IsPresent = FALSE;
+    }
+    else if (HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_24_P ||
+             HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_25_P ||
+             HdmiTx->Stream.Video.VmId == XVIDC_VM_3840x2160_30_P ||
+             HdmiTx->Stream.Video.VmId == XVIDC_VM_4096x2160_24_P) {
+        VSIF.Format = XV_HDMITX_VSIF_VF_EXTRES;
+
+        /* Set HDMI VIC */
+        switch(HdmiTx->Stream.Video.VmId) {
+            case XVIDC_VM_4096x2160_24_P :
+                VSIF.HDMI_VIC = 4;
+                break;
+            case XVIDC_VM_3840x2160_24_P :
+                VSIF.HDMI_VIC = 3;
+                break;
+            case XVIDC_VM_3840x2160_25_P :
+                VSIF.HDMI_VIC = 2;
+                break;
+            case XVIDC_VM_3840x2160_30_P :
+                VSIF.HDMI_VIC = 1;
+                break;
+            default :
+                break;
+        }
+    }
+    else {
+        VSIF.Format = XV_HDMITX_VSIF_VF_NOINFO;
+    }
+
+    XV_HdmiTx_VSIF_GeneratePacket(&VSIF,(XV_HdmiTx_Aux *)&HdmiTx->Aux);
+
+    XV_HdmiTx_AuxSend(HdmiTx);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the TX stream is up.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_StreamUpCallback(void *CallbackRef)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = (XV_HdmiTxSs *)CallbackRef;
+
+  /* Set stream up flag */
+  HdmiTxSsPtr->IsStreamUp = (TRUE);
+
+#ifdef USE_HDCP_TX
+  /* Push the stream-up event to the HDCP event queue */
+  XV_HdmiTxSs_HdcpPushEvent(HdmiTxSsPtr, XV_HDMITXSS_HDCP_STREAMUP_EVT);
+#endif
+
+  /* Check if user callback has been registered.
+     User may change the video stream properties in the callback;
+     therefore, execute the callback before changing stream settings. */
+  if (HdmiTxSsPtr->StreamUpCallback) {
+      HdmiTxSsPtr->StreamUpCallback(HdmiTxSsPtr->StreamUpRef);
+  }
+
+  /* Set TX sample rate */
+  XV_HdmiTx_SetSampleRate(HdmiTxSsPtr->HdmiTxPtr, HdmiTxSsPtr->SamplingRate);
+
+  /* Release HDMI TX reset */
+  XV_HdmiTx_Reset(HdmiTxSsPtr->HdmiTxPtr, FALSE);
+
+  if (HdmiTxSsPtr->VtcPtr) {
+    /* Setup VTC */
+    XV_HdmiTxSs_VtcSetup(HdmiTxSsPtr->VtcPtr, HdmiTxSsPtr->HdmiTxPtr);
+  }
+
+  if (HdmiTxSsPtr->AudioEnabled) {
+      /* HDMI TX unmute audio */
+      HdmiTxSsPtr->AudioMute = (FALSE);
+      XV_HdmiTx_AudioUnmute(HdmiTxSsPtr->HdmiTxPtr);
+  }
+
+  /* Configure video bridge mode according to HW setting and video format */
+  XV_HdmiTxSs_ConfigBridgeMode(HdmiTxSsPtr);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_STREAMUP, 0);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the TX stream is down.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_StreamDownCallback(void *CallbackRef)
+{
+  XV_HdmiTxSs *HdmiTxSsPtr = (XV_HdmiTxSs *)CallbackRef;
+
+  /* Assert HDMI TX reset */
+  XV_HdmiTx_Reset(HdmiTxSsPtr->HdmiTxPtr, TRUE);
+
+  /* Set stream up flag */
+  HdmiTxSsPtr->IsStreamUp = (FALSE);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_STREAMDOWN, 0);
+#endif
+#ifdef USE_HDCP_TX
+  /* Push the stream-down event to the HDCP event queue */
+  XV_HdmiTxSs_HdcpPushEvent(HdmiTxSsPtr, XV_HDMITXSS_HDCP_STREAMDOWN_EVT);
+#endif
+
+  /* Check if user callback has been registered */
+  if (HdmiTxSsPtr->StreamDownCallback) {
+      HdmiTxSsPtr->StreamDownCallback(HdmiTxSsPtr->StreamDownRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function installs an asynchronous callback function for the given
+* HandlerType:
+*
+* <pre>
+* HandlerType                     Callback Function Type
+* -----------------------         ---------------------------------------------
+* (XV_HDMITXSS_HANDLER_CONNECT)       HpdCallback
+* (XV_HDMITXSS_HANDLER_VS)            VsCallback
+* (XV_HDMITXSS_HANDLER_STREAM_DOWN)   StreamDownCallback
+* (XV_HDMITXSS_HANDLER_STREAM_UP)     StreamUpCallback
+* (XV_HDMITXSS_HANDLER_HDCP_AUTHENTICATED)
+* (XV_HDMITXSS_HANDLER_HDCP_DOWNSTREAM_TOPOLOGY_AVAILABLE)
+* (XV_HDMITXSS_HANDLER_HDCP_UNAUTHENTICATED)
+* </pre>
+*
+* @param    InstancePtr is a pointer to the HDMI TX Subsystem instance.
+* @param    HandlerType specifies the type of handler.
+* @param    CallbackFunc is the address of the callback function.
+* @param    CallbackRef is a user data item that will be passed to the
+*       callback function when it is invoked.
+*
+* @return
+*       - XST_SUCCESS if callback function installed successfully.
+*       - XST_INVALID_PARAM when HandlerType is invalid.
+*
+* @note     Invoking this function for a handler that already has been
+*       installed replaces it with the new handler.
+*
+******************************************************************************/
+int XV_HdmiTxSs_SetCallback(XV_HdmiTxSs *InstancePtr,
+    u32 HandlerType,
+    void *CallbackFunc,
+    void *CallbackRef)
+{
+    u32 Status;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(HandlerType >= (XV_HDMITXSS_HANDLER_CONNECT));
+    Xil_AssertNonvoid(CallbackFunc != NULL);
+    Xil_AssertNonvoid(CallbackRef != NULL);
+
+    /* Check for handler type */
+    switch (HandlerType) {
+        // Connect
+        case (XV_HDMITXSS_HANDLER_CONNECT):
+            InstancePtr->ConnectCallback = (XV_HdmiTxSs_Callback)CallbackFunc;
+            InstancePtr->ConnectRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Toggle
+        case (XV_HDMITXSS_HANDLER_TOGGLE):
+            InstancePtr->ToggleCallback = (XV_HdmiTxSs_Callback)CallbackFunc;
+            InstancePtr->ToggleRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Vsync
+        case (XV_HDMITXSS_HANDLER_VS):
+            InstancePtr->VsCallback = (XV_HdmiTxSs_Callback)CallbackFunc;
+            InstancePtr->VsRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream down
+        case (XV_HDMITXSS_HANDLER_STREAM_DOWN):
+            InstancePtr->StreamDownCallback =
+                (XV_HdmiTxSs_Callback)CallbackFunc;
+            InstancePtr->StreamDownRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream up
+        case (XV_HDMITXSS_HANDLER_STREAM_UP):
+            InstancePtr->StreamUpCallback = (XV_HdmiTxSs_Callback)CallbackFunc;
+            InstancePtr->StreamUpRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP authenticated
+        case (XV_HDMITXSS_HANDLER_HDCP_AUTHENTICATED):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            /* Register HDCP 1.4 callbacks */
+            if (InstancePtr->Hdcp14Ptr) {
+              XHdcp1x_SetCallback(InstancePtr->Hdcp14Ptr,
+                                  XHDCP1X_HANDLER_AUTHENTICATED,
+								  (void *)(XHdcp1x_Callback) CallbackFunc,
+								  (void *)CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+            /* Register HDCP 2.2 callbacks */
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Tx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_TX_HANDLER_AUTHENTICATED,
+									(void *)(XHdcp22_Tx_Callback)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP downstream topology available
+        case (XV_HDMITXSS_HANDLER_HDCP_DOWNSTREAM_TOPOLOGY_AVAILABLE):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            /** Register HDCP 1.4 callbacks */
+            if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetCallBack(InstancePtr->Hdcp14Ptr,
+                            (XHdcp1x_HandlerType) XHDCP1X_RPTR_HDLR_REPEATER_EXCHANGE,
+							(void *) (XHdcp1x_Callback)CallbackFunc,
+							(void *) CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+            /** Register HDCP 2.2 callbacks */
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Tx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_TX_HANDLER_DOWNSTREAM_TOPOLOGY_AVAILABLE,
+									(void *)(XHdcp22_Tx_Callback)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP unauthenticated
+        case (XV_HDMITXSS_HANDLER_HDCP_UNAUTHENTICATED):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            /** Register HDCP 1.4 callbacks */
+            if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetCallBack(InstancePtr->Hdcp14Ptr,
+                            XHDCP1X_HANDLER_UNAUTHENTICATED,
+							(void *) (XHdcp1x_Callback)CallbackFunc,
+							(void *) CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+            /** Register HDCP 2.2 callbacks */
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Tx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_TX_HANDLER_UNAUTHENTICATED,
+                                    (void *) (XHdcp22_Tx_Callback)CallbackFunc,
+									(void *) CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+          break;
+
+        default:
+            Status = (XST_INVALID_PARAM);
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads the HDMI Sink EDID.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_ReadEdid(XV_HdmiTxSs *InstancePtr, u8 *Buffer)
+{
+    u32 Status;
+
+    // Default
+    Status = (XST_FAILURE);
+
+    // Check if a sink is connected
+    if (InstancePtr->IsStreamConnected == (TRUE)) {
+
+      *Buffer = 0x00;   // Offset zero
+      Status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x50, 1, Buffer,
+        (FALSE));
+
+      // Check if write was successful
+      if (Status == (XST_SUCCESS)) {
+        // Read edid
+        Status = XV_HdmiTx_DdcRead(InstancePtr->HdmiTxPtr, 0x50, 256, Buffer,
+            (TRUE));
+      }
+    }
+  return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads one block from the HDMI Sink EDID.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_ReadEdidSegment(XV_HdmiTxSs *InstancePtr, u8 *Buffer, u8 segment)
+{
+    u32 Status;
+
+    u8 dummy = 0;
+
+    // Default
+    Status = (XST_FAILURE);
+
+    // Check if a sink is connected
+    if (InstancePtr->IsStreamConnected == (TRUE)) {
+
+	  // For multiple segment EDID read
+	  // First, read the first block, then read address 0x7e to know how many
+	  // blocks, if more than 2 blocks, then select segment after first 2 blocks
+	  // Use the following code to select segment
+
+	  if(segment != 0) {
+        // Segment Pointer
+        Status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x30, 1, &segment,
+        (FALSE));
+	  }
+
+      // Read blocks
+      dummy = 0x00;   // Offset zero
+      Status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x50, 1, &dummy,
+        (FALSE));
+
+      // Check if write was successful
+      if (Status == (XST_SUCCESS)) {
+        // Read edid
+        Status = XV_HdmiTx_DdcRead(InstancePtr->HdmiTxPtr, 0x50, 128, Buffer,
+            (TRUE));
+      }
+
+	  if(segment != 0) {
+        // Segment Pointer
+        Status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x30, 1, &segment,
+        (FALSE));
+	  }
+
+      // Read blocks
+      dummy = 0x80;   // Offset 128
+      Status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x50, 1, &dummy,
+        (FALSE));
+
+      // Check if write was successful
+      if (Status == (XST_SUCCESS)) {
+        // Read edid
+        Status = XV_HdmiTx_DdcRead(InstancePtr->HdmiTxPtr, 0x50, 128, &Buffer[128],
+            (TRUE));
+      }
+    }
+    else {
+      xil_printf("No sink is connected.\n\r");
+      xil_printf("Please connect a HDMI sink.\n\r");
+    }
+  return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function shows the HDMI source edid.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_ShowEdid(XV_HdmiTxSs *InstancePtr)
+{
+    u8 Buffer[256];
+    u8 Row;
+    u8 Column;
+    u8 Valid;
+    u32 Status;
+    u8 EdidManName[4];
+	u8 segment = 0;
+    u8 ExtensionFlag = 0;
+
+    // Check if a sink is connected
+    if (InstancePtr->IsStreamConnected == (TRUE)) {
+
+      // Default
+      Valid = (FALSE);
+
+      // Read Sink Edid Segment 0
+      Status = XV_HdmiTxSs_ReadEdidSegment(InstancePtr, (u8*)&Buffer, segment);
+
+      // Check if read was successful
+      if (Status == (XST_SUCCESS)) {
+        XVidC_EdidGetManName(&Buffer[0], (char *) EdidManName);
+        xil_printf("\r\nMFG name : %s\r\n", EdidManName);
+
+		ExtensionFlag = Buffer[126];
+		ExtensionFlag = ExtensionFlag >> 1;
+        xil_printf("Number of Segment : %d\n\r", ExtensionFlag+1);
+        xil_printf("\r\nRaw data\r\n");
+        xil_printf("----------------------------------------------------\r\n");
+	  }
+
+      segment = 0;
+	  while (segment <= ExtensionFlag)
+	  {
+        // Check if read was successful
+        if (Status == (XST_SUCCESS)) {
+          xil_printf("\n\r---- Segment %d ----\n\r", segment);
+          xil_printf("----------------------------------------------------\n\r");
+          for (Row = 0; Row < 16; Row++) {
+            xil_printf("%02X : ", (Row*16));
+            for (Column = 0; Column < 16; Column++) {
+              xil_printf("%02X ", Buffer[(Row*16)+Column]);
+            }
+        xil_printf("\r\n");
+          }
+          Valid = (TRUE);
+
+          segment++;
+		  if(segment <= ExtensionFlag) {
+            Status = XV_HdmiTxSs_ReadEdidSegment(InstancePtr, (u8*)&Buffer, segment);
+		  }
+        }
+	  }
+
+      if (!Valid) {
+        xil_printf("Error reading EDID\r\n");
+      }
+    }
+
+    else {
+      xil_printf("No sink is connected.\r\n");
+    }
+}
+
+
+/*****************************************************************************/
+/**
+*
+* This function starts the HDMI TX stream
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_StreamStart(XV_HdmiTxSs *InstancePtr)
+{
+  // Set TX pixel rate
+  XV_HdmiTx_SetPixelRate(InstancePtr->HdmiTxPtr);
+
+  // Set TX color depth
+  XV_HdmiTx_SetColorDepth(InstancePtr->HdmiTxPtr);
+
+  // Set TX color format
+  XV_HdmiTx_SetColorFormat(InstancePtr->HdmiTxPtr);
+
+  // Set TX scrambler
+  XV_HdmiTx_Scrambler(InstancePtr->HdmiTxPtr);
+
+  // Set TX clock ratio
+  XV_HdmiTx_ClockRatio(InstancePtr->HdmiTxPtr);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_STREAMSTART, 0);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sends audio info frames.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SendAuxInfoframe(XV_HdmiTxSs *InstancePtr, void *Aux)
+{
+  u8 Index;
+  u8 Crc;
+  XV_HdmiTx_Aux *tx_aux = (XV_HdmiTx_Aux *)Aux;
+
+  if (Aux == (NULL)) {
+      /* Header, Packet type */
+      InstancePtr->HdmiTxPtr->Aux.Header.Byte[0] = 0x84;
+
+      /* Version */
+      InstancePtr->HdmiTxPtr->Aux.Header.Byte[1] = 0x01;
+
+      /* Length */
+      InstancePtr->HdmiTxPtr->Aux.Header.Byte[2] = 10;
+
+      /* Checksum (this will be calculated by the HDMI TX IP) */
+      InstancePtr->HdmiTxPtr->Aux.Header.Byte[3] = 0;
+
+      /* 2 Channel count. Audio coding type refer to stream */
+      InstancePtr->HdmiTxPtr->Aux.Data.Byte[1] = 0x1;
+
+      for (Index = 2; Index < 32; Index++) {
+        InstancePtr->HdmiTxPtr->Aux.Data.Byte[Index] = 0;
+      }
+
+      /* Calculate AVI infoframe checksum */
+      Crc = 0;
+
+      /* Header */
+      for (Index = 0; Index < 3; Index++) {
+        Crc += InstancePtr->HdmiTxPtr->Aux.Header.Byte[Index];
+      }
+
+      /* Data */
+      for (Index = 1; Index < 5; Index++) {
+        Crc += InstancePtr->HdmiTxPtr->Aux.Data.Byte[Index];
+      }
+
+      Crc = 256 - Crc;
+      InstancePtr->HdmiTxPtr->Aux.Data.Byte[0] = Crc;
+
+      XV_HdmiTx_AuxSend(InstancePtr->HdmiTxPtr);
+
+  }
+
+  else {
+      // Copy Audio Infoframe
+      if (tx_aux->Header.Byte[0] == 0x84) {
+        // Header
+        InstancePtr->HdmiTxPtr->Aux.Header.Data = tx_aux->Header.Data;
+
+        // Data
+        for (Index = 0; Index < 8; Index++) {
+          InstancePtr->HdmiTxPtr->Aux.Data.Data[Index] =
+            tx_aux->Data.Data[Index];
+        }
+      }
+  }
+
+  /* Send packet */
+  XV_HdmiTx_AuxSend(InstancePtr->HdmiTxPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sends generic info frames.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SendGenericAuxInfoframe(XV_HdmiTxSs *InstancePtr, void *Aux)
+{
+  u8 Index;
+  XV_HdmiTx_Aux *tx_aux = (XV_HdmiTx_Aux *)Aux;
+
+  // Header
+  InstancePtr->HdmiTxPtr->Aux.Header.Data = tx_aux->Header.Data;
+
+  // Data
+  for (Index = 0; Index < 8; Index++) {
+    InstancePtr->HdmiTxPtr->Aux.Data.Data[Index] =
+    tx_aux->Data.Data[Index];
+  }
+
+  /* Send packet */
+  XV_HdmiTx_AuxSend(InstancePtr->HdmiTxPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS number of active audio channels
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  AudioChannels
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetAudioChannels(XV_HdmiTxSs *InstancePtr, u8 AudioChannels)
+{
+    InstancePtr->AudioChannels = AudioChannels;
+    XV_HdmiTx_SetAudioChannels(InstancePtr->HdmiTxPtr, AudioChannels);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(InstancePtr,
+                         XV_HDMITXSS_LOG_EVT_SETAUDIOCHANNELS,
+                         AudioChannels);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* This function set HDMI TX audio parameters
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_AudioMute(XV_HdmiTxSs *InstancePtr, u8 Enable)
+{
+  //Audio Mute Mode
+  if (Enable){
+    XV_HdmiTx_AudioMute(InstancePtr->HdmiTxPtr);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_AUDIOMUTE, 0);
+#endif
+  }
+  else{
+    XV_HdmiTx_AudioUnmute(InstancePtr->HdmiTxPtr);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_AUDIOUNMUTE, 0);
+#endif
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function set HDMI TX susbsystem stream parameters
+*
+* @param  None.
+*
+* @return Calculated TMDS Clock
+*
+* @note   None.
+*
+******************************************************************************/
+u32 XV_HdmiTxSs_SetStream(XV_HdmiTxSs *InstancePtr,
+        XVidC_VideoMode VideoMode, XVidC_ColorFormat ColorFormat,
+        XVidC_ColorDepth Bpc, XVidC_3DInfo *Info3D)
+{
+  u32 TmdsClock = 0;
+
+  TmdsClock = XV_HdmiTx_SetStream(InstancePtr->HdmiTxPtr, VideoMode,
+    ColorFormat, Bpc, InstancePtr->Config.Ppc, Info3D);
+#ifdef XV_HDMITXSS_LOG_ENABLE
+  XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_SETSTREAM, TmdsClock);
+#endif
+  if(TmdsClock == 0) {
+    xdbg_printf(XDBG_DEBUG_GENERAL,
+                "\nWarning: Sink does not support HDMI 2.0\r\n");
+    xdbg_printf(XDBG_DEBUG_GENERAL,
+                "         Connect to HDMI 2.0 Sink or \r\n");
+    xdbg_printf(XDBG_DEBUG_GENERAL,
+                "         Change to HDMI 1.4 video format\r\n\n");
+}
+
+  return TmdsClock;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI TX SS video stream
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+*
+* @return XVidC_VideoStream pointer
+*
+* @note   None.
+*
+******************************************************************************/
+XVidC_VideoStream *XV_HdmiTxSs_GetVideoStream(XV_HdmiTxSs *InstancePtr)
+{
+    return (&InstancePtr->HdmiTxPtr->Stream.Video);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video stream
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param
+*
+* @return XVidC_VideoStream pointer
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetVideoStream(XV_HdmiTxSs *InstancePtr,
+                                    XVidC_VideoStream VidStream)
+{
+    InstancePtr->HdmiTxPtr->Stream.Video = VidStream;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video Identification code
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  SamplingRate Value
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetSamplingRate(XV_HdmiTxSs *InstancePtr, u8 SamplingRate)
+{
+    InstancePtr->SamplingRate = SamplingRate;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video Identification code
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  InstancePtr VIC Flag Value
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetVideoIDCode(XV_HdmiTxSs *InstancePtr, u8 Vic)
+{
+    InstancePtr->HdmiTxPtr->Stream.Vic = Vic;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video stream type
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  InstancePtr VIC Value 1:HDMI 0:DVI
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetVideoStreamType(XV_HdmiTxSs *InstancePtr, u8 StreamType)
+{
+    InstancePtr->HdmiTxPtr->Stream.IsHdmi = StreamType;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video stream type
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  IsScrambled 1:IsScrambled 0: not Scrambled
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetVideoStreamScramblingFlag(XV_HdmiTxSs *InstancePtr,
+                                                            u8 IsScrambled)
+{
+    InstancePtr->HdmiTxPtr->Stream.IsScrambled = IsScrambled;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS TMDS Cock Ratio
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param  Ratio 0 - 1/10, 1 - 1/40
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetTmdsClockRatio(XV_HdmiTxSs *InstancePtr, u8 Ratio)
+{
+    InstancePtr->HdmiTxPtr->Stream.TMDSClockRatio = Ratio;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the HDMI TX SS video Identification code
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+* @param
+*
+* @return Stream Data Structure (TMDS Clock)
+*
+* @note   None.
+*
+******************************************************************************/
+u32 XV_HdmiTxSs_GetTmdsClockFreqHz(XV_HdmiTxSs *InstancePtr)
+{
+    return (InstancePtr->HdmiTxPtr->Stream.TMDSClock);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function detects connected sink is a HDMI 2.0/HDMI 1.4 sink device
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+*
+* @return
+*       - XST_SUCCESS if HDMI 2.0
+*       - XST_FAILURE if HDMI 1.4
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_DetectHdmi20(XV_HdmiTxSs *InstancePtr)
+{
+      return (XV_HdmiTx_DetectHdmi20(InstancePtr->HdmiTxPtr));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when HDMI TX SS TMDS clock changes
+*
+* @param  None.
+*
+* @return None
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_RefClockChangeInit(XV_HdmiTxSs *InstancePtr)
+{
+      /* Assert HDMI TX reset */
+      XV_HdmiTx_Reset(InstancePtr->HdmiTxPtr, TRUE);
+
+      /* Clear variables */
+      XV_HdmiTx_Clear(InstancePtr->HdmiTxPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI TX SS timing information
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_ReportTiming(XV_HdmiTxSs *InstancePtr)
+{
+      XV_HdmiTx_DebugInfo(InstancePtr->HdmiTxPtr);
+      xil_printf("Scrambled: %0d\r\n",
+        (XV_HdmiTx_IsStreamScrambled(InstancePtr->HdmiTxPtr)));
+      xil_printf("Sample rate: %0d\r\n",
+        (XV_HdmiTx_GetSampleRate(InstancePtr->HdmiTxPtr)));
+      xil_printf("Audio channels: %0d\r\n",
+        (XV_HdmiTx_GetAudioChannels(InstancePtr->HdmiTxPtr)));
+      xil_printf("\r\n");
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI TX SS subcore versions
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_ReportSubcoreVersion(XV_HdmiTxSs *InstancePtr)
+{
+  u32 Data;
+
+  if (InstancePtr->HdmiTxPtr) {
+     Data = XV_HdmiTx_GetVersion(InstancePtr->HdmiTxPtr);
+     xil_printf("  HDMI TX version : %02d.%02d (%04x)\r\n",
+        ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+
+  if (InstancePtr->VtcPtr){
+     Data = XVtc_GetVersion(InstancePtr->VtcPtr);
+     xil_printf("  VTC version     : %02d.%02d (%04x)\r\n",
+        ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  if (InstancePtr->Hdcp14Ptr){
+     Data = XHdcp1x_GetVersion(InstancePtr->Hdcp14Ptr);
+     xil_printf("  HDCP 1.4 TX version : %02d.%02d (%04x)\r\n",
+        ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+   Data = XHdcp22Tx_GetVersion(InstancePtr->Hdcp22Ptr);
+   xil_printf("  HDCP 2.2 TX version : %02d.%02d (%04x)\r\n",
+    ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+#endif
+
+}
+
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI TX SS subcore versions
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_ReportInfo(XV_HdmiTxSs *InstancePtr)
+{
+    xil_printf("------------\r\n");
+    xil_printf("HDMI TX SubSystem\r\n");
+    xil_printf("------------\r\n");
+    XV_HdmiTxSs_ReportCoreInfo(InstancePtr);
+    XV_HdmiTxSs_ReportSubcoreVersion(InstancePtr);
+    xil_printf("\r\n");
+    xil_printf("HDMI TX timing\r\n");
+    xil_printf("------------\r\n");
+    XV_HdmiTxSs_ReportTiming(InstancePtr);
+}
+/*****************************************************************************/
+/**
+*
+* This function checks if the video stream is up.
+*
+* @param  None.
+*
+* @return
+*   - TRUE if stream is up.
+*   - FALSE if stream is down.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_IsStreamUp(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify arguments. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  return (InstancePtr->IsStreamUp);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function checks if the interface is connected.
+*
+* @param  None.
+*
+* @return
+*   - TRUE if the interface is connected.
+*   - FALSE if the interface is not connected.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_IsStreamConnected(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify arguments. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  return (InstancePtr->IsStreamConnected);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function checks if the interface has toggled.
+*
+* @param  None.
+*
+* @return
+*   - TRUE if the interface HPD has toggled.
+*   - FALSE if the interface HPD has not toggled.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_IsStreamToggled(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify arguments. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  return (InstancePtr->IsStreamToggled);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function configures the Bridge for YUV420 and repeater functionality
+*
+* @param InstancePtr  Instance Pointer to the main data structure
+* @param None
+*
+* @return
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiTxSs_ConfigBridgeMode(XV_HdmiTxSs *InstancePtr) {
+
+    XVidC_ColorFormat ColorFormat;
+    XVidC_VideoMode VideoMode;
+
+    XVidC_VideoStream *HdmiTxSsVidStreamPtr;
+    HdmiTxSsVidStreamPtr = XV_HdmiTxSs_GetVideoStream(InstancePtr);
+
+    ColorFormat = HdmiTxSsVidStreamPtr->ColorFormatId;
+    VideoMode = HdmiTxSsVidStreamPtr->VmId;
+
+    if (ColorFormat == XVIDC_CSF_YCRCB_420) {
+        /*********************************************************
+         * 420 Support
+         *********************************************************/
+         XV_HdmiTxSs_BridgePixelRepeat(InstancePtr,FALSE);
+         XV_HdmiTxSs_BridgeYuv420(InstancePtr,TRUE);
+    }
+    else {
+        if ((VideoMode == XVIDC_VM_1440x480_60_I) ||
+            (VideoMode == XVIDC_VM_1440x576_50_I) )
+        {
+            /*********************************************************
+             * NTSC/PAL Support
+             *********************************************************/
+             XV_HdmiTxSs_BridgeYuv420(InstancePtr,FALSE);
+             XV_HdmiTxSs_BridgePixelRepeat(InstancePtr,TRUE);
+        }
+        else {
+            XV_HdmiTxSs_BridgeYuv420(InstancePtr,FALSE);
+            XV_HdmiTxSs_BridgePixelRepeat(InstancePtr,FALSE);
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+* This function will set the default in HDF.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+* @param    Id is the XV_HdmiTxSs ID to operate on.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetDefaultPpc(XV_HdmiTxSs *InstancePtr, u8 Id) {
+}
+
+/*****************************************************************************/
+/**
+* This function will set PPC specified by user.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+* @param    Id is the XV_HdmiTxSs ID to operate on.
+* @param    Ppc is the PPC to be set.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_SetPpc(XV_HdmiTxSs *InstancePtr, u8 Id, u8 Ppc) {
+    InstancePtr->Config.Ppc = (XVidC_PixelsPerClock) Ppc;
+    Id = Id; //squash unused variable compiler warning
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.h
new file mode 100644
index 0000000..d60da60
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss.h
@@ -0,0 +1,478 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitxss.h
+*
+* This is main header file of the Xilinx HDMI TX Subsystem driver
+*
+* <b>HDMI Transmitter Subsystem Overview</b>
+*
+* HDMI TX Subsystem is a collection of IP cores bounded together by software
+* to provide an abstract view of the processing pipe. It hides all the
+* complexities of programming the underlying cores from end user.
+*
+* <b>Subsystem Driver Features</b>
+*
+* HDMI Subsystem supports following features
+*   - AXI Stream Input/Output interface
+*   - 1, 2 or 4 pixel-wide video interface
+*   - 8/10/12/16 bits per component
+*   - RGB & YCbCr color space
+*   - Up to 4k2k 60Hz resolution at both Input and Output interface
+*   - Interlaced input support (1080i 50Hz/60Hz)
+
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     15/01/16 Add 3D Support
+* 1.2   yh     20/01/16 Added remapper support
+* 1.3   yh     01/02/16 Added set_ppc api
+* 1.4   MG     03/02/16 Added HDCP support
+* 1.5   MG     09/03/16 Removed reduced blanking support and
+*                       added XV_HdmiTxSS_SetHdmiMode and XV_HdmiTxSS_SetDviMode
+* 1.6   MH     03/15/16 Added HDCP connect event
+* 1.7   YH     17/03/16 Remove xintc.h as it is processor dependent
+* 1.8   YH     18/03/16 Add XV_HdmiTxSs_SendGenericAuxInfoframe function
+* 1.9   MH     23/06/16 Added HDCP repeater support.
+* 1.10  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+* 1.11  MH     08/08/16 Updates to optimize out HDCP when excluded.
+* 1.12  YH     18/08/16 Combine Report function into one ReportInfo
+*                       Add Event Log
+* 1.13  YH     27/08/16 Remove unused function XV_HdmiTxSs_SetUserTimerHandler
+* 1.14  YH     14/11/16 Added API to enable/disable YUV420/Pixel Repeat Mode
+*                       for video bridge
+* 1.15  YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.16  mmo    03/01/17 Add compiler option(XV_HDMITXSS_LOG_ENABLE) to enable
+*                            Log
+*                       Re-order the enumation and data structure
+* 1.17  mmo    02/03/17 Added XV_HdmiTxSs_ReadEdidSegment API for Multiple
+*                             Segment Support and HDMI Compliance Test
+* </pre>
+*
+******************************************************************************/
+
+#ifndef HDMITXSS_H /**< prevent circular inclusions by using protection macros*/
+#define HDMITXSS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "xstatus.h"
+#include "xvidc.h"
+#include "xvidc_edid.h"
+#include "xv_hdmitx.h"
+#include "xvtc.h"
+
+#if !defined(XV_CONFIG_LOG_VHDMITXSS_DISABLE) && \
+                                             !defined(XV_CONFIG_LOG_DISABLE_ALL)
+#define XV_HDMITXSS_LOG_ENABLE
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES) || defined(XPAR_XHDCP22_TX_NUM_INSTANCES)
+#define USE_HDCP_TX
+#define XV_HDMITXSS_HDCP_KEYSEL 0x00u
+#define XV_HDMITXSS_HDCP_MAX_QUEUE_SIZE 16
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+#include "xtmrctr.h"
+#include "xhdcp1x.h"
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+#include "xhdcp22_tx.h"
+#endif
+
+
+
+/****************************** Type Definitions ******************************/
+/** @name Handler Types
+* @{
+*/
+#ifdef XV_HDMITXSS_LOG_ENABLE
+typedef enum {
+	XV_HDMITXSS_LOG_EVT_NONE = 1,		  /**< Log event none. */
+	XV_HDMITXSS_LOG_EVT_HDMITX_INIT,	  /**< Log event HDMITX Init. */
+	XV_HDMITXSS_LOG_EVT_VTC_INIT,	      /**< Log event VTC Init. */
+	XV_HDMITXSS_LOG_EVT_HDCPTIMER_INIT,	  /**< Log event HDCP Timer Init */
+	XV_HDMITXSS_LOG_EVT_HDCP14_INIT,	  /**< Log event HDCP 14 Init. */
+	XV_HDMITXSS_LOG_EVT_HDCP22_INIT,	  /**< Log event HDCP 22 Init. */
+	XV_HDMITXSS_LOG_EVT_REMAP_HWRESET_INIT,	/**< Log event Remap reset Init. */
+	XV_HDMITXSS_LOG_EVT_REMAP_INIT,		/**< Log event Remapper Init. */
+	XV_HDMITXSS_LOG_EVT_START,	/**< Log event HDMITXSS Start. */
+	XV_HDMITXSS_LOG_EVT_STOP,	/**< Log event HDMITXSS Stop. */
+	XV_HDMITXSS_LOG_EVT_RESET,	/**< Log event HDMITXSS Reset. */
+	XV_HDMITXSS_LOG_EVT_CONNECT, /**< Log event Cable connect. */
+	XV_HDMITXSS_LOG_EVT_TOGGLE, /**< Log event HPD toggle. */
+	XV_HDMITXSS_LOG_EVT_DISCONNECT,	/**< Log event Cable disconnect. */
+	XV_HDMITXSS_LOG_EVT_STREAMUP,	/**< Log event Stream Up. */
+	XV_HDMITXSS_LOG_EVT_STREAMDOWN,	/**< Log event Stream Down. */
+	XV_HDMITXSS_LOG_EVT_STREAMSTART, /**< Log event Stream Start. */
+	XV_HDMITXSS_LOG_EVT_SETAUDIOCHANNELS, /**< Log event Set Audio Channels. */
+	XV_HDMITXSS_LOG_EVT_AUDIOMUTE,		/**< Log event Audio Mute */
+	XV_HDMITXSS_LOG_EVT_AUDIOUNMUTE,	/**< Log event Audio Unmute. */
+	XV_HDMITXSS_LOG_EVT_SETSTREAM,   /**< Log event HDMITXSS Setstream. */
+	XV_HDMITXSS_LOG_EVT_HDCP14_AUTHREQ,   /**< Log event HDCP 1.4 AuthReq. */
+	XV_HDMITXSS_LOG_EVT_HDCP22_AUTHREQ,   /**< Log event HDCP 2.2 AuthReq. */
+	XV_HDMITXSS_LOG_EVT_DUMMY		/**< Dummy Event should be last */
+} XV_HdmiTxSs_LogEvent;
+
+/**
+ * This typedef contains the logging mechanism for debug.
+ */
+typedef struct {
+	u16 DataBuffer[256];		/**< Log buffer with event data. */
+	u8 HeadIndex;			    /**< Index of the head entry of the
+						             Event/DataBuffer. */
+	u8 TailIndex;			    /**< Index of the tail entry of the
+						             Event/DataBuffer. */
+} XV_HdmiTxSs_Log;
+#endif
+
+/**
+* These constants specify the HDCP protection schemes
+*/
+typedef enum
+{
+    XV_HDMITXSS_HDCP_NONE,   /**< No content protection */
+    XV_HDMITXSS_HDCP_14,     /**< HDCP 1.4 */
+    XV_HDMITXSS_HDCP_22      /**< HDCP 2.2 */
+} XV_HdmiTxSs_HdcpProtocol;
+
+#ifdef USE_HDCP_TX
+/**
+* These constants specify the HDCP key types
+*/
+typedef enum
+{
+    XV_HDMITXSS_KEY_HDCP22_LC128,   /**< HDCP 2.2 LC128 */
+    XV_HDMITXSS_KEY_HDCP22_SRM,     /**< HDCP 2.2 SRM */
+    XV_HDMITXSS_KEY_HDCP14,         /**< HDCP 1.4 Key */
+    XV_HDMITXSS_KEY_HDCP14_SRM,     /**< HDCP 1.4 SRM */
+    XV_HDMITXSS_KEY_INVALID         /**< Invalid Key */
+} XV_HdmiTxSs_HdcpKeyType;
+
+/**
+* These constants specify HDCP repeater content stream management type
+*/
+typedef enum
+{
+    XV_HDMITXSS_HDCP_STREAMTYPE_0, /**< HDCP Stream Type 0 */
+    XV_HDMITXSS_HDCP_STREAMTYPE_1  /**< HDCP Stream Type 1 */
+} XV_HdmiTxSs_HdcpContentStreamType;
+
+typedef enum
+{
+    XV_HDMITXSS_HDCP_NO_EVT,
+    XV_HDMITXSS_HDCP_STREAMUP_EVT,
+    XV_HDMITXSS_HDCP_STREAMDOWN_EVT,
+    XV_HDMITXSS_HDCP_CONNECT_EVT,
+    XV_HDMITXSS_HDCP_DISCONNECT_EVT,
+    XV_HDMITXSS_HDCP_AUTHENTICATE_EVT,
+    XV_HDMITXSS_HDCP_INVALID_EVT
+} XV_HdmiTxSs_HdcpEvent;
+
+/**
+* These constants are used to identify fields inside the topology structure
+*/
+typedef enum {
+    XV_HDMITXSS_HDCP_TOPOLOGY_DEPTH,
+    XV_HDMITXSS_HDCP_TOPOLOGY_DEVICECNT,
+    XV_HDMITXSS_HDCP_TOPOLOGY_MAXDEVSEXCEEDED,
+    XV_HDMITXSS_HDCP_TOPOLOGY_MAXCASCADEEXCEEDED,
+    XV_HDMITXSS_HDCP_TOPOLOGY_HDCP20REPEATERDOWNSTREAM,
+    XV_HDMITXSS_HDCP_TOPOLOGY_HDCP1DEVICEDOWNSTREAM,
+    XV_HDMITXSS_HDCP_TOPOLOGY_INVALID
+} XV_HdmiTxSs_HdcpTopologyField;
+
+typedef struct
+{
+    XV_HdmiTxSs_HdcpEvent   Queue[XV_HDMITXSS_HDCP_MAX_QUEUE_SIZE]; /**< Data */
+    u8                      Tail;      /**< Tail pointer */
+    u8                      Head;      /**< Head pointer */
+} XV_HdmiTxSs_HdcpEventQueue;
+#endif
+
+/**
+* These constants specify different types of handler and used to differentiate
+* interrupt requests from peripheral.
+*/
+typedef enum {
+    XV_HDMITXSS_HANDLER_CONNECT = 1,                       /**< Handler for
+                                                            connect event */
+    XV_HDMITXSS_HANDLER_TOGGLE,                            /**< Handler for
+                                                            toggle event */
+    XV_HDMITXSS_HANDLER_VS,                                /**< Handler for
+                                                            vsync event */
+    XV_HDMITXSS_HANDLER_STREAM_DOWN,                       /**< Handler for
+                                                            stream down event */
+    XV_HDMITXSS_HANDLER_STREAM_UP,                         /**< Handler for
+                                                            stream up event */
+    XV_HDMITXSS_HANDLER_HDCP_AUTHENTICATED,                /**< Handler for
+                                                            HDCP authenticated
+                                                            event */
+    XV_HDMITXSS_HANDLER_HDCP_DOWNSTREAM_TOPOLOGY_AVAILABLE,/**< Handler for
+                                                            HDCP downstream
+                                                            topology available
+                                                            event */
+    XV_HDMITXSS_HANDLER_HDCP_UNAUTHENTICATED               /**< Handler for
+                                                            HDCP unauthenticated
+                                                            event */
+} XV_HdmiTxSs_HandlerType;
+/*@}*/
+
+/**
+ * Sub-Core Configuration Table
+ */
+typedef struct
+{
+  u16 IsPresent;  /**< Flag to indicate if sub-core is present in the design*/
+  u16 DeviceId;   /**< Device ID of the sub-core */
+  UINTPTR AbsAddr; /**< Sub-core Absolute Base Address */
+}XV_HdmiTxSs_SubCore;
+
+/**
+ * Video Processing Subsystem configuration structure.
+ * Each subsystem device should have a configuration structure associated
+ * that defines the MAX supported sub-cores within subsystem
+ */
+
+typedef struct
+{
+    u16 DeviceId;                     /**< DeviceId is the unique ID  of the
+                                           device */
+    UINTPTR BaseAddress;              /**< BaseAddress is the physical base
+                                           address of the subsystem address
+                                           range */
+    UINTPTR HighAddress;              /**< HighAddress is the physical MAX
+                                           address of the subsystem address
+                                           range */
+    XVidC_PixelsPerClock Ppc;         /**< Supported Pixel per Clock */
+    u8 MaxBitsPerPixel;               /**< Maximum  Supported Color Depth */
+    u32 AxiLiteClkFreq;               /**< AXI Lite Clock Frequency in Hz */
+    XV_HdmiTxSs_SubCore HdcpTimer;    /**< Sub-core instance configuration */
+    XV_HdmiTxSs_SubCore Hdcp14;       /**< Sub-core instance configuration */
+    XV_HdmiTxSs_SubCore Hdcp22;       /**< Sub-core instance configuration */
+    XV_HdmiTxSs_SubCore HdmiTx;       /**< Sub-core instance configuration */
+    XV_HdmiTxSs_SubCore Vtc;          /**< Sub-core instance configuration */
+} XV_HdmiTxSs_Config;
+
+/**
+* Callback type for interrupt.
+*
+* @param  CallbackRef is a callback reference passed in by the upper
+*   layer when setting the callback functions, and passed back to
+*   the upper layer when the callback is invoked.
+*
+* @return None.
+*
+* @note   None.
+*
+*/
+typedef void (*XV_HdmiTxSs_Callback)(void *CallbackRef);
+
+/**
+* The XVprocss driver instance data. The user is required to allocate a variable
+* of this type for every XVprocss device in the system. A pointer to a variable
+* of this type is then passed to the driver API functions.
+*/
+typedef struct
+{
+    XV_HdmiTxSs_Config Config;  /**< Hardware configuration */
+    u32 IsReady;         /**< Device and the driver instance are initialized */
+
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_Log Log;                /**< A log of events. */
+#endif
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    XTmrCtr *HdcpTimerPtr;          /**< handle to sub-core driver instance */
+    XHdcp1x *Hdcp14Ptr;             /**< handle to sub-core driver instance */
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    XHdcp22_Tx  *Hdcp22Ptr;         /**< handle to sub-core driver instance */
+#endif
+    XV_HdmiTx *HdmiTxPtr;           /**< handle to sub-core driver instance */
+    XVtc *VtcPtr;                   /**< handle to sub-core driver instance */
+
+    /* Callbacks */
+    XV_HdmiTxSs_Callback ConnectCallback; /**< Callback for connect event */
+    void *ConnectRef;                     /**< To be passed to the connect
+                                               callback */
+
+    XV_HdmiTxSs_Callback ToggleCallback; /**< Callback for toggle event */
+    void *ToggleRef;                     /**< To be passed to the toggle
+                                              callback */
+
+    XV_HdmiTxSs_Callback VsCallback; /**< Callback for Vsync event */
+    void *VsRef;                   /**< To be passed to the Vsync callback */
+
+    XV_HdmiTxSs_Callback StreamDownCallback; /**< Callback for stream down */
+    void *StreamDownRef; /**< To be passed to the stream down callback */
+
+    XV_HdmiTxSs_Callback StreamUpCallback; /**< Callback for stream up */
+    void *StreamUpRef;  /**< To be passed to the stream up callback */
+
+    /**< Scratch pad */
+    u8 SamplingRate;              /**< HDMI TX Sampling rate */
+    u8 IsStreamConnected;         /**< HDMI TX Stream Connected */
+    u8 IsStreamUp;                /**< HDMI TX Stream Up */
+    u8 IsStreamToggled;           /**< HDMI TX Stream Toggled */
+    u8 AudioEnabled;              /**< HDMI TX Audio Enabled */
+    u8 AudioMute;                 /**< HDMI TX Audio Mute */
+    u8 AudioChannels;             /**< Number of Audio Channels */
+
+    XV_HdmiTxSs_HdcpProtocol    HdcpProtocol;    /**< HDCP protect scheme */
+#ifdef USE_HDCP_TX
+    /**< HDCP specific */
+    u32                         HdcpIsReady;     /**< HDCP ready flag */
+    XV_HdmiTxSs_HdcpEventQueue  HdcpEventQueue;  /**< HDCP event queue */
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    u8                          *Hdcp22Lc128Ptr; /**< Pointer to HDCP 2.2
+                                                      LC128 */
+    u8                          *Hdcp22SrmPtr;   /**< Pointer to HDCP 2.2 SRM */
+#endif
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    u8                          *Hdcp14KeyPtr;   /**< Pointer to HDCP 1.4 key */
+    u8                          *Hdcp14SrmPtr;   /**< Pointer to HDCP 1.4 SRM */
+#endif
+#endif
+} XV_HdmiTxSs;
+
+/************************** Macros Definitions *******************************/
+#ifdef USE_HDCP_TX
+#define XV_HdmiTxSs_HdcpIsReady(InstancePtr) \
+  (InstancePtr)->HdcpIsReady
+#endif
+/************************** Function Prototypes ******************************/
+XV_HdmiTxSs_Config *XV_HdmiTxSs_LookupConfig(u32 DeviceId);
+void XV_HdmiTxSS_SetHdmiMode(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSS_SetDviMode(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSS_HdmiTxIntrHandler(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_CfgInitialize(XV_HdmiTxSs *InstancePtr,
+    XV_HdmiTxSs_Config *CfgPtr,
+    UINTPTR EffectiveAddr);
+void XV_HdmiTxSs_Start(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_Stop(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_Reset(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_SetCallback(XV_HdmiTxSs *InstancePtr,
+    u32 HandlerType,
+    void *CallbackFuncPtr,
+    void *CallbackRef);
+int XV_HdmiTxSs_ReadEdid(XV_HdmiTxSs *InstancePtr, u8 *BufferPtr);
+int XV_HdmiTxSs_ReadEdidSegment(XV_HdmiTxSs *InstancePtr, u8 *Buffer, u8 segment);
+void XV_HdmiTxSs_ShowEdid(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_StreamStart(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_SendAuxInfoframe(XV_HdmiTxSs *InstancePtr, void *AuxPtr);
+void XV_HdmiTxSs_SendGenericAuxInfoframe(XV_HdmiTxSs *InstancePtr, void *AuxPtr);
+void XV_HdmiTxSs_SetAudioChannels(XV_HdmiTxSs *InstancePtr, u8 AudioChannels);
+void XV_HdmiTxSs_AudioMute(XV_HdmiTxSs *InstancePtr, u8 Enable);
+u32 XV_HdmiTxSs_SetStream(XV_HdmiTxSs *InstancePtr,
+    XVidC_VideoMode VideoMode,
+    XVidC_ColorFormat ColorFormat,
+    XVidC_ColorDepth Bpc,
+    XVidC_3DInfo *Info3D);
+XVidC_VideoStream *XV_HdmiTxSs_GetVideoStream(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_SetVideoStream(XV_HdmiTxSs *InstancePtr,
+                                    XVidC_VideoStream VidStream);
+void XV_HdmiTxSs_SetSamplingRate(XV_HdmiTxSs *InstancePtr, u8 SamplingRate);
+void XV_HdmiTxSs_SetVideoIDCode(XV_HdmiTxSs *InstancePtr, u8 Vic);
+void XV_HdmiTxSs_SetVideoStreamType(XV_HdmiTxSs *InstancePtr, u8 StreamType);
+void XV_HdmiTxSs_SetVideoStreamScramblingFlag(XV_HdmiTxSs *InstancePtr,
+                                                            u8 IsScrambled);
+void XV_HdmiTxSs_SetTmdsClockRatio(XV_HdmiTxSs *InstancePtr, u8 Ratio);
+u32 XV_HdmiTxSs_GetTmdsClockFreqHz(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_DetectHdmi20(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_RefClockChangeInit(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_ReportInfo(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_IsStreamUp(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_IsStreamConnected(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_IsStreamToggled(XV_HdmiTxSs *InstancePtr);
+u8 XV_HdmiTxSs_IsSinkHdcp14Capable(XV_HdmiTxSs *InstancePtr);
+u8 XV_HdmiTxSs_IsSinkHdcp22Capable(XV_HdmiTxSs *InstancePtr);
+
+void XV_HdmiTxSs_SetDefaultPpc(XV_HdmiTxSs *InstancePtr, u8 Id);
+void XV_HdmiTxSs_SetPpc(XV_HdmiTxSs *InstancePtr, u8 Id, u8 Ppc);
+
+#ifdef XV_HDMITXSS_LOG_ENABLE
+void XV_HdmiTxSs_LogReset(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_LogWrite(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_LogEvent Evt, u8 Data);
+u16 XV_HdmiTxSs_LogRead(XV_HdmiTxSs *InstancePtr);
+#endif
+void XV_HdmiTxSs_LogDisplay(XV_HdmiTxSs *InstancePtr);
+
+
+#ifdef USE_HDCP_TX
+void XV_HdmiTxSs_HdcpSetKey(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_HdcpKeyType KeyType, u8 *KeyPtr);
+int XV_HdmiTxSs_HdcpPoll(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpSetProtocol(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_HdcpProtocol Protocol);
+XV_HdmiTxSs_HdcpProtocol XV_HdmiTxSs_HdcpGetProtocol(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpClearEvents(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpPushEvent(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_HdcpEvent Event);
+int XV_HdmiTxSs_HdcpEnable(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpDisable(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpAuthRequest(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpEnableEncryption(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpDisableEncryption(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpEnableBlank(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpDisableBlank(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpIsEnabled(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpIsAuthenticated(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpIsEncrypted(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpIsInProgress(XV_HdmiTxSs *InstancePtr);
+
+void XV_HdmiTxSs_HdcpInfo(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_HdcpSetInfoDetail(XV_HdmiTxSs *InstancePtr, u8 Verbose);
+
+void *XV_HdmiTxSs_HdcpGetTopology(XV_HdmiTxSs *InstancePtr);
+u8 *XV_HdmiTxSs_HdcpGetTopologyReceiverIdList(XV_HdmiTxSs *InstancePtr);
+u32 XV_HdmiTxSs_HdcpGetTopologyField(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_HdcpTopologyField Field);
+
+void XV_HdmiTxSs_HdcpSetContentStreamType(XV_HdmiTxSs *InstancePtr,
+       XV_HdmiTxSs_HdcpContentStreamType StreamType);
+int XV_HdmiTxSs_HdcpIsRepeater(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpSetRepeater(XV_HdmiTxSs *InstancePtr, u8 Set);
+int XV_HdmiTxSs_HdcpIsInComputations(XV_HdmiTxSs *InstancePtr);
+int XV_HdmiTxSs_HdcpIsInWaitforready(XV_HdmiTxSs *InstancePtr);
+
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+int XV_HdmiTxSs_HdcpTimerStart(void *InstancePtr, u16 TimeoutInMs);
+int XV_HdmiTxSs_HdcpTimerStop(void *InstancePtr);
+int XV_HdmiTxSs_HdcpTimerBusyDelay(void *InstancePtr, u16 DelayInMs);
+
+void XV_HdmiTxSS_HdcpIntrHandler(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSS_HdcpTimerIntrHandler(XV_HdmiTxSs *InstancePtr);
+void XV_HdmiTxSs_HdcpTimerCallback(void *CallBackRef, u8 TimerChannel);
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+void XV_HdmiTxSS_Hdcp22TimerIntrHandler(XV_HdmiTxSs *InstancePtr);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.c
new file mode 100644
index 0000000..b279fd1
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.c
@@ -0,0 +1,432 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitxss_coreinit.c
+* @addtogroup v_hdmitxss
+* @{
+* @details
+
+* HDMI TX Subsystem Sub-Cores initialization
+* The functions in this file provides an abstraction from the initialization
+* sequence for included sub-cores. Subsystem is assigned an address and range
+* on the axi-lite interface. This address space is condensed where-in each
+* sub-core is at a fixed offset from the subsystem base address. For processor
+* to be able to access the sub-core this offset needs to be transalted into a
+* absolute address within the subsystems addressable range
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     20/01/16 Added remapper support
+* 1.2   MG     03/02/16 Added HDCP support
+* 1.3   MH     23/04/16 VTC driver has been updated to avoid processor
+*                       exceptions. Workarounds have been removed.
+* 1.4   MH     23/06/16 Added HDCP repeater support.
+* 1.5   YH     18/07/16 Replace xil_printf with xdbg_printf
+* 1.6   YH     25/07/16 Used UINTPTR instead of u32 for BaseAddr,HighAddr,Offset
+*                       AbsAddr
+* 1.7   MH     08/08/16 Updates to optimize out HDCP when excluded.
+* 1.8   YH     17/08/16 Added Event Log
+* 1.9   YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.10  MMO    03/01/17 Remove XV_HdmiTxSs_ComputeSubcoreAbsAddr API, as it
+*                            handles in the "_g" TCL generation
+*                       Re-align coding style to ensure, 80 characters per row
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include "xv_hdmitxss_coreinit.h"
+
+/************************** Constant Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+#ifdef USE_HDCP_TX
+static int XV_HdmiTxSs_DdcReadHandler(u8 DeviceAddress,
+    u16 ByteCount, u8* BufferPtr, u8 Stop, void *RefPtr);
+static int XV_HdmiTxSs_DdcWriteHandler(u8 DeviceAddress,
+    u16 ByteCount, u8* BufferPtr, u8 Stop, void *RefPtr);
+#endif
+
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_SubcoreInitHdmiTx(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+  int Status;
+  XV_HdmiTx_Config *ConfigPtr;
+
+  if (HdmiTxSsPtr->HdmiTxPtr) {
+    /* Get core configuration */
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_HDMITX_INIT, 0);
+#endif
+    ConfigPtr  = XV_HdmiTx_LookupConfig(HdmiTxSsPtr->Config.HdmiTx.DeviceId);
+    if (ConfigPtr == NULL) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "HDMITXSS ERR:: HDMI TX device not found\r\n");
+      return(XST_FAILURE);
+    }
+
+    /* Initialize core */
+    Status = XV_HdmiTx_CfgInitialize(HdmiTxSsPtr->HdmiTxPtr,
+                                    ConfigPtr,
+                                    HdmiTxSsPtr->Config.HdmiTx.AbsAddr);
+
+    if (Status != XST_SUCCESS) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "HDMITXSS ERR:: HDMI TX Initialization failed\r\n");
+      return(XST_FAILURE);
+    }
+  }
+  return(XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_SubcoreInitVtc(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+  int Status;
+  XVtc_Config *ConfigPtr;
+
+  if (HdmiTxSsPtr->VtcPtr) {
+    /* Get core configuration */
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_VTC_INIT, 0);
+#endif
+    ConfigPtr  = XVtc_LookupConfig(HdmiTxSsPtr->Config.Vtc.DeviceId);
+    if (ConfigPtr == NULL) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,"HDMITXSS ERR:: VTC device not found\r\n");
+      return(XST_FAILURE);
+    }
+
+    /* Initialize core */
+    Status = XVtc_CfgInitialize(HdmiTxSsPtr->VtcPtr,
+                                ConfigPtr,
+                                HdmiTxSsPtr->Config.Vtc.AbsAddr);
+
+    if (Status != XST_SUCCESS) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "HDMITXSS ERR:: VTC Initialization failed\r\n");
+      return(XST_FAILURE);
+    }
+  }
+  return(XST_SUCCESS);
+}
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_SubcoreInitHdcpTimer(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+  int Status;
+  XTmrCtr_Config *ConfigPtr;
+
+  if (HdmiTxSsPtr->HdcpTimerPtr) {
+    /* Get core configuration */
+#ifdef XV_HDMITXSS_LOG_ENABLE
+    XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_HDCPTIMER_INIT, 0);
+#endif
+    ConfigPtr  = XTmrCtr_LookupConfig(HdmiTxSsPtr->Config.HdcpTimer.DeviceId);
+    if (ConfigPtr == NULL) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "HDMITXSS ERR:: AXIS Timer device not found\r\n");
+      return(XST_FAILURE);
+    }
+
+    /* Setup the instance */
+    memset(HdmiTxSsPtr->HdcpTimerPtr, 0, sizeof(XTmrCtr));
+
+    /* Initialize core */
+    XTmrCtr_CfgInitialize(HdmiTxSsPtr->HdcpTimerPtr,
+                          ConfigPtr,
+                          HdmiTxSsPtr->Config.HdcpTimer.AbsAddr);
+
+    Status = XTmrCtr_InitHw(HdmiTxSsPtr->HdcpTimerPtr);
+
+    /* Set Timer Counter instance in HDCP to the generic Hdcp1xRef
+     * that will be used in callbacks */
+    HdmiTxSsPtr->Hdcp14Ptr->Hdcp1xRef = (void *)HdmiTxSsPtr->HdcpTimerPtr;
+
+    /* Initialize the hdcp timer functions */
+    XHdcp1x_SetTimerStart(HdmiTxSsPtr->Hdcp14Ptr,
+      &XV_HdmiTxSs_HdcpTimerStart);
+    XHdcp1x_SetTimerStop(HdmiTxSsPtr->Hdcp14Ptr,
+      &XV_HdmiTxSs_HdcpTimerStop);
+    XHdcp1x_SetTimerDelay(HdmiTxSsPtr->Hdcp14Ptr,
+      &XV_HdmiTxSs_HdcpTimerBusyDelay);
+
+    if (Status != XST_SUCCESS) {
+      xdbg_printf(XDBG_DEBUG_GENERAL,
+                  "HDMITXSS ERR:: AXI Timer Initialization failed\r\n");
+      return(XST_FAILURE);
+    }
+  }
+  return(XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_SubcoreInitHdcp14(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+  int Status;
+  XHdcp1x_Config *ConfigPtr;
+
+  /* Is the HDCP 1.4 TX present? */
+  if (HdmiTxSsPtr->Hdcp14Ptr) {
+
+    /* Is the key loaded? */
+    if (HdmiTxSsPtr->Hdcp14KeyPtr) {
+
+      /* Get core configuration */
+#ifdef XV_HDMITXSS_LOG_ENABLE
+      XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_HDCP14_INIT, 0);
+#endif
+      ConfigPtr  = XHdcp1x_LookupConfig(HdmiTxSsPtr->Config.Hdcp14.DeviceId);
+      if (ConfigPtr == NULL){
+        xdbg_printf(XDBG_DEBUG_GENERAL,
+                    "HDMITXSS ERR:: HDCP 1.4 device not found\r\n");
+        return(XST_FAILURE);
+      }
+
+      /* Initialize core */
+      void *PhyIfPtr = HdmiTxSsPtr->HdmiTxPtr;
+
+      Status = XHdcp1x_CfgInitialize(HdmiTxSsPtr->Hdcp14Ptr,
+                                        ConfigPtr,
+                                        PhyIfPtr,
+                                        HdmiTxSsPtr->Config.Hdcp14.AbsAddr);
+
+      /* Self-test the hdcp interface */
+      if (XHdcp1x_SelfTest(HdmiTxSsPtr->Hdcp14Ptr) != XST_SUCCESS) {
+          Status = XST_FAILURE;
+      }
+
+      /* Set-up the DDC Handlers */
+      XHdcp1x_SetCallback(HdmiTxSsPtr->Hdcp14Ptr,
+                          XHDCP1X_HANDLER_DDC_WRITE,
+                          (void *)XV_HdmiTxSs_DdcWriteHandler,
+						  (void *)HdmiTxSsPtr->HdmiTxPtr);
+
+      XHdcp1x_SetCallback(HdmiTxSsPtr->Hdcp14Ptr,
+                          XHDCP1X_HANDLER_DDC_READ,
+						  (void *)XV_HdmiTxSs_DdcReadHandler,
+						  (void *)HdmiTxSsPtr->HdmiTxPtr);
+
+      if (Status != XST_SUCCESS) {
+        xdbg_printf(XDBG_DEBUG_GENERAL,
+                    "HDMITXSS ERR:: HDCP 1.4 Initialization failed\r\n");
+        return(XST_FAILURE);
+      }
+
+      /* Key select */
+      XHdcp1x_SetKeySelect(HdmiTxSsPtr->Hdcp14Ptr, XV_HDMITXSS_HDCP_KEYSEL);
+
+      /* Load SRM */
+
+
+      /* Disable HDCP 1.4 repeater */
+      HdmiTxSsPtr->Hdcp14Ptr->IsRepeater = 0;
+    }
+  }
+  return(XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiTxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiTxSs_SubcoreInitHdcp22(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+  int Status;
+  XHdcp22_Tx_Config *Hdcp22TxConfig;
+
+  /* Is the HDCP 2.2 TX present? */
+  if (HdmiTxSsPtr->Hdcp22Ptr) {
+
+    /* Is the key loaded? */
+    if (HdmiTxSsPtr->Hdcp22Lc128Ptr && HdmiTxSsPtr->Hdcp22SrmPtr) {
+
+      /* Get core configuration */
+#ifdef XV_HDMITXSS_LOG_ENABLE
+      XV_HdmiTxSs_LogWrite(HdmiTxSsPtr, XV_HDMITXSS_LOG_EVT_HDCP22_INIT, 0);
+#endif
+      /* Initialize HDCP 2.2 TX */
+      Hdcp22TxConfig =
+                    XHdcp22Tx_LookupConfig(HdmiTxSsPtr->Config.Hdcp22.DeviceId);
+
+      if (Hdcp22TxConfig == NULL) {
+        xdbg_printf(XDBG_DEBUG_GENERAL,
+                    "HDMITXSS ERR:: HDCP 2.2 device not found\r\n");
+        return XST_FAILURE;
+      }
+
+      Status = XHdcp22Tx_CfgInitialize(HdmiTxSsPtr->Hdcp22Ptr,
+                                       Hdcp22TxConfig,
+                                       HdmiTxSsPtr->Config.Hdcp22.AbsAddr);
+      if (Status != XST_SUCCESS) {
+        xdbg_printf(XDBG_DEBUG_GENERAL,
+                    "HDMITXSS ERR:: HDCP 2.2 Initialization failed\r\n");
+        return Status;
+      }
+
+      /* Set-up the DDC Handlers */
+      XHdcp22Tx_SetCallback(HdmiTxSsPtr->Hdcp22Ptr,
+                            XHDCP22_TX_HANDLER_DDC_WRITE,
+							(void *)XV_HdmiTxSs_DdcWriteHandler,
+							(void *)HdmiTxSsPtr->HdmiTxPtr);
+
+      XHdcp22Tx_SetCallback(HdmiTxSsPtr->Hdcp22Ptr,
+                            XHDCP22_TX_HANDLER_DDC_READ,
+							(void *)XV_HdmiTxSs_DdcReadHandler,
+							(void *)HdmiTxSsPtr->HdmiTxPtr);
+
+      /* Set polling value */
+      XHdcp22Tx_SetMessagePollingValue(HdmiTxSsPtr->Hdcp22Ptr, 2);
+
+      XHdcp22Tx_LogReset(HdmiTxSsPtr->Hdcp22Ptr, FALSE);
+
+      /* Load key */
+      XHdcp22Tx_LoadLc128(HdmiTxSsPtr->Hdcp22Ptr, HdmiTxSsPtr->Hdcp22Lc128Ptr);
+
+      /* Load SRM */
+      Status = XHdcp22Tx_LoadRevocationTable(HdmiTxSsPtr->Hdcp22Ptr,
+                                             HdmiTxSsPtr->Hdcp22SrmPtr);
+      if (Status != XST_SUCCESS) {
+        xdbg_printf(XDBG_DEBUG_GENERAL,
+                    "HDMITXSS ERR:: HDCP 2.2 failed to load SRM\r\n");
+        return Status;
+      }
+
+      /* Clear the event queue */
+      XV_HdmiTxSs_HdcpClearEvents(HdmiTxSsPtr);
+    }
+  }
+
+  return (XST_SUCCESS);
+}
+#endif
+
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC read handler for the TX.
+ *
+ * @param DeviceAddress is the 7-bit I2C slave address
+ *
+ * @param ByteCount is the number of bytes to read
+ *
+ * @param BufferPtr is a pointer to the buffer where
+ *        the read data is written to.
+ *
+ * @param Stop indicates if a I2C stop condition is generated
+ *        at the end of the burst.
+ *
+ * @param RefPtr is a callback reference to the HDMI TX instance
+ *
+ * @return
+ *  - XST_SUCCESS if action was successful
+ *  - XST_FAILURE if action was not successful
+ *
+ ******************************************************************************/
+static int XV_HdmiTxSs_DdcReadHandler(u8 DeviceAddress,
+    u16 ByteCount, u8* BufferPtr, u8 Stop, void *RefPtr)
+{
+  XV_HdmiTx *InstancePtr = (XV_HdmiTx *)RefPtr;
+  return XV_HdmiTx_DdcRead(InstancePtr,
+                           DeviceAddress,
+                           ByteCount,
+                           BufferPtr,
+                           Stop);
+}
+
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC write handler for the TX.
+ *
+ * @param DeviceAddress is the 7-bit I2C slave address
+ *
+ * @param ByteCount is the number of bytes to write
+ *
+ * @param BufferPtr is a pointer to the buffer containing
+ *        the data to be written.
+ *
+ * @param Stop indicates if a I2C stop condition is generated
+ *        at the end of the burst.
+ *
+ * @param RefPtr is a callback reference to the HDMI TX instance
+ *
+ * @return
+ *  - XST_SUCCESS if action was successful
+ *  - XST_FAILURE if action was not successful
+ *
+ ******************************************************************************/
+static int XV_HdmiTxSs_DdcWriteHandler(u8 DeviceAddress,
+    u16 ByteCount, u8* BufferPtr, u8 Stop, void *RefPtr)
+{
+  XV_HdmiTx *InstancePtr = (XV_HdmiTx *)RefPtr;
+  return XV_HdmiTx_DdcWrite(InstancePtr,
+                            DeviceAddress,
+                            ByteCount,
+                            BufferPtr,
+                            Stop);
+}
+#endif
+
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.h
new file mode 100644
index 0000000..60c4560
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_coreinit.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitxss_coreinit.h
+* @addtogroup v_hdmitxss
+* @{
+* @details
+*
+* This header file contains the hdmi tx subsystem sub-cores
+* initialization routines and helper functions.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     20/01/16 Added remapper support
+* 1.2   MG     03/02/16 Added HDCP support
+* 1.3   MH     08/08/16 Updates to optimize out HDCP when excluded.
+* 1.4   YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.5   MMO    03/01/16 Remove repetitive inclusion of header files
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMITXSS_COREINIT_H__  /* prevent circular inclusions */
+#define XV_HDMITXSS_COREINIT_H__  /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "xv_hdmitxss.h"
+/************************** Constant Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+int XV_HdmiTxSs_SubcoreInitHdmiTx(XV_HdmiTxSs *HdmiTxSsPtr);
+int XV_HdmiTxSs_SubcoreInitVtc(XV_HdmiTxSs *HdmiTxSsPtr);
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+int XV_HdmiTxSs_SubcoreInitHdcpTimer(XV_HdmiTxSs *HdmiTxSsPtr);
+int XV_HdmiTxSs_SubcoreInitHdcp14(XV_HdmiTxSs *HdmiTxSsPtr);
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+int XV_HdmiTxSs_SubcoreInitHdcp22(XV_HdmiTxSs *HdmiTxSsPtr);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_hdcp.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_hdcp.c
new file mode 100644
index 0000000..b506796
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_hdcp.c
@@ -0,0 +1,2246 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmitxss_hdcp.c
+*
+* This is main code of Xilinx HDMI Transmitter Subsystem device driver.
+* Please see xv_hdmitxss.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00   MMO 19/12/16 Move HDCP Code from xv_hdmitxss.c to xv_hdmitxss_hdcp.c
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include "xv_hdmitxss.h"
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/**************************** Local Global ***********************************/
+
+/************************** Function Prototypes ******************************/
+// HDCP specific
+#ifdef USE_HDCP_TX
+static XV_HdmiTxSs_HdcpEvent XV_HdmiTxSs_HdcpGetEvent(XV_HdmiTxSs *InstancePtr);
+static int XV_HdmiTxSs_HdcpProcessEvents(XV_HdmiTxSs *InstancePtr);
+static int XV_HdmiTxSs_HdcpReset(XV_HdmiTxSs *InstancePtr);
+static u32 XV_HdmiTxSs_HdcpGetTopologyDepth(XV_HdmiTxSs *InstancePtr);
+static u32 XV_HdmiTxSs_HdcpGetTopologyDeviceCnt(XV_HdmiTxSs *InstancePtr);
+static u8 XV_HdmiTxSs_HdcpGetTopologyMaxDevsExceeded(XV_HdmiTxSs *InstancePtr);
+static u8
+        XV_HdmiTxSs_HdcpGetTopologyMaxCascadeExceeded(XV_HdmiTxSs *InstancePtr);
+static u8
+  XV_HdmiTxSs_HdcpGetTopologyHdcp20RepeaterDownstream(XV_HdmiTxSs *InstancePtr);
+static u8
+     XV_HdmiTxSs_HdcpGetTopologyHdcp1DeviceDownstream(XV_HdmiTxSs *InstancePtr);
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+static u32 XV_HdmiTxSs_HdcpTimerConvUsToTicks(u32 TimeoutInUs,
+    u32 ClockFrequency);
+#endif
+
+/***************** Macros (Inline Functions) Definitions *********************/
+/************************** Function Definition ******************************/
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_HdcpIntrHandler(XV_HdmiTxSs *InstancePtr)
+{
+    XHdcp1x_CipherIntrHandler(InstancePtr->Hdcp14Ptr);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP Timer
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_HdcpTimerIntrHandler(XV_HdmiTxSs *InstancePtr)
+{
+    XTmrCtr_InterruptHandler(InstancePtr->HdcpTimerPtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP 2.2 Timer
+ *
+ * @param  InstancePtr is a pointer to the HDMI TX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiTxSS_Hdcp22TimerIntrHandler(XV_HdmiTxSs *InstancePtr)
+{
+  XTmrCtr *XTmrCtrPtr;
+
+  XTmrCtrPtr = XHdcp22Tx_GetTimer(InstancePtr->Hdcp22Ptr);
+
+  XTmrCtr_InterruptHandler(XTmrCtrPtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function converts from microseconds to timer ticks
+*
+* @param TimeoutInUs  the timeout to convert
+* @param ClockFrequency  the clock frequency to use in the conversion
+*
+* @return
+*   The number of "ticks"
+*
+* @note
+*   None.
+*
+******************************************************************************/
+static u32 XV_HdmiTxSs_HdcpTimerConvUsToTicks(u32 TimeoutInUs,
+                                                    u32 ClockFrequency)
+{
+    u32 TimeoutFreq = 0;
+    u32 NumTicks = 0;
+
+    /* Check for greater than one second */
+    if (TimeoutInUs > 1000000ul) {
+        u32 NumSeconds = 0;
+
+        /* Determine theNumSeconds */
+        NumSeconds = (TimeoutInUs/1000000ul);
+
+        /* Update theNumTicks */
+        NumTicks = (NumSeconds*ClockFrequency);
+
+        /* Adjust theTimeoutInUs */
+        TimeoutInUs -= (NumSeconds*1000000ul);
+    }
+
+    /* Convert TimeoutFreq to a frequency */
+    TimeoutFreq  = 1000;
+    TimeoutFreq *= 1000;
+    TimeoutFreq /= TimeoutInUs;
+
+    /* Update NumTicks */
+    NumTicks += ((ClockFrequency / TimeoutFreq) + 1);
+
+    return (NumTicks);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+*
+* This function serves as the timer callback function
+*
+* @param CallBackRef  the callback reference value
+* @param TimerChannel  the channel within the timer that expired
+*
+* @return
+*   void
+*
+* @note
+*   None
+*
+******************************************************************************/
+void XV_HdmiTxSs_HdcpTimerCallback(void* CallBackRef, u8 TimerChannel)
+{
+    XHdcp1x* HdcpPtr = (XHdcp1x*) CallBackRef;
+
+    TimerChannel = TimerChannel;
+    XHdcp1x_HandleTimeout(HdcpPtr);
+    return;
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function starts a timer on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+* @param TimeoutInMs  the timer duration in milliseconds
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpTimerStart(void *InstancePtr, u16 TimeoutInMs)
+{
+    XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+    XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+    u8 TimerChannel = 0;
+    u32 TimerOptions = 0;
+    u32 NumTicks = 0;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(TimerPtr != NULL);
+
+
+    /* Determine NumTicks */
+    NumTicks = XV_HdmiTxSs_HdcpTimerConvUsToTicks((TimeoutInMs*1000ul),
+                  TimerPtr->Config.SysClockFreqHz);
+
+
+    /* Stop it */
+    XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+    /* Configure the callback */
+    XTmrCtr_SetHandler(TimerPtr, &XV_HdmiTxSs_HdcpTimerCallback,
+                                                (void*) HdcpPtr);
+
+    /* Configure the timer options */
+    TimerOptions  = XTmrCtr_GetOptions(TimerPtr, TimerChannel);
+    TimerOptions |=  XTC_DOWN_COUNT_OPTION;
+    TimerOptions |=  XTC_INT_MODE_OPTION;
+    TimerOptions &= ~XTC_AUTO_RELOAD_OPTION;
+    XTmrCtr_SetOptions(TimerPtr, TimerChannel, TimerOptions);
+
+    /* Set the timeout and start */
+    XTmrCtr_SetResetValue(TimerPtr, TimerChannel, NumTicks);
+    XTmrCtr_Start(TimerPtr, TimerChannel);
+
+    return (XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function stops a timer on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpTimerStop(void *InstancePtr)
+{
+    XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+    XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+    u8 TimerChannel = 0;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(TimerPtr != NULL);
+
+    /* Stop it */
+    XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+    return (XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function busy waits for an interval on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+* @param DelayInMs  the delay duration in milliseconds
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpTimerBusyDelay(void *InstancePtr, u16 DelayInMs)
+{
+    XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+    XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+    u8 TimerChannel = 0;
+    u32 TimerOptions = 0;
+    u32 NumTicks = 0;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(TimerPtr != NULL);
+
+
+    /* Determine NumTicks */
+    NumTicks = XV_HdmiTxSs_HdcpTimerConvUsToTicks((DelayInMs*1000ul),
+                  TimerPtr->Config.SysClockFreqHz);
+
+    /* Stop it */
+    XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+    /* Configure the timer options */
+    TimerOptions  = XTmrCtr_GetOptions(TimerPtr, TimerChannel);
+    TimerOptions |=  XTC_DOWN_COUNT_OPTION;
+    TimerOptions &= ~XTC_INT_MODE_OPTION;
+    TimerOptions &= ~XTC_AUTO_RELOAD_OPTION;
+    XTmrCtr_SetOptions(TimerPtr, TimerChannel, TimerOptions);
+
+    /* Set the timeout and start */
+    XTmrCtr_SetResetValue(TimerPtr, TimerChannel, NumTicks);
+    XTmrCtr_Start(TimerPtr, TimerChannel);
+
+    /* Wait until done */
+    while (!XTmrCtr_IsExpired(TimerPtr, TimerChannel));
+
+    return (XST_SUCCESS);
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function pushes an event into the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+* @param Event is the event to be pushed in the queue.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpPushEvent(XV_HdmiTxSs *InstancePtr,
+                              XV_HdmiTxSs_HdcpEvent Event)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(Event < XV_HDMITXSS_HDCP_INVALID_EVT);
+
+  /* Write event into the queue */
+  InstancePtr->HdcpEventQueue.Queue[InstancePtr->HdcpEventQueue.Head] = Event;
+
+  /* Update head pointer */
+  if (InstancePtr->HdcpEventQueue.Head ==
+                                        (XV_HDMITXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+    InstancePtr->HdcpEventQueue.Head = 0;
+  }
+  else {
+    InstancePtr->HdcpEventQueue.Head++;
+  }
+
+  /* Check tail pointer. When the two pointer are equal, then the buffer
+   * is full. In this case then increment the tail pointer as well to
+   * remove the oldest entry from the buffer.
+   */
+  if (InstancePtr->HdcpEventQueue.Tail == InstancePtr->HdcpEventQueue.Head) {
+    if (InstancePtr->HdcpEventQueue.Tail ==
+                                        (XV_HDMITXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+      InstancePtr->HdcpEventQueue.Tail = 0;
+    }
+    else {
+      InstancePtr->HdcpEventQueue.Tail++;
+    }
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets an event from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return When the queue is filled, the next event is returned.
+*         When the queue is empty, XV_HDMITXSS_HDCP_NO_EVT is returned.
+*
+* @note   None.
+*
+******************************************************************************/
+static XV_HdmiTxSs_HdcpEvent XV_HdmiTxSs_HdcpGetEvent(XV_HdmiTxSs *InstancePtr)
+{
+  XV_HdmiTxSs_HdcpEvent Event;
+
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  /* Check if there are any events in the queue */
+  if (InstancePtr->HdcpEventQueue.Tail == InstancePtr->HdcpEventQueue.Head) {
+    return XV_HDMITXSS_HDCP_NO_EVT;
+  }
+
+  Event = InstancePtr->HdcpEventQueue.Queue[InstancePtr->HdcpEventQueue.Tail];
+
+  /* Update tail pointer */
+  if (InstancePtr->HdcpEventQueue.Tail ==
+                                        (XV_HDMITXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+    InstancePtr->HdcpEventQueue.Tail = 0;
+  }
+  else {
+    InstancePtr->HdcpEventQueue.Tail++;
+  }
+
+  return Event;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function clears all pending events from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpClearEvents(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  InstancePtr->HdcpEventQueue.Head = 0;
+  InstancePtr->HdcpEventQueue.Tail = 0;
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function processes pending events from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiTxSs_HdcpProcessEvents(XV_HdmiTxSs *InstancePtr)
+{
+  XV_HdmiTxSs_HdcpEvent Event;
+  int Status = XST_SUCCESS;
+
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  Event = XV_HdmiTxSs_HdcpGetEvent(InstancePtr);
+  switch (Event) {
+
+    // Stream up
+    // Attempt authentication with downstream device
+    case XV_HDMITXSS_HDCP_STREAMUP_EVT :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        // Set physical state
+        XHdcp1x_SetPhysicalState(InstancePtr->Hdcp14Ptr, TRUE);
+        // This is needed to ensure that the previous command is executed.
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+#endif
+      break;
+
+    // Stream down
+    case XV_HDMITXSS_HDCP_STREAMDOWN_EVT :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        // Set physical state
+        XHdcp1x_SetPhysicalState(InstancePtr->Hdcp14Ptr, FALSE);
+        // This is needed to ensure that the previous command is executed.
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+#endif
+      XV_HdmiTxSs_HdcpReset(InstancePtr);
+      break;
+
+    // Connect
+    case XV_HDMITXSS_HDCP_CONNECT_EVT :
+      break;
+
+    // Disconnect
+    // Reset both HDCP protocols
+    case XV_HDMITXSS_HDCP_DISCONNECT_EVT :
+      XV_HdmiTxSs_HdcpReset(InstancePtr);
+      break;
+
+    // Authenticate
+    case XV_HDMITXSS_HDCP_AUTHENTICATE_EVT :
+      XV_HdmiTxSs_HdcpAuthRequest(InstancePtr);
+      break;
+
+    default :
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function schedules the available HDCP cores. Only the active
+* HDCP protocol poll function is executed. HDCP 1.4 and 2.2 poll
+* functions should not execute in parallel.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpPoll(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  /* Only poll when the HDCP is ready */
+  if (InstancePtr->HdcpIsReady) {
+
+    /* Process any pending events from the TX event queue */
+    XV_HdmiTxSs_HdcpProcessEvents(InstancePtr);
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    if (InstancePtr->Hdcp22Ptr) {
+      if (XHdcp22Tx_IsEnabled(InstancePtr->Hdcp22Ptr)) {
+       XHdcp22Tx_Poll(InstancePtr->Hdcp22Ptr);
+      }
+    }
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    if (InstancePtr->Hdcp14Ptr) {
+      if (XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr)) {
+       XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+    }
+#endif
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function sets the active HDCP protocol and enables it.
+* The protocol can be set to either HDCP 1.4, 2.2, or None.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+* @param Protocol is the requested content protection scheme of type
+*        XV_HdmiTxSs_HdcpProtocol.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpSetProtocol(XV_HdmiTxSs *InstancePtr,
+                                XV_HdmiTxSs_HdcpProtocol Protocol)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid((Protocol == XV_HDMITXSS_HDCP_NONE)   ||
+                    (Protocol == XV_HDMITXSS_HDCP_14) ||
+                    (Protocol == XV_HDMITXSS_HDCP_22));
+
+  int Status;
+
+  // Set protocol
+  InstancePtr->HdcpProtocol = Protocol;
+
+  // Reset both protocols
+  Status = XV_HdmiTxSs_HdcpReset(InstancePtr);
+  if (Status != XST_SUCCESS) {
+    InstancePtr->HdcpProtocol = XV_HDMITXSS_HDCP_NONE;
+    return XST_FAILURE;
+  }
+
+  // Enable the requested protocol
+  Status = XV_HdmiTxSs_HdcpEnable(InstancePtr);
+  if (Status != XST_SUCCESS) {
+    InstancePtr->HdcpProtocol = XV_HDMITXSS_HDCP_NONE;
+    return XST_FAILURE;
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the active HDCP content protection scheme.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  @RequestedScheme is the requested content protection scheme.
+*
+* @note   None.
+*
+******************************************************************************/
+XV_HdmiTxSs_HdcpProtocol XV_HdmiTxSs_HdcpGetProtocol(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  return InstancePtr->HdcpProtocol;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function enables the requested HDCP protocol. This function
+* ensures that the HDCP protocols are mutually exclusive such that
+* either HDCP 1.4 or HDCP 2.2 is enabled and active at any given time.
+* When the protocol is set to None, both HDCP protocols are disabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpEnable(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status1 = XST_SUCCESS;
+  int Status2 = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol) {
+
+    /* Disable HDCP 1.4 and HDCP 2.2 */
+    case XV_HDMITXSS_HDCP_NONE :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+        // This is needed to ensure that the previous command is executed.
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Tx_Disable(InstancePtr->Hdcp22Ptr);
+      }
+#endif
+      break;
+
+    /* Enable HDCP 1.4 and disable HDCP 2.2 */
+    case XV_HDMITXSS_HDCP_14 :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Enable(InstancePtr->Hdcp14Ptr);
+        // This is needed to ensure that the previous command is executed.
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+      else {
+        Status1 = XST_FAILURE;
+      }
+#else
+      Status1 = XST_FAILURE;
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Tx_Disable(InstancePtr->Hdcp22Ptr);
+      }
+#endif
+      break;
+
+    /* Enable HDCP 2.2 and disable HDCP 1.4 */
+    case XV_HDMITXSS_HDCP_22 :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+        // This is needed to ensure that the previous command is executed.
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Tx_Enable(InstancePtr->Hdcp22Ptr);
+      }
+      else {
+        Status2 = XST_FAILURE;
+      }
+#else
+      Status2 = XST_FAILURE;
+#endif
+      break;
+
+    default :
+      return XST_FAILURE;
+  }
+
+  return (Status1 == XST_SUCCESS &&
+          Status2 == XST_SUCCESS) ?
+          XST_SUCCESS : XST_FAILURE;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function disables both HDCP 1.4 and 2.2 protocols.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpDisable(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  if (InstancePtr->Hdcp14Ptr) {
+    Status = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+    // This is needed to ensure that the previous command is executed.
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    Status = XHdcp22Tx_Disable(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function resets both HDCP 1.4 and 2.2 protocols. This function
+* also disables the both HDCP 1.4 and 2.2 protocols.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiTxSs_HdcpReset(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  // Resetting HDCP 1.4 causes the state machine to be enabled, therefore
+  // disable must be called immediately after reset is called.
+  if (InstancePtr->Hdcp14Ptr) {
+    Status = XHdcp1x_Reset(InstancePtr->Hdcp14Ptr);
+    // This is needed to ensure that the previous command is executed.
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+
+    Status = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+    // This is needed to ensure that the previous command is executed.
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    Status = XHdcp22Tx_Reset(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+
+    Status = XHdcp22Tx_Disable(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+  // Set defaults
+  XV_HdmiTxSs_HdcpDisableBlank(InstancePtr);
+  XV_HdmiTxSs_HdcpDisableEncryption(InstancePtr);
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function sends an authentication request to the connected receiver.
+* The HDCP protocol is determined automatically by checking the capabilities
+* of the connected device. When the connected device supports both HDCP 1.4
+* and HDCP 2.2, then HDCP 2.2 is given priority.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if authentication started successfully
+*  - XST_FAILURE if authentication did not start successfully
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpAuthRequest(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_FAILURE;
+
+  /* Always disable encryption */
+  if (XV_HdmiTxSs_HdcpDisableEncryption(InstancePtr) != XST_SUCCESS) {
+    XV_HdmiTxSs_HdcpSetProtocol(InstancePtr, XV_HDMITXSS_HDCP_NONE);
+    return XST_FAILURE;
+  }
+
+  /* Verify if sink is attached */
+  if (!XV_HdmiTx_IsStreamConnected(InstancePtr->HdmiTxPtr)) {
+    xdbg_printf(XDBG_DEBUG_GENERAL, "No sink is attached\r\n");
+    XV_HdmiTxSs_HdcpSetProtocol(InstancePtr, XV_HDMITXSS_HDCP_NONE);
+    return XST_FAILURE;
+  }
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  /* Authenticate HDCP 2.2, takes priority */
+  if (InstancePtr->Hdcp22Ptr) {
+    if (XV_HdmiTxSs_IsSinkHdcp22Capable(InstancePtr)) {
+      xdbg_printf(XDBG_DEBUG_GENERAL, "Starting HDCP 2.2 authentication\r\n");
+#ifdef XV_HDMITXSS_LOG_ENABLE
+      XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_HDCP22_AUTHREQ, 0);
+#endif
+	  Status = XV_HdmiTxSs_HdcpSetProtocol(InstancePtr, XV_HDMITXSS_HDCP_22);
+      Status |= XHdcp22Tx_Authenticate(InstancePtr->Hdcp22Ptr);
+    }
+    else {
+      Status = XST_FAILURE;
+      xdbg_printf(XDBG_DEBUG_GENERAL, "Sink is not HDCP 2.2 capable\r\n");
+    }
+  }
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  /* Authenticate HDCP 1.4 */
+  if ((InstancePtr->Hdcp14Ptr) && (Status == XST_FAILURE)) {
+    if (XV_HdmiTxSs_IsSinkHdcp14Capable(InstancePtr)) {
+      xdbg_printf(XDBG_DEBUG_GENERAL, "Starting HDCP 1.4 authentication\r\n");
+#ifdef XV_HDMITXSS_LOG_ENABLE
+      XV_HdmiTxSs_LogWrite(InstancePtr, XV_HDMITXSS_LOG_EVT_HDCP14_AUTHREQ, 0);
+#endif
+      Status = XV_HdmiTxSs_HdcpSetProtocol(InstancePtr, XV_HDMITXSS_HDCP_14);
+      Status |= XHdcp1x_Authenticate(InstancePtr->Hdcp14Ptr);
+    }
+    else {
+      Status = XST_FAILURE;
+      xdbg_printf(XDBG_DEBUG_GENERAL, "Sink is not HDCP 1.4 capable\r\n");
+    }
+  }
+#endif
+
+  /* Set protocol to None */
+  if (Status == XST_FAILURE) {
+    XV_HdmiTxSs_HdcpSetProtocol(InstancePtr, XV_HDMITXSS_HDCP_NONE);
+  }
+
+  return (Status == XST_SUCCESS) ? XST_SUCCESS : XST_FAILURE;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function enables encryption for the active HDCP protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpEnableEncryption(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      if (InstancePtr->Hdcp14Ptr) {
+        Status = XHdcp1x_EnableEncryption(InstancePtr->Hdcp14Ptr, 0x1);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      if (InstancePtr->Hdcp22Ptr) {
+        Status = XHdcp22Tx_EnableEncryption(InstancePtr->Hdcp22Ptr);
+      }
+      break;
+#endif
+
+    default :
+      Status = XST_FAILURE;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function disables encryption for both HDCP protocols.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpDisableEncryption(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (InstancePtr->Hdcp14Ptr) {
+    Status = XHdcp1x_DisableEncryption(InstancePtr->Hdcp14Ptr, 0x1);
+
+    if (Status != XST_SUCCESS) {
+      return XST_FAILURE;
+    }
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  if (InstancePtr->Hdcp22Ptr) {
+    Status = XHdcp22Tx_DisableEncryption(InstancePtr->Hdcp22Ptr);
+
+    if (Status != XST_SUCCESS) {
+      return XST_FAILURE;
+    }
+  }
+#endif
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function enables cipher blank for the active HDCP protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpEnableBlank(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_Enable(InstancePtr->Hdcp14Ptr);
+        XHdcp1x_EnableBlank(InstancePtr->Hdcp14Ptr);
+        return XST_SUCCESS;
+      }
+#endif
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Tx_Enable(InstancePtr->Hdcp22Ptr);
+        XHdcp22Tx_EnableBlank(InstancePtr->Hdcp22Ptr);
+        return XST_SUCCESS;
+      }
+#endif
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_EnableBlank(InstancePtr->Hdcp14Ptr);
+        return XST_SUCCESS;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Tx_EnableBlank(InstancePtr->Hdcp22Ptr);
+        return XST_SUCCESS;
+      }
+      break;
+#endif
+
+    default :
+      /* Do nothing */
+      break;
+  }
+
+  return XST_FAILURE;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function disables cipher blank for both HDCP protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpDisableBlank(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (InstancePtr->Hdcp14Ptr) {
+    XHdcp1x_DisableBlank(InstancePtr->Hdcp14Ptr);
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  if (InstancePtr->Hdcp22Ptr) {
+    XHdcp22Tx_DisableBlank(InstancePtr->Hdcp22Ptr);
+  }
+#endif
+
+  return XST_SUCCESS;
+}
+#endif
+
+/*****************************************************************************/
+/**
+*
+* This function determines if the connected HDMI sink has HDCP 1.4 capabilities.
+* The sink is determined to be HDCP 1.4 capable the BKSV indicates 20 ones and
+* 20 zeros. If the sink is capable of HDCP 1.4, then this function checks if
+* the Bcaps register indicates that the connected device a DVI or HDMI receiver.
+* If the receiver is determined to be HDMI, then the function will return FALSE
+* until the receiver has set the HDMI_MODE in the Bstatus register.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if sink is HDCP 1.4 capable and ready to authenticate.
+*  - FALSE if sink does not support HDCP 1.4 or is not ready.
+*
+******************************************************************************/
+u8 XV_HdmiTxSs_IsSinkHdcp14Capable(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  int status;
+  u8 buffer[5];
+  u8 temp = 0;
+  int zero_count = 0;
+  int one_count = 0;
+  int i,j;
+
+  if (InstancePtr->Hdcp14Ptr) {
+    buffer[0] = 0x0; // XHDCP14_BKSV_REG
+    status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr,
+                                0x3A,
+                                1,
+                                (u8*)&buffer,
+                                FALSE);
+    if (status != XST_SUCCESS)
+      return FALSE;
+
+    /* Read the receiver KSV and count the number of ones and zeros.
+       A valid KSV has 20 ones and 20 zeros. */
+    status = XV_HdmiTx_DdcRead(InstancePtr->HdmiTxPtr,
+                               0x3A,
+                               5,
+                               (u8*)&buffer,
+                               TRUE);
+    if (status != XST_SUCCESS)
+      return FALSE;
+
+    for(i = 0; i < 5; i++) {
+      temp = buffer[i];
+
+      for(j = 0; j < 8; j++) {
+        if(temp & 0x1)
+          one_count++;
+        else
+          zero_count++;
+
+        temp = temp >> 1;
+      }
+    }
+
+    if (one_count != 20 || zero_count != 20)
+      return FALSE;
+
+    /* Check if the sink device is ready to authenticate */
+    if (XHdcp1x_IsDwnstrmCapable(InstancePtr->Hdcp14Ptr)) {
+      return TRUE;
+    }
+  }
+  else {
+    return FALSE;
+  }
+#endif
+
+  return FALSE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function determines if the connected HDMI sink has HDCP 2.2 capabilities.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if sink is HDCP 2.2 capable
+*  - FALSE if sink does not support HDCP 2.2 or HDCP 2.2 is not available.
+*
+******************************************************************************/
+u8 XV_HdmiTxSs_IsSinkHdcp22Capable(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  int status;
+  u8 data = 0x50; // XHDCP2_VERSION_REG
+
+  if (InstancePtr->Hdcp22Ptr) {
+    /* Write the register offset */
+    status = XV_HdmiTx_DdcWrite(InstancePtr->HdmiTxPtr, 0x3A, 1, (u8*)&data, FALSE);
+    if (status != XST_SUCCESS)
+      return FALSE;
+
+    /* Read the HDCP2 version */
+    status = XV_HdmiTx_DdcRead(InstancePtr->HdmiTxPtr, 0x3A, 1, (u8*)&data, TRUE);
+    if (status != XST_SUCCESS)
+      return FALSE;
+
+    /* Check the HDCP2.2 version */
+    if(data & 0x4)
+      return TRUE;
+    else
+      return FALSE;
+  }
+  else {
+    return FALSE;
+  }
+#endif
+
+  return FALSE;
+}
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is enabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol is enabled
+*  - FALSE if active protocol is disabled
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsEnabled(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      return XHdcp22Tx_IsEnabled(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is authenticated.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol is authenticated
+*  - FALSE if active protocol is not authenticated
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsAuthenticated(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsAuthenticated(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      return XHdcp22Tx_IsAuthenticated(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol has encryption enabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol has encryption enabled
+*  - FALSE if active protocol has encryption disabled
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsEncrypted(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsEncrypted(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      return XHdcp22Tx_IsEncryptionEnabled(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is busy authenticating.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol is busy authenticating
+*  - FALSE if active protocol is not busy authenticating
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsInProgress(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsInProgress(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_22 :
+      return XHdcp22Tx_IsInProgress(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is in computations state.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol is in computations state
+*  - FALSE if active protocol is not in computations state
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsInComputations(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsInComputations(InstancePtr->Hdcp14Ptr);
+#endif
+
+    case XV_HDMITXSS_HDCP_22 :
+      return FALSE;
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is in wait-for-ready state.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*  - TRUE if active protocol is in computations state
+*  - FALSE if active protocol is not in computations state
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsInWaitforready(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14 :
+      return XHdcp1x_IsInWaitforready(InstancePtr->Hdcp14Ptr);
+#endif
+
+    case XV_HDMITXSS_HDCP_22 :
+      return FALSE;
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function sets pointers to the HDCP 1.4 and HDCP 2.2 keys and
+* System Renewability Message (SRM).
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_HdcpSetKey(XV_HdmiTxSs *InstancePtr,
+                            XV_HdmiTxSs_HdcpKeyType KeyType,
+                            u8 *KeyPtr)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+  Xil_AssertVoid(KeyType <= XV_HDMITXSS_KEY_INVALID);
+
+  switch (KeyType) {
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2 LC128
+    case XV_HDMITXSS_KEY_HDCP22_LC128 :
+      InstancePtr->Hdcp22Lc128Ptr = KeyPtr;
+      break;
+
+    // HDCP 2.2 SRM
+    case XV_HDMITXSS_KEY_HDCP22_SRM :
+      InstancePtr->Hdcp22SrmPtr = KeyPtr;
+      break;
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_KEY_HDCP14 :
+      InstancePtr->Hdcp14KeyPtr = KeyPtr;
+      break;
+
+    // HDCP 1.4 SRM
+    case XV_HDMITXSS_KEY_HDCP14_SRM :
+      InstancePtr->Hdcp14SrmPtr = KeyPtr;
+      break;
+#endif
+
+    default :
+      break;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function reports the HDCP info
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_HdcpInfo(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMITXSS_HDCP_NONE :
+      xil_printf("\r\nHDCP TX is disabled\r\n");
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14 :
+      if (InstancePtr->Hdcp14Ptr) {
+        if (XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr)) {
+          xil_printf("\r\nHDCP 1.4 TX Info\r\n");
+
+          // Route debug output to xil_printf
+          XHdcp1x_SetDebugPrintf(xil_printf);
+
+          // Display info
+          XHdcp1x_Info(InstancePtr->Hdcp14Ptr);
+        }
+        else {
+          xil_printf("\r\nHDCP 1.4 TX is disabled\r\n");
+        }
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22 :
+      if (InstancePtr->Hdcp22Ptr) {
+        if (XHdcp22Tx_IsEnabled(InstancePtr->Hdcp22Ptr)) {
+          XHdcp22Tx_LogDisplay(InstancePtr->Hdcp22Ptr);
+
+          xil_printf("HDCP 2.2 TX Info\r\n");
+          XHdcp22Tx_Info(InstancePtr->Hdcp22Ptr);
+        }
+        else {
+          xil_printf("\r\nHDCP 2.2 TX is disabled\r\n");
+        }
+      }
+      break;
+#endif
+
+    default:
+      xil_printf("\r\nHDCP Info Unknown?\r\n");
+      break;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function sets the logging level.
+*
+* @param  InstancePtr pointer to XV_HdmiTxSs instance
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_HdcpSetInfoDetail(XV_HdmiTxSs *InstancePtr, u8 Verbose)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  if (Verbose) {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    if (InstancePtr->Hdcp14Ptr) {
+      XHdcp1x_SetDebugLogMsg(xil_printf);
+    }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    if (InstancePtr->Hdcp22Ptr) {
+      XHdcp22Tx_LogReset(InstancePtr->Hdcp22Ptr, TRUE);
+    }
+#endif
+  } else {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    if (InstancePtr->Hdcp14Ptr) {
+      XHdcp1x_SetDebugLogMsg(NULL);
+    }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    if (InstancePtr->Hdcp22Ptr) {
+      XHdcp22Tx_LogReset(InstancePtr->Hdcp22Ptr, FALSE);
+    }
+#endif
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology for the active protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return Pointer to repeater topology structure.
+*
+* @note   None.
+*
+******************************************************************************/
+void *XV_HdmiTxSs_HdcpGetTopology(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  void *RepeaterTopologyPtr = NULL;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        RepeaterTopologyPtr = XHdcp1x_GetTopology(InstancePtr->Hdcp14Ptr);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        RepeaterTopologyPtr = XHdcp22Tx_GetTopology(InstancePtr->Hdcp22Ptr);
+      }
+      break;
+#endif
+
+    default:
+      RepeaterTopologyPtr = NULL;
+  }
+
+  return RepeaterTopologyPtr;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology list.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return Pointer to repeater topology list.
+*
+* @note   None.
+*
+******************************************************************************/
+u8 *XV_HdmiTxSs_HdcpGetTopologyReceiverIdList(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 *ListPtr = NULL;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        ListPtr = XHdcp1x_GetTopologyKSVList(InstancePtr->Hdcp14Ptr);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        ListPtr = XHdcp22Tx_GetTopologyReceiverIdList(InstancePtr->Hdcp22Ptr);
+      }
+      break;
+#endif
+
+    default:
+      ListPtr = NULL;
+  }
+
+  return ListPtr;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets various fields inside the HDCP repeater topology.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+* @param Field indicates what field of the topology structure to update.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+u32 XV_HdmiTxSs_HdcpGetTopologyField(XV_HdmiTxSs *InstancePtr,
+                                     XV_HdmiTxSs_HdcpTopologyField Field)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(Field < XV_HDMITXSS_HDCP_TOPOLOGY_INVALID);
+
+  switch (Field)
+  {
+      case XV_HDMITXSS_HDCP_TOPOLOGY_DEPTH:
+      return XV_HdmiTxSs_HdcpGetTopologyDepth(InstancePtr);
+      case XV_HDMITXSS_HDCP_TOPOLOGY_DEVICECNT:
+      return XV_HdmiTxSs_HdcpGetTopologyDeviceCnt(InstancePtr);
+      case XV_HDMITXSS_HDCP_TOPOLOGY_MAXDEVSEXCEEDED:
+      return XV_HdmiTxSs_HdcpGetTopologyMaxDevsExceeded(InstancePtr);
+      case XV_HDMITXSS_HDCP_TOPOLOGY_MAXCASCADEEXCEEDED:
+      return XV_HdmiTxSs_HdcpGetTopologyMaxCascadeExceeded(InstancePtr);
+      case XV_HDMITXSS_HDCP_TOPOLOGY_HDCP20REPEATERDOWNSTREAM:
+      return XV_HdmiTxSs_HdcpGetTopologyHdcp20RepeaterDownstream(InstancePtr);
+      case XV_HDMITXSS_HDCP_TOPOLOGY_HDCP1DEVICEDOWNSTREAM:
+      return XV_HdmiTxSs_HdcpGetTopologyHdcp1DeviceDownstream(InstancePtr);
+    default:
+      return 0;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology depth.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return Depth from the repeater topology table.
+*
+* @note   None.
+*
+******************************************************************************/
+static u32 XV_HdmiTxSs_HdcpGetTopologyDepth(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 Depth = 0;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // HDCP 1.4
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Depth = XHdcp1x_GetTopologyField(InstancePtr->Hdcp14Ptr,
+                  XHDCP1X_TOPOLOGY_DEPTH);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Depth = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                  XHDCP22_TX_TOPOLOGY_DEPTH);
+      }
+      break;
+#endif
+
+    default :
+      Depth = 0;
+  }
+
+  return Depth;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology device count.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return Depth from the repeater topology table.
+*
+* @note   None.
+*
+******************************************************************************/
+static u32 XV_HdmiTxSs_HdcpGetTopologyDeviceCnt(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 DeviceCnt = 0;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        DeviceCnt = XHdcp1x_GetTopologyField(InstancePtr->Hdcp14Ptr,
+                      XHDCP1X_TOPOLOGY_DEVICECNT);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        DeviceCnt = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                      XHDCP22_TX_TOPOLOGY_DEVICECNT);
+      }
+      break;
+#endif
+
+    default:
+      DeviceCnt = 0;
+  }
+
+  return DeviceCnt;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology maximum devices exceeded
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*   - TRUE if maximum devices exceeded.
+*   - FALSE if maximum devices not exceeded.
+*
+* @note   None.
+*
+******************************************************************************/
+static u8 XV_HdmiTxSs_HdcpGetTopologyMaxDevsExceeded(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 Flag = FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Flag = XHdcp1x_GetTopologyField(InstancePtr->Hdcp14Ptr,
+                 XHDCP1X_TOPOLOGY_MAXDEVSEXCEEDED);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Flag = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                 XHDCP22_TX_TOPOLOGY_MAXDEVSEXCEEDED);
+      }
+      break;
+#endif
+
+    default:
+      Flag = FALSE;
+  }
+
+  return Flag;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology maximum cascade exceeded
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*   - TRUE if maximum cascade exceeded.
+*   - FALSE if maximum cascade not exceeded.
+*
+* @note   None.
+*
+******************************************************************************/
+static
+u8 XV_HdmiTxSs_HdcpGetTopologyMaxCascadeExceeded(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 Flag = FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Flag = XHdcp1x_GetTopologyField(InstancePtr->Hdcp14Ptr,
+                 XHDCP1X_TOPOLOGY_MAXCASCADEEXCEEDED);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Flag = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                XHDCP22_TX_TOPOLOGY_MAXCASCADEEXCEEDED);
+      }
+      break;
+#endif
+
+    default:
+      Flag = FALSE;
+  }
+
+  return Flag;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology HDCP 2.0 repeater downstream
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*   - TRUE if HDCP 2.0 repeater is downstream.
+*   - FALSE if HDCP 2.0 repeater is not downstream.
+*
+* @note   None.
+*
+******************************************************************************/
+static
+u8 XV_HdmiTxSs_HdcpGetTopologyHdcp20RepeaterDownstream(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 Flag = FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Flag = FALSE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Flag = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                 XHDCP22_TX_TOPOLOGY_HDCP20REPEATERDOWNSTREAM);
+      }
+      break;
+#endif
+
+    default:
+      Flag = FALSE;
+  }
+
+  return Flag;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function gets the HDCP repeater topology HDCP 1.x device downstream
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*   - TRUE if HDCP 1.x device is downstream.
+*   - FALSE if HDCP 1.x device is not downstream.
+*
+* @note   None.
+*
+******************************************************************************/
+static
+   u8 XV_HdmiTxSs_HdcpGetTopologyHdcp1DeviceDownstream(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  u8 Flag = FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Flag = TRUE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Flag = XHdcp22Tx_GetTopologyField(InstancePtr->Hdcp22Ptr,
+                 XHDCP22_TX_TOPOLOGY_HDCP1DEVICEDOWNSTREAM);
+      }
+      break;
+#endif
+
+    default:
+      Flag = FALSE;
+  }
+
+  return Flag;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater content stream management type.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_HdcpSetContentStreamType(XV_HdmiTxSs *InstancePtr,
+       XV_HdmiTxSs_HdcpContentStreamType StreamType)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+  Xil_AssertVoid(StreamType <= XV_HDMITXSS_HDCP_STREAMTYPE_1);
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      break;
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Tx_SetContentStreamType(InstancePtr->Hdcp22Ptr,
+                                       (XHdcp22_Tx_ContentStreamType) StreamType);
+      }
+      break;
+#endif
+
+    default:
+      break;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function checks if the HDMI transmitter is an HDCP repeater
+* downstream interface for the active protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+*
+* @return
+*   - TRUE if repeater downstream interface.
+*   - FALSE if not repeater downstream interface.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpIsRepeater(XV_HdmiTxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = (int)FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMITXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Status = XHdcp1x_IsRepeater(InstancePtr->Hdcp14Ptr);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMITXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Status = XHdcp22Tx_IsRepeater(InstancePtr->Hdcp22Ptr);
+      }
+      break;
+#endif
+
+    default:
+      Status = (int)FALSE;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_TX
+/*****************************************************************************/
+/**
+*
+* This function enables the Repeater functionality for the HDCP protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiTxSs instance.
+* @param Set is TRUE to enable and FALSE to disable repeater.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiTxSs_HdcpSetRepeater(XV_HdmiTxSs *InstancePtr, u8 Set)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  if (InstancePtr->Hdcp14Ptr) {
+    XHdcp1x_SetRepeater(InstancePtr->Hdcp14Ptr, Set);
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_TX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    XHdcp22Tx_SetRepeater(InstancePtr->Hdcp22Ptr, Set);
+  }
+#endif
+
+  return XST_SUCCESS;
+}
+#endif
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_log.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_log.c
new file mode 100644
index 0000000..63358bb
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xv_hdmitxss_log.c
@@ -0,0 +1,262 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xv_hdmitxss_log.c
+ *
+ *
+ * @note	None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   YH   17/08/16 Initial release.
+ * 1.01  MMO  03/01/17 Add compiler option(XV_HDMITXSS_LOG_ENABLE) to enable Log
+ * </pre>
+ *
+*******************************************************************************/
+
+/******************************* Include Files ********************************/
+
+#include "xv_hdmitxss.h"
+#include "xil_printf.h"
+
+/**************************** Function Prototypes *****************************/
+
+/**************************** Function Definitions ****************************/
+
+/*****************************************************************************/
+/**
+* This function will reset the driver's logging mechanism.
+*
+* @param	InstancePtr is a pointer to the xv_hdmitxss core instance.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+#ifdef XV_HDMITXSS_LOG_ENABLE
+void XV_HdmiTxSs_LogReset(XV_HdmiTxSs *InstancePtr)
+{
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+
+	InstancePtr->Log.HeadIndex = 0;
+	InstancePtr->Log.TailIndex = 0;
+}
+
+/*****************************************************************************/
+/**
+* This function will insert an event in the driver's logginc mechanism.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+* @param	Evt is the event type to log.
+* @param	Data is the associated data for the event.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_LogWrite(XV_HdmiTxSs *InstancePtr, XV_HdmiTxSs_LogEvent Evt, u8 Data)
+{
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(Evt <= (XV_HDMITXSS_LOG_EVT_DUMMY));
+	Xil_AssertVoid(Data < 0xFF);
+
+	/* Write data and event into log buffer */
+	InstancePtr->Log.DataBuffer[InstancePtr->Log.HeadIndex] =
+			(Data << 8) | Evt;
+
+	/* Update head pointer if reached to end of the buffer */
+	if (InstancePtr->Log.HeadIndex ==
+			(u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+		/* Clear pointer */
+		InstancePtr->Log.HeadIndex = 0;
+	}
+	else {
+		/* Increment pointer */
+		InstancePtr->Log.HeadIndex++;
+	}
+
+	/* Check tail pointer. When the two pointer are equal, then the buffer
+	 * is full. In this case then increment the tail pointer as well to
+	 * remove the oldest entry from the buffer. */
+	if (InstancePtr->Log.TailIndex == InstancePtr->Log.HeadIndex) {
+		if (InstancePtr->Log.TailIndex ==
+			(u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+			InstancePtr->Log.TailIndex = 0;
+		}
+		else {
+			InstancePtr->Log.TailIndex++;
+		}
+	}
+}
+
+/*****************************************************************************/
+/**
+* This function will read the last event from the log.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+*
+* @return	The log data.
+*
+* @note		None.
+*
+******************************************************************************/
+u16 XV_HdmiTxSs_LogRead(XV_HdmiTxSs *InstancePtr)
+{
+	u16 Log;
+
+	/* Verify argument. */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+
+	/* Check if there is any data in the log */
+	if (InstancePtr->Log.TailIndex == InstancePtr->Log.HeadIndex) {
+		Log = 0;
+	}
+	else {
+		Log = InstancePtr->Log.DataBuffer[InstancePtr->Log.TailIndex];
+
+		/* Increment tail pointer */
+		if (InstancePtr->Log.TailIndex ==
+			(u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+			InstancePtr->Log.TailIndex = 0;
+		}
+		else {
+			InstancePtr->Log.TailIndex++;
+		}
+	}
+
+	return Log;
+}
+#endif
+/*****************************************************************************/
+/**
+* This function will print the entire log.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiTxSs core instance.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XV_HdmiTxSs_LogDisplay(XV_HdmiTxSs *InstancePtr)
+{
+#ifdef XV_HDMITXSS_LOG_ENABLE
+	u16 Log;
+	u8 Evt;
+	u8 Data;
+
+	/* Verify argument. */
+	Xil_AssertVoid(InstancePtr != NULL);
+
+	xil_printf("\r\n\n\nHDMI TX log\r\n");
+	xil_printf("------\r\n");
+
+	/* Read log data */
+	Log = XV_HdmiTxSs_LogRead(InstancePtr);
+
+	while (Log != 0) {
+		/* Event */
+		Evt = Log & 0xff;
+
+		/* Data */
+		Data = (Log >> 8) & 0xFF;
+		Data = Data;
+
+		switch (Evt) {
+		case (XV_HDMITXSS_LOG_EVT_NONE):
+			xil_printf("HDMI TXSS log end\r\n-------\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDMITX_INIT):
+		    xil_printf("Initializing HDMI TX core....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_VTC_INIT):
+		    xil_printf("Initializing VTC core....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDCPTIMER_INIT):
+		    xil_printf("Initializing AXI Timer core....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDCP14_INIT):
+		    xil_printf("Initializing HDCP 1.4 core....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDCP22_INIT):
+		    xil_printf("Initializing HDCP 2.2 core....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_START):
+		    xil_printf("Start HDMI TX Subsystem....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_STOP):
+		    xil_printf("Stop HDMI TX Subsystem....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_RESET):
+		    xil_printf("Reset HDMI TX Subsystem....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_CONNECT):
+		    xil_printf("TX cable is connected....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_DISCONNECT):
+		    xil_printf("TX cable is disconnected....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_TOGGLE):
+		    xil_printf("TX cable is toggled....\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_STREAMUP):
+		    xil_printf("TX Stream is Up\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_STREAMDOWN):
+		    xil_printf("TX Stream is Down\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_STREAMSTART):
+		    xil_printf("TX Stream Start\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_SETAUDIOCHANNELS):
+		    xil_printf("TX Set Audio Channels (%0d)\r\n", Data);
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_AUDIOMUTE):
+		    xil_printf("TX Audio Muted\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_AUDIOUNMUTE):
+		    xil_printf("TX Audio Unmuted\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_SETSTREAM):
+		    xil_printf("TX Set Stream, with TMDS (%0d)\r\n", Data);
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDCP14_AUTHREQ):
+		    xil_printf("TX HDCP 1.4 authentication request\r\n");
+			break;
+	    case (XV_HDMITXSS_LOG_EVT_HDCP22_AUTHREQ):
+		    xil_printf("TX HDCP 2.2 authentication request\r\n");
+			break;
+		default:
+			xil_printf("Unknown event\r\n");
+			break;
+		}
+
+		/* Read log data */
+		Log = XV_HdmiTxSs_LogRead(InstancePtr);
+	}
+#else
+    xil_printf("\r\n INFO:: HDMITXSS Log Feature is Disabled \r\n");
+#endif
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc.h
new file mode 100644
index 0000000..e566881
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc.h
@@ -0,0 +1,542 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xvidc.h
+ * @addtogroup video_common_v4_0
+ * @{
+ * @details
+ *
+ * Contains common structures, definitions, macros, and utility functions that
+ * are typically used by video-related drivers and applications.
+ *
+ * @note	None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   rc,  01/10/15 Initial release.
+ *       als
+ * 2.0   als  08/14/15 Added new video timings.
+ * 2.2   als  02/01/16 Functions with pointer arguments that don't modify
+ *                     contents now const.
+ *                     Added ability to insert a custom video timing table:
+ *                         XVidC_RegisterCustomTimingModes
+ *                         XVidC_UnregisterCustomTimingMode
+ *       yh            Added 3D support.
+ * 3.0   aad  05/13/16 Added API to search for RB video modes.
+ *       als  05/16/16 Added Y-only to color format enum.
+ * 3.1   rco  07/26/17 Moved timing table extern definition to xvidc.c
+ *                     Added video-in-memory color formats
+ *                     Updated XVidC_RegisterCustomTimingModes API signature
+ * 4.1   rco  11/23/17 Added new memory formats
+ *                     Added xil_printf include statement
+ *                     Added new API XVidC_GetVideoModeIdWBlanking
+ *                     Fix C++ warnings
+ * </pre>
+ *
+*******************************************************************************/
+
+#ifndef XVIDC_H_  /* Prevent circular inclusions by using protection macros. */
+#define XVIDC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************* Include Files ********************************/
+
+#include "xil_types.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions ******************************/
+
+/**
+ * This typedef enumerates the list of available standard display monitor
+ * timings as specified in the xvidc_timings_table.c file. The naming format is:
+ *
+ * XVIDC_VM_<RESOLUTION>_<REFRESH RATE (HZ)>_<P|I>(_RB)
+ *
+ * Where RB stands for reduced blanking.
+ */
+typedef enum {
+	/* Interlaced modes. */
+	XVIDC_VM_720x480_60_I = 0,
+	XVIDC_VM_720x576_50_I,
+	XVIDC_VM_1440x480_60_I,
+	XVIDC_VM_1440x576_50_I,
+	XVIDC_VM_1920x1080_50_I,
+	XVIDC_VM_1920x1080_60_I,
+
+	/* Progressive modes. */
+	XVIDC_VM_640x350_85_P,
+	XVIDC_VM_640x480_60_P,
+	XVIDC_VM_640x480_72_P,
+	XVIDC_VM_640x480_75_P,
+	XVIDC_VM_640x480_85_P,
+	XVIDC_VM_720x400_85_P,
+	XVIDC_VM_720x480_60_P,
+	XVIDC_VM_720x576_50_P,
+	XVIDC_VM_800x600_56_P,
+	XVIDC_VM_800x600_60_P,
+	XVIDC_VM_800x600_72_P,
+	XVIDC_VM_800x600_75_P,
+	XVIDC_VM_800x600_85_P,
+	XVIDC_VM_800x600_120_P_RB,
+	XVIDC_VM_848x480_60_P,
+	XVIDC_VM_1024x768_60_P,
+	XVIDC_VM_1024x768_70_P,
+	XVIDC_VM_1024x768_75_P,
+	XVIDC_VM_1024x768_85_P,
+	XVIDC_VM_1024x768_120_P_RB,
+	XVIDC_VM_1152x864_75_P,
+	XVIDC_VM_1280x720_50_P,
+	XVIDC_VM_1280x720_60_P,
+	XVIDC_VM_1280x768_60_P,
+	XVIDC_VM_1280x768_60_P_RB,
+	XVIDC_VM_1280x768_75_P,
+	XVIDC_VM_1280x768_85_P,
+	XVIDC_VM_1280x768_120_P_RB,
+	XVIDC_VM_1280x800_60_P,
+	XVIDC_VM_1280x800_60_P_RB,
+	XVIDC_VM_1280x800_75_P,
+	XVIDC_VM_1280x800_85_P,
+	XVIDC_VM_1280x800_120_P_RB,
+	XVIDC_VM_1280x960_60_P,
+	XVIDC_VM_1280x960_85_P,
+	XVIDC_VM_1280x960_120_P_RB,
+	XVIDC_VM_1280x1024_60_P,
+	XVIDC_VM_1280x1024_75_P,
+	XVIDC_VM_1280x1024_85_P,
+	XVIDC_VM_1280x1024_120_P_RB,
+	XVIDC_VM_1360x768_60_P,
+	XVIDC_VM_1360x768_120_P_RB,
+	XVIDC_VM_1366x768_60_P,
+	XVIDC_VM_1400x1050_60_P,
+	XVIDC_VM_1400x1050_60_P_RB,
+	XVIDC_VM_1400x1050_75_P,
+	XVIDC_VM_1400x1050_85_P,
+	XVIDC_VM_1400x1050_120_P_RB,
+	XVIDC_VM_1440x240_60_P,
+	XVIDC_VM_1440x900_60_P,
+	XVIDC_VM_1440x900_60_P_RB,
+	XVIDC_VM_1440x900_75_P,
+	XVIDC_VM_1440x900_85_P,
+	XVIDC_VM_1440x900_120_P_RB,
+	XVIDC_VM_1600x1200_60_P,
+	XVIDC_VM_1600x1200_65_P,
+	XVIDC_VM_1600x1200_70_P,
+	XVIDC_VM_1600x1200_75_P,
+	XVIDC_VM_1600x1200_85_P,
+	XVIDC_VM_1600x1200_120_P_RB,
+	XVIDC_VM_1680x720_50_P,
+	XVIDC_VM_1680x720_60_P,
+	XVIDC_VM_1680x720_100_P,
+	XVIDC_VM_1680x720_120_P,
+	XVIDC_VM_1680x1050_50_P,
+	XVIDC_VM_1680x1050_60_P,
+	XVIDC_VM_1680x1050_60_P_RB,
+	XVIDC_VM_1680x1050_75_P,
+	XVIDC_VM_1680x1050_85_P,
+	XVIDC_VM_1680x1050_120_P_RB,
+	XVIDC_VM_1792x1344_60_P,
+	XVIDC_VM_1792x1344_75_P,
+	XVIDC_VM_1792x1344_120_P_RB,
+	XVIDC_VM_1856x1392_60_P,
+	XVIDC_VM_1856x1392_75_P,
+	XVIDC_VM_1856x1392_120_P_RB,
+	XVIDC_VM_1920x1080_24_P,
+	XVIDC_VM_1920x1080_25_P,
+	XVIDC_VM_1920x1080_30_P,
+	XVIDC_VM_1920x1080_50_P,
+	XVIDC_VM_1920x1080_60_P,
+	XVIDC_VM_1920x1080_100_P,
+	XVIDC_VM_1920x1080_120_P,
+	XVIDC_VM_1920x1200_60_P,
+	XVIDC_VM_1920x1200_60_P_RB,
+	XVIDC_VM_1920x1200_75_P,
+	XVIDC_VM_1920x1200_85_P,
+	XVIDC_VM_1920x1200_120_P_RB,
+	XVIDC_VM_1920x1440_60_P,
+	XVIDC_VM_1920x1440_75_P,
+	XVIDC_VM_1920x1440_120_P_RB,
+	XVIDC_VM_1920x2160_60_P,
+	XVIDC_VM_2560x1080_50_P,
+	XVIDC_VM_2560x1080_60_P,
+	XVIDC_VM_2560x1080_100_P,
+	XVIDC_VM_2560x1080_120_P,
+	XVIDC_VM_2560x1600_60_P,
+	XVIDC_VM_2560x1600_60_P_RB,
+	XVIDC_VM_2560x1600_75_P,
+	XVIDC_VM_2560x1600_85_P,
+	XVIDC_VM_2560x1600_120_P_RB,
+	XVIDC_VM_3840x2160_24_P,
+	XVIDC_VM_3840x2160_25_P,
+	XVIDC_VM_3840x2160_30_P,
+	XVIDC_VM_3840x2160_50_P,
+	XVIDC_VM_3840x2160_60_P,
+	XVIDC_VM_4096x2160_24_P,
+	XVIDC_VM_4096x2160_25_P,
+	XVIDC_VM_4096x2160_30_P,
+	XVIDC_VM_4096x2160_50_P,
+	XVIDC_VM_4096x2160_60_P,
+	XVIDC_VM_4096x2160_60_P_RB,
+
+	XVIDC_VM_NUM_SUPPORTED,
+	XVIDC_VM_USE_EDID_PREFERRED,
+	XVIDC_VM_NO_INPUT,
+	XVIDC_VM_NOT_SUPPORTED,
+	XVIDC_VM_CUSTOM,
+
+	/* Marks beginning/end of interlaced/progressive modes in the table. */
+	XVIDC_VM_INTL_START = XVIDC_VM_720x480_60_I,
+	XVIDC_VM_PROG_START = XVIDC_VM_640x350_85_P,
+	XVIDC_VM_INTL_END = (XVIDC_VM_PROG_START - 1),
+	XVIDC_VM_PROG_END = (XVIDC_VM_NUM_SUPPORTED - 1),
+
+	/* Common naming. */
+	XVIDC_VM_480_60_I = XVIDC_VM_720x480_60_I,
+	XVIDC_VM_576_50_I = XVIDC_VM_720x576_50_I,
+	XVIDC_VM_1080_50_I = XVIDC_VM_1920x1080_50_I,
+	XVIDC_VM_1080_60_I = XVIDC_VM_1920x1080_60_I,
+	XVIDC_VM_VGA_60_P = XVIDC_VM_640x480_60_P,
+	XVIDC_VM_480_60_P = XVIDC_VM_720x480_60_P,
+	XVIDC_VM_SVGA_60_P = XVIDC_VM_800x600_60_P,
+	XVIDC_VM_XGA_60_P = XVIDC_VM_1024x768_60_P,
+	XVIDC_VM_720_50_P = XVIDC_VM_1280x720_50_P,
+	XVIDC_VM_720_60_P = XVIDC_VM_1280x720_60_P,
+	XVIDC_VM_WXGA_60_P = XVIDC_VM_1366x768_60_P,
+	XVIDC_VM_UXGA_60_P = XVIDC_VM_1600x1200_60_P,
+	XVIDC_VM_WSXGA_60_P = XVIDC_VM_1680x1050_60_P,
+	XVIDC_VM_1080_24_P = XVIDC_VM_1920x1080_24_P,
+	XVIDC_VM_1080_25_P = XVIDC_VM_1920x1080_25_P,
+	XVIDC_VM_1080_30_P = XVIDC_VM_1920x1080_30_P,
+	XVIDC_VM_1080_50_P = XVIDC_VM_1920x1080_50_P,
+	XVIDC_VM_1080_60_P = XVIDC_VM_1920x1080_60_P,
+	XVIDC_VM_WUXGA_60_P = XVIDC_VM_1920x1200_60_P,
+	XVIDC_VM_UHD2_60_P = XVIDC_VM_1920x2160_60_P,
+	XVIDC_VM_UHD_24_P = XVIDC_VM_3840x2160_24_P,
+	XVIDC_VM_UHD_25_P = XVIDC_VM_3840x2160_25_P,
+	XVIDC_VM_UHD_30_P = XVIDC_VM_3840x2160_30_P,
+	XVIDC_VM_UHD_60_P = XVIDC_VM_3840x2160_60_P,
+	XVIDC_VM_4K2K_60_P = XVIDC_VM_4096x2160_60_P,
+	XVIDC_VM_4K2K_60_P_RB = XVIDC_VM_4096x2160_60_P_RB,
+} XVidC_VideoMode;
+
+/**
+ * Progressive/interlaced video format.
+ */
+typedef enum {
+	XVIDC_VF_PROGRESSIVE = 0,
+	XVIDC_VF_INTERLACED,
+	XVIDC_VF_UNKNOWN
+} XVidC_VideoFormat;
+
+/**
+ * Frame rate.
+ */
+typedef enum {
+	XVIDC_FR_24HZ = 24,
+	XVIDC_FR_25HZ = 25,
+	XVIDC_FR_30HZ = 30,
+	XVIDC_FR_50HZ = 50,
+	XVIDC_FR_56HZ = 56,
+	XVIDC_FR_60HZ = 60,
+	XVIDC_FR_65HZ = 65,
+	XVIDC_FR_67HZ = 67,
+	XVIDC_FR_70HZ = 70,
+	XVIDC_FR_72HZ = 72,
+	XVIDC_FR_75HZ = 75,
+	XVIDC_FR_85HZ = 85,
+	XVIDC_FR_87HZ = 87,
+	XVIDC_FR_88HZ = 88,
+	XVIDC_FR_100HZ = 100,
+	XVIDC_FR_120HZ = 120,
+	XVIDC_FR_NUM_SUPPORTED = 16,
+	XVIDC_FR_UNKNOWN
+} XVidC_FrameRate;
+
+/**
+ * Color depth - bits per color component.
+ */
+typedef enum {
+	XVIDC_BPC_6 = 6,
+	XVIDC_BPC_8 = 8,
+	XVIDC_BPC_10 = 10,
+	XVIDC_BPC_12 = 12,
+	XVIDC_BPC_14 = 14,
+	XVIDC_BPC_16 = 16,
+	XVIDC_BPC_NUM_SUPPORTED = 6,
+	XVIDC_BPC_UNKNOWN
+} XVidC_ColorDepth;
+
+/**
+ * Pixels per clock.
+ */
+typedef enum {
+	XVIDC_PPC_1 = 1,
+	XVIDC_PPC_2 = 2,
+	XVIDC_PPC_4 = 4,
+	XVIDC_PPC_8 = 8,
+	XVIDC_PPC_NUM_SUPPORTED = 4,
+} XVidC_PixelsPerClock;
+
+/**
+ * Color space format.
+ */
+typedef enum {
+	/* Streaming video formats */
+	XVIDC_CSF_RGB = 0,
+	XVIDC_CSF_YCRCB_444,
+	XVIDC_CSF_YCRCB_422,
+	XVIDC_CSF_YCRCB_420,
+	XVIDC_CSF_YONLY,
+
+	/* 6 empty slots reserved for video formats for future
+	 * extension
+	 */
+
+	/* Video in memory formats */
+	XVIDC_CSF_MEM_RGBX8 = 10,   // [31:0] x:B:G:R 8:8:8:8
+	XVIDC_CSF_MEM_YUVX8,        // [31:0] x:V:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_YUYV8,        // [31:0] V:Y:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_RGBA8,        // [31:0] A:B:G:R 8:8:8:8
+    XVIDC_CSF_MEM_YUVA8,        // [31:0] A:V:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_RGBX10,       // [31:0] x:B:G:R 2:10:10:10
+    XVIDC_CSF_MEM_YUVX10,       // [31:0] x:V:U:Y 2:10:10:10
+    XVIDC_CSF_MEM_RGB565,       // [15:0] B:G:R 5:6:5
+    XVIDC_CSF_MEM_Y_UV8,        // [15:0] Y:Y 8:8, [15:0] V:U 8:8
+    XVIDC_CSF_MEM_Y_UV8_420,    // [15:0] Y:Y 8:8, [15:0] V:U 8:8
+    XVIDC_CSF_MEM_RGB8,         // [23:0] B:G:R 8:8:8
+    XVIDC_CSF_MEM_YUV8,         // [24:0] V:U:Y 8:8:8
+	XVIDC_CSF_MEM_Y_UV10,       // [31:0] x:Y:Y:Y 2:10:10:10 [31:0] x:U:V:U 2:10:10:10
+	XVIDC_CSF_MEM_Y_UV10_420,   // [31:0] x:Y:Y:Y 2:10:10:10 [31:0] x:U:V:U 2:10:10:10
+	XVIDC_CSF_MEM_Y8,           // [31:0] Y:Y:Y:Y 8:8:8:8
+	XVIDC_CSF_MEM_Y10,          // [31:0] x:Y:Y:Y 2:10:10:10
+	XVIDC_CSF_MEM_BGRA8,        // [31:0] A:R:G:B 8:8:8:8
+
+	XVIDC_CSF_NUM_SUPPORTED,    // includes the reserved slots
+	XVIDC_CSF_UNKNOWN,
+	XVIDC_CSF_STRM_START = XVIDC_CSF_RGB,
+	XVIDC_CSF_STRM_END   = XVIDC_CSF_YONLY,
+	XVIDC_CSF_MEM_START  = XVIDC_CSF_MEM_RGBX8,
+	XVIDC_CSF_MEM_END    = (XVIDC_CSF_NUM_SUPPORTED - 1),
+	XVIDC_CSF_NUM_STRM   = (XVIDC_CSF_STRM_END - XVIDC_CSF_STRM_START + 1),
+	XVIDC_CSF_NUM_MEM    = (XVIDC_CSF_MEM_END - XVIDC_CSF_MEM_START + 1)
+} XVidC_ColorFormat;
+
+/**
+ * Color space conversion standard.
+ */
+typedef enum {
+	XVIDC_BT_2020 = 0,
+	XVIDC_BT_709,
+	XVIDC_BT_601,
+	XVIDC_BT_NUM_SUPPORTED,
+	XVIDC_BT_UNKNOWN
+} XVidC_ColorStd;
+
+/**
+ * Color conversion output range.
+ */
+typedef enum {
+	XVIDC_CR_16_235 = 0,
+	XVIDC_CR_16_240,
+	XVIDC_CR_0_255,
+	XVIDC_CR_NUM_SUPPORTED,
+	XVIDC_CR_UNKNOWN_RANGE
+} XVidC_ColorRange;
+
+/**
+ * 3D formats.
+ */
+typedef enum {
+	XVIDC_3D_FRAME_PACKING = 0,	/**< Frame packing.         */
+	XVIDC_3D_FIELD_ALTERNATIVE,	/**< Field alternative.     */
+	XVIDC_3D_LINE_ALTERNATIVE,	/**< Line alternative.      */
+	XVIDC_3D_SIDE_BY_SIDE_FULL,	/**< Side-by-side (full).   */
+	XVIDC_3D_TOP_AND_BOTTOM_HALF,	/**< Top-and-bottom (half). */
+	XVIDC_3D_SIDE_BY_SIDE_HALF,	/**< Side-by-side (half).   */
+	XVIDC_3D_UNKNOWN
+} XVidC_3DFormat;
+
+/**
+ * 3D Sub-sampling methods.
+ */
+typedef enum {
+	XVIDC_3D_SAMPLING_HORIZONTAL = 0, /**< Horizontal sub-sampling. */
+	XVIDC_3D_SAMPLING_QUINCUNX,	  /**< Quincunx matrix.         */
+	XVIDC_3D_SAMPLING_UNKNOWN
+} XVidC_3DSamplingMethod;
+
+/**
+ * 3D Sub-sampling positions.
+ */
+typedef enum {
+	XVIDC_3D_SAMPPOS_OLOR = 0,	/**< Odd/Left,  Odd/Right.  */
+	XVIDC_3D_SAMPPOS_OLER,		/**< Odd/Left,  Even/Right. */
+	XVIDC_3D_SAMPPOS_ELOR,		/**< Even/Left, Odd/Right.  */
+	XVIDC_3D_SAMPPOS_ELER,		/**< Even/Left, Even/Right. */
+	XVIDC_3D_SAMPPOS_UNKNOWN
+} XVidC_3DSamplingPosition;
+
+/****************************** Type Definitions ******************************/
+
+/**
+ * Video timing structure.
+ */
+typedef struct {
+	u16 HActive;
+	u16 HFrontPorch;
+	u16 HSyncWidth;
+	u16 HBackPorch;
+	u16 HTotal;
+	u8 HSyncPolarity;
+	u16 VActive;
+	u16 F0PVFrontPorch;
+	u16 F0PVSyncWidth;
+	u16 F0PVBackPorch;
+	u16 F0PVTotal;
+	u16 F1VFrontPorch;
+	u16 F1VSyncWidth;
+	u16 F1VBackPorch;
+	u16 F1VTotal;
+	u8 VSyncPolarity;
+} XVidC_VideoTiming;
+
+/**
+ * 3D Sampling info structure.
+ */
+typedef struct {
+	XVidC_3DSamplingMethod   Method;
+	XVidC_3DSamplingPosition Position;
+} XVidC_3DSamplingInfo;
+
+/**
+ * 3D info structure.
+ */
+typedef struct {
+	XVidC_3DFormat		Format;
+	XVidC_3DSamplingInfo	Sampling;
+} XVidC_3DInfo;
+
+/**
+ * Video stream structure.
+ */
+typedef struct {
+	XVidC_ColorFormat	ColorFormatId;
+	XVidC_ColorDepth	ColorDepth;
+	XVidC_PixelsPerClock	PixPerClk;
+	XVidC_FrameRate		FrameRate;
+	u8			IsInterlaced;
+	u8			Is3D;
+	XVidC_3DInfo		Info_3D;
+	XVidC_VideoMode		VmId;
+	XVidC_VideoTiming	Timing;
+} XVidC_VideoStream;
+
+/**
+ * Video window structure.
+ */
+typedef struct {
+	u32 StartX;
+	u32 StartY;
+	u32 Width;
+	u32 Height;
+} XVidC_VideoWindow;
+
+/**
+ * Video timing mode from the video timing table.
+ */
+typedef struct {
+	XVidC_VideoMode		VmId;
+	const char		    Name[21];
+	XVidC_FrameRate		FrameRate;
+	XVidC_VideoTiming	Timing;
+} XVidC_VideoTimingMode;
+
+/**
+ * Callback type which represents a custom timer wait handler. This is only
+ * used for Microblaze since it doesn't have a native sleep function. To avoid
+ * dependency on a hardware timer, the default wait functionality is implemented
+ * using loop iterations; this isn't too accurate. Therefore a custom timer
+ * handler is used, the user may implement their own wait implementation.
+ *
+ * @param	TimerPtr is a pointer to the timer instance.
+ * @param	Delay is the duration (msec/usec) to be passed to the timer
+ *		function.
+ *
+*******************************************************************************/
+typedef void (*XVidC_DelayHandler)(void *TimerPtr, u32 Delay);
+
+/**************************** Function Prototypes *****************************/
+
+u32 XVidC_RegisterCustomTimingModes(const XVidC_VideoTimingMode *CustomTable,
+		                            u16 NumElems);
+void XVidC_UnregisterCustomTimingModes(void);
+u32 XVidC_GetPixelClockHzByHVFr(u32 HTotal, u32 VTotal, u8 FrameRate);
+u32 XVidC_GetPixelClockHzByVmId(XVidC_VideoMode VmId);
+XVidC_VideoFormat XVidC_GetVideoFormat(XVidC_VideoMode VmId);
+u8 XVidC_IsInterlaced(XVidC_VideoMode VmId);
+const XVidC_VideoTimingMode* XVidC_GetVideoModeData(XVidC_VideoMode VmId);
+const char *XVidC_GetVideoModeStr(XVidC_VideoMode VmId);
+const char *XVidC_GetFrameRateStr(XVidC_VideoMode VmId);
+const char *XVidC_GetColorFormatStr(XVidC_ColorFormat ColorFormatId);
+XVidC_FrameRate XVidC_GetFrameRate(XVidC_VideoMode VmId);
+const XVidC_VideoTiming* XVidC_GetTimingInfo(XVidC_VideoMode VmId);
+void XVidC_ReportStreamInfo(const XVidC_VideoStream *Stream);
+void XVidC_ReportTiming(const XVidC_VideoTiming *Timing, u8 IsInterlaced);
+const char *XVidC_Get3DFormatStr(XVidC_3DFormat Format);
+u32 XVidC_SetVideoStream(XVidC_VideoStream *VidStrmPtr, XVidC_VideoMode VmId,
+			             XVidC_ColorFormat ColorFormat, XVidC_ColorDepth Bpc,
+			             XVidC_PixelsPerClock Ppc);
+u32 XVidC_Set3DVideoStream(XVidC_VideoStream *VidStrmPtr, XVidC_VideoMode VmId,
+			               XVidC_ColorFormat ColorFormat, XVidC_ColorDepth Bpc,
+			               XVidC_PixelsPerClock Ppc, XVidC_3DInfo *Info3DPtr);
+XVidC_VideoMode XVidC_GetVideoModeId(u32 Width, u32 Height, u32 FrameRate,
+		                             u8 IsInterlaced);
+XVidC_VideoMode XVidC_GetVideoModeIdRb(u32 Width, u32 Height, u32 FrameRate,
+		                               u8 IsInterlaced, u8 RbN);
+XVidC_VideoMode XVidC_GetVideoModeIdWBlanking(const XVidC_VideoTiming *Timing,
+		                                      u32 FrameRate, u8 IsInterlaced);
+
+/******************* Macros (Inline Functions) Definitions ********************/
+
+/*****************************************************************************/
+/**
+ * This macro check if video stream is 3D or 2D.
+ *
+ * @param	VidStreamPtr is a pointer to the XVidC_VideoStream structure.
+ *
+ * @return	3D(1)/2D(0)
+ *
+ * @note	C-style signature:
+ *		u8 XDp_IsStream3D(XVidC_VideoStream *VidStreamPtr)
+ *
+ *****************************************************************************/
+#define XVidC_IsStream3D(VidStreamPtr)       ((VidStreamPtr)->Is3D)
+
+/*************************** Variable Declarations ****************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* XVIDC_H_ */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc_edid.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc_edid.h
new file mode 100644
index 0000000..e18f366
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvidc_edid.h
@@ -0,0 +1,468 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xvidc_edid.h
+ * @addtogroup video_common_v4_0
+ * @{
+ *
+ * Contains macros, definitions, and function declarations related to the
+ * Extended Display Identification Data (EDID) structure which is present in all
+ * monitors. All content in this file is agnostic of communication interface
+ * protocol.
+ *
+ * @note	None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   als  11/09/14 Initial release.
+ * 2.2   als  02/01/16 Functions with pointer arguments that don't modify
+ *                     contents now const.
+ * 4.0   aad  10/26/16 Functions which return fixed point values instead of
+ *		       float
+ * </pre>
+ *
+*******************************************************************************/
+
+#ifndef XVIDC_EDID_H_
+/* Prevent circular inclusions by using protection macros. */
+#define XVIDC_EDID_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************* Include Files ********************************/
+
+#include "xstatus.h"
+#include "xvidc.h"
+
+/************************** Constant Definitions ******************************/
+
+/** @name Address mapping for the base EDID block.
+ * @{
+ */
+#define XVIDC_EDID_HEADER				0x00
+/* Vendor and product identification. */
+#define XVIDC_EDID_VPI_ID_MAN_NAME0			0x08
+#define XVIDC_EDID_VPI_ID_MAN_NAME1			0x09
+#define XVIDC_EDID_VPI_ID_PROD_CODE_LSB			0x0A
+#define XVIDC_EDID_VPI_ID_PROD_CODE_MSB			0x0B
+#define XVIDC_EDID_VPI_ID_SN0				0x0C
+#define XVIDC_EDID_VPI_ID_SN1				0x0D
+#define XVIDC_EDID_VPI_ID_SN2				0x0E
+#define XVIDC_EDID_VPI_ID_SN3				0x0F
+#define XVIDC_EDID_VPI_WEEK_MAN				0x10
+#define XVIDC_EDID_VPI_YEAR				0x11
+/* EDID structure version and revision. */
+#define XVIDC_EDID_STRUCT_VER				0x12
+#define XVIDC_EDID_STRUCT_REV				0x13
+/* Basic display parameters and features. */
+#define XVIDC_EDID_BDISP_VID				0x14
+#define XVIDC_EDID_BDISP_H_SSAR				0x15
+#define XVIDC_EDID_BDISP_V_SSAR				0x16
+#define XVIDC_EDID_BDISP_GAMMA				0x17
+#define XVIDC_EDID_BDISP_FEATURE			0x18
+/* Color characteristics (display x,y chromaticity coordinates). */
+#define XVIDC_EDID_CC_RG_LOW				0x19
+#define XVIDC_EDID_CC_BW_LOW				0x1A
+#define XVIDC_EDID_CC_REDX_HIGH				0x1B
+#define XVIDC_EDID_CC_REDY_HIGH				0x1C
+#define XVIDC_EDID_CC_GREENX_HIGH			0x1D
+#define XVIDC_EDID_CC_GREENY_HIGH			0x1E
+#define XVIDC_EDID_CC_BLUEX_HIGH			0x1F
+#define XVIDC_EDID_CC_BLUEY_HIGH			0x20
+#define XVIDC_EDID_CC_WHITEX_HIGH			0x21
+#define XVIDC_EDID_CC_WHITEY_HIGH			0x22
+/* Established timings. */
+#define XVIDC_EDID_EST_TIMINGS_I			0x23
+#define XVIDC_EDID_EST_TIMINGS_II			0x24
+#define XVIDC_EDID_EST_TIMINGS_MAN			0x25
+/* Standard timings. */
+#define XVIDC_EDID_STD_TIMINGS_H(N)			(0x26 + 2 * (N - 1))
+#define XVIDC_EDID_STD_TIMINGS_AR_FRR(N)		(0x27 + 2 * (N - 1))
+/* 18 byte descriptors. */
+#define XVIDC_EDID_18BYTE_DESCRIPTOR(N)			(0x36 + 18 * (N - 1))
+#define XVIDC_EDID_PTM			(XVIDC_EDID_18BYTE_DESCRIPTOR(1))
+/* - Detailed timing descriptor (DTD) / Preferred timing mode (PTM). */
+#define XVIDC_EDID_DTD_PTM_PIXEL_CLK_KHZ_LSB		0x00
+#define XVIDC_EDID_DTD_PTM_PIXEL_CLK_KHZ_MSB		0x01
+#define XVIDC_EDID_DTD_PTM_HRES_LSB			0x02
+#define XVIDC_EDID_DTD_PTM_HBLANK_LSB			0x03
+#define XVIDC_EDID_DTD_PTM_HRES_HBLANK_U4		0x04
+#define XVIDC_EDID_DTD_PTM_VRES_LSB			0x05
+#define XVIDC_EDID_DTD_PTM_VBLANK_LSB			0x06
+#define XVIDC_EDID_DTD_PTM_VRES_VBLANK_U4		0x07
+#define XVIDC_EDID_DTD_PTM_HFPORCH_LSB			0x08
+#define XVIDC_EDID_DTD_PTM_HSPW_LSB			0x09
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4		0x0A
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2		0x0B
+#define XVIDC_EDID_DTD_PTM_HIMGSIZE_MM_LSB		0x0C
+#define XVIDC_EDID_DTD_PTM_VIMGSIZE_MM_LSB		0x0D
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4		0x0E
+#define XVIDC_EDID_DTD_PTM_HBORDER			0x0F
+#define XVIDC_EDID_DTD_PTM_VBORDER			0x10
+#define XVIDC_EDID_DTD_PTM_SIGNAL			0x11
+
+/* Extension block count. */
+#define XVIDC_EDID_EXT_BLK_COUNT			0x7E
+/* Checksum. */
+#define XVIDC_EDID_CHECKSUM				0x7F
+/* @} */
+
+/******************************************************************************/
+
+/** @name Extended Display Identification Data: Masks, shifts, and values.
+ * @{
+ */
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR0_SHIFT		2
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR0_MASK		(0x1F << 2)
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR1_MASK		0x03
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR1_POS		3
+#define XVIDC_EDID_VPI_ID_MAN_NAME1_CHAR1_SHIFT		5
+#define XVIDC_EDID_VPI_ID_MAN_NAME1_CHAR2_MASK		0x1F
+
+/* Basic display parameters and features: Video input definition. */
+#define XVIDC_EDID_BDISP_VID_VSI_SHIFT			7
+#define XVIDC_EDID_BDISP_VID_VSI_MASK			(0x01 << 7)
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_SHIFT		5
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_MASK		(0x03 << 5)
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0700_0300_1000	0x0
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0714_0286_1000	0x1
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_1000_0400_1400	0x2
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0700_0000_0700	0x3
+#define XVIDC_EDID_BDISP_VID_ANA_VID_SETUP_MASK		(0x01 << 4)
+#define XVIDC_EDID_BDISP_VID_ANA_SEP_SYNC_HV_MASK	(0x01 << 3)
+#define XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_H_MASK	(0x01 << 2)
+#define XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_G_MASK	(0x01 << 1)
+#define XVIDC_EDID_BDISP_VID_ANA_SERR_V_SYNC_MASK	(0x01)
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_SHIFT		4
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_MASK		(0x7 << 4)
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_UNDEF		0x0
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_6			0x1
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_8			0x2
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_10			0x3
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_12			0x4
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_14			0x5
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_16			0x6
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_MASK		0xF
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_UNDEF		0x0
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_DVI		0x1
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_HDMIA		0x2
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_HDMIB		0x3
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_MDDI		0x4
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_DP			0x5
+
+/* Basic display parameters and features: Feature support. */
+#define XVIDC_EDID_BDISP_FEATURE_PM_STANDBY_MASK	(0x1 << 7)
+#define XVIDC_EDID_BDISP_FEATURE_PM_SUSPEND_MASK	(0x1 << 6)
+#define XVIDC_EDID_BDISP_FEATURE_PM_OFF_VLP_MASK	(0x1 << 5)
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_SHIFT	3
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MASK	(0x3 << 3)
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MCG	0x0
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_RGB	0x1
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_NRGB	0x2
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_UNDEF	0x3
+#define XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB444_MASK	(0x1 << 3)
+#define XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB422_MASK	(0x1 << 4)
+#define XVIDC_EDID_BDISP_FEATURE_SRGB_DEF_MASK		(0x1 << 2)
+#define XVIDC_EDID_BDISP_FEATURE_PTM_INC_MASK		(0x1 << 1)
+#define XVIDC_EDID_BDISP_FEATURE_CONTFREQ_MASK		(0x1)
+
+/* Color characteristics (display x,y chromaticity coordinates). */
+#define XVIDC_EDID_CC_HIGH_SHIFT			2
+#define XVIDC_EDID_CC_RBX_LOW_SHIFT			6
+#define XVIDC_EDID_CC_RBY_LOW_SHIFT			4
+#define XVIDC_EDID_CC_RBY_LOW_MASK			(0x3 << 4)
+#define XVIDC_EDID_CC_GWX_LOW_SHIFT			2
+#define XVIDC_EDID_CC_GWX_LOW_MASK			(0x3 << 2)
+#define XVIDC_EDID_CC_GWY_LOW_MASK			(0x3)
+#define XVIDC_EDID_CC_GREENY_HIGH			0x1E
+#define XVIDC_EDID_CC_BLUEX_HIGH			0x1F
+#define XVIDC_EDID_CC_BLUEY_HIGH			0x20
+#define XVIDC_EDID_CC_WHITEX_HIGH			0x21
+#define XVIDC_EDID_CC_WHITEY_HIGH			0x22
+
+/* Established timings. */
+#define XVIDC_EDID_EST_TIMINGS_I_720x400_70_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_I_720x400_88_MASK	(0x1 << 6)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_60_MASK	(0x1 << 5)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_67_MASK	(0x1 << 4)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_72_MASK	(0x1 << 3)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_75_MASK	(0x1 << 2)
+#define XVIDC_EDID_EST_TIMINGS_I_800x600_56_MASK	(0x1 << 1)
+#define XVIDC_EDID_EST_TIMINGS_I_800x600_60_MASK	(0x1)
+#define XVIDC_EDID_EST_TIMINGS_II_800x600_72_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_II_800x600_75_MASK	(0x1 << 6)
+#define XVIDC_EDID_EST_TIMINGS_II_832x624_75_MASK	(0x1 << 5)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_87_MASK	(0x1 << 4)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_60_MASK	(0x1 << 3)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_70_MASK	(0x1 << 2)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_75_MASK	(0x1 << 1)
+#define XVIDC_EDID_EST_TIMINGS_II_1280x1024_75_MASK	(0x1)
+#define XVIDC_EDID_EST_TIMINGS_MAN_1152x870_75_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_MAN_MASK			(0x7F)
+
+/* Standard timings. */
+#define XVIDC_EDID_STD_TIMINGS_AR_SHIFT			6
+#define XVIDC_EDID_STD_TIMINGS_AR_16_10			0x0
+#define XVIDC_EDID_STD_TIMINGS_AR_4_3			0x1
+#define XVIDC_EDID_STD_TIMINGS_AR_5_4			0x2
+#define XVIDC_EDID_STD_TIMINGS_AR_16_9			0x3
+#define XVIDC_EDID_STD_TIMINGS_FRR_MASK			(0x3F)
+
+/* Detailed timing descriptor (DTD) / Preferred timing mode (PTM). */
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XBLANK_MASK		0x0F
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XRES_MASK		0xF0
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XRES_SHIFT		4
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VSPW_MASK		0x0F
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VFPORCH_MASK		0xF0
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VFPORCH_SHIFT	4
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HFPORCH_MASK		0xC0
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HSPW_MASK		0x30
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VFPORCH_MASK		0x0C
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VSPW_MASK		0x03
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HFPORCH_SHIFT	6
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HSPW_SHIFT		4
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VFPORCH_SHIFT	2
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_VIMGSIZE_MM_MASK	0x0F
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_HIMGSIZE_MM_MASK	0xF0
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_HIMGSIZE_MM_SHIFT	4
+#define XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_MASK		0x80
+#define XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_SHIFT		7
+#define XVIDC_EDID_DTD_PTM_SIGNAL_HPOLARITY_MASK		0x02
+#define XVIDC_EDID_DTD_PTM_SIGNAL_VPOLARITY_MASK		0x04
+#define XVIDC_EDID_DTD_PTM_SIGNAL_HPOLARITY_SHIFT		1
+#define XVIDC_EDID_DTD_PTM_SIGNAL_VPOLARITY_SHIFT		2
+/* @} */
+
+/******************* Macros (Inline Functions) Definitions ********************/
+
+#define XVidC_EdidIsHeaderValid(E) \
+	!memcmp(E, "\x00\xFF\xFF\xFF\xFF\xFF\xFF\x00", 8)
+
+/* Vendor and product identification: ID manufacturer name. */
+/* void XVidC_EdidGetManName(const u8 *EdidRaw, char ManName[4]); */
+
+/* Vendor and product identification: ID product code. */
+#define XVidC_EdidGetIdProdCode(E) \
+	((u16)((E[XVIDC_EDID_VPI_ID_PROD_CODE_MSB] << 8) | \
+	E[XVIDC_EDID_VPI_ID_PROD_CODE_LSB]))
+
+/* Vendor and product identification: ID serial number. */
+#define XVidC_EdidGetIdSn(E) \
+	((u32)((E[XVIDC_EDID_VPI_ID_SN3] << 24) | \
+	(E[XVIDC_EDID_VPI_ID_SN2] << 16) | (E[XVIDC_EDID_VPI_ID_SN1] << 8) | \
+	E[XVIDC_EDID_VPI_ID_SN0]))
+
+/* Vendor and product identification: Week and year of manufacture or model
+ * year. */
+#define XVidC_EdidGetManWeek(E)		(E[XVIDC_EDID_VPI_WEEK_MAN])
+#define XVidC_EdidGetModManYear(E)	(E[XVIDC_EDID_VPI_YEAR] + 1990)
+#define XVidC_EdidIsYearModel(E)	(XVidC_EdidGetManWeek(E) == 0xFF)
+#define XVidC_EdidIsYearMan(E)		(XVidC_EdidGetManWeek(E) != 0xFF)
+
+/* EDID structure version and revision. */
+#define XVidC_EdidGetStructVer(E)	(E[XVIDC_EDID_STRUCT_VER])
+#define XVidC_EdidGetStructRev(E)	(E[XVIDC_EDID_STRUCT_REV])
+
+/* Basic display parameters and features: Video input definition. */
+#define XVidC_EdidIsDigitalSig(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_VSI_MASK) != 0)
+#define XVidC_EdidIsAnalogSig(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_VSI_MASK) == 0)
+#define XVidC_EdidGetAnalogSigLvlStd(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_ANA_SLS_MASK) >> \
+	XVIDC_EDID_BDISP_VID_ANA_SLS_SHIFT)
+#define XVidC_EdidGetAnalogSigVidSetup(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_VID_SETUP_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigSepSyncHv(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_SEP_SYNC_HV_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigCompSyncH(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_H_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigCompSyncG(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_G_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigSerrVsync(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_SERR_V_SYNC_MASK) != 0)
+/* XVidC_ColorDepth XVidC_EdidGetColorDepth(const u8 *EdidRaw); */
+#define XVidC_EdidGetDigitalSigIfaceStd(E) \
+	(E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_DIG_VIS_MASK)
+
+/* Basic display parameters and features: Horizontal and vertical screen size or
+ * aspect ratio. */
+#define XVidC_EdidIsSsArDefined(E) \
+	((E[XVIDC_EDID_BDISP_H_SSAR] | E[XVIDC_EDID_BDISP_V_SSAR]) != 0)
+#define XVidC_EdidGetSsArH(E)	E[XVIDC_EDID_BDISP_H_SSAR]
+#define XVidC_EdidGetSsArV(E)	E[XVIDC_EDID_BDISP_V_SSAR]
+#define XVidC_EdidIsSsArSs(E) \
+	((XVidC_EdidGetSsArH(E) != 0) && (XVidC_EdidGetSsArV(E) != 0))
+#define XVidC_EdidIsSsArArL(E) \
+	((XVidC_EdidGetSsArH(E) != 0) && (XVidC_EdidGetSsArV(E) == 0))
+#define XVidC_EdidIsSsArArP(E) \
+	((XVidC_EdidGetSsArH(E) == 0) && (XVidC_EdidGetSsArV(E) != 0))
+#define XVidC_EdidGetSsArArL(E) \
+	((float)((XVidC_EdidGetSsArH(E) + 99.0) / 100.0))
+#define XVidC_EdidGetSsArArP(E) \
+	((float)(100.0 / (XVidC_EdidGetSsArV(E) + 99.0)))
+
+/* Basic display parameters and features: Gamma. */
+#define XVidC_EdidIsGammaInExt(E)	(E[XVIDC_EDID_BDISP_GAMMA] == 0xFF)
+#define XVidC_EdidGetGamma(E) \
+	((float)((E[XVIDC_EDID_BDISP_GAMMA] + 100.0) / 100.0))
+
+/* Basic display parameters and features: Feature support. */
+#define XVidC_EdidSuppFeaturePmStandby(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_STANDBY_MASK) != 0)
+#define XVidC_EdidSuppFeaturePmSuspend(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_SUSPEND_MASK) != 0)
+#define XVidC_EdidSuppFeaturePmOffVlp(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_OFF_VLP_MASK) != 0)
+#define XVidC_EdidGetFeatureAnaColorType(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MASK) >> \
+	XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_SHIFT)
+#define XVidC_EdidSuppFeatureDigColorEncYCrCb444(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB444_MASK) != 0)
+#define XVidC_EdidSuppFeatureDigColorEncYCrCb422(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB422_MASK) != 0)
+#define XVidC_EdidIsFeatureSrgbDef(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_SRGB_DEF_MASK) != 0)
+#define XVidC_EdidIsFeaturePtmInc(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PTM_INC_MASK) != 0)
+#define XVidC_EdidIsFeatureContFreq(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_CONTFREQ_MASK) != 0)
+
+/* Established timings. */
+#define XVidC_EdidSuppEstTimings720x400_70(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_720x400_70_MASK) != 0)
+#define XVidC_EdidSuppEstTimings720x400_88(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_720x400_88_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_67(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_67_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_72(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_72_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_56(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_800x600_56_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_800x600_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_72(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_800x600_72_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_800x600_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings832x624_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_832x624_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_87(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_87_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_70(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_70_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1280x1024_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1280x1024_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1152x870_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_MAN] & \
+	XVIDC_EDID_EST_TIMINGS_MAN_1152x870_75_MASK) != 0)
+#define XVidC_EdidGetTimingsMan(E) \
+	(E[XVIDC_EDID_EST_TIMINGS_MAN] & XVIDC_EDID_EST_TIMINGS_MAN_MASK)
+
+/* Standard timings. */
+#define XVidC_EdidGetStdTimingsH(E, N) \
+	((E[XVIDC_EDID_STD_TIMINGS_H(N)] + 31) * 8)
+#define XVidC_EdidGetStdTimingsAr(E, N) \
+	(E[XVIDC_EDID_STD_TIMINGS_AR_FRR(N)] >> XVIDC_EDID_STD_TIMINGS_AR_SHIFT)
+#define XVidC_EdidGetStdTimingsFrr(E, N) \
+	((E[XVIDC_EDID_STD_TIMINGS_AR_FRR(N)] & \
+	XVIDC_EDID_STD_TIMINGS_FRR_MASK) + 60)
+/* u16 XVidC_EdidGetStdTimingsV(const u8 *EdidRaw, u8 StdTimingsNum); */
+#define XVidC_EdidIsDtdPtmInterlaced(E) \
+	((E[XVIDC_EDID_PTM + XVIDC_EDID_DTD_PTM_SIGNAL] & \
+	XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_MASK) >> \
+	XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_SHIFT)
+
+/* Extension block count. */
+#define XVidC_EdidGetExtBlkCount(E)	(E[XVIDC_EDID_EXT_BLK_COUNT])
+
+/* Checksum. */
+#define XVidC_EdidGetChecksum(E)	(E[XVIDC_EDID_CHECKSUM])
+
+/**************************** Function Prototypes *****************************/
+
+/* Vendor and product identification: ID manufacturer name. */
+void XVidC_EdidGetManName(const u8 *EdidRaw, char ManName[4]);
+
+/* Basic display parameters and features: Video input definition. */
+XVidC_ColorDepth XVidC_EdidGetColorDepth(const u8 *EdidRaw);
+
+/* Color characteristics (display x,y chromaticity coordinates). */
+int XVidC_EdidGetCcRedX(const u8 *EdidRaw);
+int XVidC_EdidGetCcRedY(const u8 *EdidRaw);
+int XVidC_EdidGetCcGreenX(const u8 *EdidRaw);
+int XVidC_EdidGetCcGreenY(const u8 *EdidRaw);
+int XVidC_EdidGetCcBlueX(const u8 *EdidRaw);
+int XVidC_EdidGetCcBlueY(const u8 *EdidRaw);
+int XVidC_EdidGetCcWhiteX(const u8 *EdidRaw);
+int XVidC_EdidGetCcWhiteY(const u8 *EdidRaw);
+
+/* Standard timings. */
+u16 XVidC_EdidGetStdTimingsV(const u8 *EdidRaw, u8 StdTimingsNum);
+
+/* Utility functions. */
+u32 XVidC_EdidIsVideoTimingSupported(const u8 *EdidRaw,
+		const XVidC_VideoTimingMode *VtMode);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* XVIDC_EDID_H_ */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.c
new file mode 100644
index 0000000..8347792
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.c
@@ -0,0 +1,2615 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xvtc.c
+* @addtogroup vtc_v7_2
+* @{
+*
+* This is main code of Xilinx MVI Video Timing Controller (VTC) device driver.
+* The VTC device detects and generates video sync signals to Video IP cores
+* like MVI Video Scaler. Please see xvtc.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00a xd     08/05/08 First release.
+* 1.01a xd     07/23/10 Added GIER; Added more h/w generic info into
+*                       xparameters.h; Feed callbacks with pending
+*                       interrupt info. Added Doxygen & Version support.
+* 3.00a cjm    08/01/12 Converted from xio.h to xil_io.h, translating
+*                       basic types, MB cache functions, exceptions and
+*                       assertions to xil_io format.
+*                       Replaced the following:
+*                       "XExc_Init" -> "Xil_ExceptionInit"
+*                       "XExc_RegisterHandler" ->
+*                       "Xil_ExceptionRegisterHandler"
+*                       "XEXC_ID_NON_CRITICAL_INT" -> "XIL_EXCEPTION_ID_INT"
+*                       "XExceptionHandler" -> "Xil_ExceptionHandler"
+*                       "XExc_mEnableExceptions" -> "Xil_ExceptionEnable"
+*                       "XEXC_NON_CRITICAL" -> "XIL_EXCEPTION_NON_CRITICAL"
+*                       "XExc_DisableExceptions" -> "Xil_ExceptionDisable"
+*                       "XExc_RemoveHandler" -> "Xil_ExceptionRemoveHandler"
+*                       "microblaze_enable_interrupts" -> "Xil_ExceptionEnable"
+*                       "microblaze_disable_interrupts" ->
+*                       Xil_ExceptionDisable"
+*                       "XCOMPONENT_IS_STARTED" -> "XIL_COMPONENT_IS_STARTED"
+*                       "XCOMPONENT_IS_READY" -> "(XIL_COMPONENT_IS_READY)"
+*
+*                       "XASSERT_NONVOID" -> "Xil_AssertNonvoid"
+*                       "XASSERT_VOID_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XASSERT_VOID" -> "Xil_AssertVoid"
+*                       "Xil_AssertVoid_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XAssertStatus" -> "Xil_AssertStatus"
+*                       "XAssertSetCallback" -> "Xil_AssertCallback"
+*
+*                       "XASSERT_OCCURRED" -> "XIL_ASSERT_OCCURRED"
+*                       "XASSERT_NONE" -> "XIL_ASSERT_NONE"
+*
+*                       "microblaze_disable_dcache" -> "Xil_DCacheDisable"
+*                       "microblaze_enable_dcache" -> "Xil_DCacheEnable"
+*                       "microblaze_enable_icache" -> "Xil_ICacheEnable"
+*                       "microblaze_disable_icache" -> "Xil_ICacheDisable"
+*                       "microblaze_init_dcache_range" ->
+*                       "Xil_DCacheInvalidateRange"
+*                       "XCache_DisableDCache" -> "Xil_DCacheDisable"
+*                       "XCache_DisableICache" -> "Xil_ICacheDisable"
+*                       "XCache_EnableDCache" -> "Xil_DCacheEnableRegion"
+*                       "XCache_EnableICache" -> "Xil_ICacheEnableRegion"
+*                       "XCache_InvalidateDCacheLine" ->
+*                       "Xil_DCacheInvalidateRange"
+*
+*                       "XUtil_MemoryTest32" -> "Xil_TestMem32"
+*                       "XUtil_MemoryTest16" -> "Xil_TestMem16"
+*                       "XUtil_MemoryTest8" -> "Xil_TestMem8"
+*
+*                       "xutil.h" -> "xil_testmem.h"
+*
+*                       "xbasic_types.h" -> "xil_types.h"
+*                       "xio.h" -> "xil_io.h"
+*
+*                       "XIo_In32" -> "Xil_In32"
+*                       "XIo_Out32" -> "Xil_Out32"
+*
+*                       "XTRUE" -> "TRUE"
+*                       "XFALSE" -> "FALSE"
+*                       "XNULL" -> "NULL"
+*
+*                       "Xuint8" -> "u8"
+*                       "Xuint16" -> "u16"
+*                       "Xuint32" -> "u32"
+*                       "Xint8" -> "char"
+*                       "Xint16" -> "short"
+*                       "Xint32" -> "long"
+*                       "Xfloat32" -> "float"
+*                       "Xfloat64" -> "double"
+*                       "Xboolean" -> "int"
+*                       "XTEST_FAILED" -> "XST_FAILURE"
+*                       "XTEST_PASSED" -> "XST_SUCCESS"
+* 4.00a cjm    02/08/13 Removed XVTC_CTL_HASS_MASK
+* 5.00a cjm    08/07/13 Replaced CTL in Polarity and Encoding register
+*                       definition with "POL" and "ENC"
+* 5.00a cjm    10/30/13 Removed type parameter from XVtc_Enable which now
+*                       enables both generator and detector.
+*                       Added XVtc_EnableGenerator to enable only the Generator
+*                       Added XVtc_EnableDetector to enable only the Detector
+* 5.00a cjm    11/01/13 Added Timing, VideoMode and Signal Conversion Functions
+*                       XVtc_ConvVideoMode2Timing
+*                       XVtc_ConvTiming2Signal
+*                       XVtc_ConvSignal2Timing
+*                       XVtc_ConvTiming2VideoMode
+*                       Added Timing and Video Mode Set/Get Functions
+*                       XVtc_SetGeneratorTiming
+*                       XVtc_SetGeneratorVideoMode
+*                       XVtc_GetGeneratorTiming
+*                       XVtc_GetGeneratorVideoMode
+*                       XVtc_GetDetectorTiming
+*                       XVtc_GetDetectorVideoMode
+*                       Updated XVtc_GetGeneratorHoriOffset and
+*                       XVtc_SetGeneratorHoriOffset. For adding interlaced or
+*                       field-1 registers setting/getting updated
+*                       XVtc_SetGenerator to align vsync to hsync
+*                       horizontally by default.
+*                       Added Field 1 set/get to XVtc_SetGenerator,
+*                       XVtc_GetGenerator and XVtc_GetDetector.
+* 5.00a cjm    11/03/13 Added Chroma/field parity bit masks.
+*                       Replaced old timing bit masks/shifts with Start/End Bit
+*                       masks/shifts.
+* 6.1   adk    08/23/14 Modified HActiveVideo value to 1920 for
+*                       XVTC_VMODE_1080I mode.
+*                       Removed Major, Minor and Revision parameters from
+*                       XVtc_GetVersion.
+*                       Modified return type of XVtc_GetVersion from
+*                       void to u32.
+* 7.0   vns    25/02/15 Added progressive and interlaced mode switching feature.
+*                       Modified XVtc_SetGenerator, XVtc_GetGenerator,
+*                       XVtc_GetDetector, XVtc_ConvTiming2Signal and
+*                       XVtc_ConvSignal2Timing APIs
+* 7.1   vns    07/10/15 Corrected V0SyncStart and V1SyncStart values
+*                       in APIs XVtc_ConvTiming2Signal and
+*                       XVtc_ConvSignal2Timing
+*                       Corrected register read to XVTC_DVSYNC_F1_OFFSET
+*                       in API XVtc_GetDetector
+*       vns    10/14/15 Modified XVtc_SetSource API to provided programming
+*                       interlaced mode feature and modified XVtc_GetSource
+*                       API to read interlaced mode status.
+*                       Corrected XVtc_ConvSignal2Timing API to get interlaced
+*                       mode from SignalCfgPtr structure.
+* 7.2   mh     04/20/16 Removed call to XVtc_Reset from XVtc_CfgInitialize.
+*       sk     08/16/16 Used UINTPTR instead of u32 for Baseaddress as part of
+*                       adding 64 bit support. CR# 867425.
+*                       Changed the prototype of XVtc_CfgInitialize API.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xvtc.h"
+#include <linux/string.h>
+//#include "xenv.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+/*
+* Each of callback functions to be called on different types of interrupts.
+* These stub functions are set during XVtc_CfgInitialize as default
+* callback functions. If application is not registered any of the callback
+* function, these functions will be called for doing nothing.
+*/
+static void StubCallBack(void *CallBackRef);
+static void StubErrCallBack(void *CallBackRef, u32 ErrorMask);
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function initializes the VTC core. This function must be called
+* prior to using the VTC core. Initialization of the VTC includes setting up
+* the instance data, and ensuring the hardware is in a quiescent state.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+* @param	CfgPtr points to the configuration structure associated with
+*		the VTC core.
+* @param	EffectiveAddr is the base address of the device. If address
+*		translation is being used, then this parameter must reflect the
+*		virtual base address. Otherwise, the physical address should be
+*		used.
+*
+* @return
+*		- XST_SUCCESS if XVtc_CfgInitialize was successful.
+*
+* @note		None.
+*
+******************************************************************************/
+int XVtc_CfgInitialize(XVtc *InstancePtr, XVtc_Config *CfgPtr,
+				UINTPTR EffectiveAddr)
+{
+	/* Verify arguments */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+	Xil_AssertNonvoid(CfgPtr != NULL);
+	Xil_AssertNonvoid((u32 *)EffectiveAddr != NULL);
+
+	/* Setup the instance */
+	memset((void *)InstancePtr, 0, sizeof(XVtc));
+
+	memcpy((void *)&(InstancePtr->Config), (const void *)CfgPtr,
+			   sizeof(XVtc_Config));
+	InstancePtr->Config.BaseAddress = EffectiveAddr;
+
+	/* Set all handlers to stub values, let user configure this data later */
+	InstancePtr->FrameSyncCallBack = (XVtc_CallBack) StubCallBack;
+	InstancePtr->LockCallBack = (XVtc_CallBack) StubCallBack;
+	InstancePtr->DetectorCallBack = (XVtc_CallBack) StubCallBack;
+	InstancePtr->GeneratorCallBack = (XVtc_CallBack) StubCallBack;
+	InstancePtr->ErrCallBack = (XVtc_ErrorCallBack) StubErrCallBack;
+
+	/* Set the flag to indicate the driver is ready */
+	InstancePtr->IsReady = (u32)(XIL_COMPONENT_IS_READY);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables the VTC Generator core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_EnableGenerator(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Change the value according to the enabling type and write it back */
+	CtrlRegValue |= XVTC_CTL_GE_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables the VTC Detector core
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_EnableDetector(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Change the value according to the enabling type and write it back */
+	CtrlRegValue |= XVTC_CTL_DE_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables the Detector and Generator at same time of the
+* VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_Enable(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Setup the SW Enable Bit and write it back */
+	CtrlRegValue |= XVTC_CTL_SW_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+				CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function disables the VTC Generator core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_DisableGenerator(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Change the value according to the disabling type and write it
+	 * back
+	 */
+	CtrlRegValue &= (u32)(~(XVTC_CTL_GE_MASK));
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function disables the VTC Detector core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_DisableDetector(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Change the value according to the disabling type and write it
+	 * back
+	 */
+	CtrlRegValue &= (u32)(~(XVTC_CTL_DE_MASK));
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function disables the Detector and Generator at same time of the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_Disable(XVtc *InstancePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Change the value, clearing Core Enable, and write it back*/
+	CtrlRegValue &= ~XVTC_CTL_SW_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the output polarity of the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	PolarityPtr points to a Polarity configuration structure with
+*		the setting to use on the VTC core.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void XVtc_SetPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr)
+{
+	u32 PolRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(PolarityPtr != NULL);
+
+	/* Read Control register value back and clear all polarity
+	 * bits first
+	 */
+	PolRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_GPOL_OFFSET));
+	PolRegValue &= (u32)(~(XVTC_POL_ALLP_MASK));
+
+	/* Change the register value according to the setting in the Polarity
+	 * configuration structure
+	 */
+	if (PolarityPtr->ActiveChromaPol)
+		PolRegValue |= XVTC_POL_ACP_MASK;
+
+	if (PolarityPtr->ActiveVideoPol)
+		PolRegValue |= XVTC_POL_AVP_MASK;
+
+	if (PolarityPtr->FieldIdPol)
+		PolRegValue |= XVTC_POL_FIP_MASK;
+
+	if (PolarityPtr->VBlankPol)
+		PolRegValue |= XVTC_POL_VBP_MASK;
+
+	if (PolarityPtr->VSyncPol)
+		PolRegValue |= XVTC_POL_VSP_MASK;
+
+	if (PolarityPtr->HBlankPol)
+		PolRegValue |= XVTC_POL_HBP_MASK;
+
+	if (PolarityPtr->HSyncPol)
+		PolRegValue |= XVTC_POL_HSP_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_GPOL_OFFSET),
+			PolRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the output polarity setting used by the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	PolarityPtr points to a Polarity configuration structure that
+*		will be populated with the setting used on the VTC core
+*		after this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr)
+{
+	u32 PolRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(PolarityPtr != NULL);
+
+	/* Clear the Polarity configuration structure */
+	memset((void *)PolarityPtr, 0, sizeof(XVtc_Polarity));
+
+	/* Read Control register value back */
+	PolRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_GPOL_OFFSET));
+
+	/* Populate the Polarity configuration structure w/ the current setting
+	 * used in the device
+	 */
+	if (PolRegValue & XVTC_POL_ACP_MASK)
+		PolarityPtr->ActiveChromaPol = 1;
+
+	if (PolRegValue & XVTC_POL_AVP_MASK)
+		PolarityPtr->ActiveVideoPol = 1;
+
+	if (PolRegValue & XVTC_POL_FIP_MASK)
+		PolarityPtr->FieldIdPol = 1;
+
+	if (PolRegValue & XVTC_POL_VBP_MASK)
+		PolarityPtr->VBlankPol = 1;
+
+	if (PolRegValue & XVTC_POL_VSP_MASK)
+		PolarityPtr->VSyncPol = 1;
+
+	if (PolRegValue & XVTC_POL_HBP_MASK)
+		PolarityPtr->HBlankPol = 1;
+
+	if (PolRegValue & XVTC_POL_HSP_MASK)
+		PolarityPtr->HSyncPol = 1;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the input polarity setting used by the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	PolarityPtr points to a Polarity configuration structure that
+*		will be populated with the setting used on the VTC core after
+*		this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetDetectorPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr)
+{
+	u32 PolRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(PolarityPtr != NULL);
+
+	/* Clear the Polarity configuration structure */
+	memset((void *)PolarityPtr, 0, sizeof(XVtc_Polarity));
+
+	/* Read Control register value back */
+	PolRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_DPOL_OFFSET));
+
+	/* Populate the Polarity configuration structure w/ the current setting
+	 * used in the core.
+	 */
+	if (PolRegValue & XVTC_POL_ACP_MASK)
+		PolarityPtr->ActiveChromaPol = 1;
+
+	if (PolRegValue & XVTC_POL_AVP_MASK)
+		PolarityPtr->ActiveVideoPol = 1;
+
+	if (PolRegValue & XVTC_POL_FIP_MASK)
+		PolarityPtr->FieldIdPol = 1;
+
+	if (PolRegValue & XVTC_POL_VBP_MASK)
+		PolarityPtr->VBlankPol = 1;
+
+	if (PolRegValue & XVTC_POL_VSP_MASK)
+		PolarityPtr->VSyncPol = 1;
+
+	if (PolRegValue & XVTC_POL_HBP_MASK)
+		PolarityPtr->HBlankPol = 1;
+
+	if (PolRegValue & XVTC_POL_HSP_MASK)
+		PolarityPtr->HSyncPol = 1;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the source selecting of the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on
+* @param 	SourcePtr points to a Source Selecting configuration structure
+*		with the setting to use on the VTC device.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetSource(XVtc *InstancePtr, XVtc_SourceSelect *SourcePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SourcePtr != NULL);
+
+	/* Read Control register value back and clear all source selection bits
+	 * first
+	 */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+	CtrlRegValue &= ~XVTC_CTL_ALLSS_MASK;
+
+	/* Change the register value according to the setting in the source
+	 * selection configuration structure
+	 */
+
+	if (SourcePtr->FieldIdPolSrc)
+		CtrlRegValue |= XVTC_CTL_FIPSS_MASK;
+
+	if (SourcePtr->ActiveChromaPolSrc)
+		CtrlRegValue |= XVTC_CTL_ACPSS_MASK;
+
+	if (SourcePtr->ActiveVideoPolSrc)
+		CtrlRegValue |= XVTC_CTL_AVPSS_MASK;
+
+	if (SourcePtr->HSyncPolSrc)
+		CtrlRegValue |= XVTC_CTL_HSPSS_MASK;
+
+	if (SourcePtr->VSyncPolSrc)
+		CtrlRegValue |= XVTC_CTL_VSPSS_MASK;
+
+	if (SourcePtr->HBlankPolSrc)
+		CtrlRegValue |= XVTC_CTL_HBPSS_MASK;
+
+	if (SourcePtr->VBlankPolSrc)
+		CtrlRegValue |= XVTC_CTL_VBPSS_MASK;
+
+
+	if (SourcePtr->VChromaSrc)
+		CtrlRegValue |= XVTC_CTL_VCSS_MASK;
+
+	if (SourcePtr->VActiveSrc)
+		CtrlRegValue |= XVTC_CTL_VASS_MASK;
+
+	if (SourcePtr->VBackPorchSrc)
+		CtrlRegValue |= XVTC_CTL_VBSS_MASK;
+
+	if (SourcePtr->VSyncSrc)
+		CtrlRegValue |= XVTC_CTL_VSSS_MASK;
+
+	if (SourcePtr->VFrontPorchSrc)
+		CtrlRegValue |= XVTC_CTL_VFSS_MASK;
+
+	if (SourcePtr->VTotalSrc)
+		CtrlRegValue |= XVTC_CTL_VTSS_MASK;
+
+	if (SourcePtr->HBackPorchSrc)
+		CtrlRegValue |= XVTC_CTL_HBSS_MASK;
+
+	if (SourcePtr->HSyncSrc)
+		CtrlRegValue |= XVTC_CTL_HSSS_MASK;
+
+	if (SourcePtr->HFrontPorchSrc)
+		CtrlRegValue |= XVTC_CTL_HFSS_MASK;
+
+	if (SourcePtr->HTotalSrc)
+		CtrlRegValue |= XVTC_CTL_HTSS_MASK;
+
+	if (SourcePtr->InterlacedMode)
+		CtrlRegValue |= XVTC_CTL_INTERLACE_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_CTL_OFFSET),
+			CtrlRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the source select setting used by the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param 	SourcePtr points to a source select configuration structure
+*		that will be populated with the setting used on the VTC core
+*		after this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void XVtc_GetSource(XVtc *InstancePtr, XVtc_SourceSelect *SourcePtr)
+{
+	u32 CtrlRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SourcePtr != NULL);
+
+	/* Clear the source selection configuration structure */
+	memset((void *)SourcePtr, 0, sizeof(XVtc_SourceSelect));
+
+	/* Read Control register value back */
+	CtrlRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					(XVTC_CTL_OFFSET));
+
+	/* Populate the source select configuration structure with the current
+	 * setting used in the core
+	 */
+	if (CtrlRegValue & XVTC_CTL_FIPSS_MASK)
+		SourcePtr->FieldIdPolSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_ACPSS_MASK)
+		SourcePtr->ActiveChromaPolSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_AVPSS_MASK)
+		SourcePtr->ActiveVideoPolSrc= 1;
+	if (CtrlRegValue & XVTC_CTL_HSPSS_MASK)
+		SourcePtr->HSyncPolSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VSPSS_MASK)
+		SourcePtr->VSyncPolSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_HBPSS_MASK)
+		SourcePtr->HBlankPolSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VBPSS_MASK)
+		SourcePtr->VBlankPolSrc = 1;
+
+	if (CtrlRegValue & XVTC_CTL_VCSS_MASK)
+		SourcePtr->VChromaSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VASS_MASK)
+		SourcePtr->VActiveSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VBSS_MASK)
+		SourcePtr->VBackPorchSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VSSS_MASK)
+		SourcePtr->VSyncSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VFSS_MASK)
+		SourcePtr->VFrontPorchSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_VTSS_MASK)
+		SourcePtr->VTotalSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_HBSS_MASK)
+		SourcePtr->HBackPorchSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_HSSS_MASK)
+		SourcePtr->HSyncSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_HFSS_MASK)
+		SourcePtr->HFrontPorchSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_HTSS_MASK)
+		SourcePtr->HTotalSrc = 1;
+	if (CtrlRegValue & XVTC_CTL_INTERLACE_MASK)
+		SourcePtr->InterlacedMode = 1;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the line skip setting of the Generator in the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param 	GeneratorChromaSkip indicates whether to skip 1 line between
+*		active chroma for the Generator module. Use Non-0 value for
+*		this parameter to skip 1 line, and 0 to not skip lines.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetSkipLine(XVtc *InstancePtr, int GeneratorChromaSkip)
+{
+	u32 FrameEncodeRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Read Control register value back and clear all skip bits first */
+	FrameEncodeRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						(XVTC_GFENC_OFFSET));
+	FrameEncodeRegValue &= (u32)(~(XVTC_ENC_GACLS_MASK));
+
+	/* Change the register value according to the skip setting passed
+	 * into this function.
+	 */
+	if (GeneratorChromaSkip)
+		FrameEncodeRegValue |= XVTC_ENC_GACLS_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_GFENC_OFFSET),
+			FrameEncodeRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the line skip setting used by the Generator in the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	GeneratorChromaSkipPtr will point to the value indicating
+*		whether one line is skipped between active chroma for the
+*		Generator module after this function returns. Value 1 means
+*		that 1 line is skipped and zero means that no lines are
+*		skipped.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetSkipLine(XVtc *InstancePtr, int *GeneratorChromaSkipPtr)
+{
+	u32 FrameEncodeRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(GeneratorChromaSkipPtr != NULL);
+
+	/* Read Control register value back */
+	FrameEncodeRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						(XVTC_GFENC_OFFSET));
+
+	/* Populate the skip variable values according to the skip setting
+	 * used by the core.
+	 */
+	if (FrameEncodeRegValue & XVTC_ENC_GACLS_MASK)
+		*GeneratorChromaSkipPtr = 1;
+	else
+		*GeneratorChromaSkipPtr = 0;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the pixel skip setting of the Generator in the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	GeneratorChromaSkip indicates whether to skip 1 pixel between
+*		active chroma for the Generator module. Use Non-0 value for
+*		this parameter to skip 1 pixel, and 0 to not skip pixels
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetSkipPixel(XVtc *InstancePtr, int GeneratorChromaSkip)
+{
+	u32 FrameEncodeRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == (u32)(XIL_COMPONENT_IS_READY));
+
+	/* Read Control register value back and clear all skip bits first */
+	FrameEncodeRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						(XVTC_GFENC_OFFSET));
+	FrameEncodeRegValue &= (u32)(~(XVTC_ENC_GACPS_MASK));
+
+	/* Change the register value according to the skip setting passed
+	 * into this function.
+	 */
+	if (GeneratorChromaSkip)
+		FrameEncodeRegValue |= XVTC_ENC_GACPS_MASK;
+
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_GFENC_OFFSET),
+				FrameEncodeRegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the pixel skip setting used by the Generator in the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	GeneratorChromaSkipPtr will point to the value indicating
+*		whether one pixel is skipped between active chroma for the
+*		Generator module after this function returns. Value 1 means
+*		that 1 pixel is skipped and zero means that no pixels are
+*		skipped.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetSkipPixel(XVtc *InstancePtr, int *GeneratorChromaSkipPtr)
+{
+	u32 FrameEncodeRegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(GeneratorChromaSkipPtr != NULL);
+
+	/* Read Control register value back */
+	FrameEncodeRegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						(XVTC_GFENC_OFFSET));
+
+	/* Populate the skip variable values according to the skip setting
+	 * used by the core.
+	 */
+	if (FrameEncodeRegValue & XVTC_ENC_GACPS_MASK)
+		*GeneratorChromaSkipPtr = 1;
+	else
+		*GeneratorChromaSkipPtr = 0;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the Generator delay setting of the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param 	VertDelay indicates the number of total lines per frame to
+*		delay the generator output. The valid range is from 0 to 4095.
+* @param	HoriDelay indicates the number of total clock cycles per line
+*		to delay the generator output. The valid range is from 0 to
+*		4095.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetDelay(XVtc *InstancePtr, int VertDelay, int HoriDelay)
+{
+	u32 RegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(VertDelay >= 0);
+	Xil_AssertVoid(HoriDelay >= 0);
+	Xil_AssertVoid(VertDelay <= 4095);
+	Xil_AssertVoid(HoriDelay <= 4095);
+
+	/* Calculate the delay value */
+	RegValue = HoriDelay & XVTC_GGD_HDELAY_MASK;
+	RegValue |= (VertDelay << XVTC_GGD_VDELAY_SHIFT) &
+			XVTC_GGD_VDELAY_MASK;
+
+	/* Update the Generator Global Delay register w/ the value */
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, (XVTC_GGD_OFFSET),
+			RegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the Generator delay setting used by the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	VertDelayPtr will point to a value indicating the number of
+*		total lines per frame to delay the generator output after
+*		this function returns.
+* @param	HoriDelayPtr will point to a value indicating the number of
+*		total clock cycles per line to delay the generator output
+*		after this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetDelay(XVtc *InstancePtr, int *VertDelayPtr, int *HoriDelayPtr)
+{
+	u32 RegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(VertDelayPtr != NULL);
+	Xil_AssertVoid(HoriDelayPtr != NULL);
+
+	/* Read the Generator Global Delay register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+				(XVTC_GGD_OFFSET));
+
+	/* Calculate the delay values */
+	*HoriDelayPtr = RegValue & XVTC_GGD_HDELAY_MASK;
+	*VertDelayPtr = (RegValue & XVTC_GGD_VDELAY_MASK) >>
+				XVTC_GGD_VDELAY_SHIFT;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the SYNC setting of a frame sync used by the VTC
+* core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	FrameSyncIndex indicates the index number of the frame sync.
+*		The valid range is from 0 to 15.
+* @param	VertStart indicates the vertical line count during which the
+*		frame sync is active. The valid range is from 0 to 4095.
+* @param	HoriStart indicates the horizontal cycle count during which the
+*		frame sync is active. The valid range is from 0 to 4095.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetFSync(XVtc *InstancePtr, u16 FrameSyncIndex, u16 VertStart,
+			u16 HoriStart)
+{
+	u32 RegValue;
+	u32 RegAddress;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(FrameSyncIndex <= 15);
+	Xil_AssertVoid(VertStart <= 4095);
+	Xil_AssertVoid(HoriStart <= 4095);
+
+	/* Calculate the sync value */
+	RegValue = HoriStart & XVTC_FSXX_HSTART_MASK;
+	RegValue |= (VertStart << XVTC_FSXX_VSTART_SHIFT) &
+			XVTC_FSXX_VSTART_MASK;
+
+	/* Calculate the frame sync register address to write to */
+	RegAddress = XVTC_FS00_OFFSET + FrameSyncIndex * XVTC_REG_ADDRGAP;
+
+	/* Update the Generator Global Delay register w/ the value */
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, RegAddress, RegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the SYNC setting of a frame sync used by the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	FrameSyncIndex indicates the index number of the frame sync.
+* 		The valid range is from 0 to 15.
+* @param	VertStartPtr will point to the value that indicates the
+* 		vertical line count during which the frame sync is active once
+*		this function returns.
+* @param	HoriStartPtr will point to the value that indicates the
+*		horizontal cycle count during which the frame sync is active
+*		once this function returns.
+*
+* @return	None.
+*
+******************************************************************************/
+void XVtc_GetFSync(XVtc *InstancePtr, u16 FrameSyncIndex,
+			u16 *VertStartPtr, u16 *HoriStartPtr)
+{
+	u32 RegValue;
+	u32 RegAddress;
+
+	/* Assert bad arguments and conditions */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(FrameSyncIndex <= 15);
+	Xil_AssertVoid(VertStartPtr != NULL);
+	Xil_AssertVoid(VertStartPtr != NULL);
+
+	/* Calculate the frame sync register address to read from */
+	RegAddress = XVTC_FS00_OFFSET + FrameSyncIndex * XVTC_REG_ADDRGAP;
+
+	/* Read the frame sync register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, RegAddress);
+
+	/* Calculate the frame sync values */
+	*HoriStartPtr = RegValue & XVTC_FSXX_HSTART_MASK;
+	*VertStartPtr = (RegValue & XVTC_FSXX_VSTART_MASK) >>
+				XVTC_FSXX_VSTART_SHIFT;
+}
+
+/*****************************************************************************/
+/**
+ * This function sets the VBlank/VSync Horizontal Offsets for the Generator
+ * in a VTC device.
+ *
+ * @param  InstancePtr is a pointer to the VTC device instance to be worked on.
+ * @param  HoriOffsets points to a VBlank/VSync Horizontal Offset configuration
+ *	   with the setting to use on the VTC device.
+ * @return NONE.
+ *
+ *****************************************************************************/
+void XVtc_SetGeneratorHoriOffset(XVtc *InstancePtr,
+				XVtc_HoriOffsets *HoriOffsets)
+{
+	u32 RegValue;
+
+	/* Assert bad arguments and conditions */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(HoriOffsets != NULL);
+
+	/* Calculate and update Generator VBlank Hori. Offset 0 register value
+	 */
+	RegValue = (HoriOffsets->V0BlankHoriStart) & XVTC_XVXHOX_HSTART_MASK;
+	RegValue |= (HoriOffsets->V0BlankHoriEnd << XVTC_XVXHOX_HEND_SHIFT) &
+					XVTC_XVXHOX_HEND_MASK;
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, XVTC_GVBHOFF_OFFSET,
+								RegValue);
+
+	/* Calculate and update Generator VSync Hori. Offset 0 register
+	 * value
+	 */
+	RegValue = (HoriOffsets->V0SyncHoriStart) & XVTC_XVXHOX_HSTART_MASK;
+	RegValue |= (HoriOffsets->V0SyncHoriEnd << XVTC_XVXHOX_HEND_SHIFT) &
+					XVTC_XVXHOX_HEND_MASK;
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, XVTC_GVSHOFF_OFFSET,
+								RegValue);
+
+	/* Calculate and update Generator VBlank Hori. Offset 1 register
+	 * value
+	 */
+	RegValue = (HoriOffsets->V1BlankHoriStart) & XVTC_XVXHOX_HSTART_MASK;
+	RegValue |= (HoriOffsets->V1BlankHoriEnd << XVTC_XVXHOX_HEND_SHIFT) &
+					XVTC_XVXHOX_HEND_MASK;
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress, XVTC_GVBHOFF_F1_OFFSET,
+								RegValue);
+
+	/* Calculate and update Generator VSync Hori. Offset 1 register
+	 * value
+	 */
+	RegValue = (HoriOffsets->V1SyncHoriStart) & XVTC_XVXHOX_HSTART_MASK;
+	RegValue |= (HoriOffsets->V1SyncHoriEnd << XVTC_XVXHOX_HEND_SHIFT) &
+					XVTC_XVXHOX_HEND_MASK;
+	XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVSHOFF_F1_OFFSET,
+								RegValue);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the VBlank/VSync Horizontal Offsets currently used by
+* the Generator in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	HoriOffsets points to a VBlank/VSync Horizontal Offset
+*		configuration structure that will be populated with the setting
+*		currently used on the Generator in the given VTC device after
+*		this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetGeneratorHoriOffset(XVtc *InstancePtr,
+					XVtc_HoriOffsets *HoriOffsets)
+{
+	u32 RegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(HoriOffsets != NULL);
+
+	/* Parse Generator VBlank Hori. Offset 0 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GVBHOFF_OFFSET);
+	HoriOffsets->V0BlankHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V0BlankHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Generator VSync Hori. Offset 0 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVSHOFF_OFFSET);
+	HoriOffsets->V0SyncHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V0SyncHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Generator VBlank Hori. Offset 1 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVBHOFF_F1_OFFSET);
+	HoriOffsets->V1BlankHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V1BlankHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Generator VSync Hori. Offset 1 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+					 XVTC_GVSHOFF_F1_OFFSET);
+	HoriOffsets->V1SyncHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V1SyncHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the VBlank/VSync Horizontal Offsets detected by
+* the Detector in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	HoriOffsets points to a VBlank/VSync Horizontal Offset
+*		configuration structure that will be populated with the setting
+*		detected on the Detector in the given VTC device after this
+*		function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetDetectorHoriOffset(XVtc *InstancePtr,
+				XVtc_HoriOffsets *HoriOffsets)
+{
+	u32 RegValue;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(HoriOffsets != NULL);
+
+	/* Parse Detector VBlank Hori. Offset 0 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DVBHOFF_OFFSET);
+	HoriOffsets->V0BlankHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V0BlankHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Detector VSync Hori. Offset 0 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_DVSHOFF_OFFSET);
+	HoriOffsets->V0SyncHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V0SyncHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Detector VBlank Hori. Offset 1 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_DVBHOFF_F1_OFFSET);
+	HoriOffsets->V1BlankHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V1BlankHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+
+	/* Parse Detector VSync Hori. Offset 1 register value */
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_DVSHOFF_F1_OFFSET);
+	HoriOffsets->V1SyncHoriStart = RegValue & XVTC_XVXHOX_HSTART_MASK;
+	HoriOffsets->V1SyncHoriEnd = (RegValue & XVTC_XVXHOX_HEND_MASK)
+					>> XVTC_XVXHOX_HEND_SHIFT;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up VTC signal to be used by the Generator module
+* in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	SignalCfgPtr is a pointer to the VTC signal configuration
+*		to be used by the Generator module in the VTC core.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void XVtc_SetGenerator(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr)
+{
+	u32 RegValue;
+	u32 r_htotal, r_vtotal, r_hactive, r_vactive;
+	XVtc_Signal *SCPtr;
+	XVtc_HoriOffsets horiOffsets;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SignalCfgPtr != NULL);
+
+	SCPtr = SignalCfgPtr;
+	if(SCPtr->OriginMode == 0)
+	{
+		r_htotal = SCPtr->HTotal+1;
+		r_vtotal = SCPtr->V0Total+1;
+
+		r_hactive = r_htotal - SCPtr->HActiveStart;
+		r_vactive = r_vtotal - SCPtr->V0ActiveStart;
+
+		RegValue = (r_htotal) & XVTC_SB_START_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GHSIZE_OFFSET, RegValue);
+
+		RegValue = (r_vtotal) & XVTC_VSIZE_F0_MASK;
+		RegValue |= ((SCPtr->V1Total+1) << XVTC_VSIZE_F1_SHIFT) &
+							XVTC_VSIZE_F1_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GVSIZE_OFFSET, RegValue);
+
+
+		RegValue = (r_hactive) & XVTC_ASIZE_HORI_MASK;
+		RegValue |= ((r_vactive) << XVTC_ASIZE_VERT_SHIFT ) &
+							XVTC_ASIZE_VERT_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GASIZE_OFFSET, RegValue);
+
+		/* Update the Generator Horizontal 1 Register */
+		RegValue = (SCPtr->HSyncStart + r_hactive) &
+						XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->HBackPorchStart + r_hactive) <<
+				XVTC_SB_END_SHIFT) & XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GHSYNC_OFFSET, RegValue);
+
+		/* Update the Generator Vertical 1 Register (field 0) */
+		RegValue = (SCPtr->V0SyncStart + r_vactive -1) &
+						XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->V0BackPorchStart + r_vactive -1) <<
+				XVTC_SB_END_SHIFT) & XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GVSYNC_OFFSET, RegValue);
+
+		/* Update the Generator Vertical Sync Register (field 1) */
+		RegValue = (SCPtr->V1SyncStart + r_vactive -1) &
+						XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->V1BackPorchStart + r_vactive -1) <<
+					XVTC_SB_END_SHIFT) & XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GVSYNC_F1_OFFSET, RegValue);
+
+		/* Chroma Start */
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GFENC_OFFSET);
+		RegValue &= ~XVTC_ENC_CPARITY_MASK;
+		RegValue = (((SCPtr->V0ChromaStart - SCPtr->V0ActiveStart) <<
+						XVTC_ENC_CPARITY_SHIFT) &
+					XVTC_ENC_CPARITY_MASK) | RegValue;
+
+		RegValue &= ~XVTC_ENC_PROG_MASK;
+		RegValue |= (SCPtr->Interlaced << XVTC_ENC_PROG_SHIFT) &
+				XVTC_ENC_PROG_MASK;
+
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GFENC_OFFSET, RegValue);
+
+		/* Setup default Horizontal Offsets - can override later with
+		 * XVtc_SetGeneratorHoriOffset()
+		 */
+		horiOffsets.V0BlankHoriStart = r_hactive;
+		horiOffsets.V0BlankHoriEnd = r_hactive;
+		horiOffsets.V0SyncHoriStart = SCPtr->HSyncStart + r_hactive;
+		horiOffsets.V0SyncHoriEnd = SCPtr->HSyncStart + r_hactive;
+
+		horiOffsets.V1BlankHoriStart = r_hactive;
+		horiOffsets.V1BlankHoriEnd = r_hactive;
+		horiOffsets.V1SyncHoriStart = SCPtr->HSyncStart + r_hactive;
+		horiOffsets.V1SyncHoriEnd = SCPtr->HSyncStart + r_hactive;
+
+	}
+	else
+	{
+		/* Total in mode=1 is the line width */
+		r_htotal = SCPtr->HTotal;
+		/* Total in mode=1 is the frame height */
+		r_vtotal = SCPtr->V0Total;
+		r_hactive = SCPtr->HFrontPorchStart;
+		r_vactive = SCPtr->V0FrontPorchStart;
+
+		RegValue = (r_htotal) & XVTC_SB_START_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GHSIZE_OFFSET, RegValue);
+
+		RegValue = (r_vtotal) & XVTC_VSIZE_F0_MASK;
+		RegValue |= ((SCPtr->V1Total) << XVTC_VSIZE_F1_SHIFT) &
+							XVTC_VSIZE_F1_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVSIZE_OFFSET, RegValue);
+
+
+		RegValue = (r_hactive) & XVTC_ASIZE_HORI_MASK;
+		RegValue |= ((r_vactive) << XVTC_ASIZE_VERT_SHIFT) &
+							XVTC_ASIZE_VERT_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GASIZE_OFFSET, RegValue);
+
+		/* Update the Generator Horizontal 1 Register */
+		RegValue = (SCPtr->HSyncStart) & XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->HBackPorchStart) << XVTC_SB_END_SHIFT) &
+						XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GHSYNC_OFFSET, RegValue);
+
+
+		/* Update the Generator Vertical Sync Register (field 0) */
+		RegValue = (SCPtr->V0SyncStart) & XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->V0BackPorchStart) << XVTC_SB_END_SHIFT) &
+						XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVSYNC_OFFSET, RegValue);
+
+		/* Update the Generator Vertical Sync Register (field 1) */
+		RegValue = (SCPtr->V1SyncStart) & XVTC_SB_START_MASK;
+		RegValue |= ((SCPtr->V1BackPorchStart) << XVTC_SB_END_SHIFT) &
+						XVTC_SB_END_MASK;
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GVSYNC_F1_OFFSET, RegValue);
+
+		/* Chroma Start */
+		  RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GFENC_OFFSET);
+		RegValue &= ~XVTC_ENC_CPARITY_MASK;
+		RegValue = (((SCPtr->V0ChromaStart - SCPtr->V0ActiveStart) <<
+							XVTC_ENC_CPARITY_SHIFT)
+					& XVTC_ENC_CPARITY_MASK) | RegValue;
+
+		RegValue &= ~XVTC_ENC_PROG_MASK;
+		RegValue |= (SCPtr->Interlaced << XVTC_ENC_PROG_SHIFT) &
+						XVTC_ENC_PROG_MASK;
+
+		XVtc_WriteReg(InstancePtr->Config.BaseAddress,
+					XVTC_GFENC_OFFSET, RegValue);
+
+		/* Setup default Horizontal Offsets - can override later with
+		 * XVtc_SetGeneratorHoriOffset()
+		 */
+		horiOffsets.V0BlankHoriStart = r_hactive;
+		horiOffsets.V0BlankHoriEnd = r_hactive;
+		horiOffsets.V0SyncHoriStart = SCPtr->HSyncStart;
+		horiOffsets.V0SyncHoriEnd = SCPtr->HSyncStart;
+		horiOffsets.V1BlankHoriStart = r_hactive;
+		horiOffsets.V1BlankHoriEnd = r_hactive;
+		horiOffsets.V1SyncHoriStart = SCPtr->HSyncStart;
+		horiOffsets.V1SyncHoriEnd = SCPtr->HSyncStart;
+
+	}
+	XVtc_SetGeneratorHoriOffset(InstancePtr, &horiOffsets);
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the VTC signal setting used by the Generator module
+* in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	SignalCfgPtr is a pointer to a VTC signal configuration
+*		which will be populated with the setting used by the Generator
+*		module in the VTC core once this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetGenerator(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr)
+{
+	u32 RegValue;
+  u32 r_htotal, r_vtotal, r_hactive, r_vactive;
+	XVtc_Signal *SCPtr;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SignalCfgPtr != NULL);
+
+	SCPtr = SignalCfgPtr;
+  if(SCPtr->OriginMode == 0)
+  {
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GHSIZE_OFFSET);
+	r_htotal = (RegValue) & XVTC_SB_START_MASK;
+	SCPtr->HTotal = (r_htotal-1) & XVTC_SB_START_MASK;
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GVSIZE_OFFSET);
+	r_vtotal = (RegValue) & XVTC_VSIZE_F0_MASK;
+	SCPtr->V0Total = (r_vtotal-1) & XVTC_VSIZE_F0_MASK;
+	SCPtr->V1Total = (RegValue & XVTC_VSIZE_F1_MASK) >> XVTC_VSIZE_F1_SHIFT;
+    if(SCPtr->V1Total != 0)
+    {
+      SCPtr->V1Total = SCPtr->V1Total - 1;
+    }
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GASIZE_OFFSET);
+	r_hactive = (RegValue) & XVTC_ASIZE_HORI_MASK;
+	SCPtr->HActiveStart = (r_htotal - r_hactive) & XVTC_ASIZE_HORI_MASK;
+	r_vactive = (RegValue & XVTC_ASIZE_VERT_MASK) >> XVTC_ASIZE_VERT_SHIFT;
+
+	SCPtr->V0ActiveStart = (r_vtotal - r_vactive) & XVTC_VSIZE_F0_MASK;
+	SCPtr->V1ActiveStart = (SCPtr->V1Total - r_vactive - 1) & XVTC_VSIZE_F0_MASK;
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GHSYNC_OFFSET);
+    SCPtr->HSyncStart = ((RegValue - r_hactive) & XVTC_SB_START_MASK);
+    SCPtr->HBackPorchStart = (((RegValue>>16) - r_hactive) & XVTC_SB_START_MASK);
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GVSYNC_OFFSET);
+    SCPtr->V0SyncStart = ((RegValue-r_vactive+1) & XVTC_SB_START_MASK);
+    SCPtr->V0BackPorchStart = (((RegValue>>16) - r_vactive+1) & XVTC_SB_START_MASK);
+
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GVSYNC_F1_OFFSET);
+    SCPtr->V1SyncStart = ((RegValue-r_vactive+1) & XVTC_SB_START_MASK);
+    SCPtr->V1BackPorchStart = (((RegValue>>16) - r_vactive+1) & XVTC_SB_START_MASK);
+
+
+	/* Get signal values from the Generator Vertical 2 Register (field 0)*/
+	RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress, XVTC_GFENC_OFFSET);
+	SCPtr->V0ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+					XVTC_ENC_CPARITY_SHIFT) + (r_vtotal - r_vactive)) & XVTC_SB_START_MASK;
+
+	SCPtr->V1ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+					XVTC_ENC_CPARITY_SHIFT) + (SCPtr->V1Total - r_vactive - 1)) & XVTC_SB_START_MASK;
+
+	SCPtr->Interlaced = (RegValue & XVTC_ENC_PROG_MASK) >> XVTC_ENC_PROG_SHIFT;
+    SCPtr->HFrontPorchStart = 0;
+    SCPtr->V0FrontPorchStart = 0;
+  }
+	else
+	{
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GHSIZE_OFFSET);
+		r_htotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HTotal = (r_htotal) & XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GVSIZE_OFFSET);
+		r_vtotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->V0Total = (r_vtotal) & XVTC_SB_START_MASK;
+		SCPtr->V1Total = (RegValue>>XVTC_SB_END_SHIFT) &
+							XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GASIZE_OFFSET);
+		r_hactive = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HFrontPorchStart = (r_hactive) & XVTC_SB_START_MASK;
+		r_vactive = (RegValue>>XVTC_SB_END_SHIFT) & XVTC_SB_START_MASK;
+		SCPtr->V0FrontPorchStart = (r_vactive) & XVTC_SB_START_MASK;
+		SCPtr->V1FrontPorchStart = SCPtr->V0FrontPorchStart;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GHSYNC_OFFSET);
+		SCPtr->HSyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->HBackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GVSYNC_OFFSET);
+		SCPtr->V0SyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->V0BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GVSYNC_F1_OFFSET);
+		SCPtr->V1SyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->V1BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+		/* Get signal values from the Generator Vertical 2 Register (field 0)*/
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_GFENC_OFFSET);
+		SCPtr->V0ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+				XVTC_ENC_CPARITY_SHIFT)) & XVTC_SB_START_MASK;
+		SCPtr->V1ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+				XVTC_ENC_CPARITY_SHIFT)) & XVTC_SB_START_MASK;
+		SCPtr->Interlaced = (RegValue & XVTC_ENC_PROG_MASK) >> XVTC_ENC_PROG_SHIFT;
+
+		SCPtr->HActiveStart = 0;
+		SCPtr->V0ActiveStart = 0;
+		SCPtr->V1ActiveStart = 0;
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the VTC signal setting used by the Detector module
+* in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	SignalCfgPtr is a pointer to a VTC signal configuration
+*		which will be populated with the setting used by the Detector
+*		module in the VTC core once this function returns.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetDetector(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr)
+{
+	u32 RegValue;
+	u32 r_htotal, r_vtotal, r_hactive, r_vactive;
+	XVtc_Signal *SCPtr;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SignalCfgPtr != NULL);
+
+	SCPtr = SignalCfgPtr;
+
+	if(SCPtr->OriginMode == 0)
+	{
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_DHSIZE_OFFSET);
+		r_htotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HTotal = (r_htotal-1) & XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_DVSIZE_OFFSET);
+		r_vtotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->V0Total = (r_vtotal-1) & XVTC_SB_START_MASK;
+		SCPtr->V1Total = (RegValue>>XVTC_SB_END_SHIFT) &
+							XVTC_SB_START_MASK;
+		if(SCPtr->V1Total != 0) {
+			SCPtr->V1Total = SCPtr->V1Total - 1;
+		}
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DASIZE_OFFSET);
+		r_hactive = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HActiveStart = (r_htotal - r_hactive) &
+						XVTC_SB_START_MASK;
+		r_vactive = (RegValue>>XVTC_SB_END_SHIFT) &
+						XVTC_SB_START_MASK;
+		SCPtr->V0ActiveStart = (r_vtotal - r_vactive) &
+						XVTC_SB_START_MASK;
+		SCPtr->V1ActiveStart = (SCPtr->V1Total - r_vactive - 1) &
+							XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DHSYNC_OFFSET);
+		SCPtr->HSyncStart = ((RegValue - r_hactive) &
+						XVTC_SB_START_MASK);
+		SCPtr->HBackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT) -
+							r_hactive)
+						& XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DVSYNC_OFFSET);
+		SCPtr->V0SyncStart = ((RegValue-r_vactive+1) &
+							XVTC_SB_START_MASK);
+		SCPtr->V0BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT) -
+					r_vactive+1) & XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+						XVTC_GVSYNC_F1_OFFSET);
+		SCPtr->V1SyncStart = ((RegValue-r_vactive+1) &
+						XVTC_SB_START_MASK);
+		SCPtr->V1BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT) -
+								r_vactive+1)
+							& XVTC_SB_START_MASK);
+
+		/* Get signal values from the Generator Vertical 2 Register
+		 * (field 0)
+		 */
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DFENC_OFFSET);
+		SCPtr->V0ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+					XVTC_ENC_CPARITY_SHIFT) +
+				(r_vtotal - r_vactive)) & XVTC_SB_START_MASK;
+
+		SCPtr->V1ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+						XVTC_ENC_CPARITY_SHIFT) +
+			(SCPtr->V1Total - r_vactive - 1)) & XVTC_SB_START_MASK;
+		SCPtr->Interlaced = (RegValue & XVTC_ENC_PROG_MASK) >> XVTC_ENC_PROG_SHIFT;
+
+		SCPtr->HFrontPorchStart = 0;
+		SCPtr->V0FrontPorchStart = 0;
+	}
+	else
+	{
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DHSIZE_OFFSET);
+		r_htotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HTotal = (r_htotal) & XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DVSIZE_OFFSET);
+		r_vtotal = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->V0Total = (r_vtotal) & XVTC_SB_START_MASK;
+		SCPtr->V1Total = (RegValue>>XVTC_SB_END_SHIFT) &
+							XVTC_SB_START_MASK;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DASIZE_OFFSET);
+		r_hactive = (RegValue) & XVTC_SB_START_MASK;
+		SCPtr->HFrontPorchStart = (r_hactive) & XVTC_SB_START_MASK;
+		r_vactive = (RegValue>>XVTC_SB_END_SHIFT) & XVTC_SB_START_MASK;
+		SCPtr->V0FrontPorchStart = (r_vactive) & XVTC_SB_START_MASK;
+		SCPtr->V1FrontPorchStart = SCPtr->V0FrontPorchStart;
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DHSYNC_OFFSET);
+		SCPtr->HSyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->HBackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DVSYNC_OFFSET);
+		SCPtr->V0SyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->V0BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DVSYNC_F1_OFFSET);
+		SCPtr->V1SyncStart = ((RegValue) & XVTC_SB_START_MASK);
+		SCPtr->V1BackPorchStart = (((RegValue>>XVTC_SB_END_SHIFT)) &
+							XVTC_SB_START_MASK);
+
+
+		/* Get signal values from the Generator Vertical 2 Register
+		 * (field 0)
+		 */
+		RegValue = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+							XVTC_DFENC_OFFSET);
+		SCPtr->V0ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+				XVTC_ENC_CPARITY_SHIFT)) & XVTC_SB_START_MASK;
+
+		SCPtr->V1ChromaStart = (((RegValue & XVTC_ENC_CPARITY_MASK) >>
+				XVTC_ENC_CPARITY_SHIFT)) & XVTC_SB_START_MASK;
+		SCPtr->Interlaced = (RegValue & XVTC_ENC_PROG_MASK) >> XVTC_ENC_PROG_SHIFT;
+
+		SCPtr->HActiveStart = 0;
+		SCPtr->V0ActiveStart = 0;
+		SCPtr->V1ActiveStart = 0;
+	}
+
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function facilitates software identification of exact version of the
+* VTC hardware (h/w).
+*
+* @param	InstancePtr is a pointer to the XVtc instance.
+*
+* @return	Version, contents of a Version register.
+*
+* @note		None.
+*
+******************************************************************************/
+u32 XVtc_GetVersion(XVtc *InstancePtr)
+{
+	u32 Version;
+
+	/* Verify argument */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+
+	/* Read Version register */
+	Version = XVtc_ReadReg(InstancePtr->Config.BaseAddress,
+				XVTC_VER_OFFSET);
+
+	return Version;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts the video mode integer into the video timing
+* information stored within the XVtc_Timing pointer.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	Mode is a u16 int defined as macro to one of the predefined
+*		Video Modes.
+* @param	TimingPtr is a pointer to a VTC Video Timing Structure.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_ConvVideoMode2Timing(XVtc *InstancePtr, u16 Mode,
+					XVtc_Timing *TimingPtr)
+{
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(TimingPtr != NULL);
+
+	/* clear timing structure. Set Interlaced to 0 by default */
+	memset((void *)TimingPtr, 0, sizeof(XVtc_Timing));
+
+	switch(Mode)
+	{
+	case XVTC_VMODE_720P: // 720p@60 (1280x720 HD 720)
+	{
+
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1280;
+		TimingPtr->HFrontPorch   = 110;
+		TimingPtr->HSyncWidth    = 40;
+		TimingPtr->HBackPorch    = 220;
+		TimingPtr->HSyncPolarity = 1;
+
+		// Vertical Timing
+		TimingPtr->VActiveVideo  = 720;
+		TimingPtr->V0FrontPorch   = 5;
+		TimingPtr->V0SyncWidth    = 5;
+		TimingPtr->V0BackPorch    = 20;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_1080P: // 1080p@60 (1920x1080 HD 1080)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1920;
+		TimingPtr->HFrontPorch   = 88;
+		TimingPtr->HSyncWidth    = 44;
+		TimingPtr->HBackPorch    = 148;
+		TimingPtr->HSyncPolarity = 1;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 1080;
+		TimingPtr->V0FrontPorch   = 4;
+		TimingPtr->V0SyncWidth    = 5;
+		TimingPtr->V0BackPorch    = 36;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_480P: // 480p@60
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 720;
+		TimingPtr->HFrontPorch   = 16;
+		TimingPtr->HSyncWidth    = 62;
+		TimingPtr->HBackPorch    = 60;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 480;
+		TimingPtr->V0FrontPorch   = 9;
+		TimingPtr->V0SyncWidth    = 6;
+		TimingPtr->V0BackPorch    = 30;
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+	case XVTC_VMODE_576P: // 576p@50
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 720;
+		TimingPtr->HFrontPorch   = 12;
+		TimingPtr->HSyncWidth    = 64;
+		TimingPtr->HBackPorch    = 68;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 576;
+		TimingPtr->V0FrontPorch   = 5;
+		TimingPtr->V0SyncWidth    = 5;
+		TimingPtr->V0BackPorch    = 39;
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+	case XVTC_VMODE_VGA: // 640x480 (VGA)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 656;
+		TimingPtr->HFrontPorch   = 8;
+		TimingPtr->HSyncWidth    = 96;
+		TimingPtr->HBackPorch    = 40;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 496;
+		TimingPtr->V0FrontPorch   = 2;
+		TimingPtr->V0SyncWidth    = 2;
+		TimingPtr->V0BackPorch    = 25;
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+	case XVTC_VMODE_SVGA: // 800x600@60 (SVGA)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 800;
+		TimingPtr->HFrontPorch   = 40;
+		TimingPtr->HSyncWidth    = 128;
+		TimingPtr->HBackPorch    = 88;
+		TimingPtr->HSyncPolarity = 1;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 600;
+		TimingPtr->V0FrontPorch   = 1;
+		TimingPtr->V0SyncWidth    = 4;
+		TimingPtr->V0BackPorch    = 23;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_XGA: // 1024x768@60 (XGA)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1024;
+		TimingPtr->HFrontPorch   = 24;
+		TimingPtr->HSyncWidth    = 136;
+		TimingPtr->HBackPorch    = 160;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 768;
+		TimingPtr->V0FrontPorch   = 3;
+		TimingPtr->V0SyncWidth    = 6;
+		TimingPtr->V0BackPorch    = 29;
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+	case XVTC_VMODE_SXGA: // 1280x1024@60 (SXGA)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1280;
+		TimingPtr->HFrontPorch   = 48;
+		TimingPtr->HSyncWidth    = 112;
+		TimingPtr->HBackPorch    = 248;
+		TimingPtr->HSyncPolarity = 1;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 1024;
+		TimingPtr->V0FrontPorch   = 1;
+		TimingPtr->V0SyncWidth    = 3;
+		TimingPtr->V0BackPorch    = 38;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+
+	case XVTC_VMODE_WXGAPLUS: // 1440x900@60 (WXGA+)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1440;
+		TimingPtr->HFrontPorch   = 80;
+		TimingPtr->HSyncWidth    = 152;
+		TimingPtr->HBackPorch    = 232;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 900;
+		TimingPtr->V0FrontPorch   = 3;
+		TimingPtr->V0SyncWidth    = 6;
+		TimingPtr->V0BackPorch    = 25;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_WSXGAPLUS: // 1680x1050@60 (WSXGA+)
+	{
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1680;
+		TimingPtr->HFrontPorch   = 104;
+		TimingPtr->HSyncWidth    = 176;
+		TimingPtr->HBackPorch    = 280;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 1050;
+		TimingPtr->V0FrontPorch   = 3;
+		TimingPtr->V0SyncWidth    = 6;
+		TimingPtr->V0BackPorch    = 30;
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_1080I: // 1080i@60
+	{
+		TimingPtr->Interlaced = 1;
+
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 1920;
+		TimingPtr->HFrontPorch   = 88;
+		TimingPtr->HSyncWidth    = 44;
+		TimingPtr->HBackPorch    = 148;
+		TimingPtr->HSyncPolarity = 1;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 540;
+		TimingPtr->V0FrontPorch   = 2;
+		TimingPtr->V0SyncWidth    = 5;
+		TimingPtr->V0BackPorch    = 15;
+
+		TimingPtr->V1FrontPorch   = 2;
+		TimingPtr->V1SyncWidth    = 5;
+		TimingPtr->V1BackPorch    = 16;
+
+		TimingPtr->VSyncPolarity = 1;
+
+		break;
+	}
+	case XVTC_VMODE_NTSC: //480i@60
+	{
+		TimingPtr->Interlaced = 1;
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 720;
+		TimingPtr->HFrontPorch   = 19;
+		TimingPtr->HSyncWidth    = 62;
+		TimingPtr->HBackPorch    = 57;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 240;
+		TimingPtr->V0FrontPorch   = 4;
+		TimingPtr->V0SyncWidth    = 3;
+		TimingPtr->V0BackPorch    = 15;
+
+		TimingPtr->V1FrontPorch   = 4;
+		TimingPtr->V1SyncWidth    = 3;
+		TimingPtr->V1BackPorch    = 16;
+
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+	case XVTC_VMODE_PAL: //576i@50
+	{
+		TimingPtr->Interlaced = 1;
+		// Horizontal Timing
+		TimingPtr->HActiveVideo  = 720;
+		TimingPtr->HFrontPorch   = 12;
+		TimingPtr->HSyncWidth    = 63;
+		TimingPtr->HBackPorch    = 69;
+		TimingPtr->HSyncPolarity = 0;
+
+		 // Vertical Timing
+		TimingPtr->VActiveVideo  = 288;
+		TimingPtr->V0FrontPorch   = 2;
+		TimingPtr->V0SyncWidth    = 3;
+		TimingPtr->V0BackPorch    = 19;
+
+		TimingPtr->V1FrontPorch   = 2;
+		TimingPtr->V1SyncWidth    = 3;
+		TimingPtr->V1BackPorch    = 20;
+
+		TimingPtr->VSyncPolarity = 0;
+
+		break;
+	}
+
+	// add other video formats here
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts the video timing structure into the VTC signal
+* configuration structure, horizontal offsets structure and the
+* polarity structure.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	TimingPtr is a pointer to a Video Timing structure to be read.
+* @param	SignalCfgPtr is a pointer to a VTC signal configuration to be
+*		set.
+* @param	HOffPtr is a pointer to a VTC horizontal offsets structure to
+*		be set.
+* @param	PolarityPtr is a pointer to a VTC polarity structure to be set.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_ConvTiming2Signal(XVtc *InstancePtr, XVtc_Timing *TimingPtr,
+			XVtc_Signal *SignalCfgPtr, XVtc_HoriOffsets *HOffPtr,
+			XVtc_Polarity *PolarityPtr)
+{
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(TimingPtr != NULL);
+	Xil_AssertVoid(SignalCfgPtr != NULL);
+	Xil_AssertVoid(HOffPtr != NULL);
+	Xil_AssertVoid(PolarityPtr != NULL);
+
+
+	/* Setting up VTC Polarity.  */
+	memset((void *)PolarityPtr, 0, sizeof(XVtc_Polarity));
+	PolarityPtr->ActiveChromaPol = 1;
+	PolarityPtr->ActiveVideoPol  = 1;
+	PolarityPtr->FieldIdPol      = 1;
+	/* Vblank matches Vsync Polarity */
+	PolarityPtr->VBlankPol       = TimingPtr->VSyncPolarity;
+	PolarityPtr->VSyncPol        = TimingPtr->VSyncPolarity;
+	/* hblank matches hsync Polarity */
+	PolarityPtr->HBlankPol       = TimingPtr->HSyncPolarity;
+	PolarityPtr->HSyncPol        = TimingPtr->HSyncPolarity;
+
+
+	memset((void *)SignalCfgPtr, 0, sizeof(XVtc_Signal));
+	memset((void *)HOffPtr, 0, sizeof(XVtc_HoriOffsets));
+
+	/* Populate the VTC Signal config structure. */
+	/* Active Video starts at 0 */
+	SignalCfgPtr->OriginMode = 1;
+	SignalCfgPtr->HActiveStart      = 0;
+	SignalCfgPtr->HFrontPorchStart  = TimingPtr->HActiveVideo;
+	SignalCfgPtr->HSyncStart        = SignalCfgPtr->HFrontPorchStart +
+							TimingPtr->HFrontPorch;
+	SignalCfgPtr->HBackPorchStart   = SignalCfgPtr->HSyncStart +
+							TimingPtr->HSyncWidth;
+	SignalCfgPtr->HTotal            = SignalCfgPtr->HBackPorchStart +
+							TimingPtr->HBackPorch;
+
+	SignalCfgPtr->V0ChromaStart     = 0;
+	SignalCfgPtr->V0ActiveStart     = 0;
+	SignalCfgPtr->V0FrontPorchStart = TimingPtr->VActiveVideo;
+	SignalCfgPtr->V0SyncStart       = SignalCfgPtr->V0FrontPorchStart +
+						TimingPtr->V0FrontPorch - 1;
+	SignalCfgPtr->V0BackPorchStart  = SignalCfgPtr->V0SyncStart +
+						TimingPtr->V0SyncWidth;
+	SignalCfgPtr->V0Total           = SignalCfgPtr->V0BackPorchStart +
+						TimingPtr->V0BackPorch + 1;
+
+	HOffPtr->V0BlankHoriStart = SignalCfgPtr->HFrontPorchStart;
+	HOffPtr->V0BlankHoriEnd   = SignalCfgPtr->HFrontPorchStart;
+	HOffPtr->V0SyncHoriStart  = SignalCfgPtr->HSyncStart;
+	HOffPtr->V0SyncHoriEnd    = SignalCfgPtr->HSyncStart;
+
+	if(TimingPtr->Interlaced == 1) {
+		SignalCfgPtr->V1ChromaStart     = 0;
+		SignalCfgPtr->V1ActiveStart     = 0;
+		SignalCfgPtr->V1FrontPorchStart = TimingPtr->VActiveVideo;
+		SignalCfgPtr->V1SyncStart       =
+					SignalCfgPtr->V1FrontPorchStart +
+					TimingPtr->V1FrontPorch - 1;
+		SignalCfgPtr->V1BackPorchStart  =
+						SignalCfgPtr->V1SyncStart +
+							TimingPtr->V1SyncWidth;
+		SignalCfgPtr->V1Total           =
+					SignalCfgPtr->V1BackPorchStart +
+						TimingPtr->V1BackPorch + 1;
+		SignalCfgPtr->Interlaced 		= 1;
+
+		/* Align to H blank */
+		HOffPtr->V1BlankHoriStart = SignalCfgPtr->HFrontPorchStart;
+		/* Align to H Blank */
+		HOffPtr->V1BlankHoriEnd   = SignalCfgPtr->HFrontPorchStart;
+
+		/* Align to half line */
+		HOffPtr->V1SyncHoriStart  = SignalCfgPtr->HSyncStart -
+						(SignalCfgPtr->HTotal / 2);
+		HOffPtr->V1SyncHoriEnd    = SignalCfgPtr->HSyncStart -
+						(SignalCfgPtr->HTotal / 2);
+	}
+	/* Progressive formats */
+	else {
+	/* Set Field 1 same as Field 0 */
+		SignalCfgPtr->V1ChromaStart     = SignalCfgPtr->V0ChromaStart;
+		SignalCfgPtr->V1ActiveStart     = SignalCfgPtr->V0ActiveStart;
+		SignalCfgPtr->V1FrontPorchStart =
+					SignalCfgPtr->V0FrontPorchStart;
+		SignalCfgPtr->V1SyncStart       = SignalCfgPtr->V0SyncStart;
+		SignalCfgPtr->V1BackPorchStart  =
+					SignalCfgPtr->V0BackPorchStart;
+		SignalCfgPtr->V1Total           = SignalCfgPtr->V0Total;
+		SignalCfgPtr->Interlaced		= 0;
+
+		HOffPtr->V1BlankHoriStart = HOffPtr->V0BlankHoriStart;
+		HOffPtr->V1BlankHoriEnd   = HOffPtr->V0BlankHoriEnd;
+		HOffPtr->V1SyncHoriStart  = HOffPtr->V0SyncHoriStart;
+		HOffPtr->V1SyncHoriEnd    = HOffPtr->V0SyncHoriEnd;
+	}
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts the VTC signal structure, horizontal offsets
+* structure and the polarity structure into the Video Timing structure.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	SignalCfgPtr is a pointer to a VTC signal configuration to
+*		be read
+* @param	HOffPtr is a pointer to a VTC horizontal offsets structure
+*		to be read
+* @param	PolarityPtr is a pointer to a VTC polarity structure to be
+*		read.
+* @param	TimingPtr is a pointer to a Video Timing structure to be set.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_ConvSignal2Timing(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr,
+				XVtc_HoriOffsets *HOffPtr,
+				XVtc_Polarity *PolarityPtr,
+				XVtc_Timing *TimingPtr)
+{
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(SignalCfgPtr != NULL);
+	Xil_AssertVoid(HOffPtr != NULL);
+	Xil_AssertVoid(PolarityPtr != NULL);
+	Xil_AssertVoid(TimingPtr != NULL);
+	Xil_AssertVoid(SignalCfgPtr->OriginMode == 1);
+
+	memset((void *)TimingPtr, 0, sizeof(XVtc_Timing));
+
+	/* Set Polarity */
+	TimingPtr->VSyncPolarity = PolarityPtr->VSyncPol;
+	TimingPtr->HSyncPolarity = PolarityPtr->HSyncPol;
+
+	/* Horizontal Timing */
+	TimingPtr->HActiveVideo = SignalCfgPtr->HFrontPorchStart;
+
+
+	TimingPtr->HFrontPorch  = SignalCfgPtr->HSyncStart -
+					SignalCfgPtr->HFrontPorchStart;
+	TimingPtr->HSyncWidth   = SignalCfgPtr->HBackPorchStart -
+				        SignalCfgPtr->HSyncStart;
+	TimingPtr->HBackPorch   = SignalCfgPtr->HTotal -
+					SignalCfgPtr->HBackPorchStart;
+
+	/* Vertical Timing */
+	TimingPtr->VActiveVideo  = SignalCfgPtr->V0FrontPorchStart;
+
+
+	TimingPtr->V0FrontPorch  = SignalCfgPtr->V0SyncStart -
+					  SignalCfgPtr->V0FrontPorchStart + 1;
+	TimingPtr->V0SyncWidth   = SignalCfgPtr->V0BackPorchStart -
+						SignalCfgPtr->V0SyncStart + 1;
+	TimingPtr->V0BackPorch   = SignalCfgPtr->V0Total -
+					SignalCfgPtr->V0BackPorchStart;
+
+	TimingPtr->V1FrontPorch  = SignalCfgPtr->V1SyncStart -
+					SignalCfgPtr->V1FrontPorchStart + 1;
+	TimingPtr->V1SyncWidth   = SignalCfgPtr->V1BackPorchStart -
+						SignalCfgPtr->V1SyncStart + 1;
+	TimingPtr->V1BackPorch   = SignalCfgPtr->V1Total -
+					SignalCfgPtr->V1BackPorchStart;
+
+	/* Interlaced */
+	TimingPtr->Interlaced  = SignalCfgPtr->Interlaced;
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts the video timing structure into predefined video
+* mode values returned as a short integer.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	TimingPtr is a pointer to a Video Timing structure to be read.
+*
+* @return	VideoMode is the video mode of the VTC core.
+*
+* @note		None.
+*
+******************************************************************************/
+u16 XVtc_ConvTiming2VideoMode(XVtc *InstancePtr, XVtc_Timing *TimingPtr)
+{
+	/* Verify arguments. */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertNonvoid(TimingPtr != NULL);
+
+	/* Checking for Interlaced value */
+	if(TimingPtr->Interlaced == 0) {
+		if(TimingPtr->HActiveVideo == 1280) {
+			if (TimingPtr->VActiveVideo == 720) {
+				return XVTC_VMODE_720P;
+			}
+			else if (TimingPtr->VActiveVideo == 1024) {
+				return XVTC_VMODE_SXGA;
+			}
+
+		}
+		else if((TimingPtr->HActiveVideo == 1920) &&
+				(TimingPtr->VActiveVideo == 1080)) {
+			return XVTC_VMODE_1080P;
+		}
+		else if(TimingPtr->HActiveVideo == 720) {
+			if (TimingPtr->VActiveVideo == 480) {
+				return XVTC_VMODE_480P;
+			}
+			else if (TimingPtr->VActiveVideo == 576) {
+				return XVTC_VMODE_576P;
+			}
+		}
+		else if((TimingPtr->HActiveVideo == 656) &&
+				(TimingPtr->VActiveVideo == 496)) {
+			return XVTC_VMODE_VGA;
+		}
+		else if((TimingPtr->HActiveVideo == 800) &&
+				(TimingPtr->VActiveVideo == 600)) {
+			return XVTC_VMODE_SVGA;
+		}
+		else if((TimingPtr->HActiveVideo == 1024) &&
+			(TimingPtr->VActiveVideo == 768)) {
+			return XVTC_VMODE_XGA;
+		}
+		else if((TimingPtr->HActiveVideo == 1440) &&
+				(TimingPtr->VActiveVideo == 900)) {
+			return XVTC_VMODE_WXGAPLUS;
+		}
+		else if((TimingPtr->HActiveVideo == 1680) &&
+				(TimingPtr->VActiveVideo == 1050)) {
+			return XVTC_VMODE_WSXGAPLUS;
+		}
+
+	}
+	/* Interlaced */
+	else {
+		if((TimingPtr->HActiveVideo == 720) &&
+			(TimingPtr->VActiveVideo == 240)) {
+			return XVTC_VMODE_NTSC;
+		}
+		else if((TimingPtr->HActiveVideo == 1920) &&
+			(TimingPtr->VActiveVideo == 540)) {
+			return XVTC_VMODE_1080I;
+		}
+		else if((TimingPtr->HActiveVideo == 720) &&
+				(TimingPtr->VActiveVideo == 288)) {
+			return XVTC_VMODE_PAL;
+		}
+
+	}
+
+	/* Not found - read from Timing to discover format */
+	return 0;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the generator (Polarity, H/V values and horizontal
+* offsets) by reading the configuration from a video timing structure.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	TimingPtr is a pointer to a Video Timing Structure to be read.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetGeneratorTiming(XVtc *InstancePtr, XVtc_Timing * TimingPtr)
+{
+	XVtc_Polarity Polarity;
+	XVtc_Signal Signal;
+	XVtc_HoriOffsets Hoff;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(TimingPtr != NULL);
+
+	XVtc_ConvTiming2Signal(InstancePtr, TimingPtr, &Signal, &Hoff,
+				&Polarity);
+	XVtc_SetPolarity(InstancePtr, &Polarity);
+	XVtc_SetGenerator(InstancePtr, &Signal);
+	XVtc_SetGeneratorHoriOffset(InstancePtr, &Hoff);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets up the generator (Polarity, H/V values and horizontal
+* offsets) by reading the configuration from a video mode short integer.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	Mode is a short integer predefined video mode.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_SetGeneratorVideoMode(XVtc *InstancePtr, u16 Mode)
+{
+	XVtc_Timing Timing;
+
+	/* Verify arguments */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	XVtc_ConvVideoMode2Timing(InstancePtr, Mode, &Timing);
+
+	XVtc_SetGeneratorTiming(InstancePtr, &Timing);
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the video timing structure settings currently used by
+* generator in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	TimingPtr is a pointer to a Video Timing Structure to be set.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetGeneratorTiming(XVtc *InstancePtr, XVtc_Timing *TimingPtr)
+{
+
+	XVtc_Polarity Polarity;
+	XVtc_Signal Signal;
+	XVtc_HoriOffsets Hoff;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(TimingPtr != NULL);
+
+
+	Signal.OriginMode = 1;
+	XVtc_GetPolarity(InstancePtr, &Polarity);
+	XVtc_GetGeneratorHoriOffset(InstancePtr, &Hoff);
+	XVtc_GetGenerator(InstancePtr, &Signal);
+
+	XVtc_ConvSignal2Timing(InstancePtr, &Signal, &Hoff, &Polarity,
+					TimingPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the video mode currently used by the generator
+* in the VTC core. If the video mode is unknown or not recognized, then 0
+* will be returned.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	VideoMode is the video mode of the VTC core.
+*
+* @note		Note.
+*
+******************************************************************************/
+u16 XVtc_GetGeneratorVideoMode(XVtc *InstancePtr)
+{
+
+	u16 mode;
+	XVtc_Timing Timing;
+
+	/* Verify arguments */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	XVtc_GetGeneratorTiming(InstancePtr, &Timing);
+	mode = XVtc_ConvTiming2VideoMode(InstancePtr, &Timing);
+
+	return mode;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the video timing structure settings currently reported by
+* the detector in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+* @param	TimingPtr is a pointer to a Video Timing structure to be set.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_GetDetectorTiming(XVtc *InstancePtr, XVtc_Timing *TimingPtr)
+{
+	XVtc_Polarity Polarity;
+	XVtc_Signal Signal;
+	XVtc_HoriOffsets Hoff;
+
+	/* Verify arguments */
+	Xil_AssertVoid(InstancePtr != NULL);
+	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+	Xil_AssertVoid(TimingPtr != NULL);
+
+
+	Signal.OriginMode = 1;
+	XVtc_GetDetector(InstancePtr, &Signal);
+	XVtc_GetDetectorPolarity(InstancePtr, &Polarity);
+	XVtc_GetDetectorHoriOffset(InstancePtr, &Hoff);
+
+	XVtc_ConvSignal2Timing(InstancePtr, &Signal, &Hoff, &Polarity,
+					TimingPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the video mode currently reported by the detector
+* in the VTC core. If the video mode is unknown or not recognized, then 0
+* will be returned.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return 	VideoMode is the video mode of the VTC core.
+*
+* @note		None.
+*
+******************************************************************************/
+u16 XVtc_GetDetectorVideoMode(XVtc *InstancePtr)
+{
+	u16 mode;
+	XVtc_Timing Timing;
+
+	/* Verify arguments */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+
+	XVtc_GetDetectorTiming(InstancePtr, &Timing);
+	mode = XVtc_ConvTiming2VideoMode(InstancePtr, &Timing);
+
+	return mode;
+}
+
+/*****************************************************************************/
+/**
+*
+* This routine is a stub for the asynchronous callbacks. The stub is here in
+* case the upper layer forgot to set the handlers. On initialization, all
+* handlers except error handler are set to this callback. It is considered an
+* error for this handler to be invoked.
+*
+* @param	CallBackRef is a callback reference passed in by the upper
+*		layer when setting the callback functions, and passed back
+*		to the upper layer when the callback is invoked.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+static void StubCallBack(void *CallBackRef)
+{
+	(void)CallBackRef;
+	Xil_AssertVoidAlways();
+}
+
+/*****************************************************************************/
+/**
+*
+* This routine is a stub for the asynchronous error interrupt callback. The
+* stub is here in case the upper layer forgot to set the handler. On
+* initialization, Error interrupt handler is set to this callback. It is
+* considered an error for this handler to be invoked.
+*
+* @param	CallBackRef is a callback reference passed in by the upper
+*		layer when setting the callback functions, and passed back to
+*		the upper layer when the callback is invoked.
+* @param 	ErrorMask is a bit mask indicating the cause of the error. Its
+*		value equals 'OR'ing one or more XVTC_IXR_*_MASK values defined
+*		in xvtc_hw.h.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+static void StubErrCallBack(void *CallBackRef, u32 ErrorMask)
+{
+	(void)CallBackRef;
+	(void)ErrorMask;
+	Xil_AssertVoidAlways();
+}
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.h
new file mode 100644
index 0000000..08e12f0
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc.h
@@ -0,0 +1,948 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xvtc.h
+* @addtogroup vtc_v7_2
+* @{
+* @details
+*
+* This is the main header file of Xilinx MVI Video Timing Controller (VTC)
+* device driver. The VTC device detects video signals, independently
+* overrides any one of them, re-generates video signals with +/- delay and
+* with polarity inversion, and generates up to 16 one cycle Frame Sync outputs.
+*
+* The device has the following main features:
+* - Detect video signals:
+*	- horizontal sync
+*	- horizontal blank
+*	- vertical sync
+*	- vertical blank
+*	- active video
+*	- field id
+* - Independently override any one signal.
+* - Re-generate video signals with +/- delay and with polarity inversion.
+* - Generate up to 16 one cycle Frame Sync outputs.
+*
+* For a full description of VTC features, please see the hardware
+* specification.
+*
+* <b>Software Initialization & Configuration</b>
+*
+* The application needs to do following steps in order for preparing the
+* VTC to be ready to process video signal handling.
+*
+* - Call XVtc_LookupConfig using a device ID to find the core
+*   configuration.
+* - Call XVtc_CfgInitialize to initialize the device and the driver
+*   instance associated with it.
+* - Call XVtc_SetGenerator to set up the video signals to generate,
+*   if desired.
+* - Call XVtc_SetPolarity to set up the video signal polarity.
+* - Call XVtc_SetSource for source selection
+* - Call XVtc_SetGeneratorHoriOffset to set up the Generator
+*   VBlank/VSync horizontal offsets, if values other than the default are
+*   needed
+* - Call XVtc_EnableSync, if generator needs to be synced to the detector
+* - Call XVtc_Enable to enable/start the VTC device.
+*
+* <b>Interrupts </b>
+*
+* The interrupt types supported are:
+* - Frame Sync Interrupts 0 - 15
+* - Generator interrupt:
+*	- Generator Active Video Interrupt
+*	- Generator VBLANK Interrupt
+* - Detector interrupt:
+*	- Detector Active Video Interrupt
+*	- Detector VBLANK Interrupt
+* - Signal Lock interrupt:
+*	- Active Chroma signal lock
+*	- Active Video Signal Lock
+*	- Field ID Signal Lock
+*	- Vertical Blank Signal Lock
+*	- Vertical Sync Signal Lock
+*	- Horizontal Blank Signal Lock
+*	- Horizontal Sync Signal Lock
+*
+* <b> Virtual Memory </b>
+*
+* This driver supports Virtual Memory. The RTOS is responsible for calculating
+* the correct device base address in Virtual Memory space.
+*
+* <b> Threads </b>
+*
+* This driver is not thread safe. Any needs for threads or thread mutual
+* exclusion must be satisfied by the layer above this driver.
+*
+* <b> Asserts </b>
+*
+* Asserts are used within all Xilinx drivers to enforce constraints on argument
+* values. Asserts can be turned off on a system-wide basis by defining, at
+* compile time, the NDEBUG identifier. By default, asserts are turned on and it
+* is recommended that users leave asserts on during development.
+*
+* <b> Building the driver </b>
+*
+* The Vtc driver is composed of several source files. This allows the user
+* to build and link only those parts of the driver that are necessary.
+*
+* <b> Examples </b>
+*
+* An example is provided with this driver to demonstrate the driver usage.
+*
+* <b>Cache Coherency</b>
+*
+* <b>Alignment</b>
+*
+* <b>Limitations</b>
+*
+* <b>BUS Interface</b>
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- -----------------------------------------------
+* 1.00a xd     08/05/08 First release
+* 1.01a xd     07/23/10 Added GIER Added more h/w generic info into
+*                       xparameters.h Feed callbacks with pending
+*                       interrupt info. Added Doxygen & Version support
+* 2.00a xd     05/13/11 1. Renamed to "Video Timing Controller"
+*                       2. Added Generator/Detector VBlank/VSync
+*                          Horizontal offset setup/fetch support
+*                       3. Renamed the IP to support to be axi_vtc
+*                       4. Supported sync between generator and detector
+*                          with addition of new XVtc_EnableSync and
+*                          XVtc_DisableSync functions
+*                       5. Renamed XVtc_SetSync to XVtc_SetFSync
+*                       6. Renamed XVtc_GetSync to XVtc_GetFSync
+*                       7. Removed unnecessary register write in
+*                          XVtc_Reset
+*                       8. Corrected driver name in .mdd file
+*                       9. Updated register bit definition (a few fields grow
+*                          from 12 to 13 bit wide)
+* 2.00a cm     05/25/11 1. Renamed XVtc_SetSkip to XVtc_SetSkipLine
+*                       2. Renamed XVtc_GetSkip to XVtc_GetSkipLine
+*                       3. Added XVtc_SetSkipPixel
+*                       4. Added XVtc_GetSkipPixel
+* 2.00a cm     06/16/12 1. Added missing xil_assert.h include
+* 2.00a cm     07/25/12 1. Removed unused XVtc_IntrSetLockPolarity function
+* 3.00a cm     08/02/12 1. Added the XVtc_Sync_Reset frame sync'ed SW
+*                       reset function.
+* 3.00a cjm    08/02/12 Converted from xio.h to xil_io.h, translating
+*                       basic types, MB cache functions, exceptions and
+*                       assertions to xil_io format.
+*                       Replaced the following
+*                       "XExc_Init" -> "Xil_ExceptionInit"
+*                       "XExc_RegisterHandler" -> "Xil_ExceptionRegister
+*                                                                 Handler"
+*                       "XEXC_ID_NON_CRITICAL_INT" -> "XIL_EXCEPTION_ID_INT"
+*                       "XExceptionHandler" -> "Xil_ExceptionHandler"
+*                       "XExc_mEnableExceptions" -> "Xil_ExceptionEnable"
+*                       "XEXC_NON_CRITICAL" -> "XIL_EXCEPTION_NON_CRITICAL"
+*                       "XExc_DisableExceptions" -> "Xil_ExceptionDisable"
+*                       "XExc_RemoveHandler" -> "Xil_ExceptionRemoveHandler"
+*                       "microblaze_enable_interrupts" -> "Xil_ExceptionEnable"
+*                       "microblaze_disable_interrupts" -> "Xil_Exception
+*                                                               Disable"
+*
+*                       "XCOMPONENT_IS_STARTED" -> "XIL_COMPONENT_IS_STARTED"
+*                       "XCOMPONENT_IS_READY" -> "XIL_COMPONENT_IS_READY"
+*
+*                       "XASSERT_NONVOID" -> "Xil_AssertNonvoid"
+*                       "XASSERT_VOID_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XASSERT_VOID" -> "Xil_AssertVoid"
+*                       "Xil_AssertVoid_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XAssertStatus" -> "Xil_AssertStatus"
+*                       "XAssertSetCallback" -> "Xil_AssertCallback"
+*
+*                       "XASSERT_OCCURRED" -> "XIL_ASSERT_OCCURRED"
+*                       "XASSERT_NONE" -> "XIL_ASSERT_NONE"
+*
+*                       "microblaze_disable_dcache" -> "Xil_DCacheDisable"
+*                       "microblaze_enable_dcache" -> "Xil_DCacheEnable"
+*                       "microblaze_enable_icache" -> "Xil_ICacheEnable"
+*                       "microblaze_disable_icache" -> "Xil_ICacheDisable"
+*                       "microblaze_init_dcache_range" -> "Xil_DCacheInvalidate
+*                                                                       Range"
+*
+*                       "XCache_DisableDCache" -> "Xil_DCacheDisable"
+*                       "XCache_DisableICache" -> "Xil_ICacheDisable"
+*                       "XCache_EnableDCache" -> "Xil_DCacheEnableRegion"
+*                       "XCache_EnableICache" -> "Xil_ICacheEnableRegion"
+*                       "XCache_InvalidateDCacheLine" -> "Xil_DCacheInvalidate
+*                                                                       Range"
+*
+*                       "XUtil_MemoryTest32" -> "Xil_TestMem32"
+*                       "XUtil_MemoryTest16" -> "Xil_TestMem16"
+*                       "XUtil_MemoryTest8" -> "Xil_TestMem8"
+*
+*                       "xutil.h" -> "xil_testmem.h"
+*
+*                       "xbasic_types.h" -> "xil_types.h"
+*                       "xio.h" -> "xil_io.h"
+*
+*                       "XIo_In32" -> "Xil_In32"
+*                       "XIo_Out32" -> "Xil_Out32"
+*
+*                       "XTRUE" -> "TRUE"
+*                       "XFALSE" -> "FALSE"
+*                       "XNULL" -> "NULL"
+*
+*                       "Xuint8" -> "u8"
+*                       "Xuint16" -> "u16"
+*                       "Xuint32" -> "u32"
+*                       "Xint8" -> "char"
+*                       "Xint16" -> "short"
+*                       "Xint32" -> "long"
+*                       "Xfloat32" -> "float"
+*                       "Xfloat64" -> "double"
+*                       "Xboolean" -> "int"
+*                       "XTEST_FAILED" -> "XST_FAILURE"
+*                       "XTEST_PASSED" -> "XST_SUCCESS"
+* 4.00a cjm    02/07/13 Removed Unused Functions
+*                       XVtc_IntrEnableGlobal
+*                       XVtc_IntrDisableGlobal
+* 5.00a cjm    08/07/13 Replaced XVTC_RESET with (XVTC_CTL)
+*                       Replaced XVTC_RESET_RESET_MASK with
+*                       (XVTC_CTL_RESET_MASK)
+*                       Replaced XVTC_SYNC_RESET_MASK with (XVTC_CTL_SRST_MASK)
+* 5.00a cjm    10/30/13 Replaced XVtc_RegUpdate with XVtc_RegUpdateEnable
+*                       Added XVtc_RegUpdateDisable
+*                       Removed type parameter from XVtc_Enable
+*                       Added XVtc_EnableGenerator to enable only the Generator
+*                       Added XVtc_EnableDetector to enable only the Detector
+* 5.00a cjm    11/01/13 Added Timing, VideoMode and Signal Conversion
+*                       Functions:
+*                       XVtc_ConvVideoMode2Timing
+*                       XVtc_ConvTiming2Signal
+*                       XVtc_ConvSignal2Timing
+*                       XVtc_ConvTiming2VideoMode
+*                       Added Timing and Video Mode Set/Get Functions:
+*                       XVtc_SetGeneratorTiming
+*                       XVtc_SetGeneratorVideoMode
+*                       XVtc_GetGeneratorTiming
+*                       XVtc_GetGeneratorVideoMode
+*                       XVtc_GetDetectorTiming
+*                       XVtc_GetDetectorVideoMode
+* 6.0   adk    19/12/13 Updated as per the New Tcl API's.
+* 6.1   adk    23/08/14 Implemented XVtc_SelfTest in
+*                       xvtc_selftest.c.
+*                       Modified prototype of XVtc_GetVersion API.
+* 7.0   vns    02/25/15 Added Interlaced field to XVtc_Signal structure,
+*                       Removed XVtc_RegUpdate as there are is one more API,
+*                       XVtc_RegUpdateEnable with same functionality but
+*                       provided backward compatability.
+*
+*                       Modifications from xvtc.c file are:
+*                       Modified HActiveVideo value to 1920 for
+*                       XVTC_VMODE_1080I mode.
+*                       Removed Major, Minor and Revision parameters from
+*                       XVtc_GetVersion.
+*                       Modified return type of XVtc_GetVersion from
+*                       void to u32.
+*                       Added progressive and interlaced mode switching feature.
+*                       Modified XVtc_SetGenerator, XVtc_GetGenerator,
+*                       XVtc_GetDetector, XVtc_ConvTiming2Signal and
+*                       XVtc_ConvSignal2Timing APIs
+*
+*                       Modifications from xvtc_hw.h file are:
+*                       Removed XVTC_ERR_FIL_MASK macro because it is  not
+*                       present in latest product guide.
+*                       Modified register offsets from XVTC_* to XVTC_*_OFFSET
+*                       for consistency.
+*                       Added backward compatibility macros.
+*
+*                       Modifications from xvtc_intr.c and xvtc_sinit.c files
+*                       are:
+*                       updated doxygen tags.
+*
+*                       Modifications from xvtc_selftest.c file are:
+*                       First Release.
+*                       Implemented following function:
+*                       XVtc_SelfTest.
+* 7.1   vns    10/14/15 Added InterlacedMode feild to XVtc_SourceSelect
+*                       structure
+* 7.2   sk     08/16/16 Used UINTPTR instead of u32 for Baseaddress as part of
+*                       adding 64 bit support. CR# 867425.
+*                       Changed the prototype of XVtc_CfgInitialize API.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XVTC_H_
+#define XVTC_H_		/**< Prevent circular inclusions
+			  * by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xvtc_hw.h"
+#include "xil_assert.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+/** @name Interrupt Types for setting up Callbacks
+* @{
+*/
+#define XVTC_HANDLER_FRAMESYNC	1	/**< A frame sync event
+					  * interrupt type */
+#define XVTC_HANDLER_LOCK	2	/**< A signal lock event
+					  *  interrupt type */
+#define XVTC_HANDLER_DETECTOR	3	/**< A detector event
+					  *  interrupt type */
+#define XVTC_HANDLER_GENERATOR	4	/**< A generator event
+					  *  interrupt type */
+#define XVTC_HANDLER_ERROR	5	/**< An error condition
+					  *  interrupt type */
+/*@}*/
+
+/** @name Options for enabling VTC modules
+ *  @{
+ */
+#define XVTC_EN_GENERATOR	1	/**< To enable generator */
+#define XVTC_EN_DETECTOR	2	/**< To enable detector */
+/*@}*/
+
+/** @name Address gap between two register next to each other
+ *  @{
+ */
+#define XVTC_REG_ADDRGAP	4	/**< Register address gap */
+
+
+#define XVTC_VMODE_720P		1	/**< Video mode 720P */
+#define XVTC_VMODE_1080P	2	/**< Video mode 1080P */
+#define XVTC_VMODE_480P		3	/**< Video mode 480P */
+#define XVTC_VMODE_576P		4	/**< Video mode 576P */
+#define XVTC_VMODE_VGA		5	/**< Video mode VGA */
+#define XVTC_VMODE_SVGA		6	/**< Video mode SVGA */
+#define XVTC_VMODE_XGA		7	/**< Video mode XGA */
+#define XVTC_VMODE_SXGA		8	/**< Video mode SXGA */
+#define XVTC_VMODE_WXGAPLUS	9	/**< Video mode WXGAPlus */
+#define XVTC_VMODE_WSXGAPLUS	10	/**< Video mode WSXGAPlus */
+#define XVTC_VMODE_1080I	100	/**< Video mode 1080I */
+#define XVTC_VMODE_NTSC		101	/**< Video mode NTSC */
+#define XVTC_VMODE_PAL		102	/**< Video mode PAL */
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * This typedef contains configuration information for a VTC core.
+ * Each VTC device should have a configuration structure associated
+ */
+typedef struct {
+	u16 DeviceId;		/**< DeviceId is the unique ID of the VTC
+				  *  core */
+	UINTPTR BaseAddress;	/**< BaseAddress is the physical base address
+				  *  of the core's registers */
+} XVtc_Config;
+
+/**
+ * This typedef contains Polarity configuration information for a VTC core.
+ */
+typedef struct {
+	u8 ActiveChromaPol;	/**< Active Chroma Output Polarity */
+	u8 ActiveVideoPol;	/**< Active Video Output Polarity */
+	u8 FieldIdPol;		/**< Field ID Output Polarity */
+	u8 VBlankPol;		/**< Vertical Blank Output Polarity */
+	u8 VSyncPol;		/**< Vertical Sync Output Polarity */
+	u8 HBlankPol;		/**< Horizontal Blank Output
+				  *  Polarity */
+	u8 HSyncPol;		/**< Horizontal Sync Output Polarity */
+} XVtc_Polarity;
+
+/**
+ * This typedef contains Source Selection configuration information for a
+ * VTC core.
+ */
+typedef struct {
+	u8 FieldIdPolSrc;	/**< Field ID Output Polarity Source */
+	u8 ActiveChromaPolSrc;	/**< Active Chroma Output Polarity Source */
+	u8 ActiveVideoPolSrc;	/**< Active Video Output Polarity Source */
+	u8 HSyncPolSrc;		/**< Horizontal Sync Output Polarity Source */
+	u8 VSyncPolSrc;		/**< Vertical Sync Output Polarity Source */
+	u8 HBlankPolSrc;	/**< Horizontal Blank Output Polarity Source */
+	u8 VBlankPolSrc;	/**< Vertical Blank Output Polarity Source */
+
+	u8 VChromaSrc;		/**< Start of Active Chroma Register
+				  *  Source Select */
+	u8 VActiveSrc;		/**< Vertical Active Video Start Register
+				  *  Source Select */
+	u8 VBackPorchSrc;	/**< Vertical Back Porch Start Register
+				  *  Source Select */
+	u8 VSyncSrc;		/**< Vertical Sync Start Register Source
+				  *  Select */
+	u8 VFrontPorchSrc;	/**< Vertical Front Porch Start Register Source
+				  *  Select */
+	u8 VTotalSrc;		/**< Vertical Total Register Source Select */
+	u8 HActiveSrc;		/**< Horizontal Active Video Start Register
+				  *  Source Select */
+	u8 HBackPorchSrc;	/**< Horizontal Back Porch Start Register
+				  *  Source Select */
+	u8 HSyncSrc;		/**< Horizontal Sync Start Register
+				  *  Source Select */
+	u8 HFrontPorchSrc;	/**< Horizontal Front Porch Start Register
+				  *  Source Select */
+	u8 HTotalSrc;		/**< Horizontal Total Register Source Select */
+	u8 InterlacedMode;	/**< Interelaced mode */
+
+} XVtc_SourceSelect;
+
+/**
+ * This typedef contains the VTC signal configuration used by the
+ * Generator/Detector modules in a VTC device.
+ */
+typedef struct {
+	u16 OriginMode;		/**< Origin Mode */
+	u16 HTotal;		/**< Horizontal total clock cycles per Line */
+	u16 HFrontPorchStart;	/**< Horizontal Front Porch Start Cycle
+				  *  Count */
+	u16 HSyncStart;		/**< Horizontal Sync Start Cycle Count */
+	u16 HBackPorchStart;	/**< Horizontal Back Porch Start Cycle Count */
+	u16 HActiveStart;	/**< Horizontal Active Video Start Cycle
+				  *  Count */
+
+	u16 V0Total;		/**< Total lines per Frame (Field 0) */
+	u16 V0FrontPorchStart;	/**< Vertical Front Porch Start Line
+				  *  Count * (Field 0) */
+	u16 V0SyncStart;	/**< Vertical Sync Start Line Count
+				  *  (Field 0) */
+	u16 V0BackPorchStart;	/**< Vertical Back Porch Start Line
+				  *  Count *  (Field 0) */
+	u16 V0ActiveStart;	/**< Vertical Active Video Start Line
+				  *  Count *  (Field 0) */
+	u16 V0ChromaStart;	/**< Active Chroma Start Line Count
+				  *  (Field 0) */
+
+	u16 V1Total;		/**< Total lines per Frame (Field 1) */
+	u16 V1FrontPorchStart;	/**< Vertical Front Porch Start Line
+				  *  Count *  (Field 1) */
+	u16 V1SyncStart;	/**< Vertical Sync Start Line Count
+				  *  (Field 1) */
+	u16 V1BackPorchStart;	/**< Vertical Back Porch Start Line Count *
+				  *  (Field 1) */
+	u16 V1ActiveStart;	/**< Vertical Active Video Start Line
+				  *  Count (Field 1) */
+	u16 V1ChromaStart;	/**< Active Chroma Start Line Count
+				  *  (Field 1) */
+	u8 Interlaced;		/**< Interlaced / Progressive video */
+} XVtc_Signal;
+
+/**
+ * This typedef contains Detector/Generator VBlank/VSync Horizontal Offset
+ * configuration information for a VTC device.
+ */
+typedef struct {
+	u16 V0BlankHoriStart;	/**< Vertical Blank Hori Offset Start
+				  *  (field 0) */
+	u16 V0BlankHoriEnd;	/**< Vertical Blank Hori Offset End
+				  *  (field 0) */
+	u16 V0SyncHoriStart;	/**< Vertical Sync  Hori Offset Start
+				  *  (field 0) */
+	u16 V0SyncHoriEnd;	/**< Vertical Sync  Hori Offset End
+				  *  (field 0) */
+	u16 V1BlankHoriStart;	/**< Vertical Blank Hori Offset Start
+				  *  (field 1) */
+	u16 V1BlankHoriEnd;	/**< Vertical Blank Hori Offset End
+				  *  (field 1) */
+	u16 V1SyncHoriStart;	/**< Vertical Sync  Hori Offset Start
+				  * (field 1) */
+	u16 V1SyncHoriEnd;	/**< Vertical Sync  Hori Offset End
+				  *  (field 1) */
+} XVtc_HoriOffsets;
+
+/**
+* This typedef contains Timing (typically in Display Timing) format
+* configuration information for the VTC core.
+*/
+typedef struct {
+	/* Horizontal Timing */
+	u16 HActiveVideo;	/**< Horizontal Active Video Size */
+	u16 HFrontPorch;	/**< Horizontal Front Porch Size */
+	u16 HSyncWidth;		/**< Horizontal Sync Width */
+	u16 HBackPorch;		/**< Horizontal Back Porch Size */
+	u16 HSyncPolarity;	/**< Horizontal Sync Polarity */
+
+	/* Vertical Timing */
+	u16 VActiveVideo;	/**< Vertical Active Video Size */
+	u16 V0FrontPorch;	/**< Vertical Front Porch Size */
+	u16 V0SyncWidth;	/**< Vertical Sync Width */
+	u16 V0BackPorch;	/**< Horizontal Back Porch Size */
+
+	u16 V1FrontPorch;	/**< Vertical Front Porch Size */
+	u16 V1SyncWidth;	/**< Vertical Sync Width */
+	u16 V1BackPorch;	/**< Vertical Back Porch Size */
+
+	u16 VSyncPolarity;	/**< Vertical Sync Polarity */
+
+	u8 Interlaced;		/**< Interlaced / Progressive video */
+} XVtc_Timing;
+
+/**
+*
+* Callback type for all interrupts except error interrupt.
+*
+* @param	CallBackRef is a callback reference passed in by the upper
+*		layer when setting the callback functions, and passed back to
+*		the upper layer when the callback is invoked.
+* @param	Mask is a bit mask indicating the cause of the event. For
+*		current core version, this parameter is "OR" of 0 or more
+*		XVTC_IXR_*_MASK constants defined in xvtc_hw.h.
+*
+* @return	None.
+*
+* @note		None.
+*
+ *****************************************************************************/
+typedef void (*XVtc_CallBack)(void *CallBackRef, u32 Mask);
+
+/**
+*
+* Callback type for Error interrupt.
+*
+* @param	CallBackRef is a callback reference passed in by the upper
+*		layer when setting the callback functions, and passed back to
+*		the upper layer when the callback is invoked.
+* @param	ErrorMask is a bit mask indicating the cause of the error. For
+*		current core version, this parameter always have value 0 and
+*		could be ignored.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+typedef void (*XVtc_ErrorCallBack)(void *CallBackRef, u32 ErrorMask);
+
+/**
+ * The XVtc driver instance data. An instance must be allocated for each
+ * VTC core in use.
+ */
+typedef struct {
+	XVtc_Config Config;	/**< Hardware Configuration */
+	u32 IsReady;		/**< Core and the driver instance are
+				  *  initialized */
+
+	/* Interrupt callbacks*/
+	XVtc_CallBack FrameSyncCallBack;	/**< Callback for Frame Sync
+						  *  interrupt */
+	void *FrameSyncRef;		/**< To be passed to the Frame Sync
+					  *  interrupt callback */
+
+	XVtc_CallBack LockCallBack;	/**< Callback for Signal Lock
+					  *  interrupt */
+	void *LockRef;			/**< To be passed to the Signal Lock
+					  *  interrupt callback */
+
+	XVtc_CallBack DetectorCallBack;	/**< Callback for Detector interrupt */
+	void *DetectorRef;		/**< To be passed to the Detector
+					  *  interrupt callback */
+
+	XVtc_CallBack GeneratorCallBack;	/**< Callback for Generator
+						  *  interrupt */
+	void *GeneratorRef;		/**< To be passed to the Generator
+					  *  interrupt callback */
+
+	XVtc_ErrorCallBack ErrCallBack;	/**< Callback for Error interrupt */
+	void *ErrRef;			/**< To be passed to the Error
+					  *  interrupt callback */
+} XVtc;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* This function macro resets the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_Reset(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_Reset(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+			(XVTC_CTL_RESET_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This function macro resets the VTC core after the next input frame is
+* complete.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_SyncReset(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_SyncReset(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+		(XVTC_CTL_SRST_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This function macro enables synchronization of the Generator with the
+* Detector on the given VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return 	None.
+*
+* @note		C-style signature:
+*		void XVtc_EnableSync(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_EnableSync(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+		XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+			(XVTC_CTL_OFFSET)) | (XVTC_CTL_SE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This function macro enables updating timing registers at the end of each
+* Generator frame.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_RegUpdateEnable(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_RegUpdateEnable(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+		XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+			(XVTC_CTL_OFFSET)) | (XVTC_CTL_RU_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This function macro disables updating timing registers at the end of each
+* Generator frame.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_RegUpdateDisable(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_RegUpdateDisable(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+		XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+			(XVTC_CTL_OFFSET)) & (~(XVTC_CTL_RU_MASK)))
+
+/*****************************************************************************/
+/**
+*
+* This function macro disables synchronization of the Generator with the
+* Detector on the given VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_DisableSync(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_DisableSync(InstancePtr) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_CTL_OFFSET), \
+		(XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+			(XVTC_CTL_OFFSET)) & ~(XVTC_CTL_SE_MASK)))
+
+/*****************************************************************************/
+/**
+*
+* This function macro gets the status of the Detector in the VTC core.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	The Detector status. Use XVTC_DS_* in xvtc_hw.h to interpret
+*		the returned value.
+*
+* @note		C-style signature:
+*		u32 XVtc_GetDetectionStatus(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_GetDetectionStatus(InstancePtr) \
+	XVtc_ReadReg((InstancePtr)->Config.BaseAddress, (XVTC_DTSTAT_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function macro enables individual interrupts of the VTC core by
+* updating the IRQ_ENABLE register.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @param	IntrType is the bit-mask of the interrupts to be enabled.
+*		Bit positions of 1 will be enabled. Bit positions of 0 will
+*		keep the previous setting. This mask is formed by OR'ing
+*		XVTC_IXR_*_MASK bits defined in xvtc_hw.h.
+*
+* @return	None.
+*
+* @note		The existing enabled interrupt(s) will remain enabled.
+*		C-style signature:
+*		void XVtc_IntrEnable(XVtc *InstancePtr, u32 IntrType)
+*
+******************************************************************************/
+#define XVtc_IntrEnable(InstancePtr, IntrType) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_IER_OFFSET), \
+		(((IntrType) & (XVTC_IXR_ALLINTR_MASK)) | \
+			(XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+				(XVTC_IER_OFFSET)))))
+
+/*****************************************************************************/
+/**
+*
+* This function macro disables individual interrupts of the VTC core by
+* updating the IRQ_ENABLE register.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @param	IntrType is the bit-mask of the interrupts to be disabled.
+*		Bit positions of 1 will be disabled. Bit positions of 0 will
+*		keep the previous setting. This mask is formed by OR'ing
+*		XVTC_IXR_*_MASK bits defined in xvtc_hw.h.
+*
+* @return	None.
+*
+* @note		Any other interrupt not covered by parameter IntrType,
+*		if enabled before this macro is called, will remain enabled.
+*		C-style signature:
+*		void XVtc_IntrDisable(XVtc *InstancePtr, u32 IntrType)
+*
+******************************************************************************/
+#define XVtc_IntrDisable(InstancePtr, IntrType) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_IER_OFFSET), \
+		XVtc_ReadReg((InstancePtr)->Config.BaseAddress, \
+		(XVTC_IER_OFFSET)) & ((~(IntrType)) & (XVTC_IXR_ALLINTR_MASK)))
+
+/*****************************************************************************/
+/**
+*
+* This function macro returns the pending interrupt status of the VTC core
+* read from the Status register.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	The status of pending interrupts of the VTC core.
+* 		Use XVTC_IXR_*_MASK constants defined in xvtc_hw.h to
+*		interpret this value.
+*
+* @note		C-style signature:
+*		u32 XVtc_StatusGePending(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_StatusGetPending(InstancePtr) \
+	XVtc_ReadReg((InstancePtr)->Config.BaseAddress, (XVTC_ISR_OFFSET)) & \
+		(XVTC_IXR_ALLINTR_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function macro returns the pending interrupts of the VTC core for
+* the interrupts that have been enabled.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	The pending interrupts of the VTC core. Use
+*		XVTC_IXR_*_MASK constants defined in xvtc_hw.h to
+*		interpret this value. The returned value is a logical AND of
+*		the contents of the STATUS Register and the IRQ_ENABLE
+*		Register.
+*
+* @note		C-style signature:
+*		u32 XVtc_IntrGetPending(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_IntrGetPending(InstancePtr) \
+	(XVtc_ReadReg((InstancePtr)->Config.BaseAddress, XVTC_IER_OFFSET) & \
+	 XVtc_ReadReg((InstancePtr)->Config.BaseAddress, XVTC_ISR_OFFSET) & \
+	 XVTC_IXR_ALLINTR_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function macro clears/acknowledges pending interrupts of the VTC
+* core in the Status register. Bit positions of 1 will be cleared.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+* @param	IntrType is the pending interrupts to clear/acknowledge.
+*		Use OR'ing of XVTC_IXR_*_MASK constants defined in
+*		xvtc_hw.h to create this parameter value.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_IntrClear(XVtc *InstancePtr, u32 IntrType)
+*
+******************************************************************************/
+#define XVtc_IntrClear(InstancePtr, IntrType) \
+	XVtc_WriteReg((InstancePtr)->Config.BaseAddress, (XVTC_ISR_OFFSET), \
+		((IntrType) & (XVTC_IXR_ALLINTR_MASK)))
+
+/*****************************************************************************/
+/**
+*
+* This function macro resets the VTC core after the next input frame is
+* complete.
+*
+* @param	InstancePtr is a pointer to the VTC core instance to be
+*		worked on.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_Sync_Reset(XVtc *InstancePtr)
+*
+******************************************************************************/
+#define XVtc_Sync_Reset		XVtc_SyncReset
+
+/** @name Compatibility Macros
+ *  @{
+ */
+#define XVtc_RegUpdate		XVtc_RegUpdateEnable
+/*@}*/
+/************************** Function Prototypes ******************************/
+
+/* Initialization and control functions in xvtc.c */
+
+/* Initialization */
+int XVtc_CfgInitialize(XVtc *InstancePtr, XVtc_Config *CfgPtr,
+			UINTPTR EffectiveAddr);
+
+/* Enabling and Disabling the VTC core */
+void XVtc_EnableGenerator(XVtc *InstancePtr);
+void XVtc_EnableDetector(XVtc *InstancePtr);
+void XVtc_Enable(XVtc *InstancePtr);
+void XVtc_DisableGenerator(XVtc *InstancePtr);
+void XVtc_DisableDetector(XVtc *InstancePtr);
+void XVtc_Disable(XVtc *InstancePtr);
+
+/* Video Mode, Timing and Signal/HoriOffsets/Polarity Conversions */
+void XVtc_ConvVideoMode2Timing(XVtc *InstancePtr, u16 Mode,
+		XVtc_Timing *TimingPtr);
+void XVtc_ConvTiming2Signal(XVtc *InstancePtr, XVtc_Timing *TimingPtr,
+		XVtc_Signal *SignalCfgPtr, XVtc_HoriOffsets *HOffPtr,
+		XVtc_Polarity *PolarityPtr);
+void XVtc_ConvSignal2Timing(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr,
+		XVtc_HoriOffsets *HOffPtr, XVtc_Polarity *PolarityPtr,
+		XVtc_Timing *TimingPtr);
+u16 XVtc_ConvTiming2VideoMode(XVtc *InstancePtr, XVtc_Timing *TimingPtr);
+
+/* Timing/Video Mode Setting/Fetching */
+void XVtc_SetGeneratorTiming(XVtc *InstancePtr, XVtc_Timing * TimingPtr);
+void XVtc_SetGeneratorVideoMode(XVtc *InstancePtr, u16 Mode);
+void XVtc_GetGeneratorTiming(XVtc *InstancePtr, XVtc_Timing *TimingPtr);
+u16  XVtc_GetGeneratorVideoMode(XVtc *InstancePtr);
+void XVtc_GetDetectorTiming(XVtc *InstancePtr, XVtc_Timing *TimingPtr);
+u16  XVtc_GetDetectorVideoMode(XVtc *InstancePtr);
+
+/* Polarity setting */
+void XVtc_SetPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr);
+void XVtc_GetPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr);
+void XVtc_GetDetectorPolarity(XVtc *InstancePtr, XVtc_Polarity *PolarityPtr);
+
+/* Source selection */
+void XVtc_SetSource(XVtc *InstancePtr, XVtc_SourceSelect *SourcePtr);
+void XVtc_GetSource(XVtc *InstancePtr, XVtc_SourceSelect *SourcePtr);
+
+/* Skipping setting */
+void XVtc_SetSkipLine(XVtc *InstancePtr, int GeneratorChromaSkip);
+void XVtc_GetSkipLine(XVtc *InstancePtr, int *GeneratorChromaSkipPtr);
+void XVtc_SetSkipPixel(XVtc *InstancePtr, int GeneratorChromaSkip);
+void XVtc_GetSkipPixel(XVtc *InstancePtr, int *GeneratorChromaSkipPtr);
+
+/* VTC generator/detector setting/fetching */
+void XVtc_SetGenerator(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr);
+void XVtc_GetGenerator(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr);
+void XVtc_GetDetector(XVtc *InstancePtr, XVtc_Signal *SignalCfgPtr);
+
+/* Delay setting */
+void XVtc_SetDelay(XVtc *InstancePtr, int VertDelay, int HoriDelay);
+void XVtc_GetDelay(XVtc *InstancePtr, int *VertDelayPtr, int *HoriDelayPtr);
+
+/* Frame Sync setting */
+void XVtc_SetFSync(XVtc *InstancePtr, u16 FrameSyncIndex,
+			   u16 VertStart, u16 HoriStart);
+void XVtc_GetFSync(XVtc *InstancePtr, u16 FrameSyncIndex,
+			   u16 *VertStartPtr, u16 *HoriStartPtr);
+
+/* Horizontal Offset Setting */
+void XVtc_SetGeneratorHoriOffset(XVtc *InstancePtr,
+			   XVtc_HoriOffsets *HoriOffset);
+void XVtc_GetGeneratorHoriOffset(XVtc *InstancePtr,
+			   XVtc_HoriOffsets *HoriOffset);
+void XVtc_GetDetectorHoriOffset(XVtc *InstancePtr,
+			   XVtc_HoriOffsets *HoriOffset);
+
+/* Version function */
+u32 XVtc_GetVersion(XVtc *InstancePtr);
+
+/* Initialization functions in xvtc_sinit.c */
+XVtc_Config *XVtc_LookupConfig(u16 DeviceId);
+
+/*
+ * Interrupt related function(s) in xvtc_intr.c
+ */
+void XVtc_IntrHandler(void *InstancePtr);
+int XVtc_SetCallBack(XVtc *InstancePtr, u32 IntrType,
+			void *CallBackFunc, void *CallBackRef);
+
+/* SelfTest related function in xvtc_selftest.c */
+int XVtc_SelfTest(XVtc *InstancePtr);
+
+/************************** Variable Declarations ****************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_hw.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_hw.h
new file mode 100644
index 0000000..7ce32fc
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_hw.h
@@ -0,0 +1,651 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xvtc_hw.h
+* @addtogroup vtc_v7_2
+* @{
+*
+* This header file contains identifiers and register-level core functions (or
+* macros) that can be used to access the Xilinx VTC core.
+*
+* For more information about the operation of this core, see the hardware
+* specification and documentation in the higher level driver xvtc.h source
+* code file.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- -------------------------------------------------------
+* 1.00a xd     08/05/08 First release.
+* 1.01a xd     07/23/10 Added GIER. Added more h/w generic info into
+*                       xparameters.h. Feed callbacks with pending
+*                       interrupt info. Added Doxygen & Version support.
+* 2.00a cm     05/25/11 Renamed XVTC_CTL_GACS_MASK to XVTC_CTL_GACLS_MASKl.
+*                       Added XVTC_CTL_GACPS_MASK.
+* 3.00a cjm    08/01/12 Converted from xio.h to xil_io.h, translating basic
+*                       types, MB cache functions, exceptions and assertions to
+*                       xil_io format. Replaced the following
+*                       "XExc_Init" -> "Xil_ExceptionInit"
+*                       "XExc_RegisterHandler" -> "Xil_ExceptionRegisterHandler"
+*                       "XEXC_ID_NON_CRITICAL_INT" -> "XIL_EXCEPTION_ID_INT"
+*                       "XExceptionHandler" -> "Xil_ExceptionHandler"
+*                       "XExc_mEnableExceptions" -> "Xil_ExceptionEnable"
+*                       "XEXC_NON_CRITICAL" -> "XIL_EXCEPTION_NON_CRITICAL"
+*                       "XExc_DisableExceptions" -> "Xil_ExceptionDisable"
+*                       "XExc_RemoveHandler" -> "Xil_ExceptionRemoveHandler"
+*                       "microblaze_enable_interrupts" -> "Xil_Exception
+*                                                                      Enable"
+*                       "microblaze_disable_interrupts" -> "Xil_Exception
+*                                                                       Disable"
+*
+*                       "XCOMPONENT_IS_STARTED" -> "XIL_COMPONENT_IS_STARTED"
+*                       "XCOMPONENT_IS_READY" -> "XIL_COMPONENT_IS_READY"
+*
+*                       "XASSERT_NONVOID" -> "Xil_AssertNonvoid"
+*                       "XASSERT_VOID_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XASSERT_VOID" -> "Xil_AssertVoid"
+*                       "Xil_AssertVoid_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XAssertStatus" -> "Xil_AssertStatus"
+*                       "XAssertSetCallback" -> "Xil_AssertCallback"
+*
+*                       "XASSERT_OCCURRED" -> "XIL_ASSERT_OCCURRED"
+*                       "XASSERT_NONE" -> "XIL_ASSERT_NONE"
+*
+*                       "microblaze_disable_dcache" -> "Xil_DCacheDisable"
+*                       "microblaze_enable_dcache" -> "Xil_DCacheEnable"
+*                       "microblaze_enable_icache" -> "Xil_ICacheEnable"
+*                       "microblaze_disable_icache" -> "Xil_ICacheDisable"
+*                       "microblaze_init_dcache_range" -> "Xil_DCache
+*                                                         InvalidateRange"
+*
+*                       "XCache_DisableDCache" -> "Xil_DCacheDisable"
+*                       "XCache_DisableICache" -> "Xil_ICacheDisable"
+*                       "XCache_EnableDCache" -> "Xil_DCacheEnableRegion"
+*                       "XCache_EnableICache" -> "Xil_ICacheEnableRegion"
+*                       "XCache_InvalidateDCacheLine" -> "Xil_DCache
+*                                                       InvalidateRange"
+*
+*                       "XUtil_MemoryTest32" -> "Xil_TestMem32"
+*                       "XUtil_MemoryTest16" -> "Xil_TestMem16"
+*                       "XUtil_MemoryTest8" -> "Xil_TestMem8"
+*
+*                       "xutil.h" -> "xil_testmem.h"
+*
+*                       "xbasic_types.h" -> "xil_types.h"
+*                       "xio.h" -> "xil_io.h"
+*
+*                       "XIo_In32" -> "Xil_In32"
+*                       "XIo_Out32" -> "Xil_Out32"
+*
+*                       "XTRUE" -> "TRUE"
+*                       "XFALSE" -> "FALSE"
+*                       "XNULL" -> "NULL"
+*
+*                       "Xuint8" -> "u8"
+*                       "Xuint16" -> "u16"
+*                       "Xuint32" -> "u32"
+*                       "Xint8" -> "char"
+*                       "Xint16" -> "short"
+*                       "Xint32" -> "long"
+*                       "Xfloat32" -> "float"
+*                       "Xfloat64" -> "double"
+*                       "Xboolean" -> "int"
+*                       "XTEST_FAILED" -> "XST_FAILURE"
+*                       "XTEST_PASSED" -> "XST_SUCCESS"
+* 3.00a cjm    08/02/12 Changed XVTC_RESET_RESET_MASK from 0x0000_000a
+*                       to 0x8000_0000
+* 4.00a cjm    02/07/13 Remove Unused defines: XVTC_GIER, XVTC_GIER_GIE_MASK.
+* 4.00a cjm    02/08/13 Removed XVTC_CTL_HASS_MASK.
+* 5.00a cjm    08/06/13 Replaced CTL in Polarity and Encoding register
+*                       definition with "POL" and "ENC".
+*                       Renamed XVTC_RESET_RESET_MASK to XVTC_CTL_RESET_MASK.
+*                       Renamed XVTC_SYNC_RESET_MASK to XVTC_CTL_SRST_MASK.
+*                       Renamed Error register bit defs to XVTC_ERR_*
+*                       Added Patch and Internal Revision MASKs for.
+*                       Revision register.
+* 5.00a cjm    11/01/13 Removed Unused Hori Offset registers defines from
+*                       0x0a0 - 0x0c0A
+*                       Added interlaced register defines.
+*                       Changed Version Register Revision shift from 12 to 8
+*                       and changed mask to be 8 instead of 4 bits wide
+* 5.00a cjm    11/03/13 Added Chroma/field parity bit masks.
+*                       Replaced old timing bit masks/shifts with Start/End Bit
+*                       masks/shifts.
+* 6.1   adk    08/23/14 Removed XVTC_ERR_FIL_MASK macro because it is  not
+*                       present in latest product guide.
+*                       Modified register offsets from XVTC_* to XVTC_*_OFFSET
+*                       for consistency.
+*                       Added backward compatibility macros.
+* 7.1   vns   10/14/15  Added XVTC_CTL_INTERLACE_MASK macro and
+*                       modified XVTC_CTL_ALLSS_MASK
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XVTC_HW_H_
+#define XVTC_HW_H_	/**< prevent circular inclusions
+			  * by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_io.h"
+
+/************************** Constant Definitions *****************************/
+
+/** @name Core Register Offsets
+* @{
+*/
+#define XVTC_CTL_OFFSET		0x000	/**< Control Register Offset */
+#define XVTC_ISR_OFFSET		0x004	/**< Status/Interrupt Status Register
+					  *  Offset */
+#define XVTC_ERROR_OFFSET	0x008	/**< Error Register Offset */
+#define XVTC_IER_OFFSET		0x00C	/**< Interrupt Enable Register
+					  *  Offset */
+#define XVTC_VER_OFFSET		0x010	/**< Version Register Offset */
+
+#define XVTC_DASIZE_OFFSET	0x020	/**< Detector Active Size Offset */
+#define XVTC_DTSTAT_OFFSET	0x024	/**< Detector Timing Status Offset */
+#define XVTC_DFENC_OFFSET	0x028	/**< Detector Encoding Offset */
+#define XVTC_DPOL_OFFSET	0x02C	/**< Detector Polarity Offset */
+#define XVTC_DHSIZE_OFFSET	0x030	/**< Detector Frame Horizontal Size
+					  *  Offset */
+#define XVTC_DVSIZE_OFFSET	0x034	/**< Detector Frame Vertical Size
+					  *  Offset */
+#define XVTC_DHSYNC_OFFSET	0x038	/**< Detector Horizontal sync
+					  *  Offset */
+
+#define XVTC_DVBHOFF_OFFSET	0x03C	/**< Detector Frame/F0 Vblank
+					  *  Horizontal Offset */
+#define XVTC_DVSYNC_OFFSET	0x040	/**< Detector Frame/F0 Vertical Sync
+					  *  Offset */
+#define XVTC_DVSHOFF_OFFSET	0x044	/**< Detector Frame/F0 Vsync Horizontal
+					  *  Offset */
+
+#define XVTC_DVBHOFF_F1_OFFSET 	0x048	/**< Detector Field 1 Vblank Horizontal
+					  *  Offset */
+#define XVTC_DVSYNC_F1_OFFSET	0x04C	/**< Detector Field 1 Vertical Sync
+					  *  Offset */
+#define XVTC_DVSHOFF_F1_OFFSET	0x050	/**< Detector Field 1 Vsync Horizontal
+					  *  Offset */
+
+#define XVTC_GASIZE_OFFSET	0x060	/**< Generator Active Size Offset */
+#define XVTC_GTSTAT_OFFSET	0x064	/**< Generator Timing Status Offset */
+#define XVTC_GFENC_OFFSET	0x068	/**< Generator Encoding Offset */
+#define XVTC_GPOL_OFFSET	0x06C	/**< Generator Polarity Offset */
+#define XVTC_GHSIZE_OFFSET	0x070	/**< Generator Frame Horizontal Size
+					  *  Offset */
+#define XVTC_GVSIZE_OFFSET	0x074	/**< Generator Frame Vertical Size
+					  *  Offset */
+#define XVTC_GHSYNC_OFFSET	0x078	/**< Generator Horizontal Sync
+					  *  Offset */
+
+#define XVTC_GVBHOFF_OFFSET	0x07C	/**< Generator Frame/F0 Vblank
+					  *  Horizontal Offset */
+#define XVTC_GVSYNC_OFFSET	0x080	/**< Generator Frame/F0 Vertical
+					  *  Sync Offset */
+#define XVTC_GVSHOFF_OFFSET	0x084	/**< Generator Frame/F0 Vsync
+					  *  horizontal Offset */
+
+#define XVTC_GVBHOFF_F1_OFFSET	0x088	/**< Generator Field 1 Vblank
+					  *  Horizontal Offset */
+#define XVTC_GVSYNC_F1_OFFSET	0x08C	/**< Generator Field 1 Vertical
+					  *  Sync Offset */
+#define XVTC_GVSHOFF_F1_OFFSET	0x090	/**< Generator Field 1 Vsync horizontal
+					  *  Offset */
+
+#define XVTC_FS00_OFFSET	0x100	/**< Frame Sync 00 Config
+					  *  Register Offset */
+#define XVTC_FS01_OFFSET	0x104	/**< Frame Sync 01 Config
+					  *  Register Offset */
+#define XVTC_FS02_OFFSET	0x108	/**< Frame Sync 02 Config
+					  *  Register Offset */
+#define XVTC_FS03_OFFSET	0x10C	/**< Frame Sync 03 Config
+					  *  Register Offset */
+#define XVTC_FS04_OFFSET	0x110	/**< Frame Sync 04 Config
+					  *  Register Offset */
+#define XVTC_FS05_OFFSET	0x114	/**< Frame Sync 05 Config
+					  *  Register Offset */
+#define XVTC_FS06_OFFSET	0x118	/**< Frame Sync 06 Config
+					  *  Register Offset */
+#define XVTC_FS07_OFFSET	0x11C	/**< Frame Sync 07 Config
+					  *  Register Offset */
+#define XVTC_FS08_OFFSET	0x120	/**< Frame Sync 08 Config
+					  *  Register Offset */
+#define XVTC_FS09_OFFSET	0x124	/**< Frame Sync 09 Config
+					  *  Register Offset */
+#define XVTC_FS10_OFFSET	0x128	/**< Frame Sync 10 Config
+					  *  Register Offset */
+#define XVTC_FS11_OFFSET	0x12C	/**< Frame Sync 11 Config
+					  *  Register Offset */
+#define XVTC_FS12_OFFSET	0x130	/**< Frame Sync 12 Config
+					  *  Register Offset */
+#define XVTC_FS13_OFFSET	0x134	/**< Frame Sync 13 Config
+					  *  Register Offset */
+#define XVTC_FS14_OFFSET	0x138	/**< Frame Sync 14 Config
+					  *  Register Offset */
+#define XVTC_FS15_OFFSET	0x13C	/**< Frame Sync 15 Config
+					  *  Register Offset */
+
+#define XVTC_GGD_OFFSET		0x140	/**< Generator Global Delay
+					  *  Register Offset */
+/*@}*/
+
+/** @name Control Register Bit Definitions
+* @{
+*/
+#define XVTC_CTL_RESET_MASK	0x80000000 /**< Software Reset Mask */
+#define XVTC_CTL_SRST_MASK	0x40000000 /**< Frame Sync'ed Software
+					      *  Reset Mask */
+#define XVTC_CTL_FIPSS_MASK	0x04000000 /**< Field ID Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_ACPSS_MASK	0x02000000 /**< Active Chroma Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_AVPSS_MASK	0x01000000 /**< Active Video Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_HSPSS_MASK	0x00800000 /**< Horizontal Sync Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_VSPSS_MASK	0x00400000 /**< Vertical Sync Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_HBPSS_MASK	0x00200000 /**< Horizontal Blank Output
+					      *  Polarity Source Mask */
+#define XVTC_CTL_VBPSS_MASK	0x00100000 /**< Vertical Blank Output
+					      *  Polarity Source Mask */
+
+#define XVTC_CTL_INTERLACE_MASK	0x00080000 /**< Interlaced mode */
+
+#define XVTC_CTL_VCSS_MASK	0x00040000 /**< Generator Chroma Polarity
+					      *  and Encoding Source
+					      *  Select Mask */
+#define XVTC_CTL_VASS_MASK	0x00020000 /**< Generator Vertical Blank
+					      *  Offset Source Select
+					      *  Mask */
+#define XVTC_CTL_VBSS_MASK	0x00010000 /**< Generator Vertical Sync End
+					      *  (Back porch start) Source
+					      *  Select Mask */
+#define XVTC_CTL_VSSS_MASK	0x00008000 /**< Generator Vertical Sync
+					     *  Start Source Select Mask */
+#define XVTC_CTL_VFSS_MASK	0x00004000 /**< Generator Vertical Active Size
+					     *  Source Select Mask */
+#define XVTC_CTL_VTSS_MASK	0x00002000/**<  Generator Vertical Total Source
+					     *   Select (Frame Size) Mask */
+
+#define XVTC_CTL_HBSS_MASK	0x00000800 /**< Horizontal Back Porch Start
+					      *  Register Source Select
+					      *  (Sync End) Mask */
+#define XVTC_CTL_HSSS_MASK	0x00000400 /**< Horizontal Sync Start Register
+					      *  Source Select Mask */
+#define XVTC_CTL_HFSS_MASK	0x00000200 /**< Horizontal Front Porch Start
+					      *  Register Source Select
+					      *  (Active Size) Mask */
+#define XVTC_CTL_HTSS_MASK	0x00000100 /**< Horizontal Total Register
+					      *  Source Select (Frame Size)
+					      *  Mask */
+
+#define XVTC_CTL_ALLSS_MASK	0x03FDEF00 /**< Bit mask for all source
+					     *  select Mask */
+//#define XVTC_CTL_LP_MASK	0x00000008 /**< Lock Polarity */
+#define XVTC_CTL_SE_MASK	0x00000020 /**< Enable Sync with Detector */
+#define XVTC_CTL_DE_MASK	0x00000008 /**< VTC Detector Enable */
+#define XVTC_CTL_GE_MASK	0x00000004 /**< VTC Generator Enable */
+#define XVTC_CTL_RU_MASK	0x00000002 /**< VTC Register Update */
+#define XVTC_CTL_SW_MASK	0x00000001 /**< VTC Core Enable */
+/*@}*/
+
+/** @name Interrupt Status/Enable Register Bit Definitions
+* @{
+*/
+#define XVTC_IXR_FSYNC15_MASK	0x80000000 /**< Frame Sync Interrupt 15
+					      *  Mask */
+#define XVTC_IXR_FSYNC14_MASK	0x40000000 /**< Frame Sync Interrupt 14
+					      *  Mask */
+#define XVTC_IXR_FSYNC13_MASK	0x20000000 /**< Frame Sync Interrupt 13
+					      *  Mask */
+#define XVTC_IXR_FSYNC12_MASK	0x10000000 /**< Frame Sync Interrupt 12
+					      *  Mask */
+#define XVTC_IXR_FSYNC11_MASK	0x08000000 /**< Frame Sync Interrupt 11
+					      *  Mask */
+#define XVTC_IXR_FSYNC10_MASK	0x04000000 /**< Frame Sync Interrupt 10
+					      *  Mask */
+#define XVTC_IXR_FSYNC09_MASK	0x02000000 /**< Frame Sync Interrupt 09
+					      *  Mask */
+#define XVTC_IXR_FSYNC08_MASK	0x01000000 /**< Frame Sync Interrupt 08
+					      *  Mask */
+#define XVTC_IXR_FSYNC07_MASK	0x00800000 /**< Frame Sync Interrupt 07
+					      *  Mask */
+#define XVTC_IXR_FSYNC06_MASK	0x00400000 /**< Frame Sync Interrupt 06
+					      *  Mask */
+#define XVTC_IXR_FSYNC05_MASK	0x00200000 /**< Frame Sync Interrupt 05
+					      *  Mask */
+#define XVTC_IXR_FSYNC04_MASK	0x00100000 /**< Frame Sync Interrupt 04
+					      *  Mask */
+#define XVTC_IXR_FSYNC03_MASK	0x00080000 /**< Frame Sync Interrupt 03
+					      *  Mask */
+#define XVTC_IXR_FSYNC02_MASK	0x00040000 /**< Frame Sync Interrupt 02
+					      *  Mask */
+#define XVTC_IXR_FSYNC01_MASK	0x00020000 /**< Frame Sync Interrupt 01
+					      *  Mask */
+#define XVTC_IXR_FSYNC00_MASK	0x00010000 /**< Frame Sync Interrupt 00
+					      *  Mask */
+#define XVTC_IXR_FSYNCALL_MASK	0xFFFF0000 /**< All Frame Sync Interrupt 0-15
+					      *  Mask */
+
+#define XVTC_IXR_G_AV_MASK	0x00002000 /**< Generator Active Video Intr
+					      *  Mask */
+#define XVTC_IXR_G_VBLANK_MASK	0x00001000 /**< Generator VBLANK Interrupt
+					      *  Mask */
+#define XVTC_IXR_G_ALL_MASK	0x00003000 /**< All Generator interrupts
+					      *  Mask */
+
+#define XVTC_IXR_D_AV_MASK	0x00000800 /**< Detector Active Video
+					      *  Interrupt Mask */
+#define XVTC_IXR_D_VBLANK_MASK	0x00000400 /**< Detector VBLANK Interrupt
+					      *  Mask */
+#define XVTC_IXR_D_ALL_MASK	0x00000C00 /**< All Detector Interrupts
+					      *  Mask */
+
+#define XVTC_IXR_LOL_MASK	0x00000200 /**< Lock Loss Mask */
+#define XVTC_IXR_LO_MASK	0x00000100 /**< Lock Mask */
+#define XVTC_IXR_LOCKALL_MASK	0x00000300 /**< All Signal Lock interrupt
+					     *  Mask */
+
+#define XVTC_IXR_ALLINTR_MASK	(XVTC_IXR_FSYNCALL_MASK |\
+				 XVTC_IXR_G_ALL_MASK |\
+				 XVTC_IXR_D_ALL_MASK |\
+				 XVTC_IXR_LOCKALL_MASK) /**< Mask for all
+							  *  interrupts Mask */
+
+/** @name Error Register Bit Definitions
+* @{
+*/
+#define XVTC_ERR_ACL_MASK	0x00200000	/**< Active Chroma Signal
+						  *  Lock Mask */
+#define XVTC_ERR_AVL_MASK	0x00100000	/**< Active Video Signal
+						  *  Lock Mask */
+#define XVTC_ERR_HSL_MASK	0x00080000	/**< Horizontal Sync Signal
+						  *  Lock Mask */
+#define XVTC_ERR_VSL_MASK	0x00040000	/**< Vertical Sync Signal
+						  *  Lock Mask */
+#define XVTC_ERR_HBL_MASK	0x00020000	/**< Horizontal Blank Signal
+						  *  Lock Mask */
+#define XVTC_ERR_VBL_MASK	0x00010000	/**< Vertical Blank Signal
+						  *  Lock Mask */
+/*@}*/
+
+/** @name Version Register Bit Definition and Shifts
+* @{
+*/
+#define XVTC_VER_MAJOR_MASK	0xFF000000	/**< Major Version Mask */
+#define XVTC_VER_MAJOR_SHIFT	24		/**< Major Version Bit Shift */
+#define XVTC_VER_MINOR_MASK	0x00FF0000	/**< Minor Version Mask */
+#define XVTC_VER_MINOR_SHIFT	16		/**< Minor Version Bit Shift */
+#define XVTC_VER_REV_MASK	0x0000FF00	/**< Revision Version Mask */
+#define XVTC_VER_REV_SHIFT	8		/**< Revision Version Bit
+						  *  Shift */
+#define XVTC_VER_IREV_MASK	0x000000FF	/**< Internal Revision Version
+						  *  Mask */
+#define XVTC_VER_IREV_SHIFT	0		/**< Internal Revision Bit
+						  *  Shift */
+/*@}*/
+
+/** @name Generator/Detector Active Video Size Register Bit Definitions and
+* Shift
+*  @{
+*/
+#define XVTC_ASIZE_VERT_MASK	0x1FFF0000 /**< Total number of lines
+					      *  (including blanking) for
+					      *  frame or field 1 */
+#define XVTC_ASIZE_VERT_SHIFT	16	    /**<  Bit shift for End Cycle or
+					      *   Line Count */
+#define XVTC_ASIZE_HORI_MASK	0x00001FFF /**< Horizontal Active Frame
+					      *  Size.The width of the frame
+					      *  without blanking in number
+					      *  of pixels or clocks. */
+/*@}*/
+
+/** @name Generator/Detector Status Bit Definitions
+* @{
+*/
+#define XVTC_STAT_AVIDEO_MASK	0x00000004	/**< Active Video Interrupt
+						  *  Status.Mask */
+#define XVTC_STAT_VBLANK_MASK	0x00000002	/**< Vertical Blank Interrupt
+						  *  Status Mask */
+#define XVTC_STAT_LOCKED_MASK	0x00000001	/**< Lock Status. Set High when
+						  *  all signals have locked.
+						  *  (Detector only) Mask */
+/*@}*/
+
+/** @name Generator/Detector Encoding Register Bit Definitions
+* @{
+*/
+#define XVTC_ENC_GACPS_MASK	0x00000200	/**< Generator Active Chroma
+						  *  Pixel Skip/Parity Mask */
+#define XVTC_ENC_CPARITY_MASK	0x00000100	/**< Chroma Line Parity Mask */
+#define XVTC_ENC_CPARITY_SHIFT	8		/**< Bit shift for Active
+						  *  Chroma Line Parity */
+#define XVTC_ENC_FPARITY_MASK	0x00000080	/**< Field Parity Mask  */
+#define XVTC_ENC_PROG_MASK	0x00000040	/**< Progressive/Interlaced
+						  *  Mask */
+#define XVTC_ENC_PROG_SHIFT	6			/**< Progressive/Interlaced
+						  *  Shift */
+#define XVTC_ENC_GACLS_MASK	0x00000001	/**< Generator Active Chroma
+						  *  Line Skip/parity Mask */
+/*@}*/
+
+/** @name Generator/Detector Polarity Register Bit Definitions
+* @{
+*/
+#define XVTC_POL_FIP_MASK	0x00000040	/**< Field ID Output
+						  *  Polarity Mask */
+#define XVTC_POL_ACP_MASK	0x00000020	/**< Active Chroma Output
+						  *  Polarity Mask */
+#define XVTC_POL_AVP_MASK	0x00000010	/**< Active Video Output
+						  *  Polarity Mask */
+#define XVTC_POL_HSP_MASK	0x00000008	/**< Horizontal Sync Output
+						  *  Polarity Mask */
+#define XVTC_POL_VSP_MASK	0x00000004	/**< Vertical Sync Output
+						  *  Polarity Mask */
+#define XVTC_POL_HBP_MASK	0x00000002	/**< Horizontal Blank Output
+						  *  Polarity Mask */
+#define XVTC_POL_VBP_MASK	0x00000001	/**< Vertical Blank Output
+						  *  Polarity Mask */
+#define XVTC_POL_ALLP_MASK	0x0000007F	/**< Bit mask for all
+						  *  polarity bits Mask */
+/*@}*/
+
+/** @name Generator/Detector Full Vertical Size Register Bit Definitions
+* and Shift
+* @{
+*/
+#define XVTC_VSIZE_F1_MASK	0x1FFF0000 /**< Total number of lines
+					      *  (including blanking) for
+					      *  frame or field 1 */
+#define XVTC_VSIZE_F1_SHIFT	16	/**< Bit shift for End Cycle or
+					  *  Line Count */
+#define XVTC_VSIZE_F0_MASK	0x00001FFF /**< Total number of lines
+					      *  (including blanking) for
+					      *  frame or field 0 */
+/*@}*/
+
+/** @name Generator/Detector Sync/Blank Register Bit Definitions and Shift
+* @{
+*/
+#define XVTC_SB_END_MASK	0x1FFF0000 /**< End cycle or line count
+					      *  of horizontal sync, vertical
+					      *  sync or vertical blank */
+#define XVTC_SB_END_SHIFT	16	    /**< Bit shift for End Cycle or
+					      *  Line Count */
+#define XVTC_SB_START_MASK	0x00001FFF /**< Start cycle or line count
+					      *  of horizontal sync, vertical
+					      *  sync or vertical blank */
+/*@}*/
+
+/** @name Generator/Detector VBlank/VSync Horizontal Bit Definitions and Shift
+* @{
+*/
+#define XVTC_XVXHOX_HEND_MASK	0x1FFF0000	/**< Horizontal Offset End
+						  *  Mask */
+#define XVTC_XVXHOX_HEND_SHIFT	16		/**< Horizontal End Shift */
+#define XVTC_XVXHOX_HSTART_MASK	0x00001FFF	/**< Horizontal Offset Start
+						  *  Offset */
+/*@}*/
+
+/** @name Frame Sync 00 - 15
+* @{
+*/
+#define XVTC_FSXX_VSTART_MASK	0x1FFF0000 /**< Vertical line count during
+					      *  which current Frame Sync is
+					      *  active Mask */
+#define XVTC_FSXX_VSTART_SHIFT	16	    /**< Bit shift for the vertical
+					      *  line count */
+#define XVTC_FSXX_HSTART_MASK	0x00001FFF /**< Horizontal cycle count
+					      *  during which current
+					      *  Frame Sync is active Mask */
+/*@}*/
+
+/** @name VTC Generator Global Delay Bit Definition and Shift
+* @{
+*/
+#define XVTC_GGD_VDELAY_MASK	0x1FFF0000	/**< Total lines per frame to
+						  *  delay generator output
+						  *  Mask */
+#define XVTC_GGD_VDELAY_SHIFT	16		/**< Bit shift for the total
+						  *  lines */
+#define XVTC_GGD_HDELAY_MASK	0x00001FFF	/**< Total clock cycles per
+						  *  line to delay generator
+						  *  output Mask */
+/*@}*/
+
+/** @name Compatibility Macros
+* @{
+*/
+#define XVTC_CTL	XVTC_CTL_OFFSET
+#define XVTC_ISR	XVTC_ISR_OFFSET
+#define XVTC_ERROR	XVTC_ERROR_OFFSET
+#define XVTC_IER	XVTC_IER_OFFSET
+#define XVTC_VER	XVTC_VER_OFFSET
+#define XVTC_DASIZE	XVTC_DASIZE_OFFSET
+#define XVTC_DTSTAT	XVTC_DTSTAT_OFFSET
+#define XVTC_DFENC	XVTC_DFENC_OFFSET
+#define XVTC_DPOL	XVTC_DPOL_OFFSET
+#define XVTC_DHSIZE	XVTC_DHSIZE_OFFSET
+#define XVTC_DVSIZE	XVTC_DVSIZE_OFFSET
+#define XVTC_DHSYNC	XVTC_DHSYNC_OFFSET
+#define XVTC_DVBHOFF	XVTC_DVBHOFF_OFFSET
+#define XVTC_DVSYNC	XVTC_DVSYNC_OFFSET
+#define XVTC_DVSHOFF	XVTC_DVSHOFF_OFFSET
+#define XVTC_DVBHOFF_F1	XVTC_DVBHOFF_F1_OFFSET
+#define XVTC_DVSYNC_F1	XVTC_DVSYNC_F1_OFFSET
+#define XVTC_DVSHOFF_F1	XVTC_DVSHOFF_F1_OFFSET
+#define XVTC_GASIZE	XVTC_GASIZE_OFFSET
+#define XVTC_GTSTAT	XVTC_GTSTAT_OFFSET
+#define XVTC_GFENC	XVTC_GFENC_OFFSET
+#define XVTC_GPOL	XVTC_GPOL_OFFSET
+#define XVTC_GHSIZE	XVTC_GHSIZE_OFFSET
+#define XVTC_GVSIZE	XVTC_GVSIZE_OFFSET
+#define XVTC_GHSYNC	XVTC_GHSYNC_OFFSET
+#define XVTC_GVBHOFF	XVTC_GVBHOFF_OFFSET
+#define XVTC_GVSYNC	XVTC_GVSYNC_OFFSET
+#define XVTC_GVSHOFF	XVTC_GVSHOFF_OFFSET
+#define XVTC_GVBHOFF_F1	XVTC_GVBHOFF_F1_OFFSET
+#define XVTC_GVSYNC_F1	XVTC_GVSYNC_F1_OFFSET
+#define XVTC_GVSHOFF_F1	XVTC_GVSHOFF_F1_OFFSET
+#define XVTC_FS00	XVTC_FS00_OFFSET
+#define XVTC_FS01	XVTC_FS01_OFFSET
+#define XVTC_FS02	XVTC_FS02_OFFSET
+#define XVTC_FS03	XVTC_FS03_OFFSET
+#define XVTC_FS04	XVTC_FS04_OFFSET
+#define XVTC_FS05	XVTC_FS05_OFFSET
+#define XVTC_FS06	XVTC_FS06_OFFSET
+#define XVTC_FS07	XVTC_FS07_OFFSET
+#define XVTC_FS08	XVTC_FS08_OFFSET
+#define XVTC_FS09	XVTC_FS09_OFFSET
+#define XVTC_FS10	XVTC_FS10_OFFSET
+#define XVTC_FS11	XVTC_FS11_OFFSET
+#define XVTC_FS12	XVTC_FS12_OFFSET
+#define XVTC_FS13	XVTC_FS13_OFFSET
+#define XVTC_FS14	XVTC_FS14_OFFSET
+#define XVTC_FS15	XVTC_FS15_OFFSET
+#define XVTC_GGD	XVTC_GGD_OFFSET
+/*@}*/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/** @name Register Access Macro Definition
+* @{
+*/
+#define XVtc_In32		Xil_In32	/**< Input Operations */
+#define XVtc_Out32		Xil_Out32	/**< Output Operations */
+
+/*****************************************************************************/
+/**
+*
+* This function macro reads the given register.
+*
+* @param	BaseAddress is the base address of the VTC core.
+* @param	RegOffset is the register offset of the register (defined at
+*		top of this file).
+*
+* @return	The 32-bit value of the register.
+*
+* @note		C-style signature:
+*		u32 XVtc_ReadReg(u32 BaseAddress, u32 RegOffset)
+*
+******************************************************************************/
+#define XVtc_ReadReg(BaseAddress, RegOffset) \
+		XVtc_In32((BaseAddress) + ((u32)RegOffset))
+
+/*****************************************************************************/
+/**
+*
+* Write the given register.
+*
+* @param	BaseAddress is the base address of the VTC core.
+* @param	RegOffset is the register offset of the register (defined at
+*		top of this file) to be written.
+* @param	Data is the 32-bit value to write to the register.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XVtc_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+******************************************************************************/
+#define XVtc_WriteReg(BaseAddress, RegOffset, Data) 	\
+		XVtc_Out32((BaseAddress) + ((u32)RegOffset), (u32)(Data))
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Declarations ****************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_intr.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_intr.c
new file mode 100644
index 0000000..db50117
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_intr.c
@@ -0,0 +1,282 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xvtc_intr.c
+* @addtogroup vtc_v7_2
+* @{
+*
+* This file contains interrupt related functions of Xilinx VTC core.
+* Please see xvtc.h for more details of the core.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- -----------------------------------------------
+* 1.00a xd     08/05/08 First release
+* 1.01a xd     07/23/10 Added GIER. Added more h/w generic info into
+*                       xparameters.h. Feed callbacks with pending
+*                       interrupt info. Added Doxygen & Version support.
+* 3.00a cjm    08/01/12 Converted from xio.h to xil_io.h, translating
+*                       basic types, MB cache functions, exceptions and
+*                       assertions to xil_io format.
+*                       Replaced the following:
+*                       "XExc_Init" -> "Xil_ExceptionInit"
+*                       "XExc_RegisterHandler" -> "Xil_Exception
+*                                                 RegisterHandler"
+*                       "XEXC_ID_NON_CRITICAL_INT" -> "XIL_EXCEPTION_ID_INT"
+*                       "XExceptionHandler" -> "Xil_ExceptionHandler"
+*                       "XExc_mEnableExceptions" -> "Xil_ExceptionEnable"
+*                       "XEXC_NON_CRITICAL" -> "XIL_EXCEPTION_NON_CRITICAL"
+*                       "XExc_DisableExceptions" -> "Xil_ExceptionDisable"
+*                       "XExc_RemoveHandler" -> "Xil_ExceptionRemoveHandler"
+*                       "microblaze_enable_interrupts" -> "Xil_Exception
+*                                                         Enable"
+*                       "microblaze_disable_interrupts" -> "Xil_Exception
+*                                                           Disable"
+*                       "XCOMPONENT_IS_STARTED" -> "XIL_COMPONENT_IS_STARTED"
+*                       "XCOMPONENT_IS_READY" -> "XIL_COMPONENT_IS_READY"
+*                       "XASSERT_NONVOID" -> "Xil_AssertNonvoid"
+*                       "XASSERT_VOID_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XASSERT_VOID" -> "Xil_AssertVoid"
+*                       "Xil_AssertVoid_ALWAYS" -> "Xil_AssertVoidAlways"
+*                       "XAssertStatus" -> "Xil_AssertStatus"
+*                       "XAssertSetCallback" -> "Xil_AssertCallback"
+*
+*                       "XASSERT_OCCURRED" -> "XIL_ASSERT_OCCURRED"
+*                       "XASSERT_NONE" -> "XIL_ASSERT_NONE"
+*
+*                       "microblaze_disable_dcache" -> "Xil_DCacheDisable"
+*                       "microblaze_enable_dcache" -> "Xil_DCacheEnable"
+*                       "microblaze_enable_icache" -> "Xil_ICacheEnable"
+*                       "microblaze_disable_icache" -> "Xil_ICacheDisable"
+*                       "microblaze_init_dcache_range" -> "Xil_DCache
+*                                                        InvalidateRange"
+*
+*                       "XCache_DisableDCache" -> "Xil_DCacheDisable"
+*                       "XCache_DisableICache" -> "Xil_ICacheDisable"
+*                       "XCache_EnableDCache" -> "Xil_DCacheEnableRegion"
+*                       "XCache_EnableICache" -> "Xil_ICacheEnableRegion"
+*                       "XCache_InvalidateDCacheLine" -> "Xil_DCache
+*                                                             InvalidateRange"
+*
+*                       "XUtil_MemoryTest32" -> "Xil_TestMem32"
+*                       "XUtil_MemoryTest16" -> "Xil_TestMem16"
+*                       "XUtil_MemoryTest8" -> "Xil_TestMem8"
+*
+*                       "xutil.h" -> "xil_testmem.h"
+*
+*                       "xbasic_types.h" -> "xil_types.h"
+*                       "xio.h" -> "xil_io.h"
+*
+*                       "XIo_In32" -> "Xil_In32"
+*                       "XIo_Out32" -> "Xil_Out32"
+*
+*                       "XTRUE" -> "TRUE"
+*                       "XFALSE" -> "FALSE"
+*                       "XNULL" -> "NULL"
+*
+*                       "Xuint8" -> "u8"
+*                       "Xuint16" -> "u16"
+*                       "Xuint32" -> "u32"
+*                       "Xint8" -> "char"
+*                       "Xint16" -> "short"
+*                       "Xint32" -> "long"
+*                       "Xfloat32" -> "float"
+*                       "Xfloat64" -> "double"
+*                       "Xboolean" -> "int"
+*                       "XTEST_FAILED" -> "XST_FAILURE"
+*                       "XTEST_PASSED" -> "XST_SUCCESS"
+* 6.1   adk    08/23/14 Alligned doxygen tags.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xvtc.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the VTC core.
+*
+* This handler reads the pending interrupt from the IER/ISR, determines the
+* source of the interrupts, calls according callbacks and finally clears the
+* interrupts.
+*
+* The application is responsible for connecting this function to the interrupt
+* system. Application beyond this driver is also responsible for providing
+* callbacks to handle interrupts and installing the callbacks using
+* XVtc_SetCallBack() during initialization phase.
+*
+* @param	InstancePtr is a pointer to the XVtc instance that just
+*		interrupted.
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void XVtc_IntrHandler(void *InstancePtr)
+{
+	u32 PendingIntr;
+	u32 ErrorStatus;
+	XVtc *XVtcPtr = (XVtc *) InstancePtr;
+
+	/* Verify arguments. */
+	Xil_AssertVoid(XVtcPtr != NULL);
+	Xil_AssertVoid(XVtcPtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* Get pending interrupts */
+	PendingIntr = XVtc_IntrGetPending(XVtcPtr);
+
+	/* Clear pending interrupt(s) */
+	XVtc_IntrClear(XVtcPtr, PendingIntr);
+
+	/* Spurious interrupt has happened */
+	if (0 == (PendingIntr | XVTC_IXR_ALLINTR_MASK)) {
+		ErrorStatus = 0;
+		XVtcPtr->ErrCallBack(XVtcPtr->ErrRef, ErrorStatus);
+		return;
+	}
+
+	/* A generator event has happened */
+	if ((PendingIntr & XVTC_IXR_G_ALL_MASK))
+		XVtcPtr->GeneratorCallBack(XVtcPtr->GeneratorRef,
+		PendingIntr);
+
+	/* A detector event has happened */
+	if ((PendingIntr & XVTC_IXR_D_ALL_MASK))
+		XVtcPtr->DetectorCallBack(XVtcPtr->DetectorRef,
+		PendingIntr);
+
+	/* A frame sync is done */
+	if ((PendingIntr & XVTC_IXR_FSYNCALL_MASK))
+		XVtcPtr->FrameSyncCallBack(XVtcPtr->FrameSyncRef,
+		PendingIntr);
+
+	/* A signal lock is detected */
+	if ((PendingIntr & XVTC_IXR_LOCKALL_MASK))
+		XVtcPtr->LockCallBack(XVtcPtr->LockRef,
+		PendingIntr);
+}
+
+
+/*****************************************************************************/
+/**
+*
+* This routine installs an asynchronous callback function for the given
+* HandlerType:
+*
+* <pre>
+* HandlerType              Callback Function Type
+* -----------------------  --------------------------------------------------
+* XVTC_HANDLER_FRAMESYNC   XVtc_FrameSyncCallBack
+* XVTC_HANDLER_LOCK        XVtc_LockCallBack
+* XVTC_HANDLER_DETECTOR    XVtc_DetectorCallBack
+* XVTC_HANDLER_GENERATOR   XVtc_GeneratorCallBack
+* XVTC_HANDLER_ERROR       XVtc_ErrCallBack
+*
+* HandlerType              Invoked by this driver when:
+* -----------------------  --------------------------------------------------
+* XVTC_HANDLER_FRAMESYNC   A frame sync event happens
+* XVTC_HANDLER_LOCK        A signal lock event happens
+* XVTC_HANDLER_DETECTOR    A detector related event happens
+* XVTC_HANDLER_GENERATOR   A generator related event happens
+* XVTC_HANDLER_ERROR       An error condition happens
+* </pre>
+*
+* @param	InstancePtr is a pointer to the XVtc instance to be worked
+*		on.
+* @param	HandlerType specifies which callback is to be attached.
+* @param	CallBackFunc is the address of the callback function.
+* @param	CallBackRef is a user data item that will be passed to the
+*		callback function when it is invoked.
+*
+* @return
+*		- XST_SUCCESS when handler is installed.
+*		- XST_INVALID_PARAM when HandlerType is invalid.
+*
+* @note		Invoking this function for a handler that already has been
+*		installed replaces it with the new handler.
+*
+******************************************************************************/
+int XVtc_SetCallBack(XVtc *InstancePtr, u32 HandlerType,
+				void *CallBackFunc, void *CallBackRef)
+{
+
+	/* Verify arguments. */
+	Xil_AssertNonvoid(InstancePtr != NULL);
+	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+	/* For specific handler type assigning callback function reference */
+	switch (HandlerType) {
+	case XVTC_HANDLER_FRAMESYNC:
+		InstancePtr->FrameSyncCallBack =
+				(XVtc_CallBack) CallBackFunc;
+		InstancePtr->FrameSyncRef = CallBackRef;
+		break;
+
+	case XVTC_HANDLER_LOCK:
+		InstancePtr->LockCallBack = (XVtc_CallBack) CallBackFunc;
+		InstancePtr->LockRef = CallBackRef;
+		break;
+
+	case XVTC_HANDLER_DETECTOR:
+		InstancePtr->DetectorCallBack =
+				(XVtc_CallBack) CallBackFunc;
+		InstancePtr->DetectorRef = CallBackRef;
+		break;
+
+	case XVTC_HANDLER_GENERATOR:
+		InstancePtr->GeneratorCallBack =
+				(XVtc_CallBack) CallBackFunc;
+		InstancePtr->GeneratorRef = CallBackRef;
+		break;
+
+	case XVTC_HANDLER_ERROR:
+		InstancePtr->ErrCallBack =
+				(XVtc_ErrorCallBack) CallBackFunc;
+		InstancePtr->ErrRef = CallBackRef;
+		break;
+
+	default:
+		return XST_INVALID_PARAM;
+
+	}
+	return XST_SUCCESS;
+}
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_sinit.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_sinit.c
new file mode 100644
index 0000000..241b53e
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-tx/xvtc_sinit.c
@@ -0,0 +1,106 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xvtc_sinit.c
+* @addtogroup vtc_v7_2
+* @{
+*
+* This file contains static initialization methods for Xilinx VTC core.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00a xd     08/05/08 First release.
+* 1.01a xd     07/23/10 Added GIER; Added more h/w generic info into
+*                       xparameters.h. Feed callbacks with pending
+*                       interrupt info. Added Doxygen & Version support.
+* 3.00a cjm    08/01/12 Converted from xio.h to xil_io.h, translating
+*                       basic types, MB cache functions, exceptions and
+*                       assertions to xil_io format.
+*                       Replaced the following:
+*                       "Xuint16" -> "u16".
+* 6.1   adk    08/23/14 updated doxygen tags.
+* 7.1   als    08/11/16 Provide protection against driver inclusion in the
+*                       absence of VTC instantiation.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xvtc.h"
+
+/************************** Constant Definitions *****************************/
+
+#ifndef XPAR_XVTC_NUM_INSTANCES
+#define XPAR_XVTC_NUM_INSTANCES 0
+#endif
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function returns a reference to an XVtc_Config structure based on the
+* core id, <i>DeviceId</i>. The return value will refer to an entry in
+* the device configuration table defined in the xvtc_g.c file.
+*
+* @param	DeviceId is the unique core ID of the VTC core for the lookup
+*		operation.
+*
+* @return	XVtc_LookupConfig returns a reference to a config record in
+*		the configuration table (in xvtc_g.c) corresponding to
+*		<i>DeviceId</i>, or NULL if no match is found.
+*
+* @note		None.
+*
+******************************************************************************/
+XVtc_Config *XVtc_LookupConfig(u16 DeviceId)
+{
+	extern XVtc_Config XVtc_ConfigTable[];
+	XVtc_Config *CfgPtr = NULL;
+	int i;
+
+	/* Checking for device id for which instance it is matching */
+	for (i = 0; i < XPAR_XVTC_NUM_INSTANCES; i++) {
+		/* Assigning address of config table if both device ids
+		 * are matched
+		 */
+		if (XVtc_ConfigTable[i].DeviceId == DeviceId) {
+			CfgPtr = &XVtc_ConfigTable[i];
+			break;
+		}
+	}
+
+	return CfgPtr;
+}
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx_drm_hdmi.c b/drivers/staging/xilinx/hdmi/xilinx_drm_hdmi.c
new file mode 100644
index 0000000..1b7c68f
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx_drm_hdmi.c
@@ -0,0 +1,1243 @@
+/*
+ * Xilinx DRM HDMI encoder driver
+ *
+ * Copyright (C) 2016 Leon Woestenberg <leon@sidebranch.com>
+ * Copyright (C) 2014 Xilinx, Inc.
+ *
+ * Authors: Leon Woestenberg <leon@sidebranch.com>
+ *          Rohit Consul <rohitco@xilinx.com>
+ *
+ * Based on xilinx_drm_dp.c:
+ * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* if both both DEBUG and DEBUG_TRACE are defined, trace_printk() is used */
+//#define DEBUG
+//#define DEBUG_TRACE
+
+//#define DEBUG_MUTEX
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_encoder_slave.h>
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-zynqmp.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/sysfs.h>
+#include <linux/workqueue.h>
+#include <linux/gpio/consumer.h>
+
+#include "xilinx_drm_drv.h"
+#include "linux/phy/phy-vphy.h"
+
+/* baseline driver includes */
+#include "xilinx-hdmi-tx/xv_hdmitxss.h"
+
+
+#define NUM_SUBCORE_IRQ				2
+#define HDMI_MAX_LANES				4
+
+#define XVPHY_TXREFCLK_RDY_LOW		0
+#define XVPHY_TXREFCLK_RDY_HIGH		1
+
+/* select either trace or printk logging */
+#ifdef DEBUG_TRACE
+#define do_hdmi_dbg(format, ...) do { \
+  trace_printk("xlnx-hdmi-txss: " format, ##__VA_ARGS__); \
+} while(0)
+#else
+#define do_hdmi_dbg(format, ...) do { \
+  printk(KERN_DEBUG "xlnx-hdmi-txss: " format, ##__VA_ARGS__); \
+} while(0)
+#endif
+
+/* either enable or disable debugging */
+#ifdef DEBUG
+#  define hdmi_dbg(x...) do_hdmi_dbg(x)
+#else
+#  define hdmi_dbg(x...)
+#endif
+
+#if (defined(DEBUG_MUTEX) && defined(DEBUG))
+/* storage for source code line number where mutex was last locked, -1 otherwise */
+static int hdmi_mutex_line = -1;
+/* If mutex is locked, print the line number of where it was locked. lock the mutex.
+ * Please keep this macro on a single line, so that the C __LINE__ macro is correct.
+ */
+#  define hdmi_mutex_lock(x) do { if (mutex_is_locked(x)) { hdmi_dbg("@line %d waiting for mutex owner @line %d\n", __LINE__, hdmi_mutex_line); } mutex_lock(x); hdmi_mutex_line = __LINE__; } while(0)
+#  define hdmi_mutex_unlock(x) do { hdmi_mutex_line = -1; mutex_unlock(x); } while(0)
+/* non-debug variant */
+#else
+#  define hdmi_mutex_lock(x) mutex_lock(x)
+#  define hdmi_mutex_unlock(x) mutex_unlock(x)
+#endif
+
+/**
+ * struct xilinx_drm_hdmi - Xilinx HDMI core
+ * @encoder: pointer to the drm encoder structure
+ * @dev: device structure
+ * @iomem: device I/O memory for register access
+ * @dp_sub: DisplayPort subsystem
+ * @dpms: current dpms state
+ * @link_config: common link configuration between IP core and sink device
+ * @mode: current mode between IP core and sink device
+ * @train_set: set of training data
+ */
+struct xilinx_drm_hdmi {
+	struct drm_device *drm_dev;
+	struct drm_encoder *encoder;
+	struct device *dev;
+	void __iomem *iomem;
+
+	/* video streaming bus clock */
+	struct clk *clk;
+	struct clk *axi_lite_clk;
+
+	/* HDMI TXSS interrupt number */
+	int irq;
+	bool teardown;
+
+	struct phy *phy[HDMI_MAX_LANES];
+
+	/* mutex to prevent concurrent access to this structure */
+	struct mutex hdmi_mutex;
+	/* protects concurrent access from interrupt context */
+	spinlock_t irq_lock;
+	/* schedule (future) work */
+	struct workqueue_struct *work_queue;
+	struct delayed_work delayed_work_enable_hotplug;
+	/* input reference clock that we configure */
+	struct clk *tx_clk;
+
+	/* retimer that we configure by setting a clock rate */
+	struct clk *retimer_clk;
+
+	/* gpio to force phy freq. change */
+	struct gpio_desc *freqchg_gpio;
+
+	bool cable_connected;
+	bool hdmi_stream_up;
+	bool have_edid;
+	bool is_hdmi_20_sink;
+	int dpms;
+
+	XVidC_ColorFormat xvidc_colorfmt;
+	/* configuration for the baseline subsystem driver instance */
+	XV_HdmiTxSs_Config config;
+	/* bookkeeping for the baseline subsystem driver instance */
+	XV_HdmiTxSs xv_hdmitxss;
+	/* sub core interrupt status registers */
+	u32 IntrStatus[NUM_SUBCORE_IRQ];
+	/* pointer to xvphy */
+	XVphy *xvphy;
+};
+
+static inline struct xilinx_drm_hdmi *to_hdmi(struct drm_encoder *encoder)
+{
+	return to_encoder_slave(encoder)->slave_priv;
+}
+
+void HdmiTx_PioIntrHandler(XV_HdmiTx *InstancePtr);
+void HdmiTx_DdcIntrHandler(XV_HdmiTx *InstancePtr);
+void HdmiTx_AuxIntrHandler(XV_HdmiTx *InstancePtr);
+
+void XV_HdmiTxSs_IntrEnable(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+	XV_HdmiTx_PioIntrEnable(HdmiTxSsPtr->HdmiTxPtr);
+	XV_HdmiTx_DdcIntrEnable(HdmiTxSsPtr->HdmiTxPtr);
+}
+
+void XV_HdmiTxSs_IntrDisable(XV_HdmiTxSs *HdmiTxSsPtr)
+{
+	XV_HdmiTx_PioIntrDisable(HdmiTxSsPtr->HdmiTxPtr);
+	XV_HdmiTx_DdcIntrDisable(HdmiTxSsPtr->HdmiTxPtr);
+}
+
+/* XV_HdmiTx_IntrHandler */
+static irqreturn_t hdmitx_irq_handler(int irq, void *dev_id)
+{
+	struct xilinx_drm_hdmi *xhdmi;
+
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	unsigned long flags;
+
+	BUG_ON(!dev_id);
+	xhdmi = (struct xilinx_drm_hdmi *)dev_id;
+	HdmiTxSsPtr = (XV_HdmiTxSs *)&xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr->HdmiTxPtr);
+
+	if (HdmiTxSsPtr->IsReady != XIL_COMPONENT_IS_READY) {
+		printk(KERN_INFO "hdmitx_irq_handler(): HDMI TX SS is not initialized?!\n");
+	}
+
+	/* read status registers */
+	xhdmi->IntrStatus[0] = XV_HdmiTx_ReadReg(HdmiTxSsPtr->HdmiTxPtr->Config.BaseAddress, (XV_HDMITX_PIO_STA_OFFSET)) & (XV_HDMITX_PIO_STA_IRQ_MASK);
+	xhdmi->IntrStatus[1] = XV_HdmiTx_ReadReg(HdmiTxSsPtr->HdmiTxPtr->Config.BaseAddress, (XV_HDMITX_DDC_STA_OFFSET)) & (XV_HDMITX_DDC_STA_IRQ_MASK);
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	/* mask interrupt request */
+	XV_HdmiTxSs_IntrDisable(HdmiTxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	/* call bottom-half */
+	return IRQ_WAKE_THREAD;
+}
+
+/* (struct xilinx_drm_hdmi *)dev_id */
+static irqreturn_t hdmitx_irq_thread(int irq, void *dev_id)
+{
+	struct xilinx_drm_hdmi *xhdmi;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	unsigned long flags;
+
+	BUG_ON(!dev_id);
+	xhdmi = (struct xilinx_drm_hdmi *)dev_id;
+	if (!xhdmi) {
+		printk(KERN_INFO "irq_thread: !dev_id\n");
+		return IRQ_HANDLED;
+	}
+	/* driver is being torn down, do not process further interrupts */
+	if (xhdmi->teardown) {
+		printk(KERN_INFO "irq_thread: teardown\n");
+		return IRQ_HANDLED;
+	}
+	HdmiTxSsPtr = (XV_HdmiTxSs *)&xhdmi->xv_hdmitxss;
+
+	BUG_ON(!HdmiTxSsPtr->HdmiTxPtr);
+
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+
+	/* call baremetal interrupt handler, this in turn will
+	 * call the registed callbacks functions */
+	if (xhdmi->IntrStatus[0]) HdmiTx_PioIntrHandler(HdmiTxSsPtr->HdmiTxPtr);
+	if (xhdmi->IntrStatus[1]) HdmiTx_DdcIntrHandler(HdmiTxSsPtr->HdmiTxPtr);
+
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	/* unmask interrupt request */
+	XV_HdmiTxSs_IntrEnable(HdmiTxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+
+static void TxConnectCallback(void *CallbackRef)
+{
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)CallbackRef;
+	XV_HdmiTxSs *HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	XVphy *VphyPtr = xhdmi->xvphy;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiTxSsPtr);
+	BUG_ON(!VphyPtr);
+	BUG_ON(!xhdmi->phy[0]);
+	hdmi_dbg("TxConnectCallback()\n");
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+	if (HdmiTxSsPtr->IsStreamConnected) {
+		int xst_hdmi20;
+		xhdmi->cable_connected = 1;
+		/* Check HDMI sink version */
+		xst_hdmi20 = XV_HdmiTxSs_DetectHdmi20(HdmiTxSsPtr);
+		hdmi_dbg("TxConnectCallback(): TX connected to HDMI %s Sink Device\n",
+			(xst_hdmi20 == XST_SUCCESS)? "2.0": "1.4");
+		xhdmi->is_hdmi_20_sink = (xst_hdmi20 == XST_SUCCESS);
+		XVphy_IBufDsEnable(VphyPtr, 0, XVPHY_DIR_TX, (TRUE));
+	}
+	else {
+		hdmi_dbg("TxConnectCallback(): TX disconnected\n");
+		xhdmi->cable_connected = 0;
+		xhdmi->hdmi_stream_up = 0;
+		xhdmi->have_edid = 0;
+		xhdmi->is_hdmi_20_sink = 0;
+		XVphy_IBufDsEnable(VphyPtr, 0, XVPHY_DIR_TX, (FALSE));
+	}
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_dbg("TxConnectCallback() done\n");
+}
+
+static void TxStreamUpCallback(void *CallbackRef)
+{
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)CallbackRef;
+	XVphy *VphyPtr;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	XVidC_VideoStream *HdmiTxSsVidStreamPtr;
+	XVphy_PllType TxPllType;
+	u64 TxLineRate;
+
+	BUG_ON(!xhdmi);
+
+	HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	hdmi_dbg("TxStreamUpCallback(): TX stream is up\n");
+	xhdmi->hdmi_stream_up = 1;
+
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+	TxPllType = XVphy_GetPllType(VphyPtr, 0, XVPHY_DIR_TX, XVPHY_CHANNEL_ID_CH1);
+	if ((TxPllType == XVPHY_PLL_TYPE_CPLL)) {
+		TxLineRate = XVphy_GetLineRateHz(VphyPtr, 0, XVPHY_CHANNEL_ID_CH1);
+	}
+	else if((TxPllType == XVPHY_PLL_TYPE_QPLL) ||
+			(TxPllType == XVPHY_PLL_TYPE_QPLL0) ||
+			(TxPllType == XVPHY_PLL_TYPE_PLL0)) {
+		TxLineRate = XVphy_GetLineRateHz(VphyPtr, 0, XVPHY_CHANNEL_ID_CMN0);
+	}
+	else {
+		TxLineRate = XVphy_GetLineRateHz(VphyPtr, 0, XVPHY_CHANNEL_ID_CMN1);
+	}
+
+	/* configure an external retimer through a (virtual) CCF clock
+	 * (this was tested against the DP159 misc retimer driver) */
+	if (xhdmi->retimer_clk) {
+		hdmi_dbg("retimer: clk_set_rate(xhdmi->retimer_clk, TxLineRate=%lld\n", TxLineRate);
+		(void)clk_set_rate(xhdmi->retimer_clk, (signed long long)TxLineRate);
+	}
+
+	/* Enable TX TMDS clock*/
+	XVphy_Clkout1OBufTdsEnable(VphyPtr, XVPHY_DIR_TX, (TRUE));
+
+	/* Copy Sampling Rate */
+	XV_HdmiTxSs_SetSamplingRate(HdmiTxSsPtr, VphyPtr->HdmiTxSampleRate);
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+
+#ifdef DEBUG
+	HdmiTxSsVidStreamPtr = XV_HdmiTxSs_GetVideoStream(HdmiTxSsPtr);
+	XVidC_ReportStreamInfo(HdmiTxSsVidStreamPtr);
+#endif
+}
+
+static void TxStreamDownCallback(void *CallbackRef)
+{
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)CallbackRef;
+	XVphy *VphyPtr;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+
+	BUG_ON(!xhdmi);
+
+	HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	hdmi_dbg("TxStreamDownCallback(): TX stream is down\n\r");
+	xhdmi->hdmi_stream_up = 0;
+}
+
+static void TxVsCallback(void *CallbackRef)
+{
+	/* no op */
+}
+
+/* entered with vphy mutex taken */
+static void VphyHdmiTxInitCallback(void *CallbackRef)
+{
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)CallbackRef;
+	XVphy *VphyPtr;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	BUG_ON(!xhdmi);
+
+	HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	hdmi_dbg("VphyHdmiTxInitCallback(): XV_HdmiTxSs_RefClockChangeInit()\n");
+
+	/* a pair of mutexes must be locked in fixed order to prevent deadlock,
+	 * and the order is RX SS then XVPHY, so first unlock XVPHY then lock both */
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	XV_HdmiTxSs_RefClockChangeInit(HdmiTxSsPtr);
+
+	/* unlock RX SS but keep XVPHY locked */
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+	hdmi_dbg("VphyHdmiTxInitCallback() done\n");
+}
+
+/* entered with vphy mutex taken */
+static void VphyHdmiTxReadyCallback(void *CallbackRef)
+{
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)CallbackRef;
+	XVphy *VphyPtr;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	BUG_ON(!xhdmi);
+
+	HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	hdmi_dbg("VphyHdmiTxReadyCallback()\n");
+
+	/* a pair of mutexes must be locked in fixed order to prevent deadlock,
+	 * and the order is RX SS then XVPHY, so first unlock XVPHY then lock both */
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	/* unlock RX SS but keep XVPHY locked */
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+	hdmi_dbg("VphyHdmiTxReadyCallback() done\n");
+}
+
+/* drm_encoder_slave_funcs */
+static void xilinx_drm_hdmi_dpms(struct drm_encoder *encoder, int dpms)
+{
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+	hdmi_dbg("xilinx_drm_hdmi_dpms(dpms = %d)\n", dpms);
+
+	if (xhdmi->dpms == dpms) {
+		goto done;
+	}
+
+	xhdmi->dpms = dpms;
+
+	switch (dpms) {
+	case DRM_MODE_DPMS_ON:
+		/* power-up */
+		goto done;
+	default:
+		/* power-down */
+		goto done;
+	}
+done:
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+}
+
+static void xilinx_drm_hdmi_save(struct drm_encoder *encoder)
+{
+	/* no op */
+}
+
+static void xilinx_drm_hdmi_restore(struct drm_encoder *encoder)
+{
+	/* no op */
+}
+
+/* The HDMI C API requires the reference clock rate to be changed after setting the mode.
+ * However, DRM order is fixup(), set clock rate, than mode_set().
+ *
+ * Defining CHANGE_CLOCKRATE_LAST will do the actual mode set in the fixup(), and will
+ * make mode_set() a NOP. This way, the required HDMI C API requirement is met.
+ */
+#define CHANGE_CLOCKRATE_LAST
+
+#ifdef CHANGE_CLOCKRATE_LAST
+/* prototype */
+static void xilinx_drm_hdmi_mode_set(struct drm_encoder *encoder,
+				   struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode);
+#endif
+
+static bool xilinx_drm_hdmi_mode_fixup(struct drm_encoder *encoder,
+				     const struct drm_display_mode *mode,
+				     struct drm_display_mode *adjusted_mode)
+{
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	XVphy *VphyPtr;
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	/* @NOTE LEON: we are calling mode_set here, just before the reference clock is changed */
+
+	hdmi_dbg("xilinx_drm_hdmi_mode_fixup()\n");
+#ifdef CHANGE_CLOCKRATE_LAST
+	xilinx_drm_hdmi_mode_set(encoder, (struct drm_display_mode *)mode, adjusted_mode);
+#endif
+	return true;
+}
+
+/**
+ * xilinx_drm_hdmi_max_rate - Calculate and return available max pixel clock
+ * @link_rate: link rate (Kilo-bytes / sec)
+ * @lane_num: number of lanes
+ * @bpp: bits per pixel
+ *
+ * Return: max pixel clock (KHz) supported by current link config.
+ */
+static inline int xilinx_drm_hdmi_max_rate(int link_rate, u8 lane_num, u8 bpp)
+{
+	return link_rate * lane_num * 8 / bpp;
+}
+
+static int xilinx_drm_hdmi_mode_valid(struct drm_encoder *encoder,
+				    struct drm_display_mode *mode)
+{
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	int max_rate = 340 * 1000;
+	enum drm_mode_status status = MODE_OK;
+
+	hdmi_dbg("xilinx_drm_hdmi_mode_valid()\n");
+	drm_mode_debug_printmodeline(mode);
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+	/* HDMI 2.0 sink connected? */
+	if (xhdmi->is_hdmi_20_sink)
+		max_rate = 600 * 1000;
+	/* pixel clock too high for sink? */
+	if (mode->clock > max_rate)
+		status = MODE_CLOCK_HIGH;
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+	return status;
+}
+
+#ifdef CHANGE_CLOCKRATE_LAST
+static void xilinx_drm_hdmi_mode_set_nop(struct drm_encoder *encoder,
+				   struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	/* nop */
+}
+#endif
+
+static void xilinx_drm_hdmi_mode_set(struct drm_encoder *encoder,
+				   struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	XVidC_VideoTiming vt;
+	XVphy *VphyPtr;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	XVidC_VideoStream *HdmiTxSsVidStreamPtr;
+	u32 TmdsClock = 0;
+	u32 Result;
+	bool is_gpio_active_low;
+	XVidC_VideoMode VmId;
+
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	hdmi_dbg("xilinx_drm_hdmi_mode_set()\n");
+	BUG_ON(!xhdmi);
+
+	HdmiTxSsPtr = &xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	VphyPtr = xhdmi->xvphy;
+	BUG_ON(!VphyPtr);
+
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	drm_mode_debug_printmodeline(mode);
+
+	/* For every mode change phy tx_refxlk_rdy_en signal must be toggled
+	 * (asserted and de-asserted) to reset phy's internal frequency detection
+	 * state machine
+	 */
+	is_gpio_active_low = gpiod_is_active_low(xhdmi->freqchg_gpio);
+	hdmi_dbg("TxRef GPIO polarity: Active %s\n", is_gpio_active_low ? "Low" : "High");
+	
+	hdmi_dbg("force phy freq change event: TxRefClkRdy = Low\n");
+	gpiod_set_value_cansleep(xhdmi->freqchg_gpio, (is_gpio_active_low) ?
+				XVPHY_TXREFCLK_RDY_HIGH : XVPHY_TXREFCLK_RDY_LOW);
+
+#ifdef DEBUG
+	hdmi_dbg("mode->clock = %d\n", mode->clock * 1000);
+	hdmi_dbg("mode->crtc_clock = %d\n", mode->crtc_clock * 1000);
+
+
+	hdmi_dbg("mode->pvsync = %d\n",
+		!!(mode->flags & DRM_MODE_FLAG_PVSYNC));
+	hdmi_dbg("mode->phsync = %d\n",
+		!!(mode->flags & DRM_MODE_FLAG_PHSYNC));
+
+	hdmi_dbg("mode->hsync_end = %d\n", mode->hsync_end);
+	hdmi_dbg("mode->hsync_start = %d\n", mode->hsync_start);
+	hdmi_dbg("mode->vsync_end = %d\n", mode->vsync_end);
+	hdmi_dbg("mode->vsync_start = %d\n", mode->vsync_start);
+
+	hdmi_dbg("mode->hdisplay = %d\n", mode->hdisplay);
+	hdmi_dbg("mode->vdisplay = %d\n", mode->vdisplay);
+
+	hdmi_dbg("mode->htotal = %d\n", mode->htotal);
+	hdmi_dbg("mode->vtotal = %d\n", mode->vtotal);
+	hdmi_dbg("mode->vrefresh = %d\n", mode->vrefresh);
+#endif
+	/* see slide 20 of http://events.linuxfoundation.org/sites/events/files/slides/brezillon-drm-kms.pdf */
+	vt.HActive = mode->hdisplay;
+	vt.HFrontPorch = mode->hsync_start - mode->hdisplay;
+	vt.HSyncWidth = mode->hsync_end - mode->hsync_start;
+	vt.HBackPorch = mode->htotal - mode->hsync_end;
+	vt.HTotal = mode->htotal;
+	vt.HSyncPolarity = !!(mode->flags & DRM_MODE_FLAG_PHSYNC);
+
+	vt.VActive = mode->vdisplay;
+	/* Progressive timing data is stored in field 0 */
+	vt.F0PVFrontPorch = mode->vsync_start - mode->vdisplay;
+	vt.F0PVSyncWidth = mode->vsync_end - mode->vsync_start;
+	vt.F0PVBackPorch = mode->vtotal - mode->vsync_end;
+	vt.F0PVTotal = mode->vtotal;
+	/* Interlaced output is not support - set field 1 to 0 */
+	vt.F1VFrontPorch = 0;
+	vt.F1VSyncWidth = 0;
+	vt.F1VBackPorch = 0;
+	vt.F1VTotal = 0;
+	vt.VSyncPolarity = !!(mode->flags & DRM_MODE_FLAG_PVSYNC);
+
+	HdmiTxSsVidStreamPtr = XV_HdmiTxSs_GetVideoStream(HdmiTxSsPtr);
+
+	if (XVphy_IsBonded(VphyPtr, 0, XVPHY_CHANNEL_ID_CH1)) {
+		hdmi_dbg("Both the GT RX and GT TX are clocked by the RX reference clock.\n");
+		xvphy_mutex_unlock(xhdmi->phy[0]);
+		hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+		return;
+	}
+
+	/* Disable TX TDMS clock */
+	XVphy_Clkout1OBufTdsEnable(VphyPtr, XVPHY_DIR_TX, (FALSE));
+
+	VmId = XVidC_GetVideoModeIdWBlanking(&vt, mode->vrefresh, FALSE);
+
+	hdmi_dbg("VmId = %d\n", VmId);
+	if (VmId == XVIDC_VM_NOT_SUPPORTED) { //no match found in timing table
+		hdmi_dbg("Tx Video Mode not supported. Using DRM Timing\n");
+		VmId = XVIDC_VM_CUSTOM;
+		HdmiTxSsVidStreamPtr->FrameRate = mode->vrefresh;
+		HdmiTxSsVidStreamPtr->Timing = vt; //overwrite with drm detected timing
+		XVidC_ReportTiming(&HdmiTxSsVidStreamPtr->Timing, FALSE);
+	}
+	TmdsClock = XV_HdmiTxSs_SetStream(HdmiTxSsPtr, VmId, xhdmi->xvidc_colorfmt, XVIDC_BPC_8, NULL);
+
+	VphyPtr->HdmiTxRefClkHz = TmdsClock;
+	hdmi_dbg("(TmdsClock = %u, from XV_HdmiTxSs_SetStream())\n", TmdsClock);
+
+	hdmi_dbg("XVphy_SetHdmiTxParam(PixPerClk = %d, ColorDepth = %d, ColorFormatId=%d)\n",
+		(int)HdmiTxSsVidStreamPtr->PixPerClk, (int)HdmiTxSsVidStreamPtr->ColorDepth,
+		(int)HdmiTxSsVidStreamPtr->ColorFormatId);
+
+	// Set GT TX parameters, this might change VphyPtr->HdmiTxRefClkHz
+	Result = XVphy_SetHdmiTxParam(VphyPtr, 0, XVPHY_CHANNEL_ID_CHA,
+					HdmiTxSsVidStreamPtr->PixPerClk,
+					HdmiTxSsVidStreamPtr->ColorDepth,
+					HdmiTxSsVidStreamPtr->ColorFormatId);
+
+	if (Result == (XST_FAILURE)) {
+		hdmi_dbg("Unable to set requested TX video resolution.\n\r");
+		xvphy_mutex_unlock(xhdmi->phy[0]);
+		hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+		return;
+	}
+
+	/* Enable si5324 LOL signal (disable gpio override) */
+	hdmi_dbg("force phy freq change event: TxRefClkRdy = High\n");
+	gpiod_set_value_cansleep(xhdmi->freqchg_gpio, (is_gpio_active_low) ?
+				XVPHY_TXREFCLK_RDY_LOW : XVPHY_TXREFCLK_RDY_HIGH);
+
+	adjusted_mode->clock = VphyPtr->HdmiTxRefClkHz / 1000;
+	hdmi_dbg("adjusted_mode->clock = %u Hz\n", adjusted_mode->clock);
+
+	/* Disable RX clock forwarding */
+	XVphy_Clkout1OBufTdsEnable(VphyPtr, XVPHY_DIR_RX, (FALSE));
+
+	/* @NOTE in bare-metal, here the Si5324 clock is changed. If this mode_set()
+	 * is run from the fixup() call, we mimick that behaviour */
+#ifdef DEBUG
+	XV_HdmiTx_DebugInfo(HdmiTxSsPtr->HdmiTxPtr);
+	XVphy_HdmiDebugInfo(VphyPtr, 0, XVPHY_CHANNEL_ID_CHA);
+#endif	
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+}
+
+static enum drm_connector_status
+xilinx_drm_hdmi_detect(struct drm_encoder *encoder,
+		     struct drm_connector *connector)
+{
+	/* it takes HDMI 50 ms to detect connection on init */
+	static int first_time_ms = 50;
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	/* first time; wait 50 ms max until cable connected */
+	while (first_time_ms && !xhdmi->cable_connected) {
+		msleep(1);
+		first_time_ms--;
+	}
+	if (first_time_ms)
+	/* after first time, report immediately */
+	first_time_ms = 0;
+		hdmi_dbg("xilinx_drm_hdmi_detect() waited %d ms until connect.\n", 50 - first_time_ms);
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+	/* cable connected  */
+	if (xhdmi->cable_connected) {
+		hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+		hdmi_dbg("xilinx_drm_hdmi_detect() = connected\n");
+		return connector_status_connected;
+	}
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+	hdmi_dbg("xilinx_drm_hdmi_detect() = disconnected\n");
+	return connector_status_disconnected;
+}
+
+/* callback function for drm_do_get_edid(), used in xilinx_drm_hdmi_get_modes()
+ * through drm_do_get_edid() from drm/drm_edid.c.
+ *
+ * called with hdmi_mutex taken
+ *
+ * Return 0 on success, !0 otherwise
+ */
+static int xilinx_drm_hdmi_get_edid_block(void *data, u8 *buf, unsigned int block,
+				  size_t len)
+{
+	u8 *buffer;
+	struct xilinx_drm_hdmi *xhdmi = (struct xilinx_drm_hdmi *)data;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	int ret;
+
+	BUG_ON(!xhdmi);
+	/* out of bounds? */
+	if (((block * 128) + len) > 256) return -EINVAL;
+
+	buffer = kzalloc(256, GFP_KERNEL);
+	if (!buffer) return -ENOMEM;
+
+
+	HdmiTxSsPtr = (XV_HdmiTxSs *)&xhdmi->xv_hdmitxss;
+	BUG_ON(!HdmiTxSsPtr);
+
+	if (!HdmiTxSsPtr->IsStreamConnected) {
+		hdmi_dbg("xilinx_drm_hdmi_get_edid_block() stream is not connected\n");
+	}
+	/* first obtain edid in local buffer */
+	ret = XV_HdmiTxSs_ReadEdid(HdmiTxSsPtr, buffer);
+	if (ret == XST_FAILURE) {
+		hdmi_dbg("xilinx_drm_hdmi_get_edid_block() failed reading EDID\n");
+		return -EINVAL;
+	}
+
+	/* then copy the requested 128-byte block(s) */
+	memcpy(buf, buffer + block * 128, len);
+	/* free our local buffer */
+	kfree(buffer);
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Encoder operations
+ */
+static int xilinx_drm_hdmi_get_modes(struct drm_encoder *encoder,
+				   struct drm_connector *connector)
+{
+	struct xilinx_drm_hdmi *xhdmi = to_hdmi(encoder);
+	struct edid *edid = NULL;
+	int ret;
+
+	hdmi_dbg("xilinx_drm_hdmi_get_modes()\n");
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+
+	/* When the I2C adapter connected to the DDC bus is hidden behind a device that
+	* exposes a different interface to read EDID blocks this function can be used
+	* to get EDID data using a custom block read function. - from drm_edid.c
+	*/
+
+	/* private data hdmi is passed to xilinx_drm_hdmi_get_edid_block(data, ...) */
+	edid = drm_do_get_edid(connector, xilinx_drm_hdmi_get_edid_block, xhdmi);
+
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+	if (!edid) {
+		xhdmi->have_edid = 0;
+		dev_err(xhdmi->dev, "xilinx_drm_hdmi_get_modes() could not obtain edid, assume <= 1024x768 works.\n");
+		return 0;
+	}
+	xhdmi->have_edid = 1;
+
+	drm_mode_connector_update_edid_property(connector, edid);
+	ret = drm_add_edid_modes(connector, edid);
+	kfree(edid);
+	hdmi_dbg("xilinx_drm_hdmi_get_modes() done\n");
+
+	return ret;
+}
+
+static struct drm_encoder_slave_funcs xilinx_drm_hdmi_encoder_funcs = {
+	.dpms			= xilinx_drm_hdmi_dpms,
+	.save			= xilinx_drm_hdmi_save,
+	.restore		= xilinx_drm_hdmi_restore,
+	.mode_fixup		= xilinx_drm_hdmi_mode_fixup,
+	.mode_valid		= xilinx_drm_hdmi_mode_valid,
+#ifdef CHANGE_CLOCKRATE_LAST
+	.mode_set		= xilinx_drm_hdmi_mode_set_nop,
+#else
+	.mode_set		= xilinx_drm_hdmi_mode_set,
+#endif
+	.detect			= xilinx_drm_hdmi_detect,
+	.get_modes		= xilinx_drm_hdmi_get_modes,
+};
+
+/* forward declaration */
+static XV_HdmiTxSs_Config config;
+
+static int xilinx_drm_hdmi_encoder_init(struct platform_device *pdev,
+				      struct drm_device *dev,
+				      struct drm_encoder_slave *encoder)
+{
+	struct xilinx_drm_hdmi *xhdmi = platform_get_drvdata(pdev);
+	unsigned long flags;
+	XV_HdmiTxSs *HdmiTxSsPtr;
+	u32 Status;
+	int ret;
+
+	BUG_ON(!xhdmi);
+
+	hdmi_dbg("xilinx_drm_hdmi_encoder_init()\n");
+
+	encoder->slave_priv = xhdmi;
+	encoder->slave_funcs = &xilinx_drm_hdmi_encoder_funcs;
+
+	xhdmi->encoder = &encoder->base;
+	xhdmi->drm_dev = dev;
+
+	hdmi_mutex_lock(&xhdmi->hdmi_mutex);
+
+	HdmiTxSsPtr = (XV_HdmiTxSs *)&xhdmi->xv_hdmitxss;
+
+	BUG_ON(!HdmiTxSsPtr);
+
+	Status = XV_HdmiTxSs_CfgInitialize(HdmiTxSsPtr, &config, (uintptr_t)xhdmi->iomem);
+	if (Status != XST_SUCCESS)
+	{
+		dev_err(xhdmi->dev, "initialization failed with error %d\n", Status);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	XV_HdmiTxSs_IntrDisable(HdmiTxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	/* TX SS callback setup */
+	XV_HdmiTxSs_SetCallback(HdmiTxSsPtr, XV_HDMITXSS_HANDLER_CONNECT,
+		TxConnectCallback, (void *)xhdmi);
+	XV_HdmiTxSs_SetCallback(HdmiTxSsPtr, XV_HDMITXSS_HANDLER_VS,
+		TxVsCallback, (void *)xhdmi);
+	XV_HdmiTxSs_SetCallback(HdmiTxSsPtr, XV_HDMITXSS_HANDLER_STREAM_UP,
+		TxStreamUpCallback, (void *)xhdmi);
+	XV_HdmiTxSs_SetCallback(HdmiTxSsPtr, XV_HDMITXSS_HANDLER_STREAM_DOWN,
+		TxStreamDownCallback, (void *)xhdmi);
+
+	/* get a reference to the XVphy data structure */
+	xhdmi->xvphy = xvphy_get_xvphy(xhdmi->phy[0]);
+
+	BUG_ON(!xhdmi->xvphy);
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+	/* the callback is not specific to a single lane, but we need to
+	 * provide one of the phys as reference */
+	XVphy_SetHdmiCallback(xhdmi->xvphy, XVPHY_HDMI_HANDLER_TXINIT,
+		VphyHdmiTxInitCallback, (void *)xhdmi);
+
+	XVphy_SetHdmiCallback(xhdmi->xvphy, XVPHY_HDMI_HANDLER_TXREADY,
+		VphyHdmiTxReadyCallback, (void *)xhdmi);
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+
+	/* Request the interrupt */
+	ret = devm_request_threaded_irq(&pdev->dev, xhdmi->irq, hdmitx_irq_handler, hdmitx_irq_thread,
+		IRQF_TRIGGER_HIGH /*| IRQF_SHARED*/, "xilinx-hdmitxss", xhdmi/*dev_id*/);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", xhdmi->irq);
+		return ret;
+	}
+
+	hdmi_mutex_unlock(&xhdmi->hdmi_mutex);
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	XV_HdmiTxSs_IntrEnable(HdmiTxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	return 0;
+}
+
+static XV_HdmiTxSs_Config config =
+{
+	.DeviceId = 0,
+	.BaseAddress = 0,
+	.HighAddress = 0,
+	.Ppc = 2,
+	.MaxBitsPerPixel = 8,
+	.AxiLiteClkFreq = 50000000,
+	.HdcpTimer = {
+		.IsPresent = 0,
+		.DeviceId = 255,
+		.AbsAddr = 0
+	},
+	.Hdcp14 = {
+		.IsPresent = 0,
+		.DeviceId = 255,
+		.AbsAddr = 0
+	},
+	.Hdcp22 = {
+		.IsPresent = 0,
+		.DeviceId = 255,
+		.AbsAddr = 0
+	},
+	.HdmiTx = {
+		.IsPresent = 1,
+		.DeviceId = 0,
+		.AbsAddr = 0
+	},
+	.Vtc = {
+		.IsPresent = 1,
+		.DeviceId = 0,
+		.AbsAddr = 0,
+	},
+};
+
+/* Local Global table for all sub-core instance(s) configuration settings */
+XVtc_Config XVtc_ConfigTable[XPAR_XVTC_NUM_INSTANCES];
+XV_HdmiTx_Config XV_HdmiTx_ConfigTable[XPAR_XV_HDMITX_NUM_INSTANCES];
+
+/* Compute the absolute address by adding subsystem base address 
+   to sub-core offset */
+static int xhdmi_drm_subcore_AbsAddr(uintptr_t SubSys_BaseAddr,
+									 uintptr_t SubSys_HighAddr,
+									 uintptr_t SubCore_Offset,
+									 uintptr_t *SubCore_AbsAddr)
+{
+  int Status;
+  uintptr_t absAddr;
+
+  absAddr = SubSys_BaseAddr | SubCore_Offset;
+  if((absAddr>=SubSys_BaseAddr) && (absAddr<=SubSys_HighAddr)) {
+    *SubCore_AbsAddr = absAddr;
+    Status = XST_SUCCESS;
+  } else {
+    *SubCore_AbsAddr = 0;
+    Status = XST_FAILURE;
+  }
+
+  return(Status);
+}
+
+/* Each sub-core within the subsystem has defined offset read from
+   device-tree. */
+static int xhdmi_drm_compute_subcore_AbsAddr(uintptr_t SubSys_BaseAddr, 
+                                             uintptr_t SubSys_HighAddr )
+{
+	int ret;
+	
+	/* Subcore: Tx */
+	ret = xhdmi_drm_subcore_AbsAddr(SubSys_BaseAddr,
+									SubSys_HighAddr,
+									config.HdmiTx.AbsAddr,
+									&config.HdmiTx.AbsAddr);
+	if (ret != XST_SUCCESS) {
+	   hdmi_dbg("hdmitx sub-core address out-of range\n");
+	   return -EFAULT;
+	}
+	
+	/* Subcore: Vtc */
+	ret = xhdmi_drm_subcore_AbsAddr(SubSys_BaseAddr,
+									SubSys_HighAddr,
+									config.Vtc.AbsAddr,
+									&config.Vtc.AbsAddr);
+	if (ret != XST_SUCCESS) {
+	   hdmi_dbg("vtc sub-core address out-of range\n");
+	   return -EFAULT;
+	}
+	
+	return (ret);
+}
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int instance = 0;
+/* TX uses [1, 127] and RX uses [128, 254] */
+/* The HDCP22 timer uses an additional offset of +64 */
+#define TX_DEVICE_ID_BASE 1
+
+static int xilinx_drm_hdmi_parse_of(struct xilinx_drm_hdmi *xhdmi, XV_HdmiTxSs_Config *config)
+{
+	struct device *dev = xhdmi->dev;
+	struct device_node *node = dev->of_node;
+	int rc;
+	u32 val;
+	const char *format;
+
+	rc = of_property_read_u32(node, "xlnx,input-pixels-per-clock", &val);
+	if (rc < 0)
+		goto error_dt;
+	config->Ppc = val;
+
+	rc = of_property_read_u32(node, "xlnx,max-bits-per-component", &val);
+	if (rc < 0)
+		goto error_dt;
+	config->MaxBitsPerPixel = val;
+
+	rc = of_property_read_u32(node, "xlnx,hdmi-tx-offset", &val);
+	if (rc == 0) {
+		config->HdmiTx.DeviceId = TX_DEVICE_ID_BASE + instance;
+		config->HdmiTx.IsPresent = 1; 
+ 		config->HdmiTx.AbsAddr = val; 
+		XV_HdmiTx_ConfigTable[instance].DeviceId = TX_DEVICE_ID_BASE + instance;
+		XV_HdmiTx_ConfigTable[instance].BaseAddress = val;
+	}
+	
+	rc = of_property_read_u32(node, "xlnx,vtc-offset", &val);
+	if (rc < 0) {
+		hdmi_dbg("Not using an internal VTC.");
+		config->Vtc.IsPresent = 0;
+	} else if (rc == 0) {
+		config->Vtc.IsPresent = 1;
+		config->Vtc.DeviceId = TX_DEVICE_ID_BASE + instance;
+		config->Vtc.AbsAddr = val;
+		XVtc_ConfigTable[instance].DeviceId = config->Vtc.DeviceId;
+		XVtc_ConfigTable[instance].BaseAddress = val;
+	}
+
+	/* NOTE new */
+	rc = of_property_read_string(node, "xlnx,output-fmt", &format);
+	if (rc < 0) {
+		dev_err(xhdmi->dev, "xlnx,output-fmt must be specified\n");
+		goto error_dt;
+	} else
+	if (strcmp(format, "rgb") == 0) {
+		xhdmi->xvidc_colorfmt = XVIDC_CSF_RGB;
+	} else if (strcmp(format, "yuv444") == 0) {
+		xhdmi->xvidc_colorfmt = XVIDC_CSF_YCRCB_444;
+	} else if (strcmp(format, "yuv422") == 0) {
+		xhdmi->xvidc_colorfmt = XVIDC_CSF_YCRCB_422;
+	} else if (strcmp(format, "yuv420") == 0) {
+		xhdmi->xvidc_colorfmt = XVIDC_CSF_YCRCB_420;
+	} else {
+		dev_err(xhdmi->dev, "Unsupported xlnx,pixel-format\n");
+		goto error_dt;
+	}
+
+	return 0;
+
+error_dt:
+	dev_err(xhdmi->dev, "Error parsing device tree");
+	return rc;
+}
+
+static int xilinx_drm_hdmi_probe(struct platform_device *pdev)
+{
+	struct xilinx_drm_hdmi *xhdmi;
+	int ret;
+	unsigned int index;
+	struct resource *res;
+	unsigned long axi_clk_rate;
+
+	hdmi_dbg("hdmi-tx probed\n");
+	/* allocate zeroed HDMI TX device structure */
+	xhdmi = devm_kzalloc(&pdev->dev, sizeof(*xhdmi), GFP_KERNEL);
+	if (!xhdmi)
+		return -ENOMEM;
+	/* store pointer of the real device inside platform device */
+	xhdmi->dev = &pdev->dev;
+
+	/* mutex that protects against concurrent access */
+	mutex_init(&xhdmi->hdmi_mutex);
+	spin_lock_init(&xhdmi->irq_lock);
+	/* work queues */
+	xhdmi->work_queue = create_singlethread_workqueue("xilinx-hdmi-tx");
+	if (!xhdmi->work_queue) {
+		dev_err(xhdmi->dev, "Could not create work queue\n");
+		return -ENOMEM;
+	}
+
+	hdmi_dbg("xilinx_drm_hdmi DT parse start\n");
+	/* parse open firmware device tree data */
+	ret = xilinx_drm_hdmi_parse_of(xhdmi, &config);
+	if (ret < 0)
+		return ret;
+	hdmi_dbg("xilinx_drm_hdmi DT parse done\n");
+
+	for (index = 0; index < 3; index++)
+	{
+		char phy_name[16];
+		snprintf(phy_name, sizeof(phy_name), "hdmi-phy%d", index);
+		xhdmi->phy[index] = devm_phy_get(xhdmi->dev, phy_name);
+		if (IS_ERR(xhdmi->phy[index])) {
+			ret = PTR_ERR(xhdmi->phy[index]);
+			xhdmi->phy[index] = NULL;
+			if (ret == -EPROBE_DEFER) {
+				hdmi_dbg("xvphy not ready -EPROBE_DEFER\n");
+				return ret;
+			}
+			if (ret != -EPROBE_DEFER)
+				dev_err(xhdmi->dev, "failed to get phy lane %s index %d, error %d\n",
+					phy_name, index, ret);
+			goto error_phy;
+		}
+
+		ret = phy_init(xhdmi->phy[index]);
+		if (ret) {
+			dev_err(xhdmi->dev,
+				"failed to init phy lane %d\n", index);
+			goto error_phy;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xhdmi->iomem = devm_ioremap_resource(xhdmi->dev, res);
+	if (IS_ERR(xhdmi->iomem))
+		return PTR_ERR(xhdmi->iomem);
+
+	config.BaseAddress = (uintptr_t)xhdmi->iomem;
+	config.HighAddress = config.BaseAddress + resource_size(res) - 1;
+	
+	/* Compute sub-core AbsAddres */
+	ret = xhdmi_drm_compute_subcore_AbsAddr(config.BaseAddress,
+										    config.HighAddress);
+	if (ret == -EFAULT) {
+	   dev_err(xhdmi->dev, "hdmi-tx sub-core address out-of range\n");
+	   return ret;
+	}
+
+	/* video streaming bus clock */
+	xhdmi->clk = devm_clk_get(xhdmi->dev, "video");
+	if (IS_ERR(xhdmi->clk)) {
+		ret = PTR_ERR(xhdmi->clk);
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("video-clk not ready -EPROBE_DEFER\n");		
+		if (ret != -EPROBE_DEFER)
+			dev_err(xhdmi->dev, "failed to get video clk\n");
+		return ret;
+	}
+
+	clk_prepare_enable(xhdmi->clk);
+
+	/* AXI lite register bus clock */
+	xhdmi->axi_lite_clk = devm_clk_get(xhdmi->dev, "axi-lite");
+	if (IS_ERR(xhdmi->axi_lite_clk)) {
+		ret = PTR_ERR(xhdmi->clk);
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("axi-lite-clk not ready -EPROBE_DEFER\n");
+		if (ret != -EPROBE_DEFER)
+			dev_err(xhdmi->dev, "failed to get axi-lite clk\n");
+		return ret;
+	}
+
+	clk_prepare_enable(xhdmi->axi_lite_clk);
+	axi_clk_rate = clk_get_rate(xhdmi->axi_lite_clk);
+	hdmi_dbg("axi_clk_rate = %lu Hz\n", axi_clk_rate);
+	config.AxiLiteClkFreq = axi_clk_rate;
+
+	/* get irq */
+	xhdmi->irq = platform_get_irq(pdev, 0);
+	if (xhdmi->irq <= 0) {
+		dev_err(&pdev->dev, "platform_get_irq() failed\n");
+		destroy_workqueue(xhdmi->work_queue);
+		return xhdmi->irq;
+	}
+
+	/* support to drive an external retimer IC on the TX path, depending on TX clock line rate */
+	xhdmi->retimer_clk = devm_clk_get(&pdev->dev, "retimer-clk");
+	if (IS_ERR(xhdmi->retimer_clk)) {
+		ret = PTR_ERR(xhdmi->retimer_clk);
+		xhdmi->retimer_clk = NULL;
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("retimer-clk not ready -EPROBE_DEFER\n");
+		if (ret != -EPROBE_DEFER)
+			hdmi_dbg("Did not find a retimer-clk, not driving an external retimer device driver.\n");
+		return ret;
+	} else if (xhdmi->retimer_clk) {
+		hdmi_dbg("got retimer-clk\n");
+		ret = clk_prepare_enable(xhdmi->retimer_clk);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable retimer-clk\n");
+			return ret;
+		}
+		hdmi_dbg("prepared and enabled retimer-clk\n");
+	} else {
+		hdmi_dbg("no retimer clk specified, assuming no redriver/retimer is used.\n");
+	}
+
+	/* Get gpio to trigger phy freq. change (overrides si53xx LOL output) */
+	xhdmi->freqchg_gpio = devm_gpiod_get(&pdev->dev, "tx_refclk_rdy_en", GPIOD_OUT_HIGH);
+
+	if (IS_ERR(xhdmi->freqchg_gpio)) {
+		ret = (IS_ERR(xhdmi->freqchg_gpio));
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("gpio tx_refclk_rdy_en not ready -EPROBE_DEFER\n");
+		if (ret != EPROBE_DEFER)
+			dev_err(&pdev->dev, "ERROR failed to locate gpio tx_refclk_rdy_en in dt\n");
+		return ret;
+	}
+
+	/* default disable override */
+	gpiod_set_value_cansleep(xhdmi->freqchg_gpio, XVPHY_TXREFCLK_RDY_HIGH);
+	hdmi_dbg("acquired tx_refclk_rdy_en gpio\n");
+
+	platform_set_drvdata(pdev, xhdmi);
+
+	/* remainder of initialization is in encoder_init() */
+	hdmi_dbg("hdmi-tx probe successful\n");
+	/* probe has succeeded for this instance, increment instance index */
+	instance++;
+	return 0;
+error_phy:
+	return ret;
+}
+
+static int xilinx_drm_hdmi_remove(struct platform_device *pdev)
+{
+	struct xilinx_drm_hdmi *xhdmi = platform_get_drvdata(pdev);
+	if (xhdmi->work_queue) destroy_workqueue(xhdmi->work_queue);
+	return 0;
+}
+
+static const struct of_device_id xilinx_drm_hdmi_of_match[] = {
+	{ .compatible = "xlnx,v-hdmi-tx-ss-2.0", },
+	{ /* end of table */ },
+};
+MODULE_DEVICE_TABLE(of, xilinx_drm_hdmi_of_match);
+
+static struct drm_platform_encoder_driver xilinx_drm_hdmi_driver = {
+	.platform_driver = {
+		.probe			= xilinx_drm_hdmi_probe,
+		.remove			= xilinx_drm_hdmi_remove,
+		.driver			= {
+			.owner		= THIS_MODULE,
+			.name		= "xilinx-drm-hdmi",
+			.of_match_table	= xilinx_drm_hdmi_of_match,
+		},
+	},
+	.encoder_init = xilinx_drm_hdmi_encoder_init,
+};
+
+static int __init xilinx_drm_hdmi_init(void)
+{
+	return platform_driver_register(&xilinx_drm_hdmi_driver.platform_driver);
+}
+
+static void __exit xilinx_drm_hdmi_exit(void)
+{
+	platform_driver_unregister(&xilinx_drm_hdmi_driver.platform_driver);
+}
+
+module_init(xilinx_drm_hdmi_init);
+module_exit(xilinx_drm_hdmi_exit);
+
+MODULE_AUTHOR("Leon Woestenberg <leon@sidebranch.com>");
+MODULE_DESCRIPTION("Xilinx DRM KMS HDMI Driver");
+MODULE_LICENSE("GPL v2");
-- 
1.7.5.4

