From 56df499de21459c8f5e2859323038c46e6f4b418 Mon Sep 17 00:00:00 2001
From: Rohit Consul <rohitco@xilinx.com>
Date: Fri, 5 May 2017 11:39:51 -0700
Subject: [PATCH 1541/1566] media: xilinx-hdmi-rx: Initial release of xilinx
 hdmi-rx soft IP driver

commit  c7411816e42074e95f4172fa006408f76294af04 from
https://github.com/Xilinx/linux-xlnx.git

The HDMI 1.4/2.0 Receiver Subsystem is a feature-rich soft IP incorporating all
the necessary logic to properly interface with PHY layers and provide HDMI
decoding functionality. The subsystem is a hierarchical IP that bundles a
collection of HDMI RX-related IP sub-cores and outputs them as a single IP.
The subsystem receives the captured TMDS data from the video PHY layer. It then
extracts the video and audio streams from the HDMI stream and converts it to AXI
video and audio streams

Driver is being released in staging area and is in experimental state

Signed-off-by: Rohit Consul <rohitco@xilinx.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/sleep.h |   34 +
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xdebug.h    |   32 +
 .../xilinx/hdmi/xilinx-hdmi-rx/xil_assert.h        |   90 +
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xil_io.h    |   72 +
 .../xilinx/hdmi/xilinx-hdmi-rx/xil_printf.h        |   49 +
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xil_types.h |  200 ++
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xstatus.h   |  519 +++++
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.c | 1652 ++++++++++++++++
 .../staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.h | 1230 ++++++++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_hw.h      |  370 ++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_intr.c    |  892 +++++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_sinit.c   |   93 +
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.c    |  567 ++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.h    |  176 ++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.c       | 1774 +++++++++++++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.h       |  475 +++++
 .../hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.c     |  670 +++++++
 .../hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.h     |   67 +
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_hdcp.c  | 2032 ++++++++++++++++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_log.c   |  273 +++
 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc.h |  542 ++++++
 .../xilinx/hdmi/xilinx-hdmi-rx/xvidc_edid.h        |  468 +++++
 drivers/staging/xilinx/hdmi/xilinx-hdmirx.c        | 1280 ++++++++++++
 23 files changed, 13557 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/sleep.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xdebug.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_assert.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_io.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_printf.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_types.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xstatus.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_hw.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_intr.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_sinit.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_hdcp.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_log.c
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc_edid.h
 create mode 100644 drivers/staging/xilinx/hdmi/xilinx-hdmirx.c

diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/sleep.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/sleep.h
new file mode 100644
index 0000000..363ab8b
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/sleep.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+
+#ifndef SLEEP_H
+#define SLEEP_H
+
+#include "xil_types.h"
+#include "xil_io.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int usleep(unsigned long useconds);
+unsigned sleep(unsigned int seconds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xdebug.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xdebug.h
new file mode 100644
index 0000000..650946b
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xdebug.h
@@ -0,0 +1,32 @@
+#ifndef XDEBUG  /* prevent circular inclusions */
+#define XDEBUG  /* by using protection macros */
+
+#if defined(DEBUG) && !defined(NDEBUG)
+
+#ifndef XDEBUG_WARNING
+#define XDEBUG_WARNING
+#warning DEBUG is enabled
+#endif
+
+int printf(const char *format, ...);
+
+#define XDBG_DEBUG_ERROR             0x00000001U    /* error  condition messages */
+#define XDBG_DEBUG_GENERAL           0x00000002U    /* general debug  messages */
+#define XDBG_DEBUG_ALL               0xFFFFFFFFU    /* all debugging data */
+
+#define xdbg_current_types (XDBG_DEBUG_GENERAL)
+
+#define xdbg_stmnt(x)  x
+
+#define xdbg_printf(type, ...) (((type) & xdbg_current_types) ? printf (__VA_ARGS__) : 0)
+
+
+#else /* defined(DEBUG) && !defined(NDEBUG) */
+
+#define xdbg_stmnt(x)
+
+#define xdbg_printf(...)
+
+#endif /* defined(DEBUG) && !defined(NDEBUG) */
+
+#endif /* XDEBUG */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_assert.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_assert.h
new file mode 100644
index 0000000..c9c8475
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_assert.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+*
+* Copyright (C) 2009 - 2015 Xilinx, Inc. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* Use of the Software is limited solely to applications:
+* (a) running on a Xilinx device, or
+* (b) that interact with a Xilinx device through a bus or interconnect.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE.
+*
+* Except as contained in this notice, the name of the Xilinx shall not be used
+* in advertising or otherwise to promote the sale, use or other dealings in
+* this Software without prior written authorization from Xilinx.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_assert.h
+*
+* This file contains assert related functions.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_ASSERT_H	/* prevent circular inclusions */
+#define XIL_ASSERT_H	/* by using protection macros */
+
+#include "xil_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+
+/************************** Constant Definitions *****************************/
+
+#define XIL_ASSERT_NONE     0U
+#define XIL_ASSERT_OCCURRED 1U
+#define XNULL NULL
+
+/**
+ * This data type defines a callback to be invoked when an
+ * assert occurs. The callback is invoked only when asserts are enabled
+ */
+//typedef void (*Xil_AssertCallback) (const char8 *File, s32 Line);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+//#define Xil_Assert(const char8 *File, s32 Line)
+//#define Xil_AssertSetCallback(Xil_AssertCallback Routine)
+
+#define Xil_AssertVoid(Expression)
+#define Xil_AssertVoidAlways()
+#define Xil_AssertNonvoid(Expression)
+#define Xil_AssertNonvoidAlways()
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_io.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_io.h
new file mode 100644
index 0000000..3b24af4
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_io.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+*
+* Copyright (C) 2014 - 2015 Xilinx, Inc. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* Use of the Software is limited solely to applications:
+* (a) running on a Xilinx device, or
+* (b) that interact with a Xilinx device through a bus or interconnect.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE.
+*
+* Except as contained in this notice, the name of the Xilinx shall not be used
+* in advertising or otherwise to promote the sale, use or other dealings in
+* this Software without prior written authorization from Xilinx.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_io.h
+*
+* This file contains the interface for the general IO component, which
+* encapsulates the Input/Output functions for processors that do not
+* require any special I/O handling.
+*
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who      Date     Changes
+* ----- -------- -------- -----------------------------------------------
+* 5.00 	pkp  	 05/29/14 First release
+* </pre>
+******************************************************************************/
+
+#ifndef XIL_IO_H           /* prevent circular inclusions */
+#define XIL_IO_H           /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_types.h"
+#include <linux/io.h>
+
+static inline void Xil_Out32(INTPTR Addr, u32 Value)
+{
+	iowrite32(Value, (volatile void *)Addr);
+}
+static inline u32 Xil_In32(INTPTR Addr)
+{
+	return ioread32((const volatile void *)Addr);
+}
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_printf.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_printf.h
new file mode 100644
index 0000000..1529cf6
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_printf.h
@@ -0,0 +1,49 @@
+ #ifndef XIL_PRINTF_H
+ #define XIL_PRINTF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __KERNEL__
+#include <ctype.h>
+#include <string.h>
+#include <stdarg.h>
+#endif
+#include "xil_types.h"
+
+/*----------------------------------------------------*/
+/* Use the following parameter passing structure to   */
+/* make xil_printf re-entrant.                        */
+/*----------------------------------------------------*/
+
+struct params_s;
+
+
+/*---------------------------------------------------*/
+/* The purpose of this routine is to output data the */
+/* same as the standard printf function without the  */
+/* overhead most run-time libraries involve. Usually */
+/* the printf brings in many kilobytes of code and   */
+/* that is unacceptable in most embedded systems.    */
+/*---------------------------------------------------*/
+
+typedef char8* charptr;
+typedef s32 (*func_ptr)(int c);
+
+/*                                                   */
+
+void xil_printf( const char8 *ctrl1, ...);
+void print( const char8 *ptr);
+extern void outbyte (char8 c);
+extern char8 inbyte(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <linux/module.h> 
+#define xil_printf(format, ...) printk(KERN_INFO format, ## __VA_ARGS__) 
+#define print(format) printk(KERN_INFO format)
+
+#endif	/* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_types.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_types.h
new file mode 100644
index 0000000..f1dc072
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xil_types.h
@@ -0,0 +1,200 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_types.h
+*
+* @addtogroup common_types Basic Data types for Xilinx&reg; Software IP
+*
+* The xil_types.h file contains basic types for Xilinx software IP. These data types
+* are applicable for all processors supported by Xilinx.
+* @{
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* 3.03a sdm  05/30/11 Added Xuint64 typedef and XUINT64_MSW/XUINT64_LSW macros
+* 5.00 	pkp  05/29/14 Made changes for 64 bit architecture
+*	srt  07/14/14 Use standard definitions from stdint.h and stddef.h
+*		      Define LONG and ULONG datatypes and mask values
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_TYPES_H	/* prevent circular inclusions */
+#define XIL_TYPES_H	/* by using protection macros */
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#include <stddef.h>
+#endif
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#  define TRUE		1U
+#endif
+
+#ifndef FALSE
+#  define FALSE		0U
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define XIL_COMPONENT_IS_READY     0x11111111U  /**< In device drivers, This macro will be
+                                                 assigend to "IsReady" member of driver
+												 instance to indicate that driver
+												 instance is initialized and ready to use. */
+#define XIL_COMPONENT_IS_STARTED   0x22222222U  /**< In device drivers, This macro will be assigend to
+                                                 "IsStarted" member of driver instance
+												 to indicate that driver instance is
+												 started and it can be enabled. */
+
+/* @name New types
+ * New simple types.
+ * @{
+ */
+#ifndef __KERNEL__
+#ifndef XBASIC_TYPES_H
+/*
+ * guarded against xbasic_types.h.
+ */
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+/** @}*/
+#define __XUINT64__
+typedef struct
+{
+	u32 Upper;
+	u32 Lower;
+} Xuint64;
+
+
+/*****************************************************************************/
+/**
+* @brief    Return the most significant half of the 64 bit data type.
+*
+* @param    x is the 64 bit word.
+*
+* @return   The upper 32 bits of the 64 bit word.
+*
+******************************************************************************/
+#define XUINT64_MSW(x) ((x).Upper)
+
+/*****************************************************************************/
+/**
+* @brief    Return the least significant half of the 64 bit data type.
+*
+* @param    x is the 64 bit word.
+*
+* @return   The lower 32 bits of the 64 bit word.
+*
+******************************************************************************/
+#define XUINT64_LSW(x) ((x).Lower)
+
+#endif /* XBASIC_TYPES_H */
+
+/*
+ * xbasic_types.h does not typedef s* or u64
+ */
+/** @{ */
+typedef char char8;
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+typedef uint64_t u64;
+typedef int sint32;
+
+typedef intptr_t INTPTR;
+typedef uintptr_t UINTPTR;
+typedef ptrdiff_t PTRDIFF;
+/** @}*/
+#if !defined(LONG) || !defined(ULONG)
+typedef long LONG;
+typedef unsigned long ULONG;
+#endif
+
+#define ULONG64_HI_MASK	0xFFFFFFFF00000000U
+#define ULONG64_LO_MASK	~ULONG64_HI_MASK
+
+#else
+#include <linux/types.h>
+// Used by xil_io.h
+typedef char char8;
+typedef long INTPTR;
+typedef uintptr_t UINTPTR;
+typedef ptrdiff_t PTRDIFF;
+#endif
+
+/** @{ */
+/**
+ * This data type defines an interrupt handler for a device.
+ * The argument points to the instance of the component
+ */
+typedef void (*XInterruptHandler) (void *InstancePtr);
+
+/**
+ * This data type defines an exception handler for a processor.
+ * The argument points to the instance of the component
+ */
+typedef void (*XExceptionHandler) (void *InstancePtr);
+
+/**
+ * @brief  Returns 32-63 bits of a number.
+ * @param  n : Number being accessed.
+ * @return Bits 32-63 of number.
+ *
+ * @note    A basic shift-right of a 64- or 32-bit quantity.
+ *          Use this to suppress the "right shift count >= width of type"
+ *          warning when that quantity is 32-bits.
+ */
+#define UPPER_32_BITS(n) ((u32)(((n) >> 16) >> 16))
+
+/**
+ * @brief  Returns 0-31 bits of a number
+ * @param  n : Number being accessed.
+ * @return Bits 0-31 of number
+ */
+#define LOWER_32_BITS(n) ((u32)(n))
+
+
+
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#define TRUE		1U
+#endif
+
+#ifndef FALSE
+#define FALSE		0U
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#endif	/* end of protection macro */
+/**
+* @} End of "addtogroup common_types".
+*/
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xstatus.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xstatus.h
new file mode 100644
index 0000000..5f4835f
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xstatus.h
@@ -0,0 +1,519 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xstatus.h
+*
+* @addtogroup common_status_codes Xilinx&reg; software status codes
+*
+* The xstatus.h file contains the Xilinx&reg; software status codes.These codes are
+* used throughout the Xilinx device drivers.
+*
+* @{
+******************************************************************************/
+
+#ifndef XSTATUS_H		/* prevent circular inclusions */
+#define XSTATUS_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_types.h"
+#include "xil_assert.h"
+
+/************************** Constant Definitions *****************************/
+
+/*********************** Common statuses 0 - 500 *****************************/
+/**
+@name Common Status Codes for All Device Drivers
+@{
+*/
+#define XST_SUCCESS                     0L
+#define XST_FAILURE                     1L
+#define XST_DEVICE_NOT_FOUND            2L
+#define XST_DEVICE_BLOCK_NOT_FOUND      3L
+#define XST_INVALID_VERSION             4L
+#define XST_DEVICE_IS_STARTED           5L
+#define XST_DEVICE_IS_STOPPED           6L
+#define XST_FIFO_ERROR                  7L	/*!< An error occurred during an
+						   operation with a FIFO such as
+						   an underrun or overrun, this
+						   error requires the device to
+						   be reset */
+#define XST_RESET_ERROR                 8L	/*!< An error occurred which requires
+						   the device to be reset */
+#define XST_DMA_ERROR                   9L	/*!< A DMA error occurred, this error
+						   typically requires the device
+						   using the DMA to be reset */
+#define XST_NOT_POLLED                  10L	/*!< The device is not configured for
+						   polled mode operation */
+#define XST_FIFO_NO_ROOM                11L	/*!< A FIFO did not have room to put
+						   the specified data into */
+#define XST_BUFFER_TOO_SMALL            12L	/*!< The buffer is not large enough
+						   to hold the expected data */
+#define XST_NO_DATA                     13L	/*!< There was no data available */
+#define XST_REGISTER_ERROR              14L	/*!< A register did not contain the
+						   expected value */
+#define XST_INVALID_PARAM               15L	/*!< An invalid parameter was passed
+						   into the function */
+#define XST_NOT_SGDMA                   16L	/*!< The device is not configured for
+						   scatter-gather DMA operation */
+#define XST_LOOPBACK_ERROR              17L	/*!< A loopback test failed */
+#define XST_NO_CALLBACK                 18L	/*!< A callback has not yet been
+						   registered */
+#define XST_NO_FEATURE                  19L	/*!< Device is not configured with
+						   the requested feature */
+#define XST_NOT_INTERRUPT               20L	/*!< Device is not configured for
+						   interrupt mode operation */
+#define XST_DEVICE_BUSY                 21L	/*!< Device is busy */
+#define XST_ERROR_COUNT_MAX             22L	/*!< The error counters of a device
+						   have maxed out */
+#define XST_IS_STARTED                  23L	/*!< Used when part of device is
+						   already started i.e.
+						   sub channel */
+#define XST_IS_STOPPED                  24L	/*!< Used when part of device is
+						   already stopped i.e.
+						   sub channel */
+#define XST_DATA_LOST                   26L	/*!< Driver defined error */
+#define XST_RECV_ERROR                  27L	/*!< Generic receive error */
+#define XST_SEND_ERROR                  28L	/*!< Generic transmit error */
+#define XST_NOT_ENABLED                 29L	/*!< A requested service is not
+						   available because it has not
+						   been enabled */
+/** @} */
+/***************** Utility Component statuses 401 - 500  *********************/
+/**
+@name Utility Component Status Codes 401 - 500
+@{
+*/
+#define XST_MEMTEST_FAILED              401L	/*!< Memory test failed */
+
+/** @} */
+/***************** Common Components statuses 501 - 1000 *********************/
+/**
+@name Packet Fifo Status Codes 501 - 510
+@{
+*/
+/********************* Packet Fifo statuses 501 - 510 ************************/
+
+#define XST_PFIFO_LACK_OF_DATA          501L	/*!< Not enough data in FIFO   */
+#define XST_PFIFO_NO_ROOM               502L	/*!< Not enough room in FIFO   */
+#define XST_PFIFO_BAD_REG_VALUE         503L	/*!< Self test, a register value
+						   was invalid after reset */
+#define XST_PFIFO_ERROR                 504L	/*!< Generic packet FIFO error */
+#define XST_PFIFO_DEADLOCK              505L	/*!< Packet FIFO is reporting
+						 * empty and full simultaneously
+						 */
+/** @} */
+/**
+@name DMA Status Codes 511 - 530
+@{
+*/
+/************************** DMA statuses 511 - 530 ***************************/
+
+#define XST_DMA_TRANSFER_ERROR          511L	/*!< Self test, DMA transfer
+						   failed */
+#define XST_DMA_RESET_REGISTER_ERROR    512L	/*!< Self test, a register value
+						   was invalid after reset */
+#define XST_DMA_SG_LIST_EMPTY           513L	/*!< Scatter gather list contains
+						   no buffer descriptors ready
+						   to be processed */
+#define XST_DMA_SG_IS_STARTED           514L	/*!< Scatter gather not stopped */
+#define XST_DMA_SG_IS_STOPPED           515L	/*!< Scatter gather not running */
+#define XST_DMA_SG_LIST_FULL            517L	/*!< All the buffer desciptors of
+						   the scatter gather list are
+						   being used */
+#define XST_DMA_SG_BD_LOCKED            518L	/*!< The scatter gather buffer
+						   descriptor which is to be
+						   copied over in the scatter
+						   list is locked */
+#define XST_DMA_SG_NOTHING_TO_COMMIT    519L	/*!< No buffer descriptors have been
+						   put into the scatter gather
+						   list to be commited */
+#define XST_DMA_SG_COUNT_EXCEEDED       521L	/*!< The packet count threshold
+						   specified was larger than the
+						   total # of buffer descriptors
+						   in the scatter gather list */
+#define XST_DMA_SG_LIST_EXISTS          522L	/*!< The scatter gather list has
+						   already been created */
+#define XST_DMA_SG_NO_LIST              523L	/*!< No scatter gather list has
+						   been created */
+#define XST_DMA_SG_BD_NOT_COMMITTED     524L	/*!< The buffer descriptor which was
+						   being started was not committed
+						   to the list */
+#define XST_DMA_SG_NO_DATA              525L	/*!< The buffer descriptor to start
+						   has already been used by the
+						   hardware so it can't be reused
+						 */
+#define XST_DMA_SG_LIST_ERROR           526L	/*!< General purpose list access
+						   error */
+#define XST_DMA_BD_ERROR                527L	/*!< General buffer descriptor
+						   error */
+/** @} */
+/**
+@name IPIF Status Codes Codes 531 - 550
+@{
+*/
+/************************** IPIF statuses 531 - 550 ***************************/
+
+#define XST_IPIF_REG_WIDTH_ERROR        531L	/*!< An invalid register width
+						   was passed into the function */
+#define XST_IPIF_RESET_REGISTER_ERROR   532L	/*!< The value of a register at
+						   reset was not valid */
+#define XST_IPIF_DEVICE_STATUS_ERROR    533L	/*!< A write to the device interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_DEVICE_ACK_ERROR       534L	/*!< The device interrupt status
+						   register did not reset when
+						   acked */
+#define XST_IPIF_DEVICE_ENABLE_ERROR    535L	/*!< The device interrupt enable
+						   register was not updated when
+						   other registers changed */
+#define XST_IPIF_IP_STATUS_ERROR        536L	/*!< A write to the IP interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_IP_ACK_ERROR           537L	/*!< The IP interrupt status register
+						   did not reset when acked */
+#define XST_IPIF_IP_ENABLE_ERROR        538L	/*!< IP interrupt enable register was
+						   not updated correctly when other
+						   registers changed */
+#define XST_IPIF_DEVICE_PENDING_ERROR   539L	/*!< The device interrupt pending
+						   register did not indicate the
+						   expected value */
+#define XST_IPIF_DEVICE_ID_ERROR        540L	/*!< The device interrupt ID register
+						   did not indicate the expected
+						   value */
+#define XST_IPIF_ERROR                  541L	/*!< Generic ipif error */
+/** @} */
+
+/****************** Device specific statuses 1001 - 4095 *********************/
+/**
+@name Ethernet Status Codes 1001 - 1050
+@{
+*/
+/********************* Ethernet statuses 1001 - 1050 *************************/
+
+#define XST_EMAC_MEMORY_SIZE_ERROR  1001L	/*!< Memory space is not big enough
+						 * to hold the minimum number of
+						 * buffers or descriptors */
+#define XST_EMAC_MEMORY_ALLOC_ERROR 1002L	/*!< Memory allocation failed */
+#define XST_EMAC_MII_READ_ERROR     1003L	/*!< MII read error */
+#define XST_EMAC_MII_BUSY           1004L	/*!< An MII operation is in progress */
+#define XST_EMAC_OUT_OF_BUFFERS     1005L	/*!< Driver is out of buffers */
+#define XST_EMAC_PARSE_ERROR        1006L	/*!< Invalid driver init string */
+#define XST_EMAC_COLLISION_ERROR    1007L	/*!< Excess deferral or late
+						 * collision on polled send */
+/** @} */
+/**
+@name UART Status Codes 1051 - 1075
+@{
+*/
+/*********************** UART statuses 1051 - 1075 ***************************/
+#define XST_UART
+
+#define XST_UART_INIT_ERROR         1051L
+#define XST_UART_START_ERROR        1052L
+#define XST_UART_CONFIG_ERROR       1053L
+#define XST_UART_TEST_FAIL          1054L
+#define XST_UART_BAUD_ERROR         1055L
+#define XST_UART_BAUD_RANGE         1056L
+
+/** @} */
+/**
+@name IIC Status Codes 1076 - 1100
+@{
+*/
+/************************ IIC statuses 1076 - 1100 ***************************/
+
+#define XST_IIC_SELFTEST_FAILED         1076	/*!< self test failed            */
+#define XST_IIC_BUS_BUSY                1077	/*!< bus found busy              */
+#define XST_IIC_GENERAL_CALL_ADDRESS    1078	/*!< mastersend attempted with   */
+					     /* general call address        */
+#define XST_IIC_STAND_REG_RESET_ERROR   1079	/*!< A non parameterizable reg   */
+					     /* value after reset not valid */
+#define XST_IIC_TX_FIFO_REG_RESET_ERROR 1080	/*!< Tx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_RX_FIFO_REG_RESET_ERROR 1081	/*!< Rx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_TBA_REG_RESET_ERROR     1082	/*!< 10 bit addr incl in design  */
+					     /* value after reset not valid */
+#define XST_IIC_CR_READBACK_ERROR       1083	/*!< Read of the control register */
+					     /* didn't return value written */
+#define XST_IIC_DTR_READBACK_ERROR      1084	/*!< Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_DRR_READBACK_ERROR      1085	/*!< Read of the data Receive reg */
+					     /* didn't return value written */
+#define XST_IIC_ADR_READBACK_ERROR      1086	/*!< Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_TBA_READBACK_ERROR      1087	/*!< Read of the 10 bit addr reg */
+					     /* didn't return written value */
+#define XST_IIC_NOT_SLAVE               1088	/*!< The device isn't a slave    */
+/** @} */
+/**
+@name ATMC Status Codes 1101 - 1125
+@{
+*/
+/*********************** ATMC statuses 1101 - 1125 ***************************/
+
+#define XST_ATMC_ERROR_COUNT_MAX    1101L	/*!< the error counters in the ATM
+						   controller hit the max value
+						   which requires the statistics
+						   to be cleared */
+/** @} */
+/**
+@name Flash Status Codes 1126 - 1150
+@{
+*/
+/*********************** Flash statuses 1126 - 1150 **************************/
+
+#define XST_FLASH_BUSY                1126L	/*!< Flash is erasing or programming
+						 */
+#define XST_FLASH_READY               1127L	/*!< Flash is ready for commands */
+#define XST_FLASH_ERROR               1128L	/*!< Flash had detected an internal
+						   error. Use XFlash_DeviceControl
+						   to retrieve device specific codes
+						 */
+#define XST_FLASH_ERASE_SUSPENDED     1129L	/*!< Flash is in suspended erase state
+						 */
+#define XST_FLASH_WRITE_SUSPENDED     1130L	/*!< Flash is in suspended write state
+						 */
+#define XST_FLASH_PART_NOT_SUPPORTED  1131L	/*!< Flash type not supported by
+						   driver */
+#define XST_FLASH_NOT_SUPPORTED       1132L	/*!< Operation not supported */
+#define XST_FLASH_TOO_MANY_REGIONS    1133L	/*!< Too many erase regions */
+#define XST_FLASH_TIMEOUT_ERROR       1134L	/*!< Programming or erase operation
+						   aborted due to a timeout */
+#define XST_FLASH_ADDRESS_ERROR       1135L	/*!< Accessed flash outside its
+						   addressible range */
+#define XST_FLASH_ALIGNMENT_ERROR     1136L	/*!< Write alignment error */
+#define XST_FLASH_BLOCKING_CALL_ERROR 1137L	/*!< Couldn't return immediately from
+						   write/erase function with
+						   XFL_NON_BLOCKING_WRITE/ERASE
+						   option cleared */
+#define XST_FLASH_CFI_QUERY_ERROR     1138L	/*!< Failed to query the device */
+/** @} */
+/**
+@name SPI Status Codes 1151 - 1175
+@{
+*/
+/*********************** SPI statuses 1151 - 1175 ****************************/
+
+#define XST_SPI_MODE_FAULT          1151	/*!< master was selected as slave */
+#define XST_SPI_TRANSFER_DONE       1152	/*!< data transfer is complete */
+#define XST_SPI_TRANSMIT_UNDERRUN   1153	/*!< slave underruns transmit register */
+#define XST_SPI_RECEIVE_OVERRUN     1154	/*!< device overruns receive register */
+#define XST_SPI_NO_SLAVE            1155	/*!< no slave has been selected yet */
+#define XST_SPI_TOO_MANY_SLAVES     1156	/*!< more than one slave is being
+						 * selected */
+#define XST_SPI_NOT_MASTER          1157	/*!< operation is valid only as master */
+#define XST_SPI_SLAVE_ONLY          1158	/*!< device is configured as slave-only
+						 */
+#define XST_SPI_SLAVE_MODE_FAULT    1159	/*!< slave was selected while disabled */
+#define XST_SPI_SLAVE_MODE          1160	/*!< device has been addressed as slave */
+#define XST_SPI_RECEIVE_NOT_EMPTY   1161	/*!< device received data in slave mode */
+
+#define XST_SPI_COMMAND_ERROR       1162	/*!< unrecognised command - qspi only */
+#define XST_SPI_POLL_DONE           1163        /*!< controller completed polling the
+						   device for status */
+/** @} */
+/**
+@name OPB Arbiter Status Codes 1176 - 1200
+@{
+*/
+/********************** OPB Arbiter statuses 1176 - 1200 *********************/
+
+#define XST_OPBARB_INVALID_PRIORITY  1176	/*!< the priority registers have either
+						 * one master assigned to two or more
+						 * priorities, or one master not
+						 * assigned to any priority
+						 */
+#define XST_OPBARB_NOT_SUSPENDED     1177	/*!< an attempt was made to modify the
+						 * priority levels without first
+						 * suspending the use of priority
+						 * levels
+						 */
+#define XST_OPBARB_PARK_NOT_ENABLED  1178	/*!< bus parking by id was enabled but
+						 * bus parking was not enabled
+						 */
+#define XST_OPBARB_NOT_FIXED_PRIORITY 1179	/*!< the arbiter must be in fixed
+						 * priority mode to allow the
+						 * priorities to be changed
+						 */
+/** @} */
+/**
+@name INTC Status Codes 1201 - 1225
+@{
+*/
+/************************ Intc statuses 1201 - 1225 **************************/
+
+#define XST_INTC_FAIL_SELFTEST      1201	/*!< self test failed */
+#define XST_INTC_CONNECT_ERROR      1202	/*!< interrupt already in use */
+/** @} */
+/**
+@name TmrCtr Status Codes 1226 - 1250
+@{
+*/
+/********************** TmrCtr statuses 1226 - 1250 **************************/
+
+#define XST_TMRCTR_TIMER_FAILED     1226	/*!< self test failed */
+/** @} */
+/**
+@name WdtTb Status Codes 1251 - 1275
+@{
+*/
+/********************** WdtTb statuses 1251 - 1275 ***************************/
+
+#define XST_WDTTB_TIMER_FAILED      1251L
+/** @} */
+/**
+@name PlbArb status Codes 1276 - 1300
+@{
+*/
+/********************** PlbArb statuses 1276 - 1300 **************************/
+
+#define XST_PLBARB_FAIL_SELFTEST    1276L
+/** @} */
+/**
+@name Plb2Opb Status Codes 1301 - 1325
+@{
+*/
+/********************** Plb2Opb statuses 1301 - 1325 *************************/
+
+#define XST_PLB2OPB_FAIL_SELFTEST   1301L
+/** @} */
+/**
+@name Opb2Plb Status 1326 - 1350
+@{
+*/
+/********************** Opb2Plb statuses 1326 - 1350 *************************/
+
+#define XST_OPB2PLB_FAIL_SELFTEST   1326L
+/** @} */
+/**
+@name SysAce Status Codes 1351 - 1360
+@{
+*/
+/********************** SysAce statuses 1351 - 1360 **************************/
+
+#define XST_SYSACE_NO_LOCK          1351L	/*!< No MPU lock has been granted */
+/** @} */
+/**
+@name PCI Bridge Status Codes 1361 - 1375
+@{
+*/
+/********************** PCI Bridge statuses 1361 - 1375 **********************/
+
+#define XST_PCI_INVALID_ADDRESS     1361L
+/** @} */
+/**
+@name FlexRay Constants 1400 - 1409
+@{
+*/
+/********************** FlexRay constants 1400 - 1409 *************************/
+
+#define XST_FR_TX_ERROR			1400
+#define XST_FR_TX_BUSY			1401
+#define XST_FR_BUF_LOCKED		1402
+#define XST_FR_NO_BUF			1403
+/** @} */
+/**
+@name USB constants 1410 - 1420
+@{
+*/
+/****************** USB constants 1410 - 1420  *******************************/
+
+#define XST_USB_ALREADY_CONFIGURED	1410
+#define XST_USB_BUF_ALIGN_ERROR		1411
+#define XST_USB_NO_DESC_AVAILABLE	1412
+#define XST_USB_BUF_TOO_BIG		1413
+#define XST_USB_NO_BUF			1414
+/** @} */
+/**
+@name HWICAP constants 1421 - 1429
+@{
+*/
+/****************** HWICAP constants 1421 - 1429  *****************************/
+
+#define XST_HWICAP_WRITE_DONE		1421
+
+/** @} */
+/**
+@name AXI VDMA constants 1430 - 1440
+@{
+*/
+/****************** AXI VDMA constants 1430 - 1440  *****************************/
+
+#define XST_VDMA_MISMATCH_ERROR		1430
+/** @} */
+/**
+@name NAND Flash Status Codes 1441 - 1459
+@{
+*/
+/*********************** NAND Flash statuses 1441 - 1459  *********************/
+
+#define XST_NAND_BUSY			1441L	/*!< Flash is erasing or
+						 * programming
+						 */
+#define XST_NAND_READY			1442L	/*!< Flash is ready for commands
+						 */
+#define XST_NAND_ERROR			1443L	/*!< Flash had detected an
+						 * internal error.
+						 */
+#define XST_NAND_PART_NOT_SUPPORTED	1444L	/*!< Flash type not supported by
+						 * driver
+						 */
+#define XST_NAND_OPT_NOT_SUPPORTED	1445L	/*!< Operation not supported
+						 */
+#define XST_NAND_TIMEOUT_ERROR		1446L	/*!< Programming or erase
+						 * operation aborted due to a
+						 * timeout
+						 */
+#define XST_NAND_ADDRESS_ERROR		1447L	/*!< Accessed flash outside its
+						 * addressible range
+						 */
+#define XST_NAND_ALIGNMENT_ERROR	1448L	/*!< Write alignment error
+						 */
+#define XST_NAND_PARAM_PAGE_ERROR	1449L	/*!< Failed to read parameter
+						 * page of the device
+						 */
+#define XST_NAND_CACHE_ERROR		1450L	/*!< Flash page buffer error
+						 */
+
+#define XST_NAND_WRITE_PROTECTED	1451L	/*!< Flash is write protected
+						 */
+/** @} */
+
+/**************************** Type Definitions *******************************/
+
+typedef s32 XStatus;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
+/**
+* @} End of "addtogroup common_status_codes".
+*/
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.c
new file mode 100644
index 0000000..7ada356
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.c
@@ -0,0 +1,1652 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx.c
+*
+* This is the main file for Xilinx HDMI RX core. Please see xv_hdmirx.h for
+* more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  gm, mg 11/03/15 Initial release.
+* 1.01  MG     30/12/15 Added DDC HDCP 2.2 calls
+* 1.02  yh     15/01/16 Added 3D Video support
+* 1.03  MG     19/02/16 Added link error callback
+* 1.04  MG     08/03/16 Updated XV_HdmiRx_SetStream to use RefClk
+* 1.05  MG     27/05/16 Updated XV_HdmiRx_CfgInitialize
+* 1.06  YH     18/07/16 Replace xil_printf with xdbg_printf
+* 1.07  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                          XV_HdmiRx_CfgInitialize
+* 1.08  YH     18/08/16 squash unused variable compiler warning
+* 1.09  YH     29/08/16 Set Match to FALSE when HTotal = 0
+* 1.10  MG     02/03/17 Fixed YUV420 reading in function
+*                          XV_HdmiRx_GetVideoTiming
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmirx.h"
+#include "xil_printf.h"
+#include <linux/string.h>
+
+/************************** Constant Definitions *****************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+/**
+* This table contains the attributes for various standard resolutions.
+* Each entry is of the format:
+* 1) Resolution ID
+* 2) Video Identification Code.
+*/
+static const XV_HdmiRx_VicTable VicTable[38] = {
+    {XVIDC_VM_640x480_60_P, 1},     // Vic 1
+    {XVIDC_VM_720x480_60_P, 2},     // Vic 2
+    {XVIDC_VM_720x480_60_P, 3},     // Vic 3
+    {XVIDC_VM_1280x720_60_P, 4},    // Vic 4
+    {XVIDC_VM_1920x1080_60_I, 5},   // Vic 5
+    {XVIDC_VM_1440x480_60_I, 6},    // Vic 6
+    {XVIDC_VM_1440x480_60_I, 7},    // Vic 7
+
+    {XVIDC_VM_1920x1080_60_P, 16},  // Vic 16
+    {XVIDC_VM_720x576_50_P, 17},    // Vic 17
+    {XVIDC_VM_720x576_50_P, 18},    // Vic 18
+    {XVIDC_VM_1280x720_50_P, 19},   // Vic 19
+    {XVIDC_VM_1920x1080_50_I, 20},  // Vic 20
+    {XVIDC_VM_1440x576_50_I, 21},   // Vic 21
+    {XVIDC_VM_1440x576_50_I, 22},   // Vic 22
+
+    // 1680 x 720
+    {XVIDC_VM_1680x720_50_P, 82},   // Vic 82
+    {XVIDC_VM_1680x720_60_P, 83},   // Vic 83
+    {XVIDC_VM_1680x720_100_P, 84},  // Vic 84
+    {XVIDC_VM_1680x720_120_P, 85},  // Vic 85
+
+    // 1920 x 1080
+    {XVIDC_VM_1920x1080_24_P, 32},  // Vic 32
+    {XVIDC_VM_1920x1080_25_P, 33},  // Vic 33
+    {XVIDC_VM_1920x1080_30_P, 34},  // Vic 34
+    {XVIDC_VM_1920x1080_50_P, 31},  // Vic 31
+    {XVIDC_VM_1920x1080_100_P, 64}, // Vic 64
+    {XVIDC_VM_1920x1080_120_P, 63}, // Vic 63
+
+    // 2560 x 1080
+    {XVIDC_VM_2560x1080_50_P, 89},  // Vic 89
+    {XVIDC_VM_2560x1080_60_P, 90},  // Vic 89
+    {XVIDC_VM_2560x1080_100_P, 91}, // Vic 91
+    {XVIDC_VM_2560x1080_120_P, 92}, // Vic 92
+
+    // 3840 x 2160
+    {XVIDC_VM_3840x2160_24_P, 93},  // Vic 93
+    {XVIDC_VM_3840x2160_25_P, 94},  // Vic 94
+    {XVIDC_VM_3840x2160_30_P, 95},  // Vic 95
+    {XVIDC_VM_3840x2160_50_P, 96},  // Vic 96
+    {XVIDC_VM_3840x2160_60_P, 97},  // Vic 97
+
+    // 4096 x 2160
+    {XVIDC_VM_4096x2160_24_P, 98},  // Vic 98
+    {XVIDC_VM_4096x2160_25_P, 99},  // Vic 99
+    {XVIDC_VM_4096x2160_30_P, 100}, // Vic 100
+    {XVIDC_VM_4096x2160_50_P, 101}, // Vic 101
+    {XVIDC_VM_4096x2160_60_P, 102}  // Vic 102
+};
+
+/************************** Function Prototypes ******************************/
+
+static void StubCallback(void *CallbackRef);
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function initializes the HDMI RX core. This function must be called
+* prior to using the HDMI RX core. Initialization of the HDMI RX includes
+* setting up the instance data, and ensuring the hardware is in a quiescent
+* state.
+*
+* @param    InstancePtr is a pointer to the XHdmiRx core instance.
+* @param    CfgPtr points to the configuration structure associated with
+*       the HDMI RX core.
+* @param    EffectiveAddr is the base address of the device. If address
+*       translation is being used, then this parameter must reflect the
+*       virtual base address. Otherwise, the physical address should be
+*       used.
+*
+* @return
+*       - XST_SUCCESS if XV_HdmiRx_CfgInitialize was successful.
+*       - XST_FAILURE if HDMI RX PIO ID mismatched.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_CfgInitialize(XV_HdmiRx *InstancePtr, XV_HdmiRx_Config *CfgPtr, UINTPTR EffectiveAddr)
+{
+    u32 RegValue;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(CfgPtr != NULL);
+    Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)0x0);
+
+    /* Setup the instance */
+    (void)memset((void *)InstancePtr, 0, sizeof(XV_HdmiRx));
+    (void)memcpy((void *)&(InstancePtr->Config), (const void *)CfgPtr, sizeof(XV_HdmiRx_Config));
+    InstancePtr->Config.BaseAddress = EffectiveAddr;
+
+    /* Check PIO ID */
+    RegValue = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_ID_OFFSET));
+    RegValue = ((RegValue) >> (XV_HDMIRX_SHIFT_16)) & (XV_HDMIRX_MASK_16);
+    if (RegValue != (XV_HDMIRX_PIO_ID)) {
+        return (XST_FAILURE);
+    }
+
+    /*
+        Callbacks
+        These are placeholders pointing to the StubCallback
+        The actual callback pointers will be assigned by the SetCallback function
+    */
+
+    InstancePtr->ConnectCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsConnectCallbackSet = (FALSE);
+
+    InstancePtr->AuxCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsAuxCallbackSet = (FALSE);
+
+    InstancePtr->AudCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsAudCallbackSet = (FALSE);
+
+    InstancePtr->LnkStaCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsLnkStaCallbackSet = (FALSE);
+
+    InstancePtr->DdcCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsDdcCallbackSet = (FALSE);
+
+    InstancePtr->StreamDownCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsStreamDownCallbackSet = (FALSE);
+
+    InstancePtr->StreamInitCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsStreamInitCallbackSet = (FALSE);
+
+    InstancePtr->StreamUpCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsStreamUpCallbackSet = (FALSE);
+
+    InstancePtr->HdcpCallback = (XV_HdmiRx_HdcpCallback)((void *)StubCallback);
+    InstancePtr->IsHdcpCallbackSet = (FALSE);
+
+    InstancePtr->LinkErrorCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsLinkErrorCallbackSet = (FALSE);
+
+    InstancePtr->SyncLossCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsSyncLossCallbackSet = (FALSE);
+
+    InstancePtr->ModeCallback = (XV_HdmiRx_Callback)((void *)StubCallback);
+    InstancePtr->IsModeCallbackSet = (FALSE);
+
+    /* Clear HDMI variables */
+    XV_HdmiRx_Clear(InstancePtr);
+
+    // Clear connected flag
+    InstancePtr->Stream.IsConnected = (FALSE);
+
+    // Reset all peripherals
+    XV_HdmiRx_PioDisable(InstancePtr);
+    XV_HdmiRx_TmrDisable(InstancePtr);
+    XV_HdmiRx_VtdDisable(InstancePtr);
+    XV_HdmiRx_DdcDisable(InstancePtr);
+    XV_HdmiRx_AuxDisable(InstancePtr);
+    XV_HdmiRx_AudioDisable(InstancePtr);
+    XV_HdmiRx_LnkstaDisable(InstancePtr);
+
+    XV_HdmiRx_PioIntrDisable(InstancePtr);
+    XV_HdmiRx_TmrIntrDisable(InstancePtr);
+    XV_HdmiRx_VtdIntrDisable(InstancePtr);
+    XV_HdmiRx_DdcScdcClear(InstancePtr);
+
+    /*
+        PIO peripheral
+    */
+
+    /* PIO: Set event rising edge masks */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_EVT_RE_OFFSET),
+            (XV_HDMIRX_PIO_IN_DET_MASK) |
+            (XV_HDMIRX_PIO_IN_LNK_RDY_MASK) |
+            (XV_HDMIRX_PIO_IN_VID_RDY_MASK) |
+            (XV_HDMIRX_PIO_IN_MODE_MASK) |
+            (XV_HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK) |
+            (XV_HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK)
+        );
+
+    /* PIO: Set event falling edge masks */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_EVT_FE_OFFSET),
+            (XV_HDMIRX_PIO_IN_DET_MASK) |
+            (XV_HDMIRX_PIO_IN_VID_RDY_MASK) |
+            (XV_HDMIRX_PIO_IN_MODE_MASK) |
+            (XV_HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK) |
+            (XV_HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK)
+        );
+
+    /* Set run flag */
+    XV_HdmiRx_PioEnable(InstancePtr);
+
+    /* Enable interrupt */
+    XV_HdmiRx_PioIntrEnable(InstancePtr);
+
+    /*
+        Timer
+    */
+
+    /* Set run flag */
+    XV_HdmiRx_TmrEnable(InstancePtr);
+
+    /* Enable interrupt */
+    XV_HdmiRx_TmrIntrEnable(InstancePtr);
+
+    /*
+        Video Timing detector peripheral
+    */
+
+    // Set timebase
+    XV_HdmiRx_VtdSetTimebase(InstancePtr, 1600000);  // 16 ms @ 100 Mhz
+
+    // The VTD run flag is set in the armed state
+
+    /*
+        DDC peripheral
+    */
+
+    /* Enable DDC */
+    XV_HdmiRx_DdcEnable(InstancePtr);
+
+    /* Enable DDC peripheral interrupt */
+    //XV_HdmiRx_DdcIntrEnable(InstancePtr);
+
+    // Enable SCDC
+    XV_HdmiRx_DdcScdcEnable(InstancePtr);
+
+    /*
+        AUX peripheral
+    */
+
+    // The aux peripheral will be enabled in the RX init done callback
+    //XV_HdmiRx_AuxEnable(InstancePtr);
+
+    /* Enable AUX peripheral interrupt */
+    XV_HdmiRx_AuxIntrEnable(InstancePtr);
+
+    /*
+        Audio peripheral
+    */
+
+    // The audio peripheral willl be enabled in the RX init done callback
+    //XV_HdmiRx_AudioEnable(InstancePtr);
+
+    /* Enable AUD peripheral interrupt */
+    XV_HdmiRx_AudioIntrEnable(InstancePtr);
+
+    /* Enable Link Status */
+    XV_HdmiRx_LnkstaEnable(InstancePtr);
+
+    /* Enable Link Status peripheral interrupt */
+    //XV_HdmiRx_LinkIntrEnable(InstancePtr);
+
+    /* Reset the hardware and set the flag to indicate the driver is ready */
+    InstancePtr->IsReady = (u32)(XIL_COMPONENT_IS_READY);
+
+    return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function clears the HDMI RX variables and sets them to the defaults.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     This is required after a reset or init.
+*
+******************************************************************************/
+void XV_HdmiRx_Clear(XV_HdmiRx *InstancePtr)
+{
+    u32 Index;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_DOWN;            // The stream is down
+    InstancePtr->Stream.IsHdmi = (FALSE);
+    InstancePtr->Stream.Video.ColorFormatId = (XVIDC_CSF_RGB);          // Default RGB
+    InstancePtr->Stream.Video.IsInterlaced = 0;
+    InstancePtr->Stream.Video.ColorDepth = (XVIDC_BPC_8);               // Default 8 bits
+    InstancePtr->Stream.Video.PixPerClk = (XVIDC_PPC_2);
+    InstancePtr->Stream.Video.VmId = (XVIDC_VM_NO_INPUT);
+    InstancePtr->Stream.Video.Is3D = FALSE;
+    InstancePtr->Stream.Video.Info_3D.Format = XVIDC_3D_UNKNOWN;
+    InstancePtr->Stream.Video.Timing.HActive = 0;
+    InstancePtr->Stream.Video.Timing.HFrontPorch = 0;
+    InstancePtr->Stream.Video.Timing.HSyncWidth = 0;
+    InstancePtr->Stream.Video.Timing.HBackPorch = 0;
+    InstancePtr->Stream.Video.Timing.HTotal = 0;
+    InstancePtr->Stream.Video.Timing.HSyncPolarity = 0;
+    InstancePtr->Stream.Video.Timing.VActive = 0;
+    InstancePtr->Stream.Video.Timing.F0PVFrontPorch = 0;
+    InstancePtr->Stream.Video.Timing.F0PVSyncWidth = 0;
+    InstancePtr->Stream.Video.Timing.F0PVBackPorch = 0;
+    InstancePtr->Stream.Video.Timing.F0PVTotal = 0;
+    InstancePtr->Stream.Video.Timing.F1VFrontPorch = 0;
+    InstancePtr->Stream.Video.Timing.F1VSyncWidth = 0;
+    InstancePtr->Stream.Video.Timing.F1VBackPorch = 0;
+    InstancePtr->Stream.Video.Timing.F1VTotal = 0;
+    InstancePtr->Stream.Video.Timing.VSyncPolarity = 0;
+    InstancePtr->Stream.Vic = 0;
+    InstancePtr->Stream.Audio.Active = (FALSE);                             // Idle stream
+    InstancePtr->Stream.Audio.Channels = 2;                             // 2 channels
+    InstancePtr->Stream.GetVideoPropertiesTries = 0;
+
+    /* AUX */
+    InstancePtr->Aux.Header.Data = 0;
+    for (Index = 0; Index < 8; Index++) {
+        InstancePtr->Aux.Data.Data[Index] = 0;
+    }
+
+    /* Audio */
+    InstancePtr->AudCts = 0;
+    InstancePtr->AudN = 0;
+    InstancePtr->AudFormat = 0;
+
+    // Call stream down callback
+    if (InstancePtr->IsStreamDownCallbackSet) {
+        InstancePtr->StreamDownCallback(InstancePtr->StreamDownRef);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the HDMI RX stream parameters.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param    Ppc specifies the pixel per clock.
+*       - 1 = XVIDC_PPC_1
+*       - 2 = XVIDC_PPC_2
+*       - 4 = XVIDC_PPC_4
+* @param    Clock specifies reference pixel clock frequency.
+*
+* @return
+*       - XST_SUCCESS is always returned.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_SetStream(XV_HdmiRx *InstancePtr, XVidC_PixelsPerClock Ppc, u32 Clock)
+{
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid((Ppc == (XVIDC_PPC_1)) || (Ppc == (XVIDC_PPC_2))
+                                             || (Ppc == (XVIDC_PPC_4)));
+    Xil_AssertNonvoid(Clock > 0x0);
+
+    /* Pixels per clock */
+    InstancePtr->Stream.Video.PixPerClk = Ppc;
+
+    /* Reference clock */
+    InstancePtr->Stream.RefClk = Clock;
+
+    /* Set RX pixel rate */
+    XV_HdmiRx_SetPixelRate(InstancePtr);
+
+    return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the pixel rate.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - XST_SUCCESS is always returned.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_SetPixelRate(XV_HdmiRx *InstancePtr)
+{
+    u32 RegValue;
+    u8 PixelRate;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Mask pixel rate */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_MSK_OFFSET), (XV_HDMIRX_PIO_OUT_PIXEL_RATE_MASK));
+
+    /* Check pixel per clock */
+    switch (InstancePtr->Stream.Video.PixPerClk) {
+        case (XVIDC_PPC_2):
+            PixelRate = 1;
+            break;
+
+        case (XVIDC_PPC_4):
+            PixelRate = 2;
+            break;
+
+        default:
+            PixelRate = 0;
+            break;
+    }
+
+    /* Set pixel rate for video path */
+    RegValue = PixelRate << (XV_HDMIRX_PIO_OUT_PIXEL_RATE_SHIFT);
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_OFFSET), RegValue);
+
+    return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the color format
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRx_SetColorFormat(XV_HdmiRx *InstancePtr)
+{
+    u32 RegValue;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Mask PIO Out Mask register */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_MSK_OFFSET), (XV_HDMIRX_PIO_OUT_COLOR_SPACE_MASK));
+
+    /* Check for color format */
+    switch (InstancePtr->Stream.Video.ColorFormatId) {
+        case (XVIDC_CSF_YCRCB_444):
+            RegValue = 1;
+            break;
+
+        case (XVIDC_CSF_YCRCB_422):
+            RegValue = 2;
+            break;
+
+        case (XVIDC_CSF_YCRCB_420):
+            RegValue = 3;
+            break;
+
+        default:
+            RegValue = 0;
+            break;
+    }
+
+    /* Write color space into PIO Out register */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_OFFSET), (RegValue << (XV_HDMIRX_PIO_OUT_COLOR_SPACE_SHIFT)));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables/clear Hot-Plug-Detect.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param    SetClr specifies TRUE/FALSE value to either enable or
+*       clear HPD respectively.
+*
+* @return
+*       - XST_SUCCESS is always returned.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_SetHpd(XV_HdmiRx *InstancePtr, u8 SetClr)
+{
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid((SetClr == (TRUE)) || (SetClr == (FALSE)));
+
+    if (SetClr) {
+        /* Set HPD */
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_HPD_MASK));
+    }
+    else {
+        /* Clear HPD */
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_HPD_MASK));
+    }
+
+    return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides status of the HDMI RX core Link Status peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param    Type specifies one of the type for which status to be provided:
+*       - 0 = Link error counter for channel 0.
+*       - 1 = Link error counter for channel 1.
+*       - 2 = Link error counter for channel 2.
+*       - 3 = Link phase.
+*       - 4 = Link delay.
+*       - 5 = Link line length
+*
+* @return   Link status of the HDMI RX core link.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiRx_GetLinkStatus(XV_HdmiRx *InstancePtr, u8 Type)
+{
+    u32 RegValue;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(Type < 0x6);
+
+    RegValue = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_LNK_ERR0_OFFSET) + (4 * Type));
+
+    return RegValue;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides status of one of the link error counters reached the
+* maximum value.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - TRUE = Maximum error counter reached.
+*       - FALSE = Maximum error counter not reached.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_IsLinkStatusErrMax(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Read Link Status peripheral Status register */
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_STA_OFFSET)) & (XV_HDMIRX_LNKSTA_STA_ERR_MAX_MASK);
+
+    if (Status) {
+        Status = (TRUE);
+    }
+    else {
+        Status = (FALSE);
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function clears the link error counters.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRx_ClearLinkStatus(XV_HdmiRx *InstancePtr)
+{
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Set Error Clear bit */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_SET_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK));
+
+    /* Clear Error Clear bit */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_CLR_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides audio clock regenerating CTS (Cycle-Time Stamp) value
+* at the HDMI sink device.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   Audio clock CTS value.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiRx_GetAcrCts(XV_HdmiRx *InstancePtr)
+{
+    u32 CtsValue;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Read cycle time stamp value */
+    CtsValue = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUD_CTS_OFFSET));
+
+    return CtsValue;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides audio clock regenerating factor N value.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   ACR N value.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiRx_GetAcrN(XV_HdmiRx *InstancePtr)
+{
+    u32 AcrNValue;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Read ACR factor N value */
+    AcrNValue = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUD_N_OFFSET));
+
+    return AcrNValue;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the size of the EDID buffer of the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - EDID buffer size
+*
+* @note     None.
+*
+******************************************************************************/
+u16 XV_HdmiRx_DdcGetEdidWords(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_EDID_STA_OFFSET));
+    Data >>= XV_HDMIRX_DDC_STA_EDID_WORDS_SHIFT;
+    Data &= XV_HDMIRX_DDC_STA_EDID_WORDS_MASK;
+    return (Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function loads the EDID data into the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param    EdidData is a pointer to the EDID data array.
+* @param    Length is the length, in bytes, of the EDID array.
+*
+* @return
+*       - XST_SUCCESS if the EDID data was loaded successfully
+*       - XST_FAILURE if the EDID data load failed
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_DdcLoadEdid(XV_HdmiRx *InstancePtr, u8 *EdidData, u16 Length)
+{
+    u8 Data;
+    u16 Index;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Check if the EDID data fits in the DDC slave EDID buffer
+    if (XV_HdmiRx_DdcGetEdidWords(InstancePtr) >= Length)
+    {
+        // Clear EDID write pointer
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_EDID_WP_OFFSET), 0);
+
+        // Copy EDID data
+        for (Index = 0; Index < Length; Index++) {
+            Data = *(EdidData + Index);
+            XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_EDID_DATA_OFFSET), (Data));
+        }
+
+        // Enable EDID
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_EDID_EN_MASK));
+
+        return (XST_SUCCESS);
+    }
+
+    // The EDID data is larger than the DDC slave EDID buffer size
+    else
+    {
+        xdbg_printf(XDBG_DEBUG_GENERAL,"The EDID data structure is too large to be stored in the DDC peripheral (%0d).\n\r", Length);
+        return (XST_FAILURE);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP address in the DDC peripheral.
+* This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+* @param    Address is the HDCP address.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XHdmiRx_DdcHdcpSetAddress(XHdmi_Rx *InstancePtr, u8 Address)
+*
+******************************************************************************/
+void XV_HdmiRx_DdcHdcpSetAddress(XV_HdmiRx *InstancePtr, u32 Address)
+{
+    // Verify argument.
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    // Write Address
+    XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_ADDRESS_OFFSET), (Address));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function writes HDCP data in the DDC peripheral.
+* This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+* @param    Data is the HDCP data to be written.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XHdmiRx_DdcHdcpWriteData(XHdmi_Rx *InstancePtr, u8 Data)
+*
+******************************************************************************/
+void XV_HdmiRx_DdcHdcpWriteData(XV_HdmiRx *InstancePtr, u32 Data)
+{
+    // Verify argument.
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    // Write data
+    XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_DATA_OFFSET), (Data));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads HDCP data from the DDC peripheral.
+* This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return   Returns the HDCP data read from the DDC peripheral.
+*
+* @note     C-style signature:
+*       u32 XHdmiRx_DdcHdcpReadData(XHdmi_Rx *InstancePtr)
+*
+******************************************************************************/
+u32 XV_HdmiRx_DdcHdcpReadData(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    Data = XV_HdmiRx_ReadReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_DATA_OFFSET));
+    return (Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the number of bytes of the HDCP 2.2 write buffer in the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return
+*       - HDCP 2.2 write buffer words
+*
+* @note     None.
+*
+******************************************************************************/
+u16 XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_STA_OFFSET));
+    Data >>= XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_SHIFT;
+    Data &= XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_MASK;
+    return (Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the status of the HDCP 2.2 write buffer in the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return
+*       - TRUE = HDCP 2.2 message buffer is empty.
+*       - FALSE = HDCP 2.2 message buffer contains data.
+*
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_STA_OFFSET));
+    if (Data & XV_HDMIRX_DDC_STA_HDCP_WMSG_EP_MASK)
+        return (TRUE);
+    else
+        return (FALSE);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the number of bytes of the HDCP 2.2 read buffer in the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return
+*       - HDCP 2.2 read buffer words
+*
+* @note     None.
+*
+******************************************************************************/
+u16 XV_HdmiRx_DdcGetHdcpReadMessageBufferWords(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_STA_OFFSET));
+    Data >>= XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_SHIFT;
+    Data &= XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_MASK;
+    return (Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the status of the HDCP 2.2 read message buffer in the DDC slave.
+*
+* @param    InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return
+*       - TRUE = HDCP 2.2 message buffer is empty.
+*       - FALSE = HDCP 2.2 message buffer contains data.
+*
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_HDCP_STA_OFFSET));
+    if (Data & XV_HDMIRX_DDC_STA_HDCP_RMSG_EP_MASK)
+        return (TRUE);
+    else
+        return (FALSE);
+}
+
+/******************************************************************************/
+/**
+*
+* This function prints stream and timing information on STDIO/Uart console.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRx_DebugInfo(XV_HdmiRx *InstancePtr)
+{
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    /* Print stream information */
+    XVidC_ReportStreamInfo(&InstancePtr->Stream.Video);
+
+    /* Print timing information */
+    XVidC_ReportTiming(&InstancePtr->Stream.Video.Timing, InstancePtr->Stream.Video.IsInterlaced);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides status of the stream
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - TRUE = Stream is up.
+*       - FALSE = Stream is down.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_IsStreamUp(XV_HdmiRx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_UP) {
+        return (TRUE);
+    }
+    else {
+        return (FALSE);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides the stream scrambler status
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - TRUE = Stream is scrambled.
+*       - FALSE = Stream is not scrambled.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_IsStreamScrambled(XV_HdmiRx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    return (InstancePtr->Stream.IsScrambled);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function provides the stream connected status
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - TRUE = Stream is connected.
+*       - FALSE = Stream is connected.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_IsStreamConnected(XV_HdmiRx *InstancePtr)
+{
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    return (InstancePtr->Stream.IsConnected);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the SCDC TMDS clock ratio bit
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*       - TRUE = TMDS clock ratio bit is set.
+*       - FALSE = TMDS clock ratio bit is cleared.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_GetTmdsClockRatio(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_OFFSET));
+
+    if ((Data) & (XV_HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK))
+        return (TRUE);
+    else
+        return (FALSE);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the AVI VIC (captured by the AUX peripheral)
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   The AVI VIC code.
+*
+* @note     None.
+*
+******************************************************************************/
+u8 XV_HdmiRx_GetAviVic(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET));
+    Data >>= XV_HDMIRX_AUX_STA_AVI_VIC_SHIFT;
+    Data &= XV_HDMIRX_AUX_STA_AVI_VIC_MASK;
+    return (u8)(Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the AVI colorspace (captured by the AUX peripheral)
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   The AVI colorspace value.
+*
+* @note     None.
+*
+******************************************************************************/
+XVidC_ColorFormat XV_HdmiRx_GetAviColorSpace(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+    XVidC_ColorFormat ColorSpace;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET));
+    Data >>= XV_HDMIRX_AUX_STA_AVI_CS_SHIFT;
+    Data &= XV_HDMIRX_AUX_STA_AVI_CS_MASK;
+
+        switch (Data) {
+            case 1:
+                ColorSpace = (XVIDC_CSF_YCRCB_422);
+                break;
+
+            case 2:
+                ColorSpace = (XVIDC_CSF_YCRCB_444);
+                break;
+
+            case 3:
+                ColorSpace = (XVIDC_CSF_YCRCB_420);
+                break;
+
+            default:
+                ColorSpace = (XVIDC_CSF_RGB);
+                break;
+        }
+    return (ColorSpace);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the GCP color depth (captured by the AUX peripheral)
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   The GCP color depth.
+*
+* @note     None.
+*
+******************************************************************************/
+XVidC_ColorDepth XV_HdmiRx_GetGcpColorDepth(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+    XVidC_ColorDepth ColorDepth;
+
+    // Verify argument.
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    // Read status register
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET));
+    Data >>= XV_HDMIRX_AUX_STA_GCP_CD_SHIFT;
+    Data &= XV_HDMIRX_AUX_STA_GCP_CD_MASK;
+
+        switch (Data) {
+            case 1:
+                ColorDepth = (XVIDC_BPC_10);
+                break;
+
+            case 2:
+                ColorDepth = (XVIDC_BPC_12);
+                break;
+
+            case 3:
+                ColorDepth = (XVIDC_BPC_16);
+                break;
+
+            default:
+                ColorDepth = (XVIDC_BPC_8);
+                break;
+        }
+    return (ColorDepth);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function calculates the divider for the frame calculation
+*
+* @param    Dividend is the dividend value to use in the calculation.
+* @param    Divisor is the divisor value to use in the calculation.
+*
+* @return   The result of the calculation.
+*
+* @note     None.
+*
+******************************************************************************/
+u32 XV_HdmiRx_Divide(u32 Dividend, u32 Divisor)
+{
+    u32 Result;
+    u32 Remainder;
+    Result = Dividend / Divisor;
+    Remainder = Dividend % Divisor;
+    if (Remainder) {
+        if (Remainder > (Divisor/2))
+            Result += 1;
+    }
+    return (Result);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function searches for the video mode based on the vic.
+*
+* @param    Vic
+*
+* @return   Vic defined in the VIC table.
+*
+* @note     None.
+*
+******************************************************************************/
+XVidC_VideoMode XV_HdmiRx_LookupVmId(u8 Vic)
+{
+    XV_HdmiRx_VicTable const *Entry;
+    u8 Index;
+
+    for (Index = 0; Index < sizeof(VicTable)/sizeof(XV_HdmiRx_VicTable); Index++) {
+      Entry = &VicTable[Index];
+      if (Entry->Vic == Vic)
+        return (Entry->VmId);
+    }
+    return XVIDC_VM_NOT_SUPPORTED;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads the video properties from the aux peripheral
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_GetVideoProperties(XV_HdmiRx *InstancePtr)
+{
+	u32 Status;
+
+	// Read AUX peripheral status register
+	Status =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET));
+
+	// Check if AVI ready flag has been set
+	if ((Status) & (XV_HDMIRX_AUX_STA_AVI_MASK)) {
+
+		// Get AVI colorspace
+		InstancePtr->Stream.Video.ColorFormatId = XV_HdmiRx_GetAviColorSpace(InstancePtr);
+
+		// Get AVI Vic
+		InstancePtr->Stream.Vic = XV_HdmiRx_GetAviVic(InstancePtr);
+
+		// Get GCP colordepth
+		// In HDMI the colordepth in YUV422 is always 12 bits (although on the link itself it is being transmitted as 8-bits.
+		// Therefore if the colorspace is YUV422, then force the colordepth to 12 bits.
+		if (InstancePtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_422) {
+			InstancePtr->Stream.Video.ColorDepth = XVIDC_BPC_12;
+		}
+
+		// Else read the colordepth from the general control packet
+		else {
+			InstancePtr->Stream.Video.ColorDepth = XV_HdmiRx_GetGcpColorDepth(InstancePtr);
+		}
+		return (XST_SUCCESS);
+	}
+
+	else {
+
+		// If we tried more than 8 times and still haven't received any AVI infoframes,
+		// then the source is DVI.
+		// In this case the video properties are forced to RGB and 8 bpc.
+		if (InstancePtr->Stream.GetVideoPropertiesTries > 7) {
+
+			// Force AVI colorspace to RGB
+			InstancePtr->Stream.Video.ColorFormatId = XVIDC_CSF_RGB;
+
+			// Set AVI vic to zero
+			InstancePtr->Stream.Vic = 0;
+
+			// Force color depth to 8 bpc
+			InstancePtr->Stream.Video.ColorDepth = XVIDC_BPC_8;
+
+			return (XST_SUCCESS);
+		}
+
+		// Return
+		else {
+			// Increment tries
+			InstancePtr->Stream.GetVideoPropertiesTries++;
+			return (XST_FAILURE);
+		}
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reads the video timing from the VTD peripheral
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+int XV_HdmiRx_GetVideoTiming(XV_HdmiRx *InstancePtr)
+{
+    u32 Data;
+
+    XVidC_VideoStream VidStreamCopy;
+
+    // Local timing parameters
+    u16 HActive;
+    u16 HFrontPorch;
+    u16 HSyncWidth;
+    u16 HBackPorch;
+    u16 HTotal;
+    // u16 HSyncPolarity; //squash unused variable compiler warning
+    u16 VActive;
+    u16 F0PVFrontPorch;
+    u16 F0PVSyncWidth;
+    u16 F0PVBackPorch;
+    u16 F0PVTotal;
+    u16 F1VFrontPorch;
+    u16 F1VSyncWidth;
+    u16 F1VBackPorch;
+    u16 F1VTotal;
+    u8 Match;
+    u8 YUV420_Correction;
+
+    // Lookup the videomode based on the vic
+    InstancePtr->Stream.Video.VmId = XV_HdmiRx_LookupVmId(InstancePtr->Stream.Vic);
+
+    // Was the vic found?
+    // Yes, then get the timing parameters from the video library
+    if (InstancePtr->Stream.Video.VmId != (XVIDC_VM_NOT_SUPPORTED)) {
+
+        // Copy the current VideoStream
+        VidStreamCopy = InstancePtr->Stream.Video;
+
+        if (XVidC_IsStream3D(&InstancePtr->Stream.Video)){
+            XVidC_Set3DVideoStream(&InstancePtr->Stream.Video,
+                                   VidStreamCopy.VmId,
+                                   VidStreamCopy.ColorFormatId,
+                                   VidStreamCopy.ColorDepth,
+                                   VidStreamCopy.PixPerClk,
+                                   &VidStreamCopy.Info_3D);
+        }
+        else {
+            XVidC_SetVideoStream(&InstancePtr->Stream.Video,
+                                 VidStreamCopy.VmId,
+                                 VidStreamCopy.ColorFormatId,
+                                 VidStreamCopy.ColorDepth,
+                                 VidStreamCopy.PixPerClk);
+        }
+
+        return (XST_SUCCESS);
+    }
+
+    // No, then read the timing parameters from the video timing detector
+    else {
+        // If the colorspace is YUV420, then the horizontal parameters must be doubled
+        if (InstancePtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_420) {
+            YUV420_Correction = 2;
+        } else {
+            YUV420_Correction = 1;
+        }
+        // First we read the video parameters from the VTD and store them in a local variable
+        /* Read Total Pixels */
+        HTotal =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_TOT_PIX_OFFSET)) * YUV420_Correction;
+
+        /* Read Active Pixels */
+        HActive =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_ACT_PIX_OFFSET)) * YUV420_Correction;
+
+        /* Read Hsync Width */
+        HSyncWidth =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_HSW_OFFSET)) * YUV420_Correction;
+
+        /* Read HFront Porch */
+        HFrontPorch =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_HFP_OFFSET)) * YUV420_Correction;
+
+        /* Read HBack Porch */
+        HBackPorch =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_HBP_OFFSET)) * YUV420_Correction;
+
+        /* Total lines field 1 */
+        F0PVTotal =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_TOT_LIN_OFFSET)) & (0xFFFF);
+
+        /* Total lines field 2 */
+        F1VTotal =  ((XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_TOT_LIN_OFFSET))) >> 16);
+
+        /* Active lines field 1 */
+        VActive =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_ACT_LIN_OFFSET)) & (0xFFFF);
+
+        /* Read VSync Width field 1*/
+        F0PVSyncWidth =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VSW_OFFSET)) & (0xFFFF);
+
+        /* Read VSync Width field 2*/
+        F1VSyncWidth =  ((XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VSW_OFFSET))) >> 16);
+
+        /* Read VFront Porch field 1*/
+        F0PVFrontPorch =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VFP_OFFSET)) & (0xFFFF);
+
+        /* Read VFront Porch field 2*/
+        F1VFrontPorch =  ((XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VFP_OFFSET))) >> 16);
+
+        /* Read VBack Porch field 1 */
+        F0PVBackPorch =  XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VBP_OFFSET)) & (0xFFFF);
+
+        /* Read VBack Porch field 2 */
+        F1VBackPorch =  ((XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_VBP_OFFSET))) >> 16);
+
+        // Next, we compare these values with the previous stored values
+        // By default the match is true
+        Match = TRUE;
+
+        // Htotal
+        if (HTotal != InstancePtr->Stream.Video.Timing.HTotal) {
+            Match = FALSE;
+        }
+
+        if (!HTotal) {
+            Match = FALSE;
+        }
+
+        // HActive
+        if (HActive != InstancePtr->Stream.Video.Timing.HActive) {
+            Match = FALSE;
+        }
+
+        // HSyncWidth
+        if (HSyncWidth != InstancePtr->Stream.Video.Timing.HSyncWidth) {
+            Match = FALSE;
+        }
+
+        // HFrontPorch
+        if (HFrontPorch != InstancePtr->Stream.Video.Timing.HFrontPorch) {
+            Match = FALSE;
+        }
+
+        // HBackPorch
+        if (HBackPorch != InstancePtr->Stream.Video.Timing.HBackPorch) {
+            Match = FALSE;
+        }
+
+        // F0PVTotal
+        if (F0PVTotal != InstancePtr->Stream.Video.Timing.F0PVTotal) {
+            Match = FALSE;
+        }
+
+        // F1VTotal
+        if (F1VTotal != InstancePtr->Stream.Video.Timing.F1VTotal) {
+            Match = FALSE;
+        }
+
+        // VActive
+        if (VActive != InstancePtr->Stream.Video.Timing.VActive) {
+            Match = FALSE;
+        }
+
+        // F0PVSyncWidth
+        if (F0PVSyncWidth != InstancePtr->Stream.Video.Timing.F0PVSyncWidth) {
+            Match = FALSE;
+        }
+
+        // F1VSyncWidth
+        if (F1VSyncWidth != InstancePtr->Stream.Video.Timing.F1VSyncWidth) {
+            Match = FALSE;
+        }
+
+        // F0PVFrontPorch
+        if (F0PVFrontPorch != InstancePtr->Stream.Video.Timing.F0PVFrontPorch) {
+            Match = FALSE;
+        }
+
+        // F1VFrontPorch
+        if (F1VFrontPorch != InstancePtr->Stream.Video.Timing.F1VFrontPorch) {
+            Match = FALSE;
+        }
+
+        // F0PVBackPorch
+        if (F0PVBackPorch != InstancePtr->Stream.Video.Timing.F0PVBackPorch) {
+            Match = FALSE;
+        }
+
+        // F1VBackPorch
+        if (F1VBackPorch != InstancePtr->Stream.Video.Timing.F1VBackPorch) {
+            Match = FALSE;
+        }
+
+        // Then we store the timing parameters regardless if there was a match
+        /* Read Total Pixels */
+        InstancePtr->Stream.Video.Timing.HTotal =  HTotal;
+
+        /* Read Active Pixels */
+        InstancePtr->Stream.Video.Timing.HActive = HActive;
+
+        /* Read Hsync Width */
+        InstancePtr->Stream.Video.Timing.HSyncWidth = HSyncWidth;
+
+        /* Read HFront Porch */
+        InstancePtr->Stream.Video.Timing.HFrontPorch = HFrontPorch;
+
+        /* Read HBack Porch */
+        InstancePtr->Stream.Video.Timing.HBackPorch = HBackPorch;
+
+        /* Total lines field 1 */
+        InstancePtr->Stream.Video.Timing.F0PVTotal = F0PVTotal;
+
+        /* Total lines field 2 */
+        InstancePtr->Stream.Video.Timing.F1VTotal = F1VTotal;
+
+        /* Active lines field 1 */
+        InstancePtr->Stream.Video.Timing.VActive = VActive;
+
+        /* Read VSync Width field 1*/
+        InstancePtr->Stream.Video.Timing.F0PVSyncWidth = F0PVSyncWidth;
+
+        /* Read VSync Width field 2*/
+        InstancePtr->Stream.Video.Timing.F1VSyncWidth = F1VSyncWidth;
+
+        /* Read VFront Porch field 1*/
+        InstancePtr->Stream.Video.Timing.F0PVFrontPorch = F0PVFrontPorch;
+
+        /* Read VFront Porch field 2*/
+        InstancePtr->Stream.Video.Timing.F1VFrontPorch = F1VFrontPorch;
+
+        /* Read VBack Porch field 1 */
+        InstancePtr->Stream.Video.Timing.F0PVBackPorch =  F0PVBackPorch;
+
+        /* Read VBack Porch field 2 */
+        InstancePtr->Stream.Video.Timing.F1VBackPorch =  F1VBackPorch;
+
+        // Do we have a match?
+        // Yes, then continue processing
+        if (Match) {
+
+            /* Read Status register */
+            Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET));
+
+            /* Check video format */
+            if ((Data) & (XV_HDMIRX_VTD_STA_FMT_MASK)) {
+                /* Interlaced */
+                InstancePtr->Stream.Video.IsInterlaced = 1;
+            }
+            else {
+                /* Progressive */
+                InstancePtr->Stream.Video.IsInterlaced = 0;
+            }
+
+            /* Check Vsync polarity */
+            if ((Data) & (XV_HDMIRX_VTD_STA_VS_POL_MASK)) {
+                /* Positive */
+                InstancePtr->Stream.Video.Timing.VSyncPolarity = 1;
+            }
+            else {
+                /* Negative */
+                InstancePtr->Stream.Video.Timing.VSyncPolarity = 0;
+            }
+
+            /* Check Hsync polarity */
+            if ((Data) & (XV_HDMIRX_VTD_STA_HS_POL_MASK)) {
+                /* Positive */
+                InstancePtr->Stream.Video.Timing.HSyncPolarity = 1;
+            }
+            else {
+                /* Negative */
+                InstancePtr->Stream.Video.Timing.HSyncPolarity = 0;
+            }
+
+            // Calculate and set the frame rate field
+            InstancePtr->Stream.Video.FrameRate =
+               (XVidC_FrameRate) (XV_HdmiRx_Divide(InstancePtr->Stream.PixelClk,
+                                                   (InstancePtr->Stream.Video.Timing.F0PVTotal * InstancePtr->Stream.Video.Timing.HTotal)));
+
+            // If the colorspace is YUV420, then the frame rate must be doubled
+            if (InstancePtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_420) {
+                InstancePtr->Stream.Video.FrameRate = (XVidC_FrameRate) (InstancePtr->Stream.Video.FrameRate * 2);
+            }
+
+            // Lookup the video mode id
+            InstancePtr->Stream.Video.VmId =
+               XVidC_GetVideoModeIdWBlanking(&InstancePtr->Stream.Video.Timing,
+                                             InstancePtr->Stream.Video.FrameRate,
+                                             InstancePtr->Stream.Video.IsInterlaced);
+
+            //If video mode not found in the table tag it as custom
+            if (InstancePtr->Stream.Video.VmId == XVIDC_VM_NOT_SUPPORTED) {
+                InstancePtr->Stream.Video.VmId = XVIDC_VM_CUSTOM;
+            }
+
+            // Return success
+            return (XST_SUCCESS);
+        }
+
+        // No match
+        else {
+            return (XST_FAILURE);
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is a stub for the asynchronous callback. The stub is here in
+* case the upper layer forgot to set the handlers. On initialization, all
+* handlers are set to this callback. It is considered an error for this
+* handler to be invoked.
+*
+* @param    CallbackRef is a callback reference passed in by the upper
+*       layer when setting the callback functions, and passed back to
+*       the upper layer when the callback is invoked.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+static void StubCallback(void *CallbackRef)
+{
+    Xil_AssertVoid(CallbackRef != NULL);
+    Xil_AssertVoidAlways();
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.h
new file mode 100644
index 0000000..de961a1
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx.h
@@ -0,0 +1,1230 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx.h
+*
+* This is the main header file for Xilinx HDMI RX core. HDMI RX core is used
+* for extracting the video and audio streams from HDMI stream. It consists of
+* - Receiver core
+* - AXI4-Stream to Video Bridge
+* - Video Timing Controller and
+* - High-bandwidth Digital Content Protection (HDCP) (Optional)
+* - Data Recovery Unit (DRU) (Optional).
+*
+* Receiver core performs following operations:
+* - Aligns incoming data stream to the word boundary and removes inter channel
+* skew.
+* - Unscrambles the data if data rates above the 3.4 Gps. Otherwise bypasses
+* the Scrambler.
+* - Splits the data stream into video and packet data streams.
+* - Optional data streams decrypt by an external HDCP module.
+* - Decodes TMDS data into video data.
+* - Converts the pixel data from the link domain into the video domain.
+*
+* AXI Video Bridge converts the captured native video to AXI stream and outputs
+* the video data through the AXI video interface.
+*
+* Video Timing Controller (VTC) measures the video timing.
+*
+* Data Recovery Unit (DRU) to recover the data from the HDMI stream if incoming
+* HDMI stream is too slow for the transceiver.
+*
+* <b>Core Features </b>
+*
+* For a full description of HDMI RX features, please see the hardware
+* specification.
+*
+* <b>Software Initialization & Configuration</b>
+*
+* The application needs to do following steps in order for preparing the
+* HDMI RX core to be ready.
+*
+* - Call XV_HdmiRx_LookupConfig using a device ID to find the core configuration.
+* - Call XV_HdmiRx_CfgInitialize to initialize the device and the driver
+* instance associated with it.
+*
+* <b>Interrupts </b>
+*
+* This driver provides interrupt handlers
+* - XV_HdmiRx_IntrHandler, for handling the interrupts from the HDMI RX core
+* peripherals.
+*
+* Application developer needs to register interrupt handler with the processor,
+* within their examples. Whenever processor calls registered application's
+* interrupt handler associated with interrupt id, application's interrupt
+* handler needs to call appropriate peripheral interrupt handler reading
+* peripheral's Status register.
+
+* This driver provides XV_HdmiRx_SetCallback API to register functions with HDMI
+* RX core instance.
+*
+* <b> Virtual Memory </b>
+*
+* This driver supports Virtual Memory. The RTOS is responsible for calculating
+* the correct device base address in Virtual Memory space.
+*
+* <b> Threads </b>
+*
+* This driver is not thread safe. Any needs for threads or thread mutual
+* exclusion must be satisfied by the layer above this driver.
+*
+* <b> Asserts </b>
+*
+* Asserts are used within all Xilinx drivers to enforce constraints on argument
+* values. Asserts can be turned off on a system-wide basis by defining, at
+* compile time, the NDEBUG identifier. By default, asserts are turned on and it
+* is recommended that users leave asserts on during development.
+*
+* <b> Building the driver </b>
+*
+* The HDMI RX driver is composed of several source files. This allows the user
+* to build and link only those parts of the driver that are necessary.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  gm, mg 10/07/15 Initial release.
+* 1.01  yh     14/01/16 Added Marco for AxisEnable PIO
+* 1.02  yh     15/01/16 Added 3D Video support
+* 1.03  MG     18/02/16 Added link error callback.
+* 1.04  MG     08/03/16 Added RefClk to structure XV_HdmiRx_Stream
+* 1.05  MG     13/05/16 Added XV_HdmiRx_DdcHdcp22Mode and XV_HdmiRx_DdcHdcp14
+*                       Mode macros
+* 1.06  MG     27/05/16 Added VTD timebase macro
+* 1.07  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                          XV_HdmiRx_Config
+*                          XV_HdmiRx_CfgInitialize
+* 1.08  YH     14/11/16 Added XV_HdmiRx_Bridge_yuv420 & XV_HdmiRx_Bridge_pixel
+*                          mode macros
+* 1.09  MMO    02/03/17 Added Sync Loss and IsMode Handler for HDCP
+*                          compliance test.
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMIRX_H_
+#define XV_HDMIRX_H_		/**< Prevent circular inclusions
+				  *  by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmirx_hw.h"
+#include "xil_assert.h"
+#include "xstatus.h"
+#include "xdebug.h"
+#include "xvidc.h"
+
+#include "xv_hdmirx_vsif.h"
+/************************** Constant Definitions *****************************/
+
+/** @name Handler Types
+* @{
+*/
+/**
+* These constants specify different types of handler and used to differentiate
+* interrupt requests from peripheral.
+*/
+typedef enum {
+	XV_HDMIRX_HANDLER_CONNECT = 1,	/**< A connect event interrupt type */
+	XV_HDMIRX_HANDLER_AUX,			/**< Interrupt type for AUX peripheral */
+	XV_HDMIRX_HANDLER_AUD,			/**< Interrupt type for AUD peripheral */
+	XV_HDMIRX_HANDLER_LNKSTA,		/**< Interrupt type for LNKSTA peripheral */
+	XV_HDMIRX_HANDLER_DDC,			/**< Interrupt type for DDC	peripheral */
+	XV_HDMIRX_HANDLER_STREAM_DOWN,	/**< Interrupt type for stream down */
+	XV_HDMIRX_HANDLER_STREAM_INIT,	/**< Interrupt type for stream init */
+	XV_HDMIRX_HANDLER_STREAM_UP,	/**< Interrupt type for stream up */
+	XV_HDMIRX_HANDLER_HDCP,			/**< Interrupt type for hdcp */
+	XV_HDMIRX_HANDLER_LINK_ERROR,		/**< Interrupt type for link error */
+	XV_HDMIRX_HANDLER_SYNC_LOSS,       /**< Interrupt type for sync loss */
+	XV_HDMIRX_HANDLER_MODE             /**< Interrupt type for mode */
+} XV_HdmiRx_HandlerType;
+/*@}*/
+
+/** @name HDMI RX stream status
+* @{
+*/
+typedef enum {
+	XV_HDMIRX_STATE_STREAM_DOWN,			/**< Stream down */
+	XV_HDMIRX_STATE_STREAM_IDLE,			/**< Stream idle */
+	XV_HDMIRX_STATE_STREAM_INIT,			/**< Stream init */
+	XV_HDMIRX_STATE_STREAM_ARM,				/**< Stream arm */
+	XV_HDMIRX_STATE_STREAM_LOCK,			/**< Stream lock */
+	XV_HDMIRX_STATE_STREAM_RDY,				/**< Stream ready */
+	XV_HDMIRX_STATE_STREAM_UP				/**< Stream up */
+} XV_HdmiRx_State;
+
+/**************************** Type Definitions *******************************/
+
+/**
+* This typedef contains Video identification information in tabular form.
+*/
+typedef struct {
+	XVidC_VideoMode VmId;	/**< Video mode/Resolution ID */
+	u8 Vic;			/**< Video Identification code */
+} XV_HdmiRx_VicTable;
+
+/**
+* This typedef contains configuration information for the HDMI RX core.
+* Each HDMI RX device should have a configuration structure associated.
+*/
+typedef struct {
+	u16 DeviceId;		/**< DeviceId is the unique ID of the HDMI RX core */
+	UINTPTR BaseAddress;	/**< BaseAddress is the physical base address
+						* of the core's registers */
+} XV_HdmiRx_Config;
+
+/**
+* This typedef contains HDMI RX audio stream specific data structure.
+*/
+typedef struct {
+	u8	Active;			/**< Active flag. This flag is set when an acitve audio
+						* stream was detected */
+	u8 	Channels;		/**< Channels */
+} XV_HdmiRx_AudioStream;
+
+/**
+* This typedef contains HDMI RX stream specific data structure.
+*/
+typedef struct {
+	XVidC_VideoStream 	Video;			/**< Video stream for HDMI RX */
+	XV_HdmiRx_AudioStream	Audio;		/**< Audio stream */
+	u8 	Vic;							/**< Video Identification code flag */
+	u8 	IsHdmi;							/**< HDMI flag. 1 - HDMI Stream, 0 - DVI Stream */
+	u32 PixelClk;						/**< Pixel Clock */
+	u32 RefClk;							/**< Reference Clock */
+	u8 	IsScrambled; 					/**< Scrambler flag 1 - scrambled data ,
+										*	0 - non scrambled data */
+	XV_HdmiRx_State	State;				/**< State */
+	u8 	IsConnected;					/**< Connected flag. This flag is set when
+										* the cable is connected */
+	u8 GetVideoPropertiesTries;			/** This value is used  in the GetVideoProperties API*/
+} XV_HdmiRx_Stream;
+
+
+/**
+* This typedef contains Auxiliary header information for infoframe.
+*/
+typedef union {
+	u32 Data;	/**< AUX header data field */
+	u8 Byte[4];	/**< AUX header byte field */
+} XV_HdmiRx_AuxHeader;
+
+/**
+* This typedef contains Auxiliary data information for infoframe.
+*/
+typedef union {
+	u32 Data[8];	/**< AUX data field */
+	u8 Byte[32];	/**< AUX data byte field */
+} XV_HdmiRx_AuxData;
+
+/**
+* This typedef holds HDMI RX Auxiliary peripheral specific data structure.
+*/
+typedef struct {
+	XV_HdmiRx_AuxHeader Header;	/**< AUX header field */
+	XV_HdmiRx_AuxData Data;		/**< AUX data field */
+} XV_HdmiRx_Aux;
+
+/**
+* Callback type for interrupt.
+*
+* @param	CallbackRef is a callback reference passed in by the upper
+*		layer when setting the callback functions, and passed back to
+*		the upper layer when the callback is invoked.
+*
+* @return	None.
+*
+* @note		None.
+*
+*/
+typedef void (*XV_HdmiRx_Callback)(void *CallbackRef);
+typedef void (*XV_HdmiRx_HdcpCallback)(void *CallbackRef, int Data);
+
+/**
+* The XHdmiRx driver instance data. An instance must be allocated for each
+* HDMI RX core in use.
+*/
+typedef struct {
+	XV_HdmiRx_Config Config;				/**< Hardware Configuration */
+	u32 IsReady;							/**< Core and the driver instance are initialized */
+
+	/*Callbacks */
+	XV_HdmiRx_Callback ConnectCallback;		/**< Callback for connect event interrupt */
+	void *ConnectRef;						/**< To be passed to the connect interrupt callback */
+	u32 IsConnectCallbackSet;				/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback AuxCallback;			/**< Callback for AUX event interrupt */
+	void *AuxRef;							/**< To be passed to the AUX interrupt callback */
+	u32 IsAuxCallbackSet;					/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback AudCallback;			/**< Callback for AUD event interrupt */
+	void *AudRef;							/**< To be passed to the Audio interrupt callback */
+	u32 IsAudCallbackSet;					/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback LnkStaCallback;		/**< Callback for LNKSTA event interrupt */
+	void *LnkStaRef;						/**< To be passed to the LNKSTA interrupt callback */
+	u32 IsLnkStaCallbackSet;				/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback DdcCallback;			/**< Callback for PDDC interrupt */
+	void *DdcRef;							/**< To be passed to the DDC interrupt callback */
+	u32 IsDdcCallbackSet;					/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback StreamDownCallback;	/**< Callback for stream down callback */
+	void *StreamDownRef;					/**< To be passed to the stream down callback */
+	u32	IsStreamDownCallbackSet;			/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback StreamInitCallback;	/**< Callback for stream init callback */
+	void *StreamInitRef;					/**< To be passed to the stream start callback */
+	u32 IsStreamInitCallbackSet;			/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback StreamUpCallback;		/**< Callback for stream up callback */
+	void *StreamUpRef;						/**< To be passed to the stream up callback */
+	u32 IsStreamUpCallbackSet;				/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_HdcpCallback HdcpCallback;	/**< Callback for hdcp callback */
+	void *HdcpRef;							/**< To be passed to the hdcp callback */
+	u32	IsHdcpCallbackSet;					/**< Set flag. This flag is set to true when the callback has been registered */
+	XV_HdmiRx_Callback LinkErrorCallback;	/**< Callback for link error callback */
+	void *LinkErrorRef;						/**< To be passed to the link error callback */
+	u32 IsLinkErrorCallbackSet;				/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback SyncLossCallback;		/**< Callback for sync loss callback */
+	void *SyncLossRef;						/**< To be passed to the link error callback */
+	u32 IsSyncLossCallbackSet;				/**< Set flag. This flag is set to true when the callback has been registered */
+
+	XV_HdmiRx_Callback ModeCallback;			/**< Callback for sync loss callback */
+	void *ModeRef;							/**< To be passed to the link error callback */
+	u32 IsModeCallbackSet;					/**< Set flag. This flag is set to true when the callback has been registered */
+
+	/* HDMI RX stream */
+	XV_HdmiRx_Stream Stream;				/**< HDMI RX stream information */
+
+	/* Aux peripheral specific */
+	XV_HdmiRx_Aux Aux;					/**< AUX peripheral information */
+
+	/* Audio peripheral specific */
+	u32 AudCts;							/**< Audio CTS */
+	u32 AudN;							/**< Audio N element */
+	u32 AudFormat;						/**< Audio Format */
+} XV_HdmiRx;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* This macro reads the RX version
+*
+* @param  InstancePtr is a pointer to the XHdmi_RX core instance.
+*
+* @return RX version.
+*
+* *note	C-style signature:
+*		u32 XV_HdmiRx_GetVersion(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_GetVersion(InstancePtr) \
+  XV_HdmiRx_ReadReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VER_VERSION_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This macro asserts or clears the HDMI RX reset.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param	Reset specifies TRUE/FALSE value to either assert or
+*		release HDMI RX reset.
+*
+* @return	None.
+*
+* @note		The reset output of the PIO is inverted. When the system is
+*		in reset, the PIO output is cleared and this will reset the
+*		HDMI RX. Therefore, clearing the PIO reset output will assert
+*		the HDMI link and video reset.
+*		C-style signature:
+*		void XV_HdmiRx_Reset(XV_HdmiRx *InstancePtr, u8 Reset)
+*
+******************************************************************************/
+#define XV_HdmiRx_Reset(InstancePtr, Reset) \
+{ \
+	if (Reset) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_RESET_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_RESET_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro asserts or clears the HDMI RX link enable.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either assert or
+*		release HDMI RX link enable.
+*
+* @return	None.
+*
+* @note
+*		C-style signature:
+*		void XV_HdmiRx_Reset(XV_HdmiRx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiRx_LinkEnable(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_LNK_EN_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_LNK_EN_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro asserts or clears the HDMI RX video enable.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either assert or
+*		release HDMI RX video enable.
+*
+* @return	None.
+*
+* @note
+*		C-style signature:
+*		void XV_HdmiRx_Reset(XV_HdmiRx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiRx_VideoEnable(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_VID_EN_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_VID_EN_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the HDMI RX Scrambler.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Tx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either enable or disable the
+*		scrambler.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_SetScrambler(XV_HdmiRx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiRx_SetScrambler(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_SCRM_MASK)); \
+		(InstancePtr)->Stream.IsScrambled = (TRUE); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_SCRM_MASK)); \
+		(InstancePtr)->Stream.IsScrambled = (FALSE); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the YUV420 mode for video bridge.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Rx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either enable or disable the
+*		YUV 420 Support.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_Bridge_yuv420(XV_HdmiRx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiRx_Bridge_yuv420(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro controls the Pixel Drop mode for video bridge.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Rx core instance.
+* @param	SetClr specifies TRUE/FALSE value to either enable or disable the
+*		Pixel Repitition.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_Bridge_pixel(XV_HdmiRx *InstancePtr, u8 SetClr)
+*
+******************************************************************************/
+#define XV_HdmiRx_Bridge_pixel(InstancePtr, SetClr) \
+{ \
+	if (SetClr) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro asserts or clears the AXIS enable output port.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+* @param	Reset specifies TRUE/FALSE value to either assert or
+*		release HDMI RX reset.
+*
+* @return	None.
+*
+* @note		The reset output of the PIO is inverted. When the system is
+*		in reset, the PIO output is cleared and this will reset the
+*		HDMI RX. Therefore, clearing the PIO reset output will assert
+*		the HDMI link and video reset.
+*		C-style signature:
+*		void XV_HdmiRx_AxisEnable(InstancePtr, Enable)
+*
+******************************************************************************/
+#define XV_HdmiRx_AxisEnable(InstancePtr, Enable) \
+{ \
+	if (Enable) { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_SET_OFFSET), (XV_HDMIRX_PIO_OUT_AXIS_EN_MASK)); \
+	} \
+	else { \
+		XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_OUT_CLR_OFFSET), (XV_HDMIRX_PIO_OUT_AXIS_EN_MASK)); \
+	} \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX PIO peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_PioEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_PioEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_CTRL_SET_OFFSET), (XV_HDMIRX_PIO_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX PIO peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_PioDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_PioDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_CTRL_CLR_OFFSET), (XV_HDMIRX_PIO_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupts in the HDMI RX PIO peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_PioIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_PioIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_CTRL_SET_OFFSET), (XV_HDMIRX_PIO_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupts in the HDMI RX PIO peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_PioIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_PioIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_PIO_CTRL_CLR_OFFSET), (XV_HDMIRX_PIO_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX timer peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_TmrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_TmrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_TMR_CTRL_SET_OFFSET), (XV_HDMIRX_TMR_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX timer peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_TmrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_TmrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_TMR_CTRL_CLR_OFFSET), (XV_HDMIRX_TMR_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupts in the HDMI RX timer peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_TmrIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_TmrIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_TMR_CTRL_SET_OFFSET), (XV_HDMIRX_TMR_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupt in the HDMI RX timer peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_TmrIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_TmrIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_TMR_CTRL_CLR_OFFSET), (XV_HDMIRX_TMR_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro starts the HDMI RX timer peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_TmrStart(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_TmrStart(InstancePtr, Value) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_TMR_CNT_OFFSET), (u32)(Value))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX Timing Detector peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_VtdEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_VtdEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VTD_CTRL_SET_OFFSET), (XV_HDMIRX_VTD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX Timing Detector peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_VtdDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_VtdDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VTD_CTRL_CLR_OFFSET), (XV_HDMIRX_VTD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupt in the HDMI RX Timing Detector peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_VtdIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_VtdIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VTD_CTRL_SET_OFFSET), (XV_HDMIRX_VTD_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupt in the HDMI RX Timing Detector peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_VtdIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_VtdIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VTD_CTRL_CLR_OFFSET), (XV_HDMIRX_VTD_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the timebase in the HDMI RX Timing Detector peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_VtdSetTimebase(XV_HdmiRx *InstancePtr, Value)
+*
+******************************************************************************/
+#define XV_HdmiRx_VtdSetTimebase(InstancePtr, Value) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_VTD_CTRL_OFFSET), (u32)(Value << XV_HDMIRX_VTD_CTRL_TIMEBASE_SHIFT))
+
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX Display Data Channel (DDC) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the SCDC in the DDC peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcScdcEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcScdcEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_SCDC_EN_MASK));
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDCP in the DDC peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcHdcpEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcHdcpEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_HDCP_EN_MASK));
+
+#define XV_HdmiRx_DdcHdcpDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_CLR_OFFSET), (XV_HDMIRX_DDC_CTRL_HDCP_EN_MASK));
+
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the DDC peripheral into HDCP 1.4 mode.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcHdcp14Mode(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcHdcp14Mode(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_CLR_OFFSET), (XV_HDMIRX_DDC_CTRL_HDCP_MODE_MASK));
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the DDC peripheral into HDCP 2.2 mode.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcHdcp22Mode(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcHdcp22Mode(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_HDCP_MODE_MASK));
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX Display Data Channel (DDC) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_CLR_OFFSET), (XV_HDMIRX_DDC_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupts in the HDMI RX Display Data Channel (DDC)
+* peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupts in the HDMI RX Display Data Channel (DDC)
+* peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_CLR_OFFSET), (XV_HDMIRX_DDC_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro clears the SCDC registers in the DDC peripheral
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_DdcScdcClear(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcScdcClear(InstancePtr) \
+{ \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_SCDC_CLR_MASK)); \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_CLR_OFFSET), (XV_HDMIRX_DDC_CTRL_SCDC_CLR_MASK)); \
+}
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX Auxiliary (AUX) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AuxEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AuxEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUX_CTRL_SET_OFFSET), (XV_HDMIRX_AUX_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX Auxiliary (AUX) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AuxDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AuxDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUX_CTRL_CLR_OFFSET), (XV_HDMIRX_AUX_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupts in the HDMI RX Auxiliary (AUX) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AuxIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AuxIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUX_CTRL_SET_OFFSET), (XV_HDMIRX_AUX_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupts in the HDMI RX Auxiliary (AUX) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AuxIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AuxIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUX_CTRL_CLR_OFFSET), (XV_HDMIRX_AUX_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX Audio (AUD) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AudioEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AudioEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUD_CTRL_SET_OFFSET), (XV_HDMIRX_AUD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX Audio (AUD) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AudioDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AudioDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUD_CTRL_CLR_OFFSET), (XV_HDMIRX_AUD_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupts in the HDMI RX Audio (AUD) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AudioIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AudioIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUD_CTRL_SET_OFFSET), (XV_HDMIRX_AUD_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables interrupts in the HDMI RX Audio (AUD) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_AudioIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_AudioIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_AUD_CTRL_CLR_OFFSET), (XV_HDMIRX_AUD_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables the HDMI RX Link Status (LNKSTA) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_LinkstaEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_LnkstaEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_SET_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disables the HDMI RX Link Status (LNKSTA) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_LinkstaDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_LnkstaDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_CLR_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_RUN_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro enables interrupt in the HDMI RX Link Status (LNKSTA) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_LinkIntrEnable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_LinkIntrEnable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_SET_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro disable interrupt in the HDMI RX Link Status (LNKSTA) peripheral.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XV_HdmiRx_LinkIntrDisable(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_LinkIntrDisable(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_LNKSTA_CTRL_CLR_OFFSET), (XV_HDMIRX_LNKSTA_CTRL_IE_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro returns true is the audio stream is active else false
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	TRUE if the audio stream is active, FALSE if it is not.
+*
+* @note		C-style signature:
+*		u32 XV_HdmiRx_IsAudioActive(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_IsAudioActive(InstancePtr) \
+	(InstancePtr)->Stream.Audio.Active
+
+/*****************************************************************************/
+/**
+*
+* This macro returns the number of active audio channels.
+*
+* @param	InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return	Number of active audio channels.
+*
+* @note		C-style signature:
+*		u32 XV_HdmiRx_GetAudioChannels(XV_HdmiRx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_GetAudioChannels(InstancePtr) \
+	(InstancePtr)->Stream.Audio.Channels
+
+/*****************************************************************************/
+/**
+*
+* This macro clears the HDCP write message buffer in the DDC peripheral.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XHdmiRx_DdcHdcpClearWriteMessageBuffer(XHdmi_Rx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcHdcpClearWriteMessageBuffer(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_WMSG_CLR_MASK))
+
+/*****************************************************************************/
+/**
+*
+* This macro clears the HDCP read message buffer in the DDC peripheral.
+*
+* @param	InstancePtr is a pointer to the XHdmi_Rx core instance.
+*
+* @return	None.
+*
+* @note		C-style signature:
+*		void XHdmiRx_DdcHdcpClearReadMessageBuffer(XHdmi_Rx *InstancePtr)
+*
+******************************************************************************/
+#define XV_HdmiRx_DdcHdcpClearReadMessageBuffer(InstancePtr) \
+	XV_HdmiRx_WriteReg((InstancePtr)->Config.BaseAddress, (XV_HDMIRX_DDC_CTRL_SET_OFFSET), (XV_HDMIRX_DDC_CTRL_RMSG_CLR_MASK))
+
+/************************** Function Prototypes ******************************/
+
+/* Initialization function in xv_hdmirx_sinit.c */
+XV_HdmiRx_Config *XV_HdmiRx_LookupConfig(u16 DeviceId);
+
+/* Initialization and control functions in xv_hdmirx.c */
+int XV_HdmiRx_CfgInitialize(XV_HdmiRx *InstancePtr, XV_HdmiRx_Config *CfgPtr, UINTPTR EffectiveAddr);
+void XV_HdmiRx_Clear(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_SetStream(XV_HdmiRx *InstancePtr, XVidC_PixelsPerClock Ppc, u32 Clock);
+int XV_HdmiRx_IsStreamUp(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_IsStreamScrambled(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_IsStreamConnected(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_SetHpd(XV_HdmiRx *InstancePtr, u8 SetClr);
+int XV_HdmiRx_SetPixelRate(XV_HdmiRx *InstancePtr);
+void XV_HdmiRx_SetColorFormat(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_IsLinkStatusErrMax(XV_HdmiRx *InstancePtr);
+void XV_HdmiRx_ClearLinkStatus(XV_HdmiRx *InstancePtr);
+u32 XV_HdmiRx_GetLinkStatus(XV_HdmiRx *InstancePtr, u8 Type);
+u32 XV_HdmiRx_GetAcrCts(XV_HdmiRx *InstancePtr);
+u32 XV_HdmiRx_GetAcrN(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_DdcLoadEdid(XV_HdmiRx *InstancePtr, u8 *Data, u16 Length);
+void XV_HdmiRx_DdcHdcpSetAddress(XV_HdmiRx *InstancePtr, u32 Addr);
+void XV_HdmiRx_DdcHdcpWriteData(XV_HdmiRx *InstancePtr, u32 Data);
+u32 XV_HdmiRx_DdcHdcpReadData(XV_HdmiRx *InstancePtr);
+u16 XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty(XV_HdmiRx *InstancePtr);
+u16 XV_HdmiRx_DdcGetHdcpReadMessageBufferWords(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_GetTmdsClockRatio(XV_HdmiRx *InstancePtr);
+u8 XV_HdmiRx_GetAviVic(XV_HdmiRx *InstancePtr);
+XVidC_ColorFormat XV_HdmiRx_GetAviColorSpace(XV_HdmiRx *InstancePtr);
+XVidC_ColorDepth XV_HdmiRx_GetGcpColorDepth(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_GetVideoProperties(XV_HdmiRx *InstancePtr);
+int XV_HdmiRx_GetVideoTiming(XV_HdmiRx *InstancePtr);
+u32 XV_HdmiRx_Divide(u32 Dividend, u32 Divisor);
+
+/* Log specific functions */
+void XV_HdmiRx_DebugInfo(XV_HdmiRx *InstancePtr);
+
+/* Self test function in xv_hdmirx_selftest.c */
+int XV_HdmiRx_SelfTest(XV_HdmiRx *InstancePtr);
+
+/* Interrupt related function in xv_hdmirx_intr.c */
+void XV_HdmiRx_IntrHandler(void *InstancePtr);
+int XV_HdmiRx_SetCallback(XV_HdmiRx *InstancePtr, u32 HandlerType, void *CallbackFunc, void *CallbackRef);
+
+/* Vendor Specific Infomation related functions in xv_hdmirx_vsif.c */
+int XV_HdmiRx_VSIF_ParsePacket(XV_HdmiRx_Aux *AuxPtr, XV_HdmiRx_VSIF  *VSIFPtr);
+void XV_HdmiRx_VSIF_DisplayInfo(XV_HdmiRx_VSIF  *VSIFPtr);
+char* XV_HdmiRx_VSIF_3DStructToString(XV_HdmiRx_3D_Struct_Field Item);
+char* XV_HdmiRx_VSIF_3DSampMethodToString(XV_HdmiRx_3D_Sampling_Method Item);
+char* XV_HdmiRx_VSIF_3DSampPosToString(XV_HdmiRx_3D_Sampling_Position Item);
+/************************** Variable Declarations ****************************/
+/************************** Variable Declarations ****************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* End of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_hw.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_hw.h
new file mode 100644
index 0000000..6833bf5
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_hw.h
@@ -0,0 +1,370 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx_hw.h
+*
+* This header file contains identifiers and register-level core functions (or
+* macros) that can be used to access the Xilinx HDMI RX core.
+*
+* For more information about the operation of this core see the hardware
+* specification and documentation in the higher level driver xv_hdmirx.h file.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  gm, mg 11/03/15 Initial release.
+* 1.01  MG     30/12/15 Added DDC peripheral HDCP 2.2 masks
+* 1.02  yh     14/01/16 Added Bit Masking for AxisEnable PIO
+* 1.03  MG     18/02/16 Added AUX peripheral error event mask
+* 1.04  MG     13/05/16 Added DDC HDCP mode mask
+* 1.05  MG     27/05/16 Added VTD timebase
+* 1.06  MH     26/07/16 Added DDC HDCP protocol event.
+* 1.07  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiRx_WriteReg
+*                       XV_HdmiRx_ReadReg
+* 1.08  YH     14/11/16 Added BRIDGE_YUV420 and BRIDGE_PIXEL mask to PIO Out
+* 1.09  MMO    02/03/17 Added XV_HDMIRX_VTD_CTRL_SYNC_LOSS_MASK and
+*                          XV_HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK for HDCP
+*                          compliance
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMIRX_HW_H_
+#define XV_HDMIRX_HW_H_     /**< Prevent circular inclusions
+                  *  by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xil_io.h"
+
+/************************** Constant Definitions *****************************/
+
+// VER (Version Interface) peripheral register offsets
+#define XV_HDMIRX_VER_BASE                          (0*64)
+#define XV_HDMIRX_VER_ID_OFFSET                     ((XV_HDMIRX_VER_BASE)+(0*4))    /**< VER Identification *  Register offset */
+#define XV_HDMIRX_VER_VERSION_OFFSET                    ((XV_HDMIRX_VER_BASE)+(1*4))    /**< VER Version Register *  offset */
+
+// PIO (Parallel Interface) peripheral register offsets
+#define XV_HDMIRX_PIO_BASE                          (1*64)
+#define XV_HDMIRX_PIO_ID_OFFSET                     ((XV_HDMIRX_PIO_BASE)+(0*4))    /**< PIO Identification register offset */
+#define XV_HDMIRX_PIO_CTRL_OFFSET                   ((XV_HDMIRX_PIO_BASE)+(1*4))    /**< PIO Control register offset */
+#define XV_HDMIRX_PIO_CTRL_SET_OFFSET               ((XV_HDMIRX_PIO_BASE)+(2*4))    /**< PIO Control Register Set offset */
+#define XV_HDMIRX_PIO_CTRL_CLR_OFFSET               ((XV_HDMIRX_PIO_BASE)+(3*4))    /**< PIO Control Register Clear offset */
+#define XV_HDMIRX_PIO_STA_OFFSET                        ((XV_HDMIRX_PIO_BASE)+(4*4))    /**< PIO Status Register offset */
+#define XV_HDMIRX_PIO_OUT_OFFSET                        ((XV_HDMIRX_PIO_BASE)+(5*4))    /**< PIO Out Register offset */
+#define XV_HDMIRX_PIO_OUT_SET_OFFSET                    ((XV_HDMIRX_PIO_BASE)+(6*4))    /**< PIO Out Register Set offset */
+#define XV_HDMIRX_PIO_OUT_CLR_OFFSET                    ((XV_HDMIRX_PIO_BASE)+(7*4))    /**< PIO Out Register Clear offset */
+#define XV_HDMIRX_PIO_OUT_MSK_OFFSET                    ((XV_HDMIRX_PIO_BASE)+(8*4))    /**< PIO Out Mask Register  offset */
+#define XV_HDMIRX_PIO_IN_OFFSET                     ((XV_HDMIRX_PIO_BASE)+(9*4))    /**< PIO In Register offset */
+#define XV_HDMIRX_PIO_IN_EVT_OFFSET                 ((XV_HDMIRX_PIO_BASE)+(10*4))   /**< PIO In Event Register offset */
+#define XV_HDMIRX_PIO_IN_EVT_RE_OFFSET              ((XV_HDMIRX_PIO_BASE)+(11*4))   /**< PIO In Event Rising Edge Register offset */
+#define XV_HDMIRX_PIO_IN_EVT_FE_OFFSET              ((XV_HDMIRX_PIO_BASE)+(12*4))   /**< PIO In Event Falling Edge Register offset */
+
+// PIO peripheral Control register masks
+#define XV_HDMIRX_PIO_CTRL_RUN_MASK                 (1<<0)  /**< PIO Control Run mask */
+#define XV_HDMIRX_PIO_CTRL_IE_MASK                  (1<<1)  /**< PIO Control Interrupt Enable mask */
+
+// PIO peripheral Status register masks
+#define XV_HDMIRX_PIO_STA_IRQ_MASK                  (1<<0)  /**< PIO Status Interrupt mask */
+#define XV_HDMIRX_PIO_STA_EVT_MASK                  (1<<1)  /**< PIO Status Event mask */
+
+// PIO peripheral PIO Out register masks and shifts
+#define XV_HDMIRX_PIO_OUT_RESET_MASK                    (1<<0)  /**< PIO Out Reset mask */
+#define XV_HDMIRX_PIO_OUT_LNK_EN_MASK               (1<<1)  /**< PIO Out video enable mask */
+#define XV_HDMIRX_PIO_OUT_VID_EN_MASK               (1<<2)  /**< PIO Out video enable mask */
+#define XV_HDMIRX_PIO_OUT_HPD_MASK                  (1<<3)  /**< PIO Out Hot-Plug Detect mask */
+#define XV_HDMIRX_PIO_OUT_DEEP_COLOR_MASK           0x30    /**< PIO Out Deep Color mask */
+#define XV_HDMIRX_PIO_OUT_PIXEL_RATE_MASK           0xC0    /**< PIO Out Pixel Rate mask */
+#define XV_HDMIRX_PIO_OUT_SAMPLE_RATE_MASK          0x300   /**< PIO Out Sample Rate mask */
+#define XV_HDMIRX_PIO_OUT_COLOR_SPACE_MASK          0xC00   /**< PIO Out Color Space mask */
+#define XV_HDMIRX_PIO_OUT_AXIS_EN_MASK              0x80000 /**< PIO Out Axis Enable mask */
+#define XV_HDMIRX_PIO_OUT_DEEP_COLOR_SHIFT          4       /**< PIO Out Deep Color shift */
+#define XV_HDMIRX_PIO_OUT_PIXEL_RATE_SHIFT          6       /**< PIO Out Pixel Rate Shift */
+#define XV_HDMIRX_PIO_OUT_SAMPLE_RATE_SHIFT         8       /**< PIO Out Sample Rate shift */
+#define XV_HDMIRX_PIO_OUT_COLOR_SPACE_SHIFT         10      /**< PIO Out Color Space shift */
+#define XV_HDMIRX_PIO_OUT_SCRM_MASK                 (1<<12) /**< PIO Out Scrambler mask */
+#define XV_HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK        (1<<29) /**< PIO Out Bridge_YUV420 mask */
+#define XV_HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK         (1<<30) /**< PIO Out Bridge_Pixel drop mask */
+
+// PIO peripheral PIO In register masks
+#define XV_HDMIRX_PIO_IN_DET_MASK                   (1<<0) /**< PIO In cable detect mask */
+#define XV_HDMIRX_PIO_IN_LNK_RDY_MASK               (1<<1) /**< PIO In link ready mask */
+#define XV_HDMIRX_PIO_IN_VID_RDY_MASK               (1<<2) /**< PIO In video ready mask */
+#define XV_HDMIRX_PIO_IN_MODE_MASK                  (1<<3) /**< PIO In Mode mask */
+#define XV_HDMIRX_PIO_IN_SCRAMBLER_LOCK0_MASK       (1<<4) /**< PIO In Scrambler lock 0 mask */
+#define XV_HDMIRX_PIO_IN_SCRAMBLER_LOCK1_MASK       (1<<5) /**< PIO In Scrambler lock 1 mask */
+#define XV_HDMIRX_PIO_IN_SCRAMBLER_LOCK2_MASK       (1<<6) /**< PIO In Scrambler lock 2 mask */
+#define XV_HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK (1<<7) /**< PIO In SCDC scrambler enable mask */
+#define XV_HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK (1<<8) /**< PIO In SCDC TMDS clock ratio mask */
+
+// Timer peripheral register offsets
+#define XV_HDMIRX_TMR_BASE                          (2*64)
+#define XV_HDMIRX_TMR_ID_OFFSET                     ((XV_HDMIRX_TMR_BASE)+(0*4))    /**< TMR Identification register offset */
+#define XV_HDMIRX_TMR_CTRL_OFFSET                   ((XV_HDMIRX_TMR_BASE)+(1*4))    /**< TMR Control register offset */
+#define XV_HDMIRX_TMR_CTRL_SET_OFFSET               ((XV_HDMIRX_TMR_BASE)+(2*4))    /**< TMR Control Register Set offset */
+#define XV_HDMIRX_TMR_CTRL_CLR_OFFSET               ((XV_HDMIRX_TMR_BASE)+(3*4))    /**< TMR Control Register Clear offset */
+#define XV_HDMIRX_TMR_STA_OFFSET                        ((XV_HDMIRX_TMR_BASE)+(4*4))    /**< TMR Status Register offset */
+#define XV_HDMIRX_TMR_CNT_OFFSET                        ((XV_HDMIRX_TMR_BASE)+(5*4))    /**< TMR Counter Register offset */
+
+// Timer peripheral Control register masks
+#define XV_HDMIRX_TMR_CTRL_RUN_MASK                 (1<<0)  /**< TMR Control Run mask */
+#define XV_HDMIRX_TMR_CTRL_IE_MASK                  (1<<1)  /**< TMR Control Interrupt Enable mask */
+
+// Timer peripheral Status register masks
+#define XV_HDMIRX_TMR_STA_IRQ_MASK                  (1<<0)  /**< TMR Status Interrupt mask */
+#define XV_HDMIRX_TMR_STA_CNT_EVT_MASK              (1<<1)  /**< TMR Status counter Event mask */
+
+// Video Timing Detector (VTD) peripheral register offsets.
+#define XV_HDMIRX_VTD_BASE                          (3*64)
+#define XV_HDMIRX_VTD_ID_OFFSET                     ((XV_HDMIRX_VTD_BASE)+(0*4))    /**< VTD Identification Register offset */
+#define XV_HDMIRX_VTD_CTRL_OFFSET                   ((XV_HDMIRX_VTD_BASE)+(1*4))    /**< VTD Control Register offset */
+#define XV_HDMIRX_VTD_CTRL_SET_OFFSET               ((XV_HDMIRX_VTD_BASE)+(2*4))    /**< VTD Control Set Register offset */
+#define XV_HDMIRX_VTD_CTRL_CLR_OFFSET               ((XV_HDMIRX_VTD_BASE)+(3*4))    /**< VTD Control Clear Register offset */
+#define XV_HDMIRX_VTD_STA_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(4*4))    /**< VTD Status Register offset */
+#define XV_HDMIRX_VTD_TOT_PIX_OFFSET                    ((XV_HDMIRX_VTD_BASE)+(5*4))    /**< VTD Total Pixels Register offset */
+#define XV_HDMIRX_VTD_ACT_PIX_OFFSET                    ((XV_HDMIRX_VTD_BASE)+(6*4))    /**< VTD Active Pixels Register offset */
+#define XV_HDMIRX_VTD_TOT_LIN_OFFSET                    ((XV_HDMIRX_VTD_BASE)+(7*4))    /**< VTD Total Lines Register offset */
+#define XV_HDMIRX_VTD_ACT_LIN_OFFSET                    ((XV_HDMIRX_VTD_BASE)+(8*4))    /**< VTD Active Lines Register offset */
+#define XV_HDMIRX_VTD_VSW_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(9*4))    /**< VTD Vertical Sync Width Register offset */
+#define XV_HDMIRX_VTD_HSW_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(10*4))   /**< VTD Horizontal Sync Width Register offset */
+#define XV_HDMIRX_VTD_VFP_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(11*4))   /**< VTD Vertical Front Porch Register offset */
+#define XV_HDMIRX_VTD_VBP_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(12*4))   /**< VTD Vertical Back Porch Register offset */
+#define XV_HDMIRX_VTD_HFP_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(13*4))   /**< VTD Horizontal Front Porch Register offset */
+#define XV_HDMIRX_VTD_HBP_OFFSET                        ((XV_HDMIRX_VTD_BASE)+(14*4))   /**< VTD Horizontal Back Porch Register offset */
+
+// Video timing detector peripheral Control register masks and shift
+#define XV_HDMIRX_VTD_CTRL_RUN_MASK                 (1<<0)  	/**< VTD Control Run mask */
+#define XV_HDMIRX_VTD_CTRL_IE_MASK                  (1<<1)  	/**< VTD Control Interrupt Enable mask */
+#define XV_HDMIRX_VTD_CTRL_FIELD_POL_MASK           (1<<2)  	/**< VTD Control field polarity mask */
+#define XV_HDMIRX_VTD_CTRL_SYNC_LOSS_MASK           (1<<3)    /**< VTD Control field polarity mask */
+#define XV_HDMIRX_VTD_CTRL_TIMEBASE_SHIFT          	8      		/**< VTD Control timebase shift */
+#define XV_HDMIRX_VTD_CTRL_TIMERBASE_MASK          	0xffffff    /**< VTD Control timebase mask */
+
+// Video timing detector peripheral Status register masks
+#define XV_HDMIRX_VTD_STA_IRQ_MASK                  (1<<0)  /**< VTD Status Interrupt mask */
+#define XV_HDMIRX_VTD_STA_TIMEBASE_EVT_MASK        	(1<<1)  /**< VTD Status timebase event mask */
+#define XV_HDMIRX_VTD_STA_VS_POL_MASK               (1<<3)  /**< VTD Status Vsync Polarity mask */
+#define XV_HDMIRX_VTD_STA_HS_POL_MASK               (1<<4)  /**< VTD Status Hsync Polarity mask */
+#define XV_HDMIRX_VTD_STA_FMT_MASK                  (1<<5)  /**< VTD Status Format mask */
+#define XV_HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK        (1<<6)  /**< VTD Status Sync Loss mask */
+
+// DDC (Display Data Channel) peripheral register offsets.
+#define XV_HDMIRX_DDC_BASE                          (4*64)
+#define XV_HDMIRX_DDC_ID_OFFSET                     ((XV_HDMIRX_DDC_BASE)+(0*4))    /**< DDC Identification Register offset */
+#define XV_HDMIRX_DDC_CTRL_OFFSET                   ((XV_HDMIRX_DDC_BASE)+(1*4))    /**< DDC Control Register offset */
+#define XV_HDMIRX_DDC_CTRL_SET_OFFSET               ((XV_HDMIRX_DDC_BASE)+(2*4))    /**< DDC Control Register Set offset */
+#define XV_HDMIRX_DDC_CTRL_CLR_OFFSET               ((XV_HDMIRX_DDC_BASE)+(3*4))    /**< DDC Control Register Clear offset */
+#define XV_HDMIRX_DDC_STA_OFFSET                    ((XV_HDMIRX_DDC_BASE)+(4*4))    /**< DDC Status Register offset */
+#define XV_HDMIRX_DDC_EDID_STA_OFFSET               ((XV_HDMIRX_DDC_BASE)+(5*4))    /**< DDC EDID Status Register offset */
+#define XV_HDMIRX_DDC_HDCP_STA_OFFSET               ((XV_HDMIRX_DDC_BASE)+(6*4))    /**< DDC HDCP Status Register offset */
+#define XV_HDMIRX_DDC_EDID_SP_OFFSET                ((XV_HDMIRX_DDC_BASE)+(8*4))    /**< DDC Read EDID segment pointer offset */
+#define XV_HDMIRX_DDC_EDID_WP_OFFSET                ((XV_HDMIRX_DDC_BASE)+(9*4))    /**< DDC Read EDID write pointer offset */
+#define XV_HDMIRX_DDC_EDID_RP_OFFSET                ((XV_HDMIRX_DDC_BASE)+(10*4))   /**< DDC Read EDID read pointer offset */
+#define XV_HDMIRX_DDC_EDID_DATA_OFFSET              ((XV_HDMIRX_DDC_BASE)+(11*4))   /**< DDC Read EDID data offset */
+#define XV_HDMIRX_DDC_HDCP_ADDRESS_OFFSET           ((XV_HDMIRX_DDC_BASE)+(12*4))   /**< DDC Read HDCP address offset */
+#define XV_HDMIRX_DDC_HDCP_DATA_OFFSET              ((XV_HDMIRX_DDC_BASE)+(13*4))   /**< DDC Read HDCP data offset */
+
+// DDC peripheral Control register masks
+#define XV_HDMIRX_DDC_CTRL_RUN_MASK                 (1<<0)  /**< DDC Control Run mask */
+#define XV_HDMIRX_DDC_CTRL_IE_MASK                  (1<<1)  /**< DDC Control Interrupt enable mask */
+#define XV_HDMIRX_DDC_CTRL_EDID_EN_MASK             (1<<2)  /**< DDC Control EDID enable mask */
+#define XV_HDMIRX_DDC_CTRL_SCDC_EN_MASK             (1<<3)  /**< DDC Control SCDC enable mask */
+#define XV_HDMIRX_DDC_CTRL_HDCP_EN_MASK             (1<<4)  /**< DDC Control HDCP enable mask */
+#define XV_HDMIRX_DDC_CTRL_SCDC_CLR_MASK            (1<<5)  /**< DDC Control SCDC clear mask */
+#define XV_HDMIRX_DDC_CTRL_WMSG_CLR_MASK            (1<<6)  /**< DDC Control write message clear mask */
+#define XV_HDMIRX_DDC_CTRL_RMSG_CLR_MASK            (1<<7)  /**< DDC Control read message clear mask */
+#define XV_HDMIRX_DDC_CTRL_HDCP_MODE_MASK           (1<<8)  /**< DDC Control HDCP mode mask */
+
+// DDC peripheral Status register masks
+#define XV_HDMIRX_DDC_STA_IRQ_MASK                  (1<<0)  /**< DDC Status Interrupt mask */
+#define XV_HDMIRX_DDC_STA_EVT_MASK                  (1<<1)  /**< DDC Status Event mask */
+#define XV_HDMIRX_DDC_STA_BUSY_MASK                 (1<<2)  /**< DDC Status Busy mask */
+#define XV_HDMIRX_DDC_STA_SCL_MASK                  (1<<3)  /**< DDC Status state of the SCL input mask */
+#define XV_HDMIRX_DDC_STA_SDA_MASK                  (1<<4)  /**< DDC Status state of the SDA input mask */
+#define XV_HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK        (1<<5)  /**< DDC Status HDCP AKSV event mask */
+#define XV_HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK    (1<<6)  /**< DDC Status HDCP write message buffer new event mask */
+#define XV_HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK    (1<<7)  /**< DDC Status HDCP read message buffer end event mask */
+#define XV_HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK     (1<<8)  /**< DDC Status HDCP read message buffer not completed event mask */
+#define XV_HDMIRX_DDC_STA_HDCP_1_PROT_MASK          (1<<9)  /**< DDC Status HDCP 1.4 protocol flag */
+#define XV_HDMIRX_DDC_STA_HDCP_2_PROT_MASK          (1<<10) /**< DDC Status HDCP 2.2 protocol flag */
+#define XV_HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK      (1<<11) /**< DDC Status HDCP 1.4 protocol event flag */
+#define XV_HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK      (1<<12) /**< DDC Status HDCP 2.2 protocol event flag */
+#define XV_HDMIRX_DDC_STA_EDID_WORDS_SHIFT          0       /**< DDC Status EDID words shift */
+#define XV_HDMIRX_DDC_STA_EDID_WORDS_MASK           0xFFFF  /**< DDC Status EDID words mask */
+#define XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_MASK      0x7FF   /**< DDC Status HDCP 2.2 write message buffer words mask */
+#define XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_SHIFT     0       /**< DDC Status HDCP 2.2 write message buffer words shift */
+#define XV_HDMIRX_DDC_STA_HDCP_WMSG_EP_MASK         (1<<11) /**< DDC Status HDCP 2.2 write message buffer empty mask */
+#define XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_MASK      0x7FF   /**< DDC Status HDCP 2.2 read message buffer words mask */
+#define XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_SHIFT     16      /**< DDC Status HDCP 2.2 read message buffer words shift */
+#define XV_HDMIRX_DDC_STA_HDCP_RMSG_EP_MASK         (1<<27) /**< DDC Status HDCP 2.2 read message buffer empty mask */
+
+// Auxiliary (AUX) peripheral register offsets.
+#define XV_HDMIRX_AUX_BASE                          (5*64)
+#define XV_HDMIRX_AUX_ID_OFFSET                     ((XV_HDMIRX_AUX_BASE)+(0*4))    /**< AUX Identification Register offset */
+#define XV_HDMIRX_AUX_CTRL_OFFSET                   ((XV_HDMIRX_AUX_BASE)+(1*4))    /**< AUX Control Register offset */
+#define XV_HDMIRX_AUX_CTRL_SET_OFFSET               ((XV_HDMIRX_AUX_BASE)+(2*4))    /**< AUX Control Register Set offset */
+#define XV_HDMIRX_AUX_CTRL_CLR_OFFSET               ((XV_HDMIRX_AUX_BASE)+(3*4))    /**< AUX Control Register Clear offset */
+#define XV_HDMIRX_AUX_STA_OFFSET                        ((XV_HDMIRX_AUX_BASE)+(4*4))    /**< AUX Status Register offset */
+#define XV_HDMIRX_AUX_DAT_OFFSET                        ((XV_HDMIRX_AUX_BASE)+(5*4))    /**< AUX Data Register offset */
+
+// AUX peripheral Control register masks
+#define XV_HDMIRX_AUX_CTRL_RUN_MASK                 (1<<0)  /**< AUX Control Run mask */
+#define XV_HDMIRX_AUX_CTRL_IE_MASK                  (1<<1)  /**< AUX Control Interrupt Enable mask */
+
+// AUX peripheral Status register masks and shifts
+#define XV_HDMIRX_AUX_STA_IRQ_MASK                  (1<<0)  /**< AUX Status Interrupt mask */
+#define XV_HDMIRX_AUX_STA_NEW_MASK                  (1<<1)  /**< AUX Status New Packet mask */
+#define XV_HDMIRX_AUX_STA_ERR_MASK					(1<<2)	/**< AUX Status New Packet mask */
+#define XV_HDMIRX_AUX_STA_AVI_MASK					(1<<3)	/**< AUX Status AVI infoframe mask */
+#define XV_HDMIRX_AUX_STA_GCP_MASK					(1<<4)	/**< AUX Status General control packet mask */
+#define XV_HDMIRX_AUX_STA_FIFO_EP_MASK              (1<<5)  /**< AUX Status FIFO Empty mask */
+#define XV_HDMIRX_AUX_STA_FIFO_FL_MASK              (1<<6)  /**< AUX Status FIFO Full mask */
+#define XV_HDMIRX_AUX_STA_GCP_AVMUTE_MASK           (1<<31) /**< AUX Status GCP avmute mask */
+#define XV_HDMIRX_AUX_STA_NEW_PKTS_MASK             0x1F    /**< AUX Status New Packets mask */
+#define XV_HDMIRX_AUX_STA_AVI_CS_MASK               0x03    /**< AUX Status AVI colorspace mask */
+#define XV_HDMIRX_AUX_STA_AVI_VIC_MASK              0x7F    /**< AUX Status AVI VIC mask */
+#define XV_HDMIRX_AUX_STA_GCP_CD_MASK               0x03    /**< AUX Status GCP colordepth mask */
+#define XV_HDMIRX_AUX_STA_GCP_PP_MASK               0x07    /**< AUX Status GCP pixel phase mask */
+#define XV_HDMIRX_AUX_STA_NEW_PKTS_SHIFT                8       /**< AUX Status New Packets Shift */
+#define XV_HDMIRX_AUX_STA_AVI_CS_SHIFT              16      /**< AUX Status AVI colorspace Shift */
+#define XV_HDMIRX_AUX_STA_AVI_VIC_SHIFT             18      /**< AUX Status AVI VIC Shift */
+#define XV_HDMIRX_AUX_STA_GCP_CD_SHIFT              26      /**< AUX Status GCP colordepth Shift */
+#define XV_HDMIRX_AUX_STA_GCP_PP_SHIFT              28      /**< AUX Status GCP pixel phase Shift */
+
+
+// Audio (AUD) peripheral register offsets.
+#define XV_HDMIRX_AUD_BASE                          (6*64)
+#define XV_HDMIRX_AUD_ID_OFFSET                     ((XV_HDMIRX_AUD_BASE)+(0*4))    /**< AUD Identification Register offset */
+#define XV_HDMIRX_AUD_CTRL_OFFSET                   ((XV_HDMIRX_AUD_BASE)+(1*4))    /**< AUD Control Register offset */
+#define XV_HDMIRX_AUD_CTRL_SET_OFFSET               ((XV_HDMIRX_AUD_BASE)+(2*4))    /**< AUD Control Register Set offset */
+#define XV_HDMIRX_AUD_CTRL_CLR_OFFSET               ((XV_HDMIRX_AUD_BASE)+(3*4))    /**< AUD Control Register Clear offset */
+#define XV_HDMIRX_AUD_STA_OFFSET                        ((XV_HDMIRX_AUD_BASE)+(4*4))    /**< AUD Status Register offset */
+#define XV_HDMIRX_AUD_CTS_OFFSET                        ((XV_HDMIRX_AUD_BASE)+(5*4))    /**< AUD CTS Register offset */
+#define XV_HDMIRX_AUD_N_OFFSET                      ((XV_HDMIRX_AUD_BASE)+(6*4))    /**< AUD N Register offset */
+
+// Audio peripheral Control register masks
+#define XV_HDMIRX_AUD_CTRL_RUN_MASK                 (1<<0)  /**< AUD Control Run mask */
+#define XV_HDMIRX_AUD_CTRL_IE_MASK                  (1<<1)  /**< AUD Control Interrupt Enable mask */
+
+// AUD peripheral Status register masks and shift
+#define XV_HDMIRX_AUD_STA_IRQ_MASK                  (1<<0)  /**< AUD Status Interrupt mask */
+#define XV_HDMIRX_AUD_STA_ACT_EVT_MASK              (1<<1)  /**< AUD Status Event mask */
+#define XV_HDMIRX_AUD_STA_CH_EVT_MASK               (1<<2)  /**< AUD Status Event mask */
+#define XV_HDMIRX_AUD_STA_ACT_MASK                  (1<<3)  /**< AUD Status Active mask */
+#define XV_HDMIRX_AUD_STA_AUD_CH_MASK               0x03    /**< AUD Status Audio channel mask */
+#define XV_HDMIRX_AUD_STA_AUD_CH_SHIFT              4       /**< AUD Status Audio channel Shift */
+#define XV_HDMIRX_AUD_STA_AUD_FMT_MASK              0x07    /**< AUD Status Audio Format mask */
+#define XV_HDMIRX_AUD_STA_AUD_FMT_SHIFT             6       /**< AUD Status Audio Format Shift */
+
+
+// Link Status (LNKSTA) peripheral register offsets.
+#define XV_HDMIRX_LNKSTA_BASE                       (7*64)
+#define XV_HDMIRX_LNKSTA_ID_OFFSET                  ((XV_HDMIRX_LNKSTA_BASE)+(0*4)) /**< LNKSTA Identification Register offset */
+#define XV_HDMIRX_LNKSTA_CTRL_OFFSET                    ((XV_HDMIRX_LNKSTA_BASE)+(1*4)) /**< LNKSTA Control Register offset */
+#define XV_HDMIRX_LNKSTA_CTRL_SET_OFFSET                ((XV_HDMIRX_LNKSTA_BASE)+(2*4)) /**< LNKSTA Control Register Set offset */
+#define XV_HDMIRX_LNKSTA_CTRL_CLR_OFFSET                ((XV_HDMIRX_LNKSTA_BASE)+(3*4)) /**< LNKSTA Control Register Clear offset */
+#define XV_HDMIRX_LNKSTA_STA_OFFSET                 ((XV_HDMIRX_LNKSTA_BASE)+(4*4)) /**< LNKSTA Status Register offset */
+#define XV_HDMIRX_LNKSTA_LNK_ERR0_OFFSET                ((XV_HDMIRX_LNKSTA_BASE)+(5*4)) /**< LNKSTA Link Error Counter Channel 0 Register offset */
+#define XV_HDMIRX_LNKSTA_LNK_ERR1_OFFSET                ((XV_HDMIRX_LNKSTA_BASE)+(6*4)) /**< LNKSTA Link Error Counter Channel 1 Register offset */
+#define XV_HDMIRX_LNKSTA_LNK_ERR2_OFFSET                ((XV_HDMIRX_LNKSTA_BASE)+(7*4)) /**< LNKSTA Link Error Counter Channel 2 Register offset */
+
+// Link Status (LNKSTA) peripheral Control register masks
+#define XV_HDMIRX_LNKSTA_CTRL_RUN_MASK              (1<<0)  /**< LNKSTA Control Run mask */
+#define XV_HDMIRX_LNKSTA_CTRL_IE_MASK               (1<<1)  /**< LNKSTA Control Interrupt Enable mask */
+#define XV_HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK          (1<<2)  /**< LNKSTA Control Error Clear mask */
+
+// Link Status (LNKSTA) peripheral Status register masks
+#define XV_HDMIRX_LNKSTA_STA_IRQ_MASK               (1<<0)  /**< LNKSTA Status Interrupt mask */
+#define XV_HDMIRX_LNKSTA_STA_ERR_MAX_MASK           (1<<1)  /**< LNKSTA Status Maximum Errors mask */
+
+// Peripheral ID and General shift values.
+#define XV_HDMIRX_SHIFT_16      16  /**< 16 shift value */
+#define XV_HDMIRX_MASK_16       0xFFFF  /**< 16 bit mask value */
+#define XV_HDMIRX_PIO_ID            0x2200  /**< PIO ID */
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/** @name Register access macro definition
+* @{
+*/
+#define XV_HdmiRx_In32  Xil_In32    /**< Input Operations */
+#define XV_HdmiRx_Out32 Xil_Out32   /**< Output Operations */
+
+/*****************************************************************************/
+/**
+*
+* This macro reads a value from a HDMI RX register. A 32 bit read is performed.
+* If the component is implemented in a smaller width, only the least
+* significant data is read from the register. The most significant data
+* will be read as 0.
+*
+* @param    BaseAddress is the base address of the HDMI RX core instance.
+* @param    RegOffset is the register offset of the register (defined at
+*       the top of this file).
+*
+* @return   The 32-bit value of the register.
+*
+* @note     C-style signature:
+*       u32 XV_HdmiRx_ReadReg(u32 BaseAddress, u32 RegOffset)
+*
+******************************************************************************/
+#define XV_HdmiRx_ReadReg(BaseAddress, RegOffset) \
+    XV_HdmiRx_In32((BaseAddress) + (RegOffset))
+
+/*****************************************************************************/
+/**
+*
+* This macro writes a value to a HDMI RX register. A 32 bit write is performed.
+* If the component is implemented in a smaller width, only the least
+* significant data is written.
+*
+* @param    BaseAddress is the base address of the HDMI RX core instance.
+* @param    RegOffset is the register offset of the register (defined at
+*       the top of this file) to be written.
+* @param    Data is the 32-bit value to write into the register.
+*
+* @return   None.
+*
+* @note     C-style signature:
+*       void XV_HdmiRx_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+******************************************************************************/
+#define XV_HdmiRx_WriteReg(BaseAddress, RegOffset, Data) \
+    XV_HdmiRx_Out32((BaseAddress) + (RegOffset), (u32)(Data))
+/*@}*/
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Declarations ****************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_intr.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_intr.c
new file mode 100644
index 0000000..d62f934
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_intr.c
@@ -0,0 +1,892 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx_intr.c
+*
+* This file contains interrupt related functions for Xilinx HDMI RX core.
+* Please see xv_hdmirx.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.00  gm, mg 11/03/15 Initial release.
+* 1.01  yh     14/01/16 Set AxisEnable PIO to high when RX stream locked
+* 1.03  MG     18/02/16 Added Link Check callback
+* 1.04  MG     08/03/16 Added pixel clock calculation to HdmiRx_TmrIntrHandler
+* 1.05  MH     08/03/16 Added support for read not complete DDC event
+* 1.06  MG     27/05/16 Updated HdmiRx_VtdIntrHandler
+* 1.07  MG     27/05/16 Updated HdmiRx_TmrIntrHandler
+* 1.08  MG     30/05/16 Fixed issue with pixel clock adjustment for YUV422 colorspace
+* 1.09  MH     26/07/16 Added DDC HDCP protocol event.
+* 1.10  YH     18/08/16 squash unused variable compiler warning
+* 1.11  MG     03/03/17 Updated function HdmiRx_TmrIntrHandler with
+*                           GetVideoPropertiesTries
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmirx.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+void HdmiRx_PioIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_TmrIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_VtdIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_DdcIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_AuxIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_AudIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_LinkStatusIntrHandler(XV_HdmiRx *InstancePtr);
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX driver.
+*
+* This handler reads the pending interrupt from PIO, DDC, TIMDET, AUX, AUD
+* and LNKSTA peripherals, determines the source of the interrupts, clears the
+* interrupts and calls callbacks accordingly.
+*
+* The application is responsible for connecting this function to the interrupt
+* system. Application beyond this driver is also responsible for providing
+* callbacks to handle interrupts and installing the callbacks using
+* XV_HdmiRx_SetCallback() during initialization phase. An example delivered
+* with this driver demonstrates how this could be done.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx instance that just
+*       interrupted.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRx_IntrHandler(void *InstancePtr)
+{
+    u32 Data;
+    XV_HdmiRx *HdmiRxPtr = (XV_HdmiRx *)InstancePtr;
+
+    /* Verify arguments */
+    Xil_AssertVoid(HdmiRxPtr != NULL);
+    Xil_AssertVoid(HdmiRxPtr->IsReady == XIL_COMPONENT_IS_READY);
+
+    /* PIO */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_PIO_STA_OFFSET)) & (XV_HDMIRX_PIO_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to PIO handler */
+        HdmiRx_PioIntrHandler(HdmiRxPtr);
+    }
+
+    /* Timer */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_TMR_STA_OFFSET)) & (XV_HDMIRX_TMR_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to PIO handler */
+        HdmiRx_TmrIntrHandler(HdmiRxPtr);
+    }
+
+    /* Video Timing detector */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET)) & (XV_HDMIRX_VTD_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to video timing detector handler */
+        HdmiRx_VtdIntrHandler(HdmiRxPtr);
+    }
+
+    /* DDC */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET)) & (XV_HDMIRX_DDC_STA_IRQ_MASK);
+
+    /* Is the IRQ flag set */
+    if (Data) {
+        /* Jump to DDC handler */
+        HdmiRx_DdcIntrHandler(HdmiRxPtr);
+    }
+
+    /* AUX */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET)) & (XV_HDMIRX_AUX_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to AUX handler */
+        HdmiRx_AuxIntrHandler(HdmiRxPtr);
+    }
+
+    /* Audio */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_AUD_STA_OFFSET)) & (XV_HDMIRX_AUD_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to Audio handler */
+        HdmiRx_AudIntrHandler(HdmiRxPtr);
+    }
+
+    /* Link status */
+    Data = XV_HdmiRx_ReadReg(HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_STA_OFFSET)) & (XV_HDMIRX_LNKSTA_STA_IRQ_MASK);
+
+    /* Check for IRQ flag set */
+    if (Data) {
+        /* Jump to Link Status handler */
+        HdmiRx_LinkStatusIntrHandler(HdmiRxPtr);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function installs an asynchronous callback function for the given
+* HandlerType:
+*
+* <pre>
+* HandlerType                 Callback Function Type
+* -------------------------   -----------------------------------------------
+* (XV_HDMIRX_HANDLER_VTD)         VtdCallback
+* (XV_HDMIRX_HANDLER_AUX)      AuxCallback
+* (XV_HDMIRX_HANDLER_AUD)      AudCallback
+* (XV_HDMIRX_HANDLER_LNKSTA)   LnkStaCallback
+* (XV_HDMIRX_HANDLER_PIO)      PioCallback
+* </pre>
+*
+* @param    InstancePtr is a pointer to the HDMI RX core instance.
+* @param    HandlerType specifies the type of handler.
+* @param    CallbackFunc is the address of the callback function.
+* @param    CallbackRef is a user data item that will be passed to the
+*       callback function when it is invoked.
+*
+* @return
+*       - XST_SUCCESS if callback function installed successfully.
+*       - XST_INVALID_PARAM when HandlerType is invalid.
+*
+* @note     Invoking this function for a handler that already has been
+*       installed replaces it with the new handler.
+*
+******************************************************************************/
+int XV_HdmiRx_SetCallback(XV_HdmiRx *InstancePtr, u32 HandlerType, void *CallbackFunc, void *CallbackRef)
+{
+    u32 Status;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(HandlerType >= (XV_HDMIRX_HANDLER_CONNECT));
+    Xil_AssertNonvoid(CallbackFunc != NULL);
+    Xil_AssertNonvoid(CallbackRef != NULL);
+
+    /* Check for handler type */
+    switch (HandlerType) {
+
+        case (XV_HDMIRX_HANDLER_CONNECT):
+            InstancePtr->ConnectCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->ConnectRef = CallbackRef;
+            InstancePtr->IsConnectCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRX_HANDLER_AUX):
+            InstancePtr->AuxCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->AuxRef = CallbackRef;
+            InstancePtr->IsAuxCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRX_HANDLER_AUD):
+            InstancePtr->AudCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->AudRef = CallbackRef;
+            InstancePtr->IsAudCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRX_HANDLER_LNKSTA):
+            InstancePtr->LnkStaCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->LnkStaRef = CallbackRef;
+            InstancePtr->IsLnkStaCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Ddc
+        case (XV_HDMIRX_HANDLER_DDC):
+            InstancePtr->DdcCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->DdcRef = CallbackRef;
+            InstancePtr->IsDdcCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream down
+        case (XV_HDMIRX_HANDLER_STREAM_DOWN):
+            InstancePtr->StreamDownCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->StreamDownRef = CallbackRef;
+            InstancePtr->IsStreamDownCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream Init
+        case (XV_HDMIRX_HANDLER_STREAM_INIT):
+            InstancePtr->StreamInitCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->StreamInitRef = CallbackRef;
+            InstancePtr->IsStreamInitCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream up
+        case (XV_HDMIRX_HANDLER_STREAM_UP):
+            InstancePtr->StreamUpCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->StreamUpRef = CallbackRef;
+            InstancePtr->IsStreamUpCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP
+        case (XV_HDMIRX_HANDLER_HDCP):
+            InstancePtr->HdcpCallback = (XV_HdmiRx_HdcpCallback)CallbackFunc;
+            InstancePtr->HdcpRef = CallbackRef;
+            InstancePtr->IsHdcpCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+		case (XV_HDMIRX_HANDLER_LINK_ERROR):
+			InstancePtr->LinkErrorCallback = (XV_HdmiRx_Callback)CallbackFunc;
+			InstancePtr->LinkErrorRef = CallbackRef;
+			InstancePtr->IsLinkErrorCallbackSet = (TRUE);
+			Status = (XST_SUCCESS);
+			break;
+
+        // Sync Loss
+        case (XV_HDMIRX_HANDLER_SYNC_LOSS):
+            InstancePtr->SyncLossCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->SyncLossRef = CallbackRef;
+            InstancePtr->IsSyncLossCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        // Mode
+        case (XV_HDMIRX_HANDLER_MODE):
+            InstancePtr->ModeCallback = (XV_HdmiRx_Callback)CallbackFunc;
+            InstancePtr->ModeRef = CallbackRef;
+            InstancePtr->IsModeCallbackSet = (TRUE);
+            Status = (XST_SUCCESS);
+            break;
+
+        default:
+            Status = (XST_INVALID_PARAM);
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX Timing Detector
+* (TIMDET) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_VtdIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+
+    /* Read Video timing detector Status register */
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET));
+
+    /* Check for time base event */
+    if ((Status) & (XV_HDMIRX_VTD_STA_TIMEBASE_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET), (XV_HDMIRX_VTD_STA_TIMEBASE_EVT_MASK));
+
+        // Check if we are in lock state
+        if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_LOCK) {
+
+            // Read video timing
+            Status = XV_HdmiRx_GetVideoTiming(InstancePtr);
+
+            if (Status == XST_SUCCESS) {
+
+                // Enable AXI Stream output
+                XV_HdmiRx_AxisEnable(InstancePtr, (TRUE));
+
+                // Set stream status to up
+                InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_UP;          // The stream is up
+
+                // Enable sync loss
+                XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress,
+                  (XV_HDMIRX_VTD_CTRL_SET_OFFSET), (XV_HDMIRX_VTD_CTRL_SYNC_LOSS_MASK));
+
+                // Call stream up callback
+                if (InstancePtr->IsStreamUpCallbackSet) {
+                    InstancePtr->StreamUpCallback(InstancePtr->StreamUpRef);
+                }
+            }
+        }
+
+        // Check if we are in stream up state
+        else if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_UP) {
+
+            // Read video timing
+            Status = XV_HdmiRx_GetVideoTiming(InstancePtr);
+
+            if (Status != XST_SUCCESS) {
+
+                // Disable sync loss
+                XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress,
+                  (XV_HDMIRX_VTD_CTRL_CLR_OFFSET), (XV_HDMIRX_VTD_CTRL_SYNC_LOSS_MASK));
+
+                // Set stream status to up
+                InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_LOCK;
+            }
+        }
+
+    }
+
+    /* Check for sync loss event */
+    else if ((Status) & (XV_HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET), (XV_HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK));
+
+        // Call sync lost callback
+        if (InstancePtr->IsSyncLossCallbackSet) {
+            InstancePtr->SyncLossCallback(InstancePtr->SyncLossRef);
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX DDC peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_DdcIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+
+    /* Read Status register */
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET));
+
+    /* Check for HDCP write event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK);
+        }
+    }
+
+    /* Check for HDCP read event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK);
+        }
+    }
+
+    /* Check for HDCP read not complete event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK);
+        }
+    }
+
+    /* Check for HDCP 1.4 Aksv event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK);
+        }
+    }
+
+    /* Check for HDCP 1.4 protocol event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK);
+        }
+    }
+
+    /* Check for HDCP 2.2 protocol event */
+    if ((Status) & (XV_HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET), (XV_HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsHdcpCallbackSet) {
+            InstancePtr->HdcpCallback(InstancePtr->HdcpRef, XV_HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK);
+        }
+    }
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX PIO peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_PioIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Event;
+    u32 Data;
+
+    /* Read PIO IN Event register.*/
+    Event = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_EVT_OFFSET));
+
+    /* Clear event flags */
+    XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_EVT_OFFSET), (Event));
+
+    /* Read data */
+    Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_PIO_IN_OFFSET));
+
+    // Cable detect event has occurred
+    if ((Event) & (XV_HDMIRX_PIO_IN_DET_MASK)) {
+
+        // Cable is connected
+        if ((Data) & (XV_HDMIRX_PIO_IN_DET_MASK)) {
+            // Set connected flag
+            InstancePtr->Stream.IsConnected = (TRUE);
+        }
+
+        // Cable is disconnected
+        else {
+            // Clear connected flag
+            InstancePtr->Stream.IsConnected = (FALSE);
+
+            // Clear SCDC variables
+            XV_HdmiRx_DdcScdcClear(InstancePtr);
+        }
+
+        // Check if user callback has been registered
+        if (InstancePtr->IsConnectCallbackSet) {
+            InstancePtr->ConnectCallback(InstancePtr->ConnectRef);
+        }
+    }
+
+    // Link ready event has occurred
+    if ((Event) & (XV_HDMIRX_PIO_IN_LNK_RDY_MASK)) {
+
+    // Set stream status to idle
+        InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_IDLE;            // The stream idle
+
+        // Load timer
+        XV_HdmiRx_TmrStart(InstancePtr, 1000000);           // 10 ms @ 100 MHz
+    }
+
+    // Video ready event has occurred
+    if ((Event) & (XV_HDMIRX_PIO_IN_VID_RDY_MASK)) {
+
+        // Ready
+        if ((Data) & (XV_HDMIRX_PIO_IN_VID_RDY_MASK)) {
+
+            // Check the previous state
+            // The link can only change to up when the previous state was init
+            // Else there was a glitch on the video ready input
+            if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_INIT) {
+
+                // Enable video
+                XV_HdmiRx_VideoEnable(InstancePtr, (TRUE));
+
+            // Set stream status to arm
+                InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_ARM;         // The stream is armed
+
+                // Load timer
+                XV_HdmiRx_TmrStart(InstancePtr, 20000000);          // 200 ms @ 100 MHz (one UHD frame is 40 ms, 5 frames)
+            }
+        }
+
+        // Stream down
+        else {
+            /* Assert reset */
+            XV_HdmiRx_Reset(InstancePtr, (TRUE));
+
+            /* Clear variables */
+            XV_HdmiRx_Clear(InstancePtr);
+
+            // Disable aux and audio peripheral
+            // At this state the link clock is not stable.
+            // Therefore these two peripheral are disabled to prevent any glitches.
+            XV_HdmiRx_AuxDisable(InstancePtr);
+            XV_HdmiRx_AudioDisable(InstancePtr);
+
+            /* Disable VTD */
+            XV_HdmiRx_VtdDisable(InstancePtr);
+
+            // Disable link
+            XV_HdmiRx_LinkEnable(InstancePtr, (FALSE));
+
+            // Disable video
+            XV_HdmiRx_VideoEnable(InstancePtr, (FALSE));
+
+            XV_HdmiRx_AxisEnable(InstancePtr, (FALSE));
+
+            // Set stream status to down
+            InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_DOWN;
+
+            // Disable sync loss
+            XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress,
+                (XV_HDMIRX_VTD_CTRL_CLR_OFFSET), (XV_HDMIRX_VTD_CTRL_SYNC_LOSS_MASK));
+
+            // Call stream down callback
+            if (InstancePtr->IsStreamDownCallbackSet) {
+                InstancePtr->StreamDownCallback(InstancePtr->StreamDownRef);
+            }
+        }
+    }
+
+    // SCDC Scrambler Enable
+    if ((Event) & (XV_HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK)) {
+
+        // Enable scrambler
+        if ((Data) & (XV_HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK)) {
+            XV_HdmiRx_SetScrambler(InstancePtr, (TRUE));
+        }
+
+        // Disable scrambler
+        else {
+            XV_HdmiRx_SetScrambler(InstancePtr, (FALSE));
+        }
+    }
+
+    // Mode
+    if ((Event) & (XV_HDMIRX_PIO_IN_MODE_MASK)) {
+
+        // HDMI Mode
+        if ((Data) & (XV_HDMIRX_PIO_IN_MODE_MASK)) {
+            InstancePtr->Stream.IsHdmi = (TRUE);
+        }
+
+        // DVI Mode
+        else {
+            InstancePtr->Stream.IsHdmi = (FALSE);
+        }
+
+        // Call mode callback
+        if (InstancePtr->IsModeCallbackSet) {
+            InstancePtr->ModeCallback(InstancePtr->ModeRef);
+        }
+    }
+
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX TMR peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_TmrIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+
+    /* Read Status register */
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_TMR_STA_OFFSET));
+
+    /* Check for counter event */
+    if ((Status) & (XV_HDMIRX_TMR_STA_CNT_EVT_MASK)) {
+
+        // Clear counter event
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_TMR_STA_OFFSET), (XV_HDMIRX_TMR_STA_CNT_EVT_MASK));
+
+        // Idle state
+        if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_IDLE) {
+
+            // The link is stable now
+            // Then the aux and audio peripherals can be enabled
+            XV_HdmiRx_AuxEnable(InstancePtr);
+            XV_HdmiRx_AudioEnable(InstancePtr);
+
+            // Release HDMI RX reset
+            XV_HdmiRx_Reset(InstancePtr, FALSE);
+
+            // Enable link
+            XV_HdmiRx_LinkEnable(InstancePtr, (TRUE));
+
+            // Set stream status to init
+            InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_INIT;    // The stream init
+
+            // Clear GetVideoPropertiesTries
+            InstancePtr->Stream.GetVideoPropertiesTries = 0;
+
+            // Load timer
+            XV_HdmiRx_TmrStart(InstancePtr, 20000000);          // 200 ms @ 100 MHz (one UHD frame is 40 ms, 5 frames)
+        }
+
+        // Init state
+        else if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_INIT) {
+
+            // Read video properties
+            if (XV_HdmiRx_GetVideoProperties(InstancePtr) == XST_SUCCESS) {
+
+            // Now we know the reference clock and color depth,
+            // the pixel clock can be calculated
+            // In case of YUV 422 the reference clock is the pixel clock
+            if (InstancePtr->Stream.Video.ColorFormatId == XVIDC_CSF_YCRCB_422) {
+                InstancePtr->Stream.PixelClk = InstancePtr->Stream.RefClk;
+            }
+
+            // For the other color spaces the pixel clock needs to be adjusted
+            else {
+
+                switch (InstancePtr->Stream.Video.ColorDepth) {
+                    case XVIDC_BPC_10:
+                        InstancePtr->Stream.PixelClk = (InstancePtr->Stream.RefClk * 4)/5;
+                        break;
+
+                    case XVIDC_BPC_12:
+                        InstancePtr->Stream.PixelClk = (InstancePtr->Stream.RefClk * 2)/3;
+                        break;
+
+                    case XVIDC_BPC_16:
+                        InstancePtr->Stream.PixelClk = InstancePtr->Stream.RefClk / 2;
+                        break;
+
+                    default:
+                        InstancePtr->Stream.PixelClk = InstancePtr->Stream.RefClk;
+                        break;
+                }
+            }
+
+				// Call stream init callback
+				if (InstancePtr->IsStreamInitCallbackSet) {
+					InstancePtr->StreamInitCallback(InstancePtr->StreamInitRef);
+				}
+			}
+
+            else {
+		// Load timer
+                XV_HdmiRx_TmrStart(InstancePtr, 20000000);          // 200 ms @ 100 MHz (one UHD frame is 40 ms, 5 frames)
+            }
+        }
+
+        // Armed state
+        else if (InstancePtr->Stream.State == XV_HDMIRX_STATE_STREAM_ARM) {
+
+            /* Enable VTD */
+            XV_HdmiRx_VtdEnable(InstancePtr);
+
+            /* Enable interrupt */
+            XV_HdmiRx_VtdIntrEnable(InstancePtr);
+
+            // Set stream status to lock
+            InstancePtr->Stream.State = XV_HDMIRX_STATE_STREAM_LOCK;
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX AUX peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_AuxIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+    u8 Index;
+
+    /* Read Status register */
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET));
+
+    /* Check for new packet */
+    if ((Status) & (XV_HDMIRX_AUX_STA_NEW_MASK)) {
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET), (XV_HDMIRX_AUX_STA_NEW_MASK));
+
+        /* Set HDMI flag */
+        InstancePtr->Stream.IsHdmi = (TRUE);
+
+        /* Read header word and update AUX header field */
+        InstancePtr->Aux.Header.Data = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_DAT_OFFSET));
+
+        for (Index = 0x0; Index < 8; Index++) {
+            /* Read data word and update AUX data field */
+            InstancePtr->Aux.Data.Data[Index] = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_DAT_OFFSET));
+        }
+
+        /* Callback */
+        if (InstancePtr->IsAuxCallbackSet) {
+            InstancePtr->AuxCallback(InstancePtr->AuxRef);
+        }
+    }
+
+    /* Link integrity check */
+    if ((Status) & (XV_HDMIRX_AUX_STA_ERR_MASK)) {
+		XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET), (XV_HDMIRX_AUX_STA_ERR_MASK));
+
+        /* Callback */
+        if (InstancePtr->IsLinkErrorCallbackSet) {
+			InstancePtr->LinkErrorCallback(InstancePtr->LinkErrorRef);
+		}
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX AUD peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_AudIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    u32 Status;
+
+    // Read Status register
+    Status = XV_HdmiRx_ReadReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUD_STA_OFFSET));
+
+    // Check for active stream event
+    if ((Status) & (XV_HDMIRX_AUD_STA_ACT_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUD_STA_OFFSET), (XV_HDMIRX_AUD_STA_ACT_EVT_MASK));
+
+        InstancePtr->Stream.Audio.Active = (TRUE);
+    }
+
+    // Check for audio channel event
+    if ((Status) & (XV_HDMIRX_AUD_STA_CH_EVT_MASK)) {
+
+        // Clear event flag
+        XV_HdmiRx_WriteReg(InstancePtr->Config.BaseAddress, (XV_HDMIRX_AUD_STA_OFFSET), (XV_HDMIRX_AUD_STA_CH_EVT_MASK));
+
+        // Active channels
+        switch ((Status >> XV_HDMIRX_AUD_STA_AUD_CH_SHIFT) & XV_HDMIRX_AUD_STA_AUD_CH_MASK) {
+
+            // 8 channels
+            case 3 :
+                InstancePtr->Stream.Audio.Channels = 8;
+                break;
+
+            // 6 channels
+            case 2 :
+                InstancePtr->Stream.Audio.Channels = 6;
+                break;
+
+            // 4 channels
+            case 1 :
+                InstancePtr->Stream.Audio.Channels = 4;
+                break;
+
+            // 2 channels
+            default :
+                InstancePtr->Stream.Audio.Channels = 2;
+                break;
+        }
+
+        /* Callback */
+        if (InstancePtr->IsAudCallbackSet) {
+            InstancePtr->AudCallback(InstancePtr->AudRef);
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is the interrupt handler for the HDMI RX Link Status
+* (LNKSTA) peripheral.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRx core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void HdmiRx_LinkStatusIntrHandler(XV_HdmiRx *InstancePtr)
+{
+    /* Callback */
+    if (InstancePtr->IsLnkStaCallbackSet) {
+        InstancePtr->LnkStaCallback(InstancePtr->LnkStaRef);
+    }
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_sinit.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_sinit.c
new file mode 100644
index 0000000..d925828
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_sinit.c
@@ -0,0 +1,93 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx_sinit.c
+*
+* This file contains static initialization method for Xilinx HDMI RX core.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ------ -------- --------------------------------------------------
+* 1.0   gm, mg 10/07/15 Initial release.
+
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xv_hdmirx.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function returns a reference to an XV_HdmiRx_Config structure based
+* on the core id, <i>DeviceId</i>. The return value will refer to an entry in
+* the device configuration table defined in the xv_hdmirx_g.c file.
+*
+* @param    DeviceId is the unique core ID of the HDMI RX core for the
+*       lookup operation.
+*
+* @return   XV_HdmiRx_LookupConfig returns a reference to a config record
+*       in the configuration table (in xv_hdmirx_g.c) corresponding
+*       to <i>DeviceId</i>, or NULL if no match is found.
+*
+* @note     None.
+*
+******************************************************************************/
+XV_HdmiRx_Config *XV_HdmiRx_LookupConfig(u16 DeviceId)
+{
+    extern XV_HdmiRx_Config
+            XV_HdmiRx_ConfigTable[XPAR_XV_HDMIRX_NUM_INSTANCES];
+    XV_HdmiRx_Config *CfgPtr = NULL;
+    u32 Index;
+
+    /* Checking for device id for which instance it is matching */
+    for (Index = (u32)0x0; Index < (u32)(XPAR_XV_HDMIRX_NUM_INSTANCES);
+                                Index++) {
+
+        /* Assigning address of config table if both device ids
+         * are matched
+         */
+        if (XV_HdmiRx_ConfigTable[Index].DeviceId == DeviceId) {
+            CfgPtr = &XV_HdmiRx_ConfigTable[Index];
+            break;
+        }
+    }
+
+    return (XV_HdmiRx_Config *)CfgPtr;
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.c
new file mode 100644
index 0000000..adc1adb
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.c
@@ -0,0 +1,567 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx_vsif.c
+*
+* Contains function definitions related to Vendor Specific InfoFrames used
+* in HDMI. Please see xv_hdmirx_vsif.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date        Changes
+* ----- --- ----------   -----------------------------------------------
+* X.XX  XX  YYYY/MM/DD   ...
+* 1.00  RHe 2015/10/06   Initial release.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include <linux/string.h>
+#include "xv_hdmirx_vsif.h"
+#include "xv_hdmirx.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions *****************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/**************************** Type Definitions *******************************/
+
+/*************************** Function Prototypes *****************************/
+static int XV_HdmiRx_VSIF_Extract3DInfo(u8 *VSIFRaw, XV_HdmiRx_3D_Info *InstancePtr);
+static XV_HdmiRx_3D_Struct_Field XV_HdmiRx_VSIF_Conv3DInfoTo3DStruct(XVidC_3DInfo *InfoPtr);
+static XV_HdmiRx_3D_Sampling_Method XV_HdmiRx_VSIF_Conv3DInfoTo3DSampMethod(XVidC_3DInfo *InfoPtr);
+static XV_HdmiRx_3D_Sampling_Position XV_HdmiRx_VSIF_Conv3DInfoTo3DSampPos(XVidC_3DInfo *InfoPtr);
+static XVidC_3DFormat XV_HdmiRx_VSIF_Conv3DStructTo3DFormat(XV_HdmiRx_3D_Struct_Field Value);
+static XVidC_3DSamplingMethod XV_HdmiRx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HdmiRx_3D_Sampling_Method Value);
+static XVidC_3DSamplingPosition XV_HdmiRx_VSIF_Conv3DSampPosTo3DSampPos(XV_HdmiRx_3D_Sampling_Position Value);
+
+/************************** Variable Definitions *****************************/
+
+/*************************** Function Definitions ****************************/
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the 3D format from XVidC_3DInfo
+* and returns a XV_HdmiRx_3D_Struct_Field type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiRx_3D_Struct_Field XV_HdmiRx_VSIF_Conv3DInfoTo3DStruct(XVidC_3DInfo *InfoPtr)
+{
+    switch (InfoPtr->Format) {
+        case XVIDC_3D_FRAME_PACKING :
+            return XV_HDMIRX_3D_STRUCT_FRAME_PACKING;
+
+        case XVIDC_3D_FIELD_ALTERNATIVE :
+            return XV_HDMIRX_3D_STRUCT_FIELD_ALTERNATIVE;
+
+        case XVIDC_3D_LINE_ALTERNATIVE :
+            return XV_HDMIRX_3D_STRUCT_LINE_ALTERNATIVE;
+
+        case XVIDC_3D_SIDE_BY_SIDE_FULL :
+            return XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_FULL;
+
+        case XVIDC_3D_TOP_AND_BOTTOM_HALF :
+            return XV_HDMIRX_3D_STRUCT_TOP_AND_BOTTOM;
+
+        case XVIDC_3D_SIDE_BY_SIDE_HALF :
+            return XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF;
+
+        default :
+            return XV_HDMIRX_3D_STRUCT_UNKNOWN;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the sampling method info from XVidC_3DInfo
+* and returns a XV_HdmiRx_3D_Sampling_Method type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiRx_3D_Sampling_Method XV_HdmiRx_VSIF_Conv3DInfoTo3DSampMethod(XVidC_3DInfo *InfoPtr)
+{
+    switch (InfoPtr->Sampling.Method) {
+        case XVIDC_3D_SAMPLING_HORIZONTAL :
+            return XV_HDMIRX_3D_SAMPLING_HORIZONTAL;
+
+        case XVIDC_3D_SAMPLING_QUINCUNX :
+            return XV_HDMIRX_3D_SAMPLING_QUINCUNX;
+
+        default :
+            return XV_HDMIRX_3D_SAMPLING_UNKNOWN;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the sampling position info from XVidC_3DInfo
+* and returns a XV_HdmiRx_3D_Sampling_Position type.
+*
+* @param InfoPtr is a pointer to the XVidC_3DInfo instance.
+*
+* @return The extracted value.
+*
+******************************************************************************/
+static XV_HdmiRx_3D_Sampling_Position XV_HdmiRx_VSIF_Conv3DInfoTo3DSampPos(XVidC_3DInfo *InfoPtr)
+{
+    switch (InfoPtr->Sampling.Position) {
+        case XVIDC_3D_SAMPPOS_OLOR :
+            return XV_HDMIRX_3D_SAMPPOS_OLOR;
+
+        case XVIDC_3D_SAMPPOS_OLER :
+            return XV_HDMIRX_3D_SAMPPOS_OLER;
+
+        case XVIDC_3D_SAMPPOS_ELOR :
+            return XV_HDMIRX_3D_SAMPPOS_ELOR;
+
+        case XVIDC_3D_SAMPPOS_ELER :
+            return XV_HDMIRX_3D_SAMPPOS_ELER;
+
+        default :
+            return XV_HDMIRX_3D_SAMPPOS_UNKNOWN;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiRx_3D_Struct_Field type
+* to a XVidC_3DFormat type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DFormat XV_HdmiRx_VSIF_Conv3DStructTo3DFormat(XV_HdmiRx_3D_Struct_Field Value)
+{
+    switch(Value) {
+        case XV_HDMIRX_3D_STRUCT_FRAME_PACKING :
+            return XVIDC_3D_FRAME_PACKING;
+
+        case XV_HDMIRX_3D_STRUCT_FIELD_ALTERNATIVE :
+            return XVIDC_3D_FIELD_ALTERNATIVE;
+
+        case XV_HDMIRX_3D_STRUCT_LINE_ALTERNATIVE :
+            return XVIDC_3D_LINE_ALTERNATIVE;
+
+        case XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_FULL :
+            return XVIDC_3D_SIDE_BY_SIDE_FULL;
+
+        case XV_HDMIRX_3D_STRUCT_TOP_AND_BOTTOM :
+            return XVIDC_3D_TOP_AND_BOTTOM_HALF;
+
+        case XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF :
+            return XVIDC_3D_SIDE_BY_SIDE_HALF;
+
+        default :
+            return XVIDC_3D_UNKNOWN;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiRx_3D_Sampling_Method type
+* to a XVidC_3DSamplingMethod type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DSamplingMethod XV_HdmiRx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HdmiRx_3D_Sampling_Method Value)
+{
+    switch(Value) {
+        case XV_HDMIRX_3D_SAMPLING_HORIZONTAL :
+            return XVIDC_3D_SAMPLING_HORIZONTAL;
+            break;
+
+        case XV_HDMIRX_3D_SAMPLING_QUINCUNX :
+            return XVIDC_3D_SAMPLING_QUINCUNX;
+            break;
+
+        default :
+            return XVIDC_3D_SAMPLING_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function converts a XV_HdmiRx_3D_Sampling_Position type
+* to a XVidC_3DSamplingPosition type.
+*
+* @param Value is the value to convert.
+*
+* @return The converted value.
+*
+******************************************************************************/
+static XVidC_3DSamplingPosition XV_HdmiRx_VSIF_Conv3DSampPosTo3DSampPos(XV_HdmiRx_3D_Sampling_Position Value)
+{
+    switch(Value) {
+        case XV_HDMIRX_3D_SAMPPOS_OLOR :
+            return XVIDC_3D_SAMPPOS_OLOR;
+            break;
+
+        case XV_HDMIRX_3D_SAMPPOS_OLER :
+            return XVIDC_3D_SAMPPOS_OLER;
+            break;
+
+        case XV_HDMIRX_3D_SAMPPOS_ELOR :
+            return XVIDC_3D_SAMPPOS_ELOR;
+            break;
+
+        case XV_HDMIRX_3D_SAMPPOS_ELER :
+            return XVIDC_3D_SAMPPOS_ELER;
+            break;
+
+        default :
+            return XVIDC_3D_SAMPPOS_UNKNOWN;
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function parses a Vendor Specific InfoFrame (VSIF).
+*
+* @param AuxPtr is a pointer to the XV_HdmiRx_Rx_Aux instance.
+*
+* @param VSIFPtr is a pointer to the XV_HdmiRx_VSIF instance.
+*
+* @return
+*  - XST_SUCCESS if operation was successful
+*  - XST_FAILURE if an error was detected during parsing
+*
+******************************************************************************/
+int XV_HdmiRx_VSIF_ParsePacket(XV_HdmiRx_Aux *AuxPtr, XV_HdmiRx_VSIF  *VSIFPtr)
+{
+    u8 *pData;
+    u32 temp;
+    int Index;
+    int Status = XST_FAILURE;
+
+    /* Verify arguments */
+    Xil_AssertNonvoid(AuxPtr != NULL);
+    Xil_AssertNonvoid(VSIFPtr != NULL);
+
+    pData = &AuxPtr->Data.Byte[0];
+
+    /* Clear the instance */
+    (void)memset((void *)VSIFPtr, 0, sizeof(XV_HdmiRx_VSIF));
+
+    /* Set packet version */
+    VSIFPtr->Version = AuxPtr->Header.Byte[1];
+
+    /* IEEE Registration Identifier */
+    for (Index = 0; Index < 3; Index++){
+        temp = pData[Index+1];
+        VSIFPtr->IEEE_ID |= (temp << (Index * 8));
+    }
+
+    /* HDMI Video Format */
+    temp = (pData[4] & XV_HDMIRX_VSIF_VIDEO_FORMAT_MASK) >> XV_HDMIRX_VSIF_VIDEO_FORMAT_SHIFT;
+    if (temp >= XV_HDMIRX_VSIF_VF_UNKNOWN) {
+        VSIFPtr->Format = XV_HDMIRX_VSIF_VF_UNKNOWN;
+    }
+    else {
+        VSIFPtr->Format = (XV_HdmiRx_VSIF_Video_Format)temp;
+    }
+
+    switch(VSIFPtr->Format) {
+        /* HDMI VIC */
+        case XV_HDMIRX_VSIF_VF_EXTRES :
+            VSIFPtr->HDMI_VIC = pData[5];
+            Status = XST_SUCCESS;
+            break;
+
+        /* 3D Information */
+        case XV_HDMIRX_VSIF_VF_3D :
+            Status = XV_HdmiRx_VSIF_Extract3DInfo(pData, &VSIFPtr->Info_3D);
+            break;
+
+        /* No additional information */
+        case XV_HDMIRX_VSIF_VF_NOINFO :
+            Status = XST_SUCCESS;
+            break;
+
+        default :
+
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function extracts the 3D information from the
+* Vendor Specific InfoFrame (VSIF).
+*
+* @param VSIFRaw is a pointer to the VSIF payload.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRx_3D_Info instance.
+*
+* @return
+*  - XST_SUCCESS if operation was successful
+*  - XST_FAILURE if an error was detected during parsing
+*
+******************************************************************************/
+int XV_HdmiRx_VSIF_Extract3DInfo(u8 *VSIFRaw, XV_HdmiRx_3D_Info *InstancePtr)
+{
+    u8 *pData;
+    u8 temp;
+
+    /* Verify arguments */
+    Xil_AssertNonvoid(VSIFRaw != NULL);
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* 3D info starts at byte PB5 */
+    pData = &VSIFRaw[5];
+
+    /* Clear the instance */
+    (void)memset((void *)InstancePtr, 0, sizeof(XV_HdmiRx_3D_Info));
+
+    /* Set default values for the items that are not always set */
+    InstancePtr->Stream.Sampling.Method = XV_HdmiRx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HDMIRX_3D_SAMPLING_UNKNOWN);
+    InstancePtr->Stream.Sampling.Position = XV_HdmiRx_VSIF_Conv3DSampPosTo3DSampPos(XV_HDMIRX_3D_SAMPPOS_UNKNOWN);
+
+    /* Detect 3D Metadata presence */
+    if (*pData & XV_HDMIRX_3D_META_PRESENT_MASK)
+        InstancePtr->MetaData.IsPresent = TRUE;
+    else
+        InstancePtr->MetaData.IsPresent = FALSE;
+
+    /* Extract the 3D_Structure */
+    temp = (*pData & XV_HDMIRX_3D_STRUCT_MASK) >> XV_HDMIRX_3D_STRUCT_SHIFT;
+    if (temp >= XV_HDMIRX_3D_STRUCT_UNKNOWN || temp == 7) {
+        InstancePtr->Stream.Format = XV_HdmiRx_VSIF_Conv3DStructTo3DFormat(XV_HDMIRX_3D_STRUCT_UNKNOWN);
+    }
+    else {
+        InstancePtr->Stream.Format = XV_HdmiRx_VSIF_Conv3DStructTo3DFormat((XV_HdmiRx_3D_Struct_Field)temp);
+    }
+
+    /* Extract the 3D_Ext_Data */
+    if (temp >= XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF) {
+        /* Go to next byte */
+        pData++;
+
+        /* Extract the sampling method */
+        temp = (*pData & XV_HDMIRX_3D_SAMP_METHOD_MASK) >> XV_HDMIRX_3D_SAMP_METHOD_SHIFT;
+        if (temp >= XV_HDMIRX_3D_SAMPLING_UNKNOWN)
+            InstancePtr->Stream.Sampling.Method = XV_HdmiRx_VSIF_Conv3DSampMethodTo3DSampMethod(XV_HDMIRX_3D_SAMPLING_UNKNOWN);
+        else
+            InstancePtr->Stream.Sampling.Method = XV_HdmiRx_VSIF_Conv3DSampMethodTo3DSampMethod((XV_HdmiRx_3D_Sampling_Method)temp);
+
+        /* Extract the sampling position */
+        temp = (*pData & XV_HDMIRX_3D_SAMP_POS_MASK) >> XV_HDMIRX_3D_SAMP_POS_SHIFT;
+        if (temp >= XV_HDMIRX_3D_SAMPPOS_UNKNOWN)
+            InstancePtr->Stream.Sampling.Position = XV_HdmiRx_VSIF_Conv3DSampPosTo3DSampPos(XV_HDMIRX_3D_SAMPPOS_UNKNOWN);
+        else
+            InstancePtr->Stream.Sampling.Position = XV_HdmiRx_VSIF_Conv3DSampPosTo3DSampPos((XV_HdmiRx_3D_Sampling_Position)temp);
+    }
+
+    /* Extract the 3D_Metadata */
+    if (InstancePtr->MetaData.IsPresent) {
+        /* Go to next byte */
+        pData++;
+
+        /* Extract the 3D Metadata type */
+        temp = (*pData & XV_HDMIRX_3D_META_TYPE_MASK) >> XV_HDMIRX_3D_META_TYPE_SHIFT;
+        if (temp >= XV_HDMIRX_3D_META_UNKNOWN)
+            InstancePtr->MetaData.Type = XV_HDMIRX_3D_META_UNKNOWN;
+        else
+            InstancePtr->MetaData.Type = (XV_HdmiRx_3D_MetaData_Type)temp;
+
+        /* Extract the 3D Metadata length */
+        InstancePtr->MetaData.Length = (*pData & XV_HDMIRX_3D_META_LENGTH_MASK) >> XV_HDMIRX_3D_META_LENGTH_SHIFT;
+
+        /* Extract the 3D Metadata */
+        int i;
+        for (i = 0; i<InstancePtr->MetaData.Length; i++){
+            if (i < XV_HDMIRX_3D_META_MAX_SIZE)
+                InstancePtr->MetaData.Data[i] = *(++pData);
+            else
+                return XST_FAILURE;
+        }
+    }
+
+    return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function displays the contents of an XV_HdmiRx_VSIF instance.
+*
+* @param VSIFPtr is a pointer to the XV_HdmiRx_VSIF instance.
+*
+* @return None.
+*
+******************************************************************************/
+void XV_HdmiRx_VSIF_DisplayInfo(XV_HdmiRx_VSIF  *VSIFPtr)
+{
+    switch (VSIFPtr->Format) {
+        /* Extended resolution format present */
+        case XV_HDMIRX_VSIF_VF_EXTRES :
+            /* HDMI_VIC */
+            xil_printf("HDMI_VIC : %d\n\r", VSIFPtr->HDMI_VIC);
+            break;
+
+        /* 3D format indication present */
+        case XV_HDMIRX_VSIF_VF_3D :
+            /* 3D_Structure */
+            xil_printf("3D Format : %s\n\r", XV_HdmiRx_VSIF_3DStructToString(XV_HdmiRx_VSIF_Conv3DInfoTo3DStruct(&VSIFPtr->Info_3D.Stream)));
+
+
+            /* 3D_Ext_Data */
+            if (XV_HdmiRx_VSIF_Conv3DInfoTo3DStruct(&VSIFPtr->Info_3D.Stream) >= XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF) {
+                xil_printf("Sampling Method : %s\n\r", XV_HdmiRx_VSIF_3DSampMethodToString(XV_HdmiRx_VSIF_Conv3DInfoTo3DSampMethod(&VSIFPtr->Info_3D.Stream)));
+                xil_printf("Sampling Position : %s\n\r", XV_HdmiRx_VSIF_3DSampPosToString(XV_HdmiRx_VSIF_Conv3DInfoTo3DSampPos(&VSIFPtr->Info_3D.Stream)));
+            }
+
+            /* 3D Metadata */
+            if (VSIFPtr->Info_3D.MetaData.IsPresent) {
+                /* 3D_Metadata_type */
+
+
+                /* 3D_Metadata */
+            }
+
+            break;
+
+        default :
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiRx_3D_Struct_Field.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiRx_VSIF_3DStructToString(XV_HdmiRx_3D_Struct_Field Item)
+{
+    switch(Item) {
+        case XV_HDMIRX_3D_STRUCT_FRAME_PACKING :
+            return (char*) "Frame Packing";
+
+        case XV_HDMIRX_3D_STRUCT_FIELD_ALTERNATIVE :
+            return (char*) "Field Alternative";
+
+        case XV_HDMIRX_3D_STRUCT_LINE_ALTERNATIVE :
+            return (char*) "Line Alternative";
+
+        case XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_FULL :
+            return (char*) "Side-by-Side(Full)";
+
+        case XV_HDMIRX_3D_STRUCT_L_DEPTH :
+            return (char*) "L + Depth";
+
+        case XV_HDMIRX_3D_STRUCT_L_DEPTH_GRAPH_GDEPTH :
+            return (char*) "L + Depth + Graphics + Graphics-depth";
+
+        case XV_HDMIRX_3D_STRUCT_TOP_AND_BOTTOM :
+            return (char*) "Top-and-Bottom";
+
+        case XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF :
+            return (char*) "Side-by-Side(Half)";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiRx_3D_Sampling_Method.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiRx_VSIF_3DSampMethodToString(XV_HdmiRx_3D_Sampling_Method Item)
+{
+    switch (Item) {
+        case XV_HDMIRX_3D_SAMPLING_HORIZONTAL :
+            return (char*) "Horizontal Sub-Sampling";
+
+        case XV_HDMIRX_3D_SAMPLING_QUINCUNX :
+            return (char*) "Quincunx Matrix";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns a string representation of the
+* enumerated type XV_HdmiRx_3D_Sampling_Position.
+*
+* @param Item specifies the value to convert.
+*
+* @return Pointer to the converted string.
+*
+******************************************************************************/
+char* XV_HdmiRx_VSIF_3DSampPosToString(XV_HdmiRx_3D_Sampling_Position Item)
+{
+    switch(Item) {
+        case XV_HDMIRX_3D_SAMPPOS_OLOR :
+            return (char*) "Odd/Left, Odd/Right";
+
+        case XV_HDMIRX_3D_SAMPPOS_OLER :
+            return (char*) "Odd/Left, Even/Right";
+
+        case XV_HDMIRX_3D_SAMPPOS_ELOR :
+            return (char*) "Even/Left, Odd/Right";
+
+        case XV_HDMIRX_3D_SAMPPOS_ELER :
+            return (char*) "Even/Left, Even/Right";
+
+        default :
+            return (char*) "Unknown";
+    }
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.h
new file mode 100644
index 0000000..29edeba
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirx_vsif.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirx_vsif.h
+*
+* This is the main header file for Vendor Specific InfoFrames used in HDMI.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date        Changes
+* ----- --- ----------   -----------------------------------------------
+* X.XX  XX  YYYY/MM/DD   ...
+* 1.00  RHe 2015/10/06   Initial release.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XV_HDMIRX_VSIF_H_
+/* Prevent circular inclusions by using protection macros. */
+#define XV_HDMIRX_VSIF_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************* Include Files ********************************/
+#include "xil_types.h"
+#include "xil_assert.h"
+#include "xstatus.h"
+
+#include "xvidc.h"
+
+/************************** Constant Definitions ******************************/
+
+/** @name Vendor Specific InfoFrame Field Masks and Shifts.
+ * @{
+ */
+#define XV_HDMIRX_VSIF_VIDEO_FORMAT_SHIFT 5
+#define XV_HDMIRX_VSIF_VIDEO_FORMAT_MASK (0x7 << XV_HDMIRX_VSIF_VIDEO_FORMAT_SHIFT)
+
+#define XV_HDMIRX_3D_STRUCT_SHIFT 4
+#define XV_HDMIRX_3D_STRUCT_MASK (0xF << XV_HDMIRX_3D_STRUCT_SHIFT)
+
+#define XV_HDMIRX_3D_SAMP_METHOD_SHIFT 6
+#define XV_HDMIRX_3D_SAMP_METHOD_MASK (0x3 << XV_HDMIRX_3D_SAMP_METHOD_SHIFT)
+
+#define XV_HDMIRX_3D_SAMP_POS_SHIFT 4
+#define XV_HDMIRX_3D_SAMP_POS_MASK (0x3 << XV_HDMIRX_3D_SAMP_POS_SHIFT)
+
+#define XV_HDMIRX_3D_META_PRESENT_SHIFT 3
+#define XV_HDMIRX_3D_META_PRESENT_MASK (0x1 << XV_HDMIRX_3D_META_PRESENT_SHIFT)
+
+#define XV_HDMIRX_3D_META_TYPE_SHIFT 5
+#define XV_HDMIRX_3D_META_TYPE_MASK (0x7 << XV_HDMIRX_3D_META_TYPE_SHIFT)
+
+#define XV_HDMIRX_3D_META_LENGTH_SHIFT 0
+#define XV_HDMIRX_3D_META_LENGTH_MASK (0x1F << XV_HDMIRX_3D_META_LENGTH_SHIFT)
+/* @} */
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * HDMI Video Format
+ */
+typedef enum {
+    XV_HDMIRX_VSIF_VF_NOINFO = 0, /**<No additional HDMI video format is presented */
+    XV_HDMIRX_VSIF_VF_EXTRES = 1, /**<Extended resolution format present */
+    XV_HDMIRX_VSIF_VF_3D     = 2, /**<3D format indication present */
+    XV_HDMIRX_VSIF_VF_UNKNOWN
+} XV_HdmiRx_VSIF_Video_Format;
+
+/**
+ * 3D structure definitions as defined in the HDMI 1.4a specification
+ */
+typedef enum {
+    XV_HDMIRX_3D_STRUCT_FRAME_PACKING        = 0, /**<Frame packing */
+    XV_HDMIRX_3D_STRUCT_FIELD_ALTERNATIVE    = 1, /**<Field alternative */
+    XV_HDMIRX_3D_STRUCT_LINE_ALTERNATIVE     = 2, /**<Line alternative */
+    XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_FULL    = 3, /**<Side-by-side (full) */
+    XV_HDMIRX_3D_STRUCT_L_DEPTH              = 4, /**<L + depth */
+    XV_HDMIRX_3D_STRUCT_L_DEPTH_GRAPH_GDEPTH = 5, /**<L + depth + graphics + graphics-depth */
+    XV_HDMIRX_3D_STRUCT_TOP_AND_BOTTOM       = 6, /**<Top-and-bottom */
+    // 7 is reserved for future use
+    XV_HDMIRX_3D_STRUCT_SIDE_BY_SIDE_HALF    = 8, /**<Side-by-side (half) */
+    XV_HDMIRX_3D_STRUCT_UNKNOWN
+} XV_HdmiRx_3D_Struct_Field;
+
+/**
+ * Sub-sampling methods for Side-by-side(half)
+ */
+typedef enum {
+    XV_HDMIRX_3D_SAMPLING_HORIZONTAL = 0, /**<Horizontal sub-sampling */
+    XV_HDMIRX_3D_SAMPLING_QUINCUNX   = 1, /**<Quincunx matrix */
+    XV_HDMIRX_3D_SAMPLING_UNKNOWN
+} XV_HdmiRx_3D_Sampling_Method;
+
+/**
+ * Sub-sampling positions for the sub-sampling methods
+ */
+typedef enum {
+    XV_HDMIRX_3D_SAMPPOS_OLOR = 0, /**<Odd/Left, Odd/Right */
+    XV_HDMIRX_3D_SAMPPOS_OLER = 1, /**<Odd/Left, Even/Right */
+    XV_HDMIRX_3D_SAMPPOS_ELOR = 2, /**<Even/Left, Odd/Right */
+    XV_HDMIRX_3D_SAMPPOS_ELER = 3, /**<Even/Left, Even/Right */
+    XV_HDMIRX_3D_SAMPPOS_UNKNOWN
+} XV_HdmiRx_3D_Sampling_Position;
+
+/**
+ * 3D Metadata types
+ */
+typedef enum {
+    XV_HDMIRX_3D_META_PARALLAX = 0, /**<Parallax information */
+    XV_HDMIRX_3D_META_UNKNOWN
+} XV_HdmiRx_3D_MetaData_Type;
+
+
+// 8 is the maximum size for currently defined meta types (HDMI 1.4a)
+#define XV_HDMIRX_3D_META_MAX_SIZE 8 /**<Maximum 3D Metadata size in bytes */
+
+/**
+ * Structure for 3D meta data
+ */
+typedef struct {
+    u8                     IsPresent;                    /**<Indicates 3D metadata presence */
+    XV_HdmiRx_3D_MetaData_Type Type;                         /**<Type */
+    u8                     Length;                       /**<Length in bytes */
+    u8                     Data[XV_HDMIRX_3D_META_MAX_SIZE]; /**<Data */
+} XV_HdmiRx_3D_MetaData;
+
+/**
+ * Structure containing 3D information
+ */
+typedef struct {
+    XVidC_3DInfo               Stream;
+    XV_HdmiRx_3D_MetaData          MetaData;   /**<3D Metadata */
+} XV_HdmiRx_3D_Info;
+
+/**
+ * Structure for holding the VSIF.
+ * Format indicates the used union member.
+ */
+typedef struct {
+    u8                      Version; /**<Version */
+    u32                     IEEE_ID; /**<IEEE Registration Identifier */
+    XV_HdmiRx_VSIF_Video_Format Format;  /**<HDMI Video Format */
+
+    union {
+        u8            HDMI_VIC; /**<XV_HDMIRX_VSIF_VF_EXTRES: HDMI Video Format Identification Code */
+        XV_HdmiRx_3D_Info Info_3D;  /**<XV_HDMIRX_VSIF_VF_3D: 3D Information */
+    };
+
+} XV_HdmiRx_VSIF;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* End of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.c
new file mode 100644
index 0000000..646d681
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.c
@@ -0,0 +1,1774 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirxss.c
+*
+* This is main code of Xilinx HDMI Receiver Subsystem device driver.
+* Please see xv_hdmirxss.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     15/01/16 Added 3D Video support
+* 1.2   yh     20/01/16 Added remapper support
+* 1.3   yh     01/02/16 Added set_ppc api
+* 1.4   yh     01/02/16 Removed xil_print "Cable (dis)connected"
+* 1.5   yh     01/02/16 Removed xil_printf("Active audio channels...)
+* 1.6   yh     15/02/16 Added default value to XV_HdmiRxSs_ConfigRemapper
+* 1.7   MG     03/02/16 Added HDCP support
+* 1.8   MG     10/02/16 Moved HDCP 2.2 reset from stream up/down callback
+*                       to connect callback
+* 1.9   MH     15/03/16 Added HDCP authenticated callback support
+* 1.10  MH     23/04/16 1. HDCP 1.x driver now uses AXI timer 4.1, so updated
+*                       to use AXI Timer config structure to determine timer
+*                       clock frequency
+*                       2. HDCP 1.x driver has fixed the problem where the
+*                       reset for the receiver causes the entire DDC peripheral
+*                       to get reset. Based on this change the driver has been
+*                       updated to use XV_HdmiRxSs_HdcpReset and
+*                       XV_HdmiRxSs_HdcpReset functions directly.
+*                       3. Updated XV_HdmiRxSs_HdcpEnable and
+*                       XV_HdmiRxSs_HdcpEnable functions to ensure that
+*                       HDCP 1.4 and 2.2 are mutually exclusive.
+*                       This fixes the problem where HDCP 1.4 and 2.2
+*                       state machines are running simultaneously.
+* 1.11  MG     13/05/16 Added DDC peripheral HDCP mode selection to XV_HdmiRxSs_HdcpEnable
+* 1.12  MH     23/06/16 Added HDCP repeater support.
+* 1.13  YH     18/07/16 1. Replace xil_print with xdbg_printf.
+*                       2. Replace MB_Sleep() with usleep_range(,  + /10)
+* 1.14  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+*                       XV_HdmiRxSs_CfgInitialize
+* 1.15  MH     26/07/16 Updates for automatic protocol switching
+* 1.16  MH     05/08/16 Updates to optimize out HDCP when excluded
+* 1.17  YH     17/08/16 Remove sleep in XV_HdmiRxSs_ResetRemapper
+*                       squash unused variable compiler warning
+*                       Added Event Log
+* 1.18  MH     08/10/16 Improve HDCP 1.4 authentication
+* 1.19  MG     31/10/16 Fixed issue with reference clock compensation in
+*                           XV_HdmiRxSS_SetStream
+* 1.20  YH     14/11/16 Added API to enable/disable YUV420/Pixel Drop Mode
+*                       for video bridge
+* 1.21  YH     14/11/16 Remove Remapper APIs
+*                       Replace XV_HdmiRxSs_ConfigRemapper API with
+*                       XV_HdmiRxSs_ConfigBridgeMode API as remapper feature is
+*                           moved to video bridge and controlled by HDMI core
+* 1.22  MMO    03/01/17 Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable
+*                           Log
+*                       Move global variable XV_HdmiRx_VSIF VSIF to local
+*                           XV_HdmiRxSs_RetrieveVSInfoframe API
+*                       Move HDCP related API's to hdmirxss_hdcp.c
+* 1.23  MMO    10/02/17 Added Sync Loss and HDMI/DVI Interrupt Support
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include <linux/delay.h>
+#include "xv_hdmirxss.h"
+#include "xv_hdmirxss_coreinit.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+/**
+ * This typedef declares the driver instances of all the cores in the subsystem
+ */
+typedef struct
+{
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  XTmrCtr HdcpTimer;
+  XHdcp1x Hdcp14;
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  XHdcp22_Rx Hdcp22;
+#endif
+  XV_HdmiRx HdmiRx;
+} XV_HdmiRxSs_SubCores;
+
+/**************************** Local Global ***********************************/
+/** Define Driver instance of all sub-core included in the design */
+XV_HdmiRxSs_SubCores XV_HdmiRxSs_SubCoreRepo[XPAR_XV_HDMIRXSS_NUM_INSTANCES];
+
+/************************** Function Prototypes ******************************/
+static void XV_HdmiRxSs_GetIncludedSubcores(XV_HdmiRxSs *HdmiRxSsPtr,
+    u16 DevId);
+static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs *InstancePtr, u32 MicroSeconds);
+static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRx *HdmiRxPtr);
+static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef);
+static void XV_HdmiRxSs_AuxCallback(void *CallbackRef);
+static void XV_HdmiRxSs_AudCallback(void *CallbackRef);
+static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef);
+static void XV_HdmiRxSs_DdcCallback(void *CallbackRef);
+static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef);
+static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef);
+static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef);
+static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef);
+static void XV_HdmiRxSs_ModeCallback(void *CallbackRef);
+
+static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ReportTiming(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ReportLinkQuality(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ReportAudio(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ReportInfoFrame(XV_HdmiRxSs *InstancePtr);
+static void XV_HdmiRxSs_ReportSubcoreVersion(XV_HdmiRxSs *InstancePtr);
+
+static void XV_HdmiRxSs_ConfigBridgeMode(XV_HdmiRxSs *InstancePtr);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+/*****************************************************************************/
+/**
+* This macros selects the bridge YUV420 mode
+*
+* @param  InstancePtr is a pointer to the HDMI RX Subsystem
+*
+*****************************************************************************/
+#define XV_HdmiRxSs_BridgeYuv420(InstancePtr,Enable) \
+{ \
+    XV_HdmiRx_Bridge_yuv420(InstancePtr->HdmiRxPtr, Enable); \
+} \
+
+/*****************************************************************************/
+/**
+* This macros selects the bridge pixel repeat mode
+*
+* @param  InstancePtr is a pointer to the HDMI TX Subsystem
+*
+*****************************************************************************/
+#define XV_HdmiRxSs_BridgePixelDrop(InstancePtr,Enable) \
+{ \
+    XV_HdmiRx_Bridge_pixel(InstancePtr->HdmiRxPtr, Enable); \
+}
+
+/************************** Function Definition ******************************/
+
+void XV_HdmiRxSs_ReportInfo(XV_HdmiRxSs *InstancePtr)
+{
+    xil_printf("------------\r\n");
+    xil_printf("HDMI RX SubSystem\r\n");
+    xil_printf("------------\r\n");
+    XV_HdmiRxSs_ReportCoreInfo(InstancePtr);
+    XV_HdmiRxSs_ReportSubcoreVersion(InstancePtr);
+    xil_printf("\r\n");
+    xil_printf("HDMI RX timing\r\n");
+    xil_printf("------------\r\n");
+    XV_HdmiRxSs_ReportTiming(InstancePtr);
+    xil_printf("Link quality\r\n");
+    xil_printf("---------\r\n");
+    XV_HdmiRxSs_ReportLinkQuality(InstancePtr);
+    xil_printf("Audio\r\n");
+    xil_printf("---------\r\n");
+    XV_HdmiRxSs_ReportAudio(InstancePtr);
+    xil_printf("Infoframe\r\n");
+    xil_printf("---------\r\n");
+    XV_HdmiRxSs_ReportInfoFrame(InstancePtr);
+    xil_printf("\r\n");
+}
+
+/*****************************************************************************/
+/**
+* This function reports list of cores included in Video Processing Subsystem
+*
+* @param  InstancePtr is a pointer to the Subsystem instance.
+*
+* @return None
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  xil_printf("\r\n  ->HDMI RX Subsystem Cores\r\n");
+
+  /* Report all the included cores in the subsystem instance */
+  if(InstancePtr->HdmiRxPtr)
+  {
+    xil_printf("    : HDMI RX \r\n");
+  }
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if(InstancePtr->Hdcp14Ptr)
+  {
+    xil_printf("    : HDCP 1.4 RX \r\n");
+  }
+
+  if(InstancePtr->HdcpTimerPtr)
+  {
+    xil_printf("    : HDCP: AXIS Timer\r\n");
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  if(InstancePtr->Hdcp22Ptr)
+  {
+    xil_printf("    : HDCP 2.2 RX \r\n");
+  }
+#endif
+}
+
+/******************************************************************************/
+/**
+ * This function installs a custom delay/sleep function to be used by the
+ *  XV_HdmiRxSs driver.
+ *
+ * @param   InstancePtr is a pointer to the HdmiSsRx instance.
+ * @param   CallbackFunc is the address to the callback function.
+ * @param   CallbackRef is the user data item (microseconds to delay) that
+ *      will be passed to the custom sleep/delay function when it is
+ *      invoked.
+ *
+ * @return  None.
+ *
+ * @note    None.
+ *
+*******************************************************************************/
+void XV_HdmiRxSs_SetUserTimerHandler(XV_HdmiRxSs *InstancePtr,
+            XVidC_DelayHandler CallbackFunc, void *CallbackRef)
+{
+    /* Verify arguments. */
+    Xil_AssertVoid(InstancePtr != NULL);
+    Xil_AssertVoid(CallbackFunc != NULL);
+    Xil_AssertVoid(CallbackRef != NULL);
+
+    InstancePtr->UserTimerWaitUs = CallbackFunc;
+    InstancePtr->UserTimerPtr = CallbackRef;
+}
+
+/******************************************************************************/
+/**
+ * This function is the delay/sleep function for the XV_HdmiRxSs driver. For the
+ * Zynq family, there exists native sleep functionality. For MicroBlaze however,
+ * there does not exist such functionality. In the MicroBlaze case, the default
+ * method for delaying is to use a predetermined amount of loop iterations. This
+ * method is prone to inaccuracy and dependent on system configuration; for
+ * greater accuracy, the user may supply their own delay/sleep handler, pointed
+ * to by InstancePtr->UserTimerWaitUs, which may have better accuracy if a
+ * hardware timer is used.
+ *
+ * @param   InstancePtr is a pointer to the HdmiSsRx instance.
+ * @param   MicroSeconds is the number of microseconds to delay/sleep for.
+ *
+ * @return  None.
+ *
+ * @note    None.
+ *
+*******************************************************************************/
+static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs *InstancePtr, u32 MicroSeconds)
+{
+    /* Verify arguments. */
+    Xil_AssertVoid(InstancePtr != NULL);
+    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
+
+    if (MicroSeconds == 0) {
+        return;
+    }
+
+    if (InstancePtr->UserTimerWaitUs != NULL) {
+        /* Use the timer handler specified by the user for better
+         * accuracy. */
+        InstancePtr->UserTimerWaitUs(InstancePtr, MicroSeconds);
+    }
+    else {
+        usleep_range(MicroSeconds, MicroSeconds + MicroSeconds/10);
+    }
+}
+
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDMI RX
+ *
+ * @param  InstancePtr is a pointer to the HDMI RX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiRxSS_HdmiRxIntrHandler(XV_HdmiRxSs *InstancePtr)
+{
+    XV_HdmiRx_IntrHandler(InstancePtr->HdmiRxPtr);
+}
+
+/*****************************************************************************/
+/**
+ * This function register's all sub-core ISR's with interrupt controller and
+ * any subsystem level call back function with requisite sub-core
+ *
+ * @param  InstancePtr is a pointer to the Subsystem instance to be
+ *       worked on.
+ *
+ *****************************************************************************/
+static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = InstancePtr;
+
+  //Register HDMI callbacks
+  if(HdmiRxSsPtr->HdmiRxPtr) {
+    /*
+     * Register call back for Rx Core Interrupts.
+     */
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_CONNECT,
+                          (void *)XV_HdmiRxSs_ConnectCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_AUX,
+						  (void *)XV_HdmiRxSs_AuxCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_AUD,
+						  (void *)XV_HdmiRxSs_AudCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_LNKSTA,
+						  (void *)XV_HdmiRxSs_LnkStaCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_DDC,
+						  (void *)XV_HdmiRxSs_DdcCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_STREAM_DOWN,
+						  (void *)XV_HdmiRxSs_StreamDownCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_STREAM_INIT,
+						  (void *)XV_HdmiRxSs_StreamInitCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_STREAM_UP,
+						  (void *)XV_HdmiRxSs_StreamUpCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_SYNC_LOSS,
+						  (void *)XV_HdmiRxSs_SyncLossCallback,
+						  (void *)InstancePtr);
+
+    XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                          XV_HDMIRX_HANDLER_MODE,
+						  (void *)XV_HdmiRxSs_ModeCallback,
+						  (void *)InstancePtr);
+  }
+
+  return(XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* This function queries the subsystem instance configuration to determine
+* the included sub-cores. For each sub-core that is present in the design
+* the sub-core driver instance is binded with the subsystem sub-core driver
+* handle
+*
+* @param  HdmiRxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+static void XV_HdmiRxSs_GetIncludedSubcores(XV_HdmiRxSs *HdmiRxSsPtr, u16 DevId)
+{
+  HdmiRxSsPtr->HdmiRxPtr   =((HdmiRxSsPtr->Config.HdmiRx.IsPresent) ?
+                            (&XV_HdmiRxSs_SubCoreRepo[DevId].HdmiRx) : NULL);
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  HdmiRxSsPtr->Hdcp14Ptr   =((HdmiRxSsPtr->Config.Hdcp14.IsPresent) ?
+                            (&XV_HdmiRxSs_SubCoreRepo[DevId].Hdcp14) : NULL);
+  HdmiRxSsPtr->HdcpTimerPtr=((HdmiRxSsPtr->Config.HdcpTimer.IsPresent) ?
+                            (&XV_HdmiRxSs_SubCoreRepo[DevId].HdcpTimer) : NULL);
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  HdmiRxSsPtr->Hdcp22Ptr   =((HdmiRxSsPtr->Config.Hdcp22.IsPresent) ?
+                            (&XV_HdmiRxSs_SubCoreRepo[DevId].Hdcp22) : NULL);
+#endif
+}
+
+/*****************************************************************************/
+/**
+* This function initializes the video subsystem and included sub-cores.
+* This function must be called prior to using the subsystem. Initialization
+* includes setting up the instance data for top level as well as all included
+* sub-core therein, and ensuring the hardware is in a known stable state.
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+* @param  CfgPtr points to the configuration structure associated with the
+*         subsystem instance.
+* @param  EffectiveAddr is the base address of the device. If address
+*         translation is being used, then this parameter must reflect the
+*         virtual base address. Otherwise, the physical address should be
+*         used.
+*
+* @return XST_SUCCESS if initialization is successful else XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiRxSs_CfgInitialize(XV_HdmiRxSs *InstancePtr,
+    XV_HdmiRxSs_Config *CfgPtr,
+    UINTPTR EffectiveAddr)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = InstancePtr;
+
+  /* Verify arguments */
+  Xil_AssertNonvoid(HdmiRxSsPtr != NULL);
+  Xil_AssertNonvoid(CfgPtr != NULL);
+  Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)NULL);
+
+  /* Setup the instance */
+  memcpy((void *)&(HdmiRxSsPtr->Config), (const void *)CfgPtr,
+    sizeof(XV_HdmiRxSs_Config));
+  HdmiRxSsPtr->Config.BaseAddress = EffectiveAddr;
+
+  /* Determine sub-cores included in the provided instance of subsystem */
+  XV_HdmiRxSs_GetIncludedSubcores(HdmiRxSsPtr, CfgPtr->DeviceId);
+
+  /* Initialize all included sub_cores */
+  if(HdmiRxSsPtr->HdmiRxPtr)
+  {
+    if(XV_HdmiRxSs_SubcoreInitHdmiRx(HdmiRxSsPtr) != XST_SUCCESS)
+    {
+      return(XST_FAILURE);
+    }
+  }
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  if(HdmiRxSsPtr->Hdcp14Ptr)
+  {
+    if(XV_HdmiRxSs_SubcoreInitHdcp14(HdmiRxSsPtr) != XST_SUCCESS)
+    {
+      return(XST_FAILURE);
+    }
+  }
+
+  if(HdmiRxSsPtr->HdcpTimerPtr)
+  {
+    if(XV_HdmiRxSs_SubcoreInitHdcpTimer(HdmiRxSsPtr) != XST_SUCCESS)
+    {
+      return(XST_FAILURE);
+    }
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  // HDCP 2.2
+  if(HdmiRxSsPtr->Hdcp22Ptr)
+  {
+    if(XV_HdmiRxSs_SubcoreInitHdcp22(HdmiRxSsPtr) != XST_SUCCESS)
+    {
+      return(XST_FAILURE);
+    }
+  }
+#endif
+
+  /* Register Callbacks */
+  XV_HdmiRxSs_RegisterSubsysCallbacks(HdmiRxSsPtr);
+
+#ifdef USE_HDCP_RX
+  /* Default value */
+  HdmiRxSsPtr->HdcpIsReady = (FALSE);
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES) && defined(XPAR_XHDCP22_RX_NUM_INSTANCES)
+  /* HDCP is ready when both HDCP cores are instantiated and all keys are
+     loaded */
+  if (HdmiRxSsPtr->Hdcp14Ptr && HdmiRxSsPtr->Hdcp22Ptr &&
+      HdmiRxSsPtr->Hdcp22Lc128Ptr && HdmiRxSsPtr->Hdcp14KeyPtr &&
+      HdmiRxSsPtr->Hdcp22PrivateKeyPtr) {
+    HdmiRxSsPtr->HdcpIsReady = (TRUE);
+
+    /* Set default HDCP content protection scheme */
+    XV_HdmiRxSs_HdcpSetProtocol(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_14);
+  }
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES)
+  /* HDCP is ready when only the HDCP 1.4 core is instantiated and the key is
+     loaded */
+  if (!HdmiRxSsPtr->HdcpIsReady && HdmiRxSsPtr->Hdcp14Ptr &&
+       HdmiRxSsPtr->Hdcp14KeyPtr) {
+    HdmiRxSsPtr->HdcpIsReady = (TRUE);
+
+    /* Set default HDCP content protection scheme */
+    XV_HdmiRxSs_HdcpSetProtocol(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_14);
+  }
+#endif
+
+#if defined(XPAR_XHDCP22_RX_NUM_INSTANCES)
+  /* HDCP is ready when only the HDCP 2.2 core is instantiated and the keys are
+     loaded */
+  if (!HdmiRxSsPtr->HdcpIsReady && HdmiRxSsPtr->Hdcp22Ptr &&
+       HdmiRxSsPtr->Hdcp22Lc128Ptr && HdmiRxSsPtr->Hdcp22PrivateKeyPtr) {
+    HdmiRxSsPtr->HdcpIsReady = (TRUE);
+
+    /* Set default HDCP content protection scheme */
+    XV_HdmiRxSs_HdcpSetProtocol(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_22);
+  }
+#endif
+
+  /* Reset the hardware and set the flag to indicate the
+     subsystem is ready
+   */
+  XV_HdmiRxSs_Reset(HdmiRxSsPtr);
+  HdmiRxSsPtr->IsReady = XIL_COMPONENT_IS_READY;
+
+  return(XST_SUCCESS);
+}
+
+/****************************************************************************/
+/**
+* This function starts the HDMI RX subsystem including all sub-cores that are
+* included in the processing pipeline for a given use-case. Video pipe is
+* started from back to front
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+* @note Cores are started only if the corresponding start flag in the scratch
+*       pad memory is set. This allows to selectively start only those cores
+*       included in the processing chain
+******************************************************************************/
+void XV_HdmiRxSs_Start(XV_HdmiRxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_START, 0);
+#endif
+  /* Set RX hot plug detect */
+  XV_HdmiRx_SetHpd(InstancePtr->HdmiRxPtr, TRUE);
+
+  /* Disable Audio Peripheral */
+  XV_HdmiRx_AudioDisable(InstancePtr->HdmiRxPtr);
+  XV_HdmiRx_AudioIntrDisable(InstancePtr->HdmiRxPtr);
+}
+
+/*****************************************************************************/
+/**
+* This function stops the HDMI RX subsystem including all sub-cores
+* Stop the video pipe starting from front to back
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+void XV_HdmiRxSs_Stop(XV_HdmiRxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_STOP, 0);
+#endif
+}
+
+/*****************************************************************************/
+/**
+* This function resets the video subsystem sub-cores. There are 2 reset
+* networks within the subsystem
+*  - For cores that are on AXIS interface
+*  - For cores that are on AXI-MM interface
+*
+* @param  InstancePtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return None
+*
+******************************************************************************/
+void XV_HdmiRxSs_Reset(XV_HdmiRxSs *InstancePtr)
+{
+  Xil_AssertVoid(InstancePtr != NULL);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_RESET, 0);
+#endif
+  /* Assert RX reset */
+  XV_HdmiRx_Reset(InstancePtr->HdmiRxPtr, TRUE);
+
+  /* Release RX reset */
+  XV_HdmiRx_Reset(InstancePtr->HdmiRxPtr, FALSE);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX connect event has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // Is the cable connected?
+  if (XV_HdmiRx_IsStreamConnected(HdmiRxSsPtr->HdmiRxPtr)) {
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_CONNECT, 0);
+#endif
+    // Set RX hot plug detect
+    XV_HdmiRx_SetHpd(HdmiRxSsPtr->HdmiRxPtr, TRUE);
+
+    // Set stream connected flag
+    HdmiRxSsPtr->IsStreamConnected = (TRUE);
+
+#ifdef USE_HDCP_RX
+    // Push connect event to HDCP event queue
+    XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_CONNECT_EVT);
+#endif
+  }
+
+  // RX cable is disconnected
+  else {
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DISCONNECT, 0);
+#endif
+    // Clear RX hot plug detect
+    XV_HdmiRx_SetHpd(HdmiRxSsPtr->HdmiRxPtr, FALSE);
+
+    // Set stream connected flag
+    HdmiRxSsPtr->IsStreamConnected = (FALSE);
+
+#ifdef USE_HDCP_RX
+    // Push disconnect event to HDCP event queue
+    XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_DISCONNECT_EVT);
+#endif
+
+    XV_HdmiRx_SetScrambler(HdmiRxSsPtr->HdmiRxPtr, (FALSE)); //Disable scrambler
+  }
+
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->ConnectCallback) {
+    HdmiRxSsPtr->ConnectCallback(HdmiRxSsPtr->ConnectRef);
+  }
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX AUX IRQ has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_AuxCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // Retrieve Vendor Specific Info Frame
+  XV_HdmiRxSs_RetrieveVSInfoframe(HdmiRxSsPtr->HdmiRxPtr);
+
+  // HDMI mode
+  if (XV_HdmiRxSs_GetVideoStreamType(HdmiRxSsPtr )) {
+#ifdef USE_HDCP_RX
+    XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_HDMI_MODE_EVT);
+#endif
+  }
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->AuxCallback) {
+      HdmiRxSsPtr->AuxCallback(HdmiRxSsPtr->AuxRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX Sync Loss IRQ has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // Push sync loss event to HDCP event queue
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_SYNCLOSS, 0);
+#endif
+
+#ifdef USE_HDCP_RX
+  XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_SYNC_LOSS_EVT);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the mode has transitioned from DVI to HDMI or
+* vice versa.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ModeCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // HDMI mode
+  if (XV_HdmiRxSs_GetVideoStreamType(HdmiRxSsPtr )) {
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDMIMODE, 0);
+#endif
+#ifdef USE_HDCP_RX
+    XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_HDMI_MODE_EVT);
+#endif
+  }
+
+  // DVI mode
+  else {
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DVIMODE, 0);
+#endif
+#ifdef USE_HDCP_RX
+    XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_DVI_MODE_EVT);
+#endif
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function retrieves the Vendor Specific Info Frame.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRx *HdmiRx)
+{
+  /** Vendor-Specific InfoFrame structure */
+  XV_HdmiRx_VSIF VSIF;
+
+  if (HdmiRx->Aux.Header.Byte[0] == 0x81) {
+      XV_HdmiRx_VSIF_ParsePacket(&HdmiRx->Aux, &VSIF);
+
+      // Defaults
+      HdmiRx->Stream.Video.Is3D = FALSE;
+      HdmiRx->Stream.Video.Info_3D.Format = XVIDC_3D_UNKNOWN;
+
+      if (VSIF.Format == XV_HDMIRX_VSIF_VF_3D) {
+          HdmiRx->Stream.Video.Is3D = TRUE;
+          HdmiRx->Stream.Video.Info_3D = VSIF.Info_3D.Stream;
+      } else if (VSIF.Format == XV_HDMIRX_VSIF_VF_EXTRES) {
+          switch(VSIF.HDMI_VIC) {
+              case 1 :
+                  HdmiRx->Stream.Vic = 95;
+                  break;
+
+              case 2 :
+                  HdmiRx->Stream.Vic = 94;
+                  break;
+
+              case 3 :
+                  HdmiRx->Stream.Vic = 93;
+                  break;
+
+              case 4 :
+                  HdmiRx->Stream.Vic = 98;
+                  break;
+
+              default :
+                  break;
+          }
+      }
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX Audio IRQ has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_AudCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  u8 Channels;
+
+  if (XV_HdmiRx_IsAudioActive(HdmiRxSsPtr->HdmiRxPtr)) {
+
+    // Get audio channels
+    Channels = XV_HdmiRx_GetAudioChannels(HdmiRxSsPtr->HdmiRxPtr);
+    HdmiRxSsPtr->AudioChannels = Channels;
+  }
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->AudCallback) {
+      HdmiRxSsPtr->AudCallback(HdmiRxSsPtr->AudRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX Link Status IRQ has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  HdmiRxSsPtr->IsLinkStatusErrMax =
+    XV_HdmiRx_IsLinkStatusErrMax(HdmiRxSsPtr->HdmiRxPtr);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_LINKSTATUS, 0);
+#endif
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->LnkStaCallback) {
+      HdmiRxSsPtr->LnkStaCallback(HdmiRxSsPtr->LnkStaRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when a RX DDC IRQ has occurred.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_DdcCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->DdcCallback) {
+      HdmiRxSsPtr->DdcCallback(HdmiRxSsPtr->DdcRef);
+  }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the RX stream is down.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  // Assert HDMI RX reset
+  XV_HdmiRx_Reset(HdmiRxSsPtr->HdmiRxPtr, TRUE);
+
+  /* Set stream up flag */
+  HdmiRxSsPtr->IsStreamUp = (FALSE);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMDOWN, 0);
+#endif
+#ifdef USE_HDCP_RX
+  // Push stream-down event to HDCP event queue
+  XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_STREAMDOWN_EVT);
+#endif
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->StreamDownCallback) {
+      HdmiRxSsPtr->StreamDownCallback(HdmiRxSsPtr->StreamDownRef);
+  }
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the RX stream init .
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMINIT, 0);
+#endif
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->StreamInitCallback) {
+      HdmiRxSsPtr->StreamInitCallback(HdmiRxSsPtr->StreamInitRef);
+  }
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when the RX stream is up.
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr = (XV_HdmiRxSs *)CallbackRef;
+
+  /* Clear link Status error counters */
+  XV_HdmiRx_ClearLinkStatus(HdmiRxSsPtr->HdmiRxPtr);
+
+  /* Set stream up flag */
+  HdmiRxSsPtr->IsStreamUp = (TRUE);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMUP, 0);
+#endif
+#ifdef USE_HDCP_RX
+  // Push stream-up event to HDCP event queue
+  XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_STREAMUP_EVT);
+#endif
+
+  /* Configure Remapper according to HW setting and video format */
+  XV_HdmiRxSs_ConfigBridgeMode(HdmiRxSsPtr);
+
+  // Check if user callback has been registered
+  if (HdmiRxSsPtr->StreamUpCallback) {
+      HdmiRxSsPtr->StreamUpCallback(HdmiRxSsPtr->StreamUpRef);
+  }
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function installs an asynchronous callback function for the given
+* HandlerType:
+*
+* <pre>
+* HandlerType                     Callback Function Type
+* -----------------------         --------------------------------------------------
+* (XV_HDMIRXSS_HANDLER_CONNECT)             HpdCallback
+* (XV_HDMIRXSS_HANDLER_VS)                  VsCallback
+* (XV_HDMIRXSS_HANDLER_STREAM_DOWN)         StreamDownCallback
+* (XV_HDMIRXSS_HANDLER_STREAM_UP)           StreamUpCallback
+* (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED)
+* (XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED)
+* (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST)
+* (XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST)
+* (XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE)
+* </pre>
+*
+* @param    InstancePtr is a pointer to the HDMI RX Subsystem instance.
+* @param    HandlerType specifies the type of handler.
+* @param    CallbackFunc is the address of the callback function.
+* @param    CallbackRef is a user data item that will be passed to the
+*       callback function when it is invoked.
+*
+* @return
+*       - XST_SUCCESS if callback function installed successfully.
+*       - XST_INVALID_PARAM when HandlerType is invalid.
+*
+* @note     Invoking this function for a handler that already has been
+*       installed replaces it with the new handler.
+*
+******************************************************************************/
+int XV_HdmiRxSs_SetCallback(XV_HdmiRxSs *InstancePtr, u32 HandlerType,
+    void *CallbackFunc, void *CallbackRef)
+{
+    u32 Status;
+
+    /* Verify arguments. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+    Xil_AssertNonvoid(HandlerType >= (XV_HDMIRXSS_HANDLER_CONNECT));
+    Xil_AssertNonvoid(CallbackFunc != NULL);
+    Xil_AssertNonvoid(CallbackRef != NULL);
+
+    /* Check for handler type */
+    switch (HandlerType) {
+
+        case (XV_HDMIRXSS_HANDLER_CONNECT):
+            InstancePtr->ConnectCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->ConnectRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRXSS_HANDLER_AUX):
+            InstancePtr->AuxCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->AuxRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRXSS_HANDLER_AUD):
+            InstancePtr->AudCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->AudRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        case (XV_HDMIRXSS_HANDLER_LNKSTA):
+            InstancePtr->LnkStaCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->LnkStaRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Ddc
+        case (XV_HDMIRXSS_HANDLER_DDC):
+            InstancePtr->DdcCallback =(XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->DdcRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream down
+        case (XV_HDMIRXSS_HANDLER_STREAM_DOWN):
+            InstancePtr->StreamDownCallback =(XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->StreamDownRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream Init
+        case (XV_HDMIRXSS_HANDLER_STREAM_INIT):
+            InstancePtr->StreamInitCallback =(XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->StreamInitRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // Stream up
+        case (XV_HDMIRXSS_HANDLER_STREAM_UP):
+            InstancePtr->StreamUpCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->StreamUpRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP
+        case (XV_HDMIRXSS_HANDLER_HDCP):
+            InstancePtr->HdcpCallback = (XV_HdmiRxSs_Callback)CallbackFunc;
+            InstancePtr->HdcpRef = CallbackRef;
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP authenticated
+        case (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            // Register HDCP 1.4 callbacks
+            if (InstancePtr->Hdcp14Ptr) {
+              XHdcp1x_SetCallback(InstancePtr->Hdcp14Ptr,
+                                  XHDCP1X_HANDLER_AUTHENTICATED,
+								  (void *)(XHdcp1x_Callback)CallbackFunc,
+								  (void *)CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_AUTHENTICATED,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP authenticated
+        case (XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            // Register HDCP 1.4 callbacks
+            if (InstancePtr->Hdcp14Ptr) {
+              XHdcp1x_SetCallback(InstancePtr->Hdcp14Ptr,
+                                XHDCP1X_HANDLER_UNAUTHENTICATED,
+								(void *)(XHdcp1x_Callback)CallbackFunc,
+								(void *)CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_UNAUTHENTICATED,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP authentication request
+        case (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            // Register HDCP 1.4 callbacks
+            if (InstancePtr->Hdcp14Ptr) {
+        //Register the hdcp trigger downstream authentication callback
+               XHdcp1x_SetCallBack(InstancePtr->Hdcp14Ptr,
+                                   (XHdcp1x_HandlerType) XHDCP1X_RPTR_HDLR_TRIG_DOWNSTREAM_AUTH,
+								   (void *) (XHdcp1x_Callback)CallbackFunc,
+								   (void *) CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_AUTHENTICATION_REQUEST,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP stream management request
+        case (XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST):
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_STREAM_MANAGE_REQUEST,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP topology update request
+        case (XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            // Register HDCP 1.4 callbacks
+            if (InstancePtr->Hdcp14Ptr) {
+              XHdcp1x_SetCallback(InstancePtr->Hdcp14Ptr,
+                                  XHDCP1X_HANDLER_TOPOLOGY_UPDATE,
+								  (void *)(XHdcp1x_Callback)CallbackFunc,
+								  (void *)CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_TOPOLOGY_UPDATE,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        // HDCP encryption status update
+        case (XV_HDMIRXSS_HANDLER_HDCP_ENCRYPTION_UPDATE):
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+            // Register HDCP 1.4 callbacks
+            if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetCallback(InstancePtr->Hdcp14Ptr,
+                                 XHDCP1X_HANDLER_ENCRYPTION_UPDATE,
+								 (void *)(XHdcp1x_Callback)CallbackFunc,
+								 (void *)CallbackRef);
+            }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+            // Register HDCP 2.2 callbacks
+            if (InstancePtr->Hdcp22Ptr) {
+              XHdcp22Rx_SetCallback(InstancePtr->Hdcp22Ptr,
+                                    XHDCP22_RX_HANDLER_ENCRYPTION_UPDATE,
+									(void *)(XHdcp22_Rx_RunHandler)CallbackFunc,
+									(void *)CallbackRef);
+            }
+#endif
+            Status = (XST_SUCCESS);
+            break;
+
+        default:
+            Status = (XST_INVALID_PARAM);
+            break;
+    }
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the EDID parameters in the HDMI RX SS struct
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_SetEdidParam(XV_HdmiRxSs *InstancePtr, u8 *EdidDataPtr,
+                                                                u16 Length)
+{
+    InstancePtr->EdidPtr = EdidDataPtr;
+    InstancePtr->EdidLength = Length;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function loads the default EDID to the HDMI RX
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_LoadDefaultEdid(XV_HdmiRxSs *InstancePtr)
+{
+    u32 Status;
+
+    // Load new EDID
+    Status = XV_HdmiRx_DdcLoadEdid(InstancePtr->HdmiRxPtr, InstancePtr->EdidPtr,
+            InstancePtr->EdidLength);
+    if (Status == XST_SUCCESS) {
+        xil_printf("\r\nSuccessfully loaded edid.\r\n");
+    }
+    else {
+        xil_printf("\r\nError loading edid.\r\n");
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function loads the default EDID to the HDMI RX
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_LoadEdid(XV_HdmiRxSs *InstancePtr, u8 *EdidDataPtr,
+                                                                u16 Length)
+{
+    u32 Status;
+
+    // Load new EDID
+    Status = XV_HdmiRx_DdcLoadEdid(InstancePtr->HdmiRxPtr, EdidDataPtr, Length);
+
+    if (Status == XST_SUCCESS) {
+        xil_printf("\r\nSuccessfully loaded edid.\r\n");
+    }
+    else {
+        xil_printf("\r\nError loading edid.\r\n");
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the HPD on the HDMI RX.
+*
+* @param  Value is a flag used to set the HPD.
+*   - TRUE drives HPD high
+*   - FALSE drives HPD low
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_SetHpd(XV_HdmiRxSs *InstancePtr, u8 Value)
+{
+  /* Drive HPD low */
+  XV_HdmiRx_SetHpd(InstancePtr->HdmiRxPtr, Value);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function toggles the HPD on the HDMI RX.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_ToggleHpd(XV_HdmiRxSs *InstancePtr)
+{
+  /* Drive HPD low */
+  XV_HdmiRx_SetHpd(InstancePtr->HdmiRxPtr, (FALSE));
+
+  /* Wait 500 ms */
+  XV_HdmiRxSs_WaitUs(InstancePtr, 500000);
+
+  /* Drive HPD high */
+  XV_HdmiRx_SetHpd(InstancePtr->HdmiRxPtr, (TRUE));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI RX SS Aux structure
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return XVidC_VideoStream pointer
+*
+* @note   None.
+*
+******************************************************************************/
+XV_HdmiRx_Aux *XV_HdmiRxSs_GetAuxiliary(XV_HdmiRxSs *InstancePtr)
+{
+    return (&InstancePtr->HdmiRxPtr->Aux);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function set HDMI RX susbsystem stream parameters
+*
+* @param  None.
+*
+* @return Calculated TMDS Clock
+*
+* @note   None.
+*
+******************************************************************************/
+u32 XV_HdmiRxSs_SetStream(XV_HdmiRxSs *InstancePtr,
+        u32 Clock, u32 LineRate)
+{
+
+    LineRate = LineRate;
+
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  /* Write log */
+  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_SETSTREAM, 0);
+#endif
+  /* Set stream */
+  XV_HdmiRx_SetStream(InstancePtr->HdmiRxPtr, InstancePtr->Config.Ppc, Clock);
+
+  /* In case the TMDS clock ratio is 1/40 */
+  /* The reference clock must be compensated */
+  if (XV_HdmiRx_GetTmdsClockRatio(InstancePtr->HdmiRxPtr)) {
+      InstancePtr->HdmiRxPtr->Stream.RefClk =
+                   InstancePtr->HdmiRxPtr->Stream.RefClk * 4;
+  }
+
+  return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI RX SS video stream
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return XVidC_VideoStream pointer
+*
+* @note   None.
+*
+******************************************************************************/
+XVidC_VideoStream *XV_HdmiRxSs_GetVideoStream(XV_HdmiRxSs *InstancePtr)
+{
+    return (&InstancePtr->HdmiRxPtr->Stream.Video);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI RX SS video Identification code
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return VIC
+*
+* @note   None.
+*
+******************************************************************************/
+u8 XV_HdmiRxSs_GetVideoIDCode(XV_HdmiRxSs *InstancePtr)
+{
+    return (InstancePtr->HdmiRxPtr->Stream.Vic);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI RX SS video stream type
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return Stream Type  1:HDMI 0:DVI
+*
+* @note   None.
+*
+******************************************************************************/
+u8 XV_HdmiRxSs_GetVideoStreamType(XV_HdmiRxSs *InstancePtr)
+{
+    return (InstancePtr->HdmiRxPtr->Stream.IsHdmi);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the pointer to HDMI RX SS video stream type
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return Stream Type  1:IsScrambled 0: not Scrambled
+*
+* @note   None.
+*
+******************************************************************************/
+u8 XV_HdmiRxSs_GetVideoStreamScramblingFlag(XV_HdmiRxSs *InstancePtr)
+{
+    return (InstancePtr->HdmiRxPtr->Stream.IsScrambled);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns the HDMI RX SS number of active audio channels
+*
+* @param  InstancePtr pointer to XV_HdmiRxSs instance
+*
+* @return Channels
+*
+* @note   None.
+*
+******************************************************************************/
+u8 XV_HdmiRxSs_GetAudioChannels(XV_HdmiRxSs *InstancePtr)
+{
+    return (InstancePtr->AudioChannels);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function is called when HDMI RX SS TMDS clock changes
+*
+* @param  None.
+*
+* @return None
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_RefClockChangeInit(XV_HdmiRxSs *InstancePtr)
+{
+  // Set TMDS Clock ratio
+  InstancePtr->TMDSClockRatio =
+    XV_HdmiRx_GetTmdsClockRatio(InstancePtr->HdmiRxPtr);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE, 0);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI RX SS timing information
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ReportTiming(XV_HdmiRxSs *InstancePtr)
+{
+    // Check is the RX stream is up
+    if (XV_HdmiRx_IsStreamUp(InstancePtr->HdmiRxPtr)) {
+        XV_HdmiRx_DebugInfo(InstancePtr->HdmiRxPtr);
+        xil_printf("VIC: %0d\r\n", InstancePtr->HdmiRxPtr->Stream.Vic);
+        xil_printf("Scrambled: %0d\r\n",
+            (XV_HdmiRx_IsStreamScrambled(InstancePtr->HdmiRxPtr)));
+        xil_printf("Audio channels: %0d\r\n",
+            (XV_HdmiRx_GetAudioChannels(InstancePtr->HdmiRxPtr)));
+    }
+
+    // No stream
+    else {
+      xil_printf("No HDMI RX stream\r\n");
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* This function reports the link quality based on the link error counter
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ReportLinkQuality(XV_HdmiRxSs *InstancePtr)
+{
+  u8 Channel;
+  u32 Errors;
+
+  for (Channel = 0; Channel < 3; Channel++)
+  {
+      Errors = XV_HdmiRx_GetLinkStatus(InstancePtr->HdmiRxPtr, Channel);
+
+      xil_printf("Link quality channel %0d : ", Channel);
+
+      if (Errors == 0) {
+        xil_printf("excellent");
+      }
+
+      else if ((Errors > 0) && (Errors < 1024)) {
+        xil_printf("good");
+      }
+
+      else if ((Errors > 1024) && (Errors < 16384)) {
+        xil_printf("average");
+      }
+
+      else {
+        xil_printf("bad");
+      }
+
+      xil_printf(" (%0d)\r\n", Errors);
+  }
+
+  /* Clear link error counters */
+  XV_HdmiRx_ClearLinkStatus(InstancePtr->HdmiRxPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI RX SS audio information
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ReportAudio(XV_HdmiRxSs *InstancePtr)
+{
+  xil_printf("Channels : %d\r\n",
+  XV_HdmiRx_GetAudioChannels(InstancePtr->HdmiRxPtr));
+  xil_printf("ARC CTS : %d\r\n", XV_HdmiRx_GetAcrCts(InstancePtr->HdmiRxPtr));
+  xil_printf("ARC N   : %d\r\n", XV_HdmiRx_GetAcrN(InstancePtr->HdmiRxPtr));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI RX SS audio information
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ReportInfoFrame(XV_HdmiRxSs *InstancePtr)
+{
+  xil_printf("RX header: %0x\r\n", InstancePtr->HdmiRxPtr->Aux.Header.Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function prints the HDMI RX SS subcore versions
+*
+* @param  None.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_ReportSubcoreVersion(XV_HdmiRxSs *InstancePtr)
+{
+  u32 Data;
+
+  if(InstancePtr->HdmiRxPtr)
+  {
+     Data = XV_HdmiRx_GetVersion(InstancePtr->HdmiRxPtr);
+     xil_printf("  HDMI RX version : %02d.%02d (%04x)\r\n",
+     ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (InstancePtr->Hdcp14Ptr){
+     Data = XHdcp1x_GetVersion(InstancePtr->Hdcp14Ptr);
+     xil_printf("  HDCP 1.4 RX version : %02d.%02d (%04x)\r\n",
+        ((Data >> 24) & 0xFF), ((Data >> 16) & 0xFF), (Data & 0xFFFF));
+  }
+#endif
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function checks if the video stream is up.
+*
+* @param  None.
+*
+* @return
+*   - TRUE if stream is up.
+*   - FALSE if stream is down.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_IsStreamUp(XV_HdmiRxSs *InstancePtr)
+{
+  return (InstancePtr->IsStreamUp);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function checks if the interface is connected.
+*
+* @param  None.
+*
+* @return
+*   - TRUE if interface is connected.
+*   - FALSE if interface is not connected.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_IsStreamConnected(XV_HdmiRxSs *InstancePtr)
+{
+  return (InstancePtr->IsStreamConnected);
+}
+
+/******************************************************************************/
+/**
+*
+* This function configures the Bridge for YUV420 functionality and repeater
+*
+* @param InstancePtr  Instance Pointer to the main data structure
+* @param None
+*
+* @return
+*
+* @note
+*   None.
+*
+******************************************************************************/
+static void XV_HdmiRxSs_ConfigBridgeMode(XV_HdmiRxSs *InstancePtr) {
+
+    XVidC_ColorFormat ColorFormat;
+    XVidC_VideoMode VideoMode;
+
+    XVidC_VideoStream *HdmiRxSsVidStreamPtr;
+    HdmiRxSsVidStreamPtr = XV_HdmiRxSs_GetVideoStream(InstancePtr);
+
+    ColorFormat = HdmiRxSsVidStreamPtr->ColorFormatId;
+    VideoMode = HdmiRxSsVidStreamPtr->VmId;
+
+    if (ColorFormat == XVIDC_CSF_YCRCB_420) {
+        /*********************************************************
+         * 420 Support
+         *********************************************************/
+         XV_HdmiRxSs_BridgePixelDrop(InstancePtr,FALSE);
+         XV_HdmiRxSs_BridgeYuv420(InstancePtr,TRUE);
+    }
+    else {
+        if ((VideoMode == XVIDC_VM_1440x480_60_I) ||
+            (VideoMode == XVIDC_VM_1440x576_50_I) )
+        {
+            /*********************************************************
+             * NTSC/PAL Support
+             *********************************************************/
+             XV_HdmiRxSs_BridgeYuv420(InstancePtr,FALSE);
+             XV_HdmiRxSs_BridgePixelDrop(InstancePtr,TRUE);
+        }
+        else {
+            XV_HdmiRxSs_BridgeYuv420(InstancePtr,FALSE);
+            XV_HdmiRxSs_BridgePixelDrop(InstancePtr,FALSE);
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+* This function will set the default in HDF.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRxSs core instance.
+* @param    Id is the XV_HdmiRxSs ID to operate on.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_SetDefaultPpc(XV_HdmiRxSs *InstancePtr, u8 Id) {
+}
+
+/*****************************************************************************/
+/**
+* This function will set PPC specified by user.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRxSs core instance.
+* @param    Id is the XV_HdmiRxSs ID to operate on.
+* @param    Ppc is the PPC to be set.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_SetPpc(XV_HdmiRxSs *InstancePtr, u8 Id, u8 Ppc) {
+    InstancePtr->Config.Ppc = (XVidC_PixelsPerClock) Ppc;
+    Id = Id; //squash unused variable compiler warning
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.h
new file mode 100644
index 0000000..e3c7fe4
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss.h
@@ -0,0 +1,475 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirxss.h
+*
+* This is main header file of the Xilinx HDMI RX Subsystem driver
+*
+* <b>HDMI RX Subsystem Overview</b>
+*
+* Video Subsystem is a collection of IP cores bounded together by software
+* to provide an abstract view of the processing pipe. It hides all the
+* complexities of programming the underlying cores from end user.
+*
+* <b>Subsystem Driver Features</b>
+*
+* Video Subsystem supports following features
+*   - AXI Stream Input/Output interface
+*   - 1, 2 or 4 pixel-wide video interface
+*   - 8/10/12/16 bits per component
+*   - RGB & YCbCr color space
+*   - Up to 4k2k 60Hz resolution at both Input and Output interface
+*   - Interlaced input support (1080i 50Hz/60Hz)
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     20/01/16 Added remapper support
+* 1.2   yh     01/02/16 Added set_ppc api
+* 1.3   MG     03/02/16 Added HDCP support
+* 1.4   MH     03/15/16 Added HDCP connect event.
+*                       Added HDCP authenticated callback support.
+* 1.5   YH     17/03/16 Remove xintc.h as it is processor dependent
+* 1.6   MH     23/06/16 Added HDCP repeater support.
+* 1.7   YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
+* 1.8   MH     26/07/16 Updates for automatic protocol switching
+* 1.9   MH     05/08/16 Updates to optimize out HDCP when excluded
+* 1.10  YH     18/08/16 Combine Report function into one ReportInfo
+* 1.11  YH     14/11/16 Added API to enable/disable YUV420/Pixel Drop Mode
+*                       for video bridge
+* 1.15  YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.16  MMO    03/01/17 Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable
+*                         Log
+*						Re-order the enumaration and data structure
+*                       Move HDCP local API into _hdcp.h
+* </pre>
+*
+******************************************************************************/
+
+#ifndef HDMIRXSS_H /**< prevent circular inclusions by using protection macros*/
+#define HDMIRXSS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "xstatus.h"
+#include "xv_hdmirx.h"
+#if !defined(XV_CONFIG_LOG_VHDMIRXSS_DISABLE) && \
+                                             !defined(XV_CONFIG_LOG_DISABLE_ALL)
+#define XV_HDMIRXSS_LOG_ENABLE
+#endif
+
+#if defined(XPAR_XHDCP_NUM_INSTANCES) || defined(XPAR_XHDCP22_RX_NUM_INSTANCES)
+#define USE_HDCP_RX
+#define XV_HDMIRXSS_HDCP_KEYSEL 0x00u
+#define XV_HDMIRXSS_HDCP_MAX_QUEUE_SIZE 16
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+#include "xtmrctr.h"
+//#include "xhdcp1x.h"
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+//#include "xhdcp22_rx.h"
+#endif
+/****************************** Type Definitions ******************************/
+/** @name Handler Types
+* @{
+*/
+
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+typedef enum {
+	XV_HDMIRXSS_LOG_EVT_NONE = 1,		/**< Log event none. */
+	XV_HDMIRXSS_LOG_EVT_HDMIRX_INIT,	/**< Log event HDMIRX Init. */
+	XV_HDMIRXSS_LOG_EVT_VTC_INIT,	    /**< Log event VTC Init. */
+	XV_HDMIRXSS_LOG_EVT_HDCPTIMER_INIT,	/**< Log event HDCP Timer Init */
+	XV_HDMIRXSS_LOG_EVT_HDCP14_INIT,	/**< Log event HDCP 14 Init. */
+	XV_HDMIRXSS_LOG_EVT_HDCP22_INIT,	/**< Log event HDCP 22 Init. */
+	XV_HDMIRXSS_LOG_EVT_START,	        /**< Log event HDMIRXSS Start. */
+	XV_HDMIRXSS_LOG_EVT_STOP,	        /**< Log event HDMIRXSS Stop. */
+	XV_HDMIRXSS_LOG_EVT_RESET,	        /**< Log event HDMIRXSS Reset. */
+	XV_HDMIRXSS_LOG_EVT_CONNECT,        /**< Log event Cable connect. */
+	XV_HDMIRXSS_LOG_EVT_DISCONNECT,	    /**< Log event Cable disconnect. */
+	XV_HDMIRXSS_LOG_EVT_LINKSTATUS,     /**< Log event Link Status Error. */
+	XV_HDMIRXSS_LOG_EVT_STREAMUP,	    /**< Log event Stream Up. */
+	XV_HDMIRXSS_LOG_EVT_STREAMDOWN,	    /**< Log event Stream Down. */
+	XV_HDMIRXSS_LOG_EVT_STREAMINIT,	    /**< Log event Stream Init. */
+	XV_HDMIRXSS_LOG_EVT_SETSTREAM,      /**< Log event HDMIRXSS Setstream. */
+	XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE, /**< Log event TMDS Ref clock change. */
+	XV_HDMIRXSS_LOG_EVT_HDCP14,             /**< Log event Enable HDCP 1.4. */
+	XV_HDMIRXSS_LOG_EVT_HDCP22,             /**< Log event Enable HDCP 2.2. */
+	XV_HDMIRXSS_LOG_EVT_HDMIMODE,           /**< Log event HDMI Mode change. */
+	XV_HDMIRXSS_LOG_EVT_DVIMODE,            /**< Log event HDMI Mode change. */
+	XV_HDMIRXSS_LOG_EVT_SYNCLOSS,           /**< Log event Sync Loss detected. */
+	XV_HDMIRXSS_LOG_EVT_DUMMY               /**< Dummy Event should be last */
+} XV_HdmiRxSs_LogEvent;
+
+/**
+ * This typedef contains the logging mechanism for debug.
+ */
+typedef struct {
+	u16 DataBuffer[256];		/**< Log buffer with event data. */
+	u8 HeadIndex;			/**< Index of the head entry of the
+						Event/DataBuffer. */
+	u8 TailIndex;			/**< Index of the tail entry of the
+						Event/DataBuffer. */
+} XV_HdmiRxSs_Log;
+#endif
+
+#ifdef USE_HDCP_RX
+/**
+* These constants are used to identify fields inside the topology structure
+*/
+typedef enum {
+  XV_HDMIRXSS_HDCP_TOPOLOGY_DEPTH,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_DEVICECNT,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_MAXDEVSEXCEEDED,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_MAXCASCADEEXCEEDED,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_HDCP20REPEATERDOWNSTREAM,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_HDCP1DEVICEDOWNSTREAM,
+  XV_HDMIRXSS_HDCP_TOPOLOGY_INVALID
+} XV_HdmiRxSs_HdcpTopologyField;
+
+/**
+* These constants specify the HDCP Events
+*/
+typedef enum
+{
+  XV_HDMIRXSS_HDCP_NO_EVT,
+  XV_HDMIRXSS_HDCP_STREAMUP_EVT,
+  XV_HDMIRXSS_HDCP_STREAMDOWN_EVT,
+  XV_HDMIRXSS_HDCP_CONNECT_EVT,
+  XV_HDMIRXSS_HDCP_DISCONNECT_EVT,
+  XV_HDMIRXSS_HDCP_1_PROT_EVT,
+  XV_HDMIRXSS_HDCP_2_PROT_EVT,
+  XV_HDMIRXSS_HDCP_DVI_MODE_EVT,
+  XV_HDMIRXSS_HDCP_HDMI_MODE_EVT,
+  XV_HDMIRXSS_HDCP_SYNC_LOSS_EVT,
+  XV_HDMIRXSS_HDCP_INVALID_EVT
+} XV_HdmiRxSs_HdcpEvent;
+
+/**
+* These constants specify the HDCP key types
+*/
+typedef enum
+{
+  XV_HDMIRXSS_KEY_HDCP22_LC128,     /**< HDCP 2.2 LC128 */
+  XV_HDMIRXSS_KEY_HDCP22_PRIVATE,   /**< HDCP 2.2 Private */
+  XV_HDMIRXSS_KEY_HDCP14,           /**< HDCP 1.4 Key */
+} XV_HdmiRxSs_HdcpKeyType;
+
+/**
+* These constants specify HDCP repeater content stream management type
+*/
+typedef enum
+{
+  XV_HDMIRXSS_HDCP_STREAMTYPE_0, /**< HDCP Stream Type 0 */
+  XV_HDMIRXSS_HDCP_STREAMTYPE_1  /**< HDCP Stream Type 1 */
+} XV_HdmiRxSs_HdcpContentStreamType;
+
+typedef struct
+{
+  XV_HdmiRxSs_HdcpEvent Queue[XV_HDMIRXSS_HDCP_MAX_QUEUE_SIZE]; /**< Data */
+  u8                    Tail;      /**< Tail pointer */
+  u8                    Head;      /**< Head pointer */
+} XV_HdmiRxSs_HdcpEventQueue;
+#endif
+
+/**
+* These constants specify the HDCP protection schemes
+*/
+typedef enum
+{
+  XV_HDMIRXSS_HDCP_NONE,       /**< No content protection */
+  XV_HDMIRXSS_HDCP_14,         /**< HDCP 1.4 */
+  XV_HDMIRXSS_HDCP_22          /**< HDCP 2.2 */
+} XV_HdmiRxSs_HdcpProtocol;
+
+/**
+* These constants specify different types of handler and used to differentiate
+* interrupt requests from peripheral.
+*/
+typedef enum {
+  XV_HDMIRXSS_HANDLER_CONNECT = 1,                  /**< Handler for connect
+                                                         event */
+  XV_HDMIRXSS_HANDLER_AUX,                          /**< Handler for AUX
+                                                         peripheral event */
+  XV_HDMIRXSS_HANDLER_AUD,                          /**< Handler for AUD
+                                                         peripheral event */
+  XV_HDMIRXSS_HANDLER_LNKSTA,                       /**< Handler for LNKSTA
+                                                         peripheral event */
+  XV_HDMIRXSS_HANDLER_DDC,                          /**< Handler for DDC
+                                                         peripheral event */
+  XV_HDMIRXSS_HANDLER_STREAM_DOWN,                  /**< Handler for stream
+                                                         down event */
+  XV_HDMIRXSS_HANDLER_STREAM_INIT,                  /**< Handler for stream
+                                                         init event */
+  XV_HDMIRXSS_HANDLER_STREAM_UP,                    /**< Handler for stream up
+                                                         event */
+  XV_HDMIRXSS_HANDLER_HDCP,                         /**< Handler for HDCP 1.4
+                                                         event */
+  XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED,           /**< Handler for HDCP
+                                                         authenticated event */
+  XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED,         /**< Handler for HDCP
+                                                         unauthenticated event*/
+  XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST,  /**< Handler for HDCP
+                                                         authentication request
+														 event */
+  XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST,   /**< Handler for HDCP stream
+                                                         manage request event */
+  XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE,         /**< Handler for HDCP
+                                                         topology update event*/
+  XV_HDMIRXSS_HANDLER_HDCP_ENCRYPTION_UPDATE        /**< Handler for HDCP
+                                                         encryption status
+														 update event */
+} XV_HdmiRxSs_HandlerType;
+/*@}*/
+
+/**
+ * Sub-Core Configuration Table
+ */
+typedef struct
+{
+  u16 IsPresent;  /**< Flag to indicate if sub-core is present in the design*/
+  u16 DeviceId;   /**< Device ID of the sub-core */
+  UINTPTR AbsAddr; /**< Absolute Base Address of hte Sub-cores*/
+}XV_HdmiRxSs_SubCore;
+
+/**
+ * Video Processing Subsystem configuration structure.
+ * Each subsystem device should have a configuration structure associated
+ * that defines the MAX supported sub-cores within subsystem
+ */
+
+typedef struct
+{
+  u16 DeviceId;     /**< DeviceId is the unique ID  of the device */
+  UINTPTR BaseAddress;  /**< BaseAddress is the physical base address of the
+                        subsystem address range */
+  UINTPTR HighAddress;  /**< HighAddress is the physical MAX address of the
+                        subsystem address range */
+  XVidC_PixelsPerClock Ppc;         /**< Supported Pixel per Clock */
+  u8 MaxBitsPerPixel;               /**< Maximum  Supported Color Depth */
+  XV_HdmiRxSs_SubCore HdcpTimer;    /**< Sub-core instance configuration */
+  XV_HdmiRxSs_SubCore Hdcp14;       /**< Sub-core instance configuration */
+  XV_HdmiRxSs_SubCore Hdcp22;       /**< Sub-core instance configuration */
+  XV_HdmiRxSs_SubCore HdmiRx;       /**< Sub-core instance configuration */
+} XV_HdmiRxSs_Config;
+
+/**
+* Callback type for interrupt.
+*
+* @param  CallbackRef is a callback reference passed in by the upper
+*   layer when setting the callback functions, and passed back to
+*   the upper layer when the callback is invoked.
+*
+* @return None.
+*
+* @note   None.
+*
+*/
+typedef void (*XV_HdmiRxSs_Callback)(void *CallbackRef);
+
+/**
+* The XVprocss driver instance data. The user is required to allocate a variable
+* of this type for every XVprocss device in the system. A pointer to a variable
+* of this type is then passed to the driver API functions.
+*/
+typedef struct
+{
+  XV_HdmiRxSs_Config Config;    /**< Hardware configuration */
+  u32 IsReady;                  /**< Device and the driver instance are
+                                     initialized */
+
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+  XV_HdmiRxSs_Log Log;				/**< A log of events. */
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  XTmrCtr *HdcpTimerPtr;           /**< handle to sub-core driver instance */
+  XHdcp1x *Hdcp14Ptr;                /**< handle to sub-core driver instance */
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  XHdcp22_Rx  *Hdcp22Ptr;           /**< handle to sub-core driver instance */
+#endif
+  XV_HdmiRx *HdmiRxPtr;             /**< handle to sub-core driver instance */
+
+  /*Callbacks */
+  XV_HdmiRxSs_Callback ConnectCallback; /**< Callback for connect event */
+  void *ConnectRef;     /**< To be passed to the connect callback */
+
+  XV_HdmiRxSs_Callback AuxCallback;     /**< Callback for AUX event */
+  void *AuxRef;         /**< To be passed to the AUX callback */
+
+  XV_HdmiRxSs_Callback AudCallback;     /**< Callback for AUD event */
+  void *AudRef;         /**< To be passed to the AUD callback */
+
+  XV_HdmiRxSs_Callback LnkStaCallback;  /**< Callback for LNKSTA event */
+  void *LnkStaRef;      /**< To be passed to the LNKSTA callback */
+
+  XV_HdmiRxSs_Callback DdcCallback;     /**< Callback for PDDC event */
+  void *DdcRef;         /**< To be passed to the DDC callback */
+
+  XV_HdmiRxSs_Callback StreamDownCallback;/**< Callback for stream down event */
+  void *StreamDownRef;  /**< To be passed to the stream down callback */
+
+  XV_HdmiRxSs_Callback StreamInitCallback;/**< Callback for stream init event */
+  void *StreamInitRef;  /**< To be passed to the stream init callback */
+
+  XV_HdmiRxSs_Callback StreamUpCallback; /**< Callback for stream up event */
+  void *StreamUpRef;    /**< To be passed to the stream up callback */
+
+  XV_HdmiRxSs_Callback HdcpCallback;    /**< Callback for HDCP 1.4 event */
+  void *HdcpRef;        /**< To be passed to the hdcp callback */
+
+  // Scratch pad
+  u8 IsStreamConnected;         /**< HDMI RX Stream Connected */
+  u8 IsStreamUp;                /**< HDMI RX Stream Up */
+  u8 AudioChannels;             /**< Number of Audio Channels */
+  int IsLinkStatusErrMax;       /**< Link Error Status Maxed */
+  u8 *EdidPtr;                     /**< Default Edid Pointer */
+  u16 EdidLength;               /**< Default Edid Length */
+  u8 TMDSClockRatio;            /**< HDMI RX TMDS clock ratio */
+
+  XVidC_DelayHandler UserTimerWaitUs; /**< Custom user function for
+                                           delay/sleep. */
+  void *UserTimerPtr;                 /**< Pointer to a timer instance
+                                           used by the custom user
+                                           delay/sleep function. */
+
+  XV_HdmiRxSs_HdcpProtocol      HdcpProtocol;        /**< HDCP protect scheme */
+#ifdef USE_HDCP_RX
+  /**< HDCP specific */
+  u32                           HdcpIsReady;    /**< HDCP ready flag */
+  XV_HdmiRxSs_HdcpEventQueue    HdcpEventQueue;         /**< HDCP event queue */
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  u8                            *Hdcp22Lc128Ptr;     /**< Pointer to HDCP 2.2
+                                                         LC128 */
+  u8                            *Hdcp22PrivateKeyPtr;   /**< Pointer to HDCP 2.2
+                                                             Private key */
+#endif
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  u8                            *Hdcp14KeyPtr;   /**< Pointer to HDCP 1.4 key */
+#endif
+} XV_HdmiRxSs;
+
+/************************** Macros Definitions *******************************/
+#ifdef USE_HDCP_RX
+#define XV_HdmiRxSs_HdcpIsReady(InstancePtr) \
+  (InstancePtr)->HdcpIsReady
+#endif
+/************************** Function Prototypes ******************************/
+XV_HdmiRxSs_Config* XV_HdmiRxSs_LookupConfig(u32 DeviceId);
+void XV_HdmiRxSs_SetUserTimerHandler(XV_HdmiRxSs *InstancePtr,
+        XVidC_DelayHandler CallbackFunc, void *CallbackRef);
+void XV_HdmiRxSS_HdmiRxIntrHandler(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_CfgInitialize(XV_HdmiRxSs *InstancePtr,
+    XV_HdmiRxSs_Config *CfgPtr,
+    UINTPTR EffectiveAddr);
+void XV_HdmiRxSs_Start(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_Stop(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_Reset(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_SetCallback(XV_HdmiRxSs *InstancePtr,
+    u32 HandlerType,
+    void *CallbackFunc,
+    void *CallbackRef);
+void XV_HdmiRxSs_SetEdidParam(XV_HdmiRxSs *InstancePtr, u8 *EdidDataPtr,
+                                                                u16 Length);
+void XV_HdmiRxSs_LoadDefaultEdid(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_LoadEdid(XV_HdmiRxSs *InstancePtr, u8 *EdidDataPtr,
+                                                                u16 Length);
+void XV_HdmiRxSs_SetHpd(XV_HdmiRxSs *InstancePtr, u8 Value);
+void XV_HdmiRxSs_ToggleHpd(XV_HdmiRxSs *InstancePtr);
+XV_HdmiRx_Aux *XV_HdmiRxSs_GetAuxiliary(XV_HdmiRxSs *InstancePtr);
+u32 XV_HdmiRxSs_SetStream(XV_HdmiRxSs *InstancePtr,
+    u32 Clock,
+    u32 LineRate);
+XVidC_VideoStream *XV_HdmiRxSs_GetVideoStream(XV_HdmiRxSs *InstancePtr);
+u8 XV_HdmiRxSs_GetVideoIDCode(XV_HdmiRxSs *InstancePtr);
+u8 XV_HdmiRxSs_GetVideoStreamType(XV_HdmiRxSs *InstancePtr);
+u8 XV_HdmiRxSs_GetVideoStreamScramblingFlag(XV_HdmiRxSs *InstancePtr);
+u8 XV_HdmiRxSs_GetAudioChannels(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_RefClockChangeInit(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_ReportInfo(XV_HdmiRxSs *InstancePtr);
+int  XV_HdmiRxSs_IsStreamUp(XV_HdmiRxSs *InstancePtr);
+int  XV_HdmiRxSs_IsStreamConnected(XV_HdmiRxSs *InstancePtr);
+
+void XV_HdmiRxSs_SetDefaultPpc(XV_HdmiRxSs *InstancePtr, u8 Id);
+void XV_HdmiRxSs_SetPpc(XV_HdmiRxSs *InstancePtr, u8 Id, u8 Ppc);
+
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+void XV_HdmiRxSs_LogReset(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_LogWrite(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_LogEvent Evt, u8 Data);
+u16 XV_HdmiRxSs_LogRead(XV_HdmiRxSs *InstancePtr);
+#endif
+void XV_HdmiRxSs_LogDisplay(XV_HdmiRxSs *InstancePtr);
+
+#ifdef USE_HDCP_RX
+void XV_HdmiRxSs_HdcpSetKey(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpKeyType KeyType, u8 *KeyPtr);
+int XV_HdmiRxSs_HdcpEnable(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpDisable(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpClearEvents(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpPushEvent(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpEvent Event);
+int XV_HdmiRxSs_HdcpPoll(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpSetProtocol(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpProtocol Protocol);
+XV_HdmiRxSs_HdcpProtocol XV_HdmiRxSs_HdcpGetProtocol(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsEnabled(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsAuthenticated(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsEncrypted(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsInProgress(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_HdcpInfo(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSs_HdcpSetInfoDetail(XV_HdmiRxSs *InstancePtr, u8 Verbose);
+int XV_HdmiRxSs_HdcpSetTopology(XV_HdmiRxSs *InstancePtr, void *TopologyPtr);
+int XV_HdmiRxSs_HdcpSetTopologyReceiverIdList(XV_HdmiRxSs *InstancePtr, u8 *ListPtr, u32 ListSize);
+int XV_HdmiRxSs_HdcpSetTopologyField(XV_HdmiRxSs *InstancePtr,
+      XV_HdmiRxSs_HdcpTopologyField Field, u32 Value);
+int XV_HdmiRxSs_HdcpSetRepeater(XV_HdmiRxSs *InstancePtr, u8 Set);
+int XV_HdmiRxSs_HdcpSetTopologyUpdate(XV_HdmiRxSs *InstancePtr);
+XV_HdmiRxSs_HdcpContentStreamType XV_HdmiRxSs_HdcpGetContentStreamType(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsRepeater(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsInWaitforready(XV_HdmiRxSs *InstancePtr);
+int XV_HdmiRxSs_HdcpIsInComputations(XV_HdmiRxSs *InstancePtr);
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+int XV_HdmiRxSs_HdcpTimerStart(void *InstancePtr, u16 TimeoutInMs);
+int XV_HdmiRxSs_HdcpTimerStop(void *InstancePtr);
+int XV_HdmiRxSs_HdcpTimerBusyDelay(void *InstancePtr, u16 DelayInMs);
+void XV_HdmiRxSS_HdcpIntrHandler(XV_HdmiRxSs *InstancePtr);
+void XV_HdmiRxSS_HdcpTimerIntrHandler(XV_HdmiRxSs *InstancePtr);
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+void XV_HdmiRxSS_Hdcp22TimerIntrHandler(XV_HdmiRxSs *InstancePtr);
+#endif
+
+#endif // USE_HDCP_RX
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.c
new file mode 100644
index 0000000..0f1ee1e
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.c
@@ -0,0 +1,670 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirxss_coreinit.c
+* @addtogroup v_hdmirxss
+* @{
+* @details
+
+* HDMI RX Subsystem Sub-Cores initialization
+* The functions in this file provides an abstraction from the initialization
+* sequence for included sub-cores. Subsystem is assigned an address and range
+* on the axi-lite interface. This address space is condensed where-in each
+* sub-core is at a fixed offset from the subsystem base address. For processor
+* to be able to access the sub-core this offset needs to be transalted into a
+* absolute address within the subsystems addressable range
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     20/01/16 Added remapper support
+* 1.2   MG     20/01/16 Added HDCP support
+* 1.3   MH     08/03/16 Added DDC read message not complete event to
+*                       the function XV_HdmiRxSs_DdcHdcpCallback.
+*                       Updated XV_HdmiRxSs_LinkErrorCallback
+*                       function to set link error flag.
+* 1.4   MH     23/04/16 Remove XV_HdmiRxSs_Reset from
+*                       function XV_HdmiRxSs_SubcoreInitHdmiRx
+* 1.5   MH     15/07/16 Added HDCP repeater support.
+* 1.6   YH     18/07/16 Replace xil_print with xdbg_printf.
+* 1.7   YH     25/07/16 Used UINTPTR instead of u32 for BaseAddr,HighAddr,Offset
+*                       AbsAddr
+* 1.8   MH     08/08/16 Updates to optimize out HDCP when excluded.
+* 1.9   YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.10  MMO    03/01/17 Remove XV_HdmiRxSs_ComputeSubcoreAbsAddr API, as it
+*                       handles in the "_g" TCL generation
+*                       Move XV_HdmiRx_DdcLoadEdid to xv_hdmirxss.h and call it
+*                       in user application
+*                       Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable Log
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include "xv_hdmirxss_coreinit.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+#ifdef USE_HDCP_RX
+static void XV_HdmiRxSs_DdcSetRegAddrHandler(void *RefPtr, u32 Data);
+static void XV_HdmiRxSs_DdcSetRegDataHandler(void *RefPtr, u32 Data);
+static u32 XV_HdmiRxSs_DdcGetRegDataHandler(void *RefPtr);
+static void XV_HdmiRxSs_DdcHdcpCallback(void *RefPtr, int Type);
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+static u32 XV_HdmiRxSs_DdcGetWriteMessageBufferWordsHandler(void *RefPtr);
+static u32 XV_HdmiRxSs_DdcGetReadMessageBufferWordsHandler(void *RefPtr);
+static u32 XV_HdmiRxSs_DdcIsReadMessageBufferEmptyHandler(void *RefPtr);
+static u32 XV_HdmiRxSs_DdcIsWriteMessageBufferEmptyHandler(void *RefPtr);
+static void XV_HdmiRxSs_DdcClearReadMessageBufferHandler(void *RefPtr);
+static void XV_HdmiRxSs_DdcClearWriteMessageBufferHandler(void *RefPtr);
+static void XV_HdmiRxSs_LinkErrorCallback(void *RefPtr);
+#endif
+
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiRxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiRxSs_SubcoreInitHdmiRx(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+  int Status;
+  XV_HdmiRx_Config *ConfigPtr;
+
+  if(HdmiRxSsPtr->HdmiRxPtr)
+  {
+    /* Get core configuration */
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDMIRX_INIT, 0);
+#endif
+    ConfigPtr  = XV_HdmiRx_LookupConfig(HdmiRxSsPtr->Config.HdmiRx.DeviceId);
+    if(ConfigPtr == NULL)
+    {
+      xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDMI RX device not found\r\n");
+      return(XST_FAILURE);
+    }
+
+    /* Initialize core */
+    Status = XV_HdmiRx_CfgInitialize(HdmiRxSsPtr->HdmiRxPtr,
+                                    ConfigPtr,
+                                    HdmiRxSsPtr->Config.HdmiRx.AbsAddr);
+
+    if (Status != XST_SUCCESS)
+    {
+      xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDMI RX Initialization failed\r\n");
+      return(XST_FAILURE);
+    }
+
+    // Load EDID
+    XV_HdmiRx_DdcLoadEdid(HdmiRxSsPtr->HdmiRxPtr, HdmiRxSsPtr->EdidPtr,
+        HdmiRxSsPtr->EdidLength);
+
+  }
+  return(XST_SUCCESS);
+}
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiRxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiRxSs_SubcoreInitHdcpTimer(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+  int Status;
+  XTmrCtr_Config *ConfigPtr;
+
+  if(HdmiRxSsPtr->HdcpTimerPtr)
+  {
+    /* Get core configuration */
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDCPTIMER_INIT, 0);
+#endif
+    ConfigPtr  = XTmrCtr_LookupConfig(HdmiRxSsPtr->Config.HdcpTimer.DeviceId);
+    if(ConfigPtr == NULL)
+    {
+      xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: AXIS Timer device not found\r\n");
+      return(XST_FAILURE);
+    }
+
+    /* Setup the instance */
+    memset(HdmiRxSsPtr->HdcpTimerPtr, 0, sizeof(XTmrCtr));
+
+    /* Initialize core */
+    XTmrCtr_CfgInitialize(HdmiRxSsPtr->HdcpTimerPtr,
+                          ConfigPtr,
+                          HdmiRxSsPtr->Config.HdcpTimer.AbsAddr);
+
+
+    Status = XTmrCtr_InitHw(HdmiRxSsPtr->HdcpTimerPtr);
+
+    /* Set Timer Counter instance in HDCP to the generic Hdcp1xRef
+       that will be used in callbacks */
+    HdmiRxSsPtr->Hdcp14Ptr->Hdcp1xRef = (void *)HdmiRxSsPtr->HdcpTimerPtr;
+
+    /* Initialize the hdcp timer functions */
+    XHdcp1x_SetTimerStart(HdmiRxSsPtr->Hdcp14Ptr,
+      &XV_HdmiRxSs_HdcpTimerStart);
+    XHdcp1x_SetTimerStop(HdmiRxSsPtr->Hdcp14Ptr,
+      &XV_HdmiRxSs_HdcpTimerStop);
+    XHdcp1x_SetTimerDelay(HdmiRxSsPtr->Hdcp14Ptr,
+      &XV_HdmiRxSs_HdcpTimerBusyDelay);
+
+    if(Status != XST_SUCCESS)
+    {
+      xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: AXI Timer Initialization failed\r\n");
+      return(XST_FAILURE);
+    }
+  }
+  return(XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiRxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiRxSs_SubcoreInitHdcp14(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+  int Status;
+  XHdcp1x_Config *ConfigPtr;
+
+  /* Is the HDCP 1.4 RX present? */
+  if (HdmiRxSsPtr->Hdcp14Ptr) {
+
+    /* Is the key loaded? */
+    if (HdmiRxSsPtr->Hdcp14KeyPtr) {
+
+      /* Get core configuration */
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+      XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDCP14_INIT, 0);
+#endif
+      ConfigPtr  = XHdcp1x_LookupConfig(HdmiRxSsPtr->Config.Hdcp14.DeviceId);
+      if(ConfigPtr == NULL)
+      {
+        xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDCP 1.4 device not found\r\n");
+        return(XST_FAILURE);
+      }
+
+      /* Initialize core */
+      void *PhyIfPtr = HdmiRxSsPtr->HdmiRxPtr;
+      Status = XHdcp1x_CfgInitialize(HdmiRxSsPtr->Hdcp14Ptr,
+                                        ConfigPtr,
+                                        PhyIfPtr,
+                                        HdmiRxSsPtr->Config.Hdcp14.AbsAddr);
+
+      /* Self-test the hdcp interface */
+      if (XHdcp1x_SelfTest(HdmiRxSsPtr->Hdcp14Ptr) != XST_SUCCESS) {
+          Status = XST_FAILURE;
+      }
+
+      if(Status != XST_SUCCESS)
+      {
+        xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDCP 1.4 Initialization failed\r\n");
+        return(XST_FAILURE);
+      }
+
+      /* Set-up the DDC Handlers */
+      XHdcp1x_SetCallback(HdmiRxSsPtr->Hdcp14Ptr,
+                          XHDCP1X_HANDLER_DDC_SETREGADDR,
+						  (void *)(XHdcp1x_SetDdcHandler)XV_HdmiRxSs_DdcSetRegAddrHandler,
+						  (void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp1x_SetCallback(HdmiRxSsPtr->Hdcp14Ptr,
+                          XHDCP1X_HANDLER_DDC_SETREGDATA,
+						  (void *)(XHdcp1x_SetDdcHandler)XV_HdmiRxSs_DdcSetRegDataHandler,
+						  (void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp1x_SetCallback(HdmiRxSsPtr->Hdcp14Ptr,
+                          XHDCP1X_HANDLER_DDC_GETREGDATA,
+						  (void *)(XHdcp1x_GetDdcHandler)XV_HdmiRxSs_DdcGetRegDataHandler,
+						  (void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Select key */
+      XHdcp1x_SetKeySelect(HdmiRxSsPtr->Hdcp14Ptr, XV_HDMIRXSS_HDCP_KEYSEL);
+
+      /* Disable HDCP 1.4 repeater */
+      HdmiRxSsPtr->Hdcp14Ptr->IsRepeater = 0;
+
+      /* Set-up the HDMI RX HDCP Callback Handler */
+      XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                XV_HDMIRX_HANDLER_HDCP,
+				(void *)XV_HdmiRxSs_DdcHdcpCallback,
+                (void *)HdmiRxSsPtr);
+
+      /* Enable HDMI-RX DDC interrupts */
+      XV_HdmiRx_DdcIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Enable HDMI-RX HDCP */
+      XV_HdmiRx_DdcHdcpEnable(HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Clear the HDCP KSV Fifo */
+      XV_HdmiRx_DdcHdcpClearReadMessageBuffer(HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Clear the event queue */
+      XV_HdmiRxSs_HdcpClearEvents(HdmiRxSsPtr);
+    }
+  }
+  return(XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function initializes the included sub-core to it's static configuration
+*
+* @param  HdmiRxSsPtr is a pointer to the Subsystem instance to be worked on.
+*
+* @return XST_SUCCESS/XST_FAILURE
+*
+******************************************************************************/
+int XV_HdmiRxSs_SubcoreInitHdcp22(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+  int Status;
+  XHdcp22_Rx_Config *ConfigPtr;
+
+  /* Is the HDCP 2.2 RX present? */
+  if (HdmiRxSsPtr->Hdcp22Ptr) {
+
+    /* Are the keys loaded? */
+    if (HdmiRxSsPtr->Hdcp22Lc128Ptr && HdmiRxSsPtr->Hdcp22PrivateKeyPtr) {
+
+      /* Get core configuration */
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+      XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDCP22_INIT, 0);
+#endif
+      ConfigPtr  = XHdcp22Rx_LookupConfig(HdmiRxSsPtr->Config.Hdcp22.DeviceId);
+      if(ConfigPtr == NULL)
+      {
+        xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDCP 2.2 device not found\r\n");
+        return (XST_FAILURE);
+      }
+
+      /* Initialize core */
+      Status = XHdcp22Rx_CfgInitialize(HdmiRxSsPtr->Hdcp22Ptr,
+                                       ConfigPtr,
+                                       HdmiRxSsPtr->Config.Hdcp22.AbsAddr);
+      if (Status != XST_SUCCESS)
+      {
+        xdbg_printf(XDBG_DEBUG_GENERAL,"HDMIRXSS ERR:: HDCP 2.2 Initialization failed\r\n");
+        return(XST_FAILURE);
+      }
+
+      /* Set-up the DDC Handlers */
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_SETREGADDR,
+							(void *)(XHdcp22_Rx_SetHandler)XV_HdmiRxSs_DdcSetRegAddrHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_SETREGDATA,
+							(void *)(XHdcp22_Rx_SetHandler)XV_HdmiRxSs_DdcSetRegDataHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_GETREGDATA,
+							(void *)(XHdcp22_Rx_GetHandler)XV_HdmiRxSs_DdcGetRegDataHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_GETWBUFSIZE,
+							(void *)(XHdcp22_Rx_GetHandler)XV_HdmiRxSs_DdcGetWriteMessageBufferWordsHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_GETRBUFSIZE,
+							(void *)(XHdcp22_Rx_GetHandler)XV_HdmiRxSs_DdcGetReadMessageBufferWordsHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_ISWBUFEMPTY,
+							(void *)(XHdcp22_Rx_GetHandler)XV_HdmiRxSs_DdcIsWriteMessageBufferEmptyHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_ISRBUFEMPTY,
+							(void *)(XHdcp22_Rx_GetHandler)XV_HdmiRxSs_DdcIsReadMessageBufferEmptyHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_CLEARRBUF,
+							(void *)(XHdcp22_Rx_RunHandler)XV_HdmiRxSs_DdcClearReadMessageBufferHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+      XHdcp22Rx_SetCallback(HdmiRxSsPtr->Hdcp22Ptr,
+                            XHDCP22_RX_HANDLER_DDC_CLEARWBUF,
+							(void *)(XHdcp22_Rx_RunHandler)XV_HdmiRxSs_DdcClearWriteMessageBufferHandler,
+							(void *)HdmiRxSsPtr->HdmiRxPtr);
+
+
+      /* Set-up the HDMI RX HDCP Callback Handler */
+      XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                XV_HDMIRX_HANDLER_HDCP,
+				(void *)XV_HdmiRxSs_DdcHdcpCallback,
+                (void *)HdmiRxSsPtr);
+
+      /* Set-up the HDMI RX Link error Callback Handler */
+      XV_HdmiRx_SetCallback(HdmiRxSsPtr->HdmiRxPtr,
+                XV_HDMIRX_HANDLER_LINK_ERROR,
+				(void *)XV_HdmiRxSs_LinkErrorCallback,
+                (void *)HdmiRxSsPtr);
+
+      /* Load Production Keys */
+      XHdcp22Rx_LoadLc128(HdmiRxSsPtr->Hdcp22Ptr, HdmiRxSsPtr->Hdcp22Lc128Ptr);
+      XHdcp22Rx_LoadPublicCert(HdmiRxSsPtr->Hdcp22Ptr, HdmiRxSsPtr->Hdcp22PrivateKeyPtr+40);
+      XHdcp22Rx_LoadPrivateKey(HdmiRxSsPtr->Hdcp22Ptr, HdmiRxSsPtr->Hdcp22PrivateKeyPtr+562);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+      XHdcp22Rx_LogReset(HdmiRxSsPtr->Hdcp22Ptr, FALSE);
+#endif
+      /* Enable HDMI-RX DDC interrupts */
+      XV_HdmiRx_DdcIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Enable HDMI-RX HDCP */
+      XV_HdmiRx_DdcHdcpEnable(HdmiRxSsPtr->HdmiRxPtr);
+
+      /* Clear the event queue */
+      XV_HdmiRxSs_HdcpClearEvents(HdmiRxSsPtr);
+    }
+  }
+
+  return (XST_SUCCESS);
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC set register address handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @param Data is the address to be written.
+ *
+ * @return None.
+ *
+ ******************************************************************************/
+static void XV_HdmiRxSs_DdcSetRegAddrHandler(void *RefPtr, u32 Data)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  XV_HdmiRx_DdcHdcpSetAddress(InstancePtr, Data);
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC set register data handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @param Data is the data to be written.
+ *
+ * @return None.
+ *
+ ******************************************************************************/
+static void XV_HdmiRxSs_DdcSetRegDataHandler(void *RefPtr, u32 Data)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  XV_HdmiRx_DdcHdcpWriteData(InstancePtr, Data);
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC get register data handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return The read data.
+ *
+ ******************************************************************************/
+static u32 XV_HdmiRxSs_DdcGetRegDataHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  return XV_HdmiRx_DdcHdcpReadData(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC get write message buffer words handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return The number of words in the Write Message Buffer.
+ *
+ ******************************************************************************/
+static u32 XV_HdmiRxSs_DdcGetWriteMessageBufferWordsHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  return XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC get read message buffer words handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return The number of words in the Read Message Buffer.
+ *
+ ******************************************************************************/
+static u32 XV_HdmiRxSs_DdcGetReadMessageBufferWordsHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  return XV_HdmiRx_DdcGetHdcpReadMessageBufferWords(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC get read message buffer is empty handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return
+ *  - TRUE if read message buffer is empty.
+ *  - FALSE if read message buffer is not empty.
+ *
+ ******************************************************************************/
+static u32 XV_HdmiRxSs_DdcIsReadMessageBufferEmptyHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  return XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC get write message buffer is empty handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return
+ *  - TRUE if write message buffer is empty.
+ *  - FALSE if write message buffer is not empty.
+ *
+ ******************************************************************************/
+static u32 XV_HdmiRxSs_DdcIsWriteMessageBufferEmptyHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  return XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC clear read message buffer handler for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return None
+ *
+ ******************************************************************************/
+static void XV_HdmiRxSs_DdcClearReadMessageBufferHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  XV_HdmiRx_DdcHdcpClearReadMessageBuffer(InstancePtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ *
+ * This is the DDC clear write message buffer for the RX.
+ *
+ * @param RefPtr is a callback reference to the HDMI RX instance.
+ *
+ * @return None
+ *
+ ******************************************************************************/
+static void XV_HdmiRxSs_DdcClearWriteMessageBufferHandler(void *RefPtr)
+{
+  XV_HdmiRx *InstancePtr = (XV_HdmiRx *)RefPtr;
+  XV_HdmiRx_DdcHdcpClearWriteMessageBuffer(InstancePtr);
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+* This function is called when the HDMI-RX DDC HDCP interrupt has occurred.
+*
+* @param RefPtr is a callback reference to the HDCP22 RX instance.
+* @param Type indicates the cause of the interrupt.
+*
+* @return None.
+*
+* @note   None.
+******************************************************************************/
+static void XV_HdmiRxSs_DdcHdcpCallback(void *RefPtr, int Type)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr;
+  HdmiRxSsPtr = (XV_HdmiRxSs*) RefPtr;
+
+  switch (Type)
+  {
+    // HDCP 2.2. write message event
+    case XV_HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK:
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      XHdcp22Rx_SetWriteMessageAvailable(HdmiRxSsPtr->Hdcp22Ptr);
+#endif
+      break;
+
+    // HDCP 2.2 read message event
+    case XV_HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK:
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      XHdcp22Rx_SetReadMessageComplete(HdmiRxSsPtr->Hdcp22Ptr);
+#endif
+      break;
+
+    // HDCP 2.2 read not complete event
+    case XV_HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK:
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      XHdcp22Rx_SetDdcError(HdmiRxSsPtr->Hdcp22Ptr);
+#endif
+      break;
+
+    // HDCP 1.4 Aksv event
+    case XV_HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK:
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      XHdcp1x_ProcessAKsv(HdmiRxSsPtr->Hdcp14Ptr);
+#endif
+      break;
+
+    // HDCP 1.4 protocol event
+    case XV_HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK:
+#ifdef USE_HDCP_RX
+      XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_1_PROT_EVT);
+#endif
+      break;
+
+    // HDCP 2.2 protocol event
+    case XV_HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK:
+#ifdef USE_HDCP_RX
+      XV_HdmiRxSs_HdcpPushEvent(HdmiRxSsPtr, XV_HDMIRXSS_HDCP_2_PROT_EVT);
+#endif
+      break;
+
+    default:
+      break;
+  }
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+* This function is called when the HDMI-RX link error has occurred.
+*
+* @param RefPtr is a callback reference to the HDCP22 RX instance.
+*
+* @return None.
+*
+* @note   None.
+******************************************************************************/
+static void XV_HdmiRxSs_LinkErrorCallback(void *RefPtr)
+{
+  XV_HdmiRxSs *HdmiRxSsPtr;
+  HdmiRxSsPtr = (XV_HdmiRxSs*) RefPtr;
+
+  // HDCP 2.2
+  if (HdmiRxSsPtr->HdcpProtocol == XV_HDMIRXSS_HDCP_22) {
+    XHdcp22Rx_SetLinkError(HdmiRxSsPtr->Hdcp22Ptr);
+  }
+}
+#endif
+
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.h
new file mode 100644
index 0000000..5ea6fe5
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_coreinit.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirxss_coreinit.h
+* @addtogroup v_hdmirxss
+* @{
+* @details
+*
+* This header file contains the hdmi rx subsystem sub-cores
+* initialization routines and helper functions.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00         10/07/15 Initial release.
+* 1.1   yh     20/01/16 Added remapper support
+* 1.2   MG     03/02/16 Added HDCP support
+* 1.3   MH     08/08/16 Updates to optimize out HDCP when excluded.
+* 1.4   YH     14/11/16 Remove Remapper APIs as remapper feature is moved to
+*                       video bridge and controlled by HDMI core
+* 1.5   MMO    03/01/16 Remove repetitive inclusion of header files
+* </pre>
+*
+******************************************************************************/
+#ifndef XV_HDMIRXSS_COREINIT_H__  /* prevent circular inclusions */
+#define XV_HDMIRXSS_COREINIT_H__  /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "xv_hdmirxss.h"
+/************************** Constant Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+int XV_HdmiRxSs_SubcoreInitHdmiRx(XV_HdmiRxSs *HdmiRxSsPtr);
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+int XV_HdmiRxSs_SubcoreInitHdcpTimer(XV_HdmiRxSs *HdmiRxSsPtr);
+int XV_HdmiRxSs_SubcoreInitHdcp14(XV_HdmiRxSs *HdmiRxSsPtr);
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+int XV_HdmiRxSs_SubcoreInitHdcp22(XV_HdmiRxSs *HdmiRxSsPtr);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_hdcp.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_hdcp.c
new file mode 100644
index 0000000..8c7a5c4
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_hdcp.c
@@ -0,0 +1,2032 @@
+/******************************************************************************
+*
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xv_hdmirxss_hdcp.c
+*
+* This is main code of Xilinx HDMI Receiver Subsystem for HDCP Functionality.
+* Please see xv_hdmirxss.h for more details of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00   MMO 19/12/16 Move HDCP Code from xv_hdmirxss.c to xv_hdmirxss_hdcp.c
+*
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+#include "xv_hdmirxss.h"
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/************************** Function Prototypes ******************************/
+// HDCP specific
+#ifdef USE_HDCP_RX
+static XV_HdmiRxSs_HdcpEvent XV_HdmiRxSs_HdcpGetEvent(XV_HdmiRxSs *InstancePtr);
+static int XV_HdmiRxSs_HdcpProcessEvents(XV_HdmiRxSs *InstancePtr);
+static int XV_HdmiRxSs_HdcpReset(XV_HdmiRxSs *InstancePtr);
+static int XV_HdmiRxSs_HdcpSetTopologyDepth(XV_HdmiRxSs *InstancePtr, u32 Depth);
+static int XV_HdmiRxSs_HdcpSetTopologyDeviceCnt(XV_HdmiRxSs *InstancePtr, u32 DeviceCnt);
+static int XV_HdmiRxSs_HdcpSetTopologyMaxDevsExceeded(XV_HdmiRxSs *InstancePtr, u8 Value);
+static int XV_HdmiRxSs_HdcpSetTopologyMaxCascadeExceeded(XV_HdmiRxSs *InstancePtr, u8 Value);
+static int XV_HdmiRxSs_HdcpSetTopologyHdcp20RepeaterDownstream(XV_HdmiRxSs *InstancePtr, u8 Value);
+static int XV_HdmiRxSs_HdcpSetTopologyHdcp1DeviceDownstream(XV_HdmiRxSs *InstancePtr, u8 Value);
+#endif
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+static u32 XV_HdmiRxSs_HdcpTimerConvUsToTicks(u32 TimeoutInUs,
+                                            u32 ClockFrequency);
+static void XV_HdmiRxSs_HdcpTimerCallback(void *CallBackRef, u8 TimerChannel);
+#endif
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Definition ******************************/
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP
+ *
+ * @param  InstancePtr is a pointer to the HDMI RX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiRxSS_HdcpIntrHandler(XV_HdmiRxSs *InstancePtr)
+{
+    XHdcp1x_CipherIntrHandler(InstancePtr->Hdcp14Ptr);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP Timer
+ *
+ * @param  InstancePtr is a pointer to the HDMI RX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiRxSS_HdcpTimerIntrHandler(XV_HdmiRxSs *InstancePtr)
+{
+    XTmrCtr_InterruptHandler(InstancePtr->HdcpTimerPtr);
+}
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+/*****************************************************************************/
+/**
+ * This function calls the interrupt handler for HDCP 2.2 Timer
+ *
+ * @param  InstancePtr is a pointer to the HDMI RX Subsystem
+ *
+ *****************************************************************************/
+void XV_HdmiRxSS_Hdcp22TimerIntrHandler(XV_HdmiRxSs *InstancePtr)
+{
+  XTmrCtr *XTmrCtrPtr;
+
+  XTmrCtrPtr = XHdcp22Rx_GetTimer(InstancePtr->Hdcp22Ptr);
+
+  XTmrCtr_InterruptHandler(XTmrCtrPtr);
+}
+#endif
+
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function converts from microseconds to timer ticks
+*
+* @param TimeoutInUs  the timeout to convert
+* @param ClockFrequency  the clock frequency to use in the conversion
+*
+* @return
+*   The number of "ticks"
+*
+* @note
+*   None.
+*
+******************************************************************************/
+static u32 XV_HdmiRxSs_HdcpTimerConvUsToTicks(u32 TimeoutInUs,
+                                                    u32 ClockFrequency)
+{
+  u32 TimeoutFreq = 0;
+  u32 NumTicks = 0;
+
+  /* Check for greater than one second */
+  if (TimeoutInUs > 1000000ul) {
+      u32 NumSeconds = 0;
+
+      /* Determine theNumSeconds */
+      NumSeconds = (TimeoutInUs/1000000ul);
+
+      /* Update theNumTicks */
+      NumTicks = (NumSeconds*ClockFrequency);
+
+      /* Adjust theTimeoutInUs */
+      TimeoutInUs -= (NumSeconds*1000000ul);
+  }
+
+  /* Convert TimeoutFreq to a frequency */
+  TimeoutFreq  = 1000;
+  TimeoutFreq *= 1000;
+  TimeoutFreq /= TimeoutInUs;
+
+  /* Update NumTicks */
+  NumTicks += ((ClockFrequency / TimeoutFreq) + 1);
+
+  return (NumTicks);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/*****************************************************************************/
+/**
+*
+* This function serves as the timer callback function
+*
+* @param CallBackRef  the callback reference value
+* @param TimerChannel  the channel within the timer that expired
+*
+* @return
+*   void
+*
+* @note
+*   None
+*
+******************************************************************************/
+static void XV_HdmiRxSs_HdcpTimerCallback(void* CallBackRef, u8 TimerChannel)
+{
+  XHdcp1x* HdcpPtr = (XHdcp1x*) CallBackRef;
+
+  TimerChannel = TimerChannel;
+  XHdcp1x_HandleTimeout(HdcpPtr);
+  return;
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function starts a timer on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+* @param TimeoutInMs  the timer duration in milliseconds
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpTimerStart(void *InstancePtr, u16 TimeoutInMs)
+{
+  XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+  XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+  u8 TimerChannel = 0;
+  u32 TimerOptions = 0;
+  u32 NumTicks = 0;
+
+  /* Verify argument. */
+  Xil_AssertNonvoid(TimerPtr != NULL);
+
+  /* Determine NumTicks */
+  NumTicks = XV_HdmiRxSs_HdcpTimerConvUsToTicks((TimeoutInMs*1000ul),
+        TimerPtr->Config.SysClockFreqHz);
+
+  /* Stop it */
+  XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+  /* Configure the callback */
+  XTmrCtr_SetHandler(TimerPtr, &XV_HdmiRxSs_HdcpTimerCallback,
+                                              (void*) InstancePtr);
+
+  /* Configure the timer options */
+  TimerOptions  = XTmrCtr_GetOptions(TimerPtr, TimerChannel);
+  TimerOptions |=  XTC_DOWN_COUNT_OPTION;
+  TimerOptions |=  XTC_INT_MODE_OPTION;
+  TimerOptions &= ~XTC_AUTO_RELOAD_OPTION;
+  XTmrCtr_SetOptions(TimerPtr, TimerChannel, TimerOptions);
+
+  /* Set the timeout and start */
+  XTmrCtr_SetResetValue(TimerPtr, TimerChannel, NumTicks);
+  XTmrCtr_Start(TimerPtr, TimerChannel);
+
+  return (XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function stops a timer on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpTimerStop(void *InstancePtr)
+{
+  XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+  XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+  u8 TimerChannel = 0;
+
+  /* Verify argument. */
+  Xil_AssertNonvoid(TimerPtr != NULL);
+
+  /* Stop it */
+  XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+  return (XST_SUCCESS);
+}
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+/******************************************************************************/
+/**
+*
+* This function busy waits for an interval on behalf of an hdcp interface
+*
+* @param InstancePtr  the hdcp interface
+* @param DelayInMs  the delay duration in milliseconds
+*
+* @return
+*   XST_SUCCESS if successful
+*
+* @note
+*   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpTimerBusyDelay(void *InstancePtr, u16 DelayInMs)
+{
+
+  XHdcp1x *HdcpPtr = (XHdcp1x *)InstancePtr;
+  XTmrCtr *TimerPtr = (XTmrCtr *)HdcpPtr->Hdcp1xRef;
+
+  u8 TimerChannel = 0;
+  u32 TimerOptions = 0;
+  u32 NumTicks = 0;
+
+  /* Verify argument. */
+	Xil_AssertNonvoid(TimerPtr != NULL);
+
+  /* Determine NumTicks */
+  NumTicks = XV_HdmiRxSs_HdcpTimerConvUsToTicks((DelayInMs*1000ul),
+                TimerPtr->Config.SysClockFreqHz);
+
+  /* Stop it */
+  XTmrCtr_Stop(TimerPtr, TimerChannel);
+
+  /* Configure the timer options */
+  TimerOptions  = XTmrCtr_GetOptions(TimerPtr, TimerChannel);
+  TimerOptions |=  XTC_DOWN_COUNT_OPTION;
+  TimerOptions &= ~XTC_INT_MODE_OPTION;
+  TimerOptions &= ~XTC_AUTO_RELOAD_OPTION;
+  XTmrCtr_SetOptions(TimerPtr, TimerChannel, TimerOptions);
+
+  /* Set the timeout and start */
+  XTmrCtr_SetResetValue(TimerPtr, TimerChannel, NumTicks);
+  XTmrCtr_Start(TimerPtr, TimerChannel);
+
+  /* Wait until done */
+  while (!XTmrCtr_IsExpired(TimerPtr, TimerChannel));
+
+  return (XST_SUCCESS);
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function pushes an event into the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Event is the event to be pushed in the queue.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpPushEvent(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpEvent Event)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(Event < XV_HDMIRXSS_HDCP_INVALID_EVT);
+
+  /* Write event into the queue */
+  InstancePtr->HdcpEventQueue.Queue[InstancePtr->HdcpEventQueue.Head] = Event;
+
+  /* Update head pointer */
+  if (InstancePtr->HdcpEventQueue.Head == (XV_HDMIRXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+    InstancePtr->HdcpEventQueue.Head = 0;
+  }
+  else {
+    InstancePtr->HdcpEventQueue.Head++;
+  }
+
+  /* Check tail pointer. When the two pointer are equal, then the buffer
+   * is full. In this case then increment the tail pointer as well to
+   * remove the oldest entry from the buffer.
+   */
+  if (InstancePtr->HdcpEventQueue.Tail == InstancePtr->HdcpEventQueue.Head) {
+    if (InstancePtr->HdcpEventQueue.Tail == (XV_HDMIRXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+      InstancePtr->HdcpEventQueue.Tail = 0;
+    }
+    else {
+      InstancePtr->HdcpEventQueue.Tail++;
+    }
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function gets an event from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return When the queue is filled, the next event is returned.
+*         When the queue is empty, XV_HDMIRXSS_HDCP_NO_EVT is returned.
+*
+* @note   None.
+*
+******************************************************************************/
+static XV_HdmiRxSs_HdcpEvent XV_HdmiRxSs_HdcpGetEvent(XV_HdmiRxSs *InstancePtr)
+{
+  XV_HdmiRxSs_HdcpEvent Event;
+
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  /* Check if there are any events in the queue */
+  if (InstancePtr->HdcpEventQueue.Tail == InstancePtr->HdcpEventQueue.Head) {
+    return XV_HDMIRXSS_HDCP_NO_EVT;
+  }
+
+  Event = InstancePtr->HdcpEventQueue.Queue[InstancePtr->HdcpEventQueue.Tail];
+
+  /* Update tail pointer */
+  if (InstancePtr->HdcpEventQueue.Tail == (XV_HDMIRXSS_HDCP_MAX_QUEUE_SIZE - 1)) {
+    InstancePtr->HdcpEventQueue.Tail = 0;
+  }
+  else {
+    InstancePtr->HdcpEventQueue.Tail++;
+  }
+
+  return Event;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function clears all pending events from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpClearEvents(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  InstancePtr->HdcpEventQueue.Head = 0;
+  InstancePtr->HdcpEventQueue.Tail = 0;
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function processes pending events from the HDCP event queue.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpProcessEvents(XV_HdmiRxSs *InstancePtr)
+{
+  XV_HdmiRxSs_HdcpEvent Event;
+  int Status = XST_SUCCESS;
+
+  /* Verify argument */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  Event = XV_HdmiRxSs_HdcpGetEvent(InstancePtr);
+
+  switch (Event) {
+
+    // Stream up
+    case XV_HDMIRXSS_HDCP_STREAMUP_EVT :
+      break;
+
+    // Stream down
+    case XV_HDMIRXSS_HDCP_STREAMDOWN_EVT :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetHdmiMode(InstancePtr->Hdcp14Ptr, FALSE);
+      }
+#endif
+      break;
+
+    // Connect
+    case XV_HDMIRXSS_HDCP_CONNECT_EVT :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        // Set physical state
+        XHdcp1x_SetPhysicalState(InstancePtr->Hdcp14Ptr, TRUE);
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+      }
+#endif
+      XV_HdmiRxSs_HdcpSetProtocol(InstancePtr, InstancePtr->HdcpProtocol);
+      break;
+
+    // Disconnect
+    // Enable the previous HDCP protocol
+    case XV_HDMIRXSS_HDCP_DISCONNECT_EVT :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        // Clear HDMI mode
+        XHdcp1x_SetHdmiMode(InstancePtr->Hdcp14Ptr, FALSE);
+
+        // Set physical state
+        XHdcp1x_SetPhysicalState(InstancePtr->Hdcp14Ptr, FALSE);
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+      }
+#endif
+      break;
+
+    // HDCP 1.4 protocol event
+    // Enable HDCP 1.4
+    case XV_HDMIRXSS_HDCP_1_PROT_EVT :
+      if(XV_HdmiRxSs_HdcpSetProtocol(InstancePtr, XV_HDMIRXSS_HDCP_14) != XST_SUCCESS)
+        XV_HdmiRxSs_HdcpSetProtocol(InstancePtr, XV_HDMIRXSS_HDCP_22);
+      break;
+
+    // HDCP 2.2 protocol event
+    // Enable HDCP 2.2
+    case XV_HDMIRXSS_HDCP_2_PROT_EVT :
+      if(XV_HdmiRxSs_HdcpSetProtocol(InstancePtr, XV_HDMIRXSS_HDCP_22) != XST_SUCCESS)
+        XV_HdmiRxSs_HdcpSetProtocol(InstancePtr, XV_HDMIRXSS_HDCP_14);
+      break;
+
+    // DVI mode event
+    case XV_HDMIRXSS_HDCP_DVI_MODE_EVT:
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetHdmiMode(InstancePtr->Hdcp14Ptr, FALSE);
+      }
+#endif
+      break;
+
+    // HDMI mode event
+    case XV_HDMIRXSS_HDCP_HDMI_MODE_EVT:
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetHdmiMode(InstancePtr->Hdcp14Ptr, TRUE);
+      }
+#endif
+      break;
+
+    // Sync loss event
+    case XV_HDMIRXSS_HDCP_SYNC_LOSS_EVT:
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetHdmiMode(InstancePtr->Hdcp14Ptr, FALSE);
+      }
+#endif
+      break;
+
+    default :
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function schedules the available HDCP cores. Only the active
+* HDCP protocol poll function is executed. HDCP 1.4 and 2.2 poll
+* functions should not execute in parallel.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpPoll(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  /* Only poll when the HDCP is ready */
+  if (InstancePtr->HdcpIsReady) {
+
+    /* Process any pending events from the RX event queue */
+    XV_HdmiRxSs_HdcpProcessEvents(InstancePtr);
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    if (InstancePtr->Hdcp22Ptr) {
+      if (XHdcp22Rx_IsEnabled(InstancePtr->Hdcp22Ptr)) {
+        XHdcp22Rx_Poll(InstancePtr->Hdcp22Ptr);
+      }
+    }
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    if (InstancePtr->Hdcp14Ptr) {
+      if (XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr)) {
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr);
+      }
+    }
+#endif
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the active HDCP protocol and enables it.
+* The protocol can be set to either HDCP 1.4, 2.2, or None.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Protocol is the requested content protection scheme of type
+*        XV_HdmiRxSs_HdcpProtocol.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetProtocol(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpProtocol Protocol)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid((Protocol == XV_HDMIRXSS_HDCP_NONE) ||
+                    (Protocol == XV_HDMIRXSS_HDCP_14)   ||
+                    (Protocol == XV_HDMIRXSS_HDCP_22));
+
+  int Status;
+
+  /* Set requested protocol */
+  InstancePtr->HdcpProtocol = Protocol;
+
+  /* Reset both protocols */
+  Status = XV_HdmiRxSs_HdcpReset(InstancePtr);
+  if (Status != XST_SUCCESS) {
+    InstancePtr->HdcpProtocol = XV_HDMIRXSS_HDCP_NONE;
+    return XST_FAILURE;
+  }
+
+  /* Enable the requested protocol */
+  Status = XV_HdmiRxSs_HdcpEnable(InstancePtr);
+  if (Status != XST_SUCCESS) {
+    InstancePtr->HdcpProtocol = XV_HDMIRXSS_HDCP_NONE;
+    return XST_FAILURE;
+  }
+
+  return XST_SUCCESS;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function gets the active HDCP content protection scheme.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  @RequestedScheme is the requested content protection scheme.
+*
+* @note   None.
+*
+******************************************************************************/
+XV_HdmiRxSs_HdcpProtocol XV_HdmiRxSs_HdcpGetProtocol(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  return InstancePtr->HdcpProtocol;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function enables the requested HDCP protocol. This function
+* ensures that the HDCP protocols are mutually exclusive such that
+* either HDCP 1.4 or HDCP 2.2 is enabled and active at any given time.
+* When the protocol is set to None, both HDCP protocols are disabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpEnable(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status1 = XST_SUCCESS;
+  int Status2 = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol) {
+
+    /* Disable HDCP 1.4 and HDCP 2.2 */
+    case XV_HDMIRXSS_HDCP_NONE :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP14, 0);
+#endif
+      }
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Rx_Disable(InstancePtr->Hdcp22Ptr);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP22, 0);
+#endif
+      }
+#endif
+      break;
+
+    /* Enable HDCP 1.4 and disable HDCP 2.2 */
+    case XV_HDMIRXSS_HDCP_14 :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Enable(InstancePtr->Hdcp14Ptr);
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP14, 1);
+#endif
+      }
+      else {
+        Status1 = XST_FAILURE;
+      }
+
+      /* Set DDC peripheral to HDCP 1.4 mode */
+      XV_HdmiRx_DdcHdcp14Mode(InstancePtr->HdmiRxPtr);
+#else
+      Status1 = XST_FAILURE;
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Rx_Disable(InstancePtr->Hdcp22Ptr);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP22, 0);
+#endif
+      }
+#endif
+      break;
+
+    /* Enable HDCP 2.2 and disable HDCP 1.4 */
+    case XV_HDMIRXSS_HDCP_22 :
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+      if (InstancePtr->Hdcp14Ptr) {
+        Status1 = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+        XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP14, 0);
+#endif
+      }
+#endif
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+      if (InstancePtr->Hdcp22Ptr) {
+        Status2 = XHdcp22Rx_Enable(InstancePtr->Hdcp22Ptr);
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+        XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_HDCP22, 1);
+#endif
+      }
+      else {
+        Status2 = XST_FAILURE;
+      }
+
+      /* Set DDC peripheral to HDCP 2.2 mode */
+      XV_HdmiRx_DdcHdcp22Mode(InstancePtr->HdmiRxPtr);
+#else
+      Status2 = XST_FAILURE;
+#endif
+      break;
+
+    default :
+      return XST_FAILURE;
+  }
+
+  return (Status1 == XST_SUCCESS && Status2 == XST_SUCCESS) ? XST_SUCCESS : XST_FAILURE;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function disables both HDCP 1.4 and 2.2 protocols.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpDisable(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  // HDCP 1.4
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  if (InstancePtr->Hdcp14Ptr) {
+    Status = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    Status = XHdcp22Rx_Disable(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function resets both HDCP 1.4 and 2.2 protocols. This function also
+* disables both HDCP 1.4 and 2.2 protocols.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpReset(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  // Resetting HDCP 1.4 causes the state machine to be enabled, therefore
+  // disable must be called immediately after reset is called.
+  if (InstancePtr->Hdcp14Ptr) {
+    Status = XHdcp1x_Reset(InstancePtr->Hdcp14Ptr);
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+
+    Status = XHdcp1x_Disable(InstancePtr->Hdcp14Ptr);
+    XHdcp1x_Poll(InstancePtr->Hdcp14Ptr); // This is needed to ensure that the previous command is executed.
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    Status = XHdcp22Rx_Reset(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+
+    Status = XHdcp22Rx_Disable(InstancePtr->Hdcp22Ptr);
+    if (Status != XST_SUCCESS)
+      return XST_FAILURE;
+  }
+#endif
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is enabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol is enabled
+*  - FALSE if active protocol is disabled
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsEnabled(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMIRXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_14 :
+      return XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_22 :
+      return XHdcp22Rx_IsEnabled(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is authenticated.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol is authenticated
+*  - FALSE if active protocol is not authenticated
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsAuthenticated(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMIRXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_14 :
+      return XHdcp1x_IsAuthenticated(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_22 :
+      return XHdcp22Rx_IsAuthenticated(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol has encryption enabled.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol has encryption enabled
+*  - FALSE if active protocol has encryption disabled
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsEncrypted(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMIRXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_14 :
+      return XHdcp1x_IsEncrypted(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_22 :
+      return XHdcp22Rx_IsEncryptionEnabled(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is busy authenticating.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol is busy authenticating
+*  - FALSE if active protocol is not busy authenticating
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsInProgress(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMIRXSS_HDCP_NONE :
+      return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_14 :
+      return XHdcp1x_IsInProgress(InstancePtr->Hdcp14Ptr);
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    case XV_HDMIRXSS_HDCP_22 :
+      return XHdcp22Rx_IsInProgress(InstancePtr->Hdcp22Ptr);
+#endif
+
+    default :
+      return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is in computations state.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol is in computations state
+*  - FALSE if active protocol is not in computations state
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsInComputations(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+	case XV_HDMIRXSS_HDCP_NONE :
+	  return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+	case XV_HDMIRXSS_HDCP_14 :
+	  return XHdcp1x_IsInComputations(InstancePtr->Hdcp14Ptr);
+#endif
+
+	case XV_HDMIRXSS_HDCP_22 :
+	  return FALSE;
+
+	default :
+	  return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the active HDCP protocol is in wait-for-ready state.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*  - TRUE if active protocol is in computations state
+*  - FALSE if active protocol is not in computations state
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsInWaitforready(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+	case XV_HDMIRXSS_HDCP_NONE :
+	  return FALSE;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+	case XV_HDMIRXSS_HDCP_14 :
+	  return XHdcp1x_IsInWaitforready(InstancePtr->Hdcp14Ptr);
+#endif
+
+	case XV_HDMIRXSS_HDCP_22 :
+	  return FALSE;
+
+	default :
+	  return FALSE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets pointers to the HDCP 1.4 and HDCP 2.2 keys.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_HdcpSetKey(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_HdcpKeyType KeyType, u8 *KeyPtr)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+  Xil_AssertVoid((KeyType == XV_HDMIRXSS_KEY_HDCP22_LC128)   ||
+                   (KeyType == XV_HDMIRXSS_KEY_HDCP22_PRIVATE)   ||
+                    (KeyType == XV_HDMIRXSS_KEY_HDCP14));
+
+  switch (KeyType) {
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2 LC128
+    case XV_HDMIRXSS_KEY_HDCP22_LC128 :
+      InstancePtr->Hdcp22Lc128Ptr = KeyPtr;
+      break;
+
+    // HDCP 2.2 Private key
+    case XV_HDMIRXSS_KEY_HDCP22_PRIVATE :
+      InstancePtr->Hdcp22PrivateKeyPtr = KeyPtr;
+      break;
+#endif
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_KEY_HDCP14 :
+      InstancePtr->Hdcp14KeyPtr = KeyPtr;
+#endif
+      break;
+
+    default :
+      break;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function reports the HDCP information.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_HdcpInfo(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  switch (InstancePtr->HdcpProtocol) {
+    case XV_HDMIRXSS_HDCP_NONE :
+      xil_printf("\r\nHDCP RX is disabled\r\n");
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        if (XHdcp1x_IsEnabled(InstancePtr->Hdcp14Ptr)) {
+          xil_printf("\r\nHDCP 1.4 RX Info\r\n");
+
+          xil_printf("Encryption : ");
+          if (XHdcp1x_IsEncrypted(InstancePtr->Hdcp14Ptr)) {
+            xil_printf("Enabled.\r\n");
+          } else {
+            xil_printf("Disabled.\r\n");
+          }
+
+          // Route debug output to xil_printf
+          XHdcp1x_SetDebugPrintf(xil_printf);
+
+          // Display info
+          XHdcp1x_Info(InstancePtr->Hdcp14Ptr);
+        }
+        else {
+          xil_printf("\r\nHDCP 1.4 RX is disabled\r\n");
+        }
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        if (XHdcp22Rx_IsEnabled(InstancePtr->Hdcp22Ptr)) {
+          XHdcp22Rx_LogDisplay(InstancePtr->Hdcp22Ptr);
+
+          xil_printf("HDCP 2.2 RX Info\r\n");
+          XHdcp22Rx_Info(InstancePtr->Hdcp22Ptr);
+        }
+        else {
+          xil_printf("\r\nHDCP 2.2 RX is disabled\r\n");
+        }
+      }
+      break;
+#endif
+
+    default:
+      xil_printf("\r\nHDCP info unknown?\r\n");
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP logging level.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Verbose is set to TRUE to enable detailed logging.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_HdcpSetInfoDetail(XV_HdmiRxSs *InstancePtr, u8 Verbose)
+{
+  /* Verify argument. */
+  Xil_AssertVoid(InstancePtr != NULL);
+
+  if (Verbose) {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+   // HDCP 1.4
+   if (InstancePtr->Hdcp14Ptr) {
+     XHdcp1x_SetDebugLogMsg(xil_printf);
+   }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+   // HDCP 2.2
+   if (InstancePtr->Hdcp22Ptr) {
+     XHdcp22Rx_LogReset(InstancePtr->Hdcp22Ptr, TRUE);
+   }
+#endif
+  }
+
+  else {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    if (InstancePtr->Hdcp14Ptr) {
+      XHdcp1x_SetDebugLogMsg(NULL);
+    }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    if (InstancePtr->Hdcp22Ptr) {
+      XHdcp22Rx_LogReset(InstancePtr->Hdcp22Ptr, FALSE);
+    }
+#endif
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function copies the HDCP repeater topology for the active protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param TopologyPtr is a pointer to the topology structure.
+*
+* @return .
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetTopology(XV_HdmiRxSs *InstancePtr, void *TopologyPtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(TopologyPtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopology(InstancePtr->Hdcp14Ptr, ((XHdcp1x_RepeaterExchange*)(TopologyPtr)));
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopology(InstancePtr->Hdcp22Ptr, (XHdcp22_Rx_Topology*)(TopologyPtr));
+      } else {
+        Status = XST_FAILURE;
+      }
+    break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function copies the HDCP repeater topology list for the active
+* protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param ListPtr is a pointer to the Receiver ID list.
+* @param ListSize is the number of Receiver IDs in the list.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetTopologyReceiverIdList(XV_HdmiRxSs *InstancePtr, u8 *ListPtr, u32 ListSize)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(ListPtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyKSVList(InstancePtr->Hdcp14Ptr, ListPtr,	ListSize);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyReceiverIdList(InstancePtr->Hdcp22Ptr, ListPtr, ListSize);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default :
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets various fields inside the HDCP repeater topology.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Field indicates what field of the topology structure to update.
+* @param Value is the value assigned to the field of the topology structure.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetTopologyField(XV_HdmiRxSs *InstancePtr,
+      XV_HdmiRxSs_HdcpTopologyField Field, u32 Value)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+  Xil_AssertNonvoid(Field < XV_HDMIRXSS_HDCP_TOPOLOGY_INVALID);
+
+  switch (Field)
+  {
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_DEPTH:
+      return XV_HdmiRxSs_HdcpSetTopologyDepth(InstancePtr, Value);
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_DEVICECNT:
+      return XV_HdmiRxSs_HdcpSetTopologyDeviceCnt(InstancePtr, Value);
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_MAXDEVSEXCEEDED:
+      return XV_HdmiRxSs_HdcpSetTopologyMaxDevsExceeded(InstancePtr, Value);
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_MAXCASCADEEXCEEDED:
+      return XV_HdmiRxSs_HdcpSetTopologyMaxCascadeExceeded(InstancePtr, Value);
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_HDCP20REPEATERDOWNSTREAM:
+      return XV_HdmiRxSs_HdcpSetTopologyHdcp20RepeaterDownstream(InstancePtr, Value);
+	  case XV_HDMIRXSS_HDCP_TOPOLOGY_HDCP1DEVICEDOWNSTREAM:
+      return XV_HdmiRxSs_HdcpSetTopologyHdcp1DeviceDownstream(InstancePtr, Value);
+    default:
+      return XST_FAILURE;
+  }
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology depth for the active
+* protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Depth is the Repeater cascade depth.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyDepth(XV_HdmiRxSs *InstancePtr, u32 Depth)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyField(InstancePtr->Hdcp14Ptr,
+          XHDCP1X_TOPOLOGY_DEPTH, Depth);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_DEPTH, Depth);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology device count for the active
+* protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param DeviceCnt is the Total number of connected downstream devices.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyDeviceCnt(XV_HdmiRxSs *InstancePtr, u32 DeviceCnt)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyField(InstancePtr->Hdcp14Ptr,
+          XHDCP1X_TOPOLOGY_DEVICECNT, DeviceCnt);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_DEVICECNT, DeviceCnt);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology maximum devices exceeded
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Value is either TRUE or FALSE.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyMaxDevsExceeded(XV_HdmiRxSs *InstancePtr, u8 Value)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyField(InstancePtr->Hdcp14Ptr,
+          XHDCP1X_TOPOLOGY_MAXDEVSEXCEEDED, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_MAXDEVSEXCEEDED, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology maximum cascade exceeded
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Value is either TRUE or FALSE.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyMaxCascadeExceeded(XV_HdmiRxSs *InstancePtr, u8 Value)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyField(InstancePtr->Hdcp14Ptr,
+          XHDCP1X_TOPOLOGY_MAXCASCADEEXCEEDED, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_MAXCASCADEEXCEEDED, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology HDCP 2.0 repeater
+* downstream flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Value is either TRUE or FALSE.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyHdcp20RepeaterDownstream(XV_HdmiRxSs *InstancePtr, u8 Value)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  Value = Value;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_HDCP20REPEATERDOWNSTREAM, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology HDCP 1.x repeater downstream
+* flag.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Value is either TRUE or FALSE.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+static int XV_HdmiRxSs_HdcpSetTopologyHdcp1DeviceDownstream(XV_HdmiRxSs *InstancePtr, u8 Value)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  Value = Value;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyField(InstancePtr->Hdcp22Ptr,
+          XHDCP22_RX_TOPOLOGY_HDCP1DEVICEDOWNSTREAM, Value);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function sets the HDCP repeater topology update flag, indicating that
+* the topology is ready for upstream propagation.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Value is either TRUE or FALSE.
+*
+* @return XST_SUCCESS or XST_FAILURE.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetTopologyUpdate(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = XST_SUCCESS;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // None
+    case XV_HDMIRXSS_HDCP_NONE:
+      Status = XST_FAILURE;
+      break;
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        XHdcp1x_SetTopologyUpdate(InstancePtr->Hdcp14Ptr);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        XHdcp22Rx_SetTopologyUpdate(InstancePtr->Hdcp22Ptr);
+      } else {
+        Status = XST_FAILURE;
+      }
+      break;
+#endif
+
+    default:
+      Status = XST_FAILURE;
+      break;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function gets the repeater management content stream type.
+* When the protocol is HDCP 1.4 the stream type is always Type 0.
+* For HDCP 2.2 the stream type is extracted from the HDCP 2.2
+* stream manage message.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return None.
+*
+* @note   None.
+*
+******************************************************************************/
+XV_HdmiRxSs_HdcpContentStreamType XV_HdmiRxSs_HdcpGetContentStreamType(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int StreamType;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      StreamType = XV_HDMIRXSS_HDCP_STREAMTYPE_0;
+      break;
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        StreamType = XHdcp22Rx_GetContentStreamType(InstancePtr->Hdcp22Ptr);
+      } else {
+        StreamType = XV_HDMIRXSS_HDCP_STREAMTYPE_0;
+      }
+      break;
+#endif
+
+    default:
+      StreamType = XV_HDMIRXSS_HDCP_STREAMTYPE_0;
+  }
+
+  return (XV_HdmiRxSs_HdcpContentStreamType) StreamType;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function checks if the HDMI receiver is an HDCP repeater
+* upstream interface for the active protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+*
+* @return
+*   - TRUE if repeater upstream interface.
+*   - FALSE if not repeater upstream interface.
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpIsRepeater(XV_HdmiRxSs *InstancePtr)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+  int Status = (int)FALSE;
+
+  switch (InstancePtr->HdcpProtocol)
+  {
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+    // HDCP 1.4
+    case XV_HDMIRXSS_HDCP_14:
+      if (InstancePtr->Hdcp14Ptr) {
+        Status = XHdcp1x_IsRepeater(InstancePtr->Hdcp14Ptr);
+      }
+      break;
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+    // HDCP 2.2
+    case XV_HDMIRXSS_HDCP_22:
+      if (InstancePtr->Hdcp22Ptr) {
+        Status = XHdcp22Rx_IsRepeater(InstancePtr->Hdcp22Ptr);
+      }
+      break;
+#endif
+
+    default:
+      Status = (int)FALSE;
+  }
+
+  return Status;
+}
+#endif
+
+#ifdef USE_HDCP_RX
+/*****************************************************************************/
+/**
+*
+* This function enables the Repeater functionality for the HDCP protocol.
+*
+* @param InstancePtr is a pointer to the XV_HdmiRxSs instance.
+* @param Set is TRUE to enable and FALSE to disable repeater.
+*
+* @return
+*  - XST_SUCCESS if action was successful
+*  - XST_FAILURE if action was not successful
+*
+* @note   None.
+*
+******************************************************************************/
+int XV_HdmiRxSs_HdcpSetRepeater(XV_HdmiRxSs *InstancePtr, u8 Set)
+{
+  /* Verify argument. */
+  Xil_AssertNonvoid(InstancePtr != NULL);
+
+#ifdef XPAR_XHDCP_NUM_INSTANCES
+  // HDCP 1.4
+  if (InstancePtr->Hdcp14Ptr) {
+    XHdcp1x_SetRepeater(InstancePtr->Hdcp14Ptr, Set);
+  }
+#endif
+
+#ifdef XPAR_XHDCP22_RX_NUM_INSTANCES
+  // HDCP 2.2
+  if (InstancePtr->Hdcp22Ptr) {
+    XHdcp22Rx_SetRepeater(InstancePtr->Hdcp22Ptr, Set);
+  }
+#endif
+
+  return XST_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_log.c b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_log.c
new file mode 100644
index 0000000..2d27e53
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xv_hdmirxss_log.c
@@ -0,0 +1,273 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xv_hdmirxss_log.c
+ *
+ *
+ * @note    None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   YH   17/08/16 Initial release.
+ * 1.01  MMO  03/01/17 Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable Log
+ * </pre>
+ *
+*******************************************************************************/
+
+/******************************* Include Files ********************************/
+
+#include "xv_hdmirxss.h"
+#include "xil_printf.h"
+
+/**************************** Function Prototypes *****************************/
+
+/**************************** Function Definitions ****************************/
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+/*****************************************************************************/
+/**
+* This function will reset the driver's logging mechanism.
+*
+* @param    InstancePtr is a pointer to the xv_hdmirxss core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_LogReset(XV_HdmiRxSs *InstancePtr)
+{
+    /* Verify arguments. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    InstancePtr->Log.HeadIndex = 0;
+    InstancePtr->Log.TailIndex = 0;
+}
+
+/*****************************************************************************/
+/**
+* This function will insert an event in the driver's logginc mechanism.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRxSs core instance.
+* @param    Evt is the event type to log.
+* @param    Data is the associated data for the event.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_LogWrite(XV_HdmiRxSs *InstancePtr, XV_HdmiRxSs_LogEvent Evt, u8 Data)
+{
+    /* Verify arguments. */
+    Xil_AssertVoid(InstancePtr != NULL);
+    Xil_AssertVoid(Evt <= (XV_HDMIRXSS_LOG_EVT_DUMMY));
+    Xil_AssertVoid(Data < 0xFF);
+
+    /* Write data and event into log buffer */
+    InstancePtr->Log.DataBuffer[InstancePtr->Log.HeadIndex] =
+            (Data << 8) | Evt;
+
+    /* Update head pointer if reached to end of the buffer */
+    if (InstancePtr->Log.HeadIndex ==
+            (u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+        /* Clear pointer */
+        InstancePtr->Log.HeadIndex = 0;
+    }
+    else {
+        /* Increment pointer */
+        InstancePtr->Log.HeadIndex++;
+    }
+
+    /* Check tail pointer. When the two pointer are equal, then the buffer
+     * is full. In this case then increment the tail pointer as well to
+     * remove the oldest entry from the buffer. */
+    if (InstancePtr->Log.TailIndex == InstancePtr->Log.HeadIndex) {
+        if (InstancePtr->Log.TailIndex ==
+            (u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+            InstancePtr->Log.TailIndex = 0;
+        }
+        else {
+            InstancePtr->Log.TailIndex++;
+        }
+    }
+}
+
+/*****************************************************************************/
+/**
+* This function will read the last event from the log.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRxSs core instance.
+*
+* @return   The log data.
+*
+* @note     None.
+*
+******************************************************************************/
+u16 XV_HdmiRxSs_LogRead(XV_HdmiRxSs *InstancePtr)
+{
+    u16 Log;
+
+    /* Verify argument. */
+    Xil_AssertNonvoid(InstancePtr != NULL);
+
+    /* Check if there is any data in the log */
+    if (InstancePtr->Log.TailIndex == InstancePtr->Log.HeadIndex) {
+        Log = 0;
+    }
+    else {
+        Log = InstancePtr->Log.DataBuffer[InstancePtr->Log.TailIndex];
+
+        /* Increment tail pointer */
+        if (InstancePtr->Log.TailIndex ==
+            (u8)((sizeof(InstancePtr->Log.DataBuffer) / 2) - 1)) {
+            InstancePtr->Log.TailIndex = 0;
+        }
+        else {
+            InstancePtr->Log.TailIndex++;
+        }
+    }
+
+    return Log;
+}
+#endif
+
+/*****************************************************************************/
+/**
+* This function will print the entire log.
+*
+* @param    InstancePtr is a pointer to the XV_HdmiRxSs core instance.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XV_HdmiRxSs_LogDisplay(XV_HdmiRxSs *InstancePtr)
+{
+#ifdef XV_HDMIRXSS_LOG_ENABLE
+    u16 Log;
+    u8 Evt;
+    u8 Data;
+
+    /* Verify argument. */
+    Xil_AssertVoid(InstancePtr != NULL);
+
+    xil_printf("\r\n\n\nHDMI RX log\r\n");
+    xil_printf("------\r\n");
+
+    /* Read log data */
+    Log = XV_HdmiRxSs_LogRead(InstancePtr);
+
+    while (Log != 0) {
+        /* Event */
+        Evt = Log & 0xff;
+
+        /* Data */
+        Data = (Log >> 8) & 0xFF;
+        Data = Data;
+
+        switch (Evt) {
+        case (XV_HDMIRXSS_LOG_EVT_NONE):
+            xil_printf("HDMI RXSS log end\r\n-------\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_HDMIRX_INIT):
+            xil_printf("Initializing HDMI RX core....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_VTC_INIT):
+            xil_printf("Initializing VTC core....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_HDCPTIMER_INIT):
+            xil_printf("Initializing AXI Timer core....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_HDCP14_INIT):
+            xil_printf("Initializing HDCP 1.4 core....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_HDCP22_INIT):
+            xil_printf("Initializing HDCP 2.2 core....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_START):
+            xil_printf("Start HDMI RX Subsystem....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_STOP):
+            xil_printf("Stop HDMI RX Subsystem....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_RESET):
+            xil_printf("Reset HDMI RX Subsystem....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_CONNECT):
+            xil_printf("RX cable is connected....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_DISCONNECT):
+            xil_printf("RX cable is disconnected....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_LINKSTATUS):
+            xil_printf("RX Link Status Error....\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_STREAMUP):
+            xil_printf("RX Stream is Up\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_STREAMDOWN):
+            xil_printf("RX Stream is Down\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_STREAMINIT):
+            xil_printf("RX Stream Start\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_SETSTREAM):
+            xil_printf("RX Stream Init\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE):
+            xil_printf("RX TMDS reference clock change\r\n");
+            break;
+         case (XV_HDMIRXSS_LOG_EVT_HDCP14):
+              if (Data) {
+                xil_printf("RX HDCP 1.4 Enabled\r\n");
+              } else {
+                xil_printf("RX HDCP 1.4 Disabled\r\n");
+              }
+            break;
+         case (XV_HDMIRXSS_LOG_EVT_HDCP22):
+              if (Data) {
+                xil_printf("RX HDCP 2.2 Enabled\r\n");
+              } else {
+                xil_printf("RX HDCP 2.2 Disabled\r\n");
+              }
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_DVIMODE):
+            xil_printf("RX mode changed to DVI\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_HDMIMODE):
+            xil_printf("RX mode changed to HDMI\r\n");
+            break;
+        case (XV_HDMIRXSS_LOG_EVT_SYNCLOSS):
+            xil_printf("RX Sync Loss detected\r\n");
+            break;
+        default:
+            xil_printf("Unknown event\r\n");
+            break;
+        }
+
+        /* Read log data */
+        Log = XV_HdmiRxSs_LogRead(InstancePtr);
+    }
+#else
+    xil_printf("\r\n INFO:: HDMIRXSS Log Feature is Disabled \r\n");
+#endif
+}
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc.h
new file mode 100644
index 0000000..e566881
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc.h
@@ -0,0 +1,542 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xvidc.h
+ * @addtogroup video_common_v4_0
+ * @{
+ * @details
+ *
+ * Contains common structures, definitions, macros, and utility functions that
+ * are typically used by video-related drivers and applications.
+ *
+ * @note	None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   rc,  01/10/15 Initial release.
+ *       als
+ * 2.0   als  08/14/15 Added new video timings.
+ * 2.2   als  02/01/16 Functions with pointer arguments that don't modify
+ *                     contents now const.
+ *                     Added ability to insert a custom video timing table:
+ *                         XVidC_RegisterCustomTimingModes
+ *                         XVidC_UnregisterCustomTimingMode
+ *       yh            Added 3D support.
+ * 3.0   aad  05/13/16 Added API to search for RB video modes.
+ *       als  05/16/16 Added Y-only to color format enum.
+ * 3.1   rco  07/26/17 Moved timing table extern definition to xvidc.c
+ *                     Added video-in-memory color formats
+ *                     Updated XVidC_RegisterCustomTimingModes API signature
+ * 4.1   rco  11/23/17 Added new memory formats
+ *                     Added xil_printf include statement
+ *                     Added new API XVidC_GetVideoModeIdWBlanking
+ *                     Fix C++ warnings
+ * </pre>
+ *
+*******************************************************************************/
+
+#ifndef XVIDC_H_  /* Prevent circular inclusions by using protection macros. */
+#define XVIDC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************* Include Files ********************************/
+
+#include "xil_types.h"
+#include "xil_printf.h"
+
+/************************** Constant Definitions ******************************/
+
+/**
+ * This typedef enumerates the list of available standard display monitor
+ * timings as specified in the xvidc_timings_table.c file. The naming format is:
+ *
+ * XVIDC_VM_<RESOLUTION>_<REFRESH RATE (HZ)>_<P|I>(_RB)
+ *
+ * Where RB stands for reduced blanking.
+ */
+typedef enum {
+	/* Interlaced modes. */
+	XVIDC_VM_720x480_60_I = 0,
+	XVIDC_VM_720x576_50_I,
+	XVIDC_VM_1440x480_60_I,
+	XVIDC_VM_1440x576_50_I,
+	XVIDC_VM_1920x1080_50_I,
+	XVIDC_VM_1920x1080_60_I,
+
+	/* Progressive modes. */
+	XVIDC_VM_640x350_85_P,
+	XVIDC_VM_640x480_60_P,
+	XVIDC_VM_640x480_72_P,
+	XVIDC_VM_640x480_75_P,
+	XVIDC_VM_640x480_85_P,
+	XVIDC_VM_720x400_85_P,
+	XVIDC_VM_720x480_60_P,
+	XVIDC_VM_720x576_50_P,
+	XVIDC_VM_800x600_56_P,
+	XVIDC_VM_800x600_60_P,
+	XVIDC_VM_800x600_72_P,
+	XVIDC_VM_800x600_75_P,
+	XVIDC_VM_800x600_85_P,
+	XVIDC_VM_800x600_120_P_RB,
+	XVIDC_VM_848x480_60_P,
+	XVIDC_VM_1024x768_60_P,
+	XVIDC_VM_1024x768_70_P,
+	XVIDC_VM_1024x768_75_P,
+	XVIDC_VM_1024x768_85_P,
+	XVIDC_VM_1024x768_120_P_RB,
+	XVIDC_VM_1152x864_75_P,
+	XVIDC_VM_1280x720_50_P,
+	XVIDC_VM_1280x720_60_P,
+	XVIDC_VM_1280x768_60_P,
+	XVIDC_VM_1280x768_60_P_RB,
+	XVIDC_VM_1280x768_75_P,
+	XVIDC_VM_1280x768_85_P,
+	XVIDC_VM_1280x768_120_P_RB,
+	XVIDC_VM_1280x800_60_P,
+	XVIDC_VM_1280x800_60_P_RB,
+	XVIDC_VM_1280x800_75_P,
+	XVIDC_VM_1280x800_85_P,
+	XVIDC_VM_1280x800_120_P_RB,
+	XVIDC_VM_1280x960_60_P,
+	XVIDC_VM_1280x960_85_P,
+	XVIDC_VM_1280x960_120_P_RB,
+	XVIDC_VM_1280x1024_60_P,
+	XVIDC_VM_1280x1024_75_P,
+	XVIDC_VM_1280x1024_85_P,
+	XVIDC_VM_1280x1024_120_P_RB,
+	XVIDC_VM_1360x768_60_P,
+	XVIDC_VM_1360x768_120_P_RB,
+	XVIDC_VM_1366x768_60_P,
+	XVIDC_VM_1400x1050_60_P,
+	XVIDC_VM_1400x1050_60_P_RB,
+	XVIDC_VM_1400x1050_75_P,
+	XVIDC_VM_1400x1050_85_P,
+	XVIDC_VM_1400x1050_120_P_RB,
+	XVIDC_VM_1440x240_60_P,
+	XVIDC_VM_1440x900_60_P,
+	XVIDC_VM_1440x900_60_P_RB,
+	XVIDC_VM_1440x900_75_P,
+	XVIDC_VM_1440x900_85_P,
+	XVIDC_VM_1440x900_120_P_RB,
+	XVIDC_VM_1600x1200_60_P,
+	XVIDC_VM_1600x1200_65_P,
+	XVIDC_VM_1600x1200_70_P,
+	XVIDC_VM_1600x1200_75_P,
+	XVIDC_VM_1600x1200_85_P,
+	XVIDC_VM_1600x1200_120_P_RB,
+	XVIDC_VM_1680x720_50_P,
+	XVIDC_VM_1680x720_60_P,
+	XVIDC_VM_1680x720_100_P,
+	XVIDC_VM_1680x720_120_P,
+	XVIDC_VM_1680x1050_50_P,
+	XVIDC_VM_1680x1050_60_P,
+	XVIDC_VM_1680x1050_60_P_RB,
+	XVIDC_VM_1680x1050_75_P,
+	XVIDC_VM_1680x1050_85_P,
+	XVIDC_VM_1680x1050_120_P_RB,
+	XVIDC_VM_1792x1344_60_P,
+	XVIDC_VM_1792x1344_75_P,
+	XVIDC_VM_1792x1344_120_P_RB,
+	XVIDC_VM_1856x1392_60_P,
+	XVIDC_VM_1856x1392_75_P,
+	XVIDC_VM_1856x1392_120_P_RB,
+	XVIDC_VM_1920x1080_24_P,
+	XVIDC_VM_1920x1080_25_P,
+	XVIDC_VM_1920x1080_30_P,
+	XVIDC_VM_1920x1080_50_P,
+	XVIDC_VM_1920x1080_60_P,
+	XVIDC_VM_1920x1080_100_P,
+	XVIDC_VM_1920x1080_120_P,
+	XVIDC_VM_1920x1200_60_P,
+	XVIDC_VM_1920x1200_60_P_RB,
+	XVIDC_VM_1920x1200_75_P,
+	XVIDC_VM_1920x1200_85_P,
+	XVIDC_VM_1920x1200_120_P_RB,
+	XVIDC_VM_1920x1440_60_P,
+	XVIDC_VM_1920x1440_75_P,
+	XVIDC_VM_1920x1440_120_P_RB,
+	XVIDC_VM_1920x2160_60_P,
+	XVIDC_VM_2560x1080_50_P,
+	XVIDC_VM_2560x1080_60_P,
+	XVIDC_VM_2560x1080_100_P,
+	XVIDC_VM_2560x1080_120_P,
+	XVIDC_VM_2560x1600_60_P,
+	XVIDC_VM_2560x1600_60_P_RB,
+	XVIDC_VM_2560x1600_75_P,
+	XVIDC_VM_2560x1600_85_P,
+	XVIDC_VM_2560x1600_120_P_RB,
+	XVIDC_VM_3840x2160_24_P,
+	XVIDC_VM_3840x2160_25_P,
+	XVIDC_VM_3840x2160_30_P,
+	XVIDC_VM_3840x2160_50_P,
+	XVIDC_VM_3840x2160_60_P,
+	XVIDC_VM_4096x2160_24_P,
+	XVIDC_VM_4096x2160_25_P,
+	XVIDC_VM_4096x2160_30_P,
+	XVIDC_VM_4096x2160_50_P,
+	XVIDC_VM_4096x2160_60_P,
+	XVIDC_VM_4096x2160_60_P_RB,
+
+	XVIDC_VM_NUM_SUPPORTED,
+	XVIDC_VM_USE_EDID_PREFERRED,
+	XVIDC_VM_NO_INPUT,
+	XVIDC_VM_NOT_SUPPORTED,
+	XVIDC_VM_CUSTOM,
+
+	/* Marks beginning/end of interlaced/progressive modes in the table. */
+	XVIDC_VM_INTL_START = XVIDC_VM_720x480_60_I,
+	XVIDC_VM_PROG_START = XVIDC_VM_640x350_85_P,
+	XVIDC_VM_INTL_END = (XVIDC_VM_PROG_START - 1),
+	XVIDC_VM_PROG_END = (XVIDC_VM_NUM_SUPPORTED - 1),
+
+	/* Common naming. */
+	XVIDC_VM_480_60_I = XVIDC_VM_720x480_60_I,
+	XVIDC_VM_576_50_I = XVIDC_VM_720x576_50_I,
+	XVIDC_VM_1080_50_I = XVIDC_VM_1920x1080_50_I,
+	XVIDC_VM_1080_60_I = XVIDC_VM_1920x1080_60_I,
+	XVIDC_VM_VGA_60_P = XVIDC_VM_640x480_60_P,
+	XVIDC_VM_480_60_P = XVIDC_VM_720x480_60_P,
+	XVIDC_VM_SVGA_60_P = XVIDC_VM_800x600_60_P,
+	XVIDC_VM_XGA_60_P = XVIDC_VM_1024x768_60_P,
+	XVIDC_VM_720_50_P = XVIDC_VM_1280x720_50_P,
+	XVIDC_VM_720_60_P = XVIDC_VM_1280x720_60_P,
+	XVIDC_VM_WXGA_60_P = XVIDC_VM_1366x768_60_P,
+	XVIDC_VM_UXGA_60_P = XVIDC_VM_1600x1200_60_P,
+	XVIDC_VM_WSXGA_60_P = XVIDC_VM_1680x1050_60_P,
+	XVIDC_VM_1080_24_P = XVIDC_VM_1920x1080_24_P,
+	XVIDC_VM_1080_25_P = XVIDC_VM_1920x1080_25_P,
+	XVIDC_VM_1080_30_P = XVIDC_VM_1920x1080_30_P,
+	XVIDC_VM_1080_50_P = XVIDC_VM_1920x1080_50_P,
+	XVIDC_VM_1080_60_P = XVIDC_VM_1920x1080_60_P,
+	XVIDC_VM_WUXGA_60_P = XVIDC_VM_1920x1200_60_P,
+	XVIDC_VM_UHD2_60_P = XVIDC_VM_1920x2160_60_P,
+	XVIDC_VM_UHD_24_P = XVIDC_VM_3840x2160_24_P,
+	XVIDC_VM_UHD_25_P = XVIDC_VM_3840x2160_25_P,
+	XVIDC_VM_UHD_30_P = XVIDC_VM_3840x2160_30_P,
+	XVIDC_VM_UHD_60_P = XVIDC_VM_3840x2160_60_P,
+	XVIDC_VM_4K2K_60_P = XVIDC_VM_4096x2160_60_P,
+	XVIDC_VM_4K2K_60_P_RB = XVIDC_VM_4096x2160_60_P_RB,
+} XVidC_VideoMode;
+
+/**
+ * Progressive/interlaced video format.
+ */
+typedef enum {
+	XVIDC_VF_PROGRESSIVE = 0,
+	XVIDC_VF_INTERLACED,
+	XVIDC_VF_UNKNOWN
+} XVidC_VideoFormat;
+
+/**
+ * Frame rate.
+ */
+typedef enum {
+	XVIDC_FR_24HZ = 24,
+	XVIDC_FR_25HZ = 25,
+	XVIDC_FR_30HZ = 30,
+	XVIDC_FR_50HZ = 50,
+	XVIDC_FR_56HZ = 56,
+	XVIDC_FR_60HZ = 60,
+	XVIDC_FR_65HZ = 65,
+	XVIDC_FR_67HZ = 67,
+	XVIDC_FR_70HZ = 70,
+	XVIDC_FR_72HZ = 72,
+	XVIDC_FR_75HZ = 75,
+	XVIDC_FR_85HZ = 85,
+	XVIDC_FR_87HZ = 87,
+	XVIDC_FR_88HZ = 88,
+	XVIDC_FR_100HZ = 100,
+	XVIDC_FR_120HZ = 120,
+	XVIDC_FR_NUM_SUPPORTED = 16,
+	XVIDC_FR_UNKNOWN
+} XVidC_FrameRate;
+
+/**
+ * Color depth - bits per color component.
+ */
+typedef enum {
+	XVIDC_BPC_6 = 6,
+	XVIDC_BPC_8 = 8,
+	XVIDC_BPC_10 = 10,
+	XVIDC_BPC_12 = 12,
+	XVIDC_BPC_14 = 14,
+	XVIDC_BPC_16 = 16,
+	XVIDC_BPC_NUM_SUPPORTED = 6,
+	XVIDC_BPC_UNKNOWN
+} XVidC_ColorDepth;
+
+/**
+ * Pixels per clock.
+ */
+typedef enum {
+	XVIDC_PPC_1 = 1,
+	XVIDC_PPC_2 = 2,
+	XVIDC_PPC_4 = 4,
+	XVIDC_PPC_8 = 8,
+	XVIDC_PPC_NUM_SUPPORTED = 4,
+} XVidC_PixelsPerClock;
+
+/**
+ * Color space format.
+ */
+typedef enum {
+	/* Streaming video formats */
+	XVIDC_CSF_RGB = 0,
+	XVIDC_CSF_YCRCB_444,
+	XVIDC_CSF_YCRCB_422,
+	XVIDC_CSF_YCRCB_420,
+	XVIDC_CSF_YONLY,
+
+	/* 6 empty slots reserved for video formats for future
+	 * extension
+	 */
+
+	/* Video in memory formats */
+	XVIDC_CSF_MEM_RGBX8 = 10,   // [31:0] x:B:G:R 8:8:8:8
+	XVIDC_CSF_MEM_YUVX8,        // [31:0] x:V:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_YUYV8,        // [31:0] V:Y:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_RGBA8,        // [31:0] A:B:G:R 8:8:8:8
+    XVIDC_CSF_MEM_YUVA8,        // [31:0] A:V:U:Y 8:8:8:8
+    XVIDC_CSF_MEM_RGBX10,       // [31:0] x:B:G:R 2:10:10:10
+    XVIDC_CSF_MEM_YUVX10,       // [31:0] x:V:U:Y 2:10:10:10
+    XVIDC_CSF_MEM_RGB565,       // [15:0] B:G:R 5:6:5
+    XVIDC_CSF_MEM_Y_UV8,        // [15:0] Y:Y 8:8, [15:0] V:U 8:8
+    XVIDC_CSF_MEM_Y_UV8_420,    // [15:0] Y:Y 8:8, [15:0] V:U 8:8
+    XVIDC_CSF_MEM_RGB8,         // [23:0] B:G:R 8:8:8
+    XVIDC_CSF_MEM_YUV8,         // [24:0] V:U:Y 8:8:8
+	XVIDC_CSF_MEM_Y_UV10,       // [31:0] x:Y:Y:Y 2:10:10:10 [31:0] x:U:V:U 2:10:10:10
+	XVIDC_CSF_MEM_Y_UV10_420,   // [31:0] x:Y:Y:Y 2:10:10:10 [31:0] x:U:V:U 2:10:10:10
+	XVIDC_CSF_MEM_Y8,           // [31:0] Y:Y:Y:Y 8:8:8:8
+	XVIDC_CSF_MEM_Y10,          // [31:0] x:Y:Y:Y 2:10:10:10
+	XVIDC_CSF_MEM_BGRA8,        // [31:0] A:R:G:B 8:8:8:8
+
+	XVIDC_CSF_NUM_SUPPORTED,    // includes the reserved slots
+	XVIDC_CSF_UNKNOWN,
+	XVIDC_CSF_STRM_START = XVIDC_CSF_RGB,
+	XVIDC_CSF_STRM_END   = XVIDC_CSF_YONLY,
+	XVIDC_CSF_MEM_START  = XVIDC_CSF_MEM_RGBX8,
+	XVIDC_CSF_MEM_END    = (XVIDC_CSF_NUM_SUPPORTED - 1),
+	XVIDC_CSF_NUM_STRM   = (XVIDC_CSF_STRM_END - XVIDC_CSF_STRM_START + 1),
+	XVIDC_CSF_NUM_MEM    = (XVIDC_CSF_MEM_END - XVIDC_CSF_MEM_START + 1)
+} XVidC_ColorFormat;
+
+/**
+ * Color space conversion standard.
+ */
+typedef enum {
+	XVIDC_BT_2020 = 0,
+	XVIDC_BT_709,
+	XVIDC_BT_601,
+	XVIDC_BT_NUM_SUPPORTED,
+	XVIDC_BT_UNKNOWN
+} XVidC_ColorStd;
+
+/**
+ * Color conversion output range.
+ */
+typedef enum {
+	XVIDC_CR_16_235 = 0,
+	XVIDC_CR_16_240,
+	XVIDC_CR_0_255,
+	XVIDC_CR_NUM_SUPPORTED,
+	XVIDC_CR_UNKNOWN_RANGE
+} XVidC_ColorRange;
+
+/**
+ * 3D formats.
+ */
+typedef enum {
+	XVIDC_3D_FRAME_PACKING = 0,	/**< Frame packing.         */
+	XVIDC_3D_FIELD_ALTERNATIVE,	/**< Field alternative.     */
+	XVIDC_3D_LINE_ALTERNATIVE,	/**< Line alternative.      */
+	XVIDC_3D_SIDE_BY_SIDE_FULL,	/**< Side-by-side (full).   */
+	XVIDC_3D_TOP_AND_BOTTOM_HALF,	/**< Top-and-bottom (half). */
+	XVIDC_3D_SIDE_BY_SIDE_HALF,	/**< Side-by-side (half).   */
+	XVIDC_3D_UNKNOWN
+} XVidC_3DFormat;
+
+/**
+ * 3D Sub-sampling methods.
+ */
+typedef enum {
+	XVIDC_3D_SAMPLING_HORIZONTAL = 0, /**< Horizontal sub-sampling. */
+	XVIDC_3D_SAMPLING_QUINCUNX,	  /**< Quincunx matrix.         */
+	XVIDC_3D_SAMPLING_UNKNOWN
+} XVidC_3DSamplingMethod;
+
+/**
+ * 3D Sub-sampling positions.
+ */
+typedef enum {
+	XVIDC_3D_SAMPPOS_OLOR = 0,	/**< Odd/Left,  Odd/Right.  */
+	XVIDC_3D_SAMPPOS_OLER,		/**< Odd/Left,  Even/Right. */
+	XVIDC_3D_SAMPPOS_ELOR,		/**< Even/Left, Odd/Right.  */
+	XVIDC_3D_SAMPPOS_ELER,		/**< Even/Left, Even/Right. */
+	XVIDC_3D_SAMPPOS_UNKNOWN
+} XVidC_3DSamplingPosition;
+
+/****************************** Type Definitions ******************************/
+
+/**
+ * Video timing structure.
+ */
+typedef struct {
+	u16 HActive;
+	u16 HFrontPorch;
+	u16 HSyncWidth;
+	u16 HBackPorch;
+	u16 HTotal;
+	u8 HSyncPolarity;
+	u16 VActive;
+	u16 F0PVFrontPorch;
+	u16 F0PVSyncWidth;
+	u16 F0PVBackPorch;
+	u16 F0PVTotal;
+	u16 F1VFrontPorch;
+	u16 F1VSyncWidth;
+	u16 F1VBackPorch;
+	u16 F1VTotal;
+	u8 VSyncPolarity;
+} XVidC_VideoTiming;
+
+/**
+ * 3D Sampling info structure.
+ */
+typedef struct {
+	XVidC_3DSamplingMethod   Method;
+	XVidC_3DSamplingPosition Position;
+} XVidC_3DSamplingInfo;
+
+/**
+ * 3D info structure.
+ */
+typedef struct {
+	XVidC_3DFormat		Format;
+	XVidC_3DSamplingInfo	Sampling;
+} XVidC_3DInfo;
+
+/**
+ * Video stream structure.
+ */
+typedef struct {
+	XVidC_ColorFormat	ColorFormatId;
+	XVidC_ColorDepth	ColorDepth;
+	XVidC_PixelsPerClock	PixPerClk;
+	XVidC_FrameRate		FrameRate;
+	u8			IsInterlaced;
+	u8			Is3D;
+	XVidC_3DInfo		Info_3D;
+	XVidC_VideoMode		VmId;
+	XVidC_VideoTiming	Timing;
+} XVidC_VideoStream;
+
+/**
+ * Video window structure.
+ */
+typedef struct {
+	u32 StartX;
+	u32 StartY;
+	u32 Width;
+	u32 Height;
+} XVidC_VideoWindow;
+
+/**
+ * Video timing mode from the video timing table.
+ */
+typedef struct {
+	XVidC_VideoMode		VmId;
+	const char		    Name[21];
+	XVidC_FrameRate		FrameRate;
+	XVidC_VideoTiming	Timing;
+} XVidC_VideoTimingMode;
+
+/**
+ * Callback type which represents a custom timer wait handler. This is only
+ * used for Microblaze since it doesn't have a native sleep function. To avoid
+ * dependency on a hardware timer, the default wait functionality is implemented
+ * using loop iterations; this isn't too accurate. Therefore a custom timer
+ * handler is used, the user may implement their own wait implementation.
+ *
+ * @param	TimerPtr is a pointer to the timer instance.
+ * @param	Delay is the duration (msec/usec) to be passed to the timer
+ *		function.
+ *
+*******************************************************************************/
+typedef void (*XVidC_DelayHandler)(void *TimerPtr, u32 Delay);
+
+/**************************** Function Prototypes *****************************/
+
+u32 XVidC_RegisterCustomTimingModes(const XVidC_VideoTimingMode *CustomTable,
+		                            u16 NumElems);
+void XVidC_UnregisterCustomTimingModes(void);
+u32 XVidC_GetPixelClockHzByHVFr(u32 HTotal, u32 VTotal, u8 FrameRate);
+u32 XVidC_GetPixelClockHzByVmId(XVidC_VideoMode VmId);
+XVidC_VideoFormat XVidC_GetVideoFormat(XVidC_VideoMode VmId);
+u8 XVidC_IsInterlaced(XVidC_VideoMode VmId);
+const XVidC_VideoTimingMode* XVidC_GetVideoModeData(XVidC_VideoMode VmId);
+const char *XVidC_GetVideoModeStr(XVidC_VideoMode VmId);
+const char *XVidC_GetFrameRateStr(XVidC_VideoMode VmId);
+const char *XVidC_GetColorFormatStr(XVidC_ColorFormat ColorFormatId);
+XVidC_FrameRate XVidC_GetFrameRate(XVidC_VideoMode VmId);
+const XVidC_VideoTiming* XVidC_GetTimingInfo(XVidC_VideoMode VmId);
+void XVidC_ReportStreamInfo(const XVidC_VideoStream *Stream);
+void XVidC_ReportTiming(const XVidC_VideoTiming *Timing, u8 IsInterlaced);
+const char *XVidC_Get3DFormatStr(XVidC_3DFormat Format);
+u32 XVidC_SetVideoStream(XVidC_VideoStream *VidStrmPtr, XVidC_VideoMode VmId,
+			             XVidC_ColorFormat ColorFormat, XVidC_ColorDepth Bpc,
+			             XVidC_PixelsPerClock Ppc);
+u32 XVidC_Set3DVideoStream(XVidC_VideoStream *VidStrmPtr, XVidC_VideoMode VmId,
+			               XVidC_ColorFormat ColorFormat, XVidC_ColorDepth Bpc,
+			               XVidC_PixelsPerClock Ppc, XVidC_3DInfo *Info3DPtr);
+XVidC_VideoMode XVidC_GetVideoModeId(u32 Width, u32 Height, u32 FrameRate,
+		                             u8 IsInterlaced);
+XVidC_VideoMode XVidC_GetVideoModeIdRb(u32 Width, u32 Height, u32 FrameRate,
+		                               u8 IsInterlaced, u8 RbN);
+XVidC_VideoMode XVidC_GetVideoModeIdWBlanking(const XVidC_VideoTiming *Timing,
+		                                      u32 FrameRate, u8 IsInterlaced);
+
+/******************* Macros (Inline Functions) Definitions ********************/
+
+/*****************************************************************************/
+/**
+ * This macro check if video stream is 3D or 2D.
+ *
+ * @param	VidStreamPtr is a pointer to the XVidC_VideoStream structure.
+ *
+ * @return	3D(1)/2D(0)
+ *
+ * @note	C-style signature:
+ *		u8 XDp_IsStream3D(XVidC_VideoStream *VidStreamPtr)
+ *
+ *****************************************************************************/
+#define XVidC_IsStream3D(VidStreamPtr)       ((VidStreamPtr)->Is3D)
+
+/*************************** Variable Declarations ****************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* XVIDC_H_ */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc_edid.h b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc_edid.h
new file mode 100644
index 0000000..e18f366
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmi-rx/xvidc_edid.h
@@ -0,0 +1,468 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (C) 2015, 2016, 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details
+ *
+*******************************************************************************/
+/******************************************************************************/
+/**
+ *
+ * @file xvidc_edid.h
+ * @addtogroup video_common_v4_0
+ * @{
+ *
+ * Contains macros, definitions, and function declarations related to the
+ * Extended Display Identification Data (EDID) structure which is present in all
+ * monitors. All content in this file is agnostic of communication interface
+ * protocol.
+ *
+ * @note	None.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -----------------------------------------------
+ * 1.0   als  11/09/14 Initial release.
+ * 2.2   als  02/01/16 Functions with pointer arguments that don't modify
+ *                     contents now const.
+ * 4.0   aad  10/26/16 Functions which return fixed point values instead of
+ *		       float
+ * </pre>
+ *
+*******************************************************************************/
+
+#ifndef XVIDC_EDID_H_
+/* Prevent circular inclusions by using protection macros. */
+#define XVIDC_EDID_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************* Include Files ********************************/
+
+#include "xstatus.h"
+#include "xvidc.h"
+
+/************************** Constant Definitions ******************************/
+
+/** @name Address mapping for the base EDID block.
+ * @{
+ */
+#define XVIDC_EDID_HEADER				0x00
+/* Vendor and product identification. */
+#define XVIDC_EDID_VPI_ID_MAN_NAME0			0x08
+#define XVIDC_EDID_VPI_ID_MAN_NAME1			0x09
+#define XVIDC_EDID_VPI_ID_PROD_CODE_LSB			0x0A
+#define XVIDC_EDID_VPI_ID_PROD_CODE_MSB			0x0B
+#define XVIDC_EDID_VPI_ID_SN0				0x0C
+#define XVIDC_EDID_VPI_ID_SN1				0x0D
+#define XVIDC_EDID_VPI_ID_SN2				0x0E
+#define XVIDC_EDID_VPI_ID_SN3				0x0F
+#define XVIDC_EDID_VPI_WEEK_MAN				0x10
+#define XVIDC_EDID_VPI_YEAR				0x11
+/* EDID structure version and revision. */
+#define XVIDC_EDID_STRUCT_VER				0x12
+#define XVIDC_EDID_STRUCT_REV				0x13
+/* Basic display parameters and features. */
+#define XVIDC_EDID_BDISP_VID				0x14
+#define XVIDC_EDID_BDISP_H_SSAR				0x15
+#define XVIDC_EDID_BDISP_V_SSAR				0x16
+#define XVIDC_EDID_BDISP_GAMMA				0x17
+#define XVIDC_EDID_BDISP_FEATURE			0x18
+/* Color characteristics (display x,y chromaticity coordinates). */
+#define XVIDC_EDID_CC_RG_LOW				0x19
+#define XVIDC_EDID_CC_BW_LOW				0x1A
+#define XVIDC_EDID_CC_REDX_HIGH				0x1B
+#define XVIDC_EDID_CC_REDY_HIGH				0x1C
+#define XVIDC_EDID_CC_GREENX_HIGH			0x1D
+#define XVIDC_EDID_CC_GREENY_HIGH			0x1E
+#define XVIDC_EDID_CC_BLUEX_HIGH			0x1F
+#define XVIDC_EDID_CC_BLUEY_HIGH			0x20
+#define XVIDC_EDID_CC_WHITEX_HIGH			0x21
+#define XVIDC_EDID_CC_WHITEY_HIGH			0x22
+/* Established timings. */
+#define XVIDC_EDID_EST_TIMINGS_I			0x23
+#define XVIDC_EDID_EST_TIMINGS_II			0x24
+#define XVIDC_EDID_EST_TIMINGS_MAN			0x25
+/* Standard timings. */
+#define XVIDC_EDID_STD_TIMINGS_H(N)			(0x26 + 2 * (N - 1))
+#define XVIDC_EDID_STD_TIMINGS_AR_FRR(N)		(0x27 + 2 * (N - 1))
+/* 18 byte descriptors. */
+#define XVIDC_EDID_18BYTE_DESCRIPTOR(N)			(0x36 + 18 * (N - 1))
+#define XVIDC_EDID_PTM			(XVIDC_EDID_18BYTE_DESCRIPTOR(1))
+/* - Detailed timing descriptor (DTD) / Preferred timing mode (PTM). */
+#define XVIDC_EDID_DTD_PTM_PIXEL_CLK_KHZ_LSB		0x00
+#define XVIDC_EDID_DTD_PTM_PIXEL_CLK_KHZ_MSB		0x01
+#define XVIDC_EDID_DTD_PTM_HRES_LSB			0x02
+#define XVIDC_EDID_DTD_PTM_HBLANK_LSB			0x03
+#define XVIDC_EDID_DTD_PTM_HRES_HBLANK_U4		0x04
+#define XVIDC_EDID_DTD_PTM_VRES_LSB			0x05
+#define XVIDC_EDID_DTD_PTM_VBLANK_LSB			0x06
+#define XVIDC_EDID_DTD_PTM_VRES_VBLANK_U4		0x07
+#define XVIDC_EDID_DTD_PTM_HFPORCH_LSB			0x08
+#define XVIDC_EDID_DTD_PTM_HSPW_LSB			0x09
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4		0x0A
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2		0x0B
+#define XVIDC_EDID_DTD_PTM_HIMGSIZE_MM_LSB		0x0C
+#define XVIDC_EDID_DTD_PTM_VIMGSIZE_MM_LSB		0x0D
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4		0x0E
+#define XVIDC_EDID_DTD_PTM_HBORDER			0x0F
+#define XVIDC_EDID_DTD_PTM_VBORDER			0x10
+#define XVIDC_EDID_DTD_PTM_SIGNAL			0x11
+
+/* Extension block count. */
+#define XVIDC_EDID_EXT_BLK_COUNT			0x7E
+/* Checksum. */
+#define XVIDC_EDID_CHECKSUM				0x7F
+/* @} */
+
+/******************************************************************************/
+
+/** @name Extended Display Identification Data: Masks, shifts, and values.
+ * @{
+ */
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR0_SHIFT		2
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR0_MASK		(0x1F << 2)
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR1_MASK		0x03
+#define XVIDC_EDID_VPI_ID_MAN_NAME0_CHAR1_POS		3
+#define XVIDC_EDID_VPI_ID_MAN_NAME1_CHAR1_SHIFT		5
+#define XVIDC_EDID_VPI_ID_MAN_NAME1_CHAR2_MASK		0x1F
+
+/* Basic display parameters and features: Video input definition. */
+#define XVIDC_EDID_BDISP_VID_VSI_SHIFT			7
+#define XVIDC_EDID_BDISP_VID_VSI_MASK			(0x01 << 7)
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_SHIFT		5
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_MASK		(0x03 << 5)
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0700_0300_1000	0x0
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0714_0286_1000	0x1
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_1000_0400_1400	0x2
+#define XVIDC_EDID_BDISP_VID_ANA_SLS_0700_0000_0700	0x3
+#define XVIDC_EDID_BDISP_VID_ANA_VID_SETUP_MASK		(0x01 << 4)
+#define XVIDC_EDID_BDISP_VID_ANA_SEP_SYNC_HV_MASK	(0x01 << 3)
+#define XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_H_MASK	(0x01 << 2)
+#define XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_G_MASK	(0x01 << 1)
+#define XVIDC_EDID_BDISP_VID_ANA_SERR_V_SYNC_MASK	(0x01)
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_SHIFT		4
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_MASK		(0x7 << 4)
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_UNDEF		0x0
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_6			0x1
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_8			0x2
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_10			0x3
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_12			0x4
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_14			0x5
+#define XVIDC_EDID_BDISP_VID_DIG_BPC_16			0x6
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_MASK		0xF
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_UNDEF		0x0
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_DVI		0x1
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_HDMIA		0x2
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_HDMIB		0x3
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_MDDI		0x4
+#define XVIDC_EDID_BDISP_VID_DIG_VIS_DP			0x5
+
+/* Basic display parameters and features: Feature support. */
+#define XVIDC_EDID_BDISP_FEATURE_PM_STANDBY_MASK	(0x1 << 7)
+#define XVIDC_EDID_BDISP_FEATURE_PM_SUSPEND_MASK	(0x1 << 6)
+#define XVIDC_EDID_BDISP_FEATURE_PM_OFF_VLP_MASK	(0x1 << 5)
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_SHIFT	3
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MASK	(0x3 << 3)
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MCG	0x0
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_RGB	0x1
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_NRGB	0x2
+#define XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_UNDEF	0x3
+#define XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB444_MASK	(0x1 << 3)
+#define XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB422_MASK	(0x1 << 4)
+#define XVIDC_EDID_BDISP_FEATURE_SRGB_DEF_MASK		(0x1 << 2)
+#define XVIDC_EDID_BDISP_FEATURE_PTM_INC_MASK		(0x1 << 1)
+#define XVIDC_EDID_BDISP_FEATURE_CONTFREQ_MASK		(0x1)
+
+/* Color characteristics (display x,y chromaticity coordinates). */
+#define XVIDC_EDID_CC_HIGH_SHIFT			2
+#define XVIDC_EDID_CC_RBX_LOW_SHIFT			6
+#define XVIDC_EDID_CC_RBY_LOW_SHIFT			4
+#define XVIDC_EDID_CC_RBY_LOW_MASK			(0x3 << 4)
+#define XVIDC_EDID_CC_GWX_LOW_SHIFT			2
+#define XVIDC_EDID_CC_GWX_LOW_MASK			(0x3 << 2)
+#define XVIDC_EDID_CC_GWY_LOW_MASK			(0x3)
+#define XVIDC_EDID_CC_GREENY_HIGH			0x1E
+#define XVIDC_EDID_CC_BLUEX_HIGH			0x1F
+#define XVIDC_EDID_CC_BLUEY_HIGH			0x20
+#define XVIDC_EDID_CC_WHITEX_HIGH			0x21
+#define XVIDC_EDID_CC_WHITEY_HIGH			0x22
+
+/* Established timings. */
+#define XVIDC_EDID_EST_TIMINGS_I_720x400_70_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_I_720x400_88_MASK	(0x1 << 6)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_60_MASK	(0x1 << 5)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_67_MASK	(0x1 << 4)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_72_MASK	(0x1 << 3)
+#define XVIDC_EDID_EST_TIMINGS_I_640x480_75_MASK	(0x1 << 2)
+#define XVIDC_EDID_EST_TIMINGS_I_800x600_56_MASK	(0x1 << 1)
+#define XVIDC_EDID_EST_TIMINGS_I_800x600_60_MASK	(0x1)
+#define XVIDC_EDID_EST_TIMINGS_II_800x600_72_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_II_800x600_75_MASK	(0x1 << 6)
+#define XVIDC_EDID_EST_TIMINGS_II_832x624_75_MASK	(0x1 << 5)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_87_MASK	(0x1 << 4)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_60_MASK	(0x1 << 3)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_70_MASK	(0x1 << 2)
+#define XVIDC_EDID_EST_TIMINGS_II_1024x768_75_MASK	(0x1 << 1)
+#define XVIDC_EDID_EST_TIMINGS_II_1280x1024_75_MASK	(0x1)
+#define XVIDC_EDID_EST_TIMINGS_MAN_1152x870_75_MASK	(0x1 << 7)
+#define XVIDC_EDID_EST_TIMINGS_MAN_MASK			(0x7F)
+
+/* Standard timings. */
+#define XVIDC_EDID_STD_TIMINGS_AR_SHIFT			6
+#define XVIDC_EDID_STD_TIMINGS_AR_16_10			0x0
+#define XVIDC_EDID_STD_TIMINGS_AR_4_3			0x1
+#define XVIDC_EDID_STD_TIMINGS_AR_5_4			0x2
+#define XVIDC_EDID_STD_TIMINGS_AR_16_9			0x3
+#define XVIDC_EDID_STD_TIMINGS_FRR_MASK			(0x3F)
+
+/* Detailed timing descriptor (DTD) / Preferred timing mode (PTM). */
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XBLANK_MASK		0x0F
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XRES_MASK		0xF0
+#define XVIDC_EDID_DTD_PTM_XRES_XBLANK_U4_XRES_SHIFT		4
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VSPW_MASK		0x0F
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VFPORCH_MASK		0xF0
+#define XVIDC_EDID_DTD_PTM_VFPORCH_VSPW_L4_VFPORCH_SHIFT	4
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HFPORCH_MASK		0xC0
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HSPW_MASK		0x30
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VFPORCH_MASK		0x0C
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VSPW_MASK		0x03
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HFPORCH_SHIFT	6
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_HSPW_SHIFT		4
+#define XVIDC_EDID_DTD_PTM_XFPORCH_XSPW_U2_VFPORCH_SHIFT	2
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_VIMGSIZE_MM_MASK	0x0F
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_HIMGSIZE_MM_MASK	0xF0
+#define XVIDC_EDID_DTD_PTM_XIMGSIZE_MM_U4_HIMGSIZE_MM_SHIFT	4
+#define XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_MASK		0x80
+#define XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_SHIFT		7
+#define XVIDC_EDID_DTD_PTM_SIGNAL_HPOLARITY_MASK		0x02
+#define XVIDC_EDID_DTD_PTM_SIGNAL_VPOLARITY_MASK		0x04
+#define XVIDC_EDID_DTD_PTM_SIGNAL_HPOLARITY_SHIFT		1
+#define XVIDC_EDID_DTD_PTM_SIGNAL_VPOLARITY_SHIFT		2
+/* @} */
+
+/******************* Macros (Inline Functions) Definitions ********************/
+
+#define XVidC_EdidIsHeaderValid(E) \
+	!memcmp(E, "\x00\xFF\xFF\xFF\xFF\xFF\xFF\x00", 8)
+
+/* Vendor and product identification: ID manufacturer name. */
+/* void XVidC_EdidGetManName(const u8 *EdidRaw, char ManName[4]); */
+
+/* Vendor and product identification: ID product code. */
+#define XVidC_EdidGetIdProdCode(E) \
+	((u16)((E[XVIDC_EDID_VPI_ID_PROD_CODE_MSB] << 8) | \
+	E[XVIDC_EDID_VPI_ID_PROD_CODE_LSB]))
+
+/* Vendor and product identification: ID serial number. */
+#define XVidC_EdidGetIdSn(E) \
+	((u32)((E[XVIDC_EDID_VPI_ID_SN3] << 24) | \
+	(E[XVIDC_EDID_VPI_ID_SN2] << 16) | (E[XVIDC_EDID_VPI_ID_SN1] << 8) | \
+	E[XVIDC_EDID_VPI_ID_SN0]))
+
+/* Vendor and product identification: Week and year of manufacture or model
+ * year. */
+#define XVidC_EdidGetManWeek(E)		(E[XVIDC_EDID_VPI_WEEK_MAN])
+#define XVidC_EdidGetModManYear(E)	(E[XVIDC_EDID_VPI_YEAR] + 1990)
+#define XVidC_EdidIsYearModel(E)	(XVidC_EdidGetManWeek(E) == 0xFF)
+#define XVidC_EdidIsYearMan(E)		(XVidC_EdidGetManWeek(E) != 0xFF)
+
+/* EDID structure version and revision. */
+#define XVidC_EdidGetStructVer(E)	(E[XVIDC_EDID_STRUCT_VER])
+#define XVidC_EdidGetStructRev(E)	(E[XVIDC_EDID_STRUCT_REV])
+
+/* Basic display parameters and features: Video input definition. */
+#define XVidC_EdidIsDigitalSig(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_VSI_MASK) != 0)
+#define XVidC_EdidIsAnalogSig(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_VSI_MASK) == 0)
+#define XVidC_EdidGetAnalogSigLvlStd(E) \
+	((E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_ANA_SLS_MASK) >> \
+	XVIDC_EDID_BDISP_VID_ANA_SLS_SHIFT)
+#define XVidC_EdidGetAnalogSigVidSetup(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_VID_SETUP_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigSepSyncHv(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_SEP_SYNC_HV_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigCompSyncH(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_H_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigCompSyncG(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_COMP_SYNC_G_MASK) != 0)
+#define XVidC_EdidSuppAnalogSigSerrVsync(E) \
+	((E[XVIDC_EDID_BDISP_VID] & \
+	XVIDC_EDID_BDISP_VID_ANA_SERR_V_SYNC_MASK) != 0)
+/* XVidC_ColorDepth XVidC_EdidGetColorDepth(const u8 *EdidRaw); */
+#define XVidC_EdidGetDigitalSigIfaceStd(E) \
+	(E[XVIDC_EDID_BDISP_VID] & XVIDC_EDID_BDISP_VID_DIG_VIS_MASK)
+
+/* Basic display parameters and features: Horizontal and vertical screen size or
+ * aspect ratio. */
+#define XVidC_EdidIsSsArDefined(E) \
+	((E[XVIDC_EDID_BDISP_H_SSAR] | E[XVIDC_EDID_BDISP_V_SSAR]) != 0)
+#define XVidC_EdidGetSsArH(E)	E[XVIDC_EDID_BDISP_H_SSAR]
+#define XVidC_EdidGetSsArV(E)	E[XVIDC_EDID_BDISP_V_SSAR]
+#define XVidC_EdidIsSsArSs(E) \
+	((XVidC_EdidGetSsArH(E) != 0) && (XVidC_EdidGetSsArV(E) != 0))
+#define XVidC_EdidIsSsArArL(E) \
+	((XVidC_EdidGetSsArH(E) != 0) && (XVidC_EdidGetSsArV(E) == 0))
+#define XVidC_EdidIsSsArArP(E) \
+	((XVidC_EdidGetSsArH(E) == 0) && (XVidC_EdidGetSsArV(E) != 0))
+#define XVidC_EdidGetSsArArL(E) \
+	((float)((XVidC_EdidGetSsArH(E) + 99.0) / 100.0))
+#define XVidC_EdidGetSsArArP(E) \
+	((float)(100.0 / (XVidC_EdidGetSsArV(E) + 99.0)))
+
+/* Basic display parameters and features: Gamma. */
+#define XVidC_EdidIsGammaInExt(E)	(E[XVIDC_EDID_BDISP_GAMMA] == 0xFF)
+#define XVidC_EdidGetGamma(E) \
+	((float)((E[XVIDC_EDID_BDISP_GAMMA] + 100.0) / 100.0))
+
+/* Basic display parameters and features: Feature support. */
+#define XVidC_EdidSuppFeaturePmStandby(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_STANDBY_MASK) != 0)
+#define XVidC_EdidSuppFeaturePmSuspend(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_SUSPEND_MASK) != 0)
+#define XVidC_EdidSuppFeaturePmOffVlp(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PM_OFF_VLP_MASK) != 0)
+#define XVidC_EdidGetFeatureAnaColorType(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_MASK) >> \
+	XVIDC_EDID_BDISP_FEATURE_ANA_COLORTYPE_SHIFT)
+#define XVidC_EdidSuppFeatureDigColorEncYCrCb444(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB444_MASK) != 0)
+#define XVidC_EdidSuppFeatureDigColorEncYCrCb422(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_DIG_COLORENC_YCRCB422_MASK) != 0)
+#define XVidC_EdidIsFeatureSrgbDef(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_SRGB_DEF_MASK) != 0)
+#define XVidC_EdidIsFeaturePtmInc(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_PTM_INC_MASK) != 0)
+#define XVidC_EdidIsFeatureContFreq(E) \
+	((E[XVIDC_EDID_BDISP_FEATURE] & \
+	XVIDC_EDID_BDISP_FEATURE_CONTFREQ_MASK) != 0)
+
+/* Established timings. */
+#define XVidC_EdidSuppEstTimings720x400_70(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_720x400_70_MASK) != 0)
+#define XVidC_EdidSuppEstTimings720x400_88(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_720x400_88_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_67(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_67_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_72(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_72_MASK) != 0)
+#define XVidC_EdidSuppEstTimings640x480_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_640x480_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_56(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_800x600_56_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_I] & \
+	XVIDC_EDID_EST_TIMINGS_I_800x600_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_72(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_800x600_72_MASK) != 0)
+#define XVidC_EdidSuppEstTimings800x600_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_800x600_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings832x624_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_832x624_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_87(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_87_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_60(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_60_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_70(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_70_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1024x768_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1024x768_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1280x1024_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_II] & \
+	XVIDC_EDID_EST_TIMINGS_II_1280x1024_75_MASK) != 0)
+#define XVidC_EdidSuppEstTimings1152x870_75(E) \
+	((E[XVIDC_EDID_EST_TIMINGS_MAN] & \
+	XVIDC_EDID_EST_TIMINGS_MAN_1152x870_75_MASK) != 0)
+#define XVidC_EdidGetTimingsMan(E) \
+	(E[XVIDC_EDID_EST_TIMINGS_MAN] & XVIDC_EDID_EST_TIMINGS_MAN_MASK)
+
+/* Standard timings. */
+#define XVidC_EdidGetStdTimingsH(E, N) \
+	((E[XVIDC_EDID_STD_TIMINGS_H(N)] + 31) * 8)
+#define XVidC_EdidGetStdTimingsAr(E, N) \
+	(E[XVIDC_EDID_STD_TIMINGS_AR_FRR(N)] >> XVIDC_EDID_STD_TIMINGS_AR_SHIFT)
+#define XVidC_EdidGetStdTimingsFrr(E, N) \
+	((E[XVIDC_EDID_STD_TIMINGS_AR_FRR(N)] & \
+	XVIDC_EDID_STD_TIMINGS_FRR_MASK) + 60)
+/* u16 XVidC_EdidGetStdTimingsV(const u8 *EdidRaw, u8 StdTimingsNum); */
+#define XVidC_EdidIsDtdPtmInterlaced(E) \
+	((E[XVIDC_EDID_PTM + XVIDC_EDID_DTD_PTM_SIGNAL] & \
+	XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_MASK) >> \
+	XVIDC_EDID_DTD_PTM_SIGNAL_INTERLACED_SHIFT)
+
+/* Extension block count. */
+#define XVidC_EdidGetExtBlkCount(E)	(E[XVIDC_EDID_EXT_BLK_COUNT])
+
+/* Checksum. */
+#define XVidC_EdidGetChecksum(E)	(E[XVIDC_EDID_CHECKSUM])
+
+/**************************** Function Prototypes *****************************/
+
+/* Vendor and product identification: ID manufacturer name. */
+void XVidC_EdidGetManName(const u8 *EdidRaw, char ManName[4]);
+
+/* Basic display parameters and features: Video input definition. */
+XVidC_ColorDepth XVidC_EdidGetColorDepth(const u8 *EdidRaw);
+
+/* Color characteristics (display x,y chromaticity coordinates). */
+int XVidC_EdidGetCcRedX(const u8 *EdidRaw);
+int XVidC_EdidGetCcRedY(const u8 *EdidRaw);
+int XVidC_EdidGetCcGreenX(const u8 *EdidRaw);
+int XVidC_EdidGetCcGreenY(const u8 *EdidRaw);
+int XVidC_EdidGetCcBlueX(const u8 *EdidRaw);
+int XVidC_EdidGetCcBlueY(const u8 *EdidRaw);
+int XVidC_EdidGetCcWhiteX(const u8 *EdidRaw);
+int XVidC_EdidGetCcWhiteY(const u8 *EdidRaw);
+
+/* Standard timings. */
+u16 XVidC_EdidGetStdTimingsV(const u8 *EdidRaw, u8 StdTimingsNum);
+
+/* Utility functions. */
+u32 XVidC_EdidIsVideoTimingSupported(const u8 *EdidRaw,
+		const XVidC_VideoTimingMode *VtMode);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* XVIDC_EDID_H_ */
+/** @} */
diff --git a/drivers/staging/xilinx/hdmi/xilinx-hdmirx.c b/drivers/staging/xilinx/hdmi/xilinx-hdmirx.c
new file mode 100644
index 0000000..9b146ac
--- /dev/null
+++ b/drivers/staging/xilinx/hdmi/xilinx-hdmirx.c
@@ -0,0 +1,1280 @@
+/*
+ * Xilinx Video HDMI RX Subsystem driver implementing a V4L2 subdevice
+ *
+ * Copyright (C) 2016-2017 Leon Woestenberg <leon@sidebranch.com>
+ * Copyright (C) 2016-2017 Xilinx, Inc.
+ *
+ * Authors: Leon Woestenberg <leon@sidebranch.com>
+ *          Rohit Consul <rohitco@xilinx.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* if both both DEBUG and DEBUG_TRACE are defined, trace_printk() is used */
+//#define DEBUG
+//#define DEBUG_TRACE
+
+//#define DEBUG_MUTEX
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+#include <linux/v4l2-dv-timings.h>
+#include <linux/firmware.h>
+#include <linux/clk.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-dv-timings.h>
+
+#include "linux/phy/phy-vphy.h"
+
+#include "xilinx-vip.h"
+
+/* baseline driver includes */
+#include "xilinx-hdmi-rx/xv_hdmirxss.h"
+#include "xilinx-hdmi-rx/xil_printf.h"
+#include "xilinx-hdmi-rx/xstatus.h"
+
+/* select either trace or printk logging */
+#ifdef DEBUG_TRACE
+#define do_hdmi_dbg(format, ...) do { \
+  trace_printk("xlnx-hdmi-rxss: " format, ##__VA_ARGS__); \
+} while(0)
+#else
+#define do_hdmi_dbg(format, ...) do { \
+  printk(KERN_DEBUG "xlnx-hdmi-rxss: " format, ##__VA_ARGS__); \
+} while(0)
+#endif
+
+/* Use hdmi_dbg to debug control flow.
+ * Use dev_err() to report errors to user.
+ * either enable or disable debugging. */
+#ifdef DEBUG
+#  define hdmi_dbg(x...) do_hdmi_dbg(x)
+#else
+#  define hdmi_dbg(x...)
+#endif
+
+#define HDMI_MAX_LANES	4
+
+#define EDID_BLOCKS_MAX 10
+#define EDID_BLOCK_SIZE 128
+
+#if (defined(DEBUG_MUTEX) && defined(DEBUG))
+/* storage for source code line number where mutex was last locked, -1 otherwise */
+static int hdmi_mutex_line = -1;
+/* if mutex is locked, print the stored line number. lock the mutex.
+ * keep this macro on a single line, so that the C __LINE__ macro is correct
+ */
+#  define hdmi_mutex_lock(x) do { if (mutex_is_locked(x)) hdmi_dbg("@line %d waiting for mutex owner @line %d\n", __LINE__, hdmi_mutex_line); mutex_lock(x); hdmi_mutex_line = __LINE__; } while(0)
+#  define hdmi_mutex_unlock(x) do { hdmi_mutex_line = -1; mutex_unlock(x); } while(0)
+/* non-debug variant */
+#else
+#  define hdmi_mutex_lock(x) mutex_lock(x)
+#  define hdmi_mutex_unlock(x) mutex_unlock(x)
+#endif
+
+struct xhdmi_device {
+	struct device xvip;
+	struct device *dev;
+	void __iomem *iomem;
+	struct clk *clk;
+	/* interrupt number */
+	int irq;
+	bool teardown;
+	struct phy *phy[HDMI_MAX_LANES];
+
+	/* mutex to prevent concurrent access to this structure */
+	struct mutex xhdmi_mutex;
+
+	/* protects concurrent access from interrupt context */
+	spinlock_t irq_lock;
+
+	/* schedule (future) work */
+	struct workqueue_struct *work_queue;
+	struct delayed_work delayed_work_enable_hotplug;
+
+	struct v4l2_subdev subdev;
+
+	/* V4L media output pad to construct the video pipeline */
+	struct media_pad pad;
+
+	/* https://linuxtv.org/downloads/v4l-dvb-apis/subdev.html#v4l2-mbus-framefmt */
+	struct v4l2_mbus_framefmt detected_format;
+
+	struct v4l2_dv_timings detected_timings;
+	const struct xvip_video_format *vip_format;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	bool cable_is_connected;
+	bool hdmi_stream_is_up;
+
+	struct clk *axi_lite_clk;
+
+	/* copy of user specified EDID block, if any */
+	u8 edid_user[EDID_BLOCKS_MAX * EDID_BLOCK_SIZE];
+	/* number of actual blocks valid in edid_user */
+	int edid_user_blocks;
+
+	/* number of EDID blocks supported by IP */
+	int edid_blocks_max;
+
+	/* configuration for the baseline subsystem driver instance */
+	XV_HdmiRxSs_Config config;
+	/* bookkeeping for the baseline subsystem driver instance */
+	XV_HdmiRxSs xv_hdmirxss;
+	/* pointer to xvphy */
+	XVphy *xvphy;
+	/* sub core interrupt status registers */
+	u32 IntrStatus[7];
+};
+
+// Xilinx EDID
+static const u8 xilinx_edid[] = {
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x61, 0x98, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12,
+	0x1F, 0x19, 0x01, 0x03, 0x80, 0x59, 0x32, 0x78, 0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
+	0x0F, 0x50, 0x54, 0x21, 0x08, 0x00, 0x71, 0x4F, 0x81, 0xC0, 0x81, 0x00, 0x81, 0x80, 0x95, 0x00,
+	0xA9, 0xC0, 0xB3, 0x00, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
+	0x45, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x58, 0x49, 0x4C,
+	0x49, 0x4E, 0x58, 0x20, 0x48, 0x44, 0x4D, 0x49, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0C,
+	0x02, 0x03, 0x34, 0x71, 0x57, 0x61, 0x10, 0x1F, 0x04, 0x13, 0x05, 0x14, 0x20, 0x21, 0x22, 0x5D,
+	0x5E, 0x5F, 0x60, 0x65, 0x66, 0x62, 0x63, 0x64, 0x07, 0x16, 0x03, 0x12, 0x23, 0x09, 0x07, 0x07,
+	0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x78, 0x3C, 0xE3, 0x0F, 0x01, 0xE0, 0x67, 0xD8, 0x5D, 0xC4,
+	0x01, 0x78, 0x80, 0x07, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00,
+	0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x08, 0xE8, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
+	0x8A, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x04, 0x74, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80,
+	0xB0, 0x58, 0x8A, 0x00, 0x20, 0x52, 0x31, 0x00, 0x00, 0x1E, 0x66, 0x21, 0x56, 0xAA, 0x51, 0x00,
+	0x1E, 0x30, 0x46, 0x8F, 0x33, 0x00, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x2E
+};
+
+static inline struct xhdmi_device *to_xhdmi(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xhdmi_device, subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xhdmi_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	/* HDMI does not need to be enabled when we start streaming */
+	printk(KERN_INFO "xhdmi_s_stream enable = %d\n", enable);
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+ /* https://linuxtv.org/downloads/v4l-dvb-apis/vidioc-dv-timings-cap.html */
+
+/* https://linuxtv.org/downloads/v4l-dvb-apis/vidioc-subdev-g-fmt.html */
+static struct v4l2_mbus_framefmt *
+__xhdmi_get_pad_format_ptr(struct xhdmi_device *xhdmi,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		hdmi_dbg("__xhdmi_get_pad_format(): V4L2_SUBDEV_FORMAT_TRY\n");
+		return v4l2_subdev_get_try_format(&xhdmi->subdev, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		hdmi_dbg("__xhdmi_get_pad_format(): V4L2_SUBDEV_FORMAT_ACTIVE\n");
+		hdmi_dbg("detected_format->width = %u\n", xhdmi->detected_format.width);
+		return &xhdmi->detected_format;
+	default:
+		return NULL;
+	}
+}
+
+static int xhdmi_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+	hdmi_dbg("xhdmi_get_format\n");
+
+	if (fmt->pad > 0)
+		return -EINVAL;
+
+	/* copy either try or currently-active (i.e. detected) format to caller */
+	fmt->format = *__xhdmi_get_pad_format_ptr(xhdmi, cfg, fmt->pad, fmt->which);
+
+	hdmi_dbg("xhdmi_get_format, height = %u\n", fmt->format.height);
+
+	return 0;
+}
+
+/* we must modify the requested format to match what the hardware can provide */
+static int xhdmi_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+	hdmi_dbg("xhdmi_set_format\n");
+	if (fmt->pad > 0)
+		return -EINVAL;
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	/* there is nothing we can take from the format requested by the caller,
+	 * by convention we must return the active (i.e. detected) format */
+	fmt->format = xhdmi->detected_format;
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+	return 0;
+}
+
+/* https://linuxtv.org/downloads/v4l-dvb-apis-new/media/kapi/v4l2-subdev.html#v4l2-sub-device-functions-and-data-structures
+ * https://linuxtv.org/downloads/v4l-dvb-apis/vidioc-g-edid.html
+ */
+static int xhdmi_get_edid(struct v4l2_subdev *subdev, struct v4l2_edid *edid) {
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+	int do_copy = 1;
+	if (edid->pad > 0)
+		return -EINVAL;
+	if (edid->start_block != 0)
+		return -EINVAL;
+	/* caller is only interested in the size of the EDID? */
+	if ((edid->start_block == 0) && (edid->blocks == 0)) do_copy = 0;
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	/* user EDID active? */
+	if (xhdmi->edid_user_blocks) {
+		if (do_copy)
+			memcpy(edid->edid, xhdmi->edid_user, 128 * xhdmi->edid_user_blocks);
+		edid->blocks = xhdmi->edid_user_blocks;
+	} else {
+		if (do_copy)
+			memcpy(edid->edid, &xilinx_edid[0], sizeof(xilinx_edid));
+		edid->blocks = sizeof(xilinx_edid) / 128;
+	}
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+	return 0;
+}
+
+static void xhdmi_set_hpd(struct xhdmi_device *xhdmi, int enable)
+{
+	XV_HdmiRxSs *HdmiRxSsPtr;
+	BUG_ON(!xhdmi);
+	HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	XV_HdmiRx_SetHpd(HdmiRxSsPtr->HdmiRxPtr, enable);
+}
+
+static void xhdmi_delayed_work_enable_hotplug(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct xhdmi_device *xhdmi = container_of(dwork, struct xhdmi_device,
+						delayed_work_enable_hotplug);
+	XV_HdmiRxSs *HdmiRxSsPtr;
+	BUG_ON(!xhdmi);
+	HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+
+	XV_HdmiRx_SetHpd(HdmiRxSsPtr->HdmiRxPtr, 1);
+}
+
+static int xhdmi_set_edid(struct v4l2_subdev *subdev, struct v4l2_edid *edid) {
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	if (edid->pad > 0)
+		return -EINVAL;
+	if (edid->start_block != 0)
+		return -EINVAL;
+	if (edid->blocks > xhdmi->edid_blocks_max) {
+		/* notify caller of how many EDID blocks this driver supports */
+		edid->blocks = xhdmi->edid_blocks_max;
+		return -E2BIG;
+	}
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	xhdmi->edid_user_blocks = edid->blocks;
+
+	/* Disable hotplug and I2C access to EDID RAM from DDC port */
+	cancel_delayed_work_sync(&xhdmi->delayed_work_enable_hotplug);
+	xhdmi_set_hpd(xhdmi, 0);
+
+	if (edid->blocks) {
+		memcpy(xhdmi->edid_user, edid->edid, 128 * edid->blocks);
+		XV_HdmiRxSs_LoadEdid(HdmiRxSsPtr, (u8 *)&xhdmi->edid_user, 128 * xhdmi->edid_user_blocks);
+		/* enable hotplug after 100 ms */
+		queue_delayed_work(xhdmi->work_queue,
+				&xhdmi->delayed_work_enable_hotplug, HZ / 10);
+	}
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+static int xhdmi_enum_frame_size(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->pad > 0)
+		return -EINVAL;
+	/* we support a non-discrete set, i.e. contiguous range of frame sizes,
+	 * do not return a discrete set */
+	return 0;
+}
+
+static int xhdmi_dv_timings_cap(struct v4l2_subdev *subdev,
+		struct v4l2_dv_timings_cap *cap)
+{
+	if (cap->pad != 0)
+		return -EINVAL;
+	cap->type = V4L2_DV_BT_656_1120;
+	cap->bt.max_width = 4096;
+	cap->bt.max_height = 2160;
+	cap->bt.min_pixelclock = 25000000;
+	cap->bt.max_pixelclock = 297000000;
+	cap->bt.standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+			 V4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT;
+	cap->bt.capabilities = V4L2_DV_BT_CAP_PROGRESSIVE |
+		V4L2_DV_BT_CAP_REDUCED_BLANKING | V4L2_DV_BT_CAP_CUSTOM;
+	return 0;
+}
+
+static int xhdmi_query_dv_timings(struct v4l2_subdev *subdev,
+			struct v4l2_dv_timings *timings)
+{
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+
+	if (!timings)
+		return -EINVAL;
+
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	if (!xhdmi->hdmi_stream_is_up) {
+		hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+		return -ENOLINK;
+	}
+
+	/* copy detected timings into destination */
+	*timings = xhdmi->detected_timings;
+
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+	return 0;
+}
+
+/* struct v4l2_subdev_internal_ops.open */
+static int xhdmi_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xhdmi_device *xhdmi = to_xhdmi(subdev);
+	(void)xhdmi;
+	hdmi_dbg("xhdmi_open\n");
+	return 0;
+}
+
+/* struct v4l2_subdev_internal_ops.close */
+static int xhdmi_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	hdmi_dbg("xhdmi_close\n");
+	return 0;
+}
+
+static int xhdmi_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	hdmi_dbg("xhdmi_s_ctrl\n");
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xhdmi_ctrl_ops = {
+	.s_ctrl	= xhdmi_s_ctrl,
+};
+
+static struct v4l2_subdev_core_ops xhdmi_core_ops = {
+};
+
+static struct v4l2_subdev_video_ops xhdmi_video_ops = {
+	.s_stream = xhdmi_s_stream,
+	.query_dv_timings = xhdmi_query_dv_timings,
+};
+
+/* If the subdev driver intends to process video and integrate with the media framework,
+ * it must implement format related functionality using v4l2_subdev_pad_ops instead of
+ * v4l2_subdev_video_ops. */
+static struct v4l2_subdev_pad_ops xhdmi_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xhdmi_enum_frame_size,
+	.get_fmt			= xhdmi_get_format,
+	.set_fmt			= xhdmi_set_format,
+	.get_edid			= xhdmi_get_edid,
+	.set_edid			= xhdmi_set_edid,
+	.dv_timings_cap		= xhdmi_dv_timings_cap,
+};
+
+static struct v4l2_subdev_ops xhdmi_ops = {
+	.core   = &xhdmi_core_ops,
+	.video  = &xhdmi_video_ops,
+	.pad    = &xhdmi_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xhdmi_internal_ops = {
+	.open	= xhdmi_open,
+	.close	= xhdmi_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xhdmi_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Power Management
+ */
+
+static int __maybe_unused xhdmi_pm_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int __maybe_unused xhdmi_pm_resume(struct device *dev)
+{
+	return 0;
+}
+
+void HdmiRx_PioIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_TmrIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_VtdIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_DdcIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_AuxIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_AudIntrHandler(XV_HdmiRx *InstancePtr);
+void HdmiRx_LinkStatusIntrHandler(XV_HdmiRx *InstancePtr);
+
+void XV_HdmiRxSs_IntrEnable(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+	XV_HdmiRx_PioIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_TmrIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_VtdIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_DdcIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_AuxIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_AudioIntrEnable(HdmiRxSsPtr->HdmiRxPtr);
+}
+
+void XV_HdmiRxSs_IntrDisable(XV_HdmiRxSs *HdmiRxSsPtr)
+{
+	XV_HdmiRx_PioIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_TmrIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_VtdIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_DdcIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_AuxIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_AudioIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+	XV_HdmiRx_LinkIntrDisable(HdmiRxSsPtr->HdmiRxPtr);
+}
+
+static irqreturn_t hdmirx_irq_handler(int irq, void *dev_id)
+{
+	struct xhdmi_device *xhdmi;
+	XV_HdmiRxSs *HdmiRxSsPtr;
+	unsigned long flags;
+	BUG_ON(!dev_id);
+	xhdmi = (struct xhdmi_device *)dev_id;
+	HdmiRxSsPtr = (XV_HdmiRxSs *)&xhdmi->xv_hdmirxss;
+	BUG_ON(!HdmiRxSsPtr->HdmiRxPtr);
+
+	if (HdmiRxSsPtr->IsReady != XIL_COMPONENT_IS_READY) {
+		printk(KERN_INFO "hdmirx_irq_handler(): HDMI RX SS is not initialized?!\n");
+	}
+
+	/* read status registers */
+	xhdmi->IntrStatus[0] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_PIO_STA_OFFSET)) & (XV_HDMIRX_PIO_STA_IRQ_MASK);
+	xhdmi->IntrStatus[1] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_TMR_STA_OFFSET)) & (XV_HDMIRX_TMR_STA_IRQ_MASK);
+	xhdmi->IntrStatus[2] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_VTD_STA_OFFSET)) & (XV_HDMIRX_VTD_STA_IRQ_MASK);
+	xhdmi->IntrStatus[3] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_DDC_STA_OFFSET)) & (XV_HDMIRX_DDC_STA_IRQ_MASK);
+	xhdmi->IntrStatus[4] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_AUX_STA_OFFSET)) & (XV_HDMIRX_AUX_STA_IRQ_MASK);
+	xhdmi->IntrStatus[5] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_AUD_STA_OFFSET)) & (XV_HDMIRX_AUD_STA_IRQ_MASK);
+	xhdmi->IntrStatus[6] = XV_HdmiRx_ReadReg(HdmiRxSsPtr->HdmiRxPtr->Config.BaseAddress, (XV_HDMIRX_LNKSTA_STA_OFFSET)) & (XV_HDMIRX_LNKSTA_STA_IRQ_MASK);
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	/* mask interrupt request */
+	XV_HdmiRxSs_IntrDisable(HdmiRxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	/* call bottom-half */
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hdmirx_irq_thread(int irq, void *dev_id)
+{
+	struct xhdmi_device *xhdmi;
+	XV_HdmiRxSs *HdmiRxSsPtr;
+	unsigned long flags;
+
+	BUG_ON(!dev_id);
+	xhdmi = (struct xhdmi_device *)dev_id;
+	if (xhdmi->teardown) {
+		printk(KERN_INFO "irq_thread: teardown\n");
+		return IRQ_HANDLED;
+	}
+	HdmiRxSsPtr = (XV_HdmiRxSs *)&xhdmi->xv_hdmirxss;
+	BUG_ON(!HdmiRxSsPtr->HdmiRxPtr);
+
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	/* call baremetal interrupt handler, this in turn will
+	 * call the registed callbacks functions */
+
+	if (xhdmi->IntrStatus[0]) HdmiRx_PioIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[1]) HdmiRx_TmrIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[2]) HdmiRx_VtdIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[3]) HdmiRx_DdcIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[4]) HdmiRx_AuxIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[5]) HdmiRx_AudIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+	if (xhdmi->IntrStatus[6]) HdmiRx_LinkStatusIntrHandler(HdmiRxSsPtr->HdmiRxPtr);
+
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	/* unmask interrupt request */
+	XV_HdmiRxSs_IntrEnable(HdmiRxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* callbacks from HDMI RX SS interrupt handler
+ * these are called with the xhdmi->mutex locked and the xvphy_mutex non-locked
+ * to prevent mutex deadlock, always lock the xhdmi first, then the xvphy mutex */
+static void RxConnectCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	XVphy *VphyPtr = xhdmi->xvphy;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	if (!xhdmi || !HdmiRxSsPtr || !VphyPtr) return;
+
+	xhdmi->cable_is_connected = !!HdmiRxSsPtr->IsStreamConnected;
+	hdmi_dbg("RxConnectCallback(): cable is %sconnected.\n", xhdmi->cable_is_connected? "": "dis");
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+	/* RX cable is connected? */
+	if (HdmiRxSsPtr->IsStreamConnected) {
+		XVphy_IBufDsEnable(VphyPtr, 0, XVPHY_DIR_RX, (TRUE));
+	} else {
+		/* clear GT RX TMDS clock ratio */
+		VphyPtr->HdmiRxTmdsClockRatio = 0;
+		XVphy_IBufDsEnable(VphyPtr, 0, XVPHY_DIR_RX, (FALSE));
+	}
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+}
+
+static void RxAuxCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	u8 AuxBuffer[36];
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	if (!xhdmi || !HdmiRxSsPtr) return;
+	// Copy the RX packet into the local buffer
+	memcpy(AuxBuffer, XV_HdmiRxSs_GetAuxiliary(HdmiRxSsPtr), sizeof(AuxBuffer));
+}
+
+static void RxAudCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;\
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	if (!xhdmi || !HdmiRxSsPtr) return;
+	hdmi_dbg("RxAudCallback()\n");
+	(void)HdmiRxSsPtr;
+}
+
+static void RxLnkStaCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	if (!xhdmi || !HdmiRxSsPtr) return;
+	(void)HdmiRxSsPtr;
+}
+
+static void RxStreamDownCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	if (!xhdmi || !HdmiRxSsPtr) return;
+	(void)HdmiRxSsPtr;
+	hdmi_dbg("RxStreamDownCallback()\n");
+	xhdmi->hdmi_stream_is_up = 0;
+}
+
+static void RxStreamInitCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	XVphy *VphyPtr = xhdmi->xvphy;
+	XVidC_VideoStream *HdmiRxSsVidStreamPtr;
+	u32 Status;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	BUG_ON(!VphyPtr);
+	if (!xhdmi || !HdmiRxSsPtr || !VphyPtr) return;
+	hdmi_dbg("RxStreamInitCallback\r\n");
+	// Calculate RX MMCM parameters
+	// In the application the YUV422 colordepth is 12 bits
+	// However the HDMI transports YUV422 in 8 bits.
+	// Therefore force the colordepth to 8 bits when the colorspace is YUV422
+
+	HdmiRxSsVidStreamPtr = XV_HdmiRxSs_GetVideoStream(HdmiRxSsPtr);
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	if (HdmiRxSsVidStreamPtr->ColorFormatId == XVIDC_CSF_YCRCB_422) {
+		Status = XVphy_HdmiCfgCalcMmcmParam(VphyPtr, 0, XVPHY_CHANNEL_ID_CH1,
+				XVPHY_DIR_RX,
+				HdmiRxSsVidStreamPtr->PixPerClk,
+				XVIDC_BPC_8);
+	// Other colorspaces
+	} else {
+		Status = XVphy_HdmiCfgCalcMmcmParam(VphyPtr, 0, XVPHY_CHANNEL_ID_CH1,
+				XVPHY_DIR_RX,
+				HdmiRxSsVidStreamPtr->PixPerClk,
+				HdmiRxSsVidStreamPtr->ColorDepth);
+	}
+
+	if (Status == XST_FAILURE) {
+		xvphy_mutex_unlock(xhdmi->phy[0]);
+		return;
+	}
+
+	// Enable and configure RX MMCM
+	XVphy_MmcmStart(VphyPtr, 0, XVPHY_DIR_RX);
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+}
+
+/* @TODO Once this upstream V4L2 patch lands, consider VIC support: https://patchwork.linuxtv.org/patch/37137/ */
+static void RxStreamUpCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	XVidC_VideoStream *Stream;
+	BUG_ON(!xhdmi);
+	BUG_ON(!HdmiRxSsPtr);
+	BUG_ON(!HdmiRxSsPtr->HdmiRxPtr);
+	if (!xhdmi || !HdmiRxSsPtr || !HdmiRxSsPtr->HdmiRxPtr) return;
+	hdmi_dbg("RxStreamUpCallback((; stream is up.\n");
+	Stream = &HdmiRxSsPtr->HdmiRxPtr->Stream.Video;
+#ifdef DEBUG
+	XVidC_ReportStreamInfo(Stream);
+	XV_HdmiRx_DebugInfo(HdmiRxSsPtr->HdmiRxPtr);
+#endif
+	/* http://lxr.free-electrons.com/source/include/uapi/linux/videodev2.h#L1229 */
+	xhdmi->detected_format.width = Stream->Timing.HActive;
+	xhdmi->detected_format.height = Stream->Timing.VActive;
+
+	xhdmi->detected_format.field = Stream->IsInterlaced? V4L2_FIELD_INTERLACED: V4L2_FIELD_NONE;
+	/* https://linuxtv.org/downloads/v4l-dvb-apis/ch02s05.html#v4l2-colorspace */
+	if (Stream->ColorFormatId == XVIDC_CSF_RGB) {
+		hdmi_dbg("xhdmi->detected_format.colorspace = V4L2_COLORSPACE_SRGB\n");
+		xhdmi->detected_format.colorspace = V4L2_COLORSPACE_SRGB;
+	} else {
+		hdmi_dbg("xhdmi->detected_format.colorspace = V4L2_COLORSPACE_REC709\n");
+		xhdmi->detected_format.colorspace = V4L2_COLORSPACE_REC709;
+	}
+
+	/* https://linuxtv.org/downloads/v4l-dvb-apis/subdev.html#v4l2-mbus-framefmt */
+	/* see UG934 page 8 */
+	/* the V4L2 media bus fmt codes match the AXI S format, and match those from TPG */
+	if (Stream->ColorFormatId == XVIDC_CSF_RGB) {
+		/* red blue green */
+		xhdmi->detected_format.code = MEDIA_BUS_FMT_RBG888_1X24;
+		hdmi_dbg("XVIDC_CSF_RGB -> MEDIA_BUS_FMT_RBG888_1X24\n");
+	} else if (Stream->ColorFormatId == XVIDC_CSF_YCRCB_444) {
+		xhdmi->detected_format.code = MEDIA_BUS_FMT_VUY8_1X24;
+		hdmi_dbg("XVIDC_CSF_YCRCB_444 -> MEDIA_BUS_FMT_VUY8_1X24\n");
+	} else if (Stream->ColorFormatId == XVIDC_CSF_YCRCB_422) {
+		xhdmi->detected_format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+		hdmi_dbg("XVIDC_CSF_YCRCB_422 -> MEDIA_BUS_FMT_UYVY8_1X16\n");
+	} else if (Stream->ColorFormatId == XVIDC_CSF_YCRCB_420) {
+		/* similar mapping as 4:2:2 w/ omitted chroma every other line */
+		xhdmi->detected_format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+		hdmi_dbg("XVIDC_CSF_YCRCB_420 -> MEDIA_BUS_FMT_UYVY8_1X16\n");
+	}
+
+	xhdmi->detected_format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	xhdmi->detected_format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	xhdmi->detected_format.quantization = V4L2_QUANTIZATION_DEFAULT;
+
+	/* map to v4l2_dv_timings */
+	xhdmi->detected_timings.type =  V4L2_DV_BT_656_1120;
+
+	/* Read Active Pixels */
+	xhdmi->detected_timings.bt.width = Stream->Timing.HActive;
+	/* Active lines field 1 */
+	xhdmi->detected_timings.bt.height = Stream->Timing.VActive;
+	/* Interlaced */
+	xhdmi->detected_timings.bt.interlaced = !!Stream->IsInterlaced;
+	xhdmi->detected_timings.bt.polarities =
+	/* Vsync polarity, Positive == 1 */
+		(Stream->Timing.VSyncPolarity? V4L2_DV_VSYNC_POS_POL: 0) |
+	/* Hsync polarity, Positive == 1 */
+		(Stream->Timing.HSyncPolarity? V4L2_DV_HSYNC_POS_POL: 0);
+
+	/* from xvid.c:XVidC_GetPixelClockHzByVmId() but without VmId */
+	if (Stream->IsInterlaced) {
+		xhdmi->detected_timings.bt.pixelclock =
+			(Stream->Timing.F0PVTotal + Stream->Timing.F1VTotal) *
+			Stream->FrameRate / 2;
+	} else {
+		xhdmi->detected_timings.bt.pixelclock =
+			Stream->Timing.F0PVTotal * Stream->FrameRate;
+	}
+	xhdmi->detected_timings.bt.pixelclock *= Stream->Timing.HTotal;
+
+	hdmi_dbg("HdmiRxSsPtr->HdmiRxPtr->Stream.PixelClk = %d\n", HdmiRxSsPtr->HdmiRxPtr->Stream.PixelClk);
+	/* Read HFront Porch */
+	xhdmi->detected_timings.bt.hfrontporch = Stream->Timing.HFrontPorch;
+	/* Read Hsync Width */
+	xhdmi->detected_timings.bt.hsync = Stream->Timing.HSyncWidth;
+	/* Read HBack Porch */
+	xhdmi->detected_timings.bt.hbackporch = Stream->Timing.HBackPorch;
+	/* Read VFront Porch field 1*/
+	xhdmi->detected_timings.bt.vfrontporch = Stream->Timing.F0PVFrontPorch;
+	/* Read VSync Width field 1*/
+	xhdmi->detected_timings.bt.vsync = Stream->Timing.F0PVSyncWidth;
+	/* Read VBack Porch field 1 */
+	xhdmi->detected_timings.bt.vbackporch = Stream->Timing.F0PVBackPorch;
+	/* Read VFront Porch field 2*/
+	xhdmi->detected_timings.bt.il_vfrontporch = Stream->Timing.F1VFrontPorch;
+	/* Read VSync Width field 2*/
+	xhdmi->detected_timings.bt.il_vsync = Stream->Timing.F1VSyncWidth;
+	/* Read VBack Porch field 2 */
+	xhdmi->detected_timings.bt.il_vbackporch = Stream->Timing.F1VBackPorch;
+	xhdmi->detected_timings.bt.standards = V4L2_DV_BT_STD_CEA861;
+	xhdmi->detected_timings.bt.flags = V4L2_DV_FL_IS_CE_VIDEO;
+
+	(void)Stream->VmId;
+
+	xhdmi->hdmi_stream_is_up = 1;
+#ifdef DEBUG	
+	v4l2_print_dv_timings("xilinx-hdmi-rx", "", & xhdmi->detected_timings, 1);
+#endif	
+}
+
+/* Called from non-interrupt context with xvphy mutex locked
+ */
+static void VphyHdmiRxInitCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XV_HdmiRxSs *HdmiRxSsPtr = &xhdmi->xv_hdmirxss;
+	XVphy *VphyPtr = xhdmi->xvphy;
+	BUG_ON(!xhdmi);
+	BUG_ON(!VphyPtr);
+	BUG_ON(!xhdmi->phy[0]);
+	if (!xhdmi || !VphyPtr) return;
+	hdmi_dbg("VphyHdmiRxInitCallback()\n");
+
+	/* a pair of mutexes must be locked in fixed order to prevent deadlock,
+	 * and the order is RX SS then XVPHY, so first unlock XVPHY then lock both */
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	XV_HdmiRxSs_RefClockChangeInit(HdmiRxSsPtr);
+	/* @NOTE maybe implement xvphy_set_hdmirx_tmds_clockratio(); */
+	VphyPtr->HdmiRxTmdsClockRatio = HdmiRxSsPtr->TMDSClockRatio;
+	/* unlock RX SS but keep XVPHY locked */
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+}
+
+/* Called from non-interrupt context with xvphy mutex locked
+ */
+static void VphyHdmiRxReadyCallback(void *CallbackRef)
+{
+	struct xhdmi_device *xhdmi = (struct xhdmi_device *)CallbackRef;
+	XVphy *VphyPtr = xhdmi->xvphy;
+	XVphy_PllType RxPllType;
+	BUG_ON(!xhdmi);
+	BUG_ON(!VphyPtr);
+	BUG_ON(!xhdmi->phy[0]);
+	if (!xhdmi || !VphyPtr) return;
+	hdmi_dbg("VphyHdmiRxReadyCallback()\n");
+
+	/* a pair of mutexes must be locked in fixed order to prevent deadlock,
+	 * and the order is RX SS then XVPHY, so first unlock XVPHY then lock both */
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+	xvphy_mutex_lock(xhdmi->phy[0]);
+
+	RxPllType = XVphy_GetPllType(VphyPtr, 0, XVPHY_DIR_RX,
+		XVPHY_CHANNEL_ID_CH1);
+	if (!(RxPllType == XVPHY_PLL_TYPE_CPLL)) {
+		XV_HdmiRxSs_SetStream(&xhdmi->xv_hdmirxss, VphyPtr->HdmiRxRefClkHz,
+				(XVphy_GetLineRateHz(VphyPtr, 0, XVPHY_CHANNEL_ID_CMN0)/1000000));
+	}
+	else {
+		XV_HdmiRxSs_SetStream(&xhdmi->xv_hdmirxss, VphyPtr->HdmiRxRefClkHz,
+				(XVphy_GetLineRateHz(VphyPtr, 0, XVPHY_CHANNEL_ID_CH1)/1000000));
+	}
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+}
+
+static XV_HdmiRxSs_Config config = {
+	.DeviceId = 0,
+	.BaseAddress = 0,
+	.HighAddress = 0,
+	.Ppc = 2,
+	.MaxBitsPerPixel = 8,
+
+	.HdcpTimer = {
+		.IsPresent = 0,
+		.DeviceId = 255,
+		.AbsAddr = 0
+	},
+	.Hdcp14 = {
+		.IsPresent = 0,
+		.DeviceId = 255,
+		.AbsAddr = 0
+	},
+	.Hdcp22 = {
+		.IsPresent = 0,
+		.DeviceId  = 255,
+		.AbsAddr = 0
+	},
+	.HdmiRx = {
+		.IsPresent = 1,
+		.DeviceId = 0,
+		.AbsAddr = 0
+	}
+};
+
+/* Local Global table for sub-core instance(s) configuration settings */
+XV_HdmiRx_Config XV_HdmiRx_ConfigTable[XPAR_XV_HDMIRX_NUM_INSTANCES];
+
+/* Compute the absolute address by adding subsystem base address 
+   to sub-core offset */
+static int xhdmi_subcore_AbsAddr(uintptr_t SubSys_BaseAddr,
+                                 uintptr_t SubSys_HighAddr,
+								 uintptr_t SubCore_Offset,
+								 uintptr_t *SubCore_AbsAddr)
+{
+  int Status;
+  uintptr_t absAddr;
+
+  absAddr = SubSys_BaseAddr | SubCore_Offset;
+  if((absAddr>=SubSys_BaseAddr) && (absAddr<=SubSys_HighAddr)) {
+    *SubCore_AbsAddr = absAddr;
+    Status = XST_SUCCESS;
+  } else {
+    *SubCore_AbsAddr = 0;
+    Status = XST_FAILURE;
+  }
+
+  return(Status);
+}
+
+/* Each sub-core within the subsystem has defined offset read from
+   device-tree. */
+static int xhdmi_compute_subcore_AbsAddr(uintptr_t SubSys_BaseAddr, 
+                                         uintptr_t SubSys_HighAddr )
+{
+	int ret;
+	
+	/* Subcore: Rx */
+	ret = xhdmi_subcore_AbsAddr(SubSys_BaseAddr,
+							    SubSys_HighAddr,
+							    config.HdmiRx.AbsAddr,
+							    &config.HdmiRx.AbsAddr);
+	if (ret != XST_SUCCESS) {
+	   hdmi_dbg("hdmirx sub-core address out-of range\n");
+	   return -EFAULT;
+	}
+
+	return (ret);
+}
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+static int instance = 0;
+/* TX uses [1, 127] and RX uses [128, 254] */
+/* The HDCP22 timer uses an additional offset of +64 */
+#define RX_DEVICE_ID_BASE 128
+
+static int xhdmi_parse_of(struct xhdmi_device *xhdmi, XV_HdmiRxSs_Config *config)
+{
+	struct device *dev = xhdmi->dev;
+	struct device_node *node = dev->of_node;
+	int rc;
+	u32 val;
+
+	rc = of_property_read_u32(node, "xlnx,input-pixels-per-clock", &val);
+	if (rc < 0)
+		goto error_dt;
+	config->Ppc = val;
+
+	rc = of_property_read_u32(node, "xlnx,max-bits-per-component", &val);
+	if (rc < 0)
+		goto error_dt;
+	config->MaxBitsPerPixel = val;
+	
+	rc = of_property_read_u32(node, "xlnx,hdmi-rx-offset", &val);	 
+ 	if (rc == 0) { 
+		config->HdmiRx.DeviceId = RX_DEVICE_ID_BASE + instance;
+ 		config->HdmiRx.IsPresent = 1; 
+		config->HdmiRx.AbsAddr = val;
+		XV_HdmiRx_ConfigTable[instance].DeviceId = RX_DEVICE_ID_BASE + instance;
+		XV_HdmiRx_ConfigTable[instance].BaseAddress = val;
+ 	} else { 
+ 		goto error_dt; 
+ 	} 
+
+	rc = of_property_read_u32(node, "xlnx,edid-ram-size", &val);
+	if (rc == 0) {
+		if (val % 128)
+			goto error_dt;
+		xhdmi->edid_blocks_max = val / EDID_BLOCK_SIZE;
+	}
+
+	return 0;
+
+error_dt:
+		dev_err(xhdmi->dev, "Error parsing device tree");
+		return rc;
+}
+
+static int xhdmi_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xhdmi_device *xhdmi;
+	int ret;
+	unsigned int index = 0;
+	struct resource *res;
+
+	const struct firmware *fw_edid;
+	const char *fw_edid_name = "xilinx/xilinx-hdmi-rx-edid.bin";
+	unsigned long flags;
+	unsigned long axi_clk_rate;
+
+	XV_HdmiRxSs *HdmiRxSsPtr;
+	u32 Status;
+
+	hdmi_dbg("hdmi-rx probed\n");
+	/* allocate zeroed HDMI RX device structure */
+	xhdmi = devm_kzalloc(&pdev->dev, sizeof(*xhdmi), GFP_KERNEL);
+	if (!xhdmi)
+		return -ENOMEM;
+	/* store pointer of the real device inside platform device */
+	xhdmi->dev = &pdev->dev;
+
+	xhdmi->edid_blocks_max = 2;
+
+	/* mutex that protects against concurrent access */
+	mutex_init(&xhdmi->xhdmi_mutex);
+	spin_lock_init(&xhdmi->irq_lock);
+	/* work queues */
+	xhdmi->work_queue = create_singlethread_workqueue("xilinx-hdmi-rx");
+	if (!xhdmi->work_queue) {
+		dev_info(xhdmi->dev, "Could not create work queue\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&xhdmi->delayed_work_enable_hotplug,
+		xhdmi_delayed_work_enable_hotplug);
+
+	hdmi_dbg("xhdmi_probe DT parse start\n");
+	/* parse open firmware device tree data */
+	ret = xhdmi_parse_of(xhdmi, &config);
+	if (ret < 0)
+		return ret;
+	hdmi_dbg("xhdmi_probe DT parse done\n");
+
+	/* get ownership of the HDMI RXSS MMIO egister space resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	/* map the MMIO region */
+	xhdmi->iomem = devm_ioremap_resource(xhdmi->dev, res);
+	if (IS_ERR(xhdmi->iomem)) {
+		ret = PTR_ERR(xhdmi->iomem);
+		goto error_resource;
+	}
+	config.BaseAddress = (uintptr_t)xhdmi->iomem;
+	config.HighAddress = config.BaseAddress + resource_size(res) - 1;
+
+	/* Compute AbsAddress for sub-cores */
+	ret = xhdmi_compute_subcore_AbsAddr(config.BaseAddress,
+									    config.HighAddress);
+	if (ret == -EFAULT) {
+	   dev_err(xhdmi->dev, "hdmi-rx sub-core address out-of range\n");
+	   return ret;
+	}
+	
+	/* video streaming bus clock */
+	xhdmi->clk = devm_clk_get(xhdmi->dev, "video");
+	if (IS_ERR(xhdmi->clk)) {
+		ret = PTR_ERR(xhdmi->clk);
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("video-clk not ready -EPROBE_DEFER\n");
+		if (ret != -EPROBE_DEFER)
+			dev_err(xhdmi->dev, "failed to get video clk\n");
+		return ret;
+	}
+
+	clk_prepare_enable(xhdmi->clk);
+
+	/* AXI lite register bus clock */
+	xhdmi->axi_lite_clk = devm_clk_get(xhdmi->dev, "axi-lite");
+	if (IS_ERR(xhdmi->axi_lite_clk)) {
+		ret = PTR_ERR(xhdmi->clk);
+		if (ret == -EPROBE_DEFER)
+			hdmi_dbg("axi-lite clk not ready -EPROBE_DEFER\n");
+		if (ret != -EPROBE_DEFER)
+			dev_err(xhdmi->dev, "failed to get axi-lite clk\n");
+		return ret;
+	}
+
+	clk_prepare_enable(xhdmi->axi_lite_clk);
+	axi_clk_rate = clk_get_rate(xhdmi->axi_lite_clk);
+	hdmi_dbg("AXI Lite clock rate = %lu Hz\n", axi_clk_rate);
+
+	/* get HDMI RXSS irq */
+	xhdmi->irq = platform_get_irq(pdev, 0);
+	if (xhdmi->irq <= 0) {
+		dev_err(&pdev->dev, "platform_get_irq() failed\n");
+		return xhdmi->irq;
+	}
+
+	for (index = 0; index < 3; index++)
+	{
+		char phy_name[16];
+		snprintf(phy_name, sizeof(phy_name), "hdmi-phy%d", index);
+		xhdmi->phy[index] = devm_phy_get(xhdmi->dev, phy_name);
+		if (IS_ERR(xhdmi->phy[index])) {
+			ret = PTR_ERR(xhdmi->phy[index]);
+			xhdmi->phy[index] = NULL;
+			if (ret == -EPROBE_DEFER) {
+				hdmi_dbg("xvphy not ready -EPROBE_DEFER\n");
+				return ret;
+			}
+			if (ret != -EPROBE_DEFER)
+				dev_err(xhdmi->dev, "failed to get phy lane %s index %d, error %d\n",
+					phy_name, index, ret);
+			goto error_phy;
+		}
+
+		ret = phy_init(xhdmi->phy[index]);
+		if (ret) {
+			dev_err(xhdmi->dev,
+				"failed to init phy lane %d\n", index);
+			goto error_phy;
+		}
+	}
+
+	HdmiRxSsPtr = (XV_HdmiRxSs *)&xhdmi->xv_hdmirxss;
+	
+	hdmi_mutex_lock(&xhdmi->xhdmi_mutex);
+
+	/* sets pointer to the EDID used by XV_HdmiRxSs_LoadDefaultEdid() */
+	XV_HdmiRxSs_SetEdidParam(HdmiRxSsPtr, (u8 *)&xilinx_edid[0], sizeof(xilinx_edid));
+
+	/* Initialize top level and all included sub-cores */
+	Status = XV_HdmiRxSs_CfgInitialize(HdmiRxSsPtr, &config, (uintptr_t)xhdmi->iomem);
+	if (Status != XST_SUCCESS)
+	{
+		dev_err(xhdmi->dev, "initialization failed with error %d\n", Status);
+		return -EINVAL;
+	}
+
+	/* retrieve EDID */
+	if (request_firmware(&fw_edid, fw_edid_name, xhdmi->dev) == 0) {
+		int blocks = fw_edid->size / 128;
+		if ((blocks == 0) || (blocks > xhdmi->edid_blocks_max) || (fw_edid->size % 128)) {
+			dev_err(xhdmi->dev, "%s must be n * 128 bytes, with 1 <= n <= %d, using Xilinx built-in EDID instead.\n",
+				fw_edid_name, xhdmi->edid_blocks_max);
+		} else {
+			memcpy(xhdmi->edid_user, fw_edid->data, 128 * blocks);
+			xhdmi->edid_user_blocks = blocks;
+		}
+	}
+	release_firmware(fw_edid);
+
+	if (xhdmi->edid_user_blocks) {
+		dev_info(xhdmi->dev, "Using %d EDID block%s (%d bytes) from '%s'.\n",
+			xhdmi->edid_user_blocks, xhdmi->edid_user_blocks > 1? "s":"", 128 * xhdmi->edid_user_blocks, fw_edid_name);
+		XV_HdmiRxSs_LoadEdid(HdmiRxSsPtr, (u8 *)&xhdmi->edid_user, 128 * xhdmi->edid_user_blocks);
+	} else {
+		dev_info(xhdmi->dev, "Using Xilinx built-in EDID.\n");
+		XV_HdmiRxSs_LoadDefaultEdid(HdmiRxSsPtr);
+	}
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	XV_HdmiRxSs_IntrDisable(HdmiRxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	/* RX SS callback setup (from xapp1287/xhdmi_example.c:2146) */
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr, XV_HDMIRXSS_HANDLER_CONNECT,
+		RxConnectCallback, (void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr,XV_HDMIRXSS_HANDLER_AUX,
+		RxAuxCallback,(void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr,XV_HDMIRXSS_HANDLER_AUD,
+		RxAudCallback, (void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr, XV_HDMIRXSS_HANDLER_LNKSTA,
+		RxLnkStaCallback, (void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr, XV_HDMIRXSS_HANDLER_STREAM_DOWN,
+		RxStreamDownCallback, (void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr, XV_HDMIRXSS_HANDLER_STREAM_INIT,
+		RxStreamInitCallback, (void *)xhdmi);
+	XV_HdmiRxSs_SetCallback(HdmiRxSsPtr, XV_HDMIRXSS_HANDLER_STREAM_UP,
+		RxStreamUpCallback, (void *)xhdmi);
+
+	/* get a reference to the XVphy data structure */
+	xhdmi->xvphy = xvphy_get_xvphy(xhdmi->phy[0]);
+
+	BUG_ON(!xhdmi->xvphy);
+
+	xvphy_mutex_lock(xhdmi->phy[0]);
+	/* the callback is not specific to a single lane, but we need to
+	 * provide one of the phy's as reference */
+	XVphy_SetHdmiCallback(xhdmi->xvphy, XVPHY_HDMI_HANDLER_RXINIT,
+		VphyHdmiRxInitCallback, (void *)xhdmi);
+	XVphy_SetHdmiCallback(xhdmi->xvphy, XVPHY_HDMI_HANDLER_RXREADY,
+		VphyHdmiRxReadyCallback, (void *)xhdmi);
+	xvphy_mutex_unlock(xhdmi->phy[0]);
+
+	platform_set_drvdata(pdev, xhdmi);
+
+	ret = devm_request_threaded_irq(&pdev->dev, xhdmi->irq, hdmirx_irq_handler, hdmirx_irq_thread,
+		IRQF_TRIGGER_HIGH, "xilinx-hdmi-rx", xhdmi/*dev_id*/);
+
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", xhdmi->irq);
+		hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+		goto error_phy;
+	}
+
+	/* Initialize V4L2 subdevice */
+	subdev = &xhdmi->subdev;
+	v4l2_subdev_init(subdev, &xhdmi_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xhdmi_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xhdmi);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE /* | V4L2_SUBDEV_FL_HAS_EVENTS*/;
+
+	/* Initialize V4L2 media entity */
+	xhdmi->pad.flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xhdmi_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 1/*npads*/, &xhdmi->pad);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to init media entity\n");
+		hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+		goto error_irq;
+	}
+
+	v4l2_ctrl_handler_init(&xhdmi->ctrl_handler, 0/*controls*/);
+	subdev->ctrl_handler = &xhdmi->ctrl_handler;
+	ret = v4l2_ctrl_handler_setup(&xhdmi->ctrl_handler);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to set controls\n");
+		hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+		goto error_irq;
+	}
+
+	/* assume detected format */
+	xhdmi->detected_format.width = 1280;
+	xhdmi->detected_format.height = 720;
+	xhdmi->detected_format.field = V4L2_FIELD_NONE;
+	xhdmi->detected_format.colorspace = V4L2_COLORSPACE_REC709;
+	xhdmi->detected_format.code = MEDIA_BUS_FMT_RBG888_1X24;
+	xhdmi->detected_format.colorspace = V4L2_COLORSPACE_SRGB;
+	xhdmi->detected_format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	xhdmi->detected_format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	xhdmi->detected_format.quantization = V4L2_QUANTIZATION_DEFAULT;
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+		goto error;
+	}
+
+	hdmi_mutex_unlock(&xhdmi->xhdmi_mutex);
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	XV_HdmiRxSs_IntrEnable(HdmiRxSsPtr);
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+    hdmi_dbg("hdmi-rx probe successful\n");
+	/* probe has succeeded for this instance, increment instance index */
+	instance++;
+	/* return success */
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&xhdmi->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+error_irq:
+
+error_phy:
+	printk(KERN_INFO "xhdmirx_probe() error_phy:\n");
+	index = 0;
+	/* release the lanes that we did get, if we did not get all lanes */
+	if (xhdmi->phy[index]) {
+		printk(KERN_INFO "phy_exit() xhdmi->phy[%d] = %p\n", index, xhdmi->phy[index]);
+		phy_exit(xhdmi->phy[index]);
+		xhdmi->phy[index] = NULL;
+	}
+error_resource:
+	printk(KERN_INFO "xhdmirx_probe() error_resource:\n");
+	return ret;
+}
+
+static int xhdmi_remove(struct platform_device *pdev)
+{
+	struct xhdmi_device *xhdmi = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xhdmi->subdev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xhdmi->irq_lock, flags);
+	XV_HdmiRxSs_IntrDisable(&xhdmi->xv_hdmirxss);
+	xhdmi->teardown = 1;
+	spin_unlock_irqrestore(&xhdmi->irq_lock, flags);
+
+	cancel_delayed_work(&xhdmi->delayed_work_enable_hotplug);
+	destroy_workqueue(xhdmi->work_queue);
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xhdmi->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xhdmi->clk);
+	hdmi_dbg("removed.\n");
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(xhdmi_pm_ops, xhdmi_pm_suspend, xhdmi_pm_resume);
+
+static const struct of_device_id xhdmi_of_id_table[] = {
+	{ .compatible = "xlnx,v-hdmi-rx-ss-2.0" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xhdmi_of_id_table);
+
+static struct platform_driver xhdmi_driver = {
+	.driver = {
+		.name		= "xilinx-hdmi-rx",
+		.pm		= &xhdmi_pm_ops,
+		.of_match_table	= xhdmi_of_id_table,
+	},
+	.probe			= xhdmi_probe,
+	.remove			= xhdmi_remove,
+};
+
+module_platform_driver(xhdmi_driver);
+
+MODULE_DESCRIPTION("Xilinx HDMI RXSS V4L2 driver");
+MODULE_AUTHOR("Leon Woestenberg <leon@sidebranch.com>");
+MODULE_LICENSE("GPL v2");
-- 
1.7.5.4

