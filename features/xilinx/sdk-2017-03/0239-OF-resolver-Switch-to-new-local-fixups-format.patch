From ec21fb35aac02846eee108356da1aa02c867ef3e Mon Sep 17 00:00:00 2001
From: Nava kishore Manne <nava.manne@xilinx.com>
Date: Tue, 20 Jun 2017 18:03:13 +0530
Subject: [PATCH 239/532] OF: resolver: Switch to new local fixups format.

commit 6470123421766ac14c810e56f215de71793a04e1 from
https://github.com/Xilinx/linux-xlnx.git

The current resolver format is way too cryptic and its fail to
fix the local_fixups created by the latest dtc compiler.
this patch fix the local fixups based on the information exists in
devicetree ovelay file generated by the latest dtc compiler 1.4.4.

Signed-off-by: Nava kishore Manne <navam@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/of/resolver.c | 129 +++++++++++---------------------------------------
 1 file changed, 28 insertions(+), 101 deletions(-)

diff --git a/drivers/of/resolver.c b/drivers/of/resolver.c
index 46325d6..13b92bd 100644
--- a/drivers/of/resolver.c
+++ b/drivers/of/resolver.c
@@ -116,7 +116,8 @@ static void __of_adjust_tree_phandles(struct device_node *node,
 }
 
 static int __of_adjust_phandle_ref(struct device_node *node,
-		struct property *rprop, int value)
+				struct property *rprop, int value,
+				bool is_delta)
 {
 	phandle phandle;
 	struct device_node *refnode;
@@ -187,7 +188,8 @@ static int __of_adjust_phandle_ref(struct device_node *node,
 			goto err_fail;
 		}
 
-		phandle = value;
+		phandle = is_delta ? be32_to_cpup(sprop->value + offset)
+								+ value : value;
 		*(__be32 *)(sprop->value + offset) = cpu_to_be32(phandle);
 	}
 
@@ -196,97 +198,36 @@ err_fail:
 	return err;
 }
 
-/* compare nodes taking into account that 'name' strips out the @ part */
-static int __of_node_name_cmp(const struct device_node *dn1,
-		const struct device_node *dn2)
-{
-	const char *n1 = strrchr(dn1->full_name, '/') ? : "/";
-	const char *n2 = strrchr(dn2->full_name, '/') ? : "/";
-
-	return of_node_cmp(n1, n2);
-}
-
 /*
  * Adjust the local phandle references by the given phandle delta.
- * Assumes the existances of a __local_fixups__ node at the root.
- * Assumes that __of_verify_tree_phandle_references has been called.
- * Does not take any devtree locks so make sure you call this on a tree
- * which is at the detached state.
+ * Assumes the existances of a __local_fixups__ node at the root
+ * of the tree. Does not take any devtree locks so make sure you
+ * call this on a tree which is at the detached state.
  */
 static int __of_adjust_tree_phandle_references(struct device_node *node,
-		struct device_node *target, int phandle_delta)
+		int phandle_delta)
 {
-	struct device_node *child, *childtarget;
-	struct property *rprop, *sprop;
-	int err, i, count;
-	unsigned int off;
-	phandle phandle;
+	struct device_node *child;
+	struct property *rprop;
+	int err;
 
-	if (node == NULL)
-		return 0;
+	/* locate the symbols & fixups nodes on resolve */
+	for_each_child_of_node(node, child)
+		if (of_node_cmp(child->name, "__local_fixups__") == 0)
+			break;
 
-	for_each_property_of_node(node, rprop) {
+	/* no local fixups */
+	if (!child)
+		return 0;
 
+	/* find the local fixups property */
+	for_each_property_of_node(child, rprop) {
 		/* skip properties added automatically */
-		if (of_prop_cmp(rprop->name, "name") == 0 ||
-		    of_prop_cmp(rprop->name, "phandle") == 0 ||
-		    of_prop_cmp(rprop->name, "linux,phandle") == 0)
+		if (of_prop_cmp(rprop->name, "name") == 0)
 			continue;
 
-		if ((rprop->length % 4) != 0 || rprop->length == 0) {
-			pr_err("%s: Illegal property (size) '%s' @%s\n",
-					__func__, rprop->name, node->full_name);
-			return -EINVAL;
-		}
-		count = rprop->length / sizeof(__be32);
-
-		/* now find the target property */
-		for_each_property_of_node(target, sprop) {
-			if (of_prop_cmp(sprop->name, rprop->name) == 0)
-				break;
-		}
-
-		if (sprop == NULL) {
-			pr_err("%s: Could not find target property '%s' @%s\n",
-					__func__, rprop->name, node->full_name);
-			return -EINVAL;
-		}
-
-		for (i = 0; i < count; i++) {
-			off = be32_to_cpu(((__be32 *)rprop->value)[i]);
-			/* make sure the offset doesn't overstep (even wrap) */
-			if (off >= sprop->length ||
-					(off + 4) > sprop->length) {
-				pr_err("%s: Illegal property '%s' @%s\n",
-						__func__, rprop->name,
-						node->full_name);
-				return -EINVAL;
-			}
-
-			if (phandle_delta) {
-				/* adjust */
-				phandle = be32_to_cpu(*(__be32 *)(sprop->value + off));
-				phandle += phandle_delta;
-				*(__be32 *)(sprop->value + off) = cpu_to_be32(phandle);
-			}
-		}
-	}
-
-	for_each_child_of_node(node, child) {
-
-		for_each_child_of_node(target, childtarget)
-			if (__of_node_name_cmp(child, childtarget) == 0)
-				break;
-
-		if (!childtarget) {
-			pr_err("%s: Could not find target child '%s' @%s\n",
-					__func__, child->name, node->full_name);
-			return -EINVAL;
-		}
-
-		err = __of_adjust_tree_phandle_references(child, childtarget,
-				phandle_delta);
-		if (err != 0)
+		err = __of_adjust_phandle_ref(node, rprop, phandle_delta, true);
+		if (err)
 			return err;
 	}
 
@@ -308,7 +249,7 @@ static int __of_adjust_tree_phandle_references(struct device_node *node,
  */
 int of_resolve_phandles(struct device_node *resolve)
 {
-	struct device_node *child, *childroot, *refnode;
+	struct device_node *child, *refnode;
 	struct device_node *root_sym, *resolve_sym, *resolve_fix;
 	struct property *rprop;
 	const char *refpath;
@@ -327,23 +268,9 @@ int of_resolve_phandles(struct device_node *resolve)
 	/* first we need to adjust the phandles */
 	phandle_delta = of_get_tree_max_phandle() + 1;
 	__of_adjust_tree_phandles(resolve, phandle_delta);
-
-	/* locate the local fixups */
-	childroot = NULL;
-	for_each_child_of_node(resolve, childroot)
-		if (of_node_cmp(childroot->name, "__local_fixups__") == 0)
-			break;
-
-	if (childroot != NULL) {
-		/* resolve root is guaranteed to be the '/' */
-		err = __of_adjust_tree_phandle_references(childroot,
-				resolve, 0);
-		if (err != 0)
-			return err;
-
-		BUG_ON(__of_adjust_tree_phandle_references(childroot,
-				resolve, phandle_delta));
-	}
+	err = __of_adjust_tree_phandle_references(resolve, phandle_delta);
+	if (err != 0)
+		return err;
 
 	root_sym = NULL;
 	resolve_sym = NULL;
@@ -409,7 +336,7 @@ int of_resolve_phandles(struct device_node *resolve)
 		pr_debug("%s: %s phandle is 0x%08x\n",
 				__func__, rprop->name, phandle);
 
-		err = __of_adjust_phandle_ref(resolve, rprop, phandle);
+		err = __of_adjust_phandle_ref(resolve, rprop, phandle, false);
 		if (err)
 			break;
 	}
-- 
2.7.4

