From df1813a480c835630adfaf56907bd5816fe07dba Mon Sep 17 00:00:00 2001
From: Anurag Kumar Vulisha <anurag.kumar.vulisha@xilinx.com>
Date: Fri, 30 Jun 2017 15:58:08 +0530
Subject: [PATCH 174/532] usb: xhci: Add workaround for fixing ep stream ring
 hang issue

commit 1797c9ea0a60db2be72fd7fff26774d60602ede7 from
https://github.com/Xilinx/linux-xlnx.git

Dwc3 host controller has an issue with BULK IN stream rings where
it stops processing the TD's present in the endpoint stream ring
(once in a while) even after ringing the stream DoorBell register.
Since host controller doesn't process TD's in stream ring, no transfer
events are generated by the controller, resulting in a hang issue.

This patch solves the above said problem by adding a timeout handler for
every BULK IN stream ring. After timer expires, timeout handler will be
called and from that stop command on the same endpoint stream ring will
be issued and urb will be given back with urb->status set to -EAGAIN.
The UAS driver checks the urb status as -EAGAIN and re-submit the same
urb which was timedout.

NOTE: As we have already added support for usb Host streaming, this fix is
required to fix the hang issue that occurs when UAS capable device is
connected. This fix is expected to change after the HW team comes with an
alternate workaround for this issue.

Signed-off-by: Anurag Kumar Vulisha <anuragku@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/usb/host/xhci-mem.c  |  14 ++++++
 drivers/usb/host/xhci-ring.c | 105 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/usb/host/xhci.c      |   5 +++
 drivers/usb/host/xhci.h      |   6 ++-
 4 files changed, 128 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 10d4834..6489dbe 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -746,6 +746,16 @@ struct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,
 		xhci_dbg(xhci, "Setting stream %d ring ptr to 0x%08llx\n",
 				cur_stream, (unsigned long long) addr);
 
+		if (xhci->quirks & XHCI_STREAM_QUIRK) {
+			/* dwc3 host controller has an issue where it doesn't
+			 * process BULK IN stream rings even after ringing
+			 * DoorBell, so setup a timer to aviod hang condition.
+			 */
+			setup_timer(&cur_ring->stream_timer,
+				xhci_stream_timeout, (unsigned long)cur_ring);
+			cur_ring->xhci = xhci;
+		}
+
 		ret = xhci_update_stream_mapping(cur_ring, mem_flags);
 		if (ret) {
 			xhci_ring_free(xhci, cur_ring);
@@ -832,6 +842,10 @@ void xhci_free_stream_info(struct xhci_hcd *xhci,
 	for (cur_stream = 1; cur_stream < stream_info->num_streams;
 			cur_stream++) {
 		cur_ring = stream_info->stream_rings[cur_stream];
+
+		if (xhci->quirks & XHCI_STREAM_QUIRK)
+			del_timer_sync(&cur_ring->stream_timer);
+
 		if (cur_ring) {
 			xhci_ring_free(xhci, cur_ring);
 			stream_info->stream_rings[cur_stream] = NULL;
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 2b0ba75..345ab8b 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -818,7 +818,18 @@ remove_finished_td:
 		ep_ring = xhci_urb_to_transfer_ring(xhci, cur_td->urb);
 		if (ep_ring && cur_td->bounce_seg)
 			xhci_unmap_td_bounce_buffer(xhci, ep_ring, cur_td);
-		xhci_giveback_urb_in_irq(xhci, cur_td, 0);
+
+		if ((xhci->quirks & XHCI_STREAM_QUIRK) &&
+				(ep_ring->stream_timeout_handler == true)) {
+			/* We get here if stream timer timed out and stop
+			 * command is issued. Send urb status as -EAGAIN
+			 * so that the same urb can be re-submitted.
+			 */
+			xhci_giveback_urb_in_irq(xhci, cur_td, -EAGAIN);
+			ep_ring->stream_timeout_handler = false;
+		} else {
+			xhci_giveback_urb_in_irq(xhci, cur_td, 0);
+		}
 
 		/* Stop processing the cancelled list if the watchdog timer is
 		 * running.
@@ -884,6 +895,85 @@ static void xhci_kill_endpoint_urbs(struct xhci_hcd *xhci,
 	}
 }
 
+/* This function is called when the stream ring timer gets timedout.
+ * dwc3 host controller has an issue where it doesn't process the BULK IN
+ * stream ring TD's(once in a while) even after ringing DoorBell for that
+ * stream ring. Because of this behaviour there will be no transfer events
+ * generated by the controller on the stream ring, resulting in the hang
+ * condition. xhci_stream_timeout() solves this issue by sending a stop
+ * command on the stream ring after stream timer gets timedout.
+ */
+void xhci_stream_timeout(unsigned long arg)
+{
+	struct xhci_hcd *xhci;
+	struct xhci_virt_ep *ep;
+	struct xhci_ring *ep_ring;
+	unsigned int slot_id, ep_index, stream_id;
+	struct xhci_td *td = NULL;
+	struct urb *urb = NULL;
+	struct urb_priv *urb_priv;
+	struct xhci_command *command;
+	unsigned long flags;
+	int i;
+
+	ep_ring = (struct xhci_ring *) arg;
+	xhci = ep_ring->xhci;
+
+	spin_lock_irqsave(&xhci->lock, flags);
+
+	if (!list_empty(&ep_ring->td_list)) {
+		td = list_entry(ep_ring->td_list.next, struct xhci_td, td_list);
+		urb = td->urb;
+		urb_priv = urb->hcpriv;
+
+		slot_id = urb->dev->slot_id;
+		ep_index = xhci_get_endpoint_index(&urb->ep->desc);
+		stream_id = ep_ring->stream_id;
+		ep = &xhci->devs[slot_id]->eps[ep_index];
+		ep_ring->stream_timeout_handler = true;
+
+		/* Delete the stream ring timer */
+		del_timer(&ep_ring->stream_timer);
+
+		for (i = 0; i < urb_priv->length; i++) {
+			td = urb_priv->td[i];
+			list_add_tail(&td->cancelled_td_list,
+					&ep->cancelled_td_list);
+		}
+
+		/* Queue a stop endpoint command, but only if this is
+		 * the first cancellation to be handled.
+		 */
+		if (!(ep->ep_state & EP_HALT_PENDING)) {
+			command = xhci_alloc_command(xhci, false,
+					false, GFP_ATOMIC);
+			if (!command) {
+				xhci_warn(xhci,
+					"%s: Failed to allocate command\n",
+						__func__);
+				spin_unlock_irqrestore(&xhci->lock, flags);
+				return;
+			}
+
+			ep->ep_state |= EP_HALT_PENDING;
+			ep->stop_cmds_pending++;
+			ep->stop_cmd_timer.expires = jiffies +
+				XHCI_STOP_EP_CMD_TIMEOUT * HZ;
+			add_timer(&ep->stop_cmd_timer);
+			xhci_queue_stop_endpoint(xhci, command,
+					urb->dev->slot_id, ep_index, 0);
+			xhci_ring_cmd_db(xhci);
+		}
+
+		spin_unlock_irqrestore(&xhci->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&xhci->lock, flags);
+	/* let the SCSI stack take care */
+	del_timer(&ep_ring->stream_timer);
+}
+
 /* Watchdog timer function for when a stop endpoint command fails to complete.
  * In this case, we assume the host controller is broken or dying or dead.  The
  * host may still be completing some other events, so we have to be careful to
@@ -2373,6 +2463,10 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 			td_num++;
 	}
 
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) &&
+				(ep->ep_state & EP_HAS_STREAMS))
+		del_timer(&ep_ring->stream_timer);
+
 	event_dma = le64_to_cpu(event->buffer);
 	trb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));
 	/* Look for common error cases */
@@ -3356,6 +3450,15 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	}
 
 	check_trb_math(urb, enqd_len);
+
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) && (urb->stream_id > 0) &&
+				(usb_endpoint_dir_in(&urb->ep->desc) == 1)) {
+		/* Start the stream timer so that xhci_stream_timeout() can be
+		 * triggered if xhci is stuck while processing BULK IN streams.
+		 */
+		ring->stream_timeout_handler = false;
+		mod_timer(&ring->stream_timer, jiffies + 5 * HZ);
+	}
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
 			start_cycle, start_trb);
 	return 0;
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 22e40a9..5d323e7 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1549,6 +1549,11 @@ int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		goto done;
 	}
 
+	/* Delete the stream timer */
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) && (urb->stream_id > 0))
+		del_timer(&ep_ring->stream_timer);
+
+
 	urb_priv = urb->hcpriv;
 	i = urb_priv->td_cnt;
 	if (i < urb_priv->length)
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 328fe06..4a05e5e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1417,6 +1417,9 @@ struct xhci_ring {
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 	struct radix_tree_root	*trb_address_map;
+	struct timer_list	stream_timer;
+	bool			stream_timeout_handler;
+	struct xhci_hcd		*xhci;
 };
 
 struct xhci_erst_entry {
@@ -1657,6 +1660,7 @@ struct xhci_hcd {
 #define XHCI_SSIC_PORT_UNUSED	(1 << 22)
 #define XHCI_NO_64BIT_SUPPORT	(1 << 23)
 #define XHCI_MISSING_CAS	(1 << 24)
+#define XHCI_STREAM_QUIRK	(1 << 25)
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
@@ -1946,8 +1950,8 @@ void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
+void xhci_stream_timeout(unsigned long arg);
 void xhci_handle_command_timeout(struct work_struct *work);
-
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
-- 
2.7.4

