From 98e8276a51b8c2b75cab9e936146b54c8e7040ac Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Thu, 11 Nov 2010 07:23:22 -0800
Subject: [PATCH] kexec: fix vmcore for multi-cpus

When a crash kernel is invoked and the vmcore image captured, each
cpu is dumped into the vmcore image with it's data identified by
a header "reg/<PID>" where PID is the process ID that it was running.
Any cpu that is idle when a crash-kernel is invoked will have a PID=0

The problem occurs when the vmcore is loaded into gdb.  Gdb attempts
to create a thread for each cpu capture, using the pid (from the
"reg/<PID>" identifier) as an ID for the thread.  If multiple cpus
were idle at the time of the crash gdb attempts to create
multiple threads with the same id (0), which causes an exception within
gdb itself.

To correct this, all cpus that were idle (identified as running with
pid=0) will not have any data recorded in the vmcore image.

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 kernel/kexec.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/kernel/kexec.c b/kernel/kexec.c
index d828626..cb4a86b 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -1196,6 +1196,9 @@ void crash_save_cpu(struct pt_regs *regs, int cpu)
 	if (!buf)
 		return;
 	memset(&prstatus, 0, sizeof(prstatus));
+	if (current->pid == 0)
+		/* this cpu was idle; nothing to capture */
+		return;
 	prstatus.pr_pid = current->pid;
 	elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);
 	buf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,
-- 
1.6.5.2

