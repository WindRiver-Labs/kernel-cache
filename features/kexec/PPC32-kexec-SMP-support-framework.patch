From 84ea37cad1152ae6d585621dbdfe88b52d0cc15d Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 30 Mar 2010 18:22:32 -0400
Subject: [PATCH 2/5] PPC32/kexec: SMP support framework

PPC32 did not take into account the possibility of rebooting
from an SMP kernel, and thus left CPUs other than the one
triggering the system call continue their operation, with bad
consequences.

Introduce framework for taking care of multiple CPUs.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/include/asm/machdep.h     |    4 ++
 arch/powerpc/kernel/machine_kexec_32.c |   76 ++++++++++++++++++++++++++-----
 2 files changed, 67 insertions(+), 13 deletions(-)

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index 671274b..3bd4547 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -43,6 +43,10 @@ struct smp_ops_t {
 	int   (*cpu_disable)(void);
 	void  (*cpu_die)(unsigned int nr);
 	int   (*cpu_bootable)(unsigned int nr);
+#ifdef CONFIG_KEXEC
+	/* this must be called will local interrupts disabled */
+	void  (*kexec_stop_cpus)(void *arg);
+#endif
 };
 #endif
 
diff --git a/arch/powerpc/kernel/machine_kexec_32.c b/arch/powerpc/kernel/machine_kexec_32.c
index ae63a96..7cdb080 100644
--- a/arch/powerpc/kernel/machine_kexec_32.c
+++ b/arch/powerpc/kernel/machine_kexec_32.c
@@ -21,6 +21,32 @@ typedef NORET_TYPE void (*relocate_new_kernel_t)(
 				unsigned long reboot_code_buffer,
 				unsigned long start_address) ATTRIB_NORET;
 
+#ifdef CONFIG_SMP
+#include <asm/machdep.h>
+#include <asm/smp.h>
+void smp_stop_cpus(struct kimage *image)
+{
+	if (!smp_ops->kexec_stop_cpus) {
+		panic("PowerPC smp_ops.kexec_stop_cpus not implemented\n"
+			"for this type of target !\n");
+		local_irq_disable();
+		while(1);
+		/* not reached, we're screwed, missing implementation:
+		 * no sense going forward as any progress would be
+		 * sheer luck and would not result in a stable system */
+	}
+
+	smp_ops->kexec_stop_cpus(image);
+}
+#else /* !CONFIG_SMP */
+void smp_stop_cpus(struct kimage *image)
+{
+	/* non-SMP, only lock interrupts since it is the responsibility
+	 * of smp_stop_cpus(). */
+	local_irq_disable();
+}
+#endif /* CONFIG_SMP */
+
 /*
  * This is a generic machine_kexec function suitable at least for
  * non-OpenFirmware embedded platforms.
@@ -28,35 +54,59 @@ typedef NORET_TYPE void (*relocate_new_kernel_t)(
  * jumps to it.
  * A platform specific function may just call this one.
  */
-void default_machine_kexec(struct kimage *image)
+
+extern const unsigned char relocate_new_kernel[];
+extern const unsigned int relocate_new_kernel_size;
+
+/* This is in its own routine since it can be called by a CPU that is not
+ * the one on which 'kexec -e' was invoked, in some special cases, eg. a
+ * target which expects CPU0 to be the boot CPU. */
+void kexec_leave_kernel(struct kimage *image)
 {
-	extern const unsigned char relocate_new_kernel[];
-	extern const unsigned int relocate_new_kernel_size;
 	unsigned long page_list;
 	unsigned long reboot_code_buffer, reboot_code_buffer_phys;
 	relocate_new_kernel_t rnk;
 
-	/* Interrupts aren't acceptable while we reboot */
-	local_irq_disable();
-
 	page_list = image->head;
-
-	/* we need both effective and real address here */
 	reboot_code_buffer =
 			(unsigned long)page_address(image->control_code_page);
 	reboot_code_buffer_phys = virt_to_phys((void *)reboot_code_buffer);
 
-	/* copy our kernel relocation code to the control code page */
-	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
-						relocate_new_kernel_size);
-
 	flush_icache_range(reboot_code_buffer,
 				reboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE);
 	printk(KERN_INFO "Bye!\n");
 
-	/* now call it */
+	/* call kernel relocation code in control page */
 	rnk = (relocate_new_kernel_t) reboot_code_buffer;
 	(*rnk)(page_list, reboot_code_buffer_phys, image->start);
+
+	/* not reached */
+}
+
+void default_machine_kexec(struct kimage *image)
+{
+	u32 reboot_code_buffer;
+
+	/* we need both effective and real address here */
+	reboot_code_buffer = (u32)page_address(image->control_code_page);
+
+	/* copy our kernel relocation code to the control code page */
+	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
+						relocate_new_kernel_size);
+
+	smp_mb(); /* ensure memcpy finished before secondaries try to run
+		 * the relocated code */
+
+	/* Interrupts aren't acceptable while we reboot, but can't be locked
+	 * before calling smp_stop_cpus() since it invokes smp_call_function()
+	 * which complains if IRQs are disabled. smp_stop_cpus() is thus
+	 * responsible for locking them, even in the UP case. */
+
+	smp_stop_cpus(image);
+
+	kexec_leave_kernel(image);
+
+	/* not reached */
 }
 
 int default_machine_kexec_prepare(struct kimage *image)
-- 
1.6.5.2

