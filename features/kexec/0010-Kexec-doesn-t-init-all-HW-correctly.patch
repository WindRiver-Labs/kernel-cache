From cb5f90b77d5cecaec9a6d9270123fc647c1ffdb9 Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Thu, 12 Feb 2009 13:41:54 -0500
Subject: [PATCH] Kexec doesn't init all HW correctly

After running a Kexec'd kernel not all registers are left
in the same state as the bootloader leaves them.  Unfortunately
the driver assumes that the interrupt error mask register is
zeroed by the bootloader, which on this board is U-Boot.
This is clearly not the case when running the fastboot kernel.
Zero out the interrupt error register on the host controller.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 drivers/ata/sata_mv.c |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
index 394cb0c..d6f9453 100644
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@ -831,6 +831,24 @@ static void mv_set_edma_ptrs(void __iomem *port_mmio,
 		 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
 }
 
+static void mv_clear_edma_err_mask(struct ata_host *host)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base;
+	int port;
+
+	for (port = 0; port < host->n_ports; port++) {
+		void __iomem *port_mmio = mv_port_base(mmio, port);
+
+		/* Upon exiting a Kexec'd kernel unfortunately the
+		 * EDMA irq error mask bits are still on. 
+		 * Simply SMASH the EDMA error IRQ mask bits off
+		 * to avoid generating an unhandled IRQ*/
+		writelfl(0, port_mmio + EDMA_ERR_IRQ_MASK_OFS);
+	}
+}
+
+
 static void mv_set_main_irq_mask(struct ata_host *host,
 				 u32 disable_bits, u32 enable_bits)
 {
@@ -3081,6 +3099,10 @@ static int mv_init_host(struct ata_host *host, unsigned int board_idx)
 
 	n_hc = mv_get_hc_count(host->ports[0]->flags);
 
+#if defined(CONFIG_KEXEC) && defined(CONFIG_MPC7448HPC2)
+	mv_clear_edma_err_mask(host);
+#endif
+
 	for (port = 0; port < host->n_ports; port++)
 		hpriv->ops->read_preamp(hpriv, port, mmio);
 
-- 
1.5.6.3

