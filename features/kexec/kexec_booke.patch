From: Matthew Wagantall <matthew.wagantall@windriver.com>
Subject: Add kexec/kdump kernel support for PowerPC Book E processors.

Adapted from a powerpc kernel mailing list patch by Dale Farnsworth
<dale@farnsworth.org>. 

Original header follows:

Patch: [PATCH 03/10] powerpc: Add kexec support for PPC_85xx platforms.patch
Submitter: Dale Farnsworth <dale@farnsworth.org>
Date: Fri, 23 Nov 2007 02:46:07 +1100

book E processors need some extra setup in relocate_new_kernel,
because the MMU can't be turned off.  Add the code to create
the required one-to-one memory map.

Signed-off-by: Dale Farnsworth <dale@farnsworth.org>
Integrated-by: Matthew Wagantall <matthew.wagantall@windriver.com>
---
 Kconfig          |    9 ++++---
 kernel/misc_32.S |   69 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 75 insertions(+), 3 deletions(-)
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -307,7 +307,8 @@ config ARCH_ENABLE_MEMORY_HOTREMOVE
 
 config KEXEC
 	bool "kexec system call (EXPERIMENTAL)"
-	depends on (PPC_PRPMC2800 || PPC_MULTIPLATFORM) && EXPERIMENTAL
+	depends on (PPC_MULTIPLATFORM || PPC_85xx) && EXPERIMENTAL
+	select PROC_DEVICETREE 
 	help
 	  kexec is a system call that implements the ability to shutdown your
 	  current kernel, and to start another kernel.  It is like a reboot
@@ -323,8 +324,10 @@ config KEXEC
 	  strongly in flux, so no good recommendation can be made.
 
 config CRASH_DUMP
-	bool "Build a kdump crash kernel"
-	depends on PPC_MULTIPLATFORM && !BOOKE
+	bool "Build a kdump crash kernel (EXPERIMENTAL)"
+	depends on (PPC_MULTIPLATFORM || PPC_85xx) && EXPERIMENTAL
+	select RELOCATABLE
+	select VMCORE
 	help
 	  Build a kernel suitable for use as a kdump capture kernel.
 	  The kernel will be linked at a different address than normal, and
--- a/arch/powerpc/kernel/misc_32.S
+++ b/arch/powerpc/kernel/misc_32.S
@@ -878,6 +878,75 @@ relocate_new_kernel:
 	/* r4 = reboot_code_buffer */
 	/* r5 = start_address      */
 
+#ifdef CONFIG_FSL_BOOKE
+	/*
+	 * Since we can't turn off the MMU, we must create an identity
+	 * map for kernel low memory.  We start by invalidating the
+	 * TLB entries we don't need.
+	 *
+	 * First, invalidate the TLB0 entries
+	 */
+	li	r6, 0x04
+	tlbivax	0, r6
+#ifdef CONFIG_SMP
+	tlbsync
+#endif
+	msync
+
+	/*
+	 * Kernel low memory is mapped by TLB1 entries 0, 1, and 2.
+	 * Preserve these, but invalidate all other TLB1 entries.
+	 */
+	li	r7, 3			/* first TLB1 entry */
+	mfspr	r6, SPRN_TLB1CFG
+	andi.	r6, r6, 0xfff
+	mr	r8, r6
+	subf	r6, r7, r6
+	mtctr	r6
+1:
+	rlwinm	r6, r7, 16, 12, 15
+	oris	r6, r6, 0x1000
+	mtspr	SPRN_MAS0, r6
+	tlbre
+	mfspr	r6, SPRN_MAS1
+	rlwinm	r6, r6, 0, 2, 31	/* Clear MAS1 Valid and IPROT */
+	mtspr	SPRN_MAS1, r6
+	tlbwe
+	isync
+	addi	r7, r7, 1
+	bdnz	1b
+
+	/*
+	 * Using TLB1 entries 3, 4, and 5, identity-map kernel low
+	 * memory by copying and modifying the contents of TLB1
+	 * entries 0, 1 and 2, respectively.
+	 */
+	li	r7, 0			/* source TLB entry */
+	li	r8, 3			/* destination TLB entry */
+	li	r6, 3			/* number of TLBs to copy */
+	mtctr	r6
+1:
+	rlwinm	r6, r7, 16, 12, 15
+	oris	r6, r6, 0x1000
+	mtspr	SPRN_MAS0, r6
+	tlbre
+
+	mfspr	r6, SPRN_MAS2
+	lis	r0, PAGE_OFFSET@h
+	subf	r6, r0, r6		/* identity map */
+	mtspr	SPRN_MAS2, r6
+
+	rlwinm	r6, r8, 16, 12, 15
+	oris	r6, r6, 0x1000
+	mtspr	SPRN_MAS0, r6
+	tlbwe
+	sync
+	isync
+	addi	r7, r7, 1
+	addi	r8, r8, 1
+	bdnz	1b
+#endif	/* CONFIG_FSL_BOOKE */
+
 	li	r0, 0
 
 	/*
