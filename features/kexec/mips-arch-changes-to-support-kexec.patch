From 789cd9de40c34ccacc2780019b7baaa0ed02598e Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Thu, 9 Jul 2009 16:31:50 -0400
Subject: [PATCH 3/6] mips: arch changes to support kexec

Areas of kernel code common to all MIPS platforms are modified
to enable kexec.  Specifically:
- enable compiling of support for the crash kernel and crash dump
- enable machine_kexec functions to have platform-specific functions
  bound in as required, enabling many variants of MIPS to use the same
  set of basic functions
- fix a number of deficiencies in the relocate kernel assembly
- add support for SMP
- enhanced support for 64-bit
- improvements to indirection page handling for relocate kernel mechanism.
  When kexec loads the image into kernel memory, it creates a list
  of pages of four different types: indirection, source, destination
  and done. Some manipulation was done on the first page which is
  an indirection page in the case of a fast-reboot kernel, so that
  the assembly code would handle it as such. The fact is, the asm
  code is already capable of handling it without such prior work
  being done, with a very small change, ie. loading the address of
  the variable containing the page instead of the address of the
  page itself. This also allows putting in a dummy DONE page for
  the crash kernel case, since no list of pages is built because
  the kernel is already loaded in its final resting place.

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 arch/mips/Makefile                 |    4 ++
 arch/mips/kernel/crash_dump.c      |   41 +++++++++++-----
 arch/mips/kernel/machine_kexec.c   |   20 ++++++--
 arch/mips/kernel/relocate_kernel.S |   95 ++++++++++++++++++++++++++++--------
 arch/mips/kernel/setup.c           |   28 ++++++++---
 include/asm-mips/bootinfo.h        |    2 +
 include/asm-mips/kexec.h           |    2 +-
 7 files changed, 147 insertions(+), 45 deletions(-)

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index c67705b..84b5241 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -582,6 +582,10 @@ core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/txx9/rbtx4938/
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
+ifdef CONFIG_PHYSICAL_START
+load-y				= $(CONFIG_PHYSICAL_START)
+endif
+
 ifdef CONFIG_32BIT
 ifdef CONFIG_CPU_LITTLE_ENDIAN
 JIFFIES			= jiffies_64
diff --git a/arch/mips/kernel/crash_dump.c b/arch/mips/kernel/crash_dump.c
index 533035b..4e63d7f 100644
--- a/arch/mips/kernel/crash_dump.c
+++ b/arch/mips/kernel/crash_dump.c
@@ -61,21 +61,36 @@ ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
 	if (!csize)
 		return 0;
 
-	vaddr = kmap_atomic_pfn(pfn, KM_PTE0);
-
-	if (!userbuf) {
-		memcpy(buf, (vaddr + offset), csize);
-		kunmap_atomic(vaddr, KM_PTE0);
+	/* see if the PFN is valid and present */
+	if (pfn_present(pfn) && pfn_valid(pfn)) {
+		vaddr = kmap_atomic_pfn(pfn, KM_PTE0);
+
+		if (!userbuf) {
+			memcpy(buf, (vaddr + offset), csize);
+			kunmap_atomic(vaddr, KM_PTE0);
+		} else {
+			if (!kdump_buf_page) {
+				printk(KERN_WARNING "Kdump: Kdump buffer " \
+					"page not allocated\n");
+				return -EFAULT;
+			}
+			copy_page(kdump_buf_page, vaddr);
+			kunmap_atomic(vaddr, KM_PTE0);
+			if (copy_to_user(buf,
+				(kdump_buf_page + offset), csize))
+				return -EFAULT;
+		}
 	} else {
-		if (!kdump_buf_page) {
-			printk(KERN_WARNING "Kdump: Kdump buffer page not"
-			       " allocated\n");
-			return -EFAULT;
+		/* the PFN isn't present and/or valid in the paging tables
+		 * use the __va() macro to get the virtual address from the PFN
+		 */
+		vaddr = (void *)(__va(pfn * PAGE_SIZE));
+		if (!userbuf) {
+			memcpy(buf, (vaddr + offset), csize);
+		} else {
+			if (copy_to_user(buf, (vaddr + offset), csize))
+				return -EFAULT;
 		}
-		copy_page(kdump_buf_page, vaddr);
-		kunmap_atomic(vaddr, KM_PTE0);
-		if (copy_to_user(buf, (kdump_buf_page + offset), csize))
-			return -EFAULT;
 	}
 
 	return csize;
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index 9c268ed..45fd919 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -70,8 +70,20 @@ machine_kexec(struct kimage *image)
 
 	kexec_start_address = (unsigned long) phys_to_virt(image->start);
 
-	kexec_indirection_page =
-		(unsigned long) phys_to_virt(image->head & PAGE_MASK);
+	/* kexec_indirection_page is marked with the IND_INDIRECTION flag
+	 * in the lower bits of the address. The assembly code in
+	 * relocate_kernel.S will take care of masking it off.
+	 *
+	 * The image->head is a physical address: we need the virtual mapping.
+	 *
+	 * In the case of a crash_dump kernel, assign a dummy IND_DONE page
+	 */
+	if(KEXEC_TYPE_CRASH == image->type) {
+		kexec_indirection_page = IND_DONE;
+	} else {
+		kexec_indirection_page =
+			(unsigned long)phys_to_virt(image->head);
+	}
 
 	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
 	       relocate_new_kernel_size);
@@ -114,7 +126,7 @@ machine_kexec(struct kimage *image)
  * Useful for holding code to do something appropriate
  * after a kernel panic.
  */
-static int __init parse_crashkernel(char *arg) {
+static int __init mips_parse_crashkernel(char *arg) {
 	unsigned long size, base;
 
 	size = memparse(arg, &arg);
@@ -130,4 +142,4 @@ static int __init parse_crashkernel(char *arg) {
 
 	return 0;
 }
-early_param("crashkernel", parse_crashkernel);
+early_param("crashkernel", mips_parse_crashkernel);
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index e1e5628..4324671 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -21,7 +21,7 @@ LEAF(relocate_new_kernel)
      PTR_L a2,    arg2
      PTR_L a3,    arg3
 
-	PTR_L		s0, kexec_indirection_page
+	PTR_LA		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
 
 process_entry:
@@ -31,25 +31,40 @@ process_entry:
 	/* destination page */
 	and		s3, s2, 0x1
 	beq		s3, zero, 1f
+	nop
 	and		s4, s2, ~0x1	/* store destination addr in s4 */
+
+	nop
 	b		process_entry
+	nop
 
 1:
 	/* indirection page, update s0  */
 	and		s3, s2, 0x2
 	beq		s3, zero, 1f
+	nop
 	and		s0, s2, ~0x2
+
+	nop
+
 	b		process_entry
+	nop
 
 1:
 	/* done page */
 	and		s3, s2, 0x4
 	beq		s3, zero, 1f
+	nop
+
+	nop
 	b		done
+	nop
+
 1:
 	/* source page */
 	and		s3, s2, 0x8
 	beq		s3, zero, process_entry
+	nop
 	and		s2, s2, ~0x8
 	li		s6, (1 << PAGE_SHIFT) / SZREG
 
@@ -60,9 +75,15 @@ copy_word:
 	PTR_ADD		s4, s4, SZREG
 	PTR_ADD		s2, s2, SZREG
 	LONG_SUB	s6, s6, 1
-	beq		s6, zero, process_entry
+	beq		s6, zero, 1f
+	nop
 	b		copy_word
-	b		process_entry
+	nop
+
+1:
+	nop
+	b 		process_entry
+	nop
 
 done:
 #ifdef CONFIG_SMP
@@ -70,21 +91,32 @@ done:
         was moved to it's location. Note - we need relocated address
         of kexec_flag.  */
 
-     bal        1f
- 1:     move        t1,ra;
-     PTR_LA        t2,1b
-     PTR_LA        t0,kexec_flag
-     PTR_SUB        t0,t0,t2;
-     PTR_ADD        t0,t1,t0;
-     LONG_S        zero,(t0)
+	.align	3
+	bal	1f
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra, ra, -8
+	move		t1, ra;
+	PTR_LA		t2, done
+	PTR_LA		t0, kexec_flag
+	PTR_SUB		t0, t0, t2;
+	PTR_ADD		t0, t1, t0;
+	LONG_S		zero, (t0)
 #endif
 
      /* Some platforms need I-cache to be flushed before
      * jumping to new kernel.
       */
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	cache	0, 0($0)
+#endif
 
 	/* jump to kexec_start_address */
 	j		s1
+	nop
+	nop
+	nop
 	END(relocate_new_kernel)
 
 #ifdef CONFIG_SMP
@@ -104,18 +136,31 @@ LEAF(kexec_smp_wait)
      * kexec_flag.
      */
 
-    bal        1f
-1:    move        t1,ra;
-    PTR_LA        t2,1b
-    PTR_LA        t0,kexec_flag
-    PTR_SUB        t0,t0,t2;
-    PTR_ADD        t0,t1,t0;
+wait:
+	.align	3
+	bal	1f
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-8
+	move		t1,ra;
+	PTR_LA		t2,wait
+	PTR_LA		t0,kexec_flag
+	PTR_SUB		t0,t0,t2;
+	PTR_ADD		t0,t1,t0;
 
-1:    LONG_L        s0, (t0)
-    bne        s0, zero,1b
+1:
+	LONG_L		s0,(t0)
+	bne		s0, zero,1b
+	nop
+
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	cache	0, 0($0)
+#endif
 
-    j        s1
-    END(kexec_smp_wait)
+	j        s1
+	nop
+	END(kexec_smp_wait)
 #endif
 
 
@@ -165,6 +210,16 @@ kexec_indirection_page:
 	PTR		0
 	.size		kexec_indirection_page, PTRSIZE
 
+kexec_bss_start:
+	EXPORT(kexec_bss_start)
+	PTR		0
+	.size		kexec_bss_start, PTRSIZE
+
+kexec_bss_stop:
+	EXPORT(kexec_bss_stop)
+	PTR		0
+	.size		kexec_bss_stop, PTRSIZE
+
 relocate_new_kernel_end:
 
 relocate_new_kernel_size:
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 1526f07..35ffffa 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -465,15 +465,22 @@ static int __init early_parse_mem(char *p)
 }
 early_param("mem", early_parse_mem);
 
-static void __init arch_mem_init(char **cmdline_p)
+static inline unsigned long long get_total_mem(void)
 {
-	extern void plat_mem_setup(void);
+	unsigned long long total;
 
-	/* call board setup routine */
-	plat_mem_setup();
+	total = max_low_pfn - min_low_pfn;
+#ifdef CONFIG_HIGHMEM
+	total += highend_pfn - highstart_pfn;
+#endif
+
+	return total << PAGE_SHIFT;
+}
 
-	pr_info("Determined physical RAM map:\n");
-	print_memory_map();
+
+static void __init arch_mem_init(char **cmdline_p)
+{
+	extern void plat_mem_setup(void);
 
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
 	strlcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
@@ -482,16 +489,23 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	parse_early_param();
 
+	plat_mem_setup();
+
 	if (usermem) {
 		pr_info("User-defined physical RAM map:\n");
 		print_memory_map();
+	} else {
+		pr_info("Determined physical RAM map:\n");
+		print_memory_map();
 	}
 
 	bootmem_init();
 #ifdef CONFIG_KEXEC
+	pr_info("Crashkernel info:\n");
+	pr_info("\tstart=%llu end=%llu\n", crashk_res.start, crashk_res.end);
 	if (crashk_res.start != crashk_res.end)
 		reserve_bootmem(crashk_res.start,
-				crashk_res.end - crashk_res.start + 1);
+			crashk_res.end - crashk_res.start + 1, 0);
 #endif
 	sparse_init();
 	paging_init();
diff --git a/include/asm-mips/bootinfo.h b/include/asm-mips/bootinfo.h
index 610fe3a..5d410bb 100644
--- a/include/asm-mips/bootinfo.h
+++ b/include/asm-mips/bootinfo.h
@@ -102,6 +102,8 @@ extern char arcs_cmdline[CL_SIZE];
  */
 extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
 
+extern void plat_kexec_setup(void);
+
 /*
  * Platform memory detection hook called by setup_arch
  */
diff --git a/include/asm-mips/kexec.h b/include/asm-mips/kexec.h
index 72e9721..54302d4 100644
--- a/include/asm-mips/kexec.h
+++ b/include/asm-mips/kexec.h
@@ -9,7 +9,7 @@
 #ifndef _MIPS_KEXEC
 #define _MIPS_KEXEC
 
-#include <linux/stacktrace.h>
+#include <asm/stacktrace.h>
 
 /* Maximum physical address we can use pages from */
 #define KEXEC_SOURCE_MEMORY_LIMIT (0x20000000)
-- 
1.6.3.1

