From 73d445fe9e9b6529a58ab15ad4a35aa32ea2edb4 Mon Sep 17 00:00:00 2001
From: Michel Thebeau <michel.thebeau@windriver.com>
Date: Mon, 4 Mar 2013 17:34:37 -0500
Subject: [PATCH 2/2] msa: do not lock tasklist_lock in atomic context

On a preempt rt kernel, calling sys_msa would result in a BUG:

BUG: sleeping function called from invalid context at
/project/bitbake_build/tmp/work/qemux86-wrs-linux/linux-windriver-3.4-r0/linux/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 0, pid: 1477, name: time-ruse.o
Pid: 1477, comm: time-ruse.o Not tainted
3.4.28-rt40-WR5.0.1.0_preempt-rt #1
Call Trace:
 [<c105d3ce>] __might_sleep+0xce/0xf0
 [<c1688c5c>] __rt_spin_lock+0x1c/0x40
 [<c1688da3>] rt_read_lock+0x23/0x30
 [<c1058f63>] sys_msa+0x233/0x2f0
 [<c102be1d>] ? kmap_atomic_prot+0x3d/0xe0
 [<c105e7ab>] ? get_parent_ip+0xb/0x40
 [<c168c623>] ? sub_preempt_count+0x73/0xb0
 [<c105ff07>] ? msa_user_time+0x147/0x1c0
 [<c1058772>] ? msa_kernel+0x92/0xa0
 [<c168f5d7>] sysenter_do_call+0x12/0x26

read_lock and unlock cannot be called in the atomic context, when
preempt is disabled.  Solve this by moving the lock and unlock outside
of atomic context.

Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>
---
 kernel/msa.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/kernel/msa.c b/kernel/msa.c
index ae7c3e3..90ce356 100644
--- a/kernel/msa.c
+++ b/kernel/msa.c
@@ -463,11 +463,12 @@ SYSCALL_DEFINE3(msa, int, ntimers, int, which, msa_time_t __user *, timers)
 		break;
 
 	case MSA_SELF:
+		read_lock(&tasklist_lock);
 		preempt_disable();
+
 		__msa_set_timer(msp, MSA_ONCPU_SYS);
 
 		memset(out.timers, 0, sizeof(out.timers));
-		read_lock(&tasklist_lock);
 		leader_task = task = current->group_leader;
 		do {
 			tp = task->microstates.timers;
@@ -475,10 +476,11 @@ SYSCALL_DEFINE3(msa, int, ntimers, int, which, msa_time_t __user *, timers)
 			for (i = 0; i < ntimers; i++)
 				*tp1++ += *tp++;
 		} while ((task = next_thread(task)) != leader_task);
-		read_unlock(&tasklist_lock);
 		tp = out.timers;
 
 		preempt_enable();
+		read_unlock(&tasklist_lock);
+
 		break;
 
 	case MSA_CHILDREN:
-- 
1.7.9.7

