From b8427c6b627cf207428c4b43b837cc8ab28b0f46 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Thu, 6 May 2010 14:26:38 -0500
Subject: [PATCH 03/18] msa-proc

Source: git://microstate.git.sourceforge.net/gitroot/microstate/microstate
MR: 37518
Type: Integration
Disposition: Local
ChangeID: 1e08db1f39dae519301a8827599af0aa3caa0b32
Description:

Add a proc filesystem interface for microstate accounting.  The time spent
in irqs is displayed in /proc/msa_irq_time.  Each process has an "msa"
entry in /proc/<pid> that has the tasks's measurements.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Dale Farnsworth <dfarnsworth@mvista.com>
---
 fs/proc/base.c | 146 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/msa.c   |  91 +++++++++++++++++++++++++++++++++++
 2 files changed, 237 insertions(+)

diff --git a/fs/proc/base.c b/fs/proc/base.c
index 9fc77b4..5830be5 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -88,6 +88,7 @@
 #include <asm/hardwall.h>
 #endif
 #include <trace/events/oom.h>
+#include <linux/msa.h>
 #include "internal.h"
 
 /* NOTE:
@@ -2938,6 +2939,145 @@ static int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,
 	return err;
 }
 
+#ifdef CONFIG_MICROSTATE_ACCT
+/*
+ * provides microstate accounting information
+ *
+ */
+static const char * const statenames[] = {
+	"User",
+	"System",
+	"Interruptible",
+	"Uninterruptible",
+	"OnRunQueue",
+	"Zombie",
+	"Stopped",
+	"Interrupted",
+	"Paging",
+	"Futex",
+	"Poll"
+};
+
+static int proc_tid_msa(struct task_struct *task, char *buffer)
+{
+	struct microstates *msp = &task->microstates;
+	msa_time_t now;
+	msa_time_t *tp;
+	struct microstates msp1;
+
+	memcpy(&msp1, msp, sizeof(*msp));
+	tp = msp1.timers;
+
+	switch (msp1.cur_state) {
+	case MSA_ONCPU_USER:
+	case MSA_ONCPU_SYS:
+	case MSA_ONRUNQUEUE:
+		now = msp1.last_change;
+		break;
+	default:
+		MSA_NOW(now);
+		tp[msp1.cur_state] += now - msp1.last_change;
+	}
+	return
+	  sprintf(buffer,
+		  "State:      %s\n"		\
+		  "Now:	       %15llu\n"	\
+		  "ONCPU_USER      %15llu\n"	\
+		  "ONCPU_SYS       %15llu\n"	\
+		  "INTERRUPTIBLE   %15llu\n"	\
+		  "UNINTERRUPTIBLE %15llu\n"	\
+		  "INTERRUPTED     %15llu\n"	\
+		  "RUNQUEUE        %15llu\n"	\
+		  "STOPPED         %15llu\n"	\
+		  "ZOMBIE          %15llu\n"	\
+		  "SLP_POLL        %15llu\n"	\
+		  "SLP_PAGING      %15llu\n"	\
+		  "SLP_FUTEX       %15llu\n",	\
+		  msp1.cur_state >= 0 && msp1.cur_state < MSA_NR_STATES ?
+		  statenames[msp1.cur_state] : "Impossible",
+		  (unsigned long long)MSA_TO_NSEC(now),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONCPU_USER]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONCPU_SYS]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_INTERRUPTIBLE_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_UNINTERRUPTIBLE_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_INTERRUPTED]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONRUNQUEUE]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_STOPPED]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ZOMBIE]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_POLL_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_PAGING_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_FUTEX_SLEEP]));
+}
+
+/*
+ * Sum resource usage for self + children.
+ * Only a snapshot, don't worry about things changing under foot.
+ */
+
+static int proc_tgid_msa(struct task_struct *task, char *buffer)
+{
+	msa_time_t *tp;
+	msa_time_t *tp1;
+	struct microstates msp1;
+	struct microstates msp2;
+	int i;
+	msa_time_t now;
+
+	enum msa_thread_state cur_state = MSA_NR_STATES;
+
+	if (thread_group_empty(task))
+		return proc_tid_msa(task, buffer);
+
+	memset(&msp2, 0, sizeof msp2);
+	MSA_NOW(now);
+	read_lock(&tasklist_lock);
+	do {
+		msp1 = task->microstates;
+		if (msp1.cur_state < cur_state)
+			cur_state = msp1.cur_state;
+		for (i = 0, tp = msp1.timers, tp1 = msp2.timers;
+		     i < MSA_NR_STATES;
+		     i++)
+			*tp1++ += *tp++;
+		task = next_thread(task);
+	} while (!thread_group_leader(task));
+	read_unlock(&tasklist_lock);
+
+	tp = msp2.timers;
+
+	return
+	  sprintf(buffer,
+		  "State:         %s\n"		\
+		  "Now:	       %15llu\n"	\
+		  "ONCPU_USER     %15llu\n"	\
+		  "ONCPU_SYS      %15llu\n"	\
+		  "INTERRUPTIBLE  %15llu\n"	\
+		  "UNINTERRUPTIBLE%15llu\n"	\
+		  "INTERRUPTED    %15llu\n"	\
+		  "RUNQUEUE       %15llu\n"	\
+		  "STOPPED        %15llu\n"	\
+		  "ZOMBIE         %15llu\n"	\
+		  "SLP_POLL       %15llu\n"	\
+		  "SLP_PAGING     %15llu\n"	\
+		  "SLP_FUTEX      %15llu\n",	\
+		  msp1.cur_state >= 0 && msp1.cur_state < MSA_NR_STATES ?
+		  statenames[msp1.cur_state] : "Impossible",
+		  (unsigned long long)MSA_TO_NSEC(now),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONCPU_USER]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONCPU_SYS]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_INTERRUPTIBLE_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_UNINTERRUPTIBLE_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_INTERRUPTED]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ONRUNQUEUE]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_STOPPED]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_ZOMBIE]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_POLL_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_PAGING_SLEEP]),
+		  (unsigned long long)MSA_TO_NSEC(tp[MSA_FUTEX_SLEEP]));
+}
+
+#endif /* CONFIG_MICROSTATE_ACCT */
+
 /*
  * Thread groups
  */
@@ -3029,6 +3169,9 @@ static const struct pid_entry tgid_base_stuff[] = {
 #ifdef CONFIG_HARDWALL
 	INF("hardwall",   S_IRUGO, proc_pid_hardwall),
 #endif
+#ifdef CONFIG_MICROSTATE_ACCT
+	INF("msa",	S_IRUGO, proc_tgid_msa),
+#endif
 };
 
 static int proc_tgid_base_readdir(struct file * filp,
@@ -3384,6 +3527,9 @@ static const struct pid_entry tid_base_stuff[] = {
 #ifdef CONFIG_HARDWALL
 	INF("hardwall",   S_IRUGO, proc_pid_hardwall),
 #endif
+#ifdef CONFIG_MICROSTATE_ACCT
+	INF("msa",	 S_IRUGO, proc_tid_msa),
+#endif
 };
 
 static int proc_tid_base_readdir(struct file * filp,
diff --git a/kernel/msa.c b/kernel/msa.c
index 039e9ab..72e9eb0 100644
--- a/kernel/msa.c
+++ b/kernel/msa.c
@@ -447,6 +447,97 @@ SYSCALL_DEFINE3(msa, int, ntimers, int, which, msa_time_t __user *, timers)
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
+
+/*
+ * Display the total number of nanoseconds since boot spent
+ * in handling each interrupt on each processor.
+ */
+
+static void *msa_irq_time_seq_start(struct seq_file *f, loff_t *pos)
+{
+	return (*pos <= NR_IRQS) ? pos : NULL;
+}
+
+static void *msa_irq_time_seq_next(struct seq_file *f, void *v, loff_t *pos)
+{
+	(*pos)++;
+	if (*pos > NR_IRQS)
+		return NULL;
+	return pos;
+}
+
+static void msa_irq_time_seq_stop(struct seq_file *f, void *v)
+{
+	/* Nothing to do */
+}
+
+static int msa_irq_time_seq_show(struct seq_file *f, void *v)
+{
+	int i = *(loff_t *) v, cpu;
+
+	if (i == 0) {
+		msa_time_t now;
+		char cpuname[10];
+		MSA_NOW(now);
+		seq_printf(f, "Now: %15llu\n", now);
+		seq_printf(f, "     ");
+		for_each_present_cpu(cpu) {
+			sprintf(cpuname, "CPU%d", cpu);
+			seq_printf(f, " %15s", cpuname);
+		}
+		seq_putc(f, '\n');
+	}
+
+	if (i < NR_IRQS) {
+		int all_zeroes = 0;
+		for_each_present_cpu(cpu)
+			if (!(all_zeroes = !per_cpu(msa_irq, cpu)[i].times))
+				break;
+		if (all_zeroes)
+			return 0;
+		seq_printf(f, "%3d: ", i);
+		for_each_present_cpu(cpu) {
+			msa_time_t x = MSA_TO_NSEC(per_cpu(msa_irq, cpu)[i].times);
+			seq_printf(f, " %15llu", (unsigned long long)x);
+		}
+		seq_putc(f, '\n');
+	}
+
+	return 0;
+}
+
+static struct seq_operations msa_irq_time_seq_ops = {
+	.start	= msa_irq_time_seq_start,
+	.next	= msa_irq_time_seq_next,
+	.stop	= msa_irq_time_seq_stop,
+	.show	= msa_irq_time_seq_show,
+};
+
+static int msa_irq_time_open(struct inode *inode, struct file *filp)
+{
+	return seq_open(filp, &msa_irq_time_seq_ops);
+}
+
+static struct file_operations proc_msa_irq_time_ops = {
+	.open		= msa_irq_time_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static int __init proc_msa_irq_time_iinit(void)
+{
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry("msa_irq_time", 0, NULL);
+	if (entry)
+		entry->proc_fops = &proc_msa_irq_time_ops;
+	return 0;
+}
+
+fs_initcall(proc_msa_irq_time_iinit);
+#endif
+
 #else
 /*
  * Stub for sys_msa when CONFIG_MICROSTATE_ACCT is off.
-- 
1.8.0.1.264.g226dcb5

