From 38800b3276e1c5df598e86de40cc750e29cca300 Mon Sep 17 00:00:00 2001
From: Michel Thebeau <michel.thebeau@windriver.com>
Date: Mon, 4 Mar 2013 17:34:36 -0500
Subject: [PATCH 1/2] msa: remove if (which == MSA_SELF) block

There is no functionality change here.

The switch (which) statement cases for MSA_SELF and MSA_THREAD were
combined and then an if (which == MSA_SELF) used to distinguish the
two.

I am about the modify the MSA_SELF case in a way that MSA_THREAD case
should not be modified, so separate these two cases first.

Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>
---
 kernel/msa.c |   43 ++++++++++++++++++++++++-------------------
 1 file changed, 24 insertions(+), 19 deletions(-)

diff --git a/kernel/msa.c b/kernel/msa.c
index c67a7fd..ae7c3e3 100644
--- a/kernel/msa.c
+++ b/kernel/msa.c
@@ -443,6 +443,9 @@ SYSCALL_DEFINE3(msa, int, ntimers, int, which, msa_time_t __user *, timers)
 	int i;
 	struct microstates *msp = &current->microstates;
 	struct microstates out;
+	struct task_struct *task;
+	struct task_struct *leader_task;
+	msa_time_t *tp1;
 
 	WARN_ON(current->microstates.cur_state != MSA_ONCPU_SYS);
 
@@ -450,29 +453,31 @@ SYSCALL_DEFINE3(msa, int, ntimers, int, which, msa_time_t __user *, timers)
 		return -EINVAL;
 
 	switch (which) {
-	case MSA_SELF:
 	case MSA_THREAD:
 		preempt_disable();
+
 		__msa_set_timer(msp, MSA_ONCPU_SYS);
+		tp = msp->timers;
+
+		preempt_enable();
+		break;
+
+	case MSA_SELF:
+		preempt_disable();
+		__msa_set_timer(msp, MSA_ONCPU_SYS);
+
+		memset(out.timers, 0, sizeof(out.timers));
+		read_lock(&tasklist_lock);
+		leader_task = task = current->group_leader;
+		do {
+			tp = task->microstates.timers;
+			tp1 = out.timers;
+			for (i = 0; i < ntimers; i++)
+				*tp1++ += *tp++;
+		} while ((task = next_thread(task)) != leader_task);
+		read_unlock(&tasklist_lock);
+		tp = out.timers;
 
-		if (which == MSA_SELF) {
-			struct task_struct *task;
-			struct task_struct *leader_task;
-			msa_time_t *tp1;
-
-			memset(out.timers, 0, sizeof(out.timers));
-			read_lock(&tasklist_lock);
-			leader_task = task = current->group_leader;
-			do {
-				tp = task->microstates.timers;
-				tp1 = out.timers;
-				for (i = 0; i < ntimers; i++)
-					*tp1++ += *tp++;
-			} while ((task = next_thread(task)) != leader_task);
-			read_unlock(&tasklist_lock);
-			tp = out.timers;
-		} else
-			tp = msp->timers;
 		preempt_enable();
 		break;
 
-- 
1.7.9.7

