From fbea6f94048667b3e964ac3c8df3c60da46e68e9 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Tue, 16 Oct 2012 10:58:00 -0500
Subject: [PATCH 13/18] msa: Do MSA calls in schedule_ipi()

From the upstream project:
git://microstate.git.sourceforge.net/gitroot/microstate/linux-msa

The MSA calls for IRQs were missing in schedule_ipi(). Unfortunately,
that means having to pass extra stuff into that function.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
---
 include/linux/sched.h | 12 ++++++++++--
 kernel/sched/core.c   |  9 ++++++++-
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 89678af..4ce2c12 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -2346,11 +2346,19 @@ struct task_struct *fork_idle(int);
 extern void set_task_comm(struct task_struct *tsk, char *from);
 extern char *get_task_comm(char *to, struct task_struct *tsk);
 
+#ifdef CONFIG_MICROSTATE_ACCT
+#define SCHED_IPI_PARMS int irq, int is_going_to_user
+#define SCHED_IPI_PARMSET(a, b) a, b
+#else
+#define SCHED_IPI_PARMS void
+#define SCHED_IPI_PARMSET(a, b)
+#endif
+
 #ifdef CONFIG_SMP
-void scheduler_ipi(void);
+void scheduler_ipi(SCHED_IPI_PARMS);
 extern unsigned long wait_task_inactive(struct task_struct *, long match_state);
 #else
-static inline void scheduler_ipi(void) { }
+static inline void scheduler_ipi(SCHED_IPI_PARMS) { }
 static inline unsigned long wait_task_inactive(struct task_struct *p,
 					       long match_state)
 {
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 506f600..1c40a25 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1484,7 +1484,7 @@ static void sched_ttwu_pending(void)
 	raw_spin_unlock(&rq->lock);
 }
 
-void scheduler_ipi(void)
+void scheduler_ipi(SCHED_IPI_PARMS)
 {
 	if (llist_empty(&this_rq()->wake_list) && !got_nohz_idle_kick())
 		return;
@@ -1503,6 +1503,9 @@ void scheduler_ipi(void)
 	 * somewhat pessimize the simple resched case.
 	 */
 	irq_enter();
+#ifdef CONFIG_MICROSTATE_ACCT
+	msa_start_irq(irq);
+#endif
 	sched_ttwu_pending();
 
 	/*
@@ -1512,7 +1515,11 @@ void scheduler_ipi(void)
 		this_rq()->idle_balance = 1;
 		raise_softirq_irqoff(SCHED_SOFTIRQ);
 	}
+#ifdef CONFIG_MICROSTATE_ACCT
+	msa_irq_exit(irq, is_going_to_user);
+#else
 	irq_exit();
+#endif
 }
 
 static void ttwu_queue_remote(struct task_struct *p, int cpu)
-- 
1.8.0.1.264.g226dcb5

