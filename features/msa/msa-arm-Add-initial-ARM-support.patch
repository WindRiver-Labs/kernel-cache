From 34fc831691f2eb35f30b0a3033b9beb738dcf85d Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Tue, 16 Oct 2012 11:31:00 -0500
Subject: [PATCH 16/18] msa-arm: Add initial ARM support

From the upstream project:
git://microstate.git.sourceforge.net/gitroot/microstate/linux-msa

Signed-off-by: Corey Minyard <cminyard@mvista.com>
[MA: update syscall numbers due to sched deadline]
Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 arch/arm/Kconfig.debug         | 22 ++++++++++++++++++++++
 arch/arm/include/asm/msa.h     | 16 ++++++++++++++++
 arch/arm/include/asm/unistd.h  |  3 ++-
 arch/arm/kernel/calls.S        |  1 +
 arch/arm/kernel/entry-common.S | 11 ++++++++++-
 arch/arm/kernel/irq.c          |  3 ++-
 arch/arm/kernel/smp.c          | 14 +++++++++-----
 7 files changed, 62 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/include/asm/msa.h

diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 85348a0..435ea5a 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -332,4 +332,26 @@ config ARM_KPROBES_TEST
 	help
 	  Perform tests of kprobes API and instruction set simulation.
 
+config MICROSTATE_ACCT
+	bool "Microstate accounting"
+	help
+	  This option causes the kernel to keep very accurate track of
+	  how long your threads spend on the runqueues, running, or asleep or
+	  stopped.  It will slow down your kernel.
+	  Times are reported in /proc/pid/msa and through a new msa()
+	  system call.
+
+choice
+	depends on MICROSTATE_ACCT
+	prompt "Microstate timing source"
+	default MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE
+
+config MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE
+        bool "Use the sched_clock clocksource for microstate timing"
+        help
+	  Use the kernel's built-in sched_clock clock-source for
+	  timing.
+
+endchoice
+
 endmenu
diff --git a/arch/arm/include/asm/msa.h b/arch/arm/include/asm/msa.h
new file mode 100644
index 0000000..46d2aad
--- /dev/null
+++ b/arch/arm/include/asm/msa.h
@@ -0,0 +1,16 @@
+/************************************************************************
+ * asm-arm/msa.h
+ *
+ * Provide an architecture-specific clock.
+ */
+
+#ifndef _ASM_ARM_MSA_H
+#define _ASM_ARM_MSA_H
+
+#if defined(CONFIG_MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE)
+# include <asm-generic/msa.h>
+#else
+# error "No clocksource defined for Microstate Accounting"
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 03e43ac..b13281b 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -407,8 +407,9 @@
 #define __NR_sched_setscheduler2	(__NR_SYSCALL_BASE+378)
 #define __NR_sched_setparam2		(__NR_SYSCALL_BASE+379)
 #define __NR_sched_getparam2		(__NR_SYSCALL_BASE+380)
+#define __NR_msa			(__NR_SYSCALL_BASE+381)
 
-#define __NR_syscall_max 380
+#define __NR_syscall_max 381
 
 /*
  * The following SWIs are ARM private.
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index be174eb..01c5644 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -390,6 +390,7 @@
 		CALL(sys_sched_setscheduler2)
 		CALL(sys_sched_setparam2)
 /* 380 */	CALL(sys_sched_getparam2)
+		CALL(sys_msa)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 54ee265..358fad2 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -32,6 +32,11 @@ ret_fast_syscall:
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
+#ifdef CONFIG_MICROSTATE_ACCT
+	stmdb	sp!,{r0}
+	bl	msa_user
+	ldmia	sp!,{r0}
+#endif
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
@@ -451,7 +456,11 @@ ENTRY(vector_swi)
 	ldmia	r0, {r0 - r3}			@ have to reload r0 - r3
 1:
 #endif
-
+#ifdef CONFIG_MICROSTATE_ACCT
+	bl	msa_kernel
+	add	r0, sp, #S_R0 + S_OFF		@ pointer to regs
+	ldmia	r0, {r0 - r3}			@ have to reload r0 - r3
+#endif
 	tst	r10, #_TIF_SYSCALL_WORK		@ are we tracing syscalls?
 	bne	__sys_trace
 
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 8349d4e..6e703e3 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -72,6 +72,7 @@ void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
+	msa_start_irq(irq);
 
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
@@ -88,7 +89,7 @@ void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 	/* AT91 specific workaround */
 	irq_finish(irq);
 
-	irq_exit();
+	msa_irq_exit(irq, user_mode(regs));
 	set_irq_regs(old_regs);
 }
 
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 8f14a1b..e8d089a 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -539,30 +539,34 @@ void handle_IPI(int ipinr, struct pt_regs *regs)
 	switch (ipinr) {
 	case IPI_TIMER:
 		irq_enter();
+		msa_start_irq(ipinr);
 		ipi_timer();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_RESCHEDULE:
-		scheduler_ipi();
+		scheduler_ipi(SCHED_IPI_PARMSET(ipinr, user_mode(regs)));
 		break;
 
 	case IPI_CALL_FUNC:
 		irq_enter();
+		msa_start_irq(ipinr);
 		generic_smp_call_function_interrupt();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_CALL_FUNC_SINGLE:
 		irq_enter();
+		msa_start_irq(ipinr);
 		generic_smp_call_function_single_interrupt();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_CPU_STOP:
 		irq_enter();
+		msa_start_irq(ipinr);
 		ipi_cpu_stop(cpu);
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	default:
-- 
1.8.0.1.264.g226dcb5

