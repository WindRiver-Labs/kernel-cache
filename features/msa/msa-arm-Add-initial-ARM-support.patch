From 593a906df6c6d1aab596126c72d04a35e524cf8e Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Tue, 16 Oct 2012 11:31:00 -0500
Subject: [PATCH 16/18] msa-arm: Add initial ARM support

Signed-off-by: Corey Minyard <cminyard@mvista.com>
---
 arch/arm/Kconfig.debug         |   22 ++++++++++++++++++++++
 arch/arm/include/asm/msa.h     |   16 ++++++++++++++++
 arch/arm/include/asm/unistd.h  |    1 +
 arch/arm/kernel/calls.S        |    1 +
 arch/arm/kernel/entry-common.S |   11 ++++++++++-
 arch/arm/kernel/irq.c          |    3 ++-
 arch/arm/kernel/smp.c          |   14 +++++++++-----
 7 files changed, 61 insertions(+), 7 deletions(-)
 create mode 100644 arch/arm/include/asm/msa.h

diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 85348a0..435ea5a 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -332,4 +332,26 @@ config ARM_KPROBES_TEST
 	help
 	  Perform tests of kprobes API and instruction set simulation.
 
+config MICROSTATE_ACCT
+	bool "Microstate accounting"
+	help
+	  This option causes the kernel to keep very accurate track of
+	  how long your threads spend on the runqueues, running, or asleep or
+	  stopped.  It will slow down your kernel.
+	  Times are reported in /proc/pid/msa and through a new msa()
+	  system call.
+
+choice
+	depends on MICROSTATE_ACCT
+	prompt "Microstate timing source"
+	default MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE
+
+config MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE
+        bool "Use the sched_clock clocksource for microstate timing"
+        help
+	  Use the kernel's built-in sched_clock clock-source for
+	  timing.
+
+endchoice
+
 endmenu
diff --git a/arch/arm/include/asm/msa.h b/arch/arm/include/asm/msa.h
new file mode 100644
index 0000000..46d2aad
--- /dev/null
+++ b/arch/arm/include/asm/msa.h
@@ -0,0 +1,16 @@
+/************************************************************************
+ * asm-arm/msa.h
+ *
+ * Provide an architecture-specific clock.
+ */
+
+#ifndef _ASM_ARM_MSA_H
+#define _ASM_ARM_MSA_H
+
+#if defined(CONFIG_MICROSTATE_ACCT_SCHED_CLOCK_CLOCKSOURCE)
+# include <asm-generic/msa.h>
+#else
+# error "No clocksource defined for Microstate Accounting"
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 512cd14..7904bde 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -404,6 +404,7 @@
 #define __NR_setns			(__NR_SYSCALL_BASE+375)
 #define __NR_process_vm_readv		(__NR_SYSCALL_BASE+376)
 #define __NR_process_vm_writev		(__NR_SYSCALL_BASE+377)
+#define __NR_msa			(__NR_SYSCALL_BASE+378)
 
 /*
  * The following SWIs are ARM private.
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 463ff4a..edad3ed 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -387,6 +387,7 @@
 /* 375 */	CALL(sys_setns)
 		CALL(sys_process_vm_readv)
 		CALL(sys_process_vm_writev)
+		CALL(sys_msa)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 54ee265..358fad2 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -32,6 +32,11 @@ ret_fast_syscall:
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
+#ifdef CONFIG_MICROSTATE_ACCT
+	stmdb	sp!,{r0}
+	bl	msa_user
+	ldmia	sp!,{r0}
+#endif
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
@@ -451,7 +456,11 @@ ENTRY(vector_swi)
 	ldmia	r0, {r0 - r3}			@ have to reload r0 - r3
 1:
 #endif
-
+#ifdef CONFIG_MICROSTATE_ACCT
+	bl	msa_kernel
+	add	r0, sp, #S_R0 + S_OFF		@ pointer to regs
+	ldmia	r0, {r0 - r3}			@ have to reload r0 - r3
+#endif
 	tst	r10, #_TIF_SYSCALL_WORK		@ are we tracing syscalls?
 	bne	__sys_trace
 
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 8349d4e..6e703e3 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -72,6 +72,7 @@ void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
+	msa_start_irq(irq);
 
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
@@ -88,7 +89,7 @@ void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 	/* AT91 specific workaround */
 	irq_finish(irq);
 
-	irq_exit();
+	msa_irq_exit(irq, user_mode(regs));
 	set_irq_regs(old_regs);
 }
 
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 8f46446..b32e43d 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -533,30 +533,34 @@ void handle_IPI(int ipinr, struct pt_regs *regs)
 	switch (ipinr) {
 	case IPI_TIMER:
 		irq_enter();
+		msa_start_irq(ipinr);
 		ipi_timer();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_RESCHEDULE:
-		scheduler_ipi();
+		scheduler_ipi(SCHED_IPI_PARMSET(ipinr, user_mode(regs)));
 		break;
 
 	case IPI_CALL_FUNC:
 		irq_enter();
+		msa_start_irq(ipinr);
 		generic_smp_call_function_interrupt();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_CALL_FUNC_SINGLE:
 		irq_enter();
+		msa_start_irq(ipinr);
 		generic_smp_call_function_single_interrupt();
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	case IPI_CPU_STOP:
 		irq_enter();
+		msa_start_irq(ipinr);
 		ipi_cpu_stop(cpu);
-		irq_exit();
+		msa_irq_exit(ipinr, user_mode(regs));
 		break;
 
 	default:
-- 
1.7.9.7

