From 816c38567a4de5f0b0e129b38b2439275096f38e Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe.macdonald@windriver.com>
Date: Thu, 12 Apr 2012 13:09:45 -0400
Subject: [PATCH 4/5] grsec: Adding debug, resolving race during acl init

Disabled-by-default debug code for tracking down ACL issues, replacing a
read_lock with a write_lock during gracl_init().

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 fs/exec.c          |   14 ++++++++++++++
 grsecurity/gracl.c |   39 +++++++++++++++++++++++++++++++++++++--
 2 files changed, 51 insertions(+), 2 deletions(-)

diff --git a/fs/exec.c b/fs/exec.c
index 4cd2bfd..0cc7372 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -75,6 +75,11 @@ void (*pax_set_initial_flags_func)(struct linux_binprm *bprm);
 EXPORT_SYMBOL(pax_set_initial_flags_func);
 #endif
 
+#ifdef CONFIG_GRKERNSEC
+/* Define this if you think you'll need to debug RBAC/ACL problems. */
+#undef CONFIG_GRKERNSEC_ACL_DEBUG
+#endif
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 unsigned int core_pipe_limit;
@@ -1497,6 +1502,10 @@ int do_execve(char * filename,
 
 #ifdef CONFIG_GRKERNSEC
 	old_acl = current->acl;
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	if ((!old_acl) && gr_acl_is_enabled())
+		printk(KERN_ALERT "grsec: old_acl NULL\n");
+#endif
 	memcpy(old_rlim, current->signal->rlim, sizeof(old_rlim));
 	old_exec_file = current->exec_file;
 	get_file(file);
@@ -1530,6 +1539,11 @@ int do_execve(char * filename,
 
 out_fail:
 #ifdef CONFIG_GRKERNSEC
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "grsec: do_execve failed (fn: %s)\n", filename);
+	if ((!old_acl) && gr_acl_is_enabled())
+		printk(KERN_ALERT "grsec: old_acl (still?) NULL\n");
+#endif
 	current->acl = old_acl;
 	memcpy(current->signal->rlim, old_rlim, sizeof(old_rlim));
 	fput(current->exec_file);
diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index b4a70f2..7eea946 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -30,6 +30,7 @@
 /* These produce a LOT of output but can be essential in debugging null pointer
  * dereferences associated with a missing ACL on subjects and objects. */
 #undef CONFIG_GRKERNSEC_ACL_DEBUG
+#undef CONFIG_GRKERNSEC_RBAC_DEBUG
 #undef CONFIG_GRKERNSEC_WARN_NULL_ACL
 
 extern spinlock_t vfsmount_lock;
@@ -847,6 +848,12 @@ create_table(__u32 * len, int elementsize)
 	return newtable;
 }
 
+/* back-ported from modern linux kernels for convenience */
+static inline dev_t __get_dev(const struct dentry *dentry)
+{
+	return dentry->d_inode->i_sb->s_dev;
+}
+
 static int
 init_variables(const struct gr_arg *arg)
 {
@@ -858,25 +865,42 @@ init_variables(const struct gr_arg *arg)
 	name_set.n_size = arg->role_db.num_objects;
 	inodev_set.i_size = arg->role_db.num_objects;
 
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	if (WARN_ONCE((!subj_map_set.s_size || !acl_role_set.r_size || !name_set.n_size || !inodev_set.i_size), "s:%d|a:%d|n:%d|i:%d", subj_map_set.s_size, acl_role_set.r_size, name_set.n_size,inodev_set.i_size))
+		BUG();
+
+	if (WARN_ONCE((!gr_init_uidset()), "gr_init_uidset failed"))
+		BUG();
+#else
 	if (!subj_map_set.s_size || !acl_role_set.r_size ||
 	    !name_set.n_size || !inodev_set.i_size)
 		return 1;
 
 	if (!gr_init_uidset())
 		return 1;
+#endif
 
 	/* set up the stack that holds allocation info */
 
 	stacksize = arg->role_db.num_pointers + 5;
 
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	if (WARN_ONCE((!acl_alloc_stack_init(stacksize)), "acl_alloc_stack_init failed"))
+		BUG();
+#else
 	if (!acl_alloc_stack_init(stacksize))
 		return 1;
+#endif
 
 	/* grab reference for the real root dentry and vfsmount */
-	read_lock(&reaper->fs->lock);
+	write_lock(&reaper->fs->lock);
 	real_root_mnt = mntget(reaper->fs->root.mnt);
 	real_root = dget(reaper->fs->root.dentry);
-	read_unlock(&reaper->fs->lock);
+	write_unlock(&reaper->fs->lock);
+#ifdef CONFIG_GRKERNSEC_RBAC_DEBUG
+	printk(KERN_ALERT "Obtained real root device=%d, inode=%lu\n", real_root, reaper->fs->root.dentry->d_inode);
+#endif
+
 
 	fakefs_obj = acl_alloc(sizeof(struct acl_object_label));
 	if (fakefs_obj == NULL)
@@ -1668,6 +1692,7 @@ gracl_init(struct gr_arg *args)
 	}
 
 	pax_open_kernel();
+	printk(KERN_ALERT "gracl_init complete\n");
 	gr_status |= GR_READY;
 	pax_close_kernel();
 
@@ -2468,6 +2493,9 @@ gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
 		return 0;
 
 	newacl = chk_subj_label(dentry, mnt, task->role);
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "grsec: (%s:%d) newacl: (%s:%d) role: %s\n",  task->comm, task->pid, newacl->filename, newacl->mode, task->role->rolename);
+#endif
 
 	task_lock(task);
 	if ((((task->ptrace & PT_PTRACED) || unsafe_share) &&
@@ -2486,6 +2514,13 @@ gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
 
 	obj = chk_obj_label(dentry, mnt, task->acl);
 	retmode = obj->mode & (GR_INHERIT | GR_AUDIT_INHERIT);
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "grsec: (%s:%d) ojb: (%s:%d)\n", task->comm, task->pid, obj->filename, obj->mode);
+	if (retmode & GR_INHERIT)
+		printk(KERN_ALERT "grsec: object mode: INHERIT\n");
+	if (retmode & GR_AUDIT_INHERIT)
+		printk(KERN_ALERT "grsec: object mode: AUDIT_INHERIT\n");
+#endif
 
 	if (!(task->acl->mode & GR_INHERITLEARN) &&
 	    ((newacl->mode & GR_LEARN) || !(retmode & GR_INHERIT))) {
-- 
1.7.4.1

