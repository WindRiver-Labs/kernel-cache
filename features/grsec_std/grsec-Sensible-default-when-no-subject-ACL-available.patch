From 0d985eaf1be4468486187a73f26da4902ed9c9a4 Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe.macdonald@windriver.com>
Date: Tue, 3 Apr 2012 22:51:46 +0800
Subject: [PATCH 2/5] grsec: Sensible default when no subject ACL available

Testing revealed a few scenarios where it's possible for the current task
to have no ACL associated with it.  Produce a warning when that happens
and return the most reasonable response available to us.

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 grsecurity/gracl.c          |   78 ++++++++++++++++++++++++++++++++++++-------
 grsecurity/gracl_cap.c      |    9 +++++
 grsecurity/gracl_fs.c       |    3 ++
 grsecurity/gracl_ip.c       |    4 ++
 grsecurity/gracl_learn.c    |    1 +
 grsecurity/gracl_segv.c     |    9 +++++
 grsecurity/gracl_shm.c      |    3 ++
 grsecurity/grsec_disabled.c |   12 +++++++
 grsecurity/grsec_log.c      |    2 +-
 include/linux/grinternal.h  |    2 +
 include/linux/grsecurity.h  |    2 +
 11 files changed, 112 insertions(+), 13 deletions(-)

diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index 8c428b0..28b5e61 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -90,6 +90,22 @@ extern void gr_remove_uid(uid_t uid);
 extern int gr_find_uid(uid_t uid);
 
 __inline__ int
+gr_acl_is_present(const struct task_struct *t)
+{
+	if (WARN_ONCE(t->acl == NULL, "No grsecurity acl for this task!"))
+		return 0;
+	return 1;
+}
+
+__inline__ int
+gr_acl_role_is_present(const struct task_struct *t)
+{
+	if (WARN_ONCE(t->role == NULL, "No grsecurity acl for this task!"))
+		return 0;
+	return 1;
+}
+
+__inline__ int
 gr_acl_is_enabled(void)
 {
 	return (gr_status & GR_READY);
@@ -384,6 +400,9 @@ lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
 	struct role_allowed_ip *ipp;
 	unsigned int x;
 
+	if (WARN_ONCE(acl_role_set.r_hash == NULL, "acl_rol_set.r_hash empty."))
+		return default_role;
+
 	match = acl_role_set.r_hash[index];
 
 	while (match) {
@@ -445,9 +464,13 @@ struct acl_subject_label *
 lookup_acl_subj_label(const ino_t ino, const dev_t dev,
 		      const struct acl_role_label *role)
 {
-	unsigned int index = fhash(ino, dev, role->subj_hash_size);
+	unsigned int index;
 	struct acl_subject_label *match;
 
+	if (WARN_ONCE(role == NULL, "No role for this subject. Returning NULL."))
+		return NULL;
+	index = fhash(ino, dev, role->subj_hash_size);
+
 	match = role->subj_hash[index];
 
 	while (match && (match->inode != ino || match->device != dev ||
@@ -465,9 +488,13 @@ struct acl_subject_label *
 lookup_acl_subj_label_deleted(const ino_t ino, const dev_t dev,
 			  const struct acl_role_label *role)
 {
-	unsigned int index = fhash(ino, dev, role->subj_hash_size);
+	unsigned int index;
 	struct acl_subject_label *match;
 
+	if (WARN_ONCE(role == NULL, "No role for this subject. Returning NULL."))
+		return NULL;
+	index = fhash(ino, dev, role->subj_hash_size);
+
 	match = role->subj_hash[index];
 
 	while (match && (match->inode != ino || match->device != dev ||
@@ -485,9 +512,13 @@ static struct acl_object_label *
 lookup_acl_obj_label(const ino_t ino, const dev_t dev,
 		     const struct acl_subject_label *subj)
 {
-	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	unsigned int index;
 	struct acl_object_label *match;
 
+	if (WARN_ONCE(subj == NULL, "No label for this object. Returning NULL."))
+		return NULL;
+	index = fhash(ino, dev, subj->obj_hash_size);
+
 	match = subj->obj_hash[index];
 
 	while (match && (match->inode != ino || match->device != dev ||
@@ -505,9 +536,13 @@ static struct acl_object_label *
 lookup_acl_obj_label_create(const ino_t ino, const dev_t dev,
 		     const struct acl_subject_label *subj)
 {
-	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	unsigned int index;
 	struct acl_object_label *match;
 
+	if (WARN_ONCE(subj == NULL, "No label for this object. Returning NULL."))
+		return NULL;
+	index = fhash(ino, dev, subj->obj_hash_size);
+
 	match = subj->obj_hash[index];
 
 	while (match && (match->inode != ino || match->device != dev ||
@@ -579,12 +614,16 @@ lookup_name_entry_create(const char *name)
 static struct inodev_entry *
 lookup_inodev_entry(const ino_t ino, const dev_t dev)
 {
-	unsigned int index = fhash(ino, dev, inodev_set.i_size);
+	unsigned int index;
 	struct inodev_entry *match;
 
+	if (WARN_ONCE(inodev_set.i_hash == NULL, "inodev_set.i_hash empty"))
+		return NULL;
+	index = fhash(ino, dev, inodev_set.i_size);
+
 	match = inodev_set.i_hash[index];
 
-	while (match && (match->nentry->inode != ino || match->nentry->device != dev))
+	while (match && match->nentry && (match->nentry->inode != ino || match->nentry->device != dev))
 		match = match->next;
 
 	return match;
@@ -593,10 +632,13 @@ lookup_inodev_entry(const ino_t ino, const dev_t dev)
 static void
 insert_inodev_entry(struct inodev_entry *entry)
 {
-	unsigned int index = fhash(entry->nentry->inode, entry->nentry->device,
-				    inodev_set.i_size);
+	unsigned int index;
 	struct inodev_entry **curr;
 
+	if (WARN_ONCE(inodev_set.i_hash == NULL, "inodev_set.i_hash empty"))
+		return;
+	index = fhash(entry->nentry->inode, entry->nentry->device,
+				    inodev_set.i_size);
 	entry->prev = NULL;
 
 	curr = &inodev_set.i_hash[index];
@@ -707,11 +749,14 @@ static void
 insert_acl_obj_label(struct acl_object_label *obj,
 		     struct acl_subject_label *subj)
 {
-	unsigned int index =
-	    fhash(obj->inode, obj->device, subj->obj_hash_size);
+	unsigned int index;
 	struct acl_object_label **curr;
 
-
+	if (WARN_ONCE(obj == NULL, "ERROR: Object label empty."))
+		return;
+	if (WARN_ONCE(subj == NULL, "ERROR: Subject label empty."))
+		return;
+	index = fhash(obj->inode, obj->device, subj->obj_hash_size);
 	obj->prev = NULL;
 
 	curr = &subj->obj_hash[index];
@@ -728,9 +773,14 @@ static void
 insert_acl_subj_label(struct acl_subject_label *obj,
 		      struct acl_role_label *role)
 {
-	unsigned int index = fhash(obj->inode, obj->device, role->subj_hash_size);
+	unsigned int index;
 	struct acl_subject_label **curr;
 
+	if (WARN_ONCE(obj == NULL, "ERROR: Object label empty."))
+		return;
+	if (WARN_ONCE(role == NULL, "ERROR: Role label empty."))
+		return;
+	index = fhash(obj->inode, obj->device, role->subj_hash_size);
 	obj->prev = NULL;
 
 	curr = &role->subj_hash[index];
@@ -1758,6 +1808,8 @@ __full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
 	struct acl_object_label *retval2;
 
 	tmpsubj = (struct acl_subject_label *) subj;
+	if (WARN_ONCE(tmpsubj == NULL, "ERROR: Initial subject label NULL."))
+		return NULL;
 	read_lock(&gr_inode_lock);
 	do {
 		retval = lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
@@ -2031,6 +2083,8 @@ gr_search_file(const struct dentry * dentry, const __u32 mode,
 		return (mode & ~GR_AUDITS);
 
 	curracl = current->acl;
+	if (WARN_ONCE(curracl == NULL, "No grsecurity acl for this task! Returning default mode."))
+		return retval;
 
 	currobj = chk_obj_label(dentry, mnt, curracl);
 	retval = currobj->mode & mode;
diff --git a/grsecurity/gracl_cap.c b/grsecurity/gracl_cap.c
index 2d7d3ca..abfeeb1 100644
--- a/grsecurity/gracl_cap.c
+++ b/grsecurity/gracl_cap.c
@@ -57,6 +57,9 @@ gr_is_capable(const int cap)
 		return 1;
 
 	curracl = task->acl;
+	if (WARN_ONCE(curracl == NULL,
+		      "No grsecurity acl for this task! Assuming not capable."))
+		return 0;
 
 	cap_drop = curracl->cap_lower;
 	cap_mask = curracl->cap_mask;
@@ -78,6 +81,9 @@ gr_is_capable(const int cap)
 		return 1;
 
 	curracl = task->acl;
+	if (WARN_ONCE(curracl == NULL,
+		      "No grsecurity acl for this task! Assuming not capable."))
+		return 0;
 
 	if ((curracl->mode & (GR_LEARN | GR_INHERITLEARN))
 	    && cap_raised(cred->cap_effective, cap)) {
@@ -106,6 +112,9 @@ gr_is_capable_nolog(const int cap)
 		return 1;
 
 	curracl = current->acl;
+	if (WARN_ONCE(curracl == NULL,
+		      "No grsecurity acl for this task! Assuming not capable."))
+		return 0;
 
 	cap_drop = curracl->cap_lower;
 	cap_mask = curracl->cap_mask;
diff --git a/grsecurity/gracl_fs.c b/grsecurity/gracl_fs.c
index 38edce4..41872ec 100644
--- a/grsecurity/gracl_fs.c
+++ b/grsecurity/gracl_fs.c
@@ -417,6 +417,9 @@ gr_acl_handle_procpidmem(const struct task_struct *task)
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
 
+	if (unlikely(!gr_acl_is_present(task)))
+		return 0;
+
 	if (task != current && task->acl->mode & GR_PROTPROCFD)
 		return -EACCES;
 
diff --git a/grsecurity/gracl_ip.c b/grsecurity/gracl_ip.c
index 3c183d5..07ec8ca 100644
--- a/grsecurity/gracl_ip.c
+++ b/grsecurity/gracl_ip.c
@@ -89,6 +89,8 @@ gr_search_socket(const int domain, const int type, const int protocol)
 	    || (domain >= NPROTO) || (type >= SOCK_MAX) || (protocol > 255))
 		goto exit;	// let the kernel handle it
 
+	if (unlikely(!gr_acl_is_present(current)))
+		goto exit;
 	curr = current->acl;
 
 	if (!curr->ips)
@@ -177,6 +179,8 @@ gr_search_connectbind(const int full_mode, struct sock *sk,
 
 	if (unlikely(!gr_acl_is_enabled() || sk->sk_family != PF_INET))
 		return 0;
+	if (unlikely(!gr_acl_is_present(current)))
+		return 0;
 
 	curr = current->acl;
 	isk = inet_sk(sk);
diff --git a/grsecurity/gracl_learn.c b/grsecurity/gracl_learn.c
index da3e24c..6afbf10 100644
--- a/grsecurity/gracl_learn.c
+++ b/grsecurity/gracl_learn.c
@@ -12,6 +12,7 @@
 extern ssize_t write_grsec_handler(struct file * file, const char __user * buf,
 				   size_t count, loff_t *ppos);
 extern int gr_acl_is_enabled(void);
+extern int gr_acl_is_present(const struct task_struct *);
 
 static DECLARE_WAIT_QUEUE_HEAD(learn_wait);
 static int gr_learn_attached;
diff --git a/grsecurity/gracl_segv.c b/grsecurity/gracl_segv.c
index 61ed7ed..f7feb49 100644
--- a/grsecurity/gracl_segv.c
+++ b/grsecurity/gracl_segv.c
@@ -201,6 +201,9 @@ gr_handle_crash(struct task_struct *task, const int sig)
 	if (unlikely(!gr_acl_is_enabled()))
 		return;
 
+	if (unlikely(!gr_acl_is_present(task)))
+		return;
+
 	curr = task->acl;
 
 	if (!(curr->resmask & (1 << GR_CRASH_RES)))
@@ -262,6 +265,9 @@ gr_check_crash_exec(const struct file *filp)
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
 
+	if (unlikely(!gr_acl_role_is_present(current)))
+		return 0;
+
 	read_lock(&gr_inode_lock);
 	curr = lookup_acl_subj_label(filp->f_path.dentry->d_inode->i_ino,
 				     filp->f_path.dentry->d_inode->i_sb->s_dev,
@@ -293,6 +299,9 @@ gr_handle_alertkill(struct task_struct *task)
 	if (unlikely(!gr_acl_is_enabled()))
 		return;
 
+	if (unlikely(!gr_acl_is_present(task)))
+		return;
+
 	curracl = task->acl;
 	curr_ip = task->signal->curr_ip;
 
diff --git a/grsecurity/gracl_shm.c b/grsecurity/gracl_shm.c
index b4803da..b1e1f3f 100644
--- a/grsecurity/gracl_shm.c
+++ b/grsecurity/gracl_shm.c
@@ -23,6 +23,9 @@ gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
 	if (unlikely(!task))
 		task = find_task_by_vpid(shm_lapid);
 
+	if (!gr_acl_is_present(task))
+		return 1;
+
 	if (unlikely(task && (time_before_eq((unsigned long)task->start_time.tv_sec, (unsigned long)shm_createtime) ||
 			      (task->pid == shm_lapid)) &&
 		     (task->acl->mode & GR_PROTSHM) &&
diff --git a/grsecurity/grsec_disabled.c b/grsecurity/grsec_disabled.c
index efddd6b..671612a 100644
--- a/grsecurity/grsec_disabled.c
+++ b/grsecurity/grsec_disabled.c
@@ -34,6 +34,18 @@ int gr_is_taskstats_denied(int pid)
 #endif
 
 int
+gr_acl_is_present(const struct task_struct *t)
+{
+	return 0;
+}
+
+int
+gr_acl_role_is_present(const struct task_struct *t)
+{
+	return 0;
+}
+
+int
 gr_acl_is_enabled(void)
 {
 	return 0;
diff --git a/grsecurity/grsec_log.c b/grsecurity/grsec_log.c
index c2f91ec..9d25a36 100644
--- a/grsecurity/grsec_log.c
+++ b/grsecurity/grsec_log.c
@@ -64,7 +64,7 @@ set_fmt:
 	} else if (current->signal->curr_ip) {
 		sprintf(fmt, "%s%s", loglevel, "grsec: From %pI4: ");
 		snprintf(buf, PAGE_SIZE - 1, fmt, &current->signal->curr_ip);
-	} else if (gr_acl_is_enabled()) {
+	} else if (gr_acl_is_enabled() && gr_acl_is_present(current)) {
 		sprintf(fmt, "%s%s", loglevel, "grsec: (%.64s:%c:%.950s) ");
 		snprintf(buf, PAGE_SIZE - 1, fmt, current->role->rolename, gr_roletype_to_char(), current->acl->filename);
 	} else {
diff --git a/include/linux/grinternal.h b/include/linux/grinternal.h
index 5bbc3ea..27fb21c 100644
--- a/include/linux/grinternal.h
+++ b/include/linux/grinternal.h
@@ -22,6 +22,8 @@ __u32 to_gr_audit(const __u32 reqmode);
 int gr_set_acls(const int type);
 
 int gr_acl_is_enabled(void);
+int gr_acl_is_present(const struct task_struct *t);
+int gr_acl_role_is_present(const struct task_struct *t);
 char gr_roletype_to_char(void);
 
 void gr_handle_alertkill(struct task_struct *task);
diff --git a/include/linux/grsecurity.h b/include/linux/grsecurity.h
index 5e9e8ea..eb1fa1a 100644
--- a/include/linux/grsecurity.h
+++ b/include/linux/grsecurity.h
@@ -120,6 +120,8 @@ __u32 gr_acl_handle_execve(const struct dentry *dentry,
 				  const struct vfsmount *mnt);
 int gr_check_crash_exec(const struct file *filp);
 int gr_acl_is_enabled(void);
+int gr_acl_is_present(const struct task_struct *t);
+int gr_acl_role_is_present(const struct task_struct *t);
 void gr_set_kernel_label(struct task_struct *task);
 void gr_set_role_label(struct task_struct *task, const uid_t uid,
 			      const gid_t gid);
-- 
1.7.4.1

