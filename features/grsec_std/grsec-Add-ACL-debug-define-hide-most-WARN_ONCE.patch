From db5d85d3c94fc872e7e494be4661470721eb8826 Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe.macdonald@windriver.com>
Date: Thu, 12 Apr 2012 10:27:59 -0400
Subject: [PATCH 3/5] grsec: Add ACL debug define, hide most WARN_ONCE

There's no way within LKC to enable the GRKERNSEC_ACL_DEBUG option, so
we'll just define it here.  This covers all of the places where it's used
anyway.

Also, the previous commit added a lot of WARN_ONCE calls that probably
don't need to be there.  ifdef them and set the default off.

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 grsecurity/gracl.c |   27 +++++++++++++++++++++++++++
 1 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index 28b5e61..b4a70f2 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -27,6 +27,11 @@
 #include <asm/errno.h>
 #include <asm/mman.h>
 
+/* These produce a LOT of output but can be essential in debugging null pointer
+ * dereferences associated with a missing ACL on subjects and objects. */
+#undef CONFIG_GRKERNSEC_ACL_DEBUG
+#undef CONFIG_GRKERNSEC_WARN_NULL_ACL
+
 extern spinlock_t vfsmount_lock;
 
 static struct acl_role_db acl_role_set;
@@ -400,8 +405,10 @@ lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
 	struct role_allowed_ip *ipp;
 	unsigned int x;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(acl_role_set.r_hash == NULL, "acl_rol_set.r_hash empty."))
 		return default_role;
+#endif
 
 	match = acl_role_set.r_hash[index];
 
@@ -467,8 +474,10 @@ lookup_acl_subj_label(const ino_t ino, const dev_t dev,
 	unsigned int index;
 	struct acl_subject_label *match;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(role == NULL, "No role for this subject. Returning NULL."))
 		return NULL;
+#endif
 	index = fhash(ino, dev, role->subj_hash_size);
 
 	match = role->subj_hash[index];
@@ -491,8 +500,10 @@ lookup_acl_subj_label_deleted(const ino_t ino, const dev_t dev,
 	unsigned int index;
 	struct acl_subject_label *match;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(role == NULL, "No role for this subject. Returning NULL."))
 		return NULL;
+#endif
 	index = fhash(ino, dev, role->subj_hash_size);
 
 	match = role->subj_hash[index];
@@ -515,8 +526,10 @@ lookup_acl_obj_label(const ino_t ino, const dev_t dev,
 	unsigned int index;
 	struct acl_object_label *match;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(subj == NULL, "No label for this object. Returning NULL."))
 		return NULL;
+#endif
 	index = fhash(ino, dev, subj->obj_hash_size);
 
 	match = subj->obj_hash[index];
@@ -539,8 +552,10 @@ lookup_acl_obj_label_create(const ino_t ino, const dev_t dev,
 	unsigned int index;
 	struct acl_object_label *match;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(subj == NULL, "No label for this object. Returning NULL."))
 		return NULL;
+#endif
 	index = fhash(ino, dev, subj->obj_hash_size);
 
 	match = subj->obj_hash[index];
@@ -617,8 +632,10 @@ lookup_inodev_entry(const ino_t ino, const dev_t dev)
 	unsigned int index;
 	struct inodev_entry *match;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(inodev_set.i_hash == NULL, "inodev_set.i_hash empty"))
 		return NULL;
+#endif
 	index = fhash(ino, dev, inodev_set.i_size);
 
 	match = inodev_set.i_hash[index];
@@ -635,8 +652,10 @@ insert_inodev_entry(struct inodev_entry *entry)
 	unsigned int index;
 	struct inodev_entry **curr;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(inodev_set.i_hash == NULL, "inodev_set.i_hash empty"))
 		return;
+#endif
 	index = fhash(entry->nentry->inode, entry->nentry->device,
 				    inodev_set.i_size);
 	entry->prev = NULL;
@@ -752,10 +771,12 @@ insert_acl_obj_label(struct acl_object_label *obj,
 	unsigned int index;
 	struct acl_object_label **curr;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(obj == NULL, "ERROR: Object label empty."))
 		return;
 	if (WARN_ONCE(subj == NULL, "ERROR: Subject label empty."))
 		return;
+#endif
 	index = fhash(obj->inode, obj->device, subj->obj_hash_size);
 	obj->prev = NULL;
 
@@ -776,10 +797,12 @@ insert_acl_subj_label(struct acl_subject_label *obj,
 	unsigned int index;
 	struct acl_subject_label **curr;
 
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(obj == NULL, "ERROR: Object label empty."))
 		return;
 	if (WARN_ONCE(role == NULL, "ERROR: Role label empty."))
 		return;
+#endif
 	index = fhash(obj->inode, obj->device, role->subj_hash_size);
 	obj->prev = NULL;
 
@@ -1808,8 +1831,10 @@ __full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
 	struct acl_object_label *retval2;
 
 	tmpsubj = (struct acl_subject_label *) subj;
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(tmpsubj == NULL, "ERROR: Initial subject label NULL."))
 		return NULL;
+#endif
 	read_lock(&gr_inode_lock);
 	do {
 		retval = lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
@@ -2083,8 +2108,10 @@ gr_search_file(const struct dentry * dentry, const __u32 mode,
 		return (mode & ~GR_AUDITS);
 
 	curracl = current->acl;
+#ifdef CONFIG_GRKERNSEC_WARN_NULL_ACL
 	if (WARN_ONCE(curracl == NULL, "No grsecurity acl for this task! Returning default mode."))
 		return retval;
+#endif
 
 	currobj = chk_obj_label(dentry, mnt, curracl);
 	retval = currobj->mode & mode;
-- 
1.7.4.1

