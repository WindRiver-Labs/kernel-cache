From 4c45dce8446d1b714df39cd7277ab9882c0a4c56 Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe.macdonald@windriver.com>
Date: Wed, 4 Apr 2012 04:28:59 +0800
Subject: [PATCH 5/5] debug: Adding kdb and usb debug patches

Simple back-port of kdb functionality into the 4.3 kernel and adding the
ability to debug with kdboc over a USB keyboard.  In order to use this,
it's necessary to pass the kernel command-line option kdboc=kbd.  This
will drop to a kdb prompt on almost any kernel panic and allow USB
keyboard debugging

This patch set originally came from Jason Wessel
<jason.wessel@windriver.com> as two separate sets of patches.

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 drivers/hid/usbhid/hid-core.c   |   18 +++-
 drivers/serial/kgdboc.c         |   22 ++++-
 drivers/usb/core/hcd.c          |   77 +++++++++++++++
 include/linux/kdb.h             |   13 +++
 include/linux/usb.h             |    4 +
 kernel/debug/kdb/kdb_keyboard.c |  195 ++++++++++++++++++++++++++++++++++++++-
 kernel/debug/kdb/kdb_main.c     |    4 +-
 lib/Kconfig.kgdb                |    7 ++
 8 files changed, 333 insertions(+), 7 deletions(-)

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 5242684..e4a1e4e 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -35,6 +35,8 @@
 #include <linux/hiddev.h>
 #include <linux/hid-debug.h>
 #include <linux/hidraw.h>
+#include <linux/kgdb.h>
+#include <linux/kdb.h>
 #include "usbhid.h"
 
 /*
@@ -245,9 +247,17 @@ static void hid_irq_in(struct urb *urb)
 	case 0:			/* success */
 		usbhid_mark_busy(usbhid);
 		usbhid->retry_delay = 0;
-		hid_input_report(urb->context, HID_INPUT_REPORT,
-				 urb->transfer_buffer,
-				 urb->actual_length, 1);
+		if (unlikely(in_dbg_master() && hid && hid->driver &&
+			     urb->actual_length)) {
+			kdb_put_usb_char(usbhid->inbuf,
+					 interface_to_usbdev(usbhid->intf));
+			break;
+		} else {
+			hid_input_report(urb->context, HID_INPUT_REPORT,
+					 urb->transfer_buffer,
+					 urb->actual_length, 1);
+		}
+
 		/*
 		 * autosuspend refused while keys are pressed
 		 * because most keyboards don't wake up when
@@ -1027,6 +1037,7 @@ static int usbhid_start(struct hid_device *hid)
 				USB_INTERFACE_PROTOCOL_KEYBOARD) {
 		usbhid_set_leds(hid);
 		device_set_wakeup_enable(&dev->dev, 1);
+		kdb_keyboard_attach(dev);
 	}
 	return 0;
 
@@ -1048,6 +1059,7 @@ static void usbhid_stop(struct hid_device *hid)
 	if (WARN_ON(!usbhid))
 		return;
 
+	kdb_keyboard_detach(hid_to_usb_dev(hid));
 	clear_bit(HID_STARTED, &usbhid->iofl);
 	spin_lock_irq(&usbhid->lock);	/* Sync with error handler */
 	set_bit(HID_DISCONNECTED, &usbhid->iofl);
diff --git a/drivers/serial/kgdboc.c b/drivers/serial/kgdboc.c
index 8d97dc6..2b31cde 100644
--- a/drivers/serial/kgdboc.c
+++ b/drivers/serial/kgdboc.c
@@ -18,6 +18,7 @@
 #include <linux/tty.h>
 #include <linux/console.h>
 #include <linux/kbd_kern.h>
+#include <linux/usb.h>
 
 #define MAX_CONFIG_LEN		40
 #define MAX_CHAR_RING		512
@@ -49,6 +50,12 @@ static int kgdboc_register_kbd(char **cptr)
 		if (kdb_poll_idx < KDB_POLL_FUNC_MAX) {
 			kdb_poll_funcs[kdb_poll_idx] = kdb_get_kbd_char;
 			kdb_poll_idx++;
+#ifdef CONFIG_KDB_USB
+			if (kdb_poll_idx < KDB_POLL_FUNC_MAX) {
+				kdb_poll_funcs[kdb_poll_idx] = kdb_get_usb_char;
+				kdb_poll_idx++;
+			}
+#endif /* CONFIG_KDB_USB */
 			kgdboc_use_kbd = true;
 			if (cptr[0][3] == ',')
 				*cptr += 4;
@@ -64,7 +71,12 @@ static void kgdboc_unregister_kbd(void)
 	int i;
 
 	for (i = 0; i < kdb_poll_idx; i++) {
+#ifdef CONFIG_KDB_USB
+		if (kdb_poll_funcs[i] == kdb_get_kbd_char ||
+			kdb_poll_funcs[i] == kdb_get_usb_char) {
+#else /* ! CONFIG_KDB_USB */
 		if (kdb_poll_funcs[i] == kdb_get_kbd_char) {
+#endif /* CONFIG_KDB_USB */
 			kdb_poll_idx--;
 			kdb_poll_funcs[i] = kdb_poll_funcs[kdb_poll_idx];
 			kdb_poll_funcs[kdb_poll_idx] = NULL;
@@ -75,8 +87,16 @@ static void kgdboc_unregister_kbd(void)
 
 static inline void kgdboc_clear_kbd(void)
 {
-	if (kgdboc_use_kbd)
+	if (kgdboc_use_kbd) {
 		kbd_dbg_clear_keys(); /* Release all pressed keys */
+
+#if 0
+		/* in mainline this needs to be in a tasklet */
+#ifdef CONFIG_KDB_USB
+		usb_poll_irq_schedule_flush();
+#endif /* CONFIG_KDB_USB */
+#endif
+	}
 }
 #else /* ! CONFIG_KDB_KEYBOARD */
 #define kgdboc_register_kbd(x) 0
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index a86ff17..19f21bb 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -98,6 +98,10 @@ struct usb_busmap {
 };
 static struct usb_busmap busmap;
 
+/* Support polling for a single device's urbs */
+static struct usb_device *usb_poll_hcd_device;
+static LIST_HEAD(delayed_usb_complete_queue);
+
 /* used when updating list of hcds */
 DEFINE_MUTEX(usb_bus_list_lock);	/* exported only for usbfs */
 EXPORT_SYMBOL_GPL (usb_bus_list_lock);
@@ -1520,6 +1524,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 }
 
 /*-------------------------------------------------------------------------*/
+static DEFINE_MUTEX(usb_poll_irq_flush_mutex);
 
 /**
  * usb_hcd_giveback_urb - return URB from HCD to device driver
@@ -1554,6 +1559,16 @@ void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)
 
 	/* pass ownership to the completion handler */
 	urb->status = status;
+	if (unlikely(usb_poll_hcd_device)) {
+		/*
+		 * Any other device than the one being polled should get
+		 * queued for a later flush.
+		 */
+		if (usb_poll_hcd_device != urb->dev) {
+			list_add_tail(&urb->urb_list, &delayed_usb_complete_queue);
+			return;
+		}
+	}
 	urb->complete (urb);
 	atomic_dec (&urb->use_count);
 	if (unlikely(atomic_read(&urb->reject)))
@@ -2313,6 +2328,7 @@ usb_hcd_platform_shutdown(struct platform_device* dev)
 }
 EXPORT_SYMBOL_GPL(usb_hcd_platform_shutdown);
 
+#if 0
 void
 usb_poll_irq(struct usb_device *udev)
 {
@@ -2322,6 +2338,67 @@ usb_poll_irq(struct usb_device *udev)
 	usb_hcd_irq(0, hcd);
 }
 EXPORT_SYMBOL_GPL(usb_poll_irq);
+#endif
+
+/**
+ * usb_poll_irq - run HCD to call all urb->complete's for a usb device
+ * @udev: The usb device to poll
+ *
+ * The intent of this function is to run the completion handlers for
+ * any urbs for the specified usb device.  Any other devices will have
+ * the urb completions queued to be run at a later point.  Any user of
+ * this function needs call usb_poll_irq_schedule_flush() at a later
+ * point to schedule the processing of the queue.  This function MUST
+ * be called with the interrupts off.
+ */
+void usb_poll_irq(struct usb_device *udev)
+{
+	struct usb_hcd *hcd;
+
+	WARN_ON_ONCE(!irqs_disabled());
+	hcd = bus_to_hcd(udev->bus);
+	usb_poll_hcd_device = udev;
+	usb_hcd_irq(0, hcd);
+	usb_poll_hcd_device = NULL;
+}
+EXPORT_SYMBOL_GPL(usb_poll_irq);
+
+static void usb_poll_irq_flush_helper(struct work_struct *dummy)
+{
+	struct urb *urb;
+	struct urb *scratch;
+	unsigned long flags;
+
+	WARN_ON_ONCE(!irqs_disabled());
+	mutex_lock(&usb_poll_irq_flush_mutex);
+	local_irq_save(flags);
+	list_for_each_entry_safe(urb, scratch, &delayed_usb_complete_queue,
+				 urb_list) {
+		list_del(&urb->urb_list);
+		urb->complete(urb);
+		atomic_dec(&urb->use_count);
+		if (unlikely(atomic_read(&urb->reject)))
+			wake_up(&usb_kill_urb_queue);
+		usb_put_urb(urb);
+	}
+	local_irq_restore(flags);
+	mutex_unlock(&usb_poll_irq_flush_mutex);
+}
+
+static DECLARE_WORK(usb_poll_irq_flush_work, usb_poll_irq_flush_helper);
+
+/**
+ * usb_poll_irq_sechedule_flush()
+ *
+ * For any function that invoked usb_poll_irq() this function needs to
+ * be called to schedule the draining of the urb completion queue in
+ * order to restore normal processing of the usb devices.
+ */
+void usb_poll_irq_schedule_flush(void)
+{
+	schedule_work(&usb_poll_irq_flush_work);
+}
+EXPORT_SYMBOL_GPL(usb_poll_irq_schedule_flush);
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/include/linux/kdb.h b/include/linux/kdb.h
index ccb2b3e..e661bf2 100644
--- a/include/linux/kdb.h
+++ b/include/linux/kdb.h
@@ -93,6 +93,19 @@ typedef int (*get_char_func)(void);
 extern get_char_func kdb_poll_funcs[];
 extern int kdb_get_kbd_char(void);
 
+#ifdef CONFIG_KDB_USB
+extern int kdb_no_usb;
+extern int kdb_get_usb_char(void);
+struct usb_device;
+void kdb_keyboard_attach(struct usb_device *dev);
+void kdb_keyboard_detach(struct usb_device *dev);
+extern void kdb_put_usb_char(char *buffer, struct usb_device *dev);
+#else /* ! CONFIG_KDB_USB */
+#define kdb_put_usb_char(x)
+#define kdb_keyboard_attach(x)
+#define kdb_keyboard_detach(x)
+#endif /* ! CONFIG_KDB_USB */
+
 static inline
 int kdb_process_cpu(const struct task_struct *p)
 {
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a867e87..87874b8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -572,6 +572,10 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 /* for polling the hcd device */
 extern void usb_poll_irq(struct usb_device *udev);
 
+/* for polling the hcd device */
+extern void usb_poll_irq(struct usb_device *udev);
+extern void usb_poll_irq_schedule_flush(void);
+
 /* for drivers using iso endpoints */
 extern int usb_get_current_frame_number(struct usb_device *usb_dev);
 
diff --git a/kernel/debug/kdb/kdb_keyboard.c b/kernel/debug/kdb/kdb_keyboard.c
index 4bca634..1d41dc6 100644
--- a/kernel/debug/kdb/kdb_keyboard.c
+++ b/kernel/debug/kdb/kdb_keyboard.c
@@ -5,7 +5,7 @@
  * License.
  *
  * Copyright (c) 1999-2006 Silicon Graphics, Inc.  All Rights Reserved.
- * Copyright (c) 2009 Wind River Systems, Inc.  All Rights Reserved.
+ * Copyright (c) 2009-2010 Wind River Systems, Inc.  All Rights Reserved.
  */
 
 #include <linux/kdb.h>
@@ -13,6 +13,7 @@
 #include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/usb.h>
 
 /* Keyboard Controller Registers on normal PCs. */
 
@@ -210,3 +211,195 @@ int kdb_get_kbd_char(void)
 	return keychar & 0xff;
 }
 EXPORT_SYMBOL_GPL(kdb_get_kbd_char);
+
+#ifdef CONFIG_KDB_USB
+static unsigned char kdb_usb_keycode[256] = {
+	  0,   0,   0,   0,  30,  48,  46,  32,  18,  33,  34,  35,  23,
+	 36,  37,  38,  50,  49,  24,  25,  16,  19,  31,  20,  22,  47,
+	 17,  45,  21,  44,   2,   3,   4,   5,   6,   7,   8,   9,  10,
+	 11,  28,   1,  14,  15,  57,  12,  13,  26,  27,  43,  84,  39,
+	 40,  41,  51,  52,  53,  58,  59,  60,  61,  62,  63,  64,  65,
+	 66,  67,  68,  87,  88,  99,  70, 119, 110, 102, 104, 111, 107,
+	109, 106, 105, 108, 103,  69,  98,  55,  74,  78,  96,  79,  80,
+	 81,  75,  76,  77,  71,  72,  73,  82,  83,  86, 127, 116, 117,
+	 85,  89,  90,  91,  92,  93,  94,  95, 120, 121, 122, 123, 134,
+	138, 130, 132, 128, 129, 131, 137, 133, 135, 136, 113, 115, 114,
+	  0,   0,   0, 124,   0, 181, 182, 183, 184, 185, 186, 187, 188,
+	189, 190, 191, 192, 193, 194, 195, 196, 197, 198,   0,   0,   0,
+	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+	  0,   0,   0,  29,  42,  56, 125,  97,  54, 100, 126, 164, 166,
+	165, 163, 161, 115, 114, 113, 150, 158, 159, 128, 136, 177, 178,
+	176, 142, 152, 173, 140,
+};
+
+#define MAX_KEYBOARDS	8
+static struct usb_device *kdb_keyboard_dev[8];
+
+#define KDB_USB_RING_MAX 4
+static int kdb_usbkbd_head;
+static int kdb_usbkbd_tail;
+static int kdb_usbkbd_ring[KDB_USB_RING_MAX];
+static bool kdb_usbkbd_caps_lock;
+
+static void push_usbkbd_key(int keycode)
+{
+	int next = kdb_usbkbd_head + 1;
+
+	if (next >= KDB_USB_RING_MAX)
+		next = 0;
+	if (next == kdb_usbkbd_tail)
+		return;
+
+	kdb_usbkbd_ring[kdb_usbkbd_head] = keycode;
+	kdb_usbkbd_head = next;
+}
+
+static int kdb_pop_usbkbd_key(void)
+{
+	int next = kdb_usbkbd_tail + 1;
+	int ret = kdb_usbkbd_ring[kdb_usbkbd_tail];
+
+	if (kdb_usbkbd_tail == kdb_usbkbd_head)
+		return -1;
+	if (next >= KDB_USB_RING_MAX)
+		next = 0;
+	kdb_usbkbd_tail = next;
+	return ret;
+}
+
+#define MAX_KEYS_DOWN 4
+static int kbdusb_keys_down[MAX_KEYS_DOWN];
+static int kbdusb_idx;
+
+/*
+ * This function receive input from usb keyboard devices
+ */
+void kdb_put_usb_char(char *buffer, struct usb_device *dev)
+{
+	unsigned char keycode, spec;
+	int i, j, found;
+
+	/* Mark keys up if they are no longer down */
+	for (i = 0; i < kbdusb_idx; i++) {
+		for (j = 0; j < MAX_KEYS_DOWN; j++) {
+			if (kbdusb_keys_down[i] == buffer[2+j])
+				break;
+		}
+		if (j == MAX_KEYS_DOWN) {
+			kbdusb_idx--;
+			kbdusb_keys_down[i] = kbdusb_keys_down[kbdusb_idx];
+			i--;
+			if (kbdusb_idx == 0)
+				break;
+		}
+	}
+
+	for (i = 0; i < MAX_KEYS_DOWN; i++) {
+		if (!buffer[2+i])
+			break;
+
+		keycode = buffer[2+i];
+		buffer[2+i] = 0;
+		spec = buffer[0];
+		buffer[0] = 0;
+
+		/* if the key was previously down, skip it */
+		found = 0;
+		for (j = 0; j < kbdusb_idx; j++)
+			if (keycode == kbdusb_keys_down[j]) {
+				found = 1;
+				break;
+			}
+		if (found)
+			continue;
+
+		if (kbdusb_idx < MAX_KEYS_DOWN) {
+			kbdusb_keys_down[kbdusb_idx] = keycode;
+			kbdusb_idx++;
+		}
+		/* A normal key is pressed, decode it */
+		if (keycode)
+			keycode = kdb_usb_keycode[keycode];
+
+		/* 2 Keys pressed at one time ? */
+		if (spec && keycode) {
+			switch (spec) {
+			case 0x2:
+			case 0x20: /* Shift */
+				push_usbkbd_key(key_maps[1][keycode]);
+				break;
+			case 0x1:
+			case 0x10: /* Ctrl */
+				push_usbkbd_key(key_maps[4][keycode]);
+				break;
+			case 0x4:
+			case 0x40: /* Alt */
+				break;
+			}
+		} else if (keycode) { /* If only one key pressed */
+			switch (keycode) {
+			case 0x1C: /* Enter */
+				push_usbkbd_key(13);
+				break;
+			case 0x3A: /* Capslock */
+				kdb_usbkbd_caps_lock = !kdb_usbkbd_caps_lock;
+				break;
+			case 0x0E: /* Backspace */
+				push_usbkbd_key(8);
+				break;
+			case 0x0F: /* TAB */
+				push_usbkbd_key(9);
+				break;
+			case 0x77: /* Pause */
+				break;
+			default:
+				if (!kdb_usbkbd_caps_lock)
+					push_usbkbd_key(plain_map[keycode]);
+				else
+					push_usbkbd_key(key_maps[1][keycode]);
+				break;
+			}
+		}
+	}
+}
+
+void kdb_keyboard_attach(struct usb_device *dev)
+{
+	int i;
+
+	for (i = 0; i < MAX_KEYBOARDS; i++)
+		if (kdb_keyboard_dev[i] == NULL) {
+			kdb_keyboard_dev[i] = dev;
+			break;
+		}
+}
+
+void kdb_keyboard_detach(struct usb_device *dev)
+{
+	int i;
+
+	for (i = 0; i < MAX_KEYBOARDS; i++)
+		if (kdb_keyboard_dev[i] == dev) {
+			kdb_keyboard_dev[i] = NULL;
+			break;
+		}
+}
+
+int kdb_get_usb_char(void)
+{
+	int ret = kdb_pop_usbkbd_key();
+	int i;
+
+	if (ret >= 0)
+		return ret;
+	for (i = 0; i < MAX_KEYBOARDS; i++)
+		if (kdb_keyboard_dev[i])
+			usb_poll_irq(kdb_keyboard_dev[i]);
+	return kdb_pop_usbkbd_key();
+}
+
+#endif /* CONFIG_KDB_USB */
diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c
index 5ace8ff..c11efdd 100644
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@ -1990,7 +1990,7 @@ static int kdb_lsmod(int argc, const char **argv)
 	list_for_each_entry(mod, kdb_modules, list) {
 
 		kdb_printf("%-20s%8u  0x%p ", mod->name,
-			   mod->core_size, (void *)mod);
+			   mod->core_size_rw, (void *)mod);
 #ifdef CONFIG_MODULE_UNLOAD
 		kdb_printf("%4d ", module_refcount(mod));
 #endif
@@ -2000,7 +2000,7 @@ static int kdb_lsmod(int argc, const char **argv)
 			kdb_printf(" (Loading)");
 		else
 			kdb_printf(" (Live)");
-		kdb_printf(" 0x%p", mod->module_core);
+		kdb_printf(" 0x%p", mod->module_core_rw);
 
 #ifdef CONFIG_MODULE_UNLOAD
 		{
diff --git a/lib/Kconfig.kgdb b/lib/Kconfig.kgdb
index 80c3706..be941bd 100644
--- a/lib/Kconfig.kgdb
+++ b/lib/Kconfig.kgdb
@@ -118,4 +118,11 @@ config KDB_KEYBOARD
 	help
 	  KDB can use a PS/2 type keyboard for an input device
 
+config KDB_USB
+	bool "KGDB_KDB: Allow usb input device devices"
+	depends on KDB_KEYBOARD && USB
+	default y
+	help
+	  KDB can use a USB keyboard for an input device
+
 endif # KGDB
-- 
1.7.4.1

