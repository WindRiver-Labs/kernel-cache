From 777064a089736b57603775fb4cd435cb61f5445c Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Tue, 18 Nov 2014 15:34:02 -0500
Subject: [PATCH] Disable CPU migration during USDPAA Cleanup

CPU specific variables are used during USDPAA cleanup. Disabling
CPU migration is needed to avoid the cleanup process from being
moved to another CPU (especially when using the RT preemption models)

Change-Id: If0133117fcec82f69e6123cb4da3167363b0dad3
Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/24105
Reviewed-by: Roy Pledge <roy.pledge@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |   15 +++++++++++++--
 1 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index dc0fa69..7c1f130 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -522,6 +522,10 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 	struct qm_portal *portal_array[qman_portal_max];
 	int portal_count = 0;
 
+	/* Ensure the release operation cannot be migrated to another
+	   CPU as CPU specific variables may be needed during cleanup */
+	migrate_disable();
+
 	/* The following logic is used to recover resources that were not
 	   correctly released by the process that is closing the FD.
 	   Step 1: syncronize the HW with the qm_portal/bm_portal structures
@@ -557,12 +561,15 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		qm_alloced_portal = qm_get_unused_portal();
 		if (!qm_alloced_portal) {
 			pr_crit("No QMan portal avalaible for cleanup\n");
+			migrate_enable();
 			return -1;
 		}
 		qm_cleanup_portal = kmalloc(sizeof(struct qm_portal),
 					    GFP_KERNEL);
-		if (!qm_cleanup_portal)
+		if (!qm_cleanup_portal) {
+			migrate_enable();
 			return -ENOMEM;
+		}
 		init_qm_portal(qm_alloced_portal, qm_cleanup_portal);
 		portal_array[portal_count] = qm_cleanup_portal;
 		++portal_count;
@@ -571,12 +578,15 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		bm_alloced_portal = bm_get_unused_portal();
 		if (!bm_alloced_portal) {
 			pr_crit("No BMan portal avalaible for cleanup\n");
+			migrate_enable();
 			return -1;
 		}
 		bm_cleanup_portal = kmalloc(sizeof(struct bm_portal),
 					    GFP_KERNEL);
-		if (!bm_cleanup_portal)
+		if (!bm_cleanup_portal) {
+			migrate_enable();
 			return -ENOMEM;
+		}
 		init_bm_portal(bm_alloced_portal, bm_cleanup_portal);
 	}
 
@@ -652,6 +662,7 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 	}
 
 	kfree(ctx);
+	migrate_enable();
 	return 0;
 }
 
-- 
1.7.5.4

