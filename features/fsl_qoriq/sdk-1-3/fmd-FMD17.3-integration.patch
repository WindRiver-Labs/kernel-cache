From 1a25bd91bf1d856137fe2843df8c23d55cf1858e Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Fri, 28 Sep 2012 15:27:20 +0300
Subject: [PATCH 083/162] fmd: FMD17.3 integration

Add changes from FMD17.3 integration.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |   13 ++++++++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |   11 +++++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |    2 ++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |    3 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |    2 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |    4 ++++
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |    2 +-
 7 files changed, 28 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index ae26fc2..a1e67ba 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -125,6 +125,7 @@ static void FreeStatObjects(t_List     *p_List,
     while (!LIST_IsEmpty(p_List))
     {
         p_StatsObj = DequeueStatsObj(p_List);
+        ASSERT_COND(p_StatsObj);
 
         FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
         FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsCounters);
@@ -172,7 +173,7 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
         p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                                                   p_CcNode->countersArraySize,
                                                                   FM_PCD_CC_AD_TABLE_ALIGN);
-        if (!p_StatsObj->h_StatsAd)
+        if (!p_StatsObj->h_StatsCounters)
         {
             FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
             XX_Free(p_StatsObj);
@@ -713,9 +714,13 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         XX_UnlockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock, intFlags);
     }
     else
+    {
+        uint8_t numEntries = ((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries;
+        ASSERT_COND(numEntries < FM_PCD_MAX_NUM_OF_CC_GROUPS);
         memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                &p_AdditionalParams->keyAndNextEngineParams,
-               sizeof(t_FmPcdCcKeyAndNextEngineParams) * (((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries));
+               sizeof(t_FmPcdCcKeyAndNextEngineParams) * numEntries);
+    }
 
     ReleaseLst(h_FmPcdOldPointersLst);
     ReleaseLst(h_FmPcdNewPointersLst);
@@ -2492,6 +2497,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
                 ASSERT_COND(p_StatsObj);
 
                 /* Store allocated statistics object */
+                ASSERT_COND(keyIndex < FM_PCD_MAX_NUM_OF_CC_GROUPS);
                 p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
 
                 h_StatsAd = p_StatsObj->h_StatsAd;
@@ -2785,6 +2791,7 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
 
         if (j == keyIndex)
         {
+            ASSERT_COND(keyIndex < FM_PCD_MAX_NUM_OF_CC_GROUPS);
             if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
             {
                 /* As statistics were enabled, we need to update the existing
@@ -3278,7 +3285,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
         numOfKeys = p_FmPcdCcTree->numOfEntries;
         memcpy(p_KeyAndNextEngineParams,
                p_FmPcdCcTree->keyAndNextEngineParams,
-               256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+               FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
     }
 
     p_FmPcdModifyCcKeyAdditionalParams =
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index 7398690..bb6ab48 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -416,7 +416,6 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
                     p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-
                 else if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
                 {
@@ -630,14 +629,16 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
 
-
-        /* advance pointer */
+            /* advance pointer */
             p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
         }
     }
     else
+    {
+        ASSERT_COND(p_Last);
         /* set the "last" indication on the last command of the current table */
         WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
+    }
 
     return E_OK;
 }
@@ -654,7 +655,7 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
     if(p_FmPcdManipParams->h_NextManip)
     {
         if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-            nextSize =(uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
+            nextSize = (uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
     }
@@ -960,6 +961,8 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
 
     }
 
+    ASSERT_COND(p_Ad);
+
    if(p_Manip->updateParams & OFFSET_OF_PR)
    {
         tmpReg32 = 0;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 5c464f8..8568fac 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -1625,6 +1625,8 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
                 return 0;
             }
+            ASSERT_COND(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs ||
+                        ((p_FmPcd->guestId != NCSW_MASTER_ID) && p_FmPcd->h_IpcSession));
             break;
 
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 928affa..08c236d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -990,6 +990,8 @@ t_Error PlcrSetPortProfiles(t_FmPcd    *p_FmPcd,
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
     if (GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("The requesting port has already an allocated profiles window."));
@@ -1036,6 +1038,7 @@ t_Error PlcrClearPortProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
     WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index f0b738f..620ef96 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -143,7 +143,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 
     p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch),4), 0, sizeof(uint32_t));
     if (!p_TmpCode)
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
     memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch),4));
     memcpy((uint8_t *)p_TmpCode, (uint8_t *)swPrsPatch, sizeof(swPrsPatch));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 73728a5..6946409 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -2184,6 +2184,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX))
     {
+        ASSERT_COND(macId < FM_MAX_NUM_OF_1G_MACS);
         if (p_PortParams->maxFrameLength >= p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId])
             p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] = p_PortParams->maxFrameLength;
         else
@@ -2311,7 +2312,10 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 #endif /* defined(FM_MAX_NUM_OF_10G_MACS) && ... */
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX))
+    {
+        ASSERT_COND(macId < FM_MAX_NUM_OF_1G_MACS);
         p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] = 0;
+    }
 
 #ifdef FM_LOW_END_RESTRICTION
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 61f5961..f39d5d9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -240,7 +240,7 @@ typedef _Packed struct t_FmIpcSetCongestionGroupPfcPriority {
     uint8_t      priorityBitMap;
 }_PackedType t_FmIpcSetCongestionGroupPfcPriority;
 
-#define FM_IPC_MAX_REPLY_BODY_SIZE  16
+#define FM_IPC_MAX_REPLY_BODY_SIZE  20
 #define FM_IPC_MAX_REPLY_SIZE       (FM_IPC_MAX_REPLY_BODY_SIZE + sizeof(uint32_t))
 #define FM_IPC_MAX_MSG_SIZE         30
 
-- 
1.7.9.7

