From 67b286823d169429373e50ee944ff22ebd5c0081 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Tue, 25 Sep 2012 11:49:14 +0300
Subject: [PATCH 052/162] dpaa_eth: Differentiate Congestion State
 Notification thresholds

Define separate congestion thresholds on 1G and 10G egress ports,
because the former may become more easily flooded with egress traffic if
the cores are transmitting in a very tight loop, such as that of
netperf's UDP_STREAM tests.
If a threshold is too high and a device remains congested for too long,
there is a risk that the netdev watchdog fire and dump a disgraceful
call trace. Or we may run out of memory before that happens.
Conversely, if the threshold is too low, transmission will unjustifiedly
hiccup.

(To minimize the risk of a last-minute impact on the SDK,
we'll be leaving the two thresholds at the same value for now.
Situations such as the one described have not been reported in the SDK
releases yet, but this change is probably a good idea nevertheless.)

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   39 ++++++++++++++++++++-----
 1 file changed, 32 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 2ba18967..e0c2c06 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -82,12 +82,25 @@
 
 #define DPA_NAPI_WEIGHT		64
 
-/**
- * Size in bytes of the Congestion State threshold.
- * Used for CGR-based congestion control on the egress ports.
- * Values for the 1G and 10G ports should be proportionately different.
+/* Size in bytes of the Congestion State notification threshold on 10G ports */
+#define DPA_CS_THRESHOLD_10G	0x10000000
+/*
+ * Size in bytes of the Congestion State notification threshold on 1G ports.
+
+ * The 1G dTSECs can quite easily be flooded by cores doing Tx in a tight loop
+ * (e.g. by sending UDP datagrams at "while(1) speed"),
+ * and the larger the frame size, the more acute the problem.
+ *
+ * So we have to find a balance between these factors:
+ *	- avoiding the device staying congested for a prolonged time (risking
+ *	  the netdev watchdog to fire - see also the tx_timeout module param);
+ *	- affecting performance of protocols such as TCP, which otherwise
+ *	  behave well under the congestion notification mechanism;
+ *	- preventing the Tx cores from tightly-looping (as if the congestion
+ *	  threshold was too low to be effective);
+ *	- running out of memory if the CS threshold is set too high.
  */
-#define DPA_CS_THRESHOLD	0x10000000
+#define DPA_CS_THRESHOLD_1G	0x10000000
 
 /* S/G table requires at least 256 bytes */
 #define SGT_BUFFER_SIZE		DPA_BP_SIZE(256)
@@ -122,6 +135,7 @@ static uint8_t debug = -1;
 module_param(debug, byte, S_IRUGO);
 MODULE_PARM_DESC(debug, "Module/Driver verbosity level");
 
+/* This has to work in tandem with the DPA_CS_THRESHOLD_xxx values. */
 static uint16_t __devinitdata tx_timeout = 1000;
 module_param(tx_timeout, ushort, S_IRUGO);
 MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
@@ -3350,7 +3364,7 @@ static int dpa_netdev_init(struct device_node *dpa_node,
 
 	SET_ETHTOOL_OPS(net_dev, &dpa_ethtool_ops);
 	net_dev->needed_headroom = DPA_BP_HEAD;
-	net_dev->watchdog_timeo = tx_timeout * HZ / 1000;
+	net_dev->watchdog_timeo = msecs_to_jiffies(tx_timeout);
 
 	err = register_netdev(net_dev);
 	if (err < 0) {
@@ -3576,7 +3590,18 @@ static int dpaa_eth_cgr_init(struct dpa_priv_s *priv)
 	/* Enable Congestion State Change Notifications and CS taildrop */
 	initcgr.we_mask = QM_CGR_WE_CSCN_EN | QM_CGR_WE_CS_THRES;
 	initcgr.cgr.cscn_en = QM_CGR_EN;
-	qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres, DPA_CS_THRESHOLD, 1);
+	/*
+	 * Set different thresholds based on the MAC speed.
+	 * TODO: this may turn suboptimal if the MAC is reconfigured at a speed
+	 * lower than its max, e.g. if a dTSEC later negotiates a 100Mbps link.
+	 * In such cases, we ought to reconfigure the threshold, too.
+	 */
+	if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
+		qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres,
+			DPA_CS_THRESHOLD_10G, 1);
+	else
+		qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres,
+			DPA_CS_THRESHOLD_1G, 1);
 
 	initcgr.we_mask |= QM_CGR_WE_CSTD_EN;
 	initcgr.cgr.cstd_en = QM_CGR_EN;
-- 
1.7.9.7

