From 4a20b942544f2f55363956b0f9ada34f690cfe73 Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Wed, 11 Jul 2012 03:37:10 +0000
Subject: [PATCH 058/162] fmd: remove support for loading the microcode from
 NOR flash

Early versions of FMD read the Fman microcode from NOR flash, but that feature
has been deprecated for quite some time.  The feature is not normally
compiled anyway, but we don't want anyone to think that it's an acceptable
approach.  The only supported method for obtaining the microcode is from
the device tree.

Signed-off-by: Timur Tabi <timur@freescale.com>
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |   78 +-------------------
 1 file changed, 2 insertions(+), 76 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index e663ad3..df20707 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -425,39 +425,8 @@ typedef _Packed struct {
     return E_OK;
 }
 
-/* The default address for the Fman microcode in flash. Having a default
- * allows older systems to continue functioning.  0xEF000000 is the address
- * where the firmware is normally on a P4080DS.
- */
-#ifdef CONFIG_PHYS_64BIT
-static phys_addr_t P4080_UCAddr = 0xfef000000ull;
-#else
-static phys_addr_t P4080_UCAddr = 0xef000000;
-#endif
-
-
-/**
- * FmanUcodeAddrParam - process the fman_ucode kernel command-line parameter
- *
- * This function is called when the kernel encounters a fman_ucode command-
- * line parameter.  This parameter contains the address of the Fman microcode
- * in flash.
- */
-static int FmanUcodeAddrParam(char *str)
-{
-    unsigned long long l;
-    int ret;
-
-    ret = strict_strtoull(str, 0, &l);
-    if (!ret)
-        P4080_UCAddr = (phys_addr_t) l;
-
-    return ret;
-}
-__setup("fman_ucode=", FmanUcodeAddrParam);
-
 /**
- * FindFmanMicrocode - find the Fman microcode in memory
+ * FindFmanMicrocode - find the Fman microcode
  *
  * This function returns a pointer to the QE Firmware blob that holds
  * the Fman microcode.  We use the QE Firmware structure because Fman microcode
@@ -469,18 +438,11 @@ __setup("fman_ucode=", FmanUcodeAddrParam);
  * be fetching the firmware node for the current Fman, but we don't have that
  * information any more, so we assume that there is only one firmware node in
  * the device tree, and that all Fmen use the same firmware.
- *
- * If we have an older U-Boot, then we assume that the firmware is located in
- * flash at physical address 'P4080_UCAddr'
  */
 static const struct qe_firmware *FindFmanMicrocode(void)
 {
     static const struct qe_firmware *P4080_UCPatch;
     struct device_node *np;
-#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
-    unsigned long P4080_UCSize;
-    const struct qe_header *hdr;
-#endif
 
     if (P4080_UCPatch)
 	    return P4080_UCPatch;
@@ -496,39 +458,8 @@ static const struct qe_firmware *FindFmanMicrocode(void)
 		    REPORT_ERROR(WARNING, E_NOT_FOUND, ("firmware node is incomplete"));
     }
 
-#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
-    /* If not, then we have a legacy U-Boot.  The firmware is in flash. */
-    /* Only map enough to the get the core structure */
-    P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
-    if (!P4080_UCPatch) {
-        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
-        return NULL;
-    }
-    /* Make sure it really is a QE Firmware blob */
-    hdr = &P4080_UCPatch->header;
-    if (!hdr ||
-        (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
-        (hdr->magic[2] != 'F')) {
-        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
-        return NULL;
-    }
-
-    /* Now we call ioremap again, this time to pick up the whole blob. We never
-     * iounmap() the memory because we might reset the Fman at any time.
-     */
-    /* TODO: ionumap() should be performed when unloading the driver */
-    P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
-    iounmap((void *)P4080_UCPatch);
-    P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
-    if (!P4080_UCPatch) {
-        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
-        return NULL;
-    }
-#else
     /* Returning NULL here forces the reuse of the IRAM content */
-    P4080_UCPatch = NULL;
-#endif /* FMAN_READ_MICROCODE_FROM_NOR_FLASH */
-    return P4080_UCPatch;
+    return NULL;
 }
 
 static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
@@ -828,14 +759,9 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     fw = FindFmanMicrocode();
 
     if (!fw) {
-#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
-        /* We already reported an error, so just return NULL*/
-        return ERROR_CODE(E_NULL_POINTER);
-#else
         /* this forces the reuse of the current IRAM content */
         p_LnxWrpFmDev->fmDevSettings.param.firmware.size = 0;
         p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code = NULL;
-#endif
     } else {
         p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
             (void *) fw + fw->microcode[0].code_offset;
-- 
1.7.9.7

