From 1cab131dcd8062a1f621f3293975de30ff867f2a Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 12 Jul 2012 14:28:11 +0000
Subject: [PATCH 032/162] dpaa_eth: remove FMD dependency upon dpaa_eth kernel
 parameters

The DPAA Ethernet Driver offers kernel configuration options for
maximum frame size and reception buffer extra headroom. These values
are also required by the FMan Driver, being used in the resource
allocation algorithm.
As the usual relation between the two modules is for the DPAA
Ethernet Driver to use the FMan Driver exported API, these
configuration options were moved to FMD wrapper and getter functions
were added.
The boot params are mirrored in the dpaa_eth driver for performance reasons.
Old boot parameter fsl_fman_phy_max_frm is now called fsl_fm_max_frm.
Old boot parameter dpa_extra_headroom is now called fsl_fm_rx_extra_headroom.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig             |   39 -------
 .../net/ethernet/freescale/dpa/NetCommSw/Kconfig   |   52 +++++++++
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman.h       |   10 ++
 .../dpa/NetCommSw/src/wrapper/fman_test.c          |    9 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |  114 ++++++++++++++++++++
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.h          |    8 ++
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |   15 +--
 .../net/ethernet/freescale/dpa/dpaa_eth-common.h   |    5 -
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |  113 +++----------------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   13 ++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c   |   13 ++-
 drivers/net/ethernet/freescale/dpa/mac-api.c       |    3 +-
 drivers/net/ethernet/freescale/dpa/mac.h           |    4 -
 13 files changed, 222 insertions(+), 176 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 6bb8f63..3e2bd03 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -135,45 +135,6 @@ config DPA_OFFLINE_PORTS
 	  Choosing this feature will not impact the functionality and/or performance of the system,
 	  so it is safe to have it.
 
-config DPA_MAX_FRM_SIZE
-	int "Maximum L2 frame size"
-	depends on DPA
-	range 64 9600
-	default "1522"
-	help
-	  Configure this in relation to the maximum possible MTU of your network configuration. In particular,
-	  one would need to increase this value in order to use jumbo frames. DPA_MAX_FRM_SIZE must accomodate
-	  the Ethernet FCS (4 bytes) and one ETH+VLAN header (18 bytes), to a total of 22 bytes in excess of
-	  the desired L3 MTU.
-
-	  Note that having too large a DPA_MAX_FRM_SIZE (much larger than the actual MTU) may lead to buffer
-	  exhaustion, especially in the case of badly fragmented datagrams on the Rx path. Conversely,
-	  having a DPA_MAX_FRM_SIZE smaller than the actual MTU will lead to frames being dropped.
-
-	  This can be overridden by specifying "fsl_fman_phy_max_frm" in the kernel bootargs:
-	    * in Hypervisor-based scenarios, by adding a "chosen" node with the "bootargs" property specifying
-              "fsl_fman_phy_max_frm=<YourValue>";
-	    * in non-Hypervisor-based scenarios, via u-boot's env, by modifying the "bootargs" env variable.
-
-config DPA_EXTRA_HEADROOM
-	int "Add extra headroom at beginning of data buffers"
-	depends on DPA
-	range 0 447
-	default "64"
-	help
-	  Configure this to tell the Frame Manager to reserve some extra space at the beginning of a
-	  data buffer on the receive path, before Internal Context fields are copied. This is in addition
-	  to the private data area already reserved for driver internal use.
-	  The option does not affect in any way the layout of transmitted buffers.
-
-	  Default value of 64 favours the case when forwarded frames are being encapsulated (e.g. IPSec).
-	  For plain forwarding or termination cases, a value of zero is recommended for optimum performance.
-
-	  This setting can be overridden by specifying "dpa_extra_headroom" in the kernel bootargs:
-	    * in Hypervisor-based scenarios, by adding a "chosen" node with the "bootargs" property specifying
-              "dpa_extra_headroom=<YourValue>";
-	    * in non-Hypervisor-based scenarios, via u-boot's env, by modifying the "bootargs" env variable.
-
 config DPAA_ETH_SG_SUPPORT
 	bool "Add support for S/G frames in the DPAA Ethernet driver"
 	depends on DPA
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig b/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
index d1fc98e..2dc1df5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
@@ -52,6 +52,58 @@ config FMAN_MIB_CNT_OVF_IRQ_EN
 		for the counters overflow but reduces performance and
 		triggers error messages in HV setups.
 
+
+config FSL_FM_MAX_FRAME_SIZE
+	int "Maximum L2 frame size"
+	depends on FSL_FMAN
+	range 64 9600
+	default "1522"
+	help
+		Configure this in relation to the maximum possible MTU of your
+		network configuration. In particular, one would need to
+		increase this value in order to use jumbo frames.
+		FSL_FM_MAX_FRAME_SIZE must accomodate the Ethernet FCS (4 bytes)
+		and one ETH+VLAN header (18 bytes), to a total of 22 bytes in
+		excess of the desired L3 MTU.
+
+		Note that having too large a FSL_FM_MAX_FRAME_SIZE (much larger
+		than the actual MTU) may lead to buffer exhaustion, especially
+		in the case of badly fragmented datagrams on the Rx path.
+		Conversely, having a FSL_FM_MAX_FRAME_SIZE smaller than the actual
+		MTU will lead to frames being dropped.
+
+		This can be overridden by specifying "fsl_fm_max_frm" in
+		the kernel bootargs:
+		 * in Hypervisor-based scenarios, by adding a "chosen" node
+		with the "bootargs" property specifying
+		"fsl_fm_max_frm=<YourValue>";
+		 * in non-Hypervisor-based scenarios, via u-boot's env, by
+		modifying the "bootargs" env variable.
+
+config FSL_FM_RX_EXTRA_HEADROOM
+	int "Add extra headroom at beginning of data buffers"
+	depends on FSL_FMAN
+	range 0 384
+	default "64"
+	help
+		Configure this to tell the Frame Manager to reserve some extra
+		space at the beginning of a data buffer on the receive path,
+		before Internal Context fields are copied. This is in addition
+		to the private data area already reserved for driver internal
+		use. The option does not affect in any way the layout of
+		transmitted buffers. You may be required to enable the config
+		option FMAN_RESOURCE_ALLOCATION_ALGORITHM and also
+		FMAN_DISABLE_OH_TO_REUSE_RESOURCES to have enough resources
+		when using this option and also supporting jumbo frames.
+
+		This setting can be overridden by specifying
+		"fsl_fm_rx_extra_headroom" in the kernel bootargs:
+		 * in Hypervisor-based scenarios, by adding a "chosen" node
+		with the "bootargs" property specifying
+		"fsl_fm_rx_extra_headroom=<YourValue>";
+		 * in non-Hypervisor-based scenarios, via u-boot's env, by
+		modifying the "bootargs" env variable.
+
 endif # FSL_FMAN
 
 endmenu
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
index 44203fb..b4d3e00 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
@@ -272,6 +272,16 @@ void fm_mutex_lock(void);
 *//***************************************************************************/
 void fm_mutex_unlock(void);
 
+/**************************************************************************//**
+ @Description   Get the maximum frame size
+*//***************************************************************************/
+int fm_get_max_frm(void);
+
+/**************************************************************************//**
+ @Description   Get the extra headroom size
+*//***************************************************************************/
+int fm_get_rx_extra_headroom(void);
+
 /** @} */ /* end of FM_LnxKern_ctrl_grp group */
 /** @} */ /* end of FM_LnxKern_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
index 30dd75b..a7b5908 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
@@ -431,7 +431,8 @@ static int fmt_fq_release(const struct qm_fd *fd)
 }
 
 /* sync it w/ dpaa_eth.c: DPA_BP_HEAD */
-#define DPA_BP_HEADROOM (DPA_RX_PRIV_DATA_SIZE + \
+#define DPA_BP_HEADROOM (DPA_TX_PRIV_DATA_SIZE + \
+			fm_get_rx_extra_headroom() + \
 			DPA_PARSE_RESULTS_SIZE + \
 			DPA_HASH_RESULTS_SIZE)
 #define MAC_HEADER_LENGTH 14
@@ -536,7 +537,7 @@ enum dpaa_eth_hook_result fmt_tx_confirm_hook(
 	fd_virt_addr = phys_to_virt(addr);
 	fd_len = fd->length20 + fd->offset;
 
-	if (fd_len > fsl_fman_phy_maxfrm) {
+	if (fd_len > fm_get_max_frm()) {
 		_fmt_err("tx confirm bad frame size: %u!\n", fd_len);
 		goto _fmt_tx_confirm_hook_continue;
 	}
@@ -577,7 +578,7 @@ enum dpaa_eth_hook_result fmt_tx_confirm_error_hook(
 	fd_virt_addr = phys_to_virt(addr);
 	fd_len = fd->length20 + fd->offset;
 
-	if (fd_len > fsl_fman_phy_maxfrm) {
+	if (fd_len > fm_get_max_frm()) {
 		_fmt_err("tx confirm err bad frame size: %u !\n", fd_len);
 		goto _priv_ingress_tx_err_continue;
 	}
@@ -728,7 +729,7 @@ static enum qman_cb_dqrr_result fmt_pcd_dqrr(
 
 	fd_len = dq->fd.length20 + dq->fd.offset;
 
-	if (fd_len > fsl_fman_phy_maxfrm) {
+	if (fd_len > fm_get_max_frm()) {
 		_fmt_err("pcd dqrr wrong frame size: %u (%u:%u)!\n",
 			fd_len, dq->fd.length20, dq->fd.offset);
 		goto _fmt_pcd_dqrr_return;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index 9b84edf..e663ad3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -93,8 +93,122 @@
                          ("Number of advanced-configuration entries exceeded"));\
     } while (0)
 
+/* Bootarg used to override the Kconfig FSL_FM_MAX_FRAME_SIZE value */
+#define FSL_FM_MAX_FRM_BOOTARG     "fsl_fm_max_frm"
+
+/* Bootarg used to override FSL_FM_RX_EXTRA_HEADROOM Kconfig value */
+#define FSL_FM_RX_EXTRA_HEADROOM_BOOTARG  "fsl_fm_rx_extra_headroom"
+
+/* Maximum value for the fsl_fm_rx_extra_headroom bootarg */
+#define FSL_FM_RX_EXTRA_HEADROOM_MAX 384
+
+/*
+ * Max frame size, across all interfaces.
+ * Configurable from Kconfig or bootargs, to avoid allocating
+ * oversized (socket) buffers when not using jumbo frames.
+ * Must be large enough to accomodate the network MTU, but small enough
+ * to avoid wasting skb memory.
+ *
+ * Could be overridden once, at boot-time, via the
+ * fm_set_max_frm() callback.
+ */
+int fsl_fm_max_frm = CONFIG_FSL_FM_MAX_FRAME_SIZE;
+
+/*
+ * Extra headroom for Rx buffers.
+ * FMan is instructed to allocate, on the Rx path, this amount of
+ * space at the beginning of a data buffer, beside the DPA private
+ * data area and the IC fields.
+ * Does not impact Tx buffer layout.
+ *
+ * Configurable from Kconfig or bootargs. Zero by default, it's needed
+ * on particular forwarding scenarios that add extra headers to the
+ * forwarded frame.
+ */
+int fsl_fm_rx_extra_headroom = CONFIG_FSL_FM_RX_EXTRA_HEADROOM;
+
 static t_LnxWrpFm   lnxWrpFm;
 
+int fm_get_max_frm()
+{
+	return fsl_fm_max_frm;
+}
+
+int fm_get_rx_extra_headroom()
+{
+	return fsl_fm_rx_extra_headroom;
+}
+
+static int __init fm_set_max_frm(char *str)
+{
+	int ret = 0;
+
+	ret = get_option(&str, &fsl_fm_max_frm);
+	if (ret != 1) {
+		/*
+		 * This will only work if CONFIG_EARLY_PRINTK is compiled in,
+		 * and something like "earlyprintk=serial,uart0,115200" is
+		 * specified in the bootargs
+		 */
+		printk(KERN_WARNING "No suitable %s=<int> prop in bootargs; "
+			"will use the default FSL_FM_MAX_FRAME_SIZE (%d) "
+			"from Kconfig.\n", FSL_FM_MAX_FRM_BOOTARG,
+			CONFIG_FSL_FM_MAX_FRAME_SIZE);
+
+		fsl_fm_max_frm = CONFIG_FSL_FM_MAX_FRAME_SIZE;
+		return 1;
+	}
+
+	/* Don't allow invalid bootargs; fallback to the Kconfig value */
+	if (fsl_fm_max_frm < 64 || fsl_fm_max_frm > 9600) {
+		printk(KERN_WARNING "Invalid %s=%d in bootargs, valid range is "
+			"64-9600. Falling back to the FSL_FM_MAX_FRAME_SIZE (%d) "
+			"from Kconfig.\n",
+			FSL_FM_MAX_FRM_BOOTARG, fsl_fm_max_frm,
+			CONFIG_FSL_FM_MAX_FRAME_SIZE);
+
+		fsl_fm_max_frm = CONFIG_FSL_FM_MAX_FRAME_SIZE;
+		return 1;
+	}
+
+	printk(KERN_INFO "Using fsl_fm_max_frm=%d from bootargs\n",
+		fsl_fm_max_frm);
+	return 0;
+}
+early_param(FSL_FM_MAX_FRM_BOOTARG, fm_set_max_frm);
+
+static int __init fm_set_rx_extra_headroom(char *str)
+{
+	int ret;
+
+	ret = get_option(&str, &fsl_fm_rx_extra_headroom);
+
+	if (ret != 1) {
+		printk(KERN_WARNING "No suitable %s=<int> prop in bootargs; "
+			"will use the default FSL_FM_RX_EXTRA_HEADROOM (%d) "
+			"from Kconfig.\n", FSL_FM_RX_EXTRA_HEADROOM_BOOTARG,
+			CONFIG_FSL_FM_RX_EXTRA_HEADROOM);
+		fsl_fm_rx_extra_headroom = CONFIG_FSL_FM_RX_EXTRA_HEADROOM;
+
+		return 1;
+	}
+
+	if (fsl_fm_rx_extra_headroom < 0 ||
+		fsl_fm_rx_extra_headroom > FSL_FM_RX_EXTRA_HEADROOM_MAX) {
+		printk(KERN_WARNING "Invalid value for %s=<int> prop in "
+			"bootargs; will use the default "
+			"FSL_FM_RX_EXTRA_HEADROOM (%d) from Kconfig.\n",
+			FSL_FM_RX_EXTRA_HEADROOM_BOOTARG,
+			CONFIG_FSL_FM_RX_EXTRA_HEADROOM);
+		fsl_fm_rx_extra_headroom = CONFIG_FSL_FM_RX_EXTRA_HEADROOM;
+	}
+
+	printk(KERN_INFO "Using fsl_fm_rx_extra_headroom=%d from bootargs\n",
+		fsl_fm_rx_extra_headroom);
+
+	return 0;
+}
+early_param(FSL_FM_RX_EXTRA_HEADROOM_BOOTARG, fm_set_rx_extra_headroom);
 
 static irqreturn_t fm_irq(int irq, void *_dev)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
index 9aa02aa..571e27c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
@@ -66,6 +66,14 @@
 #define FM_DEFAULT_TX10G_OPENDMA 8 /* default TX 10g open dmas */
 #define FM_DEFAULT_RX10G_OPENDMA 8 /* default RX 10g open dmas */
 
+#ifndef CONFIG_FSL_FM_MAX_FRAME_SIZE
+#define CONFIG_FSL_FM_MAX_FRAME_SIZE 0
+#endif
+
+#ifndef CONFIG_FSL_FM_RX_EXTRA_HEADROOM
+#define CONFIG_FSL_FM_RX_EXTRA_HEADROOM       0
+#endif
+
 typedef enum {
     e_NO_PCD = 0,
     e_FM_PCD_3_TUPLE
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index 47736cc..853ea3c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -51,9 +51,6 @@
 
 #include "lnxwrp_resources.h"
 
-extern int fsl_fman_phy_maxfrm;	/* MAC file */
-extern int dpa_rx_extra_headroom; /* dpaa_eth.c */
-
 static struct device_node *match_mac_to_dpaa_port(struct device_node
 						  *enet_mac_node)
 {
@@ -243,11 +240,9 @@ static uint32_t get_largest_buf_size(uint32_t max_rx_frame_size, uint32_t buf_si
 	uint32_t hash_results_size = 16;	/* DPA_HASH_RESULTS_SIZE */
 	uint32_t parse_results_size =
 		sizeof(t_FmPrsResult);		/* DPA_PARSE_RESULTS_SIZE */
-	uint32_t dpa_extra_headroom = (dpa_rx_extra_headroom != 0) ?
-					dpa_rx_extra_headroom :
-					CONFIG_DPA_EXTRA_HEADROOM;
-	uint32_t bp_head = priv_data_size + hash_results_size
-		+ parse_results_size + dpa_extra_headroom; /* DPA_BP_HEAD */
+	uint32_t bp_head = priv_data_size + hash_results_size +
+			   parse_results_size +
+			   fm_get_rx_extra_headroom(); /* DPA_BP_HEAD */
 	uint32_t bp_size = bp_head + max_rx_frame_size
 		+ NET_IP_ALIGN;			/* DPA_BP_SIZE */
 
@@ -317,9 +312,7 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 	int min_rx_bufs = 0; /* minimum RX buffers required (see refman.) */
 
 	/* Buffer sizes calculus */
-	int max_frame_size =
-		fsl_fman_phy_maxfrm ? fsl_fman_phy_maxfrm :
-		CONFIG_DPA_MAX_FRM_SIZE;
+	int max_frame_size = fm_get_max_frm();
 	int remaining_bufs = 0;
 	int rx_1g_bufs_ceil = 0, rx_2g5_bufs_ceil = 0, rx_10g_bufs_ceil = 0;
 	int rx_2g5_max_bufs = 0, rx_10g_max_bufs = 0;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
index 3b1b96e..1a08a7e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
@@ -147,12 +147,7 @@ enum dpa_fq_type {
 #define DPA_PARSE_RESULTS_SIZE sizeof(t_FmPrsResult)
 #define DPA_HASH_RESULTS_SIZE 16
 
-#ifndef CONFIG_DPA_EXTRA_HEADROOM
-#define CONFIG_DPA_EXTRA_HEADROOM	0
-#endif
-
 #define DPA_TX_PRIV_DATA_SIZE	16
-#define DPA_RX_PRIV_DATA_SIZE	(DPA_TX_PRIV_DATA_SIZE + dpa_rx_extra_headroom)
 
 #define dpaa_eth_init_port(type, port, param, errq_id, defq_id, priv_size, \
 			   has_timer) \
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index c595077..ef099f6 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -89,12 +89,6 @@
  * creating a S/G frame */
 #define DPA_SKB_COPY_MAX_SIZE	256
 
-/* Bootarg used to override the Kconfig DPA_MAX_FRM_SIZE value */
-#define FSL_FMAN_PHY_MAXFRM_BOOTARG	"fsl_fman_phy_max_frm"
-
-/* Bootarg used to override DPA_EXTRA_HEADROOM Kconfig value */
-#define DPA_EXTRA_HEADROOM_BOOTARG	"dpa_extra_headroom"
-
 /* Valid checksum indication */
 #define DPA_CSUM_VALID		0xFFFF
 
@@ -130,30 +124,9 @@ static struct dentry *dpa_debugfs_root;
 extern struct dentry *powerpc_debugfs_root;
 #endif
 
-/*
- * Max frame size, across all interfaces.
- * Configurable from Kconfig or bootargs, to avoid allocating
- * oversized (socket) buffers when not using jumbo frames.
- * Must be large enough to accomodate the network MTU, but small enough
- * to avoid wasting skb memory.
- *
- * Could be overridden once, at boot-time, via the
- * fsl_fman_phy_set_max_frm() callback.
- */
-int fsl_fman_phy_maxfrm = CONFIG_DPA_MAX_FRM_SIZE;
-
-/*
- * Extra headroom for Rx buffers.
- * FMan is instructed to allocate, on the Rx path, this amount of
- * space at the beginning of a data buffer, beside the DPA private
- * data area and the IC fields.
- * Does not impact Tx buffer layout.
- *
- * Configurable from Kconfig or bootargs. Zero by default, it's needed
- * on particular forwarding scenarios that add extra headers to the
- * forwarded frame to avoid unbounded increase of recycled buffers.
- */
-int dpa_rx_extra_headroom = CONFIG_DPA_EXTRA_HEADROOM;
+/* dpaa_eth mirror for the FMan values */
+static int dpa_rx_extra_headroom;
+static int dpa_max_frm;
 
 static const char rtx[][3] = {
 	[RX] = "RX",
@@ -737,7 +710,8 @@ dpa_get_stats(struct net_device *net_dev)
 static int dpa_change_mtu(struct net_device *net_dev, int new_mtu)
 {
 	const struct dpa_priv_s *priv;
-	const int max_mtu = fsl_fman_phy_maxfrm - (VLAN_ETH_HLEN + ETH_FCS_LEN);
+	const int max_mtu = dpa_get_max_frm()
+				- (VLAN_ETH_HLEN + ETH_FCS_LEN);
 	const int min_mtu = 64;
 
 	priv = netdev_priv(net_dev);
@@ -2082,14 +2056,15 @@ static enum qman_cb_dqrr_result __devinit tx_unit_test_dqrr(
 	if (fd->cmd & FM_FD_CMD_FCO) {
 		size_t bufsize = skb_end_pointer(skb) - startaddr;
 
-		if (bufsize < fsl_fman_phy_maxfrm)
+		if (bufsize < dpa_get_max_frm())
 			goto out;
 	} else {
 		/*
 		 * If we didn't recycle, but the buffer was big enough,
 		 * increment the counter to put it back
 		 */
-		if (skb_end_pointer(skb) - skb->head >= fsl_fman_phy_maxfrm)
+		if (skb_end_pointer(skb) - skb->head >=
+			dpa_get_max_frm())
 			(*percpu_priv->dpa_bp_count)++;
 
 		/* If we didn't recycle, the data pointer should be good */
@@ -2181,7 +2156,7 @@ static int __devinit dpa_tx_unit_test(struct net_device *net_dev)
 			}
 
 			if (skb_end_pointer(skb) - skb->head >=
-					fsl_fman_phy_maxfrm)
+					dpa_get_max_frm())
 				(*percpu_priv->dpa_bp_count)--;
 
 			skb_put(skb, size + headroom);
@@ -3612,6 +3587,10 @@ static int __init __cold dpa_load(void)
 
 	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
 
+	/* initialise dpaa_eth mirror values */
+	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
+	dpa_max_frm = fm_get_max_frm();
+
 #ifdef CONFIG_DEBUG_FS
 	dpa_debugfs_root = debugfs_create_dir(KBUILD_MODNAME,
 					      powerpc_debugfs_root);
@@ -3659,69 +3638,3 @@ static void __exit __cold dpa_unload(void)
 	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
 }
 module_exit(dpa_unload);
-
-static int __init fsl_fman_phy_set_max_frm(char *str)
-{
-	int ret = 0;
-
-	ret = get_option(&str, &fsl_fman_phy_maxfrm);
-	if (ret != 1) {
-		/* This will only work if CONFIG_EARLY_PRINTK is compiled in,
-		 * and something like "earlyprintk=serial,uart0,115200" is
-		 * specified in the bootargs */
-		printk(KERN_WARNING "No suitable %s=<int> prop in bootargs; "
-			"will use the default DPA_MAX_FRM_SIZE (%d) "
-			"from Kconfig.\n",
-			FSL_FMAN_PHY_MAXFRM_BOOTARG, CONFIG_DPA_MAX_FRM_SIZE);
-
-		fsl_fman_phy_maxfrm = CONFIG_DPA_MAX_FRM_SIZE;
-		return 1;
-	}
-
-	/* Don't allow invalid bootargs; fallback to the Kconfig value */
-	if (fsl_fman_phy_maxfrm < 64 || fsl_fman_phy_maxfrm > 9600) {
-		printk(KERN_WARNING "Invalid %s=%d in bootargs, valid range is "
-			"64-9600. Falling back to the DPA_MAX_FRM_SIZE (%d) "
-			"from Kconfig.\n",
-			FSL_FMAN_PHY_MAXFRM_BOOTARG, fsl_fman_phy_maxfrm,
-			CONFIG_DPA_MAX_FRM_SIZE);
-
-		fsl_fman_phy_maxfrm = CONFIG_DPA_MAX_FRM_SIZE;
-		return 1;
-	}
-
-	printk(KERN_INFO "Using fsl_fman_phy_maxfrm=%d from bootargs\n",
-		fsl_fman_phy_maxfrm);
-	return 0;
-}
-early_param(FSL_FMAN_PHY_MAXFRM_BOOTARG, fsl_fman_phy_set_max_frm);
-
-static int __init dpa_set_extra_headroom(char *str)
-{
-	int ret;
-
-	ret = get_option(&str, &dpa_rx_extra_headroom);
-	if (ret != 1) {
-		printk(KERN_WARNING "No suitable %s=<int> prop in bootargs; "
-			"will use the default DPA_EXTRA_HEADROOM (%d) "
-			"from Kconfig.\n",
-			DPA_EXTRA_HEADROOM_BOOTARG, CONFIG_DPA_EXTRA_HEADROOM);
-		dpa_rx_extra_headroom = CONFIG_DPA_EXTRA_HEADROOM;
-		return 1;
-	}
-
-	/* Don't allow invalid bootargs; fallback to the Kconfig value */
-	if (dpa_rx_extra_headroom + DPA_BP_HEAD > DPA_MAX_FD_OFFSET) {
-		printk(KERN_WARNING "Invalid %s=%d in bootargs, valid range is "
-			"0-%d. Falling back to the Kconfig value (%d).\n",
-			DPA_EXTRA_HEADROOM_BOOTARG, dpa_rx_extra_headroom,
-			DPA_MAX_FD_OFFSET - DPA_BP_HEAD,
-			CONFIG_DPA_EXTRA_HEADROOM);
-		dpa_rx_extra_headroom = CONFIG_DPA_EXTRA_HEADROOM;
-		return 1;
-	}
-
-	return 0;
-}
-
-early_param(DPA_EXTRA_HEADROOM_BOOTARG, dpa_set_extra_headroom);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index d445eac..0ed99d7 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -56,6 +56,11 @@
 
 #include "mac.h"		/* struct mac_device */
 
+#define dpa_get_rx_extra_headroom() dpa_rx_extra_headroom
+#define dpa_get_max_frm() dpa_max_frm
+
+#define DPA_RX_PRIV_DATA_SIZE   (DPA_TX_PRIV_DATA_SIZE + \
+					dpa_get_rx_extra_headroom())
 
 /* number of Tx queues to FMan */
 #define DPAA_ETH_TX_QUEUES	8
@@ -132,7 +137,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
 #define DPA_BP_HEAD (DPA_TX_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
 			DPA_HASH_RESULTS_SIZE)
-#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + dpa_rx_extra_headroom + (s))
+#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + dpa_get_rx_extra_headroom() + (s))
 
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 #define DEFAULT_SKB_COUNT 64 /* maximum number of SKBs in each percpu list */
@@ -143,10 +148,10 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 #define DEFAULT_BUF_SIZE	PAGE_SIZE
 #else
 /*
- * Default buffer size is based on L2 MAXFRM value, minus the FCS which is
+ * Default buffer size is based on L2 MAX_FRM value, minus the FCS which is
  * stripped down by hardware.
  */
-#define DEFAULT_BUF_SIZE DPA_BP_SIZE(fsl_fman_phy_maxfrm - ETH_FCS_LEN)
+#define DEFAULT_BUF_SIZE DPA_BP_SIZE(dpa_get_max_frm() - ETH_FCS_LEN)
 #endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
 
 /*
@@ -301,8 +306,6 @@ struct dpa_priv_s {
 };
 
 extern const struct ethtool_ops dpa_ethtool_ops;
-extern int fsl_fman_phy_maxfrm;
-extern int dpa_rx_extra_headroom;
 
 void __attribute__((nonnull))
 dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index a507230..8f27b19 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -171,11 +171,9 @@ void dpa_list_add_skbs(struct dpa_percpu_priv_s *cpu_priv, int count)
 	int i;
 
 	for (i = 0; i < count; i++) {
-		/*
-		 * new skb of (NET_SKB_PAD + DPA_BP_HEAD +
-		 * DPA_COPIED_HEADERS_SIZE) bytes
-		 */
-		new_skb = dev_alloc_skb(DPA_BP_SIZE(DPA_COPIED_HEADERS_SIZE));
+		new_skb = dev_alloc_skb(DPA_BP_HEAD +
+				fm_get_rx_extra_headroom() +
+				DPA_COPIED_HEADERS_SIZE);
 		if (unlikely(!new_skb)) {
 			pr_err("dev_alloc_skb() failed\n");
 			break;
@@ -286,7 +284,7 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	 * TODO: maybe adjust to actual headers length from
 	 * parse results
 	 */
-	copy_size = min(DPA_COPIED_HEADERS_SIZE, dpa_fd_length(fd));
+	copy_size = min((ssize_t)DPA_COPIED_HEADERS_SIZE, dpa_fd_length(fd));
 	memcpy(skb_put(skb, copy_size), vaddr + dpa_fd_offset(fd), copy_size);
 
 #ifdef CONFIG_FSL_DPA_1588
@@ -422,7 +420,8 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 	if (unlikely(skb == NULL)) {
 		/* List is empty, so allocate a new skb */
-		skb = dev_alloc_skb(DPA_BP_SIZE(DPA_COPIED_HEADERS_SIZE));
+		skb = dev_alloc_skb(DPA_BP_HEAD + fm_get_rx_extra_headroom() +
+			DPA_COPIED_HEADERS_SIZE);
 		if (unlikely(skb == NULL)) {
 			if (netif_msg_rx_err(priv) && net_ratelimit())
 				cpu_netdev_err(net_dev,
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index df24813..a9f355c 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -144,7 +144,8 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 		goto _return;
 	}
 
-	err = FM_MAC_ConfigMaxFrameLength(priv->mac, fsl_fman_phy_maxfrm);
+	err = FM_MAC_ConfigMaxFrameLength(priv->mac,
+					  fm_get_max_frm());
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
 		dpaa_eth_err(mac_dev->dev,
diff --git a/drivers/net/ethernet/freescale/dpa/mac.h b/drivers/net/ethernet/freescale/dpa/mac.h
index f95dde8..9da9beb 100644
--- a/drivers/net/ethernet/freescale/dpa/mac.h
+++ b/drivers/net/ethernet/freescale/dpa/mac.h
@@ -39,10 +39,6 @@
 
 #include "fsl_fman.h"		/* struct port_device */
 
-#ifndef CONFIG_DPA_MAX_FRM_SIZE
-#define CONFIG_DPA_MAX_FRM_SIZE		0
-#endif
-
 enum {DTSEC, XGMAC};
 
 struct mac_device {
-- 
1.7.9.7

