From c0eede72e55a46ecd6314c47980de3a0045053bf Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 3 Oct 2012 11:57:25 +0300
Subject: [PATCH 048/162] dpaa_eth: Selectively disable GRO

For certain types of traffic and/or PCD configurations, GRO is
undesirable because of unnecessary extra header processing. This becomes
much more of a problem with small frames (e.g. 64-byte UDP, or 64-byte
IP) and going through GRO when we know for sure it isn't the case incurs
a heavy performance penalty.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    |   37 ++++++++++++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   60 +++++++++++++++++++---
 2 files changed, 88 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 12c361f..917ca0c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1098,6 +1098,8 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	dma_addr_t addr = qm_fd_addr(fd);
 	u32 fd_status = fd->status;
 	unsigned int skb_len;
+	t_FmPrsResult *parse_result;
+	int use_gro = net_dev->features & NETIF_F_GRO;
 
 	skbh = (struct sk_buff **)phys_to_virt(addr);
 
@@ -1148,8 +1150,39 @@ void __hot _dpa_rx(struct net_device *net_dev,
 		 * the frame would have been received on the Error FQ,
 		 * respectively on the _dpa_rx_error() path). */
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
-	} else
+		if (use_gro) {
+			/*
+			 * Don't go through GRO for certain types of traffic
+			 * that we know are not GRO-able, such as dgram-based
+			 * protocols. In the worst-case scenarios, such as
+			 * small-pkt terminating UDP or similar IP forwarding,
+			 * the extra GRO processing would be overkill.
+			 *
+			 * So if the FMan Parser is running, the only supported
+			 * protocol that's also GRO-able is currently TCP.
+			 */
+			parse_result = (t_FmPrsResult *)((u8 *)skbh +
+				DPA_RX_PRIV_DATA_SIZE);
+			if (!(parse_result->l4r & FM_L4_PARSE_RESULT_TCP))
+				use_gro = 0;
+		}
+	} else {
 		skb->ip_summed = CHECKSUM_NONE;
+		/*
+		 * Bypass GRO for unknown traffic or if no PCDs are applied.
+		 * It's unlikely that a GRO handler is installed for this proto
+		 * or, if it is, user does not seem to care about performance
+		 * (otherwise, PCDs would have been in place).
+		 *
+		 * TODO: Ultimately, we might still leave GRO for frames larger
+		 * than a certain size (beyond which the GRO overhead becomes
+		 * negligible - that is, empirically, around 1500 bytes), but
+		 * that approach is rather clumsy. The way to go is knowing
+		 * for sure whether the Parser was running, and only disable
+		 * GRO for unrecognized frames.
+		 */
+		use_gro = 0;
+	}
 
 	/* Execute the Rx processing hook, if it exists. */
 	if (dpaa_eth_hooks.rx_default && dpaa_eth_hooks.rx_default(skb,
@@ -1159,7 +1192,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 	skb_len = skb->len;
 
-	if (likely(net_dev->features & NETIF_F_GRO)) {
+	if (use_gro) {
 		gro_result_t gro_result;
 
 		gro_result = napi_gro_receive(&percpu_priv->napi, skb);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index e93b659..8c74dd1 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -278,7 +278,8 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
  * received data is recycled as it is no longer required.
  */
 static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
-				   const struct qm_fd *fd, struct sk_buff *skb)
+				   const struct qm_fd *fd, struct sk_buff *skb,
+				   int *use_gro)
 {
 	unsigned int copy_size;
 	dma_addr_t addr = qm_fd_addr(fd);
@@ -289,7 +290,6 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	unsigned char *tailptr;
 	t_FmPrsResult *parse_results;
 
-
 	vaddr = phys_to_virt(addr);
 
 #ifdef CONFIG_FSL_DPA_1588
@@ -313,6 +313,19 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 		parse_results = (t_FmPrsResult *)(vaddr +
 			DPA_RX_PRIV_DATA_SIZE);
 		copy_size = parse_results->nxthdr_off;
+
+		/*
+		 * Don't go through GRO for certain types of traffic
+		 * that we know are not GRO-able, such as dgram-based
+		 * protocols. In the worst-case scenarios, such as
+		 * small-pkt terminating UDP or similar IP forwarding,
+		 * the extra GRO processing would be overkill.
+		 *
+		 * So if the FMan Parser is running, the only supported
+		 * protocol that's also GRO-able is currently TCP.
+		 */
+		if (*use_gro && !(parse_results->l4r & FM_L4_PARSE_RESULT_TCP))
+			*use_gro = 0;
 	} else {
 		skb->ip_summed = CHECKSUM_NONE;
 		/*
@@ -321,6 +334,21 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 		 */
 		copy_size = min((ssize_t)DPA_COPIED_HEADERS_SIZE,
 			dpa_fd_length(fd));
+
+		/*
+		 * Bypass GRO for unknown traffic or if no PCDs are applied.
+		 * It's unlikely that a GRO handler is installed for this proto
+		 * or, if it is, user does not seem to care about performance
+		 * (otherwise, PCDs would have been in place).
+		 *
+		 * TODO: Ultimately, we might still leave GRO for frames larger
+		 * than a certain size (beyond which the GRO overhead becomes
+		 * negligible - that is, empirically, around 1500 bytes), but
+		 * that approach is rather clumsy. The way to go is knowing
+		 * for sure whether the Parser was running, and only disable
+		 * GRO for unrecognized frames.
+		 */
+		*use_gro = 0;
 	}
 
 	tailptr = skb_put(skb, copy_size);
@@ -359,7 +387,8 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
  * The page holding the S/G Table is recycled here.
  */
 static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
-			       const struct qm_fd *fd, struct sk_buff *skb)
+			       const struct qm_fd *fd, struct sk_buff *skb,
+			       int *use_gro)
 {
 	const struct qm_sg_entry *sgt;
 	dma_addr_t addr = qm_fd_addr(fd);
@@ -370,6 +399,7 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	int frag_offset, frag_len;
 	int page_offset;
 	int i;
+	t_FmPrsResult *parse_results;
 
 	vaddr = phys_to_virt(addr);
 
@@ -431,8 +461,23 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 		 * respectively on the _dpa_rx_error() path).
 		 */
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
-	} else
+
+		/*
+		 * In the case of a SG frame, FMan stores the Internal Context
+		 * in the buffer containing the sgt.
+		 */
+		parse_results = (t_FmPrsResult *)(vaddr +
+			DPA_RX_PRIV_DATA_SIZE);
+		/*
+		 * Selectively disable GRO. See comment in contig_fd_to_skb().
+		 */
+		if (*use_gro && !(parse_results->l4r & FM_L4_PARSE_RESULT_TCP))
+			*use_gro = 0;
+	} else {
 		skb->ip_summed = CHECKSUM_NONE;
+		/* Bypass GRO. See comment in contig_fd_to_skb(). */
+		use_gro = 0;
+	}
 
 
 #ifdef CONFIG_FSL_DPA_1588
@@ -457,6 +502,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	dma_addr_t addr = qm_fd_addr(fd);
 	u32 fd_status = fd->status;
 	unsigned int skb_len;
+	int use_gro = net_dev->features & NETIF_F_GRO;
 
 	if (unlikely(fd_status & FM_FD_STAT_ERRORS) != 0) {
 		if (netif_msg_hw(priv) && net_ratelimit())
@@ -496,9 +542,9 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	prefetch(phys_to_virt(addr) + dpa_fd_offset(fd));
 
 	if (likely(fd->format == qm_fd_contig))
-		contig_fd_to_skb(priv, fd, skb);
+		contig_fd_to_skb(priv, fd, skb, &use_gro);
 	else if (fd->format == qm_fd_sg)
-		sg_fd_to_skb(priv, fd, skb);
+		sg_fd_to_skb(priv, fd, skb, &use_gro);
 	else
 		/* The only FD types that we may receive are contig and S/G */
 		BUG();
@@ -513,7 +559,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 	skb_len = skb->len;
 
-	if (likely(net_dev->features & NETIF_F_GRO)) {
+	if (use_gro) {
 		gro_result_t gro_result;
 
 		gro_result = napi_gro_receive(&percpu_priv->napi, skb);
-- 
1.7.9.7

