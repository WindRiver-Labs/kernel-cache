From 1699de67810c2b14c235cb83753bb5c96534f1e8 Mon Sep 17 00:00:00 2001
From: Stefan Szabo <szbs001@freescale.com>
Date: Fri, 31 Aug 2012 20:20:12 +0300
Subject: [PATCH 081/162] fmd: FMD17.1 Integration

This integrates FMD LLD release 17.1.

Signed-off-by: Stefan Szabo <szbs001@freescale.com>
Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |    3 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |  384 ++++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |    7 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  802 +++++++++++++++-----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   72 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |    2 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |   95 +--
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |   54 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |    4 +-
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    6 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |    2 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |   75 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   12 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |    4 +-
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |    6 +-
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    5 +-
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    5 +-
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    5 +-
 .../freescale/dpa/NetCommSw/inc/etc/mm_ext.h       |    7 +-
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |    8 +-
 .../inc/integrations/P1023/part_integration_ext.h  |   25 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |    5 +-
 .../P3040_P4080_P5020/part_integration_ext.h       |    7 +-
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    6 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/std_ext.h |    7 +-
 .../freescale/dpa/NetCommSw/inc/types_ext.h        |    6 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h  |    4 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |    2 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |  410 ++++++----
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |   48 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |    7 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |   35 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |  129 ++--
 35 files changed, 1549 insertions(+), 722 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index d8a7f83..dca18e1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -60,6 +60,9 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 #if FM_MAX_NUM_OF_10G_MACS > 0
     else
        p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+#else
+    else
+        p_FmMacControllerDriver = NULL; /* should not be reached */
 #endif /* FM_MAX_NUM_OF_10G_MACS > 0 */
 #else
     p_FmMacControllerDriver = (t_FmMacControllerDriver *)MEMAC_Config(p_FmMacParam);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 50392b2..cddb0dd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -626,7 +626,6 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMemMap    *p_MemMap;
     uint32_t        tmpReg32;
-    int             i = 1000;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
@@ -639,10 +638,7 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
 
     WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
-    while (--i && (GET_UINT32(p_MemMap->command_config) & CMD_CFG_STAT_CLR));
-
-    if (!i)
-        return E_TIMEOUT;
+    while (GET_UINT32(p_MemMap->command_config) & CMD_CFG_STAT_CLR) ;
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index bed5e34..2fd16d9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -214,8 +214,8 @@ static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
     }
 }
 
-static void UpdateStatsCounters(t_AdOfTypeStats *p_StatsAd,
-                                uint32_t        statsCountersAddr)
+static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
+                             uint32_t        statsCountersAddr)
 {
     uint32_t tmp = (statsCountersAddr & 0x00FFFFFF);
 
@@ -245,7 +245,7 @@ static void UpdateStatsAd(t_AdOfTypeStats *p_StatsAd,
 
     WRITE_UINT32(p_StatsAd->nextActionIndx, tmp);
 
-    UpdateStatsCounters(p_StatsAd, statsCountersAddr);
+    SetStatsCounters(p_StatsAd, statsCountersAddr);
 }
 
 static void FillAdOfTypeContLookup(t_Handle h_Ad,
@@ -559,6 +559,24 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
                                          &ccNodeInfo,
                                          p_FmPcdCcNextNode->h_Spinlock);
         }
+        if (p_AdditionalParams->h_ManipForAdd)
+        {
+            p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
+                                                             p_AdditionalParams->h_CurrentNode,
+                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+
+            if (p_CcNodeInformation)
+                p_CcNodeInformation->index++;
+            else
+            {
+                memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
+                ccNodeInfo.index = 1;
+                EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
+                                            &ccNodeInfo,
+                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+            }
+        }
     }
 
     if (p_AdditionalParams->h_NodeForRmv)
@@ -616,6 +634,23 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
                                           p_FmPcdCcNextNode->h_Spinlock);
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
+
+        if (p_AdditionalParams->h_ManipForRmv)
+        {
+             p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
+                                                             p_AdditionalParams->h_CurrentNode,
+                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+
+            ASSERT_COND(p_CcNodeInformation);
+            ASSERT_COND(p_CcNodeInformation->index);
+
+            p_CcNodeInformation->index--;
+
+            if (p_CcNodeInformation->index == 0)
+               DequeueNodeInfoFromRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
+                                              p_AdditionalParams->h_CurrentNode,
+                                              FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+        }
     }
 
     if (p_AdditionalParams->h_ManipForRmv)
@@ -1097,22 +1132,6 @@ void ReleaseLst(t_List *p_List)
     LIST_Del(p_List);
 }
 
-void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
-{
-    t_List              *p_Pos;
-    t_CcNodeInformation *p_CcNodeInfo;
-    t_Handle            h_FmPcdCcTree;
-
-    LIST_FOR_EACH(p_Pos, p_List)
-    {
-        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
-        CcRootReleaseLock(h_FmPcdCcTree);
-    }
-
-    ReleaseLst(p_List);
-}
-
 static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 {
     uint32_t i;
@@ -1222,9 +1241,11 @@ static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCc
 }
 
 static void  GetSizeHeaderField(e_NetHeaderType     hdr,
+                                e_FmPcdHdrIndex     index,
                                 t_FmPcdFields       field,
                                 uint8_t             *parseCodeRealSize)
 {
+    UNUSED(index);
     switch (hdr)
     {
         case (HEADER_TYPE_ETH):
@@ -1324,6 +1345,11 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                    *parseCodeRealSize = 4;
+#ifdef FM_EXP_FEATURES
+                   if ((field.ipv6 == NET_HEADER_FIELD_IPv6_TC) &&
+                     ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1)) )
+                        *parseCodeRealSize = 1;
+#endif /*FM_EXP_FEATURES*/
                     break;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
@@ -1687,6 +1713,10 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             {
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+#ifdef FM_EXP_FEATURES
+                    if (field.ipv6 == NET_HEADER_FIELD_IPv6_TC)
+                        return CC_PC_FF_IPTOS1;
+#endif /*FM_EXP_FEATURES*/
                         return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
@@ -1698,6 +1728,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV6PTYPE1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
 
@@ -2209,14 +2241,16 @@ static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_Addit
                          p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
-                          uint8_t       keySize,
-                          uint8_t       *p_Mask)
+static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
+                             uint8_t       keySize,
+                             uint8_t       *p_Mask)
 {
+    uint8_t prvGlblMaskSize = p_CcNode->glblMaskSize;
+
     if (p_Mask &&
         !p_CcNode->glblMaskUpdated &&
         (keySize <= 4) &&
-        !p_CcNode->lclMask )
+        !p_CcNode->lclMask)
     {
         memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
         p_CcNode->glblMaskUpdated = TRUE;
@@ -2232,7 +2266,7 @@ static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
             p_CcNode->glblMaskSize = 0;
         }
     }
-    else if (!p_Mask && (p_CcNode->glblMaskUpdated) && (keySize <= 4))
+    else if (!p_Mask && p_CcNode->glblMaskUpdated && (keySize <= 4))
     {
         uint32_t tmpMask = 0xffffffff;
         if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
@@ -2246,6 +2280,17 @@ static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
         p_CcNode->lclMask = TRUE;
         p_CcNode->glblMaskSize = 0;
     }
+
+    /* In static mode (maxNumOfKeys > 0), local mask is supported
+       only is mask support was enabled at initialization */
+    if (p_CcNode->maxNumOfKeys && (!p_CcNode->maskSupport) && p_CcNode->lclMask)
+    {
+        p_CcNode->lclMask = FALSE;
+        p_CcNode->glblMaskSize = prvGlblMaskSize;
+        return ERROR_CODE(E_NOT_SUPPORTED);
+    }
+
+    return E_OK;
 }
 
 static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
@@ -2384,9 +2429,11 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     prvLclMask = p_CcNode->lclMask;
 
     /* Check that new key is not require update of localMask */
-    UpdateGblMask(p_CcNode,
-                  p_CcNode->ccKeySizeAccExtraction,
-                  p_KeyParams->p_Mask);
+    err = UpdateGblMask(p_CcNode,
+                        p_CcNode->ccKeySizeAccExtraction,
+                        p_KeyParams->p_Mask);
+    if (err)
+        RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -2398,9 +2445,9 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             p_CcNode->userSizeOfExtraction);
 
     if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+        && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
     {
-        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
+        err = FmPcdCcAllocAndFillAdForContLookupManip(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2597,6 +2644,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
     if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+    if (p_KeyParams->ccNextEngineParams.h_Manip)
+        p_AdditionalInfo->h_ManipForAdd = p_KeyParams->ccNextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
         if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
@@ -2710,10 +2759,12 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
 
     prvLclMask = p_CcNode->lclMask;
 
-    /*check that new key is not require update of localMask*/
-    UpdateGblMask(p_CcNode,
-                  p_CcNode->ccKeySizeAccExtraction,
-                  p_Mask);
+    /* Check that new key is not require update of localMask */
+    err = UpdateGblMask(p_CcNode,
+                        p_CcNode->ccKeySizeAccExtraction,
+                        p_Mask);
+    if (err)
+        RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
@@ -2751,8 +2802,8 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
-                UpdateStatsCounters(p_AdTableNewTmp,
-                                    (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
+                SetStatsCounters(p_AdTableNewTmp,
+                                 (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
 
                 tmpStatsObj.h_StatsAd = p_StatsObj->h_StatsAd;
                 tmpStatsObj.h_StatsCounters = p_StatsObj->h_StatsCounters;
@@ -2906,8 +2957,10 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+
 #if (DPAA_VERSION >= 11)
         if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
@@ -3043,6 +3096,8 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
+    if (p_CcNextEngineParams->h_Manip)
+        p_AdditionalInfo->h_ManipForAdd = p_CcNextEngineParams->h_Manip;
 
     /* If statistics were previously enabled, but now are disabled,
        store the old statistics object to be released */
@@ -3354,11 +3409,11 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
     return err;
 }
 static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
-                                          uint16_t             frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR],
+                                          t_FmPcdCcNodeParams  *p_CcNodeParam,
                                           uint32_t             *p_NumOfRanges,
                                           uint32_t             *p_CountersArraySize)
 {
-    uint32_t    i;
+    UNUSED(p_CcNodeParam);
 
     switch (statisticsMode)
     {
@@ -3368,41 +3423,48 @@ static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
         case e_FM_PCD_CC_STATS_MODE_FRAME:
         case e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME:
             *p_NumOfRanges = 1;
-            *p_CountersArraySize = 2 * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
+            *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
             return E_OK;
 
+#ifdef FM_EXP_FEATURES
         case e_FM_PCD_CC_STATS_MODE_RMON:
-            if (frameLengthRanges[0] <= 0)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
-
-            if (frameLengthRanges[0] == 0xFFFF)
             {
-                *p_NumOfRanges = 1;
-                *p_CountersArraySize = 2 * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
-                return E_OK;
-            }
+                uint16_t    *p_FrameLengthRanges = p_CcNodeParam->keysParams.frameLengthRanges;
+                uint32_t    i;
 
-            for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
-            {
-                if (frameLengthRanges[i-1] >= frameLengthRanges[i])
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Frame length range must be larger at least by 1 from preceding range"));
+                if (p_FrameLengthRanges[0] <= 0)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
 
-                /* Stop when last range is reached */
-                if (frameLengthRanges[i] == 0xFFFF)
-                    break;
-            }
+                if (p_FrameLengthRanges[0] == 0xFFFF)
+                {
+                    *p_NumOfRanges = 1;
+                    *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
+                    return E_OK;
+                }
 
-            if (frameLengthRanges[i] != 0xFFFF)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
+                for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
+                {
+                    if (p_FrameLengthRanges[i-1] >= p_FrameLengthRanges[i])
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                                     ("Frame length range must be larger at least by 1 from preceding range"));
 
-            *p_NumOfRanges = i+1;
+                    /* Stop when last range is reached */
+                    if (p_FrameLengthRanges[i] == 0xFFFF)
+                        break;
+                }
 
-            /* Allocate an extra counter for byte count, as counters
-               array always begins with byte count */
-            *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
+                if (i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR ||
+                        p_FrameLengthRanges[i] != 0xFFFF)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
 
-            return E_OK;
+                *p_NumOfRanges = i+1;
 
+                /* Allocate an extra counter for byte count, as counters
+                   array always begins with byte count */
+                *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_COUNTER_SIZE;
+            }
+            return E_OK;
+#endif /* FM_EXP_FEATURES */
         default:
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
     }
@@ -3420,7 +3482,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
 
     /* Validate statistics parameters */
     err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
-                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
@@ -3467,9 +3529,11 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        UpdateGblMask(p_CcNode,
-                      p_CcNodeParam->keysParams.keySize,
-                      p_KeyParams->p_Mask);
+        err = UpdateGblMask(p_CcNode,
+                            p_CcNodeParam->keysParams.keySize,
+                            p_KeyParams->p_Mask);
+        if (err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
@@ -3510,9 +3574,6 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     {
         if (p_CcNode->maxNumOfKeys < p_CcNode->numOfKeys)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Number of keys exceed the provided maximal number of keys"));
-
-        if ((!p_CcNode->maskSupport) && (p_CcNode->glblMaskUpdated || p_CcNode->lclMask))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Mask support should be enabled, as it was required by the received keys parameters"));
     }
 
     *isKeyTblAlloc = TRUE;
@@ -3539,7 +3600,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
     /* Validate statistics parameters */
     err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
-                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
@@ -3643,15 +3704,16 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     if (!POWER_OF_2(p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
 
-    if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes ))
+    if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
 
-    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
+    if (p_CcNodeParam->keysParams.maxNumOfKeys &&
+        (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
     /* Validate statistics parameters */
     err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
-                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
@@ -3819,37 +3881,41 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     return ERROR_CODE(E_NOT_FOUND);
 }
 
-static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode *p_CcNode, bool isKeyTblAlloc)
+static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
+                                     bool           isKeyTblAlloc,
+                                     uint32_t       *p_MatchTableSize,
+                                     uint32_t       *p_AdTableSize)
 {
     uint32_t    shadowSize;
     t_Error     err;
 
     /* Calculate keys table maximal size - each entry consists of a key and a mask,
        (if local mask support is requested) */
-    p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+    *p_MatchTableSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
 
     if (p_CcNode->maskSupport)
-        p_CcNode->keysMatchTableMaxSize *= 2;
+        *p_MatchTableSize *= 2;
+
+    /* Calculate next action descriptors table, including one more entry for miss */
+    *p_AdTableSize = (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Calculate maximal shadow size of this node.
-       All shadow structures will be used for runtime modifications host command.
-       If keys table was allocated for this node, the keys table and next engines table may be
-       modified in run time (entries added or removed), so shadow tables are requires.
-       Otherwise, the only supported runtime modification is a specific next engine update and
-       this requires shadow memory of a single AD */
+       All shadow structures will be used for runtime modifications host command. If
+       keys table was allocated for this node, the keys table and next engines table may
+       be modified in run time (entries added or removed), so shadow tables are requires.
+       Otherwise, the only supported runtime modification is a specific next engine update
+       and this requires shadow memory of a single AD */
 
     /* Shadow size should be enough to hold the following 3 structures:
      * 1 - an action descriptor */
     shadowSize = FM_PCD_CC_AD_ENTRY_SIZE;
 
+    /* 2 - keys match table, if was allocated for the current node */
     if (isKeyTblAlloc)
-    {
-        /* 2 - keys match table, if was allocated for the current node */
-        shadowSize += p_CcNode->keysMatchTableMaxSize;
+        shadowSize += *p_MatchTableSize;
 
-        /* 3 - next action descriptors table, including one more entry for miss */
-        shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
-    }
+    /* 3 - next action descriptors table */
+    shadowSize += *p_AdTableSize;
 
     /* Update shadow to the calculated size */
     err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
@@ -3934,6 +4000,8 @@ static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
     if (!p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this key"));
 
+    memset(p_KeyStatistics, 0, sizeof (t_FmPcdCcKeyStatistics));
+
     p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
     ASSERT_COND(p_StatsCounters);
 
@@ -3941,9 +4009,13 @@ static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
 
     for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
     {
-        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
+        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_COUNTER_SIZE);
 
+        p_KeyStatistics->frameCount += GET_UINT32(*p_StatsCounters);
+
+#ifdef FM_EXP_FEATURES
         p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
+#endif /* FM_EXP_FEATURES */
     }
 
     return E_OK;
@@ -4354,10 +4426,6 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    if (p_CcNode->maxNumOfKeys)
-        if ((!p_CcNode->maskSupport) && (p_Mask))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
-
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
                        p_Key,
@@ -4502,14 +4570,9 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     if (p_CcNode->maxNumOfKeys)
-    {
         if ((p_CcNode->numOfKeys + 1) > p_CcNode->maxNumOfKeys)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
 
-        if ((!p_CcNode->maskSupport) && (p_FmPcdCcKeyParams->p_Mask))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
-    }
-
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
                        p_FmPcdCcKeyParams->p_Key,
@@ -4604,12 +4667,6 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    if (p_CcNode->maxNumOfKeys)
-    {
-        if ((!p_CcNode->maskSupport) && (p_FmPcdCcKeyParams->p_Mask))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
-    }
-
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
                        p_FmPcdCcKeyParams->p_Key,
@@ -4749,9 +4806,10 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
     t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_List                  *p_Pos, *p_Tmp;
     t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
+    uint32_t                intFlags;
     t_Error                 err = E_OK;
 
-    UNUSED(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
 
     if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"));
@@ -4780,9 +4838,35 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
         EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo, NULL);
     }
 
+    FmPcdUnlock(h_FmPcd, intFlags);
+    CORE_MemoryBarrier();
+
     return err;
 }
 
+void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
+{
+    t_List              *p_Pos;
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_Handle            h_FmPcdCcTree;
+    uint32_t            intFlags;
+
+    intFlags = FmPcdLock(h_FmPcd);
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
+        CcRootReleaseLock(h_FmPcdCcTree);
+    }
+
+    ReleaseLst(p_List);
+
+    FmPcdUnlock(h_FmPcd, intFlags);
+    CORE_MemoryBarrier();
+}
+
+
 t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 {
     uint32_t    intFlags;
@@ -5253,13 +5337,17 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     uint32_t            tmp, keySize;
     bool                glblMask = FALSE;
     t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Handle            h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp, h_StatsFLRs;
+    t_Handle            h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
+#ifdef FM_EXP_FEATURES
+    t_Handle            h_StatsFLRs;
+#endif /* FM_EXP_FEATURES */
     bool                fullField = FALSE;
     ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
     bool                isKeyTblAlloc, fromIc = FALSE;
-    uint16_t            numOfKeysToAlloc;
+    uint32_t            matchTableSize, adTableSize;
     t_CcNodeInformation ccNodeInfo, *p_CcInformation;
     t_FmPcdStatsObj     *p_StatsObj;
+    t_Handle            h_Manip;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
@@ -5283,9 +5371,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     /* For backward compatibility - even if statistics mode is nullified,
        we'll fix it to frame mode so we can support per-key request for
        statistics using 'statisticsEn' in next engine parameters */
-    if ((!p_CcNode->maxNumOfKeys) &&
+    if (!p_CcNode->maxNumOfKeys &&
         (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
-            p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
+        p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
 
     h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
     if (!h_FmMuram)
@@ -5377,6 +5465,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                               p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
                                               p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
                     GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
                                        p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
                                        &p_CcNode->sizeOfExtraction);
                     fullField = TRUE;
@@ -5387,6 +5476,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                         (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
+                        (p_CcNode->parseCode !=CC_PC_FF_IPTOS1) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
                         glblMask)
                     {
@@ -5509,14 +5599,10 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     /* Update CC shadow with maximal size required by this node */
     if (p_CcNode->maxNumOfKeys)
     {
-        numOfKeysToAlloc = p_CcNode->maxNumOfKeys;
-
-        /* If local mask is currently used, 'keySize' holds local mask size.
-           Otherwise, we need to allocate twice as much memory for future local mask support. */
-        if (p_CcNode->maskSupport && !(p_CcNode->lclMask))
-            numOfKeysToAlloc *= 2;
-
-        err = CalcAndUpdateCcShadow(p_CcNode, isKeyTblAlloc);
+        err = CalcAndUpdateCcShadow(p_CcNode,
+                                    isKeyTblAlloc,
+                                    &matchTableSize,
+                                    &adTableSize);
         if (err != E_OK)
         {
             DeleteNode(p_CcNode);
@@ -5524,6 +5610,8 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             return NULL;
         }
 
+        p_CcNode->keysMatchTableMaxSize = matchTableSize;
+
         if (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
         {
             err = PreAllocStatsObjs(p_CcNode);
@@ -5549,8 +5637,12 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
     else
-        numOfKeysToAlloc = p_CcNode->numOfKeys;
+    {
+        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t) * (p_CcNode->numOfKeys + 1));
+        adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
+    }
 
+#ifdef FM_EXP_FEATURES
     /* If RMON statistics mode requested, allocate frame length ranges array */
     if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
@@ -5577,6 +5669,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                         FM_PCD_CC_STATS_FLR_SIZE);
         }
     }
+#else
+    p_CcNode->h_StatsFLRs = NULL;
+#endif /* FM_EXP_FEATURES */
 
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
@@ -5584,8 +5679,8 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     {
         p_CcNode->h_KeysMatchTable =
             (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                        (uint32_t)(keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1)),
-                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+                                        matchTableSize,
+                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_CcNode->h_KeysMatchTable)
         {
             DeleteNode(p_CcNode);
@@ -5594,13 +5689,13 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
         IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
                    0,
-                   keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
+                   matchTableSize);
     }
 
     /* Allocate action descriptors table */
     p_CcNode->h_AdTable =
         (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                    (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                    adTableSize,
                                     FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_CcNode->h_AdTable)
     {
@@ -5608,15 +5703,13 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
         return NULL;
     }
-    IOMemSet32((uint8_t *)p_CcNode->h_AdTable,
-               0,
-               (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
     p_AdTableTmp      = p_CcNode->h_AdTable;
 
     /* For each key, create the key and the next step AD */
-    for (tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
@@ -5723,8 +5816,26 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                              &ccNodeInfo,
                                              p_FmPcdCcNextNode->h_Spinlock);
             }
+            else // TODO - think about Spinlock around ++
+                p_CcInformation->index++;
+            if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            {
+                h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
+                p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                                                             (t_Handle)p_CcNode,
+                                                             FmPcdManipGetSpinlock(h_Manip));
+                if (!p_CcInformation)
+                 {
+                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                     ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
+                     ccNodeInfo.index = 1;
+                     EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                                                  &ccNodeInfo,
+                                                  FmPcdManipGetSpinlock(h_Manip));
+            }
             else
                 p_CcInformation->index++;
+            }
         }
     }
 
@@ -5896,7 +6007,6 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -5907,9 +6017,7 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
     {
         DBG(TRACE, ("Node's trees lock failed"));
@@ -5923,7 +6031,7 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
                            p_Key,
                            p_Mask);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
     switch (GET_ERROR_TYPE(err))
     {
@@ -6226,7 +6334,6 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -6239,9 +6346,7 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
     {
         DBG(TRACE, ("Node's trees lock failed"));
@@ -6251,7 +6356,7 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
     if (GET_ERROR_TYPE(err) != E_OK)
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
+        FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
                                   "match table of the provided node"));
     }
@@ -6263,7 +6368,7 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
                            p_NewKey,
                            p_NewMask);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
     switch (GET_ERROR_TYPE(err))
     {
@@ -6344,7 +6449,7 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 
     /* The first counter is byte counter, so we need to advance to the next counter */
     frameCount = GET_UINT32(*(uint32_t *)(PTR_MOVE(p_StatsCounters,
-                                                   FM_PCD_CC_STATS_FLR_COUNT_SIZE)));
+                                                   FM_PCD_CC_STATS_COUNTER_SIZE)));
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -6472,6 +6577,15 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         return NULL;
     }
 
+#ifdef FM_EXP_FEATURES
+    if (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("RMON statistics mode currently not supported for hash table"));
+        return NULL;
+    }
+#endif /* FM_EXP_FEATURES */
+
     p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
     if (!p_ExactMatchCcNodeParam)
     {
@@ -6552,7 +6666,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 
     p_IndxHashCcNodeParam->keysParams.maxNumOfKeys   = numOfSets;
     p_IndxHashCcNodeParam->keysParams.maskSupport    = FALSE;
-    p_IndxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
+    p_IndxHashCcNodeParam->keysParams.statisticsMode = e_FM_PCD_CC_STATS_MODE_NONE;
     p_IndxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
     p_IndxHashCcNodeParam->keysParams.keySize        = 2;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 211fd62..6288f79 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -84,6 +84,9 @@
 #define CC_PC_FF_IPV6SRC1                   0x10
 #define CC_PC_FF_IPV6SRC2                   0x1e
 #define CC_PC_FF_IPV6HOP_LIMIT              0x2a
+#define CC_PC_FF_IPPID                      0x24
+#define CC_PC_FF_IPTOS1                     0x76
+
 #define CC_PC_FF_GREPTYPE                   0x11
 
 #define CC_PC_FF_MINENCAP_PTYPE             0x12
@@ -154,6 +157,7 @@
 #define FM_PCD_AD_RESULT_VSP_SHIFT           24
 #define FM_PCD_AD_RESULT_NO_OM_VSPE          0x02000000
 #define FM_PCD_AD_RESULT_VSP_MASK            0x3f
+#define FM_PCD_AD_NCSPFQIDM_MASK             0x80000000
 #endif /* (DPAA_VERSION >= 11) */
 
 #define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
@@ -265,6 +269,7 @@ typedef struct
     t_Handle        h_NodeForAdd;
     t_Handle        h_NodeForRmv;
     t_Handle        h_ManipForRmv;
+    t_Handle        h_ManipForAdd;
     t_FmPcdStatsObj *p_StatsObjForRmv;
 #if (DPAA_VERSION >= 11)
     t_Handle        h_FrmReplicForAdd;
@@ -366,7 +371,7 @@ typedef struct
 
 bool        FmPcdManipIsManipNode(t_Handle h_Ad);
 t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
-void        FmPcdCcNodeTreeReleaseLock(t_List *p_List);
+void        FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List);
 t_Error     FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align);
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index 02b7458..9bbac6a7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -136,9 +136,9 @@ static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
 /****************************************/
 
 
-static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16_t *p_TableSize, uint8_t *p_DataSize)
 {
-    uint8_t dataSize, remain, tableSize = 0;
+    uint8_t localDataSize, remain, tableSize = 0, dataSize = 0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
@@ -149,8 +149,7 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
                 tableSize +=  HMCD_BASIC_SIZE;
             break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
-                return 0;
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
         }
     }
 
@@ -160,18 +159,26 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
             case (e_FM_PCD_MANIP_INSRT_GENERIC):
                 remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
                 if (remain)
-                    dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+                    localDataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
                 else
-                    dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
-                tableSize += (uint8_t)(HMCD_BASIC_SIZE + dataSize);
+                    localDataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+                tableSize += (uint8_t)(HMCD_BASIC_SIZE + localDataSize);
             break;
             case (e_FM_PCD_MANIP_INSRT_BY_HDR):
                 /* As long as the only insert command is the internal L2, no check on type is required */
-                tableSize +=  HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
-                break;
+                tableSize += HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
+                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
+                    switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+                    {
+                        case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                            dataSize += p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+                        break;
+                        default:
+                            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                    }
+            break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
-                return 0;
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
         }
     }
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
@@ -181,12 +188,18 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
                 tableSize += HMCD_BASIC_SIZE;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                {
                     tableSize += HMCD_PTR_SIZE;
+                    dataSize += DSCP_TO_VLAN_TABLE_SIZE;
+                }
             break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 tableSize += HMCD_BASIC_SIZE;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                {
                     tableSize += HMCD_PARAM_SIZE;
+                    dataSize += 2;
+                }
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
@@ -208,8 +221,7 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
                     tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE;
             break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
-                return 0;
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
         }
     }
 
@@ -217,23 +229,30 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
     {
         switch (p_FmPcdManipParams->u.hdr.customParams.type){
             case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+            {
                 tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
+                dataSize += p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                    dataSize += 2;
+            }
             break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
-                return 0;
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
         }
     }
 
-    return tableSize;
+    *p_TableSize = tableSize;
+    *p_DataSize = dataSize;
+
+    return E_OK;
 }
 
-static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_DestHmct, uint8_t *p_DestData, bool new)
 {
-    uint32_t        *p_HmcdTbl = p_Manip->p_HmcdTbl;
-    uint32_t        *p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
+    uint32_t        *p_TmpHmct = p_DestHmct, *p_LocalData;
     uint32_t        tmpReg=0, *p_Last=NULL;
-    uint8_t         remain, i, size=0, origSize, *p_Data=NULL;
+    uint8_t         remain, i, size=0, origSize, *p_UsrData=NULL, *p_TmpData = p_DestData;
     t_Handle        h_FmPcd = p_Manip->h_FmPcd;
     uint8_t         j=0;
 
@@ -278,11 +297,11 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
         else
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
 
-        WRITE_UINT32(*p_TmpPtr, tmpReg);
+        WRITE_UINT32(*p_TmpHmct, tmpReg);
         /* save a pointer to the "last" indication word */
-        p_Last = p_TmpPtr;
+        p_Last = p_TmpHmct;
         /* advance to next command */
-        p_TmpPtr += HMCD_BASIC_SIZE/4;
+        p_TmpHmct += HMCD_BASIC_SIZE/4;
     }
 
     if (p_FmPcdManipParams->u.hdr.insrt)
@@ -299,13 +318,13 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size << HMCD_INSRT_SIZE_SHIFT;
 
             size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
-            p_Data = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
+            p_UsrData = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
 
-            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            WRITE_UINT32(*p_TmpHmct, tmpReg);
             /* save a pointer to the "last" indication word */
-            p_Last = p_TmpPtr;
+            p_Last = p_TmpHmct;
 
-            p_TmpPtr += HMCD_BASIC_SIZE/4;
+            p_TmpHmct += HMCD_BASIC_SIZE/4;
 
             /* initialize data to be inserted */
             /* if size is not a multiple of 4, padd with 0's */
@@ -314,19 +333,19 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             if (remain)
             {
                 size += (uint8_t)(4 - remain);
-                p_TmpData = (uint32_t *)XX_Malloc(size);
-                memset((uint8_t *)p_TmpData, 0, size);
-                memcpy((uint8_t *)p_TmpData, p_Data, origSize);
+                p_LocalData = (uint32_t *)XX_Malloc(size);
+                memset((uint8_t *)p_LocalData, 0, size);
+                memcpy((uint8_t *)p_LocalData, p_UsrData, origSize);
             }
             else
-                p_TmpData = (uint32_t*)p_Data;
+                p_LocalData = (uint32_t*)p_UsrData;
 
             /* initialize data and advance pointer to next command */
-            for (i = 0; i<size/4 ; i++, p_TmpPtr += HMCD_BASIC_SIZE/4)
-                WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
+            for (i = 0; i<size/4 ; i++, p_TmpHmct += HMCD_BASIC_SIZE/4)
+                WRITE_UINT32(*p_TmpHmct, *(p_LocalData+i));
 
             if (remain)
-                XX_Free(p_TmpData);
+                XX_Free(p_LocalData);
         }
 
         else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
@@ -345,29 +364,27 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                         hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
                     else
                         hmcdOpt = HMCD_INSRT_L2_MPLS;
-                    break;
+                break;
                 default:
                     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
             }
             tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
 
-            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            WRITE_UINT32(*p_TmpHmct, tmpReg);
             /* save a pointer to the "last" indication word */
-            p_Last = p_TmpPtr;
+            p_Last = p_TmpHmct;
 
-            p_TmpPtr += HMCD_BASIC_SIZE/4;
+            p_TmpHmct += HMCD_BASIC_SIZE/4;
 
             /* set size and pointer of user's data */
             size = (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
-            p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, size, 4);
-            if (!p_TmpData)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
-
-            memcpy((uint8_t*)p_TmpData, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data, size);
-            tmpReg = (size << HMCD_INSRT_L2_SIZE_SHIFT) | (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
-            WRITE_UINT32(*p_TmpPtr, tmpReg);
-            p_TmpPtr += HMCD_PTR_SIZE/4;
-            p_Manip->p_InsertData = (uint8_t*)p_TmpData;
+
+            ASSERT_COND(p_TmpData);
+            Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data, size);
+            tmpReg = (size << HMCD_INSRT_L2_SIZE_SHIFT) | (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+            WRITE_UINT32(*p_TmpHmct, tmpReg);
+            p_TmpHmct += HMCD_PTR_SIZE/4;
+            p_TmpData += size;
         }
         else
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
@@ -388,18 +405,14 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI) << HMCD_VLAN_PRI_REP_MODE_SHIFT;
                     /* set VPRI default */
                     tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
-                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpPtr;
+                    p_Last = p_TmpHmct;
                     /* write the table pointer into the Manip descriptor */
-                    p_TmpPtr += HMCD_BASIC_SIZE/4;
-
-                    /* Allocate MURAM for translation table and set its content. */
-                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, DSCP_TO_VLAN_TABLE_SIZE, 4);
-                    if (!p_TmpData)
-                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+                    p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                     tmpReg = 0;
+                    ASSERT_COND(p_TmpData);
                     for (i=0; i<FM_PCD_MANIP_DSCP_VALUES; i++)
                     {
                         /* first we build from each 8 values a 32bit register */
@@ -409,16 +422,15 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                          * (i=7-->word 0, i=15-->word 1,... i=63-->word 7) */
                         if ((i%8) == 7)
                         {
-                            WRITE_UINT32(*(p_TmpData + (i+1)/8-1), tmpReg);
+                            WRITE_UINT32(*((uint32_t*)p_TmpData + (i+1)/8-1), tmpReg);
                             tmpReg = 0;
                             j = 0;
                         }
                     }
-                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
-                    p_TmpPtr += HMCD_PTR_SIZE/4;
+                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    p_TmpHmct += HMCD_PTR_SIZE/4;
 
-                    /* Save data pointer so it can later be freed */
-                    p_Manip->p_UpdateData = (uint8_t*)p_TmpData;
+                    p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
 
                 else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
@@ -429,10 +441,10 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
                     /* set VPRI parameter */
                     tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
-                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpPtr;
-                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+                    p_Last = p_TmpHmct;
+                    p_TmpHmct += HMCD_BASIC_SIZE/4;
                 }
                 break;
 
@@ -453,33 +465,31 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
                     tmpReg |= HMCD_IPV4_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
-                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
-                p_Last = p_TmpPtr;
+                p_Last = p_TmpHmct;
 
-                p_TmpPtr += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
                 {
-                    /* Allocate MURAM for IP ID and copy its content. */
-                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, 2, 4);
-                    if (!p_TmpData)
-                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
-
-                    *(uint16_t*)p_TmpData = p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id;
-                    p_Manip->p_UpdateData = (uint8_t*)p_TmpData;
-                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
-                    p_TmpPtr += HMCD_PTR_SIZE/4;
+                    ASSERT_COND(p_TmpData);
+                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id);
+                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                    p_TmpData += 2;
+                    p_TmpHmct += HMCD_PTR_SIZE/4;
                 }
+
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
                 {
-                    WRITE_UINT32(*p_TmpPtr, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
-                    p_TmpPtr += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
                 }
+
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
                 {
-                    WRITE_UINT32(*p_TmpPtr, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
-                    p_TmpPtr += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
                 }
                 break;
 
@@ -498,22 +508,22 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
                     tmpReg |= HMCD_IPV6_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
-                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
-                p_Last = p_TmpPtr;
+                p_Last = p_TmpHmct;
 
-                p_TmpPtr += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE/4;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
                     for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
-                        WRITE_UINT32(*p_TmpPtr, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
-                        p_TmpPtr += HMCD_PTR_SIZE/4;
+                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
+                        p_TmpHmct += HMCD_PTR_SIZE/4;
                     }
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
                     for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
-                        WRITE_UINT32(*p_TmpPtr, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
-                        p_TmpPtr += HMCD_PTR_SIZE/4;
+                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
+                        p_TmpHmct += HMCD_PTR_SIZE/4;
                     }
                 break;
 
@@ -524,11 +534,11 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     /* set opcode */
                     tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM) << HMCD_OC_SHIFT;
                     /* write the first 4 bytes of the descriptor */
-                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpPtr;
+                    p_Last = p_TmpHmct;
 
-                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE/4;
                 }
                 else
                 {
@@ -540,19 +550,19 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                          tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
                     /* write the first 4 bytes of the descriptor */
-                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpPtr;
+                    p_Last = p_TmpHmct;
 
-                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                     tmpReg = 0;
                     if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
                     if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
-                    WRITE_UINT32(*p_TmpPtr, tmpReg);
-                    p_TmpPtr += HMCD_PTR_SIZE/4;
+                    WRITE_UINT32(*p_TmpHmct, tmpReg);
+                    p_TmpHmct += HMCD_PTR_SIZE/4;
                 }
                 break;
 
@@ -585,38 +595,29 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                                  ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
 
                 /* write the first 4 bytes of the descriptor */
-                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
-                p_Last = p_TmpPtr;
+                p_Last = p_TmpHmct;
 
-                p_TmpPtr += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                 size = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
-                /* Allocate MURAM for IP ID and copy its content. */
-                p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, size, 4);
-                if (!p_TmpData)
-                    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
-
-                memcpy(p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr, size);
-                p_Manip->p_CustomData1 = (uint8_t*)p_TmpData;
+                ASSERT_COND(p_TmpData);
+                Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr, size);
                 tmpReg = (uint32_t)(size << HMCD_IP_REPLACE_L3HDRSIZE_SHIFT);
-                tmpReg |= (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
-                WRITE_UINT32(*p_TmpPtr, tmpReg);
-                p_TmpPtr += HMCD_PTR_SIZE/4;
+                tmpReg |= (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                WRITE_UINT32(*p_TmpHmct, tmpReg);
+                p_TmpHmct += HMCD_PTR_SIZE/4;
+                p_TmpData += size;
 
                 if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
                         (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                 {
-                    /* Allocate MURAM for IP ID and copy its content. */
-                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, 2, 4);
-                    if (!p_TmpData)
-                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
-
-                    *(uint16_t*)p_TmpData = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id;
-                    p_Manip->p_CustomData2 = (uint8_t*)p_TmpData;
-                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
+                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    p_TmpData += 2;
                 }
-                p_TmpPtr += HMCD_PTR_SIZE/4;
+                p_TmpHmct += HMCD_PTR_SIZE/4;
             break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
@@ -624,22 +625,50 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     }
 
 
-
     /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
        the old table and should be freed */
     if (p_FmPcdManipParams->h_NextManip &&
         (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
     {
+        //ASSERT_COND(MANIP_IS_FIRST(p_FmPcdManipParams->h_NextManip));
+
+        if (new)
+        {
         /* copy old table to new location */
-        memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
-        /* free old table */
+            IO2IOCpy32((uint8_t *)p_TmpHmct, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
+
+            /* copy old data section to new location (perhaps can be unified with above). */
+            if (p_TmpData)
+            {
+                p_TmpData = p_TmpData - MANIP_GET_DATA_SIZE(p_Manip) - MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip);
+                IO2IOCpy32((uint8_t *)p_TmpData,
+                        MANIP_GET_DATA_PTR(p_FmPcdManipParams->h_NextManip),
+                        MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip));
+            }
+        /* If this is the first time this manip is created we need to free unused memory. If it
+         * is a dynamic changes case, the memory used is either the CC shadow or the existing
+         * table - no allocation, no free */
+            MANIP_UPDATE_UNIFIED_POSITION(p_FmPcdManipParams->h_NextManip);
+
+            p_Manip->unifiedPosition = e_MANIP_UNIFIED_FIRST;
+
+            /* The HMTD of the next Manip is never going to be used */
+            if (((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
+                FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
+            else
+                XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
+            ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
+
+
+            /* We copied the HMCT to create a new large HMCT so we can free the old one */
         FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
+
         /* update old manip table pointer */
-        MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
-        /* indicate that this manip node has no MURAM memory to be freed */
-        MANIP_SET_UNIFIED_TBL_PTR_INDICATION(p_FmPcdManipParams->h_NextManip);
+            MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpHmct);
+            MANIP_SET_DATA_PTR(p_FmPcdManipParams->h_NextManip, p_TmpData);
         /* advance pointer */
-        p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+            p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+        }
     }
     else
         /* set the "last" indication on the last command of the current table */
@@ -648,16 +677,17 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     return E_OK;
 }
 
-static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
     t_Error     err;
-    uint16_t    tmpReg, tmpSize;
+    uint16_t    tmpReg;
+    uint32_t    nextSize = 0, totalSize;
 
     /* set Manip structure */
     if (p_FmPcdManipParams->h_NextManip)
     {
         if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-            p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
+            nextSize =(uint32_t)(MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip) + MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
     }
@@ -665,44 +695,196 @@ static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_Fm
 
     /* Allocate new table */
     /* calculate table size according to manip parameters */
-    tmpSize = CalculateTableSize(p_FmPcdManipParams);
-    if (tmpSize == 0)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CalculateTableSize Failed"));
+    err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize, &p_Manip->dataSize);
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
-    p_Manip->tableSize += tmpSize;
-    p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
-    if (!p_Manip->p_HmcdTbl)
+    totalSize = p_Manip->tableSize + p_Manip->dataSize + nextSize;
+
+    p_Manip->p_Hmct = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
+    if (!p_Manip->p_Hmct)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
+    if(p_Manip->dataSize)
+        p_Manip->p_Data = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + nextSize;
+
+    /* update shadow size to allow runtime replacement of Header manipulation */
+    /* The allocated shadow is divided as follows:
+       0 . . .       16 . . .
+       --------------------------------
+       |   Shadow   |   Shadow HMTD   |
+       |   HMTD     |   Match Table   |
+       | (16 bytes) | (maximal size)  |
+       --------------------------------
+     */
+
+    err = FmPcdUpdateCcShadow (p_Manip->h_FmPcd, totalSize + 16, FM_PCD_CC_AD_TABLE_ALIGN);
+    if (err != E_OK)
+    {
+        FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for HdrManip node shadow"));
+    }
+
     /* Fill table */
-    err = BuildHmct(p_Manip, p_FmPcdManipParams);
+    err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, TRUE);
     if (err)
+    {
+        FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
         RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     /* Build HMTD (table descriptor) */
     tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
     /* add parseAfterManip */
     if (!p_Manip->dontParseAfterManip)
         tmpReg |= HMTD_CFG_PRS_AFTER_HM;
+    /* create cascade */
     if (p_FmPcdManipParams->h_NextManip &&
         !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
     {
         /* indicate that there's another HM table descriptor */
         tmpReg |= HMTD_CFG_NEXT_AD_EN;
         WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
-                     (uint16_t)((uint32_t)(PTR_TO_UINT(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip))) -
+                     (uint16_t)((uint32_t)(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
                                 (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
     }
 
     WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
     WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-            (uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+            (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
 
     WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
 
     return E_OK;
 }
 
+static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
+{
+     t_FmPcdManip     *p_CurManip = p_Manip;
+
+    if (!MANIP_IS_UNIFIED(p_Manip))
+        p_CurManip = p_Manip;
+    else
+    {
+        /* go to first unified */
+        while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+            p_CurManip = p_CurManip->h_PrevManip;
+    }
+
+    switch (manipInfo)
+    {
+        case (e_MANIP_HMCT):
+            return p_CurManip->p_Hmct;
+        case (e_MANIP_HMTD):
+            return p_CurManip->h_Ad;
+        case (e_MANIP_HANDLER_TABLE_OWNER):
+            return (t_Handle)p_CurManip;
+        default:
+            return NULL;
+    }
+}
+static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+{
+    uint8_t         *p_WholeHmct, newDataSize, *p_TmpDataPtr = NULL;
+    uint16_t        newSize;
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    t_Error            err;
+    t_FmPcdManip    *p_CurManip = p_Manip;
+    uint32_t        *p_TmpHmctPtr;
+
+
+    err = CalculateTableSize(p_FmPcdManipParams, &newSize, &newDataSize);
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* check coherency of new table parameters */
+    if (newSize > p_Manip->tableSize)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (command table)."));
+    if (newDataSize > p_Manip->dataSize)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (data)."));
+    if (p_FmPcdManipParams->h_NextManip)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration can not contain h_NextManip."));
+    if (MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
+    if (p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration differs in dontParseAfterManip value."));
+
+    p_Manip->tableSize = newSize;
+    p_Manip->dataSize = newDataSize;
+
+
+    /* Build the new table in the shadow */
+    if (!MANIP_IS_UNIFIED(p_Manip))
+    {
+        p_TmpHmctPtr = (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16);
+        if (p_Manip->p_Data)
+            p_TmpDataPtr = (uint8_t*)p_FmPcd->p_CcShadow + 16 + (p_Manip->p_Data - (uint8_t*)p_Manip->p_Hmct);
+
+        BuildHmct(p_Manip, p_FmPcdManipParams, (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16), p_Manip->p_Data, FALSE);
+    }
+    else
+    {
+        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+        ASSERT_COND(p_WholeHmct);
+
+        /* Run till the last Manip (which is the first to configure) */
+        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+            p_CurManip = p_CurManip->h_NextManip;
+
+        while(p_CurManip)
+        {
+            /* If this is a non-head node in a unified table, point to the part of the shadow
+             * which is the relative offset in HMCT.
+             * else, point to the beginning of the
+             * shadow table (we save 16 for the HMTD.
+             */
+            p_TmpHmctPtr = (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16 + ((uint8_t*)p_CurManip->p_Hmct - p_WholeHmct));
+            if(p_CurManip->p_Data)
+                p_TmpDataPtr = (uint8_t*)p_FmPcd->p_CcShadow + 16 + (p_CurManip->p_Data - p_WholeHmct);
+
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            p_CurManip = p_CurManip->h_PrevManip;
+        }
+    }
+
+    return E_OK;
+}
+
+static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+{
+    uint8_t         *p_WholeHmct, *p_TmpDataPtr;
+    t_FmPcdManip    *p_CurManip = p_Manip;
+    uint32_t        *p_TmpHmctPtr;
+
+    /* Build the new table in the shadow */
+    if (!MANIP_IS_UNIFIED(p_Manip))
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
+    else
+    {
+        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+        ASSERT_COND(p_WholeHmct);
+
+        /* Run till the last Manip (which is the first to configure) */
+        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+            p_CurManip = p_CurManip->h_NextManip;
+
+        while(p_CurManip)
+        {
+            /* If this is a unified table, point to the part of the table
+             * which is the relative offset in HMCT.
+            */
+            p_TmpHmctPtr = p_CurManip->p_Hmct;
+            p_TmpDataPtr = p_CurManip->p_Data;
+
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+
+            p_CurManip = p_CurManip->h_PrevManip;
+       }
+    }
+
+    return E_OK;
+}
+
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
@@ -711,7 +893,7 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
@@ -766,7 +948,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->type & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
     if (p_Manip->updateParams)
@@ -833,7 +1015,7 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
@@ -885,8 +1067,8 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) ||
-                               (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) ||
+                               (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
@@ -970,7 +1152,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
 
@@ -1410,7 +1592,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->frag, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams, E_INVALID_HANDLE);
 
@@ -1513,6 +1695,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     else
     {
 #else
+#ifdef FM_EXP_FEATURES
     if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1532,6 +1715,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
         tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
         WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
     }
+#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION == 10)
     }
@@ -1676,7 +1860,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                             switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
                                 case (HEADER_TYPE_CAPWAP_DTLS) :
-                                    p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                                    p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
                                     p_Manip->muramAllocate = TRUE;
                                     if (p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
@@ -1687,7 +1871,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                                             switch (p_ManipParams->fragOrReasmParams.hdr)
                                             {
                                                 case (HEADER_TYPE_CAPWAP):
-                                                    p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
+                                                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                                                     break;
                                                 default:
                                                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
@@ -1709,7 +1893,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                                 case (HEADER_TYPE_CAPWAP) :
                                     if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
-                                    p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                                    p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
                                     p_Manip->muramAllocate = TRUE;
                                     p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
                                     break;
@@ -1732,7 +1916,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
-                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
                 p_Manip->muramAllocate = FALSE;
                 if (p_ManipParams->fragOrReasm)
                 {
@@ -1741,7 +1925,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                            switch (p_ManipParams->fragOrReasmParams.hdr)
                            {
                                 case (HEADER_TYPE_CAPWAP):
-                                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                                     break;
                                 default:
                                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
@@ -1763,7 +1947,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
                 case (HEADER_TYPE_CAPWAP):
-                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                     p_Manip->muramAllocate = FALSE;
                     break;
                 default:
@@ -1796,6 +1980,15 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
     switch (p_ManipParams->type)
     {
         case e_FM_PCD_MANIP_HDR :
+            /* Check that next-manip is not already used */
+            if (p_ManipParams->h_NextManip)
+            {
+                if (!MANIP_IS_FIRST(p_ManipParams->h_NextManip))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_NextManip is already a part of another chain"));
+                if (MANIP_GET_TYPE(p_ManipParams->h_NextManip) != e_FM_PCD_MANIP_HDR)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
+            }
+
             if (p_ManipParams->u.hdr.rmv)
             {
                 switch (p_ManipParams->u.hdr.rmvParams.type)
@@ -1804,7 +1997,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                         switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                         {
                             case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
-                                p_Manip->type = HMAN_OC;
+                                p_Manip->opcode = HMAN_OC;
                                 p_Manip->muramAllocate = TRUE;
                                 break;
                             default :
@@ -1812,7 +2005,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                         }
                         break;
                    case (e_FM_PCD_MANIP_RMV_GENERIC):
-                       p_Manip->type = HMAN_OC;
+                       p_Manip->opcode = HMAN_OC;
                        p_Manip->muramAllocate = TRUE;
                        break;
                    default:
@@ -1826,7 +2019,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 {
                     case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
                     case (e_FM_PCD_MANIP_INSRT_GENERIC):
-                        p_Manip->type = HMAN_OC;
+                        p_Manip->opcode = HMAN_OC;
                         p_Manip->muramAllocate = TRUE;
                         break;
                     default:
@@ -1855,13 +2048,13 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
 
                 }
 
-                p_Manip->type = HMAN_OC;
+                p_Manip->opcode = HMAN_OC;
                 p_Manip->muramAllocate = TRUE;
                 p_Manip->fieldUpdate = TRUE;
             }
             else if (p_ManipParams->u.hdr.custom)
             {
-                p_Manip->type = HMAN_OC;
+                p_Manip->opcode = HMAN_OC;
                 p_Manip->muramAllocate = TRUE;
                 p_Manip->custom = TRUE;
             }
@@ -1880,7 +2073,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for reassembly"));
              }
-            p_Manip->type = HMAN_OC_IP_REASSEMBLY;
+            p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
             break;
         case e_FM_PCD_MANIP_FRAG :
             if (p_ManipParams->h_NextManip)
@@ -1893,14 +2086,14 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
              }
-            p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
+            p_Manip->opcode = HMAN_OC_IP_FRAGMENTATION;
             p_Manip->muramAllocate = TRUE;
             break;
         case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
             switch (p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
-                    p_Manip->type = HMAN_OC_IPSEC_MANIP;
+                    p_Manip->opcode = HMAN_OC_IPSEC_MANIP;
                     p_Manip->muramAllocate = TRUE;
                     break;
                 default:
@@ -1911,12 +2104,6 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
-    /* Check that next-manip is not already used */
-    if ((p_Manip->type == HMAN_OC) &&
-            p_ManipParams->h_NextManip &&
-            MANIP_GET_OWNERS(p_ManipParams->h_NextManip))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_NextManip is already used and may not be shared (no sharing of non-head manip nodes)"));
-
     return E_OK;
 }
 #endif /* not FM_CAPWAP_SUPPORT */
@@ -2001,7 +2188,7 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
@@ -2039,7 +2226,7 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 
     UNUSED(level);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
@@ -2446,7 +2633,13 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
     tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
     WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
 #endif /* (DPAA_VERSION == 10) */
-
+#if (DPAA_VERSION >= 11)
+    if (p_Manip->ipReassmParams.nonConsistentSpFqid != 0)
+    {
+        tmpReg32 = FM_PCD_AD_NCSPFQIDM_MASK | (uint32_t)(p_Manip->ipReassmParams.nonConsistentSpFqid);
+        WRITE_UINT32(p_Ad->gmask, tmpReg32);
+    }
+#endif /* (DPAA_VERSION >= 11) */
     /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
@@ -2539,7 +2732,12 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
 #if (DPAA_VERSION == 10)
     p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
 #endif /* (DPAA_VERSION == 10) */
-    /* Creates and initializes the IP Reassembly common parameter table */
+#if (DPAA_VERSION >= 11)
+    if (reassmManipParams.nonConsistentSpFqid != 0)
+    {
+        p_Manip->ipReassmParams.nonConsistentSpFqid = reassmManipParams.nonConsistentSpFqid;
+    }
+#endif /* (DPAA_VERSION >= 11) */    /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonTable(p_Manip);
 
     /* Creation of IPv4 reassembly manipulation */
@@ -2925,10 +3123,10 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
     ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
     ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
 
-#ifdef ALU_CUSTOM
+#ifdef FM_EXP_FEATURES
     if (p_ManipParams->optionsCounterEn)
         ccAdBaseReg |= FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN;
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
 
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
@@ -3056,7 +3254,7 @@ static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsPa
     switch (p_StatsParams->type)
     {
         case (e_FM_PCD_STATS_PER_FLOWID):
-            p_Manip->type = HMAN_OC_CAPWAP_INDEXED_STATS;
+            p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
             p_Manip->muramAllocate = TRUE;
             break;
         default:
@@ -3081,6 +3279,9 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     }
     memset(p_Manip, 0, sizeof(t_FmPcdManip));
 
+    p_Manip->type = ((t_FmPcdManipParams *)p_Params)->type;
+    memcpy((uint8_t*)&p_Manip->manipParams, p_Params, sizeof(p_Manip->manipParams));
+
     if (!stats)
         err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
 #ifdef FM_CAPWAP_SUPPORT
@@ -3101,7 +3302,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         return NULL;
     }
 
-    if (p_Manip->type != HMAN_OC_IP_REASSEMBLY)
+    if (p_Manip->opcode != HMAN_OC_IP_REASSEMBLY)
     {
         /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
            be defines later on */
@@ -3171,7 +3372,7 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 
     ASSERT_COND(h_Manip);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
@@ -3184,13 +3385,30 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
 {
 
+    uint32_t            intFlags;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    intFlags = XX_LockIntrSpinlock(p_Manip->h_Spinlock);
     if (add)
-        ((t_FmPcdManip *)h_Manip)->owner++;
+        p_Manip->owner++;
     else
     {
-        ASSERT_COND(((t_FmPcdManip *)h_Manip)->owner);
-        ((t_FmPcdManip *)h_Manip)->owner--;
+        ASSERT_COND(p_Manip->owner);
+        p_Manip->owner--;
     }
+    XX_UnlockIntrSpinlock(p_Manip->h_Spinlock, intFlags);
+}
+t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip)
+{
+    ASSERT_COND(h_Manip);
+    return &((t_FmPcdManip *)h_Manip)->nodesLst;
+}
+t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
+{
+    ASSERT_COND(h_Manip);
+   return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
 
 t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
@@ -3204,7 +3422,7 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
             if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
@@ -3254,8 +3472,11 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             p_Manip->ownerTmp++;
             break;
         case (HMAN_OC):
-            if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
+            if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
+            if (!MANIP_IS_FIRST(p_Manip)) //TODO Ganit - maybe change to owners
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
+
             break;
 
         default:
@@ -3273,7 +3494,7 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
             if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
@@ -3316,7 +3537,7 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
 
     /* According to "type", either build & initialize a new AD (p_AdNew) or initialize
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
@@ -3386,7 +3607,7 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
@@ -3494,7 +3715,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     }
     memset(p_Manip, 0, sizeof(t_FmPcdManip));
 
-    p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+    p_Manip->opcode = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
@@ -3546,8 +3767,17 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
     if (!p_Manip)
         return NULL;
+    p_Manip->h_Spinlock = XX_InitSpinlock();
+    if (!p_Manip->h_Spinlock)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+    INIT_LIST(&p_Manip->nodesLst);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
@@ -3593,7 +3823,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->insrt)
-                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
         case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
@@ -3611,7 +3841,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->rmv)
-                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
@@ -3623,7 +3853,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             break;
        case (HMAN_OC):
            /* New Manip */
-           err = CreateManipAction(p_Manip, p_ManipParams);
+           err = CreateManipActionNew(p_Manip, p_ManipParams);
            break;
        default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3642,6 +3872,8 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
 
     if (p_ManipParams->h_NextManip)
     {
+        /* in the check routine we've verified that h_NextManip has no owners
+         * and that only supported types are allowed. */
         p_Manip->h_NextManip = p_ManipParams->h_NextManip;
         /* save a "prev" pointer in h_NextManip */
         MANIP_SET_PREV(p_Manip->h_NextManip, p_Manip);
@@ -3651,6 +3883,188 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     return p_Manip;
 }
 
+
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_CrntMdfManip,
+                                                       t_List            *h_NodesLst)
+{
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfManip = NULL;
+    t_List                  *p_Pos;
+    int                     i = 0;
+    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation     ccNodeInfo;
+
+    LIST_FOR_EACH(p_Pos, &p_CrntMdfManip->nodesLst)
+    {
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        p_NodePtrOnCurrentMdfManip = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+
+        ASSERT_COND(p_NodePtrOnCurrentMdfManip);
+
+        /* Search in the previous node which exact index points on this current modified node for getting AD */
+        for(i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
+        {
+            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                {
+                    if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
+                    else
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                PTR_MOVE(p_NodePtrOnCurrentMdfManip->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
+                    EnqueueNodeInfoToRelevantLst(h_NodesLst, &ccNodeInfo, NULL);
+
+                }
+            }
+        }
+
+        ASSERT_COND(i != p_NodePtrOnCurrentMdfManip->numOfKeys);
+    }
+}
+
+
+static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd *p_FmPcd)
+{
+    t_Error err;
+
+   /* Copy the HMTD */
+    IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
+    /* Replace the HMCT table pointer  */
+    WRITE_UINT32(((t_Hmtd *)p_Dest)->hmcdBasePtr,
+              (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
+    /* Call Host Command to replace HMTD by a new HMTD */
+    err = FmHcPcdCcDoDynamicChange(p_FmPcd->h_Hc,
+                                (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
+                                (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
+    if (err)
+     REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
+
+}
+
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipParams)
+{
+    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
+    t_Error                     err;
+    uint8_t                     *p_WholeHmct= NULL, *p_ShadowHmct= NULL, *p_Hmtd = NULL;
+    t_List                      lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
+    t_CcNodeInformation         *p_CcNodeInfo;
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+
+    INIT_LIST(&lstOfNodeshichPointsOnCrntMdfManip);
+
+    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR) || (p_Manip->type != e_FM_PCD_MANIP_HDR))
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
+
+    ASSERT_COND(p_Manip->opcode == HMAN_OC);
+    ASSERT_COND(p_Manip->manipParams.h_NextManip == p_Manip->h_NextManip);
+    memcpy((uint8_t*)&p_Manip->manipParams, p_ManipParams, sizeof(p_Manip->manipParams));
+    p_Manip->manipParams.h_NextManip = p_Manip->h_NextManip;
+
+    /* The replacement of the HdrManip depends on the node type.*/
+    /*
+     * (1) If this is an independent node, all its owners should be updated.
+     *
+     * (2) If it is the head of a cascaded chain (it does not have a "prev" but
+     * it has a "next" and it has a "cascaded-next" indication), the next
+     * node remains unchanged, and the behavior is as in (1).
+     *
+     * (3) If it is not the head, but a part of a cascaded chain, in can be
+     * also replaced as a regular node with just one owner.
+     *
+     * (4) If it is a part of a chain implemented as a unified table, the
+     * whole table is replaced and the owners of the head node must be updated.
+     *
+     */
+    /* lock shadow */
+    if (!p_FmPcd->p_CcShadow)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
+
+    if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        return ERROR_CODE(E_BUSY);
+
+    /* this routine creates a new manip action in the CC Shadow. */
+    err = CreateManipActionShadow(p_Manip, p_ManipParams);
+    if (err)
+    {
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* If the owners list is empty (these are NOT the "owners" counter, but pointers from CC)
+     * replace only HMTD and no lcok is required. Otherwise
+     * lock the whole PCD
+     * In case 4 MANIP_IS_UNIFIED_NON_FIRST(p_Manip) - Use the head node instead. */
+    //TODO - restrict the lock if LIST >0 .
+     if (!FmPcdLockTryLockAll(p_FmPcd))
+     {
+         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+         return ERROR_CODE(E_BUSY);
+     }
+
+    p_ShadowHmct = (uint8_t*)UINT_TO_PTR((PTR_TO_UINT(p_FmPcd->p_CcShadow) + 16));
+
+    p_FirstManip = GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);//TODO GetFirstManip(p_Manip);
+    ASSERT_COND(p_FirstManip);
+
+    if (!LIST_IsEmpty(&p_FirstManip->nodesLst))
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
+
+    p_Hmtd =(uint8_t *) GetManipInfo(p_Manip, e_MANIP_HMTD);//TODO GetHmtd(p_Manip);
+    ASSERT_COND(p_Hmtd);
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+
+    LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_ShadowHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+    }
+
+    /* If LIST > 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.
+      * For each p_Hmct (from list+fixed):
+      * call Host Command to replace HMTD by a new one */
+    //TODO: Ganit
+    /* Copy shadow table to original location */
+    p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+    ASSERT_COND(p_WholeHmct);
+
+    /* re-build the HMCT n the origional location */
+    //memcpy(p_WholeHmct, p_ShadowHmct, GetHmctSize(p_Manip));
+    err = CreateManipActionBackToOrig(p_Manip, p_ManipParams);
+    if (err)
+    {
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    p_Hmtd = (uint8_t *) GetManipInfo(p_Manip, e_MANIP_HMTD);//TODO GetHmtd(p_Manip);
+    ASSERT_COND(p_Hmtd);
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,((t_FmPcd*)p_Manip->h_FmPcd));
+
+    LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_WholeHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+    }
+
+
+    ReleaseLst(&lstOfNodeshichPointsOnCrntMdfManip);
+
+    //TODO : Ganit - if locked!
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    /* unlock shadow */
+    RELEASE_LOCK(p_FmPcd->shadowLock);
+
+   return E_OK;
+}
+
 t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 {
     t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
@@ -3666,12 +4080,14 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if (p_Manip->p_InsertData)
-        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_InsertData);
-    if (p_Manip->p_UpdateData)
-        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_UpdateData);
-    if (p_Manip->p_HmcdTbl && !p_Manip->unifiedTablePtr)
-        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_HmcdTbl);
+    if (p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
+
+    if (p_Manip->h_Spinlock)
+     {
+         XX_FreeSpinlock(p_Manip->h_Spinlock);
+         p_Manip->h_Spinlock = NULL;
+     }
 
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
@@ -3687,7 +4103,7 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
 
-    switch (p_Manip->type)
+    switch (p_Manip->opcode)
     {
         case (HMAN_OC_IP_REASSEMBLY):
             return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
@@ -3714,7 +4130,7 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
     if (!p_Manip)
         return NULL;
 
-     switch (p_Manip->type)
+     switch (p_Manip->opcode)
      {
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
             /* Indexed statistics */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 388be01..5c6418f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -120,9 +120,9 @@
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK                   0xFF000000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT                  24
-#ifdef ALU_CUSTOM
+#ifdef FM_EXP_FEATURES
 #define FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN                   0x04000000
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
 
 #define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
 #define FM_PCD_MANIP_IPSEC_VIPV_EN                          0x08000000
@@ -209,18 +209,58 @@
 
 #define HMCD_IP_REPLACE_L3HDRSIZE_SHIFT         24
 
-#define MANIP_IS_CASCADE(h_Manip)                       (((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define DSCP_TO_VLAN_TABLE_SIZE                 32
+
 #define MANIP_GET_HMCT_SIZE(h_Manip)                    (((t_FmPcdManip *)h_Manip)->tableSize)
-#define MANIP_GET_HMCT_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
-#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)           (((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
+#define MANIP_GET_DATA_SIZE(h_Manip)                    (((t_FmPcdManip *)h_Manip)->dataSize)
+
+#define MANIP_GET_HMCT_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->p_Hmct)
+#define MANIP_GET_DATA_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->p_Data)
+
+#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)           (((t_FmPcdManip *)h_Manip)->p_Hmct = h_NewPtr)
+#define MANIP_SET_DATA_PTR(h_Manip, h_NewPtr)           (((t_FmPcdManip *)h_Manip)->p_Data = h_NewPtr)
+
 #define MANIP_GET_HMTD_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->h_Ad)
 #define MANIP_DONT_REPARSE(h_Manip)                     (((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
 #define MANIP_SET_PREV(h_Manip, h_Prev)                 (((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
 #define MANIP_GET_OWNERS(h_Manip)                       (((t_FmPcdManip *)h_Manip)->owner)
+#define MANIP_GET_TYPE(h_Manip)                         (((t_FmPcdManip *)h_Manip)->type)
 #define MANIP_SET_UNIFIED_TBL_PTR_INDICATION(h_Manip)   (((t_FmPcdManip *)h_Manip)->unifiedTablePtr = TRUE)
 #define MANIP_GET_MURAM(h_Manip)                        (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
-
-#define DSCP_TO_VLAN_TABLE_SIZE                 32
+#define MANIP_FREE_HMTD(h_Manip)                        \
+        {if(((t_FmPcdManip *)h_Manip)->muramAllocate)   \
+            FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)h_Manip)->h_Ad);\
+        else                                            \
+            XX_Free(((t_FmPcdManip *)h_Manip)->h_Ad);   \
+        ((t_FmPcdManip *)h_Manip)->h_Ad = NULL;         \
+        }
+/* position regarding Manip SW structure */
+#define MANIP_IS_FIRST(h_Manip)                         (!(((t_FmPcdManip *)h_Manip)->h_PrevManip))
+#define MANIP_IS_CASCADE_NEXT(h_Manip)                  (((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define MANIP_IS_UNIFIED(h_Manip)                       (!(((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_NONE))
+#define MANIP_IS_UNIFIED_NON_FIRST(h_Manip)             ((((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_MID) || \
+                                                         (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_LAST))
+#define MANIP_IS_UNIFIED_NON_LAST(h_Manip)              ((((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_FIRST) ||\
+                                                         (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_MID))
+#define MANIP_IS_UNIFIED_FIRST(h_Manip)                 (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_FIRST)
+#define MANIP_IS_UNIFIED_LAST(h_Manip)                  (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_LAST)
+
+#define MANIP_UPDATE_UNIFIED_POSITION(h_Manip)          (((t_FmPcdManip *)h_Manip)->unifiedPosition = \
+                                                        (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_NONE)? \
+                                                           e_MANIP_UNIFIED_LAST : e_MANIP_UNIFIED_MID)
+
+typedef enum e_ManipUnifiedPosition {
+    e_MANIP_UNIFIED_NONE = 0,
+    e_MANIP_UNIFIED_FIRST,
+    e_MANIP_UNIFIED_MID,
+    e_MANIP_UNIFIED_LAST
+} e_ManipUnifiedPosition;
+
+typedef enum e_ManipInfo {
+    e_MANIP_HMTD,
+    e_MANIP_HMCT,
+    e_MANIP_HANDLER_TABLE_OWNER
+}e_ManipInfo;
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
@@ -367,28 +407,29 @@ typedef struct t_IpReassmParams
     uint8_t                         relativeSchemeId[2];
     t_Handle                        h_Ipv4Scheme;
     t_Handle                        h_Ipv6Scheme;
+    uint32_t                        nonConsistentSpFqid;
 } t_IpReassmParams;
 
 typedef struct{
+    e_FmPcdManipType        type;
+    t_FmPcdManipParams      manipParams;
     bool                    muramAllocate;
     t_Handle                h_Ad;
-    uint32_t                type;
+    uint32_t                opcode;
     bool                    rmv;
     bool                    insrt;
     t_Handle                h_NextManip;
     t_Handle                h_PrevManip;
     /* HdrManip parameters*/
-    uint32_t                *p_HmcdTbl;
+    uint32_t                *p_Hmct;
+    uint8_t                 *p_Data;
     bool                    dontParseAfterManip;
     bool                    fieldUpdate;
     bool                    custom;
-    uint8_t                 *p_InsertData;
-    uint8_t                 *p_UpdateData;
-    uint8_t                 *p_CustomData1;
-    uint8_t                 *p_CustomData2;
     uint16_t                tableSize;
+    uint8_t                 dataSize;
     bool                    cascadedNext;
-    bool                    unifiedTablePtr;
+    e_ManipUnifiedPosition  unifiedPosition;
     /* end HdrManip */
     uint8_t                 *p_Template;
     t_Handle                h_Frag;
@@ -408,6 +449,9 @@ typedef struct{
     bool                    cnia;
     t_Handle                p_StatsTbl;
     t_Handle                h_FmPcd;
+    t_List                  nodesLst;
+    t_Handle                h_Spinlock;
+
 } t_FmPcdManip;
 
 typedef struct t_FmPcdCcSavedManipParams
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 1bf08ed..377b9f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -552,6 +552,8 @@ void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
 void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock);
 void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock);
 t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock);
+t_List *FmPcdManipGetSpinlock(t_Handle h_Manip);
+t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip);
 
 
 void NextStepAd(t_Handle                     h_Ad,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index 3dbc960..f8aa678 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -95,56 +95,65 @@
 }
 
 #else
-/* version: 106.3.8 */
+/* version: 106.3.9 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
-    0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2F,0x34,0xF5, \
-    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
-    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
-    0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3,0x29,0x8F, \
-    0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00, \
-    0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x43,0x3B,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x53,0xA2,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x55, \
-    0x00,0x00,0x30,0x7E,0x43,0x55,0x00,0x3C,0x1B,0x6F, \
+    0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x52,0xF6,0x08,0x4B,0x31,0x53,0x00,0xFB, \
+    0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
+    0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x0A,0x00, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x00, \
+    0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x53,0x09, \
+    0x00,0x00,0x00,0x00,0x9F,0x98,0x53,0x09,0x00,0x00, \
+    0x1B,0x25,0x34,0xF5,0x00,0xFB,0xFF,0xFF,0x00,0x7F, \
+    0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7,0x00,0xF9, \
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
+    0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01, \
+    0x1B,0xFE,0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00, \
+    0x00,0x00,0x00,0x00,0x53,0x3D,0x04,0x4B,0x31,0x53, \
+    0x00,0xFB,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x29,0x2B,0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00, \
+    0x00,0x00,0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA, \
+    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x47, \
+    0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA, \
+    0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0xAE, \
+    0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x61,0x00,0x00, \
+    0x30,0x7E,0x43,0x61,0x00,0x3C,0x1B,0x7B,0x32,0x11, \
+    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+    0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x5A, \
+    0x30,0x7E,0x53,0x91,0x00,0x2B,0x32,0x11,0x28,0x41, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
+    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xA5, \
+    0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41, \
+    0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
+    0x1B,0xF2,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xD6,0x00,0x2C, \
     0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
     0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
     0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
     0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
     0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0x4E,0x30,0x7E,0x53,0x85,0x00,0x2B,0x32,0x11, \
-    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
-    0x53,0x99,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x1B,0xE6,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xCA, \
-    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0xAD,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
-    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
-    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
-    0x2B,0x97,0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9, \
-    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
-    0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x01,0x1B,0xFE,                               \
+    0x1B,0xB9,0x34,0xF5,0x00,0xFB,0xFF,0xFF,0x00,0x7F, \
+    0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7,0x00,0xF9, \
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
+    0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01, \
+    0x1B,0xFE                                          \
 }
 #endif /* (DPAA_VERSION == 10) */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 5a9d36c..46a0a4d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -1981,7 +1981,7 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
 
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
-/*TODO - not atomic - it seems that port has to be disabled*/
+    /* TODO - not atomic - it seems that port has to be disabled */
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
     {
         switch (p_FmPort->portType)
@@ -2112,6 +2112,7 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
 }
 
 #if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
 t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2169,6 +2170,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
 
     return E_OK;
 }
+#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
 
 t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
@@ -3973,7 +3975,7 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
     return E_OK;
 }
 
-t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
@@ -4626,11 +4628,6 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    /*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
-             it has to be returned to the default state - initially*/
-
-    p_FmPort->requiredAction = 0;
-
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
@@ -4745,9 +4742,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
     t_FmPortPcdCcParams     fmPortPcdCcParams;
     t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-#ifdef ALU_CUSTOM
+#if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
     void                    *p_MuramPage;
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4786,12 +4785,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
             }
 
-            /* No user-tree, need to build internal tree */
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
             if (!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
+            /* No user-tree, need to build internal tree */
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
-
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
             p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
             if (!p_FmPort->h_IpReassemblyTree)
@@ -4881,9 +4879,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
-#ifdef ALU_CUSTOM
+#if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
             FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, &p_MuramPage);
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
             if ((p_FmPort->fmRevInfo.majorRev < 6) &&
@@ -5360,6 +5360,13 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg), ("fmbm_odcfg"));
+        DUMP_SUBSTRUCT_ARRAY(i, 3)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
         break;
     case (1):
         DUMP_SUBTITLE(("\n"));
@@ -5421,7 +5428,13 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdcfg);
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg), ("fmbm_rdcfg"));
+        DUMP_SUBSTRUCT_ARRAY(i, 3)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
         break;
     case (2):
 
@@ -5451,6 +5464,13 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg), ("fmbm_tdcfg"));
+        DUMP_SUBSTRUCT_ARRAY(i, 3)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tgpr);
         break;
 
    default:
@@ -5642,7 +5662,8 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     return  E_OK;
 }
 
-#ifdef ALU_CUSTOM
+#if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
 t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
 {
     t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -5657,4 +5678,5 @@ t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCo
 
     return E_OK;
 }
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 55640a2..638bb3b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -171,11 +171,12 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 /***********************************************************************/
 /*          SW parser IP-fragmentation labels (offsets)                */
 /***********************************************************************/
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
 #if (DPAA_VERSION == 10)
+#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
 #define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
 #else
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x031
+#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
+#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x047
 #endif /* (DPAA_VERSION == 10) */
 #define IP_FRAG_SW_PATCH_IPv6_LABEL             \
     (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
@@ -523,17 +524,18 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
                                                  FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW       | \
-                                                 FM_PORT_FRM_ERR_IPRE                   | \
-                                                 FM_PORT_FRM_ERR_IPFE)
+                                                 FM_PORT_FRM_ERR_IPRE)
 
 #ifdef FM_DISABLE_SEC_ERRORS
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
+                                                 FM_PORT_FRM_ERR_IPFE                   | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_NON_FM                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 
 #else
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
+                                                 FM_PORT_FRM_ERR_IPFE                   | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 #endif /* FM_DISABLE_SEC_ERRORS */
@@ -737,9 +739,9 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       Additional defines
 *//***************************************************************************/
-#ifdef ALU_CUSTOM
+#ifdef FM_EXP_FEATURES
 #define IPF_OPTIONS_COUNT_OFFSET                0x30
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
 
 typedef struct {
     t_Handle                    h_FmMuram;
@@ -884,9 +886,11 @@ typedef struct {
     t_Handle                    h_IpReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
     bool                        vspe;
     e_FmPortGprFuncType         gprFunc;
     void                        *p_MuramPage;
+#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
 
     t_FmPortDriverParam         *p_FmPortDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 6a29d6a..93f4007 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -777,6 +777,7 @@ uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
 /*          Common API for FM-Port module                            */
 /***********************************************************************/
 #if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
 typedef enum e_FmPortGprFuncType
 {
     e_FM_PORT_GPR_EMPTY = 0,
@@ -784,7 +785,8 @@ typedef enum e_FmPortGprFuncType
 } e_FmPortGprFuncType;
 
 t_Error     FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value);
-#endif /* DPAA_VERSION >= 11) */
+#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index ba40f53..feced06 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,7 +31,7 @@
  */
 
 
-/******************************************************************************
+/**************************************************************************//**
  @File          dpaa_ext.h
 
  @Description   DPAA Application Programming Interface.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 4bbd3b8..c9cf207 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 1b0d5f0..ce9ac01 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -98,7 +98,12 @@
 #define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
 #define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
                                                                              of the SW parser area */
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000240          /**< Number of bytes saved for patches */
+#else
 #define FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
+#endif /* (DPAA_VERSION >= 11) */
+
 #define FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
                                                                              the end of the SW parser area */
 #define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_OFFSET-FM_PCD_PRS_SW_TAIL_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE)
@@ -234,12 +239,17 @@ typedef struct t_FmPcdParams {
     uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition.
                                                              this parameter is relevant if 'kgSupport'=TRUE. */
     bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
-    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand' = TRUE. */
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions. */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand' = TRUE.
+                                                         */
+
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions.
+                                                         */
     t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or
-                                                             Policer profile exceptions. */
+                                                             Policer profile exceptions.
+                                                         */
     t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
-                                                             be passed by the driver upon calling the above callbacks. */
+                                                             be passed by the driver upon calling the above callbacks.
+                                                         */
     uint8_t                     partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
                                                              this parameter is relevant if 'plcrSupport'=TRUE.
                                                              NOTE: this parameter relevant only when working with multiple partitions. */
@@ -1165,7 +1175,9 @@ typedef enum e_FmPcdCcStatsMode {
     e_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
     e_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
     e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+#ifdef FM_EXP_FEATURES
     e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
+#endif /* FM_EXP_FEATURES */
 } e_FmPcdCcStatsMode;
 
 /**************************************************************************//**
@@ -1628,11 +1640,13 @@ typedef struct t_FmPcdKgSchemeParams {
 } t_FmPcdKgSchemeParams;
 
 /**************************************************************************//**
- @Collection
+ @Collection    Definitions for CC statistics
 *//***************************************************************************/
+#ifdef FM_EXP_FEATURES
 #define FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
 #define FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
-#define FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
+#endif /* FM_EXP_FEATURES */
+#define FM_PCD_CC_STATS_COUNTER_SIZE        4   /* Size in bytes of a frame length range counter */
 /* @} */
 
 /**************************************************************************//**
@@ -1728,9 +1742,11 @@ typedef struct t_FmPcdCcNextEngineParams {
         t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
 #endif /* (DPAA_VERSION >= 11) */
     } params;                                           /**< union used for all the next-engine parameters options */
+
     t_Handle                            h_Manip;        /**< Handle to Manipulation object.
                                                              Relevant if next engine is of type result
                                                              (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+
     bool                                statisticsEn;   /**< If TRUE, statistics counters are incremented
                                                              for each frame passing through this
                                                              Coarse Classification entry. */
@@ -1745,7 +1761,12 @@ typedef struct t_FmPcdCcKeyParams {
     uint8_t                     *p_Mask;    /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
                                                  pointer to the Mask per key  of the size defined
                                                  in keySize. p_Key and p_Mask (if defined) has to be
-                                                 of the same size defined in the keySize */
+                                                 of the same size defined in the keySize;
+                                                 NOTE that if this value is equal for all entries whithin
+                                                 this table, the driver will automatically use global-mask
+                                                 (i.e. one common mask for all entries) instead of private
+                                                 one; that is done in order to spare some memory and for
+                                                 better performance. */
     t_FmPcdCcNextEngineParams   ccNextEngineParams;
                                             /**< parameters for the next for the defined Key in
                                                  the p_Key */
@@ -1779,13 +1800,15 @@ typedef struct t_KeysParams {
                                                      Should be TRUE to reserve table memory for key masks, even if
                                                      initial keys do not contain masks, or if the node was initialized
                                                      as 'empty' (without keys); this will allow user to add keys with
-                                                     masks at runtime. */
+                                                     masks at runtime.
+                                                     NOTE that if user want to use only global-masks (i.e. one common mask
+                                                     for all the entries within this table, this parameter should set to 'FALSE'. */
     e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
                                                      the requested statistics mode will be allocated according to
                                                      'maxNumOfKeys'. */
+#ifdef FM_EXP_FEATURES
     uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics
-                                                     mode.
+                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics mode.
                                                      Holds a list of programmable thresholds. For each received frame,
                                                      its length in bytes is examined against these range thresholds and
                                                      the appropriate counter is incremented by 1. For example, to belong
@@ -1793,7 +1816,7 @@ typedef struct t_KeysParams {
                                                      range i-1 threshold < frame length <= range i threshold
                                                      Each range threshold must be larger then its preceding range
                                                      threshold. Last range threshold must be 0xFFFF. */
-
+#endif /* FM_EXP_FEATURES */
     uint16_t                    numOfKeys;      /**< Number of initial keys;
                                                      Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
                                                      this field should be power-of-2 of the number of bits that are
@@ -1881,12 +1904,16 @@ typedef struct t_FmPcdCcTreeParams {
                                                         /**< Parameters for each group. */
 } t_FmPcdCcTreeParams;
 
+
 /**************************************************************************//**
  @Description   CC key statistics structure
 *//***************************************************************************/
 typedef struct t_FmPcdCcKeyStatistics {
     uint32_t    byteCount;      /**< This counter reflects byte count of frames that
                                      were matched this key. */
+    uint32_t    frameCount;     /**< This counter reflects count of frames that
+                                     were matched this key. */
+#ifdef FM_EXP_FEATURES
     uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
                                 /**< These counters reflect how many frames passed that
                                      were matched this key.
@@ -1898,8 +1925,8 @@ typedef struct t_FmPcdCcKeyStatistics {
                                      For 'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME'
                                      statistics mode:
                                      The first counter holds the number of frames that
-                                     were matched to this key.
-                                   */
+                                     were matched to this key. */
+#endif /* FM_EXP_FEATURES */
 } t_FmPcdCcKeyStatistics;
 
 /**************************************************************************//**
@@ -2115,12 +2142,11 @@ typedef struct t_FmPcdManipFragIpParams {
     e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
                                                              than MTU and its DF bit is set, then this field will
                                                              determine the action to be taken.*/
-#ifdef ALU_CUSTOM
+#ifdef FM_EXP_FEATURES
     bool                        optionsCounterEn;       /**< If TRUE, A counter is incremented each time an IPv4 frame with IPv4 Options
                                                              is encountered and the COPIED flag on one of the options is cleared.
                                                              The counter is located on the port page */
-#endif /* ALU_CUSTOM */
-
+#endif /* FM_EXP_FEATURES */
 } t_FmPcdManipFragIpParams;
 
 /**************************************************************************//**
@@ -2434,6 +2460,7 @@ typedef struct t_FmPcdManipParams {
         t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
         t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
     } u;
+
     t_Handle                                h_NextManip;        /**< Handle to another (previously defined) manipulation node;
                                                                      Allows concatenation of manipulation actions;
                                                                      This parameter is optional and may be NULL. */
@@ -3354,6 +3381,20 @@ t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
 *//***************************************************************************/
 t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
 
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+
+ @Param[in]     h_ManipNode         A handle to a manipulation node.
+ @Param[out]    p_ManipParams       A structure of parameters defining the change requirement
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, t_FmPcdManipParams *p_ManipParams);
+
 #if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Function      FM_PCD_FrmReplicSetGroup
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 5add10f..8e0eba5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -137,9 +137,9 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
                                                                                     was chained to FM */
 #endif /* FM_DISABLE_SEC_ERRORS */
 
-#define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)    /**< IPR error */
-#define FM_PORT_FRM_ERR_IPR_TO                  (FM_FD_ERR_IPR_TO & ~FM_FD_IPR) /**< IPR timeout */
-#define FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                   /**< IPF error */
+#define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
+#define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
+#define FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                       /**< IPF error */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
@@ -2123,9 +2123,11 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
 *//***************************************************************************/
 t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
 
-#ifdef ALU_CUSTOM
+#if (DPAA_VERSION >= 11)
+#ifdef FM_EXP_FEATURES
 t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 
 /** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of FM_PORT_runtime_control_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index 6e8bc1e..a45f004 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index 25ceb02..d8b8488 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,7 +31,7 @@
  */
 
 
-/**
+/**************************************************************************//**
  @File          error_ext.h
 
  @Description   Error definitions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index bb5496b..39456a0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -32,7 +32,6 @@
 
 
 /**************************************************************************//**
-
  @File          list_ext.h
 
  @Description   External prototypes for list.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index 5284959..e88330c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -32,7 +32,6 @@
 
 
 /**************************************************************************//**
-
  @File          mem_ext.h
 
  @Description   External prototypes for the memory manager object
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index 59351fa..31690a4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -32,7 +32,6 @@
 
 
 /**************************************************************************//**
-
  @File          memcpy_ext.h
 
  @Description   Efficient functions for copying and setting blocks of memory.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
index 085b95c..fa7c85e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,8 +31,7 @@
  */
 
 
- /**************************************************************************//**
-
+/**************************************************************************//**
  @File          mm_ext.h
 
  @Description   Memory Manager Application Programming Interface
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index 4e34234..5ebc3e7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,12 +31,10 @@
  */
 
 
-/******************************************************************************
-
+/**************************************************************************//**
  @File          sprint_ext.h
 
  @Description   Debug routines (externals).
-
 *//***************************************************************************/
 
 #ifndef __SPRINT_EXT_H
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index e2eeca6..841be18 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,9 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
-/**
-
+/**************************************************************************//**
  @File          part_integration_ext.h
 
  @Description   P1023 external definitions and structures.
@@ -41,9 +39,6 @@
 #define __PART_INTEGRATION_EXT_H
 
 #include "std_ext.h"
-#ifndef NCSW_LINUX
-#include "ddr_std_ext.h"
-#endif
 #include "dpaa_integration_ext.h"
 
 
@@ -385,20 +380,6 @@ t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
                             uint32_t    *p_DdrDivFactor);
 
 
-/**************************************************************************//**
- @Function      P1023_GetDdrType
-
- @Description   returns the multiplication factor of the clock in for the DDR clock .
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
- @Param         p_DdrType   - (Out) returns DDR type DDR1/DDR2/DDR3.
-
- @Return        E_OK on success; Other value otherwise.
-*//***************************************************************************/
-#ifndef NCSW_LINUX
-t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
-#endif
-
 
 /** @} */ /* end of 1023_init_grp group */
 /** @} */ /* end of 1023_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index c34b731..3f0d0ad 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2009-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -225,7 +225,6 @@ typedef enum
 
 /* p4080 unique features */
 #define FM_NO_DISPATCH_RAM_ECC
-#define FM_FIFO_ALLOCATION_OLD_ALG
 #define FM_NO_WATCHDOG
 #define FM_NO_TNUM_AGING
 #define FM_KG_NO_BYPASS_FQID_GEN
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
index 7dddd5a..9519807 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,8 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
-
+/**************************************************************************//**
  @File          part_integration_ext.h
 
  @Description   P3040/P4080/P5020 external definitions and structures.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index 29df6f4..36d181a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,7 +31,7 @@
  */
 
 
- /**************************************************************************//**
+/**************************************************************************//**
  @File          ncsw_ext.h
 
  @Description   General NetCommSw Standard Definitions
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
index 9bb18f4..d91e6fd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,8 +31,7 @@
  */
 
 
- /**************************************************************************//**
-
+/**************************************************************************//**
  @File          std_ext.h
 
  @Description   General Standard Definitions
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
index 29ab09c..fd900e2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,7 +31,7 @@
  */
 
 
- /**************************************************************************//**
+/**************************************************************************//**
  @File          types_ext.h
 
  @Description   General types Standard Definitions
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
index f8b6589..72207de 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index 4a906e5..6405a2d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -944,7 +944,7 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
     /* for all other platforms: MURAM Space for fifosize=3/4 * MURAM_SIZE*/
     if(fm_precalculate_fifosizes(
         p_LnxWrpFmDev,
-        CEIL_DIV((3*FM_MURAM_SIZE-1),4))
+        44*KILOBYTE)
         != 0)
     return -EIO;
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 5de155a..c53a003 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -389,7 +389,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_plcr_byte_rate_mode_param_t) == sizeof(t_FmPcdPlcrByteRateModeParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_plcr_non_passthrough_alg_param_t) == sizeof(t_FmPcdPlcrNonPassthroughAlgParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_plcr_next_engine_params_u) == sizeof(u_FmPcdPlcrNextEngineParams));
-    /*fm_pcd_port_params_t : private */
+    /*ioc_fm_pcd_port_params_t : private */
     ASSERT_COND(sizeof(ioc_fm_pcd_plcr_profile_params_t) == sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *));
     /*ioc_fm_pcd_cc_tree_modify_next_engine_params_t : private */
 
@@ -512,7 +512,7 @@ void LnxWrpPCDIOCTLEnumChecking(void)
 
 static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg, bool compat)
 {
-    t_Error err = E_READ_FAILED;
+    t_Error err = E_OK;
 
 /*
     Status: PCD API to fmlib (file: drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h):
@@ -554,7 +554,7 @@ Status: not exported
 
 Status: feature not supported
 #ifdef FM_CAPWAP_SUPPORT
-#error unsported feature
+#error unsupported feature
     FM_PCD_StatisticsSetNode
 #endif
 
@@ -598,7 +598,7 @@ Status: feature not supported
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_fm_pcd_prs_sw(compat_param, param, COMPAT_US_TO_K);
@@ -612,28 +612,28 @@ Status: feature not supported
                             sizeof(ioc_fm_pcd_prs_sw_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
             if (!param->p_code || !param->size)
             {
                 XX_Free(param);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             p_code = (uint8_t *) XX_Malloc(param->size);
             if (!p_code)
             {
                 XX_Free(param);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             memset(p_code, 0, param->size);
             if (copy_from_user(p_code, param->p_code, param->size)) {
                 XX_Free(p_code);
                 XX_Free(param);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             param->p_code = p_code;
@@ -692,7 +692,7 @@ Status: feature not supported
                                     sizeof(ioc_fm_pcd_exception_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
             else
@@ -702,7 +702,7 @@ Status: feature not supported
                                     sizeof(ioc_fm_pcd_exception_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -750,7 +750,7 @@ Status: feature not supported
                                     sizeof(ioc_fm_pcd_kg_dflt_value_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
             else
@@ -760,7 +760,7 @@ Status: feature not supported
                                     sizeof(ioc_fm_pcd_kg_dflt_value_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -771,9 +771,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT:
+        case FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT:
 #endif
-        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS:
+        case FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET:
         {
             ioc_fm_pcd_net_env_params_t  *param;
 
@@ -802,7 +802,7 @@ Status: feature not supported
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_net_env(compat_param, param, COMPAT_US_TO_K);
@@ -815,12 +815,21 @@ Status: feature not supported
                             sizeof(ioc_fm_pcd_net_env_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
             param->id = FM_PCD_NetEnvCharacteristicsSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
 
+            if (!param->id) {
+                XX_Free(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -837,18 +846,20 @@ Status: feature not supported
                 memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_net_env_params_t));
                 compat_copy_fm_pcd_net_env(compat_param, param, COMPAT_K_TO_US);
 
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_net_env_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_net_env_params_t *)arg, param, sizeof(ioc_fm_pcd_net_env_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_net_env_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_net_env_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             XX_Free(param);
@@ -856,9 +867,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT:
+        case FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS:
+        case FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -885,9 +896,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_KG_SET_SCHEME_COMPAT:
+        case FM_PCD_IOC_KG_SCHEME_SET_COMPAT:
 #endif
-        case FM_PCD_IOC_KG_SET_SCHEME:
+        case FM_PCD_IOC_KG_SCHEME_SET:
         {
             ioc_fm_pcd_kg_scheme_params_t *param;
 
@@ -917,7 +928,7 @@ Status: feature not supported
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_kg_scheme(compat_param, param, COMPAT_US_TO_K);
@@ -931,12 +942,21 @@ Status: feature not supported
                             sizeof(ioc_fm_pcd_kg_scheme_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
             param->id = FM_PCD_KgSchemeSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
 
+            if (!param->id) {
+                XX_Free(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -952,20 +972,20 @@ Status: feature not supported
 
                 memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
                 compat_copy_fm_pcd_kg_scheme(compat_param, param, COMPAT_K_TO_US);
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_kg_scheme_params_t *)compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_kg_scheme_params_t *)compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_kg_scheme_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_kg_scheme_params_t *)arg,
+                if (copy_to_user((ioc_fm_pcd_kg_scheme_params_t *)arg,
                             param,
                             sizeof(ioc_fm_pcd_kg_scheme_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
             }
 
             XX_Free(param);
@@ -973,9 +993,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_KG_DEL_SCHEME_COMPAT:
+        case FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_KG_DEL_SCHEME:
+        case FM_PCD_IOC_KG_SCHEME_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -1046,7 +1066,7 @@ Status: feature not supported
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node(compat_param, param, COMPAT_US_TO_K);
@@ -1059,7 +1079,7 @@ Status: feature not supported
                 if (copy_from_user(param, (ioc_fm_pcd_cc_node_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1083,7 +1103,7 @@ Status: feature not supported
                                     param->keys_params.key_size))
                         {
                             XX_Free(param);
-                            RETURN_ERROR(MINOR, err, NO_MSG);
+                            RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                         }
 
                         param->keys_params.key_params[i].p_key = &keys[k];
@@ -1096,7 +1116,7 @@ Status: feature not supported
                                     param->keys_params.key_size))
                         {
                             XX_Free(param);
-                            RETURN_ERROR(MINOR, err, NO_MSG);
+                            RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                         }
 
                         param->keys_params.key_params[i].p_mask = &masks[k];
@@ -1106,6 +1126,15 @@ Status: feature not supported
 
             param->id = FM_PCD_MatchTableSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
 
+            if (!param->id) {
+                XX_Free(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1123,18 +1152,20 @@ Status: feature not supported
                         2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
                 compat_copy_fm_pcd_cc_node(compat_param, param, COMPAT_K_TO_US);
 
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_node_params_t *)compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_cc_node_params_t *)compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_cc_node_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_cc_node_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_node_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_cc_node_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_cc_node_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             XX_Free(param);
@@ -1142,9 +1173,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_DELETE_NODE_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_DELETE_NODE:
+        case FM_PCD_IOC_MATCH_TABLE_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -1171,9 +1202,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_BUILD_TREE_COMPAT:
+        case FM_PCD_IOC_CC_ROOT_BUILD_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_BUILD_TREE:
+        case FM_PCD_IOC_CC_ROOT_BUILD:
         {
             ioc_fm_pcd_cc_tree_params_t *param;
 
@@ -1203,7 +1234,7 @@ Status: feature not supported
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_tree(compat_param, param, COMPAT_US_TO_K);
@@ -1217,12 +1248,21 @@ Status: feature not supported
                             sizeof(ioc_fm_pcd_cc_tree_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
             param->id = FM_PCD_CcRootBuild(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
 
+            if (!param->id) {
+                XX_Free(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1239,18 +1279,20 @@ Status: feature not supported
 
                 compat_copy_fm_pcd_cc_tree(compat_param, param, COMPAT_K_TO_US);
 
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_tree_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_cc_tree_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             XX_Free(param);
@@ -1258,9 +1300,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_DELETE_TREE_COMPAT:
+        case FM_PCD_IOC_CC_ROOT_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_DELETE_TREE:
+        case FM_PCD_IOC_CC_ROOT_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -1287,9 +1329,9 @@ Status: feature not supported
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT:
+        case FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT:
 #endif
-        case FM_PCD_IOC_PLCR_SET_PROFILE:
+        case FM_PCD_IOC_PLCR_PROFILE_SET:
         {
             ioc_fm_pcd_plcr_profile_params_t *param;
 
@@ -1319,7 +1361,7 @@ Status: feature not supported
                             sizeof(ioc_compat_fm_pcd_plcr_profile_params_t))) {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_plcr_profile(compat_param, param, COMPAT_US_TO_K);
@@ -1333,7 +1375,7 @@ Status: feature not supported
                                     sizeof(ioc_fm_pcd_plcr_profile_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1341,22 +1383,22 @@ Status: feature not supported
                 (((t_FmPcdPlcrProfileParams*)param)->id.newParams.profileType != e_FM_PCD_PLCR_SHARED))
             {
                 t_Handle h_Port;
-                fm_pcd_port_params_t *port_params;
+                ioc_fm_pcd_port_params_t *port_params;
 
-                port_params = (fm_pcd_port_params_t*) XX_Malloc(sizeof(fm_pcd_port_params_t));
+                port_params = (ioc_fm_pcd_port_params_t*) XX_Malloc(sizeof(ioc_fm_pcd_port_params_t));
                 if (!port_params)
                 {
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
-                memset(port_params, 0, sizeof(fm_pcd_port_params_t));
-                if (copy_from_user(port_params, (fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort,
-                            sizeof(fm_pcd_port_params_t)))
+                memset(port_params, 0, sizeof(ioc_fm_pcd_port_params_t));
+                if (copy_from_user(port_params, (ioc_fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort,
+                            sizeof(ioc_fm_pcd_port_params_t)))
                 {
                     XX_Free(port_params);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 switch(port_params->port_type)
@@ -1395,6 +1437,15 @@ invalid_port_id:
 
             param->id = FM_PCD_PlcrProfileSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
 
+            if (!param->id) {
+                XX_Free(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1410,18 +1461,20 @@ invalid_port_id:
 
                 memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_plcr_profile_params_t));
                 compat_copy_fm_pcd_plcr_profile(compat_param, param, COMPAT_K_TO_US);
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_plcr_profile_params_t *) compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_plcr_profile_params_t *) compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_plcr_profile_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_plcr_profile_params_t *)arg, param, sizeof(ioc_fm_pcd_plcr_profile_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_plcr_profile_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_plcr_profile_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             XX_Free(param);
@@ -1429,9 +1482,9 @@ invalid_port_id:
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT:
+        case FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_PLCR_DEL_PROFILE:
+        case FM_PCD_IOC_PLCR_PROFILE_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -1458,9 +1511,9 @@ invalid_port_id:
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT:
+        case FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE:
+        case FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE:
         {
             ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param;
 
@@ -1488,9 +1541,9 @@ invalid_port_id:
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_fm_pcd_cc_tree_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
@@ -1504,7 +1557,7 @@ invalid_port_id:
                             sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1518,9 +1571,9 @@ invalid_port_id:
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE:
         {
             ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
 
@@ -1548,9 +1601,9 @@ invalid_port_id:
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
@@ -1564,7 +1617,7 @@ invalid_port_id:
                             sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1577,9 +1630,9 @@ invalid_port_id:
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE:
         {
             ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
 
@@ -1607,9 +1660,9 @@ invalid_port_id:
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
                                     sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
@@ -1623,7 +1676,7 @@ invalid_port_id:
                                     sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1635,9 +1688,9 @@ invalid_port_id:
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_REMOVE_KEY:
+        case FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY:
         {
             ioc_fm_pcd_cc_node_remove_key_params_t *param;
 
@@ -1666,9 +1719,9 @@ invalid_port_id:
                             (ioc_compat_fm_pcd_cc_node_remove_key_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_remove_key_params_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 param->id = compat_ptr(compat_param->id);
@@ -1683,7 +1736,7 @@ invalid_port_id:
                             sizeof(ioc_fm_pcd_cc_node_remove_key_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1693,9 +1746,9 @@ invalid_port_id:
             break;
         }
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_ADD_KEY:
+        case FM_PCD_IOC_MATCH_TABLE_ADD_KEY:
         {
             ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
             uint8_t *p_key = NULL, *p_mask = NULL;
@@ -1725,9 +1778,9 @@ invalid_port_id:
                             (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(compat_param, param, COMPAT_US_TO_K);
@@ -1741,28 +1794,28 @@ invalid_port_id:
                                     sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
             /* copy key & mask: p_mask is optional! */
             p_key = (uint8_t *) XX_Malloc(2 * param->key_size);
             if(!p_key)
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
 
             p_mask = p_key + param->key_size;
 
             if (param->key_params.p_key && copy_from_user(p_key, param->key_params.p_key, param->key_size))
             {
                 XX_Free(p_key);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
             param->key_params.p_key = p_key;
 
             if (param->key_params.p_mask && copy_from_user(p_mask, param->key_params.p_mask,param->key_size))
             {
-                XX_Free(p_mask);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                XX_Free(p_key);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
             param->key_params.p_mask = p_mask;
 
@@ -1771,15 +1824,15 @@ invalid_port_id:
                     param->key_size,
                     (t_FmPcdCcKeyParams*)(&param->key_params));
 
+            XX_Free(p_key);
             XX_Free(param);
-            kfree(p_key);
             break;
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE:
         {
             ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
 
@@ -1799,7 +1852,6 @@ invalid_port_id:
                         sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
                 if (!compat_param)
                 {
-                    XX_Free(compat_param);
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
@@ -1811,7 +1863,7 @@ invalid_port_id:
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(compat_param, param, COMPAT_US_TO_K);
@@ -1825,7 +1877,7 @@ invalid_port_id:
                             sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -1847,37 +1899,84 @@ invalid_port_id:
             param = kmalloc(sizeof(*param), GFP_KERNEL);
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
-                /* TODO: return -ENOMEM;*/
 
             memset(param, 0, sizeof(*param)) ;
 
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                printk(KERN_WARNING "FM_PCD_IOC_HASH_TABLE_SET: compat ioctl call not implemented! \n");
-                kfree(param);
-                RETURN_ERROR(MINOR, E_INVALID_HANDLE, ("IOCTL FM PCD"));
+                ioc_compat_fm_pcd_hash_table_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_hash_table_params_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_hash_table_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_hash_table_params_t));
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_hash_table_params_t*)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_hash_table_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_hash_table(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
             }
             else
 #endif
             {
                 if (copy_from_user(param, (ioc_fm_pcd_hash_table_params_t *)arg,
                                     sizeof(ioc_fm_pcd_hash_table_params_t)))
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             param->id = FM_PCD_HashTableSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdHashTableParams *) param);
 
+            if (!param->id) {
+                kfree(param);
+                err = E_INVALID_VALUE;
+                /* Since the LLD has no errno-style error reporting,
+                   we're left here with no other option than to report
+                   a generic E_INVALID_VALUE */
+                break;
+            }
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
+                ioc_compat_fm_pcd_hash_table_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_hash_table_params_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_hash_table_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_hash_table_params_t));
+                compat_copy_fm_pcd_hash_table(compat_param, param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_hash_table_params_t*) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_hash_table_params_t)))
+                    err = E_WRITE_FAILED;
+
+                XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
-                                        param, sizeof(ioc_fm_pcd_hash_table_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_hash_table_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             kfree(param);
@@ -1898,7 +1997,7 @@ invalid_port_id:
                 ioc_compat_fm_obj_t compat_id;
 
                 if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
 
                 id.obj = compat_ptr(compat_id.obj);
             }
@@ -1921,7 +2020,6 @@ invalid_port_id:
             param = kmalloc(sizeof(*param), GFP_KERNEL);
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
-                /* TODO: return -ENOMEM;*/
 
             memset(param, 0, sizeof(*param)) ;
 
@@ -1937,7 +2035,7 @@ invalid_port_id:
             {
                 if (copy_from_user(param, (ioc_fm_pcd_hash_table_add_key_params_t *)arg,
                                     sizeof(ioc_fm_pcd_hash_table_add_key_params_t)))
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             err = FM_PCD_HashTableAddKey(param->p_hash_tbl, param->key_size, (t_FmPcdCcKeyParams  *)param->p_key_params);
@@ -1956,7 +2054,6 @@ invalid_port_id:
             param = kmalloc(sizeof(*param), GFP_KERNEL);
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
-                /* TODO: return -ENOMEM;*/
 
             memset(param, 0, sizeof(*param)) ;
 
@@ -1972,7 +2069,7 @@ invalid_port_id:
             {
                 if (copy_from_user(param, (ioc_fm_pcd_hash_table_remove_key_params_t *)arg,
                                     sizeof(ioc_fm_pcd_hash_table_remove_key_params_t)))
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             err = FM_PCD_HashTableRemoveKey(param->p_hash_tbl, param->key_size, param->p_key);
@@ -1981,9 +2078,9 @@ invalid_port_id:
             break;
         }
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT:
 #endif
-        case FM_PCD_IOC_CC_NODE_MODIFY_KEY:
+        case FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY:
         {
             ioc_fm_pcd_cc_node_modify_key_params_t  *param;
             uint8_t                                 *key  = NULL;
@@ -2015,7 +2112,7 @@ invalid_port_id:
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_copy_fm_pcd_cc_node_modify_key(compat_param, param, COMPAT_US_TO_K);
@@ -2029,7 +2126,7 @@ invalid_port_id:
                                     sizeof(ioc_fm_pcd_cc_node_modify_key_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -2051,7 +2148,7 @@ invalid_port_id:
             {
                 XX_Free(key);
                 XX_Free(param);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             param->p_key = key;
@@ -2070,9 +2167,9 @@ invalid_port_id:
                 if (copy_from_user(mask, param->p_mask, param->key_size))
                 {
                     XX_Free(mask);
-                    if (key) XX_Free(key);
+                    XX_Free(key);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 param->p_mask = mask;
@@ -2085,16 +2182,15 @@ invalid_port_id:
                     param->p_mask);
 
             if (mask) XX_Free(mask);
-            if (key)  XX_Free(key);
-
+            XX_Free(key);
             XX_Free(param);
             break;
         }
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_MANIP_SET_NODE_COMPAT:
+        case FM_PCD_IOC_MANIP_NODE_SET_COMPAT:
 #endif
-        case FM_PCD_IOC_MANIP_SET_NODE:
+        case FM_PCD_IOC_MANIP_NODE_SET:
         {
             ioc_fm_pcd_manip_params_t *param;
             uint8_t *p_data = NULL;
@@ -2128,7 +2224,7 @@ invalid_port_id:
                 {
                     XX_Free(compat_param);
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 compat_fm_pcd_manip_set_node(compat_param, param, COMPAT_US_TO_K);
@@ -2142,7 +2238,7 @@ invalid_port_id:
                                             sizeof(ioc_fm_pcd_manip_params_t)))
                 {
                     XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
             }
 
@@ -2150,20 +2246,46 @@ invalid_port_id:
                 size = param->u.hdr.insrt_params.u.generic.size;
                 p_data = (uint8_t *) kmalloc(size, GFP_KERNEL);
                 if (!p_data )
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, NO_MSG);
 
                 if (param->u.hdr.insrt_params.u.generic.p_data &&
                         copy_from_user(p_data,
                             param->u.hdr.insrt_params.u.generic.p_data, size)) {
                     XX_Free(p_data);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
                 }
 
                 param->u.hdr.insrt_params.u.generic.p_data = p_data;
             }
 
-            param->id = FM_PCD_ManipNodeSet(p_LnxWrpFmDev->h_PcdDev,
-                            (t_FmPcdManipParams *)param);
+            if (param->id) {
+                /* Security Hole: the user can pass any piece of garbage
+                   in 'param->id', and that will go straight through to the LLD,
+                   no checks being done by the wrapper! */
+                err = FM_PCD_ManipNodeReplace((t_Handle)param->id,
+                        (t_FmPcdManipParams *)param);
+                if (err) {
+                    if (p_data)
+                        kfree(p_data);
+                    XX_Free(param);
+                    break;
+                }
+            }
+            else
+            {
+                param->id = FM_PCD_ManipNodeSet(p_LnxWrpFmDev->h_PcdDev,
+                        (t_FmPcdManipParams *)param);
+                if (!param->id) {
+                    if (p_data)
+                        kfree(p_data);
+                    XX_Free(param);
+                    err = E_INVALID_VALUE;
+                    /* Since the LLD has no errno-style error reporting,
+                       we're left here with no other option than to report
+                       a generic E_INVALID_VALUE */
+                    break;
+                }
+            }
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -2182,19 +2304,19 @@ invalid_port_id:
 
                 compat_fm_pcd_manip_set_node(compat_param, param, COMPAT_K_TO_US);
 
-                if (param->id && !copy_to_user((ioc_compat_fm_pcd_manip_params_t *) compat_ptr(arg),
+                if (copy_to_user((ioc_compat_fm_pcd_manip_params_t *) compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_manip_params_t)))
-                    err = E_OK;
+                    err = E_WRITE_FAILED;
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (param->id && !copy_to_user((ioc_fm_pcd_manip_params_t *)arg,
-                                        param, sizeof(ioc_fm_pcd_manip_params_t)))
-                    err = E_OK;
+                if (copy_to_user((ioc_fm_pcd_manip_params_t *)arg,
+                            param, sizeof(ioc_fm_pcd_manip_params_t)))
+                    err = E_WRITE_FAILED;
             }
 
             if (p_data)
@@ -2204,9 +2326,9 @@ invalid_port_id:
         break;
 
 #if defined(CONFIG_COMPAT)
-        case FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT:
+        case FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT:
 #endif
-        case FM_PCD_IOC_MANIP_DELETE_NODE:
+        case FM_PCD_IOC_MANIP_NODE_DELETE:
         {
             ioc_fm_obj_t id;
 
@@ -2250,10 +2372,11 @@ invalid_port_id:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION,
                 ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
                 cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
-
-            break;
     }
 
+    if (err)
+        RETURN_ERROR(MINOR, err, ("IOCTL FM PCD"));
+
     return err;
 }
 
@@ -2306,6 +2429,7 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
             FM_GetRevision(p_LnxWrpFmDev->h_Dev, (t_FmRevisionInfo*)param);
+            /* This one never returns anything other than E_OK */
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -2834,8 +2958,8 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                                    (ioc_compat_fm_pcd_kg_scheme_select_t *) compat_ptr(arg),
                                    sizeof(ioc_compat_fm_pcd_kg_scheme_select_t)))
                 {
-                    XX_Free(param);
                     XX_Free(compat_param);
+                    XX_Free(param);
                     RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
                 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 8588765..abc2ef7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -213,8 +213,8 @@ void compat_copy_fm_pcd_plcr_profile(
         {
             param->profile_select.new_params.profile_type =
                 compat_param->profile_select.new_params.profile_type;
-            param->profile_select.new_params.p_port =
-                compat_ptr(compat_param->profile_select.new_params.p_port);
+            param->profile_select.new_params.p_fm_port =
+                compat_ptr(compat_param->profile_select.new_params.p_fm_port);
             param->profile_select.new_params.relative_profile_id =
                 compat_param->profile_select.new_params.relative_profile_id;
         }
@@ -248,8 +248,8 @@ void compat_copy_fm_pcd_plcr_profile(
         if(!param->modify){
             compat_param->profile_select.new_params.profile_type =
                 param->profile_select.new_params.profile_type;
-            compat_param->profile_select.new_params.p_port =
-                ptr_to_compat(param->profile_select.new_params.p_port);
+            compat_param->profile_select.new_params.p_fm_port =
+                ptr_to_compat(param->profile_select.new_params.p_fm_port);
             compat_param->profile_select.new_params.relative_profile_id =
                 param->profile_select.new_params.relative_profile_id;
         }
@@ -496,6 +496,36 @@ void compat_fm_pcd_cc_tree_modify_next_engine(
             compat);
 }
 
+void compat_copy_fm_pcd_hash_table(
+        ioc_compat_fm_pcd_hash_table_params_t *compat_param,
+        ioc_fm_pcd_hash_table_params_t *param,
+        uint8_t compat)
+{
+    if (compat == COMPAT_US_TO_K)
+    {
+        param-> max_num_of_keys = compat_param->max_num_of_keys;
+        param->statistics_mode  = compat_param->statistics_mode;
+        param->hash_res_mask    = compat_param->hash_res_mask;
+        param->hash_shift       = compat_param->hash_shift;
+        param->match_key_size   = compat_param->match_key_size;
+        param->id               = compat_ptr(compat_param->id);
+    }
+    else
+    {
+        compat_param-> max_num_of_keys = param->max_num_of_keys;
+        compat_param->statistics_mode  = param->statistics_mode;
+        compat_param->hash_res_mask    = param->hash_res_mask;
+        compat_param->hash_shift       = param->hash_shift;
+        compat_param->match_key_size   = param->match_key_size;
+        compat_param->id               = ptr_to_compat(param->id);
+    }
+
+    compat_copy_fm_pcd_cc_next_engine(
+            &compat_param->cc_next_engine_params_for_miss,
+            &param->cc_next_engine_params_for_miss,
+            compat);
+}
+
 void compat_copy_fm_pcd_cc_grp(
         ioc_compat_fm_pcd_cc_grp_params_t *compat_param,
         ioc_fm_pcd_cc_grp_params_t *param,
@@ -1002,20 +1032,26 @@ void compat_fm_pcd_manip_set_node(
         }
 
         if (compat_param->p_next_manip)
-            param->p_next_manip = compat_get_id2ptr(compat_param->id, FM_MAP_TYPE_PCD_NODE);
+            param->p_next_manip = compat_get_id2ptr(compat_param->p_next_manip, FM_MAP_TYPE_PCD_NODE);
+
+        if (compat_param->id)
+            param->id = compat_get_id2ptr(compat_param->id, FM_MAP_TYPE_PCD_NODE);
     }
     else {
         compat_param->type = param->type;
         memcpy(&compat_param->u, &param->u, sizeof(compat_param->u));
 
-        /* user garbage - it could break the US application! */
         if (param->type == e_IOC_FM_PCD_MANIP_HDR &&
             param->u.hdr.insrt_params.type == e_IOC_FM_PCD_MANIP_INSRT_GENERIC)
                 compat_param->u.hdr.insrt_params.u.generic.p_data =
                     ptr_to_compat(param->u.hdr.insrt_params.u.generic.p_data);
 
+        /* This one should be unnecessary, but if the LLD decided to change it,
+           then we'd be scr...eened! */
         if (param->p_next_manip)
             compat_param->p_next_manip = compat_get_ptr2id(param->id, FM_MAP_TYPE_PCD_NODE);
+            /* ... should be one that was added previously by the very call to
+               compat_add_ptr2id() below: */
 
         compat_param->id = compat_add_ptr2id(param->id, FM_MAP_TYPE_PCD_NODE);
     }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index 8b713c0..1e79dfc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -124,7 +124,7 @@ typedef struct ioc_compat_fm_pcd_plcr_profile_params_t {
     union {
         struct {
             ioc_fm_pcd_profile_type_selection   profile_type;
-            compat_uptr_t                       p_port;
+            compat_uptr_t                       p_fm_port;
             uint16_t                            relative_profile_id;
         } new_params;
         compat_uptr_t                           p_profile;
@@ -463,6 +463,11 @@ void compat_fm_pcd_cc_tree_modify_next_engine(
         ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param,
         uint8_t compat);
 
+void compat_copy_fm_pcd_hash_table(
+        ioc_compat_fm_pcd_hash_table_params_t *compat_param,
+        ioc_fm_pcd_hash_table_params_t *param,
+        uint8_t compat);
+
 void compat_copy_fm_pcd_cc_grp(
         ioc_compat_fm_pcd_cc_grp_params_t *compat_param,
         ioc_fm_pcd_cc_grp_params_t *param,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index 63ebb2c..573ef3a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -237,7 +237,6 @@ int fm_set_active_fman_ports(struct platform_device *of_dev,
 }
 #endif /*!defined(FMAN_RESOURCES_UNIT_TEST)*/
 
-#ifdef FM_FIFO_ALLOCATION_OLD_ALG
 /* BPOOL size is constant and equal w/ DPA_BP_SIZE */
 static uint32_t get_largest_buf_size(uint32_t max_rx_frame_size, uint32_t buf_size)
 {
@@ -259,7 +258,6 @@ static uint32_t get_largest_buf_size(uint32_t max_rx_frame_size, uint32_t buf_si
 	return max((uint32_t)16, CEIL_DIV(bp_size, buf_size));
 #endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
 }
-#endif
 
 /* Calculate the fifosize based on MURAM allocation, number of ports, dpde
    value and s/g software support (! Kernel does not suport s/g).
@@ -365,25 +363,26 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 			+ DPDE_10G + 3 + 1; /* +1 to handle Jumbo Frames */
 
 	{
-#ifdef FM_FIFO_ALLOCATION_OLD_ALG
-#if !defined(FMAN_RESOURCES_UNIT_TEST)
+/*
+ * On P1023RDS FM_FIFO_ALLOCATION_ALG is enabled allowing a smaller Rx FIFO
+ * on hardware major rev 4. If the Rx FIFO is smaller than the size of the
+ * buffer in the buffer pool SG frames will be received
+ */
+#if defined(FM_FIFO_ALLOCATION_ALG) && \
+	!defined(FMAN_RESOURCES_UNIT_TEST) && \
+	defined(CONFIG_DPAA_ETH_SG_SUPPORT)
 		uint8_t fm_rev_major = 0;
-		fm_rev_major =
-			(uint8_t) ((*
-				    ((volatile uint32_t *)
-				     UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr +
-						 0x000c30c4)) & 0xff00) >> 8);
+		fm_rev_major = (uint8_t) ((*
+				((volatile uint32_t *)
+					UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr +
+						0x000c30c4)) & 0xff00) >> 8);
 
-		if (fm_rev_major < 4)
-#else
-		if(1)
-#endif
-			min_rx_bufs =
-				get_largest_buf_size(max_frame_size,
-						     buf_size) + 7;
+		if (fm_rev_major == 4)
+			min_rx_bufs = 8;
 		else
 #endif
-			min_rx_bufs = 8;
+			min_rx_bufs = get_largest_buf_size(max_frame_size,
+							buf_size) + 7;
 	}
 
 	shared_ext_buff = num_10g_ports ? 32 : 16; /* LLD boundaries:
@@ -403,7 +402,7 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 
 	if (remaining_bufs < 0) {
 		printk(KERN_ALERT
-		       "This configuration will not work due to low number of"
+		       "\nThis configuration will not work due to low number of"
 			" buffers (%u buffers)...\n",
 		       total_no_buffers);
 		err = -1;
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index cdf870a..f4e7249 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -1370,9 +1370,9 @@ typedef struct ioc_keys_params_t {
                                                      masks at runtime. */
     ioc_fm_pcd_cc_stats_mode    statistics_mode;/**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for
                                                      the requested statistics mode will be allocated according to 'max_num_of_keys'. */
+#ifdef FM_EXP_FEATURES
     uint16_t                    frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'e_IOC_FM_PCD_CC_STATS_MODE_RMON' statistics
-                                                     mode.
+                                                /**< Relevant only for 'e_IOC_FM_PCD_CC_STATS_MODE_RMON' statistics mode.
                                                      Holds a list of programmable thresholds. For each received frame,
                                                      its length in bytes is examined against these range thresholds and
                                                      the appropriate counter is incremented by 1. For example, to belong
@@ -1380,6 +1380,7 @@ typedef struct ioc_keys_params_t {
                                                      range i-1 threshold < frame length <= range i threshold
                                                      Each range threshold must be larger then its preceding range
                                                      threshold. Last range threshold must be 0xFFFF. */
+#endif /* FM_EXP_FEATURES */
     uint16_t                    num_of_keys;    /**< Number of initial keys;
                                                      Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
                                                      this field should be power-of-2 of the number of bits that are
@@ -1513,10 +1514,10 @@ typedef union ioc_fm_pcd_plcr_next_engine_params_u {
         void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
 } ioc_fm_pcd_plcr_next_engine_params_u;
 
-typedef struct fm_pcd_port_params_t {
+typedef struct ioc_fm_pcd_port_params_t {
     ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
     uint8_t                             port_id;            /**< FM-Port id of port for this profile */
-} fm_pcd_port_params_t;
+} ioc_fm_pcd_port_params_t;
 
 /**************************************************************************//**
  @Description   Parameters for defining the policer profile entry
@@ -1527,7 +1528,7 @@ typedef struct ioc_fm_pcd_plcr_profile_params_t {
     union {
         struct {
             ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
-            void                               *p_port;                     /**< Relevant for per-port profiles only */
+            ioc_fm_pcd_port_params_t            *p_fm_port;                 /**< Relevant for per-port profiles only */
             uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
         } new_params;                                                       /**< Use it when modify = FALSE */
         void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
@@ -1676,11 +1677,11 @@ typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
     ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;    /**< Dont Fragment Action - If an IP packet is larger
                                                                  than MTU and its DF bit is set, then this field will
                                                                  determine the action to be taken.*/
-#ifdef ALU_CUSTOM
+#ifdef FM_EXP_FEATURES
     bool                        options_counter_en;         /**< If TRUE, A counter is incremented each time an IPv4 frame with IPv4 Options
                                                                  is encountered and the COPIED flag on one of the options is cleared.
                                                                  The counter is located on the port page */
-#endif /* ALU_CUSTOM */
+#endif /* FM_EXP_FEATURES */
 } ioc_fm_pcd_manip_frag_ip_params_t;
 
 /**************************************************************************//**
@@ -1997,9 +1998,9 @@ typedef struct ioc_fm_pcd_manip_params_t {
         ioc_fm_pcd_manip_frag_params_t              frag;   /**< Parameters for defining fragmentation manipulation node */
         ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
     } u;
-    void*                                           p_next_manip;/**< Handle to another (previously defined) manipulation node;
-                                                                      Allows concatenation of manipulation actions
-                                                                      This parameter is optional and may be NULL. */
+    void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
+                                                                 Allows concatenation of manipulation actions
+                                                                 This parameter is optional and may be NULL. */
 #ifdef FM_CAPWAP_SUPPORT
 #error "FM_CAPWAP_SUPPORT feature not supported!"
     bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
@@ -2129,11 +2130,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT   FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
-
 #endif
 #define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
 
 /**************************************************************************//**
  @Function      FM_PCD_NetEnvCharacteristicsDelete
@@ -2146,10 +2144,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS   FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
 
 /**************************************************************************//**
  @Function      FM_PCD_KgSchemeSet
@@ -2167,10 +2163,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_KG_SCHEME_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
-#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT     FM_PCD_IOC_KG_SCHEME_SET_COMPAT
 #endif
 #define FM_PCD_IOC_KG_SCHEME_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
-#define FM_PCD_IOC_KG_SET_SCHEME    FM_PCD_IOC_KG_SCHEME_SET
 
 /**************************************************************************//**
  @Function      FM_PCD_KgSchemeDelete
@@ -2183,10 +2177,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT     FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_KG_SCHEME_DELETE     _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
-#define FM_PCD_IOC_KG_DEL_SCHEME        FM_PCD_IOC_KG_SCHEME_DELETE
 
 /**************************************************************************//**
  @Function      FM_PCD_CcRootBuild
@@ -2203,11 +2195,9 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 #if defined(CONFIG_COMPAT)
 //#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_compat_fm_pcd_cc_tree_params_t)
 #define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
-#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
 #endif
 //#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
 #define FM_PCD_IOC_CC_ROOT_BUILD    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
-#define FM_PCD_IOC_CC_BUILD_TREE    FM_PCD_IOC_CC_ROOT_BUILD
 
 /**************************************************************************//**
  @Function      FM_PCD_CcRootDelete
@@ -2218,10 +2208,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT    FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_CC_ROOT_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
-#define FM_PCD_IOC_CC_DELETE_TREE    FM_PCD_IOC_CC_ROOT_DELETE
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableSet
@@ -2251,10 +2239,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
-#define FM_PCD_IOC_CC_DELETE_NODE       FM_PCD_IOC_MATCH_TABLE_DELETE
 
 /**************************************************************************//**
  @Function      FM_PCD_CcRootModifyNextEngine
@@ -2269,10 +2255,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT    FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
 #endif
 #define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyNextEngine
@@ -2287,10 +2271,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT       FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE       FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyMissNextEngine
@@ -2305,10 +2287,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT      FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE      FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableRemoveKey
@@ -2325,10 +2305,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY       FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableAddKey
@@ -2348,11 +2326,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_ADD_KEY      FM_PCD_IOC_MATCH_TABLE_ADD_KEY
-
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
@@ -2368,10 +2343,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT        FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE       FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyKey
@@ -2387,10 +2360,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT        FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
 #endif
 #define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY       FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
 
 /**************************************************************************//**
  @Function      FM_PCD_HashTableSet
@@ -2486,11 +2457,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
-#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
 #endif
 #define FM_PCD_IOC_PLCR_PROFILE_SET     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
-#define FM_PCD_IOC_PLCR_SET_PROFILE     FM_PCD_IOC_PLCR_PROFILE_SET
-
 
 /**************************************************************************//**
  @Function      FM_PCD_PlcrProfileDelete
@@ -2504,10 +2472,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_fm_obj_t)
-#define FM_PCD_IOC_PLCR_DEL_PROFILE     FM_PCD_IOC_PLCR_PROFILE_DELETE
 
 /**************************************************************************//**
  @Function      FM_PCD_ManipNodeSet
@@ -2522,11 +2488,28 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MANIP_NODE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
-#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
 #endif
 #define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
-#define FM_PCD_IOC_MANIP_SET_NODE   FM_PCD_IOC_MANIP_NODE_SET
 
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+                (Here, it's implemented as a variant of the same IOCTL as for
+                FM_PCD_ManipNodeSet(), and one that when called, the 'id' member
+                in its 'ioc_fm_pcd_manip_params_t' argument is set to contain
+                the manip node's handle)
+
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_REPLACE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#endif
+#define FM_PCD_IOC_MANIP_NODE_REPLACE           FM_PCD_IOC_MANIP_NODE_SET
 
 /**************************************************************************//**
  @Function      FM_PCD_ManipNodeDelete
@@ -2541,10 +2524,8 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
-#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
 #endif
 #define FM_PCD_IOC_MANIP_NODE_DELETE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
-#define FM_PCD_IOC_MANIP_DELETE_NODE    FM_PCD_IOC_MANIP_NODE_DELETE
 
 /**************************************************************************//**
 @Function      FM_PCD_SetAdvancedOffloadSupport
@@ -2578,6 +2559,56 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 
 #endif /* FM_CAPWAP_SUPPORT */
 
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
+#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_SET_COMPAT
+#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
+#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT         FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
+#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT        FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
+#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT        FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT     FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
+#endif
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
+#define FM_PCD_IOC_KG_SET_SCHEME                FM_PCD_IOC_KG_SCHEME_SET
+#define FM_PCD_IOC_KG_DEL_SCHEME                FM_PCD_IOC_KG_SCHEME_DELETE
+#define FM_PCD_IOC_CC_BUILD_TREE                FM_PCD_IOC_CC_ROOT_BUILD
+#define FM_PCD_IOC_CC_DELETE_TREE               FM_PCD_IOC_CC_ROOT_DELETE
+#define FM_PCD_IOC_CC_DELETE_NODE               FM_PCD_IOC_MATCH_TABLE_DELETE
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY           FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
+#define FM_PCD_IOC_CC_NODE_ADD_KEY              FM_PCD_IOC_MATCH_TABLE_ADD_KEY
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY           FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
+#define FM_PCD_IOC_PLCR_SET_PROFILE             FM_PCD_IOC_PLCR_PROFILE_SET
+#define FM_PCD_IOC_PLCR_DEL_PROFILE             FM_PCD_IOC_PLCR_PROFILE_DELETE
+#define FM_PCD_IOC_MANIP_SET_NODE               FM_PCD_IOC_MANIP_NODE_SET
+#define FM_PCD_IOC_MANIP_DELETE_NODE            FM_PCD_IOC_MANIP_NODE_DELETE
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
 #endif /* __FM_PCD_IOCTLS_H */
 /** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
-- 
1.7.9.7

