From 49881fae1dfdf0df39d76c9f07122ef80d2182d3 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 29 Aug 2012 15:01:18 +0000
Subject: [PATCH 095/162] gianfar: Add support for nfc rx-flow hashing based
 on SPI

Program the filer to perform hashing based on SPI (Secutity Parameter
Index) for AH/ESP packets. The aim is to speed up processing of IPSEC flows
on veTSEC controllers, by distributing their processing to separate cores.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball. Just minor
context mods in order to port to 3.4 kernel.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.h         |    8 ++++
 drivers/net/ethernet/freescale/gianfar_ethtool.c |   46 ++++++++++++++++++++++
 2 files changed, 54 insertions(+)

diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index b8e440b..47f34f6 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -561,6 +561,14 @@ extern const char gfar_driver_version[];
 #define RQFPR_PER		0x00000002
 #define RQFPR_EER		0x00000001
 
+/* RBIFX B[x]CTL field values  */
+#define RBIFX_B_NONE		0x0
+#define RBIFX_B_BEFORE_L2	0x1
+#define RBIFX_B_AFTER_L2	0x2
+#define RBIFX_B_AFTER_L3	0x3
+/* BCTL field offset */
+#define RBIFX_BCTL_OFF		6
+
 /* TxBD status field bits */
 #define TXBD_READY		0x8000
 #define TXBD_PADCRC		0x4000
diff --git a/drivers/net/ethernet/freescale/gianfar_ethtool.c b/drivers/net/ethernet/freescale/gianfar_ethtool.c
index 59f4c2f..2f562db 100644
--- a/drivers/net/ethernet/freescale/gianfar_ethtool.c
+++ b/drivers/net/ethernet/freescale/gianfar_ethtool.c
@@ -42,6 +42,7 @@
 #include <linux/phy.h>
 #include <linux/sort.h>
 #include <linux/if_vlan.h>
+#include <linux/in.h>
 
 #include "gianfar.h"
 
@@ -631,6 +632,9 @@ static int gfar_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 static void ethflow_to_filer_rules (struct gfar_private *priv, u64 ethflow)
 {
 	u32 fcr = 0x0, fpr = FPR_FILER_MASK;
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 class = upper_32_bits(ethflow);
+	int i;
 
 	if (ethflow & RXH_L2DA) {
 		fcr = RQFCR_PID_DAH |RQFCR_CMP_NOMATCH |
@@ -701,6 +705,43 @@ static void ethflow_to_filer_rules (struct gfar_private *priv, u64 ethflow)
 		gfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);
 		priv->cur_filer_idx = priv->cur_filer_idx - 1;
 	}
+
+	if (((class == AH_V4_FLOW) || (class == ESP_V4_FLOW)) &&
+		(ethflow & RXH_AH_ESP_SPI)) {
+		u8 rbifx_bx, spi_off;
+		u32 rbifx;
+
+		fcr = RQFCR_PID_ARB | RQFCR_HASH | RQFCR_HASHTBL_0 |
+			RQFCR_CMP_NOMATCH | RQFCR_AND;
+		priv->ftp_rqfpr[priv->cur_filer_idx] = fpr;
+		priv->ftp_rqfcr[priv->cur_filer_idx] = fcr;
+		gfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);
+		priv->cur_filer_idx = priv->cur_filer_idx - 1;
+
+		fcr = RQFCR_PID_L4P | RQFCR_CMP_EXACT | RQFCR_AND;
+		fpr = (class == AH_V4_FLOW) ? IPPROTO_AH : IPPROTO_ESP;
+		priv->ftp_rqfpr[priv->cur_filer_idx] = fpr;
+		priv->ftp_rqfcr[priv->cur_filer_idx] = fcr;
+		gfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);
+		priv->cur_filer_idx = priv->cur_filer_idx - 1;
+
+		/* SPI field to be extracted starting from offset 4 for AH,
+		 * or offset 0 for ESP, just after the L3 header
+		 */
+		spi_off = (class == AH_V4_FLOW) ? 4 : 0;
+		/* configure RBIFX's B0 field */
+		rbifx_bx = RBIFX_B_AFTER_L3 << RBIFX_BCTL_OFF;
+		rbifx_bx |= spi_off;
+		rbifx = rbifx_bx;
+		/* configure the next 3 bytes (B1, B2, B3) */
+		for (i = 1; i < 4; i++) {
+			rbifx_bx++; /* next SPI byte offset */
+			rbifx <<= 8;
+			rbifx |= rbifx_bx;
+		}
+
+		gfar_write(&regs->rbifx, rbifx);
+	}
 }
 
 static int gfar_ethflow_to_filer_table(struct gfar_private *priv, u64 ethflow, u64 class)
@@ -736,6 +777,11 @@ static int gfar_ethflow_to_filer_table(struct gfar_private *priv, u64 ethflow, u
 	case UDP_V6_FLOW:
 		cmp_rqfpr = RQFPR_IPV6 |RQFPR_UDP;
 		break;
+	case AH_V4_FLOW:
+	case ESP_V4_FLOW:
+		cmp_rqfpr = RQFPR_IPV4;
+		ethflow |= (class << 32);
+		break;
 	default:
 		pr_err("Right now this class is not supported\n");
 		ret = 0;
-- 
1.7.9.7

