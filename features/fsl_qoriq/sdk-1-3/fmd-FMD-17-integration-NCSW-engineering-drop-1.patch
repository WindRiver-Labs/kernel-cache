From 20e8ddb3c0865fa07e917fb33b288cfbdfa868bd Mon Sep 17 00:00:00 2001
From: Stefan Szabo <szbs001@freescale.com>
Date: Mon, 2 Jul 2012 17:58:27 +0300
Subject: [PATCH 073/162] fmd: FMD 17 integration (NCSW engineering drop #1)

- Added LLD *_ext.h headers;
- Added LLD sources;
- Sync'ed *ioctls.h, *_integration_ext.h, lnxwrp_ioctls_fm_compat.h
- Removed #ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
  (IP Reass. & Frag. support is now included unconditionally on all platforms)
- Removed #ifdef FM_QMI_DEQ_OPTIONS_SUPPORT (deprecated from NCSW)

Signed-off-by: Stefan Szabo <szbs001@freescale.com>
Signed-off-by: Madalin Bucur <B32716@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |   58 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |   20 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |    4 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |   55 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       | 1939 ++++++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |  118 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       | 3268 ++++++++++---------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 1353 +++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   23 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  598 ++--
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |   49 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   84 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     | 1504 +++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |  252 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |  117 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  730 +++--
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   59 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |    8 +-
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |   43 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    | 3321 +++++++++++---------
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   59 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |   44 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |   86 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |    7 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |  301 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |    3 +
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  524 ++-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  156 +-
 .../inc/integrations/P1023/dpaa_integration_ext.h  |    1 +
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |    3 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c     |    2 -
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |   40 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |   10 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |   72 +-
 include/linux/fmd/Peripherals/fm_ioctls.h          |  111 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      | 1720 ++++++----
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |  517 +--
 include/linux/fmd/net_ioctls.h                     |   43 +-
 38 files changed, 9871 insertions(+), 7431 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index 376b996..58d4075 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -69,10 +69,10 @@
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFFE00
 #endif /* (DPAA_VERSION == 10) */
 
-#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
+#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
-#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdPlcrInterModuleProfileRegs))
-#define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
+#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgSchemeRegs)+sizeof(t_FmPcdPlcrProfileRegs))
+#define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrProfileRegs)+sizeof(uint32_t))
 #define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
 
 #define BUILD_FD(len)                     \
@@ -99,9 +99,9 @@ typedef _Packed struct t_HcFrame {
     volatile uint32_t                           extraReg;
     volatile uint32_t                           commandSequence;
     union {
-        t_FmPcdKgInterModuleSchemeRegs          schemeRegs;
-        t_FmPcdKgInterModuleSchemeRegs          schemeRegsWithoutCounter;
-        t_FmPcdPlcrInterModuleProfileRegs       profileRegs;
+        t_FmPcdKgSchemeRegs                     schemeRegs;
+        t_FmPcdKgSchemeRegs                     schemeRegsWithoutCounter;
+        t_FmPcdPlcrProfileRegs                  profileRegs;
         volatile uint32_t                       singleRegForWrite;    /* for writing SP, CPP, profile counter */
         t_FmPcdKgPortRegs                       portRegsForRead;
         volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
@@ -284,11 +284,13 @@ void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 }
 
-t_Error FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_SchemeParams)
+t_Error FmHcPcdKgSetScheme(t_Handle             h_FmHc,
+                           t_Handle             h_Scheme,
+                           t_FmPcdKgSchemeRegs  *p_SchemeRegs,
+                           bool                 updateCounter)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
-    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
     uint8_t                             physicalSchemeId, relativeSchemeId;
@@ -300,24 +302,17 @@ t_Error FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemePa
     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
 
-    err = FmPcdKgBuildScheme(h_Scheme, p_SchemeParams, &schemeRegs);
-    if(err)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_SchemeParams->schemeCounter.update);
+    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, updateCounter);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
-    memcpy(&p_HcFrame->hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
-    if(!p_SchemeParams->schemeCounter.update)
+    memcpy(&p_HcFrame->hcSpecificData.schemeRegs, p_SchemeRegs, sizeof(t_FmPcdKgSchemeRegs));
+    if (!updateCounter)
     {
-        p_HcFrame->hcSpecificData.schemeRegs.kgse_dv0   = schemeRegs.kgse_dv0;
-        p_HcFrame->hcSpecificData.schemeRegs.kgse_dv1   = schemeRegs.kgse_dv1;
-        p_HcFrame->hcSpecificData.schemeRegs.kgse_ccbs  = schemeRegs.kgse_ccbs;
-        p_HcFrame->hcSpecificData.schemeRegs.kgse_mv    = schemeRegs.kgse_mv;
+        p_HcFrame->hcSpecificData.schemeRegs.kgse_dv0   = p_SchemeRegs->kgse_dv0;
+        p_HcFrame->hcSpecificData.schemeRegs.kgse_dv1   = p_SchemeRegs->kgse_dv1;
+        p_HcFrame->hcSpecificData.schemeRegs.kgse_ccbs  = p_SchemeRegs->kgse_ccbs;
+        p_HcFrame->hcSpecificData.schemeRegs.kgse_mv    = p_SchemeRegs->kgse_mv;
     }
 
     BUILD_FD(sizeof(t_HcFrame));
@@ -349,7 +344,7 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
-    memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgSchemeRegs));
 
     BUILD_FD(sizeof(t_HcFrame));
 
@@ -811,36 +806,25 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
     return E_OK;
 }
 
-t_Error FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams)
+t_Error FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileRegs *p_PlcrRegs)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
     t_Error                             err = E_OK;
     uint16_t                            profileIndx;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
 
-
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     profileIndx = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
 
-    memset(&profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
-
-    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_ProfileParams, &profileRegs);
-    if(err)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
     p_HcFrame->extraReg = 0x00008000;
-    memcpy(&p_HcFrame->hcSpecificData.profileRegs, &profileRegs, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+    memcpy(&p_HcFrame->hcSpecificData.profileRegs, p_PlcrRegs, sizeof(t_FmPcdPlcrProfileRegs));
 
     BUILD_FD(sizeof(t_HcFrame));
 
@@ -871,7 +855,7 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
     p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     p_HcFrame->actionReg  |= 0x00008000;
     p_HcFrame->extraReg = 0x00008000;
-    memset(&p_HcFrame->hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+    memset(&p_HcFrame->hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrProfileRegs));
 
     BUILD_FD(sizeof(t_HcFrame));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 79c5a53..dce1fb1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -472,7 +472,7 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 
     ASSERT_COND(p_Dtsec);
 
-    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
     ASSERT_COND(p_MemMap);
 
     /* Assert the graceful transmit stop bit */
@@ -481,22 +481,23 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
                      GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
 
 #ifdef FM_GRS_ERRATA_DTSEC_A002
-    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         XX_UDelay(100);
 #endif /* FM_GRS_ERRATA_DTSEC_A002 */
 
     if (mode & e_COMM_MODE_TX)
 #if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
-    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
 #else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
 #ifdef FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
-    if((p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2) || (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 5))
+    if ((p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2) ||
+        (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 5))
         DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
 #else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
         WRITE_UINT32(p_MemMap->tctrl,
                      GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
-#endif
+#endif /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
 #endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
 
     return E_OK;
@@ -716,8 +717,8 @@ static t_Error DtsecSetTxPauseFrames(t_Handle h_Dtsec,
                                      uint16_t threshTime)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    uint32_t        ptv = 0;
     t_DtsecMemMap   *p_MemMap;
+    uint32_t        ptv = 0;
 
 UNUSED(priority);UNUSED(threshTime);
 
@@ -730,7 +731,7 @@ UNUSED(priority);UNUSED(threshTime);
     if (pauseTime)
     {
 #ifdef FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
-        if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
             if (pauseTime <= 320)
                 RETURN_ERROR(MINOR, E_INVALID_VALUE,
                              ("This pause-time value of %d is illegal due to errata dTSEC-A003!"
@@ -1462,6 +1463,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
+
+    FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &p_Dtsec->fmMacControllerDriver.fmRevInfo);
 
     CHECK_INIT_PARAMETERS(p_Dtsec, CheckInitParameters);
 
@@ -1704,8 +1708,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
                            e_FM_MAC_1G,
                            p_Dtsec->fmMacControllerDriver.macId,
                            p_DtsecDriverParam->maxFrameLength);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
     /***************MAXFRM************************/
 
     /***************CAM1************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index b252456..d8a7f83 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -409,7 +409,9 @@ t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statistic
 
     if (p_FmMacControllerDriver->f_FM_MAC_SetStatistics)
         return p_FmMacControllerDriver->f_FM_MAC_SetStatistics(h_FmMac, statisticsLevel);
-
+#if (DPAA_VERSION >= 11)
+    return E_OK;
+#endif
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 72c6d52..c83d1e2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -55,20 +55,21 @@
 
 static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
 {
-    if(ENET_SPEED_FROM_MODE(p_Tgec->enetMode) < e_ENET_SPEED_10000)
+    if (ENET_SPEED_FROM_MODE(p_Tgec->enetMode) < e_ENET_SPEED_10000)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
 #if (FM_MAX_NUM_OF_10G_MACS > 0)
-    if(p_Tgec->macId >= FM_MAX_NUM_OF_10G_MACS)
+    if (p_Tgec->macId >= FM_MAX_NUM_OF_10G_MACS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10G can not be greater than 0"));
-#endif
-    if(p_Tgec->addr == 0)
+#endif /* (FM_MAX_NUM_OF_10G_MACS > 0) */
+
+    if (p_Tgec->addr == 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
-    if(!p_Tgec->f_Exception)
+    if (!p_Tgec->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Exception"));
-    if(!p_Tgec->f_Event)
+    if (!p_Tgec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-    if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
+    if (!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
 
@@ -622,31 +623,29 @@ static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
 
 static t_Error TgecResetCounters (t_Handle h_Tgec)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap       *p_MemMap ;
-    uint32_t            tmpReg32, cmdConfCtrl;
-    int i;
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_MemMap;
+    uint32_t        tmpReg32;
+    int             i = 1000;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
 
-    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    cmdConfCtrl = GET_UINT32(p_MemMap->command_config);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
 
-    cmdConfCtrl |= CMD_CFG_STAT_CLR;
+    tmpReg32 |= CMD_CFG_STAT_CLR;
 
-    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
-    for (i=0; i<1000; i++)
-    {
-        tmpReg32 = GET_UINT32(p_MemMap->command_config);
-        if (!(tmpReg32 & CMD_CFG_STAT_CLR))
-            break;
-    }
+    while (--i && (GET_UINT32(p_MemMap->command_config) & CMD_CFG_STAT_CLR));
+
+    if (!i)
+        return E_TIMEOUT;
 
-    cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
-    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
+    tmpReg32 &= ~CMD_CFG_STAT_CLR;
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -972,9 +971,12 @@ static t_Error TgecInit(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
 
     FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &p_Tgec->fmMacControllerDriver.fmRevInfo);
 
+    CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
+
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
     {
@@ -987,8 +989,6 @@ static t_Error TgecInit(t_Handle h_Tgec)
     }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-    CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
-
     p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
     p_MemMap = p_Tgec->p_MemMap;
 
@@ -1046,11 +1046,6 @@ static t_Error TgecInit(t_Handle h_Tgec)
                            e_FM_MAC_10G,
                            p_Tgec->fmMacControllerDriver.macId,
                            p_TgecDriverParam->maxFrameLength);
-    if (err)
-    {
-        FreeInitResources(p_Tgec);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
 
     /* Pause Time */
     WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 4ac056f..4e5c65e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -84,7 +84,7 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    if(add)
+    if (add)
         p_CcNode->owners++;
     else
     {
@@ -95,7 +95,163 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 }
 
+static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
+{
+    t_FmPcdStatsObj  *p_StatsObj = NULL;
+    t_List           *p_Next;
+
+    if (!LIST_IsEmpty(p_List))
+    {
+        p_Next = LIST_FIRST(p_List);
+        p_StatsObj = LIST_OBJECT(p_Next, t_FmPcdStatsObj, node);
+        ASSERT_COND(p_StatsObj);
+        LIST_DelAndInit(p_Next);
+    }
+
+    return p_StatsObj;
+}
+
+static __inline__ void EnqueueStatsObj(t_List              *p_List,
+                                     t_FmPcdStatsObj     *p_StatsObj)
+{
+    LIST_AddToTail(&p_StatsObj->node, p_List);
+}
+
+static void FreeStatObjects(t_List     *p_List,
+                            t_Handle   h_FmMuram)
+{
+    t_FmPcdStatsObj     *p_StatsObj;
+
+    while (!LIST_IsEmpty(p_List))
+    {
+        p_StatsObj = DequeueStatsObj(p_List);
+
+        FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
+        FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsCounters);
+
+        XX_Free(p_StatsObj);
+    }
+}
+
+static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
+{
+    t_FmPcdStatsObj*    p_StatsObj;
+    t_Handle            h_FmMuram;
+
+    ASSERT_COND(p_CcNode);
+
+    /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
+       upon node initialization */
+    if (p_CcNode->maxNumOfKeys)
+    {
+        p_StatsObj = DequeueStatsObj(&p_CcNode->availableStatsLst);
+    }
+    else
+    {
+        h_FmMuram = ((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram;
+        ASSERT_COND(h_FmMuram);
+
+        p_StatsObj = XX_Malloc(sizeof(t_FmPcdStatsObj));
+        if (!p_StatsObj)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("statistics object"));
+            return NULL;
+        }
+
+        p_StatsObj->h_StatsAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                            FM_PCD_CC_AD_ENTRY_SIZE,
+                                                            FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!p_StatsObj->h_StatsAd)
+        {
+            XX_Free(p_StatsObj);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics ADs"));
+            return NULL;
+        }
+        IOMemSet32(p_StatsObj->h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                                  p_CcNode->countersArraySize,
+                                                                  FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!p_StatsObj->h_StatsAd)
+        {
+            FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
+            XX_Free(p_StatsObj);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics counters"));
+            return NULL;
+        }
+        IOMemSet32(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
+    }
+
+    return p_StatsObj;
+}
+
+static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
+                        t_FmPcdStatsObj     *p_StatsObj)
+{
+    t_Handle            h_FmMuram;
+
+    ASSERT_COND(p_CcNode);
+    ASSERT_COND(p_StatsObj);
+
+    /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
+       upon node initialization and now will be enqueued back to the list */
+    if (p_CcNode->maxNumOfKeys)
+    {
+        /* Nullify counters */
+        IOMemSet32(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
+
+        EnqueueStatsObj(&p_CcNode->availableStatsLst, p_StatsObj);
+    }
+    else
+    {
+        h_FmMuram = ((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram;
+        ASSERT_COND(h_FmMuram);
+
+        FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
+        FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsCounters);
+
+        XX_Free(p_StatsObj);
+    }
+}
+
+static void UpdateStatsCounters(t_AdOfTypeStats *p_StatsAd,
+                                uint32_t        statsCountersAddr)
+{
+    uint32_t tmp = (statsCountersAddr & 0x00FFFFFF);
+
+    WRITE_UINT32(p_StatsAd->statsTableAddr, tmp);
+}
+
+static void UpdateStatsAd(t_AdOfTypeStats *p_StatsAd,
+                          uint32_t        statsCountersAddr,
+                          uint32_t        nextActionAddr,
+                          uint32_t        frameLengthRangesAddr)
+{
+    uint32_t tmp = 0;
+
+    tmp = 0x40000000;
+
+    if (frameLengthRangesAddr)
+        tmp |= (frameLengthRangesAddr & 0x00FFFFFF);
+
+    WRITE_UINT32(p_StatsAd->profileTableAddr, tmp);
+
+    tmp = 0;
+    tmp |= (uint32_t)((nextActionAddr << 12) & 0xFFFF0000);
+    tmp |= (0x00008000 | 0x36);
+
+    if (frameLengthRangesAddr)
+        tmp |= 0x00004000;
+
+    WRITE_UINT32(p_StatsAd->nextActionIndx, tmp);
+
+    UpdateStatsCounters(p_StatsAd, statsCountersAddr);
+}
+
 static void FillAdOfTypeContLookup(t_Handle h_Ad,
+                                   t_Handle h_StatsAd,
+                                   t_Handle h_StatsCounters,
+                                   t_Handle h_StatsFLRs,
                                    t_Handle h_FmPcd,
                                    t_Handle p_CcNode,
                                    t_Handle h_Manip,
@@ -103,8 +259,10 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
 {
     t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
     t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
+    t_AdOfTypeStats         *p_StatsAd = (t_AdOfTypeStats *)h_StatsAd;
+    t_Handle                h_TmpAd;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpReg32;
+    uint32_t                tmpReg32, statsFLRsAddr = 0;
     t_Handle                p_AdNewPtr = NULL;
 
     UNUSED(h_Manip);
@@ -126,14 +284,35 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdContLookup;
 
-#if (DPAA_VERSION >= 11)
+    /* Initialize an action descriptor, if current statistics mode requires an Ad */
+    if (h_StatsAd)
+    {
+        /* Swapping addresses between statistics Ad and the current lookup AD */
+        h_TmpAd = p_StatsAd;
+        p_StatsAd = h_Ad;
+        h_Ad = h_TmpAd;
+
+        p_AdNewPtr = h_Ad;
+        p_AdContLookup = h_Ad;
+
+        if (h_StatsFLRs)
+            statsFLRsAddr = (uint32_t)((XX_VirtToPhys(h_StatsFLRs) - p_FmPcd->physicalMuramBase));
+
+        /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
+        UpdateStatsAd(p_StatsAd,
+                      (uint32_t)((XX_VirtToPhys(h_StatsCounters) - p_FmPcd->physicalMuramBase)),
+                      (uint32_t)((XX_VirtToPhys(h_Ad) - p_FmPcd->physicalMuramBase)),
+                      statsFLRsAddr);
+    }
+
+#if DPAA_VERSION >= 11
     if (h_Manip && h_FrmReplic)
         FmPcdManipUpdateAdContLookupForCc(h_Manip,
                                           h_Ad,
                                           &p_AdNewPtr,
-                                          (uint32_t)((XX_VirtToPhys(FrmReplicGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
+                                          (uint32_t)((XX_VirtToPhys(FrmReplicGroupGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
     else if (h_FrmReplic)
-        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, h_Ad, &p_AdNewPtr);
+        FrmReplicGroupUpdateAd(h_FrmReplic, h_Ad, &p_AdNewPtr);
     else
 #endif /* (DPAA_VERSION >= 11) */
     if (h_Manip)
@@ -193,12 +372,15 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
-        if(!p_CcNode->h_Ad)
+        if (!p_CcNode->h_Ad)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
 
         IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
         FillAdOfTypeContLookup(p_CcNode->h_Ad,
+                               NULL,
+                               NULL,
+                               NULL,
                                p_CcNode->h_FmPcd,
                                p_CcNode,
                                NULL,
@@ -227,92 +409,92 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
     uint8_t             relativeSchemeId, physicalSchemeId;
     t_CcNodeInformation ccNodeInfo;
 
-     for(i = 0; i < numOfEntries; i++)
+     for (i = 0; i < numOfEntries; i++)
      {
-        if(i == 0)
+        if (i == 0)
             h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        switch(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        switch (p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
-            case(e_FM_PCD_CC):
-                if(requiredAction)
+            case (e_FM_PCD_CC):
+                if (requiredAction)
                 {
                     p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
                     ASSERT_COND(p_CcNode);
-                    if(p_CcNode->shadowAction == requiredAction)
+                    if (p_CcNode->shadowAction == requiredAction)
                         break;
-                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 0);
-                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
+                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
                         EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
                     }
-                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
                     {
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 1);
-                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
+                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
                         DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
                         tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
                         tmp = p_CcNode->numOfKeys;
                     err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_CcNode->keyAndNextEngineParams, p_CcNode->h_AdTable, tmp, h_Tree);
-                    if(err != E_OK)
+                    if (err != E_OK)
                         return err;
                     p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_KG):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_KG):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
                     relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
-                    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                    if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
                     if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-                    if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                    if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
                     err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
-                    if(err != E_OK)
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_PLCR):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_PLCR):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
-                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
                     err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
-                    if(err!= E_OK)
+                    if (err!= E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
-                    if(err != E_OK)
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_DONE):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_DONE):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
@@ -351,7 +533,6 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
     SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((1 == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
 
-
     /* We don't update subtree of the new node with new tree because it was done in the previous stage */
     if (p_AdditionalParams->h_NodeForAdd)
     {
@@ -439,22 +620,14 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
     if (p_AdditionalParams->h_ManipForRmv)
         FmPcdManipUpdateOwner(p_AdditionalParams->h_ManipForRmv, FALSE);
 
-#if (DPAA_VERSION >= 11)
-    if (p_AdditionalParams->h_FrmReplicForAdd)
-    {
-        FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForAdd,
-                               TRUE,  /* add */
-                               TRUE,  /* fullUpdate */
-                               p_AdditionalParams->h_CurrentNode);
-    }
+    if (p_AdditionalParams->p_StatsObjForRmv)
+        PutStatsObj((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode),
+                    p_AdditionalParams->p_StatsObjForRmv);
 
+#if (DPAA_VERSION >= 11)
     if (p_AdditionalParams->h_FrmReplicForRmv)
-    {
-        FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForRmv,
-                               FALSE, /* remove */
-                               TRUE,  /* fullUpdate */
-                               p_AdditionalParams->h_CurrentNode);
-    }
+        FrmReplicGroupUpdateOwner(p_AdditionalParams->h_FrmReplicForRmv,
+                                  FALSE/* remove */);
 #endif /* (DPAA_VERSION >= 11) */
 
     if (!useShadowStructs)
@@ -496,7 +669,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
 
         memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                 &p_AdditionalParams->keyAndNextEngineParams,
-                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (FM_PCD_MAX_NUM_OF_KEYS));
+                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
     }
     else
         memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
@@ -519,7 +692,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
 
     p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_FmPcdCcNodeTmp)
+    if (!p_FmPcdCcNodeTmp)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
         return NULL;
@@ -551,6 +724,9 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
             }
         }
         FillAdOfTypeContLookup(h_Ad,
+                               NULL,
+                               NULL,
+                               NULL,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
@@ -562,6 +738,9 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
         (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
     {
         FillAdOfTypeContLookup(h_Ad,
+                               NULL,
+                               NULL,
+                               NULL,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
@@ -677,7 +856,7 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
     {
         /* When the host-command above has ended, the old structures are 'free'and we can update
            them by copying from the new shadow structures. */
-        if(p_CcNode->lclMask)
+        if (p_CcNode->lclMask)
             keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
         else
             keySize = p_CcNode->ccKeySizeAccExtraction;
@@ -730,9 +909,9 @@ static bool FmPcdCcIsCapwapApplSpecific(t_Handle h_Node)
 
     ASSERT_COND(h_Node);
     /* assumption that this function called only for INDEXED_FLOW_ID - so no miss*/
-    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
-        if( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
+        if ( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
             FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
         {
             isManipForCapwapApplSpecificBuild = TRUE;
@@ -769,7 +948,7 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
                                h_PcdParams,
                                h_FmPort,
                                p_CcTree->h_IpReassemblyManip,
-                               h_Ad,
+                               NULL,
                                validate,
                                level,
                                h_FmTree,
@@ -792,7 +971,7 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
                 p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_CcNode);
 
-                if(p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
                     err = FmPcdManipUpdate(h_FmPcd,
                                            NULL,
@@ -852,23 +1031,23 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
 {
     switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
     {
-        case(e_FM_PCD_ACTION_EXACT_MATCH):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case (e_FM_PCD_ACTION_EXACT_MATCH):
+            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case(e_FM_PCD_EXTRACT_FROM_KEY):
+                case (e_FM_PCD_EXTRACT_FROM_KEY):
                     return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                case (e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
                 default:
                     return CC_PRIVATE_INFO_NONE;
             }
 
-        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case (e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                case (e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
-                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                case (e_FM_PCD_EXTRACT_FROM_FLOW_ID):
                     return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
                 default:
                   return  CC_PRIVATE_INFO_NONE;
@@ -898,7 +1077,7 @@ void ReleaseLst(t_List *p_List)
 {
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
 
-    if(!LIST_IsEmpty(p_List))
+    if (!LIST_IsEmpty(p_List))
     {
         p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
         while (p_CcNodeInfo)
@@ -908,7 +1087,7 @@ void ReleaseLst(t_List *p_List)
         }
     }
 
-    LIST_DelAndInit(p_List);
+    LIST_Del(p_List);
 }
 
 void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
@@ -929,51 +1108,75 @@ void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
 
 static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 {
-    if (p_CcNode)
+    uint32_t i;
+
+    if (!p_CcNode)
+        return;
+
+    if (p_CcNode->p_GlblMask)
     {
-        if (p_CcNode->p_GlblMask)
-        {
-            XX_Free(p_CcNode->p_GlblMask);
-            p_CcNode->p_GlblMask = NULL;
-        }
+        XX_Free(p_CcNode->p_GlblMask);
+        p_CcNode->p_GlblMask = NULL;
+    }
 
-        if (p_CcNode->h_KeysMatchTable)
-        {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
-            p_CcNode->h_KeysMatchTable = NULL;
-        }
+    if (p_CcNode->h_KeysMatchTable)
+    {
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
+        p_CcNode->h_KeysMatchTable = NULL;
+    }
 
-        if (p_CcNode->h_AdTable)
-        {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
-            p_CcNode->h_AdTable = NULL;
-        }
+    if (p_CcNode->h_AdTable)
+    {
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
+        p_CcNode->h_AdTable = NULL;
+    }
 
-        if (p_CcNode->h_Ad)
-        {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
-            p_CcNode->h_Ad = NULL;
-        }
+    if (p_CcNode->h_Ad)
+    {
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
+        p_CcNode->h_Ad = NULL;
+    }
 
-        if (p_CcNode->h_Spinlock)
-        {
-            XX_FreeSpinlock(p_CcNode->h_Spinlock);
-            p_CcNode->h_Spinlock = NULL;
-        }
+    if (p_CcNode->h_StatsFLRs)
+    {
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_StatsFLRs);
+        p_CcNode->h_StatsFLRs = NULL;
+    }
+
+    if (p_CcNode->h_Spinlock)
+    {
+        XX_FreeSpinlock(p_CcNode->h_Spinlock);
+        p_CcNode->h_Spinlock = NULL;
+    }
 
-        ReleaseLst(&p_CcNode->ccPrevNodesLst);
-        ReleaseLst(&p_CcNode->ccTreeIdLst);
-        ReleaseLst(&p_CcNode->ccTreesLst);
+    /* Releasing all currently used statistics objects, including 'miss' entry */
+    for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
+        if (p_CcNode->keyAndNextEngineParams[i].p_StatsObj)
+            PutStatsObj(p_CcNode, p_CcNode->keyAndNextEngineParams[i].p_StatsObj);
+
+    if (!LIST_IsEmpty(&p_CcNode->availableStatsLst))
+    {
+        t_Handle    h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
 
-        XX_Free(p_CcNode);
+        ASSERT_COND(h_FmMuram);
+
+        FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
     }
+
+    LIST_Del(&p_CcNode->availableStatsLst);
+
+    ReleaseLst(&p_CcNode->ccPrevNodesLst);
+    ReleaseLst(&p_CcNode->ccTreeIdLst);
+    ReleaseLst(&p_CcNode->ccTreesLst);
+
+    XX_Free(p_CcNode);
 }
 
 static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 {
-    if(p_FmPcdTree)
+    if (p_FmPcdTree)
     {
-        if(p_FmPcdTree->ccTreeBaseAddr)
+        if (p_FmPcdTree->ccTreeBaseAddr)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
             p_FmPcdTree->ccTreeBaseAddr = 0;
@@ -987,25 +1190,25 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 
 static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
 {
-    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+    if ((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
         *parseCodeCcSize = 1;
-    else if(parseCodeRealSize == 2)
+    else if (parseCodeRealSize == 2)
         *parseCodeCcSize = 2;
-    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+    else if ((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
         *parseCodeCcSize = 4;
-    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+    else if ((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
         *parseCodeCcSize = 8;
-    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+    else if ((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
         *parseCodeCcSize = 16;
-    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+    else if ((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
         *parseCodeCcSize = 24;
-    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+    else if ((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
         *parseCodeCcSize = 32;
-    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+    else if ((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
         *parseCodeCcSize = 40;
-    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+    else if ((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
         *parseCodeCcSize = 48;
-    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+    else if ((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
         *parseCodeCcSize = 56;
     else
         *parseCodeCcSize = 0;
@@ -1015,20 +1218,23 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
                                 t_FmPcdFields       field,
                                 uint8_t             *parseCodeRealSize)
 {
-    switch(hdr)
+    switch (hdr)
     {
         case (HEADER_TYPE_ETH):
-            switch(field.eth)
+            switch (field.eth)
             {
-                case(NET_HEADER_FIELD_ETH_DA):
+                case (NET_HEADER_FIELD_ETH_DA):
                     *parseCodeRealSize = 6;
                     break;
-                case(NET_HEADER_FIELD_ETH_SA):
+
+                case (NET_HEADER_FIELD_ETH_SA):
                     *parseCodeRealSize = 6;
                     break;
-                case(NET_HEADER_FIELD_ETH_TYPE):
+
+                case (NET_HEADER_FIELD_ETH_TYPE):
                     *parseCodeRealSize = 2;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1036,12 +1242,13 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-        case(HEADER_TYPE_PPPoE):
-            switch(field.pppoe)
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
             {
-                case(NET_HEADER_FIELD_PPPoE_PID):
+                case (NET_HEADER_FIELD_PPPoE_PID):
                     *parseCodeRealSize = 2;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1050,11 +1257,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_VLAN):
-            switch(field.vlan)
+            switch (field.vlan)
             {
-               case(NET_HEADER_FIELD_VLAN_TCI):
+               case (NET_HEADER_FIELD_VLAN_TCI):
                     *parseCodeRealSize = 2;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported2"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1063,11 +1271,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_MPLS):
-            switch(field.mpls)
+            switch (field.mpls)
             {
-                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
                     *parseCodeRealSize = 4;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported3"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1076,22 +1285,26 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_IPv4):
-            switch(field.ipv4)
+            switch (field.ipv4)
             {
-                case(NET_HEADER_FIELD_IPv4_DST_IP):
-                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                case (NET_HEADER_FIELD_IPv4_DST_IP):
+                case (NET_HEADER_FIELD_IPv4_SRC_IP):
                     *parseCodeRealSize = 4;
                     break;
-                case(NET_HEADER_FIELD_IPv4_TOS):
-                case(NET_HEADER_FIELD_IPv4_PROTO):
+
+                case (NET_HEADER_FIELD_IPv4_TOS):
+                case (NET_HEADER_FIELD_IPv4_PROTO):
                     *parseCodeRealSize = 1;
                     break;
-                case(NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+
+                case (NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
                     *parseCodeRealSize = 8;
                     break;
-                case(NET_HEADER_FIELD_IPv4_TTL):
+
+                case (NET_HEADER_FIELD_IPv4_TTL):
                     *parseCodeRealSize = 1;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported4"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1100,19 +1313,22 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_IPv6):
-            switch(field.ipv6)
+            switch (field.ipv6)
             {
-                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                    *parseCodeRealSize = 4;
                     break;
-                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+
+                case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                case (NET_HEADER_FIELD_IPv6_HOP_LIMIT):
                    *parseCodeRealSize = 1;
                     break;
-                case(NET_HEADER_FIELD_IPv6_DST_IP):
-                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+
+                case (NET_HEADER_FIELD_IPv6_DST_IP):
+                case (NET_HEADER_FIELD_IPv6_SRC_IP):
                    *parseCodeRealSize = 16;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1121,11 +1337,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_GRE):
-            switch(field.gre)
+            switch (field.gre)
             {
-                case(NET_HEADER_FIELD_GRE_TYPE):
+                case (NET_HEADER_FIELD_GRE_TYPE):
                    *parseCodeRealSize = 2;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported6"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1134,18 +1351,21 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_MINENCAP):
-            switch(field.minencap)
+            switch (field.minencap)
             {
-                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
                    *parseCodeRealSize = 1;
                     break;
-                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
-                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
                   *parseCodeRealSize = 4;
                     break;
-                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+
+                 case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
                   *parseCodeRealSize = 8;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported7"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1154,15 +1374,17 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_TCP):
-            switch(field.tcp)
+            switch (field.tcp)
             {
-                case(NET_HEADER_FIELD_TCP_PORT_SRC):
-                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
                    *parseCodeRealSize = 2;
                     break;
-                 case(NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
+
+                 case (NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
                   *parseCodeRealSize = 4;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported8"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1171,15 +1393,17 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_UDP):
-            switch(field.udp)
+            switch (field.udp)
             {
-                case(NET_HEADER_FIELD_UDP_PORT_SRC):
-                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
                    *parseCodeRealSize = 2;
                     break;
-                 case(NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
+
+                 case (NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
                   *parseCodeRealSize = 4;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported9"));
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -1195,19 +1419,24 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
 }
 
 t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
-                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams,
+                                 e_FmPcdCcStatsMode         supportedStatsMode)
 {
     uint16_t    absoluteProfileId;
     t_Error     err = E_OK;
     uint8_t     relativeSchemeId;
 
-    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    if ((supportedStatsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
+        (p_FmPcdCcNextEngineParams->statisticsEn))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics supported was not requested upon this table initialization"));
+
+    switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
-         case(e_FM_PCD_INVALID):
+         case (e_FM_PCD_INVALID):
              err = E_NOT_SUPPORTED;
              break;
 
-         case(e_FM_PCD_DONE):
+         case (e_FM_PCD_DONE):
              if (p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
              {
                  if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
@@ -1218,54 +1447,51 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
              }
             break;
 
-        case(e_FM_PCD_KG):
-            relativeSchemeId =
-                    FmPcdKgGetRelativeSchemeId(h_FmPcd, FmPcdKgGetSchemeId(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
+        case (e_FM_PCD_KG):
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd,
+                                                          FmPcdKgGetSchemeId(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
             if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-
             if (!FmPcdKgIsSchemeValidSw(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
             if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
             break;
 
-        case(e_FM_PCD_PLCR):
-            if(p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
+        case (e_FM_PCD_PLCR):
+            if (p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
             {
                 /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-                if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
+                if (p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
                 {
                     err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
                                                         e_FM_PCD_PLCR_SHARED,
                                                         NULL,
                                                         p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
                                                         &absoluteProfileId);
-                    if(err)
+                    if (err)
                         RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
-                    if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
+                    if (!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
                 }
                 else
                 {
                 }
                 /* TODO - add check according to the revision of the chip.
-                if(!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
+                if (!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
                    (p_FmPcdCcNextEngineParams->params.plcrParams.newFqid & ~0x00FFFFFF))
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("newFqid  must be between 1 and 2^24-1"));
                 */
             }
             break;
 
-        case(e_FM_PCD_CC):
-            if(!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+        case (e_FM_PCD_CC):
+            if (!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
                 RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
-            if(p_FmPcdCcNextEngineParams->statisticsEn)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("not allowed to put statisticsEn when nextEngine == e_FM_PCD_CC"));
         break;
 
 #if (DPAA_VERSION >= 11)
-         case(e_FM_PCD_FR):
+         case (e_FM_PCD_FR):
              if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
              break;
@@ -1288,19 +1514,19 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
 {
     UNUSED(h_FmPcd);
 
-    if(!fromIc)
+    if (!fromIc)
     {
-        switch(src)
+        switch (src)
         {
-            case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
-                if(glblMask)
+            case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
+                if (glblMask)
                     return CC_PC_GENERIC_WITH_MASK ;
                 else
                   return CC_PC_GENERIC_WITHOUT_MASK;
 
-            case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+            case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
-                if(offset)
+                if (offset)
                     return CC_PR_OFFSET;
                 else
                     return CC_PR_WITHOUT_OFFSET;
@@ -1314,18 +1540,22 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
     {
         switch (icCode)
         {
-            case(CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
+            case (CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
                  *parseArrayOffset = 0x50;
                  return CC_PC_GENERIC_IC_GMASK;
-            case(CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
+
+            case (CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
                *parseArrayOffset = 0x48;
                return CC_PC_GENERIC_IC_GMASK;
-            case(CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
+
+            case (CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
                 *parseArrayOffset = 0x48;
                  return CC_PC_GENERIC_IC_HASH_INDEXED;
-            case(CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
+
+            case (CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
                 *parseArrayOffset = 0x16;
                  return CC_PC_GENERIC_IC_HASH_INDEXED;
+
             default:
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
                 break;
@@ -1340,197 +1570,222 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                                      t_FmPcdFields      field)
 {
 
-      switch(hdr)
-        {
-            case(HEADER_TYPE_NONE):
-                ASSERT_COND(FALSE);
-                return CC_PC_ILLEGAL;
+    switch (hdr)
+    {
+        case (HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+            return CC_PC_ILLEGAL;
 
-       case(HEADER_TYPE_ETH):
-                switch(field.eth)
-                {
-                    case(NET_HEADER_FIELD_ETH_DA):
-                        return CC_PC_FF_MACDST;
-                    case(NET_HEADER_FIELD_ETH_SA):
-                         return CC_PC_FF_MACSRC;
-                    case(NET_HEADER_FIELD_ETH_TYPE):
-                         return CC_PC_FF_ETYPE;
-                    default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return CC_PC_ILLEGAL;
-                }
+        case (HEADER_TYPE_ETH):
+            switch (field.eth)
+            {
+                case (NET_HEADER_FIELD_ETH_DA):
+                    return CC_PC_FF_MACDST;
+                case (NET_HEADER_FIELD_ETH_SA):
+                    return CC_PC_FF_MACSRC;
+                case (NET_HEADER_FIELD_ETH_TYPE):
+                    return CC_PC_FF_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-         case(HEADER_TYPE_VLAN):
-            switch(field.vlan)
+        case (HEADER_TYPE_VLAN):
+            switch (field.vlan)
             {
-                case(NET_HEADER_FIELD_VLAN_TCI):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_VLAN_TCI):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_TCI1;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_TCI2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
+
                 default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return CC_PC_ILLEGAL;
             }
 
-        case(HEADER_TYPE_MPLS):
-            switch(field.mpls)
+        case (HEADER_TYPE_MPLS):
+            switch (field.mpls)
             {
-                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_MPLS1;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_MPLS_LAST;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return CC_PC_ILLEGAL;
+
                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
              }
 
-        case(HEADER_TYPE_IPv4):
-            switch(field.ipv4)
+        case (HEADER_TYPE_IPv4):
+            switch (field.ipv4)
             {
-                case(NET_HEADER_FIELD_IPv4_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4DST1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv4_TOS):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv4_TOS):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4IPTOS_TC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv4_PROTO):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv4_PROTO):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1_IPV4DST1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv4_TTL):
+
+                case (NET_HEADER_FIELD_IPv4_TTL):
                     return CC_PC_FF_IPV4TTL;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
 
-        case(HEADER_TYPE_IPv6):
-             switch(field.ipv6)
+        case (HEADER_TYPE_IPv6):
+             switch (field.ipv6)
             {
-                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv6_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv6_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6DST1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+
+                case (NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6SRC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6SRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
-                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+
+                case (NET_HEADER_FIELD_IPv6_HOP_LIMIT):
                     return CC_PC_FF_IPV6HOP_LIMIT;
-                 default:
+
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
 
-        case(HEADER_TYPE_GRE):
-            switch(field.gre)
+        case (HEADER_TYPE_GRE):
+            switch (field.gre)
             {
-                case(NET_HEADER_FIELD_GRE_TYPE):
+                case (NET_HEADER_FIELD_GRE_TYPE):
                     return CC_PC_FF_GREPTYPE;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
            }
-        case(HEADER_TYPE_MINENCAP):
-            switch(field.minencap)
+        case (HEADER_TYPE_MINENCAP):
+            switch (field.minencap)
             {
-                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
                     return CC_PC_FF_MINENCAP_PTYPE;
-                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
                     return CC_PC_FF_MINENCAP_IPDST;
-                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
                     return CC_PC_FF_MINENCAP_IPSRC;
-                case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
                     return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
            }
 
-        case(HEADER_TYPE_TCP):
-            switch(field.tcp)
+        case (HEADER_TYPE_TCP):
+            switch (field.tcp)
             {
-                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
                     return CC_PC_FF_L4PSRC;
-                case(NET_HEADER_FIELD_TCP_PORT_DST):
+
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
                     return CC_PC_FF_L4PDST;
-                case(NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
+
+                case (NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
                     return CC_PC_FF_L4PSRC_L4PDST;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
 
-        case(HEADER_TYPE_PPPoE):
-            switch(field.pppoe)
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
             {
-                case(NET_HEADER_FIELD_PPPoE_PID):
+                case (NET_HEADER_FIELD_PPPoE_PID):
                     return CC_PC_FF_PPPPID;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
 
-        case(HEADER_TYPE_UDP):
-            switch(field.udp)
+        case (HEADER_TYPE_UDP):
+            switch (field.udp)
             {
-                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
                     return CC_PC_FF_L4PSRC;
-                case(NET_HEADER_FIELD_UDP_PORT_DST):
+
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
                     return CC_PC_FF_L4PDST;
-                case(NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
+
+                case (NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
                     return CC_PC_FF_L4PSRC_L4PDST;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
@@ -1550,45 +1805,45 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
 {
     bool offsetRelevant = FALSE;
 
-    if(offset)
+    if (offset)
         offsetRelevant = TRUE;
 
-    switch(hdr)
+    switch (hdr)
     {
-        case(HEADER_TYPE_NONE):
+        case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
             return CC_PC_ILLEGAL;
 
-        case(HEADER_TYPE_ETH):
+        case (HEADER_TYPE_ETH):
             *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
             break;
 
-        case(HEADER_TYPE_USER_DEFINED_SHIM1):
-            if(offset || glblMask)
+        case (HEADER_TYPE_USER_DEFINED_SHIM1):
+            if (offset || glblMask)
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
             else
                 return CC_PC_PR_SHIM1;
             break;
 
-        case(HEADER_TYPE_USER_DEFINED_SHIM2):
-            if(offset || glblMask)
+        case (HEADER_TYPE_USER_DEFINED_SHIM2):
+            if (offset || glblMask)
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
             else
                 return CC_PC_PR_SHIM2;
             break;
 
-        case(HEADER_TYPE_LLC_SNAP):
+        case (HEADER_TYPE_LLC_SNAP):
             *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
             break;
 
-        case(HEADER_TYPE_PPPoE):
+        case (HEADER_TYPE_PPPoE):
             *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
             break;
 
-        case(HEADER_TYPE_MPLS):
-            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+        case (HEADER_TYPE_MPLS):
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-            else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+            else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
             else
             {
@@ -1597,11 +1852,11 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             }
             break;
 
-        case(HEADER_TYPE_IPv4):
-        case(HEADER_TYPE_IPv6):
-            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+        case (HEADER_TYPE_IPv4):
+        case (HEADER_TYPE_IPv6):
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                 *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-            else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+            else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
                 *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
             else
             {
@@ -1610,20 +1865,20 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             }
             break;
 
-        case(HEADER_TYPE_MINENCAP):
+        case (HEADER_TYPE_MINENCAP):
             *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
             break;
 
-        case(HEADER_TYPE_GRE):
+        case (HEADER_TYPE_GRE):
             *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
             break;
 
-        case(HEADER_TYPE_TCP):
-        case(HEADER_TYPE_UDP):
-        case(HEADER_TYPE_IPSEC_AH):
-        case(HEADER_TYPE_IPSEC_ESP):
-        case(HEADER_TYPE_DCCP):
-        case(HEADER_TYPE_SCTP):
+        case (HEADER_TYPE_TCP):
+        case (HEADER_TYPE_UDP):
+        case (HEADER_TYPE_IPSEC_AH):
+        case (HEADER_TYPE_IPSEC_ESP):
+        case (HEADER_TYPE_DCCP):
+        case (HEADER_TYPE_SCTP):
             *parseArrayOffset = CC_PC_PR_L4_OFFSET;
             break;
 
@@ -1632,7 +1887,7 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             return CC_PC_ILLEGAL;
      }
 
-    if(offsetRelevant)
+    if (offsetRelevant)
         return CC_PR_OFFSET;
     else
         return CC_PR_WITHOUT_OFFSET;
@@ -1646,34 +1901,36 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
 {
     bool offsetRelevant = FALSE;
 
-    if(offset)
+    if (offset)
         offsetRelevant = TRUE;
 
-    switch(hdr)
+    switch (hdr)
     {
-        case(HEADER_TYPE_NONE):
+        case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-        case(HEADER_TYPE_ETH):
-            switch(field.eth)
+        case (HEADER_TYPE_ETH):
+            switch (field.eth)
             {
-                case(NET_HEADER_FIELD_ETH_TYPE):
+                case (NET_HEADER_FIELD_ETH_TYPE):
                     *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
             break;
 
-        case(HEADER_TYPE_VLAN):
-            switch(field.vlan)
+        case (HEADER_TYPE_VLAN):
+            switch (field.vlan)
             {
-                case(NET_HEADER_FIELD_VLAN_TCI):
-                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_VLAN_TCI):
+                    if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                    else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                         *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                     break;
+
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
@@ -1685,18 +1942,23 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
             return CC_PC_ILLEGAL;
     }
 
-    if(offsetRelevant)
+    if (offsetRelevant)
         return CC_PR_OFFSET;
     else
         return CC_PR_WITHOUT_OFFSET;
 }
 
 void FillAdOfTypeResult(t_Handle                    h_Ad,
+                        t_Handle                    h_StatsAd,
+                        t_Handle                    h_StatsCounters,
+                        t_Handle                    h_StatsFLRs,
                         t_FmPcd                     *p_FmPcd,
                         t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)h_Ad;
-    uint32_t            tmp = 0, tmpNia = 0;
+    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult *)h_Ad;
+    t_AdOfTypeStats     *p_StatsAd = (t_AdOfTypeStats *)h_StatsAd;
+    t_Handle            h_TmpAd;
+    uint32_t            tmp = 0, tmpNia = 0, statsFLRsAddr = 0;
     uint16_t            profileId;
     t_Handle            p_AdNewPtr = NULL;
 
@@ -1709,15 +1971,41 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
      *         this routine returns and point to the existing AD.
      * Case 3: Manip exists. The action descriptor is built within the match table.
      *         FmPcdManipUpdateAdResultForCc returns a NULL p_AdNewPtr.
+     *
+     * If statistics were enabled and the statistics mode of this node requires
+     * a statistics Ad, it will be placed after the result Ad and before the
+     * manip Ad, if manip Ad exists here.
      */
 
     /* As default, the "new" ptr is the current one. i.e. the content of the result
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdResult;
 
-    /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
+    /* Initialize an action descriptor, if current statistics mode requires an Ad */
+    if (h_StatsAd)
+    {
+        /* Swapping addresses between statistics Ad and the current lookup AD addresses */
+        h_TmpAd = p_StatsAd;
+        p_StatsAd = h_Ad;
+        h_Ad = h_TmpAd;
+
+        p_AdNewPtr = h_Ad;
+        p_AdResult = h_Ad;
+
+        if (h_StatsFLRs)
+            statsFLRsAddr = (uint32_t)((XX_VirtToPhys(h_StatsFLRs) - p_FmPcd->physicalMuramBase));
+
+        /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
+        UpdateStatsAd(p_StatsAd,
+                      (uint32_t)((XX_VirtToPhys(h_StatsCounters) - p_FmPcd->physicalMuramBase)),
+                      (uint32_t)((XX_VirtToPhys(h_Ad) - p_FmPcd->physicalMuramBase)),
+                      statsFLRsAddr);
+    }
+
+    /* Create manip and return p_AdNewPtr to either a new descriptor or NULL */
     if (p_CcNextEngineParams->h_Manip)
         FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip,
+                                      p_CcNextEngineParams,
                                       h_Ad,
                                       &p_AdNewPtr);
 
@@ -1749,9 +2037,6 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                     tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                 else
                     tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
-
-                if (p_CcNextEngineParams->statisticsEn)
-                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
             case (e_FM_PCD_KG):
@@ -1771,12 +2056,9 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                 tmpNia = NIA_KG_DIRECT;
                 tmpNia |= NIA_ENG_KG;
                 tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
-
-                if (p_CcNextEngineParams->statisticsEn)
-                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
-            case(e_FM_PCD_PLCR):
+            case (e_FM_PCD_PLCR):
                 tmp = 0;
                 if (p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
@@ -1805,9 +2087,6 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                    tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
 
                 tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
-
-                if (p_CcNextEngineParams->statisticsEn)
-                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                break;
 
             default:
@@ -1852,38 +2131,50 @@ static t_Error CcUpdateParams(t_Handle      h_FmPcd,
                          FALSE);
 }
 
-/*static*/ void NextStepAd(t_Handle                     h_Ad,
-                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
-                           t_FmPcd                      *p_FmPcd)
+void NextStepAd(t_Handle                     h_Ad,
+                t_Handle                     h_StatsAd,
+                t_Handle                     h_StatsCounters,
+                t_Handle                     h_StatsFLRs,
+                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                t_FmPcd                      *p_FmPcd)
 {
-    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
-        case(e_FM_PCD_KG):
-        case(e_FM_PCD_PLCR):
-        case(e_FM_PCD_DONE):
+        case (e_FM_PCD_KG):
+        case (e_FM_PCD_PLCR):
+        case (e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(h_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            FillAdOfTypeResult(h_Ad,
+                               h_StatsAd,
+                               h_StatsCounters,
+                               h_StatsFLRs,
+                               p_FmPcd,
+                               p_FmPcdCcNextEngineParams);
             break;
 #if (DPAA_VERSION >= 11)
-        case(e_FM_PCD_FR):
+        case (e_FM_PCD_FR):
             if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
                 FillAdOfTypeContLookup(h_Ad,
+                                       h_StatsAd,
+                                       h_StatsCounters,
+                                       h_StatsFLRs,
                                        p_FmPcd,
                                        p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                        p_FmPcdCcNextEngineParams->h_Manip,
                                        p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
-                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
-                                                                 TRUE,  /* add */
-                                                                 FALSE, /* fullUpdate */
-                                                                 NULL);
+                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
+                                          TRUE/* add */);
             }
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
-        case(e_FM_PCD_CC):
+        case (e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
             FillAdOfTypeContLookup(h_Ad,
+                                   h_StatsAd,
+                                   h_StatsCounters,
+                                   h_StatsFLRs,
                                    p_FmPcd,
                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                    p_FmPcdCcNextEngineParams->h_Manip,
@@ -1900,11 +2191,11 @@ static t_Error CcUpdateParams(t_Handle      h_FmPcd,
 
 static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    if(p_AdditionalInfo->p_AdTableNew)
+    if (p_AdditionalInfo->p_AdTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_AdTableNew);
 
-    if(p_AdditionalInfo->p_KeysMatchTableNew)
+    if (p_AdditionalInfo->p_KeysMatchTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_KeysMatchTableNew);
 }
@@ -1946,22 +2237,21 @@ static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
         p_CcNode->lclMask = TRUE;
         p_CcNode->glblMaskSize = 0;
     }
-
 }
 
-static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
+static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
 {
     t_FmPcd         *p_FmPcd;
     t_Handle        h_Ad;
 
-
-    if(isTree)
+    if (isTree)
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcTree *)h_FmPcdCcNodeOrTree)->h_FmPcd);
     else
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_FmPcd);
 
 
-    if((isTree && p_FmPcd->p_CcShadow) || (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
+    if ((isTree && p_FmPcd->p_CcShadow) ||
+        (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
     {
         /* The allocated shadow is divided as follows:
            0 . . .       16 . . .
@@ -2000,7 +2290,7 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_C
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    if(p_CcNode->lclMask)
+    if (p_CcNode->lclMask)
         *size = 2 * p_CcNode->ccKeySizeAccExtraction;
     else
         *size = p_CcNode->ccKeySizeAccExtraction;
@@ -2065,6 +2355,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
     t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    t_Handle                h_StatsAd, h_StatsCounters;
     int                     size;
     int                     i = 0, j = 0;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -2072,10 +2363,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     bool                    prvLclMask;
     t_CcNodeInformation     *p_CcNodeInformation;
     t_List                  *p_Pos;
+    t_FmPcdStatsObj         *p_StatsObj;
 
     /* Check that new NIA is legal */
-    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
-    if(err)
+    err = ValidateNextEngineParams(h_FmPcd,
+                                   &p_KeyParams->ccNextEngineParams,
+                                   p_CcNode->statisticsMode);
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     prvLclMask = p_CcNode->lclMask;
@@ -2123,12 +2417,11 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Check that manip is legal and what requiredAction is necessary for this manip */
-    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    if (p_KeyParams->ccNextEngineParams.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
-
     }
 
     p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
@@ -2142,8 +2435,35 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
         if (j == keyIndex)
         {
+            if (p_KeyParams->ccNextEngineParams.statisticsEn)
+            {
+                /* Allocate a statistics object that holds statistics AD and counters.
+                   - For added key - New statistics AD and counters pointer need to be allocated
+                     new statistics object. If statistics were enabled, we need to replace the
+                     existing descriptor with a new descriptor with nullified counters.
+                 */
+                p_StatsObj = GetStatsObj(p_CcNode);
+                ASSERT_COND(p_StatsObj);
+
+                /* Store allocated statistics object */
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+
+                h_StatsAd = p_StatsObj->h_StatsAd;
+                h_StatsCounters = p_StatsObj->h_StatsCounters;
+            }
+            else
+            {
+                h_StatsAd = NULL;
+                h_StatsCounters = NULL;
+            }
+
             /* Building action descriptor for the received new key */
-            NextStepAd(p_AdTableNewTmp, &p_KeyParams->ccNextEngineParams, p_FmPcd);
+            NextStepAd(p_AdTableNewTmp,
+                       h_StatsAd,
+                       h_StatsCounters,
+                       p_CcNode->h_StatsFLRs,
+                       &p_KeyParams->ccNextEngineParams,
+                       p_FmPcd);
 
             /* Copy the received new key into keys match table */
             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
@@ -2153,7 +2473,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             /* Update mask for the received new key */
             if (p_CcNode->lclMask)
             {
-                if(p_KeyParams->p_Mask)
+                if (p_KeyParams->p_Mask)
                 {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
@@ -2187,8 +2507,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
              IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
 
              /* Copy existing keys and their masks to the newly allocated keys match table */
-             p_KeysMatchTableNewTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-             p_KeysMatchTableOldTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i*size * sizeof(uint8_t));
+             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+             p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i * size * sizeof(uint8_t));
 
              if (p_CcNode->lclMask)
              {
@@ -2201,7 +2521,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
                  else
                  {
                      p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable,
-                                                       i*p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                                                       i * p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
 
                      if (p_CcNode->ccKeySizeAccExtraction > 4)
                      {
@@ -2227,8 +2547,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     }
 
     /* Miss action descriptor */
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreesLst))
@@ -2237,8 +2557,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         {
             p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
             ASSERT_COND(p_CcNodeInformation->h_CcNode);
-            /*update the manipulation which has to be updated from parameters of the port*/
-            /*it's has to be updated with restrictions defined in the function*/
+            /* Update the manipulation which has to be updated from parameters of the port */
+            /* It's has to be updated with restrictions defined in the function */
             err = FmPcdCcSetRequiredAction(p_CcNode->h_FmPcd,
                                            p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
                                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
@@ -2283,6 +2603,11 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+
+        /* If statistics were previously enabled, store the old statistics object to be released */
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
@@ -2309,42 +2634,50 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
 
     /*function which allocates in the memory new KeyTbl, AdTbl*/
     err = BuildNewNodeCommonPart(p_CcNode, &size, p_AdditionalInfo);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update new Ad and new Key Table according to new requirement*/
-    for(i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
+    for (i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
     {
-        if(j == keyIndex)
+        if (j == keyIndex)
         {
-            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
             j++;
         }
-        if(j == p_CcNode->numOfKeys)
+        if (j == p_CcNode->numOfKeys)
             break;
-         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i*FM_PCD_CC_AD_ENTRY_SIZE);
-         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
          IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-         p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j*size * sizeof(uint8_t));
-         p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i*size * sizeof(uint8_t));
+         p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
+         p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
          IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
-    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        p_AdditionalInfo->h_NodeForRmv =
+            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-        p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+        p_AdditionalInfo->h_ManipForRmv =
+            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+
+    /* If statistics were previously enabled, store the old statistics object to be released */
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+        p_AdditionalInfo->p_StatsObjForRmv =
+            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
 
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
             (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
    return E_OK;
@@ -2356,13 +2689,14 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
                                      uint8_t                            *p_Mask,
                                      t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
     t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
     int                     size;
     int                     i = 0, j = 0;
     bool                    prvLclMask;
-
+    t_FmPcdStatsObj         *p_StatsObj;
     p_AdditionalInfo->numOfKeys =  p_CcNode->numOfKeys;
 
     prvLclMask = p_CcNode->lclMask;
@@ -2387,65 +2721,74 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
                p_CcNode->userSizeOfExtraction);
 
     /*function which build in the memory new KeyTbl, AdTbl*/
-    err = BuildNewNodeCommonPart(p_CcNode, &size,  p_AdditionalInfo);
-    if(err)
+    err = BuildNewNodeCommonPart(p_CcNode, &size, p_AdditionalInfo);
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill the New AdTable and New KeyTable*/
-    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    for (j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
     {
         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
-        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        if(j == keyIndex)
+        if (j == keyIndex)
         {
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+            if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            {
+                /* As statistics were enabled, we need to update the existing
+                   statistics descriptor with a new nullified counters. */
+                p_StatsObj = GetStatsObj(p_CcNode);
+                ASSERT_COND(p_StatsObj);
+
+                /* Store allocated statistics object */
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+
+                UpdateStatsCounters(p_AdTableNewTmp,
+                                    (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
+
+                /* As statistics were previously enabled, store the old statistics object to be released */
+                p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+            }
+
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
 
             Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_CcNode->userSizeOfExtraction);
 
-            if(p_CcNode->lclMask)
+            if (p_CcNode->lclMask)
             {
                 if (p_Mask)
-                {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                 p_Mask,
                                 p_CcNode->userSizeOfExtraction);
-                }
                 else if (p_CcNode->ccKeySizeAccExtraction > 4)
-                {
                     IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                p_CcNode->ccKeySizeAccExtraction),
                                0xff,
                                p_CcNode->userSizeOfExtraction);
-                }
                 else
-                {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                 p_CcNode->p_GlblMask,
                                 p_CcNode->userSizeOfExtraction);
-                }
             }
         }
         else
         {
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i*size * sizeof(uint8_t));
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * size * sizeof(uint8_t));
 
             if (p_CcNode->lclMask)
             {
-                if(prvLclMask)
-                {
+                if (prvLclMask)
                     IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
                                PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
                                p_CcNode->userSizeOfExtraction);
-                }
                 else
                 {
-                    p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i*p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+                    p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
@@ -2458,12 +2801,14 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
                                    p_CcNode->userSizeOfExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction);
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp,
+                       p_KeysMatchTableOldTmp,
+                       p_CcNode->ccKeySizeAccExtraction);
         }
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i * FM_PCD_CC_AD_ENTRY_SIZE);
 
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -2478,31 +2823,41 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
                                             t_List                              *h_NewLst,
                                             t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalInfo)
 {
-    t_Error      err = E_OK;
-    uint32_t     requiredAction = 0;
-    t_List       *p_Pos;
+    t_Error             err = E_OK;
+    uint32_t            requiredAction = 0;
+    t_List              *p_Pos;
     t_CcNodeInformation *p_CcNodeInformation, ccNodeInfo;
-    t_Handle     p_Ad;
-    t_FmPcdCcNode *p_FmPcdCcNode1 = NULL;
-    t_FmPcdCcTree *p_FmPcdCcTree = NULL;
+    t_Handle            p_Ad;
+    t_FmPcdCcNode       *p_FmPcdCcNode1 = NULL;
+    t_FmPcdCcTree       *p_FmPcdCcTree = NULL;
+    t_FmPcdStatsObj     *p_StatsObj;
 
     ASSERT_COND(p_CcNextEngineParams);
 
-    /*check that new NIA is legal*/
-    err = ValidateNextEngineParams(h_FmPcd, p_CcNextEngineParams);
+    /* check that new NIA is legal */
+    if (!p_AdditionalInfo->tree)
+        err = ValidateNextEngineParams(h_FmPcd,
+                                       p_CcNextEngineParams,
+                                       ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->statisticsMode);
+    else
+        /* Statistics are not supported for CC root */
+        err = ValidateNextEngineParams(h_FmPcd,
+                                       p_CcNextEngineParams,
+                                       e_FM_PCD_CC_STATS_MODE_NONE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /*update internal data structure for next engine per index (index - key)*/
-    memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    /* Update internal data structure for next engine per index (index - key) */
+    memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
+           p_CcNextEngineParams,
+           sizeof(t_FmPcdCcNextEngineParams));
 
-    /*check that manip is legal and what requiredAction is necessary for this manip*/
+    /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_CcNextEngineParams->h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(p_CcNextEngineParams,&requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEgine(p_CcNextEngineParams, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
-
     }
 
     if (!p_AdditionalInfo->tree)
@@ -2547,8 +2902,18 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     }
 
     ASSERT_COND(p_Ad);
+
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
+
+    /* If statistics were enabled, this Ad is the statistics Ad. Need to follow its
+       nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,
+       only the actual Nia-Ad should be modified. */
+    if ((!p_AdditionalInfo->tree) &&
+        (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
+        (p_CcNextEngineParams->statisticsEn))
+        ccNodeInfo.h_CcNode = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+
     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -2557,8 +2922,33 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
     IOMemSet32((uint8_t *)p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
-    if (p_CcNextEngineParams)
-        NextStepAd(p_Ad,p_CcNextEngineParams, h_FmPcd);
+    /* If statistics were not enabled before, but requested now -  Allocate a statistics
+       object that holds statistics AD and counters. */
+    if ((!p_AdditionalInfo->tree) &&
+        (!((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
+        (p_CcNextEngineParams->statisticsEn))
+    {
+        p_StatsObj = GetStatsObj((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree);
+        ASSERT_COND(p_StatsObj);
+
+        /* Store allocated statistics object */
+        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+
+        NextStepAd(p_Ad,
+                   p_StatsObj->h_StatsAd,
+                   p_StatsObj->h_StatsCounters,
+                   ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs,
+                   p_CcNextEngineParams,
+                   h_FmPcd);
+    }
+    else
+        NextStepAd(p_Ad,
+                   NULL,
+                   NULL,
+                   NULL,
+                   p_CcNextEngineParams,
+                   h_FmPcd);
+
     ccNodeInfo.h_CcNode = p_Ad;
     EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
@@ -2631,6 +3021,14 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
 
+    /* If statistics were previously enabled, but now are disabled,
+       store the old statistics object to be released */
+    if ((!p_AdditionalInfo->tree) &&
+         (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
+         (!p_CcNextEngineParams->statisticsEn))
+        p_AdditionalInfo->p_StatsObjForRmv =
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj;
+
 #if (DPAA_VERSION >= 11)
         if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
             (p_CcNextEngineParams->params.frParams.h_FrmReplic) &&
@@ -2638,7 +3036,6 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
             p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
-
     return E_OK;
 }
 
@@ -2661,16 +3058,20 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
-        for(i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
+        for (i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
                         p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
+                    else if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj)
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
                     else
-                        p_AdTablePtOnCrntCurrentMdfNode = PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+                        p_AdTablePtOnCrntCurrentMdfNode =
+                                PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
@@ -2705,11 +3106,11 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
 
         /*search in the trees which exact index points on this current modified node for getting AD */
-        for(i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
+        for (i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -2765,7 +3166,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             return NULL;
         }
 
-        if(!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
+        if (!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
            (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
         {
             XX_Free(p_KeyAndNextEngineParams);
@@ -2777,9 +3178,9 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
                p_CcNode->keyAndNextEngineParams,
                256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if(ttlCheck)
+        if (ttlCheck)
         {
-            if((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
                (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
             {
                 XX_Free(p_KeyAndNextEngineParams);
@@ -2788,9 +3189,9 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             }
         }
 
-        if(hashCheck)
+        if (hashCheck)
         {
-            if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
                 XX_Free(p_KeyAndNextEngineParams);
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_GENERIC_IC_HASH_INDEXED can not be used for this operation"));
@@ -2809,7 +3210,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     p_FmPcdModifyCcKeyAdditionalParams =
         (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
-    if(!p_FmPcdModifyCcKeyAdditionalParams)
+    if (!p_FmPcdModifyCcKeyAdditionalParams)
     {
         XX_Free(p_KeyAndNextEngineParams);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
@@ -2822,11 +3223,11 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     while(i < numOfKeys)
     {
-        if((j == keyIndex) && !wasUpdate)
+        if ((j == keyIndex) && !wasUpdate)
         {
-            if(modifyState == e_MODIFY_STATE_ADD)
+            if (modifyState == e_MODIFY_STATE_ADD)
                 j++;
-            else if(modifyState == e_MODIFY_STATE_REMOVE)
+            else if (modifyState == e_MODIFY_STATE_REMOVE)
                 i++;
             wasUpdate = TRUE;
         }
@@ -2844,7 +3245,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else if(modifyState == e_MODIFY_STATE_REMOVE)
+        else if (modifyState == e_MODIFY_STATE_REMOVE)
             i++;
     }
 
@@ -2867,10 +3268,10 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
     t_Handle                    h_NewAd;
 
     /* Building a list of all action descriptors that point to the previous node */
-    if(!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
+    if (!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
         UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
-    if(!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
+    if (!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
         UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
     /* This node must be found as next engine of one of its previous nodes or trees*/
@@ -2878,7 +3279,7 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
 
     /* Building a new action descriptor that points to the modified node */
     h_NewAd = GetNewAd(p_CcNode, FALSE);
-    if(!h_NewAd)
+    if (!h_NewAd)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -2913,19 +3314,73 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
     t_Error err = E_OK;
     int     i = 0;
 
-    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
-        if(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
         {
             err = FmPcdManipCheckParamsWithCcNodeParams(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
                                                         (t_Handle)p_CcNode);
-            if(err)
+            if (err)
                 return err;
         }
     }
 
     return err;
 }
+static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
+                                          uint16_t             frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR],
+                                          uint32_t             *p_NumOfRanges,
+                                          uint32_t             *p_CountersArraySize)
+{
+    uint32_t    i;
+
+    switch (statisticsMode)
+    {
+        case e_FM_PCD_CC_STATS_MODE_NONE:
+            return E_OK;
+
+        case e_FM_PCD_CC_STATS_MODE_FRAME:
+        case e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME:
+            *p_NumOfRanges = 1;
+            *p_CountersArraySize = 2 * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
+            return E_OK;
+
+        case e_FM_PCD_CC_STATS_MODE_RMON:
+            if (frameLengthRanges[0] <= 0)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
+
+            if (frameLengthRanges[0] == 0xFFFF)
+            {
+                *p_NumOfRanges = 1;
+                *p_CountersArraySize = 2 * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
+                return E_OK;
+            }
+
+            for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
+            {
+                if (frameLengthRanges[i-1] >= frameLengthRanges[i])
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Frame length range must be larger at least by 1 from preceding range"));
+
+                /* Stop when last range is reached */
+                if (frameLengthRanges[i] == 0xFFFF)
+                    break;
+            }
+
+            if (frameLengthRanges[i] != 0xFFFF)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
+
+            *p_NumOfRanges = i+1;
+
+            /* Allocate an extra counter for byte count, as counters
+               array always begins with byte count */
+            *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_FLR_COUNT_SIZE;
+
+            return E_OK;
+
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
+    }
+}
 
 static t_Error CheckParams(t_Handle             h_FmPcd,
                            t_FmPcdCcNodeParams  *p_CcNodeParam,
@@ -2937,14 +3392,25 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     t_Error                 err;
     uint32_t                requiredAction = 0;
 
-    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    /* Validate statistics parameters */
+    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     &(p_CcNode->numOfStatsFLRs),
+                                     &(p_CcNode->countersArraySize));
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
+
+    /* Validate next engine parameters on Miss */
+    err = ValidateNextEngineParams(h_FmPcd,
+                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                                   p_CcNode->statisticsMode);
     if (err)
         RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
@@ -2966,11 +3432,13 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(!p_KeyParams->p_Key)
+        if (!p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
 
-        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
-        if(err)
+        err = ValidateNextEngineParams(h_FmPcd,
+                                       &p_KeyParams->ccNextEngineParams,
+                                       p_CcNode->statisticsMode);
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         UpdateGblMask(p_CcNode,
@@ -3043,7 +3511,17 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
     if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
-    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    /* Validate statistics parameters */
+    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     &(p_CcNode->numOfStatsFLRs),
+                                     &(p_CcNode->countersArraySize));
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
+
+    err = ValidateNextEngineParams(h_FmPcd,
+                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                                   p_CcNodeParam->keysParams.statisticsMode);
     if (err)
         RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
 
@@ -3078,7 +3556,9 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         if (memcmp(p_KeyParams->p_Key, &key, 1) != 0)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
 
-        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+        err = ValidateNextEngineParams(h_FmPcd,
+                                       &p_KeyParams->ccNextEngineParams,
+                                       p_CcNodeParam->keysParams.statisticsMode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
@@ -3143,20 +3623,32 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
-    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    /* Validate statistics parameters */
+    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+                                     p_CcNodeParam->keysParams.frameLengthRanges,
+                                     &(p_CcNode->numOfStatsFLRs),
+                                     &(p_CcNode->countersArraySize));
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
+
+    err = ValidateNextEngineParams(h_FmPcd,
+                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                                   p_CcNodeParam->keysParams.statisticsMode);
     if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
+        if (p_KeyParams->p_Mask || p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
-        if((glblMask & (tmp * 16)) == (tmp * 16))
+        if ((glblMask & (tmp * 16)) == (tmp * 16))
         {
-            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+            err = ValidateNextEngineParams(h_FmPcd,
+                                           &p_KeyParams->ccNextEngineParams,
+                                           p_CcNodeParam->keysParams.statisticsMode);
             if (err)
                 RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
 
@@ -3182,8 +3674,10 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
         }
         else
         {
-            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
-            if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+            err = ValidateNextEngineParams(h_FmPcd,
+                                           &p_KeyParams->ccNextEngineParams,
+                                           p_CcNode->statisticsMode);
+            if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
                 RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
@@ -3299,6 +3793,105 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     return ERROR_CODE(E_NOT_FOUND);
 }
 
+static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode *p_CcNode, bool isKeyTblAlloc)
+{
+    uint32_t    shadowSize;
+    t_Error     err;
+
+    /* Calculate keys table maximal size - each entry consists of a key and a mask,
+       (if local mask support is requested) */
+    p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+
+    if (p_CcNode->maskSupport)
+        p_CcNode->keysMatchTableMaxSize *= 2;
+
+    /* Calculate maximal shadow size of this node.
+       All shadow structures will be used for runtime modifications host command.
+       If keys table was allocated for this node, the keys table and next engines table may be
+       modified in run time (entries added or removed), so shadow tables are requires.
+       Otherwise, the only supported runtime modification is a specific next engine update and
+       this requires shadow memory of a single AD */
+
+    /* Shadow size should be enough to hold the following 3 structures:
+     * 1 - an action descriptor */
+    shadowSize = FM_PCD_CC_AD_ENTRY_SIZE;
+
+    if (isKeyTblAlloc)
+    {
+        /* 2 - keys match table, if was allocated for the current node */
+        shadowSize += p_CcNode->keysMatchTableMaxSize;
+
+        /* 3 - next action descriptors table, including one more entry for miss */
+        shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+    }
+
+    /* Update shadow to the calculated size */
+    err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
+    if (err != E_OK)
+    {
+        DeleteNode(p_CcNode);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
+    }
+
+    return E_OK;
+}
+
+static t_Error PreAllocStatsObjs(t_FmPcdCcNode *p_CcNode)
+{
+    t_FmPcdStatsObj     *p_StatsObj;
+    t_Handle            h_FmMuram, h_StatsAd, h_StatsCounters;
+    uint32_t            i;
+
+    h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
+    if (!h_FmMuram)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
+
+    /* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)
+       will be allocated to support runtime modifications */
+    for (i = 0; i < p_CcNode->maxNumOfKeys + 2; i++)
+    {
+        /* Allocate list object structure */
+        p_StatsObj = XX_Malloc(sizeof(t_FmPcdStatsObj));
+        if (!p_StatsObj)
+        {
+            FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Statistics object"));
+        }
+        memset(p_StatsObj, 0, sizeof(t_FmPcdStatsObj));
+
+        /* Allocate statistics AD from MURAM */
+        h_StatsAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                FM_PCD_CC_AD_ENTRY_SIZE,
+                                                FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!h_StatsAd)
+        {
+            FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
+            XX_Free(p_StatsObj);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics ADs"));
+        }
+        IOMemSet32(h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        /* Allocate statistics counters from MURAM */
+        h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                      p_CcNode->countersArraySize,
+                                                      FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!h_StatsCounters)
+        {
+            FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
+            FM_MURAM_FreeMem(h_FmMuram, h_StatsAd);
+            XX_Free(p_StatsObj);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics counters"));
+        }
+        IOMemSet32(h_StatsCounters, 0, p_CcNode->countersArraySize);
+
+        p_StatsObj->h_StatsAd = h_StatsAd;
+        p_StatsObj->h_StatsCounters = h_StatsCounters;
+
+        EnqueueStatsObj(&p_CcNode->availableStatsLst, p_StatsObj);
+    }
+
+    return E_OK;
+}
 
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
@@ -3318,7 +3911,7 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
 
         ASSERT_COND(p_CcInformation->h_CcNode);
 
-        if(p_CcInformation->h_CcNode == h_Info)
+        if (p_CcInformation->h_CcNode == h_Info)
         {
             XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
             return p_CcInformation;
@@ -3373,13 +3966,17 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
     for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation);
         ASSERT_COND(p_CcInformation->h_CcNode);
         if (p_CcInformation->h_CcNode == h_Info)
             break;
     }
 
     if (p_CcInformation)
+    {
         LIST_DelAndInit(&p_CcInformation->node);
+        XX_Free(p_CcInformation);
+    }
 
     if (h_Spinlock)
         XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
@@ -3395,7 +3992,7 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     t_FmPcdCcNextEngineParams   nextEngineParams;
     t_NetEnvParams              netEnvParams;
     t_Handle                    h_Ad;
-    bool                        isIpv6Present, isIpv4Present;
+    bool                        isIpv6Present;
     uint8_t                     ipv4GroupId, ipv6GroupId;
     t_Error                     err;
 
@@ -3403,23 +4000,18 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     /* this routine must be protected by the calling routine! */
 
-    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
-
     memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
     memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
 
     h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    isIpv4Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, FALSE);
-    isIpv6Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, TRUE);
+    isIpv6Present = FmPcdManipIpReassmIsIpv6Hdr(h_IpReassemblyManip);
 
-    netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
-    netEnvParams.numOfDistinctionUnits = 0;
+    if (isIpv6Present && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
-    err = PcdGetUnitsVector(h_FmPcd, &netEnvParams);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
     nextEngineParams.nextEngine = e_FM_PCD_DONE;
     nextEngineParams.h_Manip = h_IpReassemblyManip;
@@ -3446,8 +4038,7 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     if (isIpv6Present)
     {
         ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = 14;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-2);
 
         if (createSchemes)
         {
@@ -3460,34 +4051,41 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
             }
         }
 
-        NextStepAd(PTR_MOVE(h_Ad, 14 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+        NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
+                   NULL,
+                   NULL,
+                   NULL,
+                   &nextEngineParams,
+                   h_FmPcd);
     }
 
-    if (isIpv4Present)
-    {
-        ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = 15;
+    ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = 0;
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-1);
 
-        if (createSchemes)
+    if (createSchemes)
+    {
+        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+        if (err)
         {
-            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
-            if (err)
+            p_FmPcdCcTree->numOfGrps--;
+            if (isIpv6Present)
             {
-                if (isIpv6Present)
-                {
-                    /* Removing both IPv4 and IPv6 groups */
-                    p_FmPcdCcTree->numOfGrps -= 2;
-                    FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
-                }
-                CcRootReleaseLock(p_FmPcdCcTree);
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+                p_FmPcdCcTree->numOfGrps--;
+                FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
             }
+            CcRootReleaseLock(p_FmPcdCcTree);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-
-        NextStepAd(PTR_MOVE(h_Ad, 15 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
 
+    NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+               NULL,
+               NULL,
+               NULL,
+               &nextEngineParams,
+               h_FmPcd);
+
     p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
 
     CcRootReleaseLock(p_FmPcdCcTree);
@@ -3577,7 +4175,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if(p_FmPcd->p_CcShadow)
+    if (p_FmPcd->p_CcShadow)
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
             return ERROR_CODE(E_BUSY);
 
@@ -3588,7 +4186,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
                                        &h_OldPointersLst,
                                        &h_NewPointersLst,
                                        p_ModifyKeyParams);
-    if(err)
+    if (err)
     {
         XX_Free(p_ModifyKeyParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4044,7 +4642,7 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
-    if(grpId >= p_FmPcdCcTree->numOfGrps)
+    if (grpId >= p_FmPcdCcTree->numOfGrps)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
 
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
@@ -4263,7 +4861,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     }
 
     p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc(sizeof(t_FmPcdCcTree));
-    if(!p_FmPcdCcTree)
+    if (!p_FmPcdCcTree)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("PCD tree structure"));
         return NULL;
@@ -4271,8 +4869,8 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree));
     p_FmPcdCcTree->h_FmPcd = h_FmPcd;
 
-    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(16 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
-    memset(p_Params, 0, 16 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    memset(p_Params, 0, FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
 
@@ -4284,7 +4882,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         FmPcdCcIsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
-        if(!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
+        if (!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
@@ -4313,17 +4911,17 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
         p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
         numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
-        if (numOfEntries > 16)
+        if (numOfEntries > FM_PCD_MAX_NUM_OF_CC_GROUPS)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than 16"));
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than %d", FM_PCD_MAX_NUM_OF_CC_GROUPS));
             return NULL;
         }
 
         if (lastOne)
         {
-            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            if (p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
@@ -4353,7 +4951,9 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
         for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
         {
-            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j]);
+            err = ValidateNextEngineParams(h_FmPcd,
+                                           &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                                           e_FM_PCD_CC_STATS_MODE_NONE);
             if (err)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
@@ -4418,11 +5018,16 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
     j = 0;
-    for(i = 0; i < numOfEntries; i++)
+    for (i = 0; i < numOfEntries; i++)
     {
         p_KeyAndNextEngineParams = p_Params+i;
 
-        NextStepAd(p_CcTreeTmp,&p_KeyAndNextEngineParams->nextEngineParams,p_FmPcd);
+        NextStepAd(p_CcTreeTmp,
+                   NULL,
+                   NULL,
+                   NULL,
+                   &p_KeyAndNextEngineParams->nextEngineParams,
+                   p_FmPcd);
 
         p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -4430,14 +5035,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                p_KeyAndNextEngineParams,
                sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
             p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
                                                         (t_Handle)p_FmPcdCcTree,
                                                         p_FmPcdCcNextNode->h_Spinlock);
 
-            if(!p_CcInformation)
+            if (!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcTree;
@@ -4462,13 +5067,13 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         return NULL;
     }
 
-    for(i = 0; i < numOfEntries; i++)
+    for (i = 0; i < numOfEntries; i++)
     {
-        if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
             err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
                                             &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
-            if(err)
+            if (err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
@@ -4539,12 +5144,8 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 #if (DPAA_VERSION >= 11)
         if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
-        {
-             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                       FALSE,
-                                       TRUE,  /* fullUpdate */
-                                       p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode);
-        }
+            FrmReplicGroupUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                                      FALSE);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
@@ -4581,14 +5182,13 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                            grpId,
                                            index,
                                            p_FmPcdCcNextEngineParams);
+    FmPcdLockUnlockAll(p_FmPcd);
+
     if (err)
     {
-        CcRootReleaseLock(p_CcTree);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    FmPcdLockUnlockAll(p_FmPcd);
-
     return E_OK;
 }
 
@@ -4597,16 +5197,16 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
     t_FmPcdCcNode       *p_CcNode, *p_FmPcdCcNextNode;
     t_Error             err = E_OK;
-    uint32_t            tmp, keySize, shadowSize;
+    uint32_t            tmp, keySize;
     bool                glblMask = FALSE;
     t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Handle            p_KeysMatchTblTmp;
-    t_Handle            p_AdTableTmp;
+    t_Handle            h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp, h_StatsFLRs;
     bool                fullField = FALSE;
     ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
     bool                isKeyTblAlloc, fromIc = FALSE;
     uint16_t            numOfKeysToAlloc;
     t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+    t_FmPcdStatsObj     *p_StatsObj;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
@@ -4621,14 +5221,23 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
     memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    p_CcNode->h_FmPcd      = h_FmPcd;
-    p_CcNode->numOfKeys    = p_CcNodeParam->keysParams.numOfKeys;
-    p_CcNode->maxNumOfKeys = p_CcNodeParam->keysParams.maxNumOfKeys;
-    p_CcNode->maskSupport  = p_CcNodeParam->keysParams.maskSupport;
+    p_CcNode->h_FmPcd           = h_FmPcd;
+    p_CcNode->numOfKeys         = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->maxNumOfKeys      = p_CcNodeParam->keysParams.maxNumOfKeys;
+    p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
+    p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
+
+    h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
+    if (!h_FmMuram)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
+        return NULL;
+    }
 
     INIT_LIST(&p_CcNode->ccPrevNodesLst);
     INIT_LIST(&p_CcNode->ccTreeIdLst);
     INIT_LIST(&p_CcNode->ccTreesLst);
+    INIT_LIST(&p_CcNode->availableStatsLst);
 
     p_CcNode->h_Spinlock = XX_InitSpinlock();
     if (!p_CcNode->h_Spinlock)
@@ -4842,57 +5451,79 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     {
         numOfKeysToAlloc = p_CcNode->maxNumOfKeys;
 
-        /* Calculate keys table maximal size - each entry consists of a key and a mask,
-           (if local mask support is requested) */
-        p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+        /* If local mask is currently used, 'keySize' holds local mask size.
+           Otherwise, we need to allocate twice as much memory for future local mask support. */
+        if (p_CcNode->maskSupport && !(p_CcNode->lclMask))
+            numOfKeysToAlloc *= 2;
 
-        if (p_CcNode->maskSupport)
+        err = CalcAndUpdateCcShadow(p_CcNode, isKeyTblAlloc);
+        if (err != E_OK)
         {
-            p_CcNode->keysMatchTableMaxSize *= 2;
-
-            /* If local mask is currently used, 'keySize' holds local mask size.
-               Otherwise, we need to allocate twice as much memory for future local mask support. */
-            if (!(p_CcNode->lclMask))
-                numOfKeysToAlloc *= 2;
+            DeleteNode(p_CcNode);
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
         }
 
-        /* Calculate maximal shadow size of this node.
-           All shadow structures will be used for runtime modifications host command.
-           If keys table was allocated for this node, the keys table and next engines table may be
-           modified in run time (entries added or removed), so shadow tables are requires.
-           Otherwise, the only supported runtime modification is a specific next engine update and
-           this requires shadow memory of a single AD */
-
-        /* Shadow size should be enough to hold the following 3 structures:
-         * 1 - an action descriptor */
-        shadowSize = FM_PCD_CC_AD_ENTRY_SIZE;
-
-        if (isKeyTblAlloc)
+        if (p_CcNodeParam->keysParams.statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
         {
-            /* 2 - keys match table, if was allocated for the current node */
-            shadowSize += p_CcNode->keysMatchTableMaxSize;
-
-            /* 3 - next action descriptors table, including one more entry for miss */
-            shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+            err = PreAllocStatsObjs(p_CcNode);
+            if (err != E_OK)
+            {
+                DeleteNode(p_CcNode);
+                REPORT_ERROR(MAJOR, err, NO_MSG);
+                return NULL;
+            }
         }
 
-        /* Update shadow to the calculated size */
-        err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
-        if (err != E_OK)
+        /* If manipulation will be initialized before this node, it will use the table
+           descriptor in the AD table of previous node and this node will need an extra
+           AD as his table descriptor. */
+        p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                     FM_PCD_CC_AD_ENTRY_SIZE,
+                                                     FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_CcNode->h_Ad)
         {
             DeleteNode(p_CcNode);
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+            return NULL;
         }
     }
     else
         numOfKeysToAlloc = p_CcNode->numOfKeys;
 
+    /* If RMON statistics mode requested, allocate frame length ranges array */
+    if (p_CcNodeParam->keysParams.statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
+    {
+        /* First counter is always 'byte count', so ranges count is smaller by 1 */
+        p_CcNode->h_StatsFLRs =
+                FM_MURAM_AllocMem(h_FmMuram,
+                                  (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
+                                  FM_PCD_CC_AD_TABLE_ALIGN);
+
+        if (!p_CcNode->h_StatsFLRs)
+        {
+            DeleteNode(p_CcNode);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
+            return NULL;
+        }
+
+        /* Initialize using value received from the user */
+        for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
+        {
+            h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
+
+            Mem2IOCpy32(h_StatsFLRs,
+                        &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
+                        FM_PCD_CC_STATS_FLR_SIZE);
+        }
+    }
+
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
     if (isKeyTblAlloc)
     {
         p_CcNode->h_KeysMatchTable =
-            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+            (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                         (uint32_t)(keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1)),
                                          FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_CcNode->h_KeysMatchTable)
@@ -4908,8 +5539,8 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
     /* Allocate action descriptors table */
     p_CcNode->h_AdTable =
-        (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
-                                    (uint32_t)( (numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE),
+        (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                    (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE),
                                     FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_CcNode->h_AdTable)
     {
@@ -4954,20 +5585,68 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
 
         /* Create the next action descriptor in the match table */
-        NextStepAd(p_AdTableTmp, &p_KeyParams->ccNextEngineParams, p_FmPcd);
+        if (p_KeyParams->ccNextEngineParams.statisticsEn)
+        {
+            p_StatsObj = GetStatsObj(p_CcNode);
+            ASSERT_COND(p_StatsObj);
+
+            NextStepAd(p_AdTableTmp,
+                       p_StatsObj->h_StatsAd,
+                       p_StatsObj->h_StatsCounters,
+                       p_CcNode->h_StatsFLRs,
+                       &p_KeyParams->ccNextEngineParams,
+                       p_FmPcd);
+
+            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
+        }
+        else
+        {
+            NextStepAd(p_AdTableTmp,
+                       NULL,
+                       NULL,
+                       NULL,
+                       &p_KeyParams->ccNextEngineParams,
+                       p_FmPcd);
+
+            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
+        }
 
         p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
     }
 
     /* Update next engine for the 'miss' entry */
-    NextStepAd(p_AdTableTmp, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+    if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.statisticsEn)
+    {
+        p_StatsObj = GetStatsObj(p_CcNode);
+        ASSERT_COND(p_StatsObj);
+
+        NextStepAd(p_AdTableTmp,
+                   p_StatsObj->h_StatsAd,
+                   p_StatsObj->h_StatsCounters,
+                   p_CcNode->h_StatsFLRs,
+                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                   p_FmPcd);
+
+        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
+    }
+    else
+    {
+        NextStepAd(p_AdTableTmp,
+                   NULL,
+                   NULL,
+                   NULL,
+                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                   p_FmPcd);
+
+        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
+    }
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
        that points to this node and it should be 0 for full field extraction */
     if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
-    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, FM_PCD_MAX_NUM_OF_KEYS); tmp++)
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
         if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
@@ -4999,18 +5678,8 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
 
     /* Required action for each next engine */
-    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, FM_PCD_MAX_NUM_OF_KEYS); tmp++)
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
-#if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic)
-            && (!(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)))
-            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic,
-                                      TRUE, /* add */
-                                      TRUE, /* fullUpdate */
-                                      p_CcNode);
-#endif /* (DPAA_VERSION >= 11) */
-
         if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
             err = FmPcdCcSetRequiredAction(h_FmPcd,
@@ -5064,16 +5733,8 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
         if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
-            if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                          FALSE,
-                                          FALSE, /* fullUpdate */
-                                          NULL);
-            else
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                          FALSE,
-                                          TRUE,  /* fullUpdate */
-                                          p_CcNode);
+            FrmReplicGroupUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                                      FALSE);
         }
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -5090,7 +5751,6 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -5102,8 +5762,6 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
     if (keyIndex == FM_PCD_LAST_KEY_INDEX)
         keyIndex = p_CcNode->numOfKeys;
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5136,7 +5794,6 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -5144,8 +5801,6 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5231,7 +5886,6 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -5240,8 +5894,6 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5274,7 +5926,6 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_Cc
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -5283,8 +5934,6 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_Cc
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5318,7 +5967,6 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -5327,8 +5975,6 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5365,7 +6011,6 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5375,8 +6020,6 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5386,7 +6029,7 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
     if (GET_ERROR_TYPE(err) != E_OK)
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
+        FmPcdLockUnlockAll(p_FmPcd);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
@@ -5417,7 +6060,6 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5428,8 +6070,6 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5439,7 +6079,7 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
     if (GET_ERROR_TYPE(err) != E_OK)
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
+        FmPcdLockUnlockAll(p_FmPcd);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
@@ -5472,7 +6112,6 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5483,8 +6122,6 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    INIT_LIST(&h_List);
-
     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
@@ -5494,7 +6131,7 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
     if (GET_ERROR_TYPE(err) != E_OK)
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
+        FmPcdLockUnlockAll(p_FmPcd);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
@@ -5609,32 +6246,96 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_AdOfTypeResult    *p_AdResult = NULL;
+    uint32_t            *p_StatsCounters, *p_FrameCounter;
 
     SANITY_CHECK_RETURN_VALUE(p_CcNode, E_INVALID_HANDLE, 0);
 
     if (keyIndex >= p_CcNode->numOfKeys)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("keyIndex > numOfKeys defined for this node"));
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
         return 0;
     }
 
-    p_AdResult = PTR_MOVE(p_CcNode->h_AdTable, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE);
-    ASSERT_COND(p_AdResult);
-
-    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("statistics updated only for entries where next engine not CC"));
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
         return 0;
     }
+    ASSERT_COND(p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj);
 
-    if(!p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.statisticsEn)
-     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("statistics wasn't enable"));
+    if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME) &&
+        (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Frame count is not supported in the statistics mode of this match table"));
         return 0;
     }
 
-    return  GET_UINT32(p_AdResult->res);
+    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+
+    /* The first counter is byte counter */
+    p_FrameCounter = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
+    ASSERT_COND(p_FrameCounter);
+
+    return GET_UINT32(*p_FrameCounter);
+}
+
+t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics)
+{
+    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t            *p_StatsCounters, i;
+
+    if (keyIndex >= p_CcNode->numOfKeys)
+    {
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
+    }
+
+    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
+    {
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
+    }
+
+    ASSERT_COND(p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj);
+
+    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    ASSERT_COND(p_StatsCounters);
+
+    p_KeyStatistics->byteCount = GET_UINT32(*p_StatsCounters);
+
+    for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
+    {
+        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
+
+        p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
+    }
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
+                                               uint8_t                  keySize,
+                                               uint8_t                  *p_Key,
+                                               uint8_t                  *p_Mask,
+                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+{
+    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t            keyIndex;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Mask, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
+
+    err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
+    if (GET_ERROR_TYPE(err) != E_OK)
+    {
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
+                                  "match table of the provided node"));
+    }
+
+    return FM_PCD_MatchTableGetKeyStatistics(h_CcNode, keyIndex, p_KeyStatistics);
 }
 
 t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
@@ -5698,7 +6399,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     }
 
     p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_ExactMatchCcNodeParam)
+    if (!p_ExactMatchCcNodeParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_ExactMatchCcNodeParam"));
         return NULL;
@@ -5706,7 +6407,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     memset(p_ExactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
     p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_IndxHashCcNodeParam)
+    if (!p_IndxHashCcNodeParam)
     {
         XX_Free(p_ExactMatchCcNodeParam);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_IndxHashCcNodeParam"));
@@ -5815,6 +6516,8 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
+    XX_Free(p_HashBuckets);
+
     return E_OK;
 }
 
@@ -5954,3 +6657,35 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
 
     return E_OK;
 }
+
+t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
+                                              uint8_t                  keySize,
+                                              uint8_t                  *p_Key,
+                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        h_HashBucket;
+    uint8_t         bucketIndex;
+    uint16_t        lastIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
+
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
+                                                keySize,
+                                                p_Key,
+                                                p_HashTbl->userOffset,
+                                                &h_HashBucket,
+                                                &bucketIndex,
+                                                &lastIndex);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return FM_PCD_MatchTableFindNGetKeyStatistics(h_HashBucket,
+                                                  keySize,
+                                                  p_Key,
+                                                  NULL,
+                                                  p_KeyStatistics);
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 5ae7bef..1a112c3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -50,6 +50,8 @@
 /*          Coarse classification defines                              */
 /***********************************************************************/
 
+#define CC_MAX_NUM_OF_KEYS                  MAX(FM_PCD_MAX_NUM_OF_KEYS, FM_PCD_MAX_NUM_OF_FLOWS)
+
 #define CC_PC_FF_MACDST                     0x00
 #define CC_PC_FF_MACSRC                     0x01
 #define CC_PC_FF_ETYPE                      0x02
@@ -142,6 +144,8 @@
 #define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
 #define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
 
+#define FM_PCD_AD_BYPASS_TYPE               0xc0000000
+
 #define FM_PCD_AD_TYPE_MASK                 0xc0000000
 #define FM_PCD_AD_OPCODE_MASK               0x0000000f
 
@@ -185,6 +189,14 @@ typedef _Packed struct
     volatile uint32_t gmask;
 } _PackedType t_AdOfTypeContLookup;
 
+typedef _Packed struct
+{
+    volatile uint32_t profileTableAddr;
+    volatile uint32_t reserved;
+    volatile uint32_t nextActionIndx;
+    volatile uint32_t statsTableAddr;
+} _PackedType t_AdOfTypeStats;
+
 typedef _Packed union
 {
     volatile t_AdOfTypeResult        adResult;
@@ -207,6 +219,13 @@ typedef enum e_ModifyState
     e_MODIFY_STATE_CHANGE
 } e_ModifyState;
 
+typedef struct t_FmPcdStatsObj
+{
+    t_Handle        h_StatsAd;
+    t_Handle        h_StatsCounters;
+    t_List          node;
+} t_FmPcdStatsObj;
+
 typedef struct
 {
     uint8_t                     key[FM_PCD_MAX_SIZE_OF_KEY];
@@ -215,6 +234,9 @@ typedef struct
     t_FmPcdCcNextEngineParams   nextEngineParams;
     uint32_t                    requiredAction;
     uint32_t                    shadowAction;
+
+    t_FmPcdStatsObj             *p_StatsObj;
+
 } t_FmPcdCcKeyAndNextEngineParams;
 
 typedef struct
@@ -232,23 +254,24 @@ typedef struct
 
 typedef struct
 {
-    t_Handle    p_AdTableNew;
-    t_Handle    p_KeysMatchTableNew;
-    t_Handle    p_AdTableOld;
-    t_Handle    p_KeysMatchTableOld;
-    uint16_t    numOfKeys;
-    t_Handle    h_CurrentNode;
-    uint16_t    savedKeyIndex;
-    t_Handle    h_NodeForAdd;
-    t_Handle    h_NodeForRmv;
-    t_Handle    h_ManipForRmv;
+    t_Handle        p_AdTableNew;
+    t_Handle        p_KeysMatchTableNew;
+    t_Handle        p_AdTableOld;
+    t_Handle        p_KeysMatchTableOld;
+    uint16_t        numOfKeys;
+    t_Handle        h_CurrentNode;
+    uint16_t        savedKeyIndex;
+    t_Handle        h_NodeForAdd;
+    t_Handle        h_NodeForRmv;
+    t_Handle        h_ManipForRmv;
+    t_FmPcdStatsObj *p_StatsObjForRmv;
 #if (DPAA_VERSION >= 11)
-    t_Handle    h_FrmReplicForAdd;
-    t_Handle    h_FrmReplicForRmv;
+    t_Handle        h_FrmReplicForAdd;
+    t_Handle        h_FrmReplicForRmv;
 #endif /* (DPAA_VERSION >= 11) */
-    bool        tree;
+    bool            tree;
 
-    t_FmPcdCcKeyAndNextEngineParams  keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
+    t_FmPcdCcKeyAndNextEngineParams  keyAndNextEngineParams[CC_MAX_NUM_OF_KEYS];
 } t_FmPcdModifyCcKeyAdditionalParams;
 
 typedef struct
@@ -259,43 +282,50 @@ typedef struct
 
 typedef struct
 {
-    uint16_t    numOfKeys;
-    uint16_t    maxNumOfKeys;
-
-    bool        maskSupport;
-    uint32_t    keysMatchTableMaxSize;
+    uint16_t            numOfKeys;
+    uint16_t            maxNumOfKeys;
+
+    bool                maskSupport;
+    uint32_t            keysMatchTableMaxSize;
+
+    e_FmPcdCcStatsMode  statisticsMode;
+    uint32_t            numOfStatsFLRs;
+    uint32_t            countersArraySize;
+
+    bool                glblMaskUpdated;
+    t_Handle            p_GlblMask;
+    bool                lclMask;
+    uint8_t             parseCode;
+    uint8_t             offset;
+    uint8_t             prsArrayOffset;
+    bool                ctrlFlow;
+    uint8_t             owners;
 
-    bool        glblMaskUpdated;
-    t_Handle    p_GlblMask;
-    bool        lclMask;
-    uint8_t     parseCode;
-    uint8_t     offset;
-    uint8_t     prsArrayOffset;
-    bool        ctrlFlow;
-    uint8_t     owners;
+    uint8_t             ccKeySizeAccExtraction;
+    uint8_t             sizeOfExtraction;
+    uint8_t             glblMaskSize;
 
-    uint8_t     ccKeySizeAccExtraction;
-    uint8_t     sizeOfExtraction;
-    uint8_t     glblMaskSize;
+    t_Handle            h_KeysMatchTable;
+    t_Handle            h_AdTable;
+    t_Handle            h_StatsAds;
+    t_Handle            h_Ad;
+    t_Handle            h_StatsFLRs;
 
-    t_Handle    h_KeysMatchTable;
-    t_Handle    h_AdTable;
-    t_Handle    h_StatsAds;
-    t_Handle    h_Ad;
+    t_List              availableStatsLst;
 
-    t_List      ccPrevNodesLst;
+    t_List              ccPrevNodesLst;
 
-    t_List      ccTreeIdLst;
-    t_List      ccTreesLst;
+    t_List              ccTreeIdLst;
+    t_List              ccTreesLst;
 
-    t_Handle    h_FmPcd;
-    uint32_t    shadowAction;
-    uint8_t     userSizeOfExtraction;
-    uint8_t     userOffset;
+    t_Handle            h_FmPcd;
+    uint32_t            shadowAction;
+    uint8_t             userSizeOfExtraction;
+    uint8_t             userOffset;
 
-    t_Handle    h_Spinlock;
+    t_Handle            h_Spinlock;
 
-    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
+    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[CC_MAX_NUM_OF_KEYS];
 } t_FmPcdCcNode;
 
 typedef struct
@@ -329,7 +359,7 @@ typedef struct
     uint32_t            requiredAction;
     t_Handle            h_IpReassemblyManip;
 
-    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
+    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
 } t_FmPcdCcTree;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 5845a6c..e6591f6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -104,59 +104,59 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
 {
     int i;
 
-    switch(code)
+    switch (code)
     {
-        case( KG_SCH_GEN_PARSE_RESULT_N_FQID):
-        case( KG_SCH_GEN_DEFAULT):
-        case( KG_SCH_GEN_NEXTHDR):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+        case (KG_SCH_GEN_PARSE_RESULT_N_FQID):
+        case (KG_SCH_GEN_DEFAULT):
+        case (KG_SCH_GEN_NEXTHDR):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
             ASSERT_COND(FALSE);
-        case( KG_SCH_GEN_SHIM1):
-        case( KG_SCH_GEN_SHIM2):
-        case( KG_SCH_GEN_IP_PID_NO_V):
-        case( KG_SCH_GEN_ETH_NO_V):
-        case( KG_SCH_GEN_SNAP_NO_V):
-        case( KG_SCH_GEN_VLAN1_NO_V):
-        case( KG_SCH_GEN_VLAN2_NO_V):
-        case( KG_SCH_GEN_ETH_TYPE_NO_V):
-        case( KG_SCH_GEN_PPP_NO_V):
-        case( KG_SCH_GEN_MPLS1_NO_V):
-        case( KG_SCH_GEN_MPLS_LAST_NO_V):
-        case( KG_SCH_GEN_L3_NO_V):
-        case( KG_SCH_GEN_IP2_NO_V):
-        case( KG_SCH_GEN_GRE_NO_V):
-        case( KG_SCH_GEN_L4_NO_V):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+        case (KG_SCH_GEN_SHIM1):
+        case (KG_SCH_GEN_SHIM2):
+        case (KG_SCH_GEN_IP_PID_NO_V):
+        case (KG_SCH_GEN_ETH_NO_V):
+        case (KG_SCH_GEN_SNAP_NO_V):
+        case (KG_SCH_GEN_VLAN1_NO_V):
+        case (KG_SCH_GEN_VLAN2_NO_V):
+        case (KG_SCH_GEN_ETH_TYPE_NO_V):
+        case (KG_SCH_GEN_PPP_NO_V):
+        case (KG_SCH_GEN_MPLS1_NO_V):
+        case (KG_SCH_GEN_MPLS_LAST_NO_V):
+        case (KG_SCH_GEN_L3_NO_V):
+        case (KG_SCH_GEN_IP2_NO_V):
+        case (KG_SCH_GEN_GRE_NO_V):
+        case (KG_SCH_GEN_L4_NO_V):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
 
-        case( KG_SCH_GEN_START_OF_FRM):
-        case( KG_SCH_GEN_ETH):
-        case( KG_SCH_GEN_SNAP):
-        case( KG_SCH_GEN_VLAN1):
-        case( KG_SCH_GEN_VLAN2):
-        case( KG_SCH_GEN_ETH_TYPE):
-        case( KG_SCH_GEN_PPP):
-        case( KG_SCH_GEN_MPLS1):
-        case( KG_SCH_GEN_MPLS2):
-        case( KG_SCH_GEN_MPLS3):
-        case( KG_SCH_GEN_MPLS_LAST):
-        case( KG_SCH_GEN_IPV4):
-        case( KG_SCH_GEN_IPV6):
-        case( KG_SCH_GEN_IPV4_TUNNELED):
-        case( KG_SCH_GEN_IPV6_TUNNELED):
-        case( KG_SCH_GEN_MIN_ENCAP):
-        case( KG_SCH_GEN_GRE):
-        case( KG_SCH_GEN_TCP):
-        case( KG_SCH_GEN_UDP):
-        case( KG_SCH_GEN_IPSEC_AH):
-        case( KG_SCH_GEN_SCTP):
-        case( KG_SCH_GEN_DCCP):
-        case( KG_SCH_GEN_IPSEC_ESP):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+        case (KG_SCH_GEN_START_OF_FRM):
+        case (KG_SCH_GEN_ETH):
+        case (KG_SCH_GEN_SNAP):
+        case (KG_SCH_GEN_VLAN1):
+        case (KG_SCH_GEN_VLAN2):
+        case (KG_SCH_GEN_ETH_TYPE):
+        case (KG_SCH_GEN_PPP):
+        case (KG_SCH_GEN_MPLS1):
+        case (KG_SCH_GEN_MPLS2):
+        case (KG_SCH_GEN_MPLS3):
+        case (KG_SCH_GEN_MPLS_LAST):
+        case (KG_SCH_GEN_IPV4):
+        case (KG_SCH_GEN_IPV6):
+        case (KG_SCH_GEN_IPV4_TUNNELED):
+        case (KG_SCH_GEN_IPV6_TUNNELED):
+        case (KG_SCH_GEN_MIN_ENCAP):
+        case (KG_SCH_GEN_GRE):
+        case (KG_SCH_GEN_TCP):
+        case (KG_SCH_GEN_UDP):
+        case (KG_SCH_GEN_IPSEC_AH):
+        case (KG_SCH_GEN_SCTP):
+        case (KG_SCH_GEN_DCCP):
+        case (KG_SCH_GEN_IPSEC_ESP):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
         default:
             return e_FM_PCD_KG_DFLT_ILLEGAL;
@@ -167,18 +167,18 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 {
     *p_Offset = 0;
 
-    switch(src)
+    switch (src)
     {
-        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+        case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
             return KG_SCH_GEN_START_OF_FRM;
-        case(e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
+        case (e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
             return KG_SCH_GEN_DEFAULT;
-        case(e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
+        case (e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case(e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
+        case (e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
             *p_Offset = 32;
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+        case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
             return KG_SCH_GEN_NEXTHDR;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -188,104 +188,104 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 
 static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
 {
-    if(!ignoreProtocolValidation)
-        switch(hdr)
+    if (!ignoreProtocolValidation)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
+            case (HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP;
-            case(HEADER_TYPE_MPLS):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     return KG_SCH_GEN_MPLS2;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_3)
                     return KG_SCH_GEN_MPLS3;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case(HEADER_TYPE_IPv4):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV4;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV4_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
                 return 0;
-            case(HEADER_TYPE_IPv6):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV6;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV6_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
                 return 0;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE;
-            case(HEADER_TYPE_TCP):
+            case (HEADER_TYPE_TCP):
                 return KG_SCH_GEN_TCP;
-            case(HEADER_TYPE_UDP):
+            case (HEADER_TYPE_UDP):
                 return KG_SCH_GEN_UDP;
-            case(HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_AH):
                 return KG_SCH_GEN_IPSEC_AH;
-            case(HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_IPSEC_ESP):
                 return KG_SCH_GEN_IPSEC_ESP;
-            case(HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_SCTP):
                 return KG_SCH_GEN_SCTP;
-            case(HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_DCCP;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                 return 0;
         }
     else
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
+            case (HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH_NO_V;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP_NO_V;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP_NO_V;
-            case(HEADER_TYPE_MPLS):
-                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1_NO_V;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST_NO_V;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
                 else
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_L3_NO_V;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IP2_NO_V;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
-            case(HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_MINENCAP):
                 return KG_SCH_GEN_IP2_NO_V;
-            case(HEADER_TYPE_USER_DEFINED_L3):
+            case (HEADER_TYPE_USER_DEFINED_L3):
                 return KG_SCH_GEN_L3_NO_V;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE_NO_V;
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_SCTP):
-            case(HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_L4_NO_V;
-            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
                 return KG_SCH_GEN_SHIM1;
-            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
                 return KG_SCH_GEN_SHIM2;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -295,106 +295,106 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
 static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
 {
     if (!ignoreProtocolValidation)
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
-                switch(field.eth)
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-            case(HEADER_TYPE_VLAN):
-                switch(field.vlan)
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
                 {
-                    case(NET_HEADER_FIELD_VLAN_TCI):
-                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case (NET_HEADER_FIELD_VLAN_TCI):
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             return KG_SCH_GEN_VLAN1;
-                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                             return KG_SCH_GEN_VLAN2;
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
-            case(HEADER_TYPE_MPLS):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_LLC_SNAP):
-            case(HEADER_TYPE_PPPoE):
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-            case(HEADER_TYPE_GRE):
-            case(HEADER_TYPE_MINENCAP):
-            case(HEADER_TYPE_USER_DEFINED_L3):
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_SCTP):
-            case(HEADER_TYPE_DCCP):
-            case(HEADER_TYPE_USER_DEFINED_L4):
+            case (HEADER_TYPE_MPLS):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+            case (HEADER_TYPE_GRE):
+            case (HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_USER_DEFINED_L3):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_USER_DEFINED_L4):
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
                 return 0;
         }
         else
-            switch(hdr)
+            switch (hdr)
             {
-                case(HEADER_TYPE_NONE):
+                case (HEADER_TYPE_NONE):
                     ASSERT_COND(FALSE);
-                case(HEADER_TYPE_ETH):
-                switch(field.eth)
+                case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE_NO_V;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-                case(HEADER_TYPE_VLAN):
-                    switch(field.vlan)
+                case (HEADER_TYPE_VLAN):
+                    switch (field.vlan)
                     {
-                        case(NET_HEADER_FIELD_VLAN_TCI) :
-                            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        case (NET_HEADER_FIELD_VLAN_TCI) :
+                            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                                 return KG_SCH_GEN_VLAN1_NO_V;
-                            if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                                 return KG_SCH_GEN_VLAN2_NO_V;
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                             return 0;
                     }
-                case(HEADER_TYPE_IPv4):
-                    switch(field.ipv4)
+                case (HEADER_TYPE_IPv4):
+                    switch (field.ipv4)
                     {
-                        case(NET_HEADER_FIELD_IPv4_PROTO):
+                        case (NET_HEADER_FIELD_IPv4_PROTO):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case(HEADER_TYPE_IPv6):
-                   switch(field.ipv6)
+                case (HEADER_TYPE_IPv6):
+                   switch (field.ipv6)
                     {
-                        case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                        case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case(HEADER_TYPE_MPLS):
-                case(HEADER_TYPE_LLC_SNAP):
-                case(HEADER_TYPE_PPPoE):
-                case(HEADER_TYPE_GRE):
-                case(HEADER_TYPE_MINENCAP):
-                case(HEADER_TYPE_USER_DEFINED_L3):
-                case(HEADER_TYPE_TCP):
-                case(HEADER_TYPE_UDP):
-                case(HEADER_TYPE_IPSEC_AH):
-                case(HEADER_TYPE_IPSEC_ESP):
-                case(HEADER_TYPE_SCTP):
-                case(HEADER_TYPE_DCCP):
-                case(HEADER_TYPE_USER_DEFINED_L4):
+                case (HEADER_TYPE_MPLS):
+                case (HEADER_TYPE_LLC_SNAP):
+                case (HEADER_TYPE_PPPoE):
+                case (HEADER_TYPE_GRE):
+                case (HEADER_TYPE_MINENCAP):
+                case (HEADER_TYPE_USER_DEFINED_L3):
+                case (HEADER_TYPE_TCP):
+                case (HEADER_TYPE_UDP):
+                case (HEADER_TYPE_IPSEC_AH):
+                case (HEADER_TYPE_IPSEC_ESP):
+                case (HEADER_TYPE_SCTP):
+                case (HEADER_TYPE_DCCP):
+                case (HEADER_TYPE_USER_DEFINED_L4):
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
                 default:
@@ -405,39 +405,39 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
 
 static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
 {
-    switch(hdr)
+    switch (hdr)
     {
-        case(HEADER_TYPE_NONE):
+        case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
-        case(HEADER_TYPE_ETH):
-            switch(field.eth)
+        case (HEADER_TYPE_ETH):
+            switch (field.eth)
             {
-                case(NET_HEADER_FIELD_ETH_DA):
+                case (NET_HEADER_FIELD_ETH_DA):
                     return KG_SCH_KN_MACDST;
-                case(NET_HEADER_FIELD_ETH_SA):
+                case (NET_HEADER_FIELD_ETH_SA):
                     return KG_SCH_KN_MACSRC;
-                case(NET_HEADER_FIELD_ETH_TYPE):
+                case (NET_HEADER_FIELD_ETH_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case(HEADER_TYPE_LLC_SNAP):
-            switch(field.llcSnap)
+        case (HEADER_TYPE_LLC_SNAP):
+            switch (field.llcSnap)
             {
-                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                case (NET_HEADER_FIELD_LLC_SNAP_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case(HEADER_TYPE_VLAN):
-            switch(field.vlan)
+        case (HEADER_TYPE_VLAN):
+            switch (field.vlan)
             {
-                case(NET_HEADER_FIELD_VLAN_TCI):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_VLAN_TCI):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_TCI1;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_TCI2;
                     else
                     {
@@ -448,15 +448,15 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_MPLS):
-            switch(field.mpls)
+        case (HEADER_TYPE_MPLS):
+            switch (field.mpls)
             {
-                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_MPLS1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_MPLS2;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_MPLS_LAST;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return 0;
@@ -464,34 +464,34 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPv4):
-            switch(field.ipv4)
+        case (HEADER_TYPE_IPv4):
+            switch (field.ipv4)
             {
-                case(NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_PROTO):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_PROTO):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_TOS):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_TOS):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPTOS_TC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
@@ -499,34 +499,34 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPv6):
-             switch(field.ipv6)
+        case (HEADER_TYPE_IPv6):
+             switch (field.ipv6)
             {
-                case(NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
@@ -534,100 +534,100 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_GRE):
-            switch(field.gre)
+        case (HEADER_TYPE_GRE):
+            switch (field.gre)
             {
-                case(NET_HEADER_FIELD_GRE_TYPE):
+                case (NET_HEADER_FIELD_GRE_TYPE):
                     return KG_SCH_KN_GREPTYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case(HEADER_TYPE_MINENCAP):
-            switch(field.minencap)
+        case (HEADER_TYPE_MINENCAP):
+            switch (field.minencap)
             {
-                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
                     return KG_SCH_KN_IPSRC2;
-                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
                     return KG_SCH_KN_IPDST2;
-                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
                     return KG_SCH_KN_PTYPE2;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case(HEADER_TYPE_TCP):
-            switch(field.tcp)
+        case (HEADER_TYPE_TCP):
+            switch (field.tcp)
             {
-                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
-                case(NET_HEADER_FIELD_TCP_FLAGS):
+                case (NET_HEADER_FIELD_TCP_FLAGS):
                     return KG_SCH_KN_TFLG;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_UDP):
-            switch(field.udp)
+        case (HEADER_TYPE_UDP):
+            switch (field.udp)
             {
-                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPSEC_AH):
-            switch(field.ipsecAh)
+        case (HEADER_TYPE_IPSEC_AH):
+            switch (field.ipsecAh)
             {
-                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
+                case (NET_HEADER_FIELD_IPSEC_AH_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
-                case(NET_HEADER_FIELD_IPSEC_AH_NH):
+                case (NET_HEADER_FIELD_IPSEC_AH_NH):
                     return KG_SCH_KN_IPSEC_NH;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPSEC_ESP):
-            switch(field.ipsecEsp)
+        case (HEADER_TYPE_IPSEC_ESP):
+            switch (field.ipsecEsp)
             {
-                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                case (NET_HEADER_FIELD_IPSEC_ESP_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_SCTP):
-            switch(field.sctp)
+        case (HEADER_TYPE_SCTP):
+            switch (field.sctp)
             {
-                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
+                case (NET_HEADER_FIELD_SCTP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_SCTP_PORT_DST):
+                case (NET_HEADER_FIELD_SCTP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_DCCP):
-            switch(field.dccp)
+        case (HEADER_TYPE_DCCP):
+            switch (field.dccp)
             {
-                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
+                case (NET_HEADER_FIELD_DCCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_DCCP_PORT_DST):
+                case (NET_HEADER_FIELD_DCCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_PPPoE):
-            switch(field.pppoe)
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
             {
-                case(NET_HEADER_FIELD_PPPoE_PID):
+                case (NET_HEADER_FIELD_PPPoE_PID):
                     return KG_SCH_KN_PPPID;
-                case(NET_HEADER_FIELD_PPPoE_SID):
+                case (NET_HEADER_FIELD_PPPoE_SID):
                     return KG_SCH_KN_PPPSID;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -645,7 +645,7 @@ static uint8_t GetKnownFieldId(uint32_t bitMask)
     uint8_t cnt = 0;
 
     while (bitMask)
-        if(bitMask & 0x80000000)
+        if (bitMask & 0x80000000)
             break;
         else
         {
@@ -661,24 +661,24 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
 
     /* bitOffset 1-7 --> mask 0x1-0x7F */
-    if(bitOffset<8)
+    if (bitOffset<8)
     {
         mask = 0;
-        for(i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
+        for (i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
             mask |= walking1Mask;
     }
     else
     {
        mask = 0xFF;
        numOfOnesToClear = 0;
-       if(fqid && bitOffset>24)
+       if (fqid && bitOffset>24)
            /* bitOffset 25-31 --> mask 0xFE-0x80 */
            numOfOnesToClear = (uint8_t)(bitOffset-24);
        else
           /* bitOffset 9-15 --> mask 0xFE-0x80 */
-          if(!fqid && bitOffset>8)
+          if (!fqid && bitOffset>8)
                numOfOnesToClear = (uint8_t)(bitOffset-8);
-       for(i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
+       for (i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
            mask &= ~walking1Mask;
        /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
     }
@@ -721,7 +721,7 @@ static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSche
     p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
     /* for each scheme - update owners counters */
-    for(i = 0; i < p_BindPort->numOfSchemes; i++)
+    for (i = 0; i < p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
         ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
@@ -742,7 +742,7 @@ static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
    ASSERT_COND(p_Scheme);
    ASSERT_COND(p_Scheme->valid);
 
-    if(add)
+    if (add)
         p_Scheme->pointedOwners++;
     else
         p_Scheme->pointedOwners--;
@@ -765,7 +765,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     /* lock a common KG reg */
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
+    if (err)
     {
         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         RETURN_ERROR(MINOR, err, NO_MSG);
@@ -773,7 +773,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
 
     tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
-    if(add)
+    if (add)
         tmpKgpeSp |= spReg;
     else /* clear */
         tmpKgpeSp &= ~spReg;
@@ -862,21 +862,21 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
 
-    if(event & FM_PCD_KG_DOUBLE_ECC)
+    if (event & FM_PCD_KG_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    if (event & FM_PCD_KG_KEYSIZE_OVERFLOW)
     {
-        if(schemeIndexes)
+        if (schemeIndexes)
         {
             while(schemeIndexes)
             {
-                if(schemeIndexes & 0x1)
+                if (schemeIndexes & 0x1)
                     p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
                 schemeIndexes >>= 1;
                 index+=1;
@@ -914,7 +914,7 @@ static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
                                  NULL,
                                  NULL)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
+    if (replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
     memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
 
@@ -937,12 +937,12 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 
     /**********************KGEEER******************/
     tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    if (p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_KG_DOUBLE_ECC;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+    if (p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
         tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
     WRITE_UINT32(p_Regs->kgeeer,tmpReg);
     /**********************KGEEER******************/
@@ -964,7 +964,12 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     /**********************KGGCR******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm,
+                   e_FM_MOD_KG,
+                   0,
+                   e_FM_INTR_TYPE_ERR,
+                   PcdKgErrorException,
+                   p_FmPcd);
 
     /* clear binding between ports to schemes so that all ports are not bound to any schemes */
     for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
@@ -972,11 +977,11 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
         err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -985,13 +990,13 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
 
 
-    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if (p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
         err = FmPcdKgAllocSchemes(p_FmPcd,
                                   p_FmPcd->p_FmPcdKg->numOfSchemes,
                                   p_FmPcd->guestId,
                                   p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1001,1587 +1006,1588 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 static void  ValidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
     ASSERT_COND(!p_Scheme->valid);
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = TRUE;
 }
 
-static t_Error  InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
+static t_Error InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
     if (p_Scheme->owners)
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
 
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = FALSE;
 
     return E_OK;
 }
 
-
-/*****************************************************************************/
-/*              Inter-module API routines                                    */
-/*****************************************************************************/
-t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
+                               t_FmPcdKgSchemeParams    *p_SchemeParams,
+                               t_FmPcdKgSchemeRegs      *p_SchemeRegs)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err = E_OK;
-    uint32_t                        oredVectors = 0;
-    int                             i, j;
-
-    /* this routine is protected by the calling routine ! */
-    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
-
-    /* find a new clsPlan group */
-    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
-        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
-            break;
-    if (i == FM_MAX_NUM_OF_PORTS)
-        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
-
-    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
-
-    p_Grp->clsPlanGrpId = (uint8_t)i;
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
+    uint32_t                            grpBits = 0;
+    uint8_t                             grpBase;
+    bool                                direct=TRUE, absolute=FALSE;
+    uint16_t                            profileId=0, numOfProfiles=0, relativeProfileId;
+    t_Error                             err = E_OK;
+    int                                 i = 0;
+    t_NetEnvParams                      netEnvParams;
+    uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
+    t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash = NULL;
+    uint8_t                             j, curr, idx;
+    uint8_t                             id, shift=0, code=0, offset=0, size=0;
+    t_FmPcdExtractEntry                 *p_Extract = NULL;
+    t_FmPcdKgExtractedOrParams          *p_ExtractOr;
+    bool                                generic = FALSE;
+    t_KnownFieldsMasks                  bitMask;
+    e_FmPcdKgExtractDfltSelect          swDefault = (e_FmPcdKgExtractDfltSelect)0;
+    t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
+    uint8_t                             numOfSwDefaults = 0;
+    t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
+    uint8_t                             currGenId = 0;
 
-    if (p_Grp->numOfOptions == 0)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
+    memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgSchemeRegs));
 
-    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
-    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
-    p_ClsPlanGrp->owners = 0;
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
-    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+    if (p_SchemeParams->netEnvParams.numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("numOfDistinctionUnits should not exceed %d", FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS));
 
-    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1 << p_Grp->numOfOptions);
-    /* a minimal group of 8 is required */
-    if (p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
-        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    /* by netEnv parameters, get match vector */
+    if (!p_SchemeParams->alwaysDirect)
     {
-        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
-
-        if(err)
-            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        p_Scheme->netEnvId = FmPcdGetNetEnvId(p_SchemeParams->netEnvParams.h_NetEnv);
+        netEnvParams.netEnvId = p_Scheme->netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_SchemeParams->netEnvParams.numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, p_SchemeParams->netEnvParams.unitIds, (sizeof(uint8_t))*p_SchemeParams->netEnvParams.numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if (err)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        p_Scheme->matchVector = netEnvParams.vector;
     }
     else
     {
-        t_FmPcdIpcMsg   msg;
-        uint32_t        replyLength;
-        t_FmPcdIpcReply reply;
-
-        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        memset(&kgAlloc, 0, sizeof(kgAlloc));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
-        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(kgAlloc),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-
-        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if ((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
-
-        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
+        p_Scheme->matchVector = SCHEME_ALWAYS_DIRECT;
+        p_Scheme->netEnvId = ILLEGAL_NETENV;
     }
 
-    /* build classification plan entries parameters */
-    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
-    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+    if (p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
 
-    oredVectors = 0;
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    if (p_SchemeParams->bypassFqidGeneration)
     {
-        oredVectors |= p_Grp->optVectors[i];
-        /* save an array of used options - the indexes represent the power of 2 index */
-        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+#ifdef FM_KG_NO_BYPASS_FQID_GEN
+        if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
+#endif /* FM_KG_NO_BYPASS_FQID_GEN */
+        if (p_SchemeParams->baseFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
     }
-    /* set the classification plan relevant entries so that all bits
-     * relevant to the list of options is cleared
-     */
-    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
-        p_ClsPlanSet->vectors[j] = ~oredVectors;
+    else
+        if (!p_SchemeParams->baseFqid)
+            DBG(WARNING, ("baseFqid is 0."));
 
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    if (p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
     {
-       /* option i got the place 2^i in the clsPlan array. all entries that
-         * have bit i set, should have the vector bit cleared. So each option
-         * has one location that it is exclusive (1,2,4,8...) and represent the
-         * presence of that option only, and other locations that represent a
-         * combination of options.
-         * e.g:
-         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
-         * now represents a frame with ethernet-BC header - so the bit
-         * representing ethernet-BC should be set and all other option bits
-         * should be cleared.
-         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
-         * vector[1] set, but they also have other bits set:
-         * 3=1+2, options 0 and 1
-         * 6=2+4, options 1 and 2
-         * 7=1+2+4, options 0,1,and 2
-         * 10=2+8, options 1 and 3
-         * etc.
-         * */
+        direct = p_SchemeParams->kgNextEngineParams.plcrProfile.direct;
+        p_Scheme->directPlcr = direct;
+        absolute = (bool)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
+        if (!direct && absolute)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
 
-        /* now for each option (i), we set their bits in all entries (j)
-         * that contain bit 2^i.
-         */
-        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        if (direct)
         {
-            if(j & (1<<i))
-                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
         }
     }
 
-    return E_OK;
-}
-
-void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
-{
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength;
-    t_FmPcdIpcReply                 reply;
-
-    /* check that no port is bound to this clsPlan */
-    if (p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    if (p_SchemeParams->nextEngine == e_FM_PCD_CC)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
-        return;
-    }
-
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
-
-    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+#ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
+        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        {
+            if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
+        }
+#endif /* FM_KG_NO_BYPASS_PLCR_PROFILE_GEN */
 
-    if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+        err = FmPcdCcGetGrpParams(p_SchemeParams->kgNextEngineParams.cc.h_CcTree,
+                             p_SchemeParams->kgNextEngineParams.cc.grpId,
+                             &grpBits,
+                             &grpBase);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_Scheme->ccUnits = grpBits;
 
-    /* free blocks */
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        KgFreeClsPlanEntries(h_FmPcd,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
-                             p_FmPcd->guestId,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+           (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        {
+                if (p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
+                absolute = FALSE;
+                direct = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.direct;
+                if (direct)
+                {
+                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                    numOfProfiles = 1;
+                }
+                else
+                {
+                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                    shift = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                    numOfProfiles = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+                }
+        }
     }
-    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+
+    /* if policer is used directly after KG, or after CC */
+    if ((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
+       ((p_SchemeParams->nextEngine == e_FM_PCD_CC) &&
+        (p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+        (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
     {
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
-        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
-        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = sizeof(uint32_t);
-        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                (uint8_t*)&msg,
-                                sizeof(msg.msgId) + sizeof(kgAlloc),
-                                (uint8_t*)&reply,
-                                &replyLength,
-                                NULL,
-                                NULL);
-        if (err != E_OK)
+        /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
+        if (absolute)
         {
-            REPORT_ERROR(MINOR, err, NO_MSG);
-            return;
+            /* for absolute direct policy only, */
+            relativeProfileId = profileId;
+            err = FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
+            if (!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
+            p_Scheme->relativeProfileId = profileId;
         }
-        if (replyLength != sizeof(uint32_t))
+        else
         {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            return;
-        }
-        if((t_Error)reply.error != E_OK)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
-            return;
+            /* save relative profile id's for later check */
+            p_Scheme->nextRelativePlcrProfile = TRUE;
+            p_Scheme->relativeProfileId = profileId;
+            p_Scheme->numOfProfiles = numOfProfiles;
         }
     }
-    /* clear clsPlan driver structure */
-    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
-}
-
-t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                j, schemesPerPortVector = 0;
-    t_FmPcdKgScheme         *p_Scheme;
-    uint8_t                 i, relativeSchemeId;
-    uint32_t                tmp, walking1Mask;
-    uint8_t                 swPortIndex = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    else
+    {
+        /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
+        is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
+        if (p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
+        if (p_SchemeParams->bypassFqidGeneration &&
+                p_SchemeParams->useHash &&
+                p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"));
+    }
 
-    /* for each scheme */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    /* configure all 21 scheme registers */
+    tmpReg =  KG_SCH_MODE_EN;
+    switch (p_SchemeParams->nextEngine)
     {
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+        case (e_FM_PCD_PLCR):
+            /* add to mode register - NIA */
+            tmpReg |= KG_SCH_MODE_NIA_PLCR;
+            tmpReg |= NIA_ENG_PLCR;
+            tmpReg |= (uint32_t)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
+            /* initialize policer profile command - */
+            /*  configure kgse_ppc  */
+            if (direct)
+            /* use profileId as base, other fields are 0 */
+                p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+            else
+            {
+                if (shift > MAX_PP_SHIFT)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
 
-        if(add)
-        {
-            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
-            /* check netEnvId  of the port against the scheme netEnvId */
-            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+                if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
-            /* if next engine is private port policer profile, we need to check that it is valid */
-            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
-            if(p_Scheme->nextRelativePlcrProfile)
-            {
-                for(j = 0;j<p_Scheme->numOfProfiles;j++)
-                {
-                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
-                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
-                }
+                ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                ppcTmp |= (uint32_t)profileId;
+
+                p_SchemeRegs->kgse_ppc = ppcTmp;
             }
-            if(!p_BindPort->useClsPlan)
-            {
-                /* This check may be redundant as port is a assigned to the whole NetEnv */
+            break;
+        case (e_FM_PCD_CC):
+            /* mode reg - define NIA */
+            tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
 
-                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
-                cls plan options. Schemes that are used only directly, should not be checked.
-                it also may not be bound to schemes that go to CC with units that are options  - so we OR
-                the match vector and the grpBits (= ccUnits) */
-                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+            p_SchemeRegs->kgse_ccbs = grpBits;
+            tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
+
+            if (p_SchemeParams->kgNextEngineParams.cc.plcrNext)
+            {
+                if (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
                 {
-                    walking1Mask = 0x80000000;
-                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
-                    tmp |= p_Scheme->ccUnits;
-                    while (tmp)
+                    /* find out if absolute or relative */
+                    if (absolute)
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
+                    if (direct)
                     {
-                        if(tmp & walking1Mask)
-                        {
-                            tmp &= ~walking1Mask;
-                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
-                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
-                        }
-                        walking1Mask >>= 1;
+                        /* mask = 0, base = directProfileId */
+                        p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+                    }
+                    else
+                    {
+                        if (shift > MAX_PP_SHIFT)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+                        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                        ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                        ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                        ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                        ppcTmp |= (uint32_t)profileId;
+
+                        p_SchemeRegs->kgse_ppc = ppcTmp;
                     }
                 }
+                else
+                    ppcTmp = KG_SCH_PP_NO_GEN;
             }
-        }
-        /* build vector */
-        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+            break;
+        case (e_FM_PCD_DONE):
+            if (p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+                tmpReg |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
+            else
+                tmpReg |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
+            break;
+        default:
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
     }
+    p_SchemeRegs->kgse_mode = tmpReg;
 
-    *p_SpReg = schemesPerPortVector;
-
-    return E_OK;
-}
-
-t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                spReg;
-    t_Error                 err = E_OK;
-
-    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    IncSchemeOwners(p_FmPcd, p_SchemeBind);
-
-    return E_OK;
-}
-
-t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                spReg;
-    t_Error                 err = E_OK;
+    p_SchemeRegs->kgse_mv = p_Scheme->matchVector;
 
-    err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+#if (DPAA_VERSION >= 11)
+    if (p_SchemeParams->overrideStorageProfile)
+    {
+        p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
 
-    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        tmpReg = 0;
+        if (p_SchemeParams->storageProfile.direct)
+        {
+            profileId = p_SchemeParams->storageProfile.profileSelect.directRelativeProfileId;
+            shift = 0;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_SchemeParams->storageProfile.profileSelect.indirectProfile.numOfProfiles;
+        }
+        if (shift > MAX_SP_SHIFT)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_SP_SHIFT));
 
-    DecSchemeOwners(p_FmPcd, p_SchemeBind);
+        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
-    return E_OK;
-}
+        tmpReg = (uint32_t)shift << KG_SCH_VSP_SHIFT;
+        tmpReg |= ((uint32_t)(numOfProfiles-1) << KG_SCH_VSP_MASK_SHIFT);
+        tmpReg |= (uint32_t)profileId;
 
-bool FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
-    return p_Scheme->valid;
-}
+        p_SchemeRegs->kgse_vsp = tmpReg;
 
-bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+        p_Scheme->vspe = TRUE;
 
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
-        return TRUE;
+    }
     else
-        return FALSE;
-}
+        p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
+#endif /* (DPAA_VERSION >= 11) */
 
-t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint8_t             i, j;
+    if (p_SchemeParams->useHash)
+    {
+        p_KeyAndHash = &p_SchemeParams->keyExtractAndHashParams;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+        if (p_KeyAndHash->numOfUsedExtracts >= FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfUsedExtracts out of range"));
 
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC, so no need for lock */
+        /*  configure kgse_dv0  */
+        p_SchemeRegs->kgse_dv0 = p_KeyAndHash->privateDflt0;
 
-    for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
-    {
-        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
-        {
-            p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
-            p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = guestId;
-            p_SchemesIds[j] = i;
-            j++;
-        }
-    }
+        /*  configure kgse_dv1  */
+        p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
 
-    if (j != numOfSchemes)
-    {
-        /* roll back */
-        for(j--; j; j--)
+        if (!p_SchemeParams->bypassFqidGeneration)
         {
-            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].allocated = FALSE;
-            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
-            p_SchemesIds[j] = 0;
+            if (!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
+            if ((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
+                DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
         }
 
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
-    }
-
-    return E_OK;
-}
-
-t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint8_t             i;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC */
-
-    for (i = 0; i < numOfSchemes; i++)
-    {
-        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        /*  configure kgse_ekdv  */
+        tmpReg = 0;
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
         {
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+            switch (p_KeyAndHash->dflts[i].type)
+            {
+                case (e_FM_PCD_KG_MAC_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_TCI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_ENET_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_PPP_SESSION_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_MPLS_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_IP_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_PROTOCOL_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_IP_TOS_TC):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_IPSEC_SPI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_L4_PORT):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_TCP_FLAG):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
+                    break;
+                case (e_FM_PCD_KG_GENERIC_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case (e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case (e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                   break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
         }
-        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        p_SchemeRegs->kgse_ekdv = tmpReg;
+
+        p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
+        if (!p_LocalExtractsArray)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+
+        /*  configure kgse_ekfc and  kgse_gec */
+        knownTmp = 0;
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+            p_Extract = &p_KeyAndHash->extractArray[i];
+            switch (p_Extract->type)
+            {
+                case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                    knownTmp |= KG_SCH_KN_PORT_ID;
+                    /* save in driver structure */
+                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
+                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                    break;
+                case (e_FM_PCD_EXTRACT_BY_HDR):
+                    switch (p_Extract->extractByHdr.hdr)
+                    {
+                        case (HEADER_TYPE_UDP_ENCAP_ESP):
+                            switch (p_Extract->extractByHdr.type)
+                            {
+                                case (e_FM_PCD_EXTRACT_FROM_HDR):
+                                    /* case where extraction from ESP only */
+                                    if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
+                                    {
+                                        p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                        p_Extract->extractByHdr.extractByHdrType.fromHdr.offset -= UDP_HEADER_SIZE;
+                                        p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                    }
+                                    else
+                                    {
+                                        p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                        p_Extract->extractByHdr.ignoreProtocolValidation = FALSE;
+                                    }
+                                    break;
+                                case (e_FM_PCD_EXTRACT_FROM_FIELD):
+                                    switch (p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
+                                    {
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                            break;
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                    }
+                                    break;
+                                case (e_FM_PCD_EXTRACT_FULL_FIELD):
+                                    switch (p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
+                                    {
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                            break;
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SEQ_NUM_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                    }
+                                    break;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    switch (p_Extract->extractByHdr.type)
+                    {
+                        case (e_FM_PCD_EXTRACT_FROM_HDR):
+                            generic = TRUE;
+                            /* get the header code for the generic extract */
+                            code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
+                            /* set generic register fields */
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
+                            break;
+                        case (e_FM_PCD_EXTRACT_FROM_FIELD):
+                            generic = TRUE;
+                            /* get the field code for the generic extract */
+                            code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
+                                        p_Extract->extractByHdr.extractByHdrType.fromField.field, p_Extract->extractByHdr.ignoreProtocolValidation,p_Extract->extractByHdr.hdrIndex);
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                            break;
+                        case (e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if (!p_Extract->extractByHdr.ignoreProtocolValidation)
+                            {
+                                /* if we have a known field for it - use it, otherwise use generic */
+                                bitMask = GetKnownProtMask(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
+                                            p_Extract->extractByHdr.extractByHdrType.fullField);
+                                if (bitMask)
+                                {
+                                    knownTmp |= bitMask;
+                                    /* save in driver structure */
+                                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(bitMask);
+                                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                                }
+                                else
+                                    generic = TRUE;
+
+                            }
+                            else
+                                generic = TRUE;
+                            if (generic)
+                            {
+                                /* tmp - till we cover more headers under generic */
+                                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
+                            }
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                case (e_FM_PCD_EXTRACT_NON_HDR):
+                    /* use generic */
+                    generic = TRUE;
+                    offset = 0;
+                    /* get the field code for the generic extract */
+                    code = GetGenCode(p_Extract->extractNonHdr.src, &offset);
+                    offset += p_Extract->extractNonHdr.offset;
+                    size = p_Extract->extractNonHdr.size;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+
+            if (generic)
+            {
+                /* set generic register fields */
+                if (currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                    RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                if (!code)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+
+                genTmp = KG_SCH_GEN_VALID;
+                genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+                genTmp |= offset;
+                if ((size > MAX_KG_SCH_SIZE) || (size < 1))
+                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
+                swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
+                if (swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                    DBG(WARNING, ("No sw default configured"));
+
+                genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
+                genTmp |= KG_SCH_GEN_MASK;
+                p_SchemeRegs->kgse_gec[currGenId] = genTmp;
+                /* save in driver structure */
+                p_LocalExtractsArray->extractsArray[i].id = currGenId++;
+                p_LocalExtractsArray->extractsArray[i].known = FALSE;
+                generic = FALSE;
+            }
         }
-        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
-        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
-    }
+        p_SchemeRegs->kgse_ekfc = knownTmp;
 
-    return E_OK;
-}
+        selectTmp = 0;
+        maskTmp = 0xFFFFFFFF;
+        /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
 
-t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint8_t     numOfBlocks, blocksFound=0, first=0;
-    uint8_t     i, j;
+        if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        {
+            /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
+            id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
+            /* Get the shift of the select field (depending on i) */
+            GET_MASK_SEL_SHIFT(shift,i);
+            if (p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].known)
+                selectTmp |= id << shift;
+            else
+                selectTmp |= (id + MASK_FOR_GENERIC_BASE_ID) << shift;
 
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC, so no need for lock */
+            /* Get the shift of the offset field (depending on i) - may
+               be in  kgse_bmch or in kgse_fqb (depending on i) */
+            GET_MASK_OFFSET_SHIFT(shift,i);
+            if (i<=1)
+                selectTmp |= p_KeyAndHash->masks[i].offset << shift;
+            else
+                fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
 
-    if(!numOfClsPlanEntries)
-        return E_OK;
+            /* Get the shift of the mask field (depending on i) */
+            GET_MASK_SHIFT(shift,i);
+            /* pass all bits */
+            maskTmp |= KG_SCH_BITMASK_MASK << shift;
+            /* clear bits that need masking */
+            maskTmp &= ~(0xFF << shift) ;
+            /* set mask bits */
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
+        }
+        p_SchemeRegs->kgse_bmch = selectTmp;
+        p_SchemeRegs->kgse_bmcl = maskTmp;
+        /* kgse_fqb will be written t the end of the routine */
 
-    if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+        /*  configure kgse_hc  */
+        if (p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        if (p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
 
-    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+        tmpReg = 0;
 
-    /* try to find consequent blocks */
-    first = 0;
-    for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
-    {
-        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
+        tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+
+        if (p_KeyAndHash->symmetricHash)
         {
-            blocksFound++;
-            i++;
-            if (blocksFound == numOfBlocks)
-                break;
+            if ((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
+            tmpReg |= KG_SCH_HASH_CONFIG_SYM;
         }
-        else
+        p_SchemeRegs->kgse_hc = tmpReg;
+
+        /* build the return array describing the order of the extractions */
+
+        /* the last currGenId places of the array
+           are for generic extracts that are always last.
+           We now sort for the calculation of the order of the known
+           extractions we sort the known extracts between orderedArray[0] and
+           orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].
+           for the calculation of the order of the generic extractions we use:
+           num_of_generic - currGenId
+           num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
+           first_generic_index = num_of_known */
+        curr = 0;
+        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
-            blocksFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfBlocks);
+            if (p_LocalExtractsArray->extractsArray[i].known)
+            {
+                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
+                j = curr;
+                /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
+                index in the user's extractions array */
+                /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
+                location */
+                while((j > 0) && (p_LocalExtractsArray->extractsArray[i].id <
+                      p_LocalExtractsArray->extractsArray[p_Scheme->orderedArray[j-1]].id))
+                {
+                    p_Scheme->orderedArray[j] =
+                        p_Scheme->orderedArray[j-1];
+                    j--;
+                }
+                p_Scheme->orderedArray[j] = (uint8_t)i;
+                curr++;
+            }
+            else
+            {
+                /* index is first_generic_index + generic index (id) */
+                idx = (uint8_t)(p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id);
+                ASSERT_COND(idx < FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY);
+                p_Scheme->orderedArray[idx]= (uint8_t)i;
+            }
         }
-    }
+        XX_Free(p_LocalExtractsArray);
+        p_LocalExtractsArray = NULL;
 
-    if (blocksFound == numOfBlocks)
-    {
-        *p_First = (uint8_t)(first * CLS_PLAN_NUM_PER_GRP);
-        for (j = first; j < (first + numOfBlocks); j++)
-        {
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
-        }
-        return E_OK;
     }
     else
-        RETURN_ERROR(MINOR, E_FULL, ("No resources for clsPlan"));
-}
+    {
+        /* clear all unused registers: */
+        p_SchemeRegs->kgse_ekfc = 0;
+        p_SchemeRegs->kgse_ekdv = 0;
+        p_SchemeRegs->kgse_bmch = 0;
+        p_SchemeRegs->kgse_bmcl = 0;
+        p_SchemeRegs->kgse_hc = 0;
+        p_SchemeRegs->kgse_dv0 = 0;
+        p_SchemeRegs->kgse_dv1 = 0;
+    }
 
-void KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     numOfBlocks;
-    uint8_t     i, baseBlock;
+    if (p_SchemeParams->bypassFqidGeneration)
+        p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
 
-#ifdef DISABLE_ASSERTIONS
-UNUSED(guestId);
-#endif /* DISABLE_ASSERTIONS */
+    /*  configure kgse_spc  */
+    if ( p_SchemeParams->schemeCounter.update)
+        p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC, so no need for lock */
 
-    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
-    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
+    /* check that are enough generic registers */
+    if (p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
-    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
+    /* extracted OR mask on Qid */
+    for ( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
     {
-        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
-        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
-    }
-}
 
-void KgEnable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+        p_Scheme->extractedOrs = TRUE;
+        /*  configure kgse_gec[i]  */
+        p_ExtractOr = &p_SchemeParams->extractedOrs[i];
+        switch (p_ExtractOr->type)
+        {
+            case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
+                offset = 0;
+                break;
+            case (e_FM_PCD_EXTRACT_BY_HDR):
+                /* get the header code for the generic extract */
+                code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
+                /* set generic register fields */
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            case (e_FM_PCD_EXTRACT_NON_HDR):
+                /* get the field code for the generic extract */
+                offset = 0;
+                code = GetGenCode(p_ExtractOr->src, &offset);
+                offset += p_ExtractOr->extractionOffset;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+        }
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
-}
+        /* set generic register fields */
+        if (!code)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+        genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
+        genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+        genTmp |= offset;
+        if (!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
 
-void KgDisable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+        /************************************************************************************
+            bitOffsetInFqid and bitOffsetInPolicerProfile are translated to rotate parameter
+            in the following way:
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
-}
+            Driver API and implementation:
+            ==============================
+            FQID: extracted OR byte may be shifted right 1-31 bits to effect parts of the FQID.
+            if shifted less than 8 bits, or more than 24 bits a mask is set on the bits that
+            are not overlapping FQID.
+                     ------------------------
+                    |      FQID (24)         |
+                     ------------------------
+            --------
+           |        |  extracted OR byte
+            --------
 
-void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, intFlags;
-    uint16_t                i, j;
+            Policer Profile: extracted OR byte may be shifted right 1-15 bits to effect parts of the
+            PP id. Unless shifted exactly 8 bits to overlap the PP id, a mask is set on the bits that
+            are not overlapping PP id.
 
-    /* This routine is protected by the calling routine ! */
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+                     --------
+                    | PP (8) |
+                     --------
+            --------
+           |        |  extracted OR byte
+            --------
 
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
-    {
-        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+            HW implementation
+            =================
+            FQID and PP construct a 32 bit word in the way describe below. Extracted byte is located
+            as the highest byte of that word and may be rotated to effect any part os the FQID or
+            the PP.
+             ------------------------  --------
+            |      FQID (24)         || PP (8) |
+             ------------------------  --------
+             --------
+            |        |  extracted OR byte
+             --------
 
-        for (j = i; j < i+8; j++)
+        ************************************************************************************/
+
+        if (p_ExtractOr->bitOffsetInFqid)
         {
-            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
-            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+            if (p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
+            if (p_ExtractOr->bitOffsetInFqid<8)
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
+            else
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInFqid, TRUE);
         }
-
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        else /* effect policer profile */
         {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
-            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-            return;
+            if (p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
+            p_Scheme->bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
+            genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInPlcrProfile, FALSE);
         }
+
+        genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
+        /* clear bits that need masking */
+        genTmp &= ~KG_SCH_GEN_MASK ;
+        /* set mask bits */
+        genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
+        p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
+
     }
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+    /* clear all unused GEC registers */
+    for ( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        p_SchemeRegs->kgse_gec[i] = 0;
+
+    /* add base Qid for this scheme */
+    /* add configuration for kgse_fqb */
+    if (p_SchemeParams->baseFqid & ~0x00FFFFFF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
+
+    fqbTmp |= p_SchemeParams->baseFqid;
+    p_SchemeRegs->kgse_fqb = fqbTmp;
+
+    p_Scheme->nextEngine = p_SchemeParams->nextEngine;
+    p_Scheme->doneAction = p_SchemeParams->kgNextEngineParams.doneAction;
+
+    return E_OK;
 }
 
-t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
 {
-    t_FmPcdKg   *p_FmPcdKg;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err = E_OK;
+    uint32_t                        oredVectors = 0;
+    int                             i, j;
 
-    UNUSED(p_FmPcd);
+    /* this routine is protected by the calling routine ! */
+    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
 
-    if (p_FmPcdParams->numOfSchemes > FM_PCD_KG_NUM_OF_SCHEMES)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("numOfSchemes should not exceed %d", FM_PCD_KG_NUM_OF_SCHEMES));
-        return NULL;
-    }
+    /* find a new clsPlan group */
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+        if (!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if (i == FM_MAX_NUM_OF_PORTS)
+        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
 
-    p_FmPcdKg = (t_FmPcdKg *)XX_Malloc(sizeof(t_FmPcdKg));
-    if (!p_FmPcdKg)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Keygen allocation FAILED"));
-        return NULL;
-    }
-    memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
 
-    if(FmIsMaster(p_FmPcd->h_Fm))
-    {
-        p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
-        p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
-    }
+    p_Grp->clsPlanGrpId = (uint8_t)i;
 
-    p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
-    if((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
+    if (p_Grp->numOfOptions == 0)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
+    p_ClsPlanGrp->owners = 0;
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
+    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1 << p_Grp->numOfOptions);
+    /* a minimal group of 8 is required */
+    if (p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
-        p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
-        DBG(WARNING, ("numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"));
+        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+
+        if (err)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
     }
+    else
+    {
+        t_FmPcdIpcMsg   msg;
+        uint32_t        replyLength;
+        t_FmPcdIpcReply reply;
 
-    p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        memset(&kgAlloc, 0, sizeof(kgAlloc));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(kgAlloc),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return p_FmPcdKg;
-}
+        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if ((t_Error)reply.error != E_OK)
+            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
 
-t_Error KgInit(t_FmPcd *p_FmPcd)
-{
-    t_Error err = E_OK;
+        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
+    }
 
-    p_FmPcd->p_FmPcdKg->h_HwSpinlock = XX_InitSpinlock();
-    if (!p_FmPcd->p_FmPcdKg->h_HwSpinlock)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG HW spinlock"));
+    /* build classification plan entries parameters */
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
-        err =  KgInitMaster(p_FmPcd);
-    else
-        err =  KgInitGuest(p_FmPcd);
+    oredVectors = 0;
+    for (i = 0; i<p_Grp->numOfOptions; i++)
+    {
+        oredVectors |= p_Grp->optVectors[i];
+        /* save an array of used options - the indexes represent the power of 2 index */
+        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+    }
+    /* set the classification plan relevant entries so that all bits
+     * relevant to the list of options is cleared
+     */
+    for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    if(err != E_OK)
+    for (i = 0; i<p_Grp->numOfOptions; i++)
     {
-        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
+       /* option i got the place 2^i in the clsPlan array. all entries that
+         * have bit i set, should have the vector bit cleared. So each option
+         * has one location that it is exclusive (1,2,4,8...) and represent the
+         * presence of that option only, and other locations that represent a
+         * combination of options.
+         * e.g:
+         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
+         * now represents a frame with ethernet-BC header - so the bit
+         * representing ethernet-BC should be set and all other option bits
+         * should be cleared.
+         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
+         * vector[1] set, but they also have other bits set:
+         * 3=1+2, options 0 and 1
+         * 6=2+4, options 1 and 2
+         * 7=1+2+4, options 0,1,and 2
+         * 10=2+8, options 1 and 3
+         * etc.
+         * */
+
+        /* now for each option (i), we set their bits in all entries (j)
+         * that contain bit 2^i.
+         */
+        for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        {
+            if (j & (1<<i))
+                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+        }
     }
 
-    return err;
+    return E_OK;
 }
 
-t_Error KgFree(t_FmPcd *p_FmPcd)
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 {
-    t_FmPcdIpcKgSchemesParams       kgAlloc;
-    t_Error                         err = E_OK;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err;
     t_FmPcdIpcMsg                   msg;
     uint32_t                        replyLength;
     t_FmPcdIpcReply                 reply;
 
-    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
-
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    /* check that no port is bound to this clsPlan */
+    if (p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
     {
-        err = FmPcdKgFreeSchemes(p_FmPcd,
-                                    p_FmPcd->p_FmPcdKg->numOfSchemes,
-                                    p_FmPcd->guestId,
-                                    p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-
-        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-
-        return E_OK;
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+        return;
     }
 
-    /* guest */
-    memset(&reply, 0, sizeof(reply));
-    memset(&msg, 0, sizeof(msg));
-    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
-    kgAlloc.guestId = p_FmPcd->guestId;
-    ASSERT_COND(kgAlloc.numOfSchemes < FM_PCD_KG_NUM_OF_SCHEMES);
-    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds, (sizeof(uint8_t))*kgAlloc.numOfSchemes);
-    msg.msgId = FM_PCD_FREE_KG_SCHEMES;
-    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-    replyLength = sizeof(uint32_t);
-    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId) + sizeof(kgAlloc),
-                                 (uint8_t*)&reply,
-                                 &replyLength,
-                                 NULL,
-                                 NULL)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if (replyLength != sizeof(uint32_t))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-
-    if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
-        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-
-    return (t_Error)reply.error;
-}
-
-t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp)
-{
-    t_FmPcd                                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdKgInterModuleClsPlanGrpParams    grpParams, *p_GrpParams;
-    t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
-    t_FmPcdKgInterModuleClsPlanSet          *p_ClsPlanSet;
-    t_Error                                 err;
-
-    /* This function is issued only from FM_PORT_SetPcd which locked all PCD modules,
-       so no need for lock here */
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
 
-    memset(&grpParams, 0, sizeof(grpParams));
-    grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
-    p_GrpParams = &grpParams;
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
 
-    p_GrpParams->netEnvId = netEnvId;
+    if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
 
-    /* Get from the NetEnv the information of the clsPlan (can be already created,
-     * or needs to build) */
-    err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
-    if(err)
-        RETURN_ERROR(MINOR,err,NO_MSG);
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
 
-    if(p_GrpParams->grpExists)
+    /* free blocks */
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
-        /* this group was already updated (at least) in SW */
-        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+        KgFreeClsPlanEntries(h_FmPcd,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
+                             p_FmPcd->guestId,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
     }
-    else
+    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
     {
-        p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
-        if (!p_ClsPlanSet)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
-        memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
-        /* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
-        err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
-        if (err)
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(kgAlloc),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
         {
-            XX_Free(p_ClsPlanSet);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
         }
-        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+        if (replyLength != sizeof(uint32_t))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return;
+        }
+        if ((t_Error)reply.error != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
+            return;
+        }
+    }
+}
 
-        if (p_FmPcd->h_Hc)
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint8_t                 swPortIndex = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for (i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+        if (add)
         {
-            /* write clsPlan entries to memory */
-            err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_ClsPlanSet);
-            if (err)
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if ((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
+            if (p_Scheme->nextRelativePlcrProfile)
             {
-                XX_Free(p_ClsPlanSet);
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+                for (j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
+                    if (p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if (!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
             }
-        }
-        else
-            /* write clsPlan entries to memory */
-            KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
+            if (!p_BindPort->useClsPlan)
+            {
+                /* This check may be redundant as port is a assigned to the whole NetEnv */
 
-        XX_Free(p_ClsPlanSet);
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if (tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
     }
 
-    /* Set caller parameters     */
+    *p_SpReg = schemesPerPortVector;
 
-    /* mark if this is an empty classification group */
-    if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
-        *p_IsEmptyClsPlanGrp = TRUE;
-    else
-        *p_IsEmptyClsPlanGrp = FALSE;
+    return E_OK;
+}
 
-    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
+t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
 
-   /* increment owners number */
-    p_ClsPlanGrp->owners++;
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /* copy options array for port */
-    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /* bind port to the new or existing group */
-    err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+    IncSchemeOwners(p_FmPcd, p_SchemeBind);
 
     return E_OK;
 }
 
-t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
-    t_FmPcdKgInterModuleClsPlanSet  *p_ClsPlanSet;
-    t_Error                         err;
-
-    /* This function is issued only from FM_PORT_DeletePcd which locked all PCD modules,
-       so no need for lock here */
-
-    UnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
 
-    /* decrement owners number */
-    ASSERT_COND(p_ClsPlanGrp->owners);
-    p_ClsPlanGrp->owners--;
+    err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if (!p_ClsPlanGrp->owners)
-    {
-        if (p_FmPcd->h_Hc)
-        {
-            err = FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
-            return err;
-        }
-        else
-        {
-            /* clear clsPlan entries in memory */
-            p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
-            if (!p_ClsPlanSet)
-            {
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
-            }
-            memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-            p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
-            p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
-            KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
-            XX_Free(p_ClsPlanSet);
+    DecSchemeOwners(p_FmPcd, p_SchemeBind);
 
-            FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
-       }
-    }
     return E_OK;
 }
 
-t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
+bool FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
 {
-    t_FmPcdKgScheme                     *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
-    uint32_t                            grpBits = 0;
-    uint8_t                             grpBase;
-    bool                                direct=TRUE, absolute=FALSE;
-    uint16_t                            profileId=0, numOfProfiles=0, relativeProfileId;
-    t_Error                             err = E_OK;
-    int                                 i = 0;
-    t_NetEnvParams                      netEnvParams;
-    uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
-    t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash = NULL;
-    uint8_t                             j, curr, idx;
-    uint8_t                             id, shift=0, code=0, offset=0, size=0;
-    t_FmPcdExtractEntry                 *p_Extract = NULL;
-    t_FmPcdKgExtractedOrParams          *p_ExtractOr;
-    bool                                generic = FALSE;
-    t_KnownFieldsMasks                  bitMask;
-    e_FmPcdKgExtractDfltSelect          swDefault = (e_FmPcdKgExtractDfltSelect)0;
-    t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
-    uint8_t                             numOfSwDefaults = 0;
-    t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
-    uint8_t                             currGenId = 0;
+    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
-    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
-    memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    return p_Scheme->valid;
+}
 
-    if (p_SchemeParams->netEnvParams.numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("numOfDistinctionUnits should not exceed %d", FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS));
+bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    /* by netEnv parameters, get match vector */
-    if(!p_SchemeParams->alwaysDirect)
-    {
-        p_Scheme->netEnvId = FmPcdGetNetEnvId(p_SchemeParams->netEnvParams.h_NetEnv);
-        netEnvParams.netEnvId = p_Scheme->netEnvId;
-        netEnvParams.numOfDistinctionUnits = p_SchemeParams->netEnvParams.numOfDistinctionUnits;
-        memcpy(netEnvParams.unitIds, p_SchemeParams->netEnvParams.unitIds, (sizeof(uint8_t))*p_SchemeParams->netEnvParams.numOfDistinctionUnits);
-        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
-        if(err)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-        p_Scheme->matchVector = netEnvParams.vector;
-    }
+    if (p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+        return TRUE;
     else
-    {
-        p_Scheme->matchVector = SCHEME_ALWAYS_DIRECT;
-        p_Scheme->netEnvId = ILLEGAL_NETENV;
-    }
+        return FALSE;
+}
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
+t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint8_t             i, j;
 
-    if(p_SchemeParams->bypassFqidGeneration)
-    {
-#ifdef FM_KG_NO_BYPASS_FQID_GEN
-        if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
-#endif /* FM_KG_NO_BYPASS_FQID_GEN */
-        if(p_SchemeParams->baseFqid)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
-    }
-    else
-        if(!p_SchemeParams->baseFqid)
-            DBG(WARNING, ("baseFqid is 0."));
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
-    {
-        direct = p_SchemeParams->kgNextEngineParams.plcrProfile.direct;
-        p_Scheme->directPlcr = direct;
-        absolute = (bool)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
-        if(!direct && absolute)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
-        if(direct)
-        {
-            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
-            numOfProfiles = 1;
-        }
-        else
+    for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
+    {
+        if (!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
         {
-            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-            shift = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
-            numOfProfiles = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+            p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = guestId;
+            p_SchemesIds[j] = i;
+            j++;
         }
     }
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_CC)
+    if (j != numOfSchemes)
     {
-#ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
-        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        /* roll back */
+        for (j--; j; j--)
         {
-            if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].allocated = FALSE;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
+            p_SchemesIds[j] = 0;
         }
-#endif /* FM_KG_NO_BYPASS_PLCR_PROFILE_GEN */
 
-        err = FmPcdCcGetGrpParams(p_SchemeParams->kgNextEngineParams.cc.h_CcTree,
-                             p_SchemeParams->kgNextEngineParams.cc.grpId,
-                             &grpBits,
-                             &grpBase);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        p_Scheme->ccUnits = grpBits;
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
+    }
 
-        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
-           (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+    return E_OK;
+}
+
+t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint8_t             i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC */
+
+    for (i = 0; i < numOfSchemes; i++)
+    {
+        if (!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
         {
-                if(p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
-                absolute = FALSE;
-                direct = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.direct;
-                if(direct)
-                {
-                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
-                    numOfProfiles = 1;
-                }
-                else
-                {
-                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-                    shift = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
-                    numOfProfiles = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
-                }
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
         }
+        if (p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
     }
 
-    /* if policer is used directly after KG, or after CC */
-    if((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
-       ((p_SchemeParams->nextEngine == e_FM_PCD_CC) &&
-        (p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
-        (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
+    return E_OK;
+}
+
+t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
+
+    if (!numOfClsPlanEntries)
+        return E_OK;
+
+    if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
     {
-        /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-        if(absolute)
+        if (!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
         {
-            /* for absolute direct policy only, */
-            relativeProfileId = profileId;
-            err = FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
-            if(err)
-                RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
-            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
-            p_Scheme->relativeProfileId = profileId;
+            blocksFound++;
+            i++;
+            if (blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
         }
-        else
+    }
+
+    if (blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first * CLS_PLAN_NUM_PER_GRP);
+        for (j = first; j < (first + numOfBlocks); j++)
         {
-            /* save relative profile id's for later check */
-            p_Scheme->nextRelativePlcrProfile = TRUE;
-            p_Scheme->relativeProfileId = profileId;
-            p_Scheme->numOfProfiles = numOfProfiles;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
         }
+        return E_OK;
     }
     else
-    {
-        /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
-        is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
-        if(p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                    ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
-        if(p_SchemeParams->bypassFqidGeneration &&
-                p_SchemeParams->useHash &&
-                p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                    ("hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"));
-    }
+        RETURN_ERROR(MINOR, E_FULL, ("No resources for clsPlan"));
+}
 
-    /* configure all 21 scheme registers */
-    tmpReg =  KG_SCH_MODE_EN;
-    switch(p_SchemeParams->nextEngine)
-    {
-        case(e_FM_PCD_PLCR):
-            /* add to mode register - NIA */
-            tmpReg |= KG_SCH_MODE_NIA_PLCR;
-            tmpReg |= NIA_ENG_PLCR;
-            tmpReg |= (uint32_t)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
-            /* initialize policer profile command - */
-            /*  configure kgse_ppc  */
-            if(direct)
-            /* use profileId as base, other fields are 0 */
-                p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
-            else
-            {
-                if(shift > MAX_PP_SHIFT)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+void KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks;
+    uint8_t     i, baseBlock;
 
-                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+#ifdef DISABLE_ASSERTIONS
+UNUSED(guestId);
+#endif /* DISABLE_ASSERTIONS */
 
-                ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
-                ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
-                ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
-                ppcTmp |= (uint32_t)profileId;
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
-                p_SchemeRegs->kgse_ppc = ppcTmp;
-            }
-            break;
-        case(e_FM_PCD_CC):
-            /* mode reg - define NIA */
-            tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
 
-            p_SchemeRegs->kgse_ccbs = grpBits;
-            tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
+    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
+    for (i=baseBlock;i<baseBlock+numOfBlocks;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
+    }
+}
 
-            if(p_SchemeParams->kgNextEngineParams.cc.plcrNext)
-            {
-                if(!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
-                {
-                    /* find out if absolute or relative */
-                    if(absolute)
-                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
-                    if(direct)
-                    {
-                        /* mask = 0, base = directProfileId */
-                        p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
-                    }
-                    else
-                    {
-                        if(shift > MAX_PP_SHIFT)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
-                        if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+void KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-                        ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
-                        ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
-                        ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
-                        ppcTmp |= (uint32_t)profileId;
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+}
 
-                        p_SchemeRegs->kgse_ppc = ppcTmp;
-                    }
-                }
-                else
-                    ppcTmp = KG_SCH_PP_NO_GEN;
-            }
-            break;
-        case(e_FM_PCD_DONE):
-            if(p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
-                tmpReg |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
-            else
-                tmpReg |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
-            break;
-        default:
-             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
-    }
-    p_SchemeRegs->kgse_mode = tmpReg;
+void KgDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    p_SchemeRegs->kgse_mv = p_Scheme->matchVector;
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+}
 
-#if (DPAA_VERSION >= 11)
-    if (p_SchemeParams->overrideStorageProfile)
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, intFlags;
+    uint16_t                i, j;
+
+    /* This routine is protected by the calling routine ! */
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
-        p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
-        tmpReg = 0;
-        if (p_SchemeParams->storageProfile.direct)
+        for (j = i; j < i+8; j++)
         {
-            profileId = p_SchemeParams->storageProfile.profileSelect.directRelativeProfileId;
-            shift = 0;
-            numOfProfiles = 1;
+            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
         }
-        else
+
+        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
         {
-            profileId = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-            shift = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetShift;
-            numOfProfiles = p_SchemeParams->storageProfile.profileSelect.indirectProfile.numOfProfiles;
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+            return;
         }
-        if (shift > MAX_SP_SHIFT)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_SP_SHIFT));
-
-        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
-
-        tmpReg = (uint32_t)shift << KG_SCH_VSP_SHIFT;
-        tmpReg |= ((uint32_t)(numOfProfiles-1) << KG_SCH_VSP_MASK_SHIFT);
-        tmpReg |= (uint32_t)profileId;
+    }
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+}
 
+t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdKg   *p_FmPcdKg;
 
-        p_SchemeRegs->kgse_vsp = tmpReg;
+    UNUSED(p_FmPcd);
 
-        p_Scheme->vspe = TRUE;
+    if (p_FmPcdParams->numOfSchemes > FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("numOfSchemes should not exceed %d", FM_PCD_KG_NUM_OF_SCHEMES));
+        return NULL;
+    }
 
+    p_FmPcdKg = (t_FmPcdKg *)XX_Malloc(sizeof(t_FmPcdKg));
+    if (!p_FmPcdKg)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Keygen allocation FAILED"));
+        return NULL;
     }
-    else
-        p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
-#endif /* (DPAA_VERSION >= 11) */
+    memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
 
-    if(p_SchemeParams->useHash)
+    if (FmIsMaster(p_FmPcd->h_Fm))
     {
-        p_KeyAndHash = &p_SchemeParams->keyExtractAndHashParams;
+        p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+    }
 
-        if (p_KeyAndHash->numOfUsedExtracts >= FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfUsedExtracts out of range"));
+    p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
+    if ((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
+    {
+        p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+        DBG(WARNING, ("numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"));
+    }
 
-        /*  configure kgse_dv0  */
-        p_SchemeRegs->kgse_dv0 = p_KeyAndHash->privateDflt0;
+    p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
 
-        /*  configure kgse_dv1  */
-        p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
+    return p_FmPcdKg;
+}
 
-        if(!p_SchemeParams->bypassFqidGeneration)
-        {
-            if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
-            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
-                DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
-        }
+t_Error KgInit(t_FmPcd *p_FmPcd)
+{
+    t_Error err = E_OK;
 
-        /*  configure kgse_ekdv  */
-        tmpReg = 0;
-        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
-        {
-            switch(p_KeyAndHash->dflts[i].type)
-            {
-                case(e_FM_PCD_KG_MAC_ADDR):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_TCI):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_ENET_TYPE):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_PPP_SESSION_ID):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_MPLS_LABEL):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_IP_ADDR):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_PROTOCOL_TYPE):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_IP_TOS_TC):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_IPSEC_SPI):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_L4_PORT):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_TCP_FLAG):
-                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
-                    break;
-                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
-                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
-                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
-                    numOfSwDefaults ++;
-                    break;
-                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
-                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
-                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
-                    numOfSwDefaults ++;
-                    break;
-                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
-                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
-                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
-                    numOfSwDefaults ++;
-                   break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-        }
-        p_SchemeRegs->kgse_ekdv = tmpReg;
+    p_FmPcd->p_FmPcdKg->h_HwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG HW spinlock"));
 
-        p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
-        if(!p_LocalExtractsArray)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+        err =  KgInitMaster(p_FmPcd);
+    else
+        err =  KgInitGuest(p_FmPcd);
 
-        /*  configure kgse_ekfc and  kgse_gec */
-        knownTmp = 0;
-        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
-        {
-            p_Extract = &p_KeyAndHash->extractArray[i];
-            switch(p_Extract->type)
-            {
-                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
-                    knownTmp |= KG_SCH_KN_PORT_ID;
-                    /* save in driver structure */
-                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
-                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
-                    break;
-                case(e_FM_PCD_EXTRACT_BY_HDR):
-                    switch(p_Extract->extractByHdr.hdr)
-                    {
-                        case(HEADER_TYPE_UDP_ENCAP_ESP):
-                            switch(p_Extract->extractByHdr.type)
-                            {
-                                case(e_FM_PCD_EXTRACT_FROM_HDR):
-                                    /* case where extraction from ESP only */
-                                    if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
-                                    {
-                                        p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                        p_Extract->extractByHdr.extractByHdrType.fromHdr.offset -= UDP_HEADER_SIZE;
-                                        p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
-                                    }
-                                    else
-                                    {
-                                        p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
-                                        p_Extract->extractByHdr.ignoreProtocolValidation = FALSE;
-                                    }
-                                    break;
-                                case(e_FM_PCD_EXTRACT_FROM_FIELD):
-                                    switch(p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
-                                    {
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
-                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
-                                            break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
-                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
-                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
-                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
-                                            break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
-                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
-                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
-                                            break;
-                                    }
-                                    break;
-                                case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                                    switch(p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
-                                    {
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
-                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
-                                            break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
-                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
-                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
-                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
-                                            break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
-                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
-                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SEQ_NUM_OFFSET;
-                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
-                                            break;
-                                    }
-                                    break;
-                            }
-                            break;
-                        default:
-                            break;
-                    }
-                    switch(p_Extract->extractByHdr.type)
-                    {
-                        case(e_FM_PCD_EXTRACT_FROM_HDR):
-                            generic = TRUE;
-                            /* get the header code for the generic extract */
-                            code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
-                            /* set generic register fields */
-                            offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
-                            size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
-                            break;
-                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
-                            generic = TRUE;
-                            /* get the field code for the generic extract */
-                            code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
-                                        p_Extract->extractByHdr.extractByHdrType.fromField.field, p_Extract->extractByHdr.ignoreProtocolValidation,p_Extract->extractByHdr.hdrIndex);
-                            offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
-                            size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
-                            break;
-                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                            if(!p_Extract->extractByHdr.ignoreProtocolValidation)
-                            {
-                                /* if we have a known field for it - use it, otherwise use generic */
-                                bitMask = GetKnownProtMask(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
-                                            p_Extract->extractByHdr.extractByHdrType.fullField);
-                                if(bitMask)
-                                {
-                                    knownTmp |= bitMask;
-                                    /* save in driver structure */
-                                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(bitMask);
-                                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
-                                }
-                                else
-                                    generic = TRUE;
+    if (err != E_OK)
+    {
+        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
+    }
 
-                            }
-                            else
-                                generic = TRUE;
-                            if(generic)
-                            {
-                                /* tmp - till we cover more headers under generic */
-                                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
-                            }
-                            break;
-                        default:
-                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-                    }
-                    break;
-                case(e_FM_PCD_EXTRACT_NON_HDR):
-                    /* use generic */
-                    generic = TRUE;
-                    offset = 0;
-                    /* get the field code for the generic extract */
-                    code = GetGenCode(p_Extract->extractNonHdr.src, &offset);
-                    offset += p_Extract->extractNonHdr.offset;
-                    size = p_Extract->extractNonHdr.size;
-                    break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
+    return err;
+}
 
-            if(generic)
-            {
-                /* set generic register fields */
-                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
-                    RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
-                if(!code)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+t_Error KgFree(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdIpcKgSchemesParams       kgAlloc;
+    t_Error                         err = E_OK;
+    t_FmPcdIpcMsg                   msg;
+    uint32_t                        replyLength;
+    t_FmPcdIpcReply                 reply;
 
-                genTmp = KG_SCH_GEN_VALID;
-                genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
-                genTmp |= offset;
-                if((size > MAX_KG_SCH_SIZE) || (size < 1))
-                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
-                genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
-                swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
-                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
-                    DBG(WARNING, ("No sw default configured"));
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
 
-                genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
-                genTmp |= KG_SCH_GEN_MASK;
-                p_SchemeRegs->kgse_gec[currGenId] = genTmp;
-                /* save in driver structure */
-                p_LocalExtractsArray->extractsArray[i].id = currGenId++;
-                p_LocalExtractsArray->extractsArray[i].known = FALSE;
-                generic = FALSE;
-            }
-        }
-        p_SchemeRegs->kgse_ekfc = knownTmp;
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        err = FmPcdKgFreeSchemes(p_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                    p_FmPcd->guestId,
+                                    p_FmPcd->p_FmPcdKg->schemesIds);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        selectTmp = 0;
-        maskTmp = 0xFFFFFFFF;
-        /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
+        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
 
-        if(p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
-        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
-        {
-            /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
-            id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
-            /* Get the shift of the select field (depending on i) */
-            GET_MASK_SEL_SHIFT(shift,i);
-            if (p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].known)
-                selectTmp |= id << shift;
-            else
-                selectTmp |= (id + MASK_FOR_GENERIC_BASE_ID) << shift;
+        return E_OK;
+    }
 
-            /* Get the shift of the offset field (depending on i) - may
-               be in  kgse_bmch or in kgse_fqb (depending on i) */
-            GET_MASK_OFFSET_SHIFT(shift,i);
-            if (i<=1)
-                selectTmp |= p_KeyAndHash->masks[i].offset << shift;
-            else
-                fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
+    /* guest */
+    memset(&reply, 0, sizeof(reply));
+    memset(&msg, 0, sizeof(msg));
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.guestId = p_FmPcd->guestId;
+    ASSERT_COND(kgAlloc.numOfSchemes < FM_PCD_KG_NUM_OF_SCHEMES);
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds, (sizeof(uint8_t))*kgAlloc.numOfSchemes);
+    msg.msgId = FM_PCD_FREE_KG_SCHEMES;
+    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+    replyLength = sizeof(uint32_t);
+    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId) + sizeof(kgAlloc),
+                                 (uint8_t*)&reply,
+                                 &replyLength,
+                                 NULL,
+                                 NULL)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (replyLength != sizeof(uint32_t))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
-            /* Get the shift of the mask field (depending on i) */
-            GET_MASK_SHIFT(shift,i);
-            /* pass all bits */
-            maskTmp |= KG_SCH_BITMASK_MASK << shift;
-            /* clear bits that need masking */
-            maskTmp &= ~(0xFF << shift) ;
-            /* set mask bits */
-            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
-        }
-        p_SchemeRegs->kgse_bmch = selectTmp;
-        p_SchemeRegs->kgse_bmcl = maskTmp;
-        /* kgse_fqb will be written t the end of the routine */
+    if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
 
-        /*  configure kgse_hc  */
-        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
-        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+    return (t_Error)reply.error;
+}
 
-        tmpReg = 0;
+t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp)
+{
+    t_FmPcd                                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgInterModuleClsPlanGrpParams    grpParams, *p_GrpParams;
+    t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
+    t_FmPcdKgInterModuleClsPlanSet          *p_ClsPlanSet;
+    t_Error                                 err;
 
-        tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
-        tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+    /* This function is issued only from FM_PORT_SetPcd which locked all PCD modules,
+       so no need for lock here */
+
+    memset(&grpParams, 0, sizeof(grpParams));
+    grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
+    p_GrpParams = &grpParams;
+
+    p_GrpParams->netEnvId = netEnvId;
+
+    /* Get from the NetEnv the information of the clsPlan (can be already created,
+     * or needs to build) */
+    err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
+    if (err)
+        RETURN_ERROR(MINOR,err,NO_MSG);
 
-        if(p_KeyAndHash->symmetricHash)
+    if (p_GrpParams->grpExists)
+    {
+        /* this group was already updated (at least) in SW */
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+    }
+    else
+    {
+        p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
+        if (!p_ClsPlanSet)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
+        memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
+        /* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
+        err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
+        if (err)
         {
-            if((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
-                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
-                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
-                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
-            tmpReg |= KG_SCH_HASH_CONFIG_SYM;
+            XX_Free(p_ClsPlanSet);
+            RETURN_ERROR(MINOR, err, NO_MSG);
         }
-        p_SchemeRegs->kgse_hc = tmpReg;
-
-        /* build the return array describing the order of the extractions */
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
 
-        /* the last currGenId places of the array
-           are for generic extracts that are always last.
-           We now sort for the calculation of the order of the known
-           extractions we sort the known extracts between orderedArray[0] and
-           orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].
-           for the calculation of the order of the generic extractions we use:
-           num_of_generic - currGenId
-           num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
-           first_generic_index = num_of_known */
-        curr = 0;
-        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        if (p_FmPcd->h_Hc)
         {
-            if(p_LocalExtractsArray->extractsArray[i].known)
-            {
-                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
-                j = curr;
-                /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
-                index in the user's extractions array */
-                /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
-                location */
-                while((j > 0) && (p_LocalExtractsArray->extractsArray[i].id <
-                      p_LocalExtractsArray->extractsArray[p_Scheme->orderedArray[j-1]].id))
-                {
-                    p_Scheme->orderedArray[j] =
-                        p_Scheme->orderedArray[j-1];
-                    j--;
-                }
-                p_Scheme->orderedArray[j] = (uint8_t)i;
-                curr++;
-            }
-            else
+            /* write clsPlan entries to memory */
+            err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_ClsPlanSet);
+            if (err)
             {
-                /* index is first_generic_index + generic index (id) */
-                idx = (uint8_t)(p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id);
-                ASSERT_COND(idx < FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY);
-                p_Scheme->orderedArray[idx]= (uint8_t)i;
+                XX_Free(p_ClsPlanSet);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
-        XX_Free(p_LocalExtractsArray);
-        p_LocalExtractsArray = NULL;
+        else
+            /* write clsPlan entries to memory */
+            KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
 
+        XX_Free(p_ClsPlanSet);
     }
-    else
-    {
-        /* clear all unused registers: */
-        p_SchemeRegs->kgse_ekfc = 0;
-        p_SchemeRegs->kgse_ekdv = 0;
-        p_SchemeRegs->kgse_bmch = 0;
-        p_SchemeRegs->kgse_bmcl = 0;
-        p_SchemeRegs->kgse_hc = 0;
-        p_SchemeRegs->kgse_dv0 = 0;
-        p_SchemeRegs->kgse_dv1 = 0;
-    }
-
-    if(p_SchemeParams->bypassFqidGeneration)
-        p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
-
-    /*  configure kgse_spc  */
-    if( p_SchemeParams->schemeCounter.update)
-        p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
+    /* Set caller parameters     */
 
-    /* check that are enough generic registers */
-    if(p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
-        RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+    /* mark if this is an empty classification group */
+    if (*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        *p_IsEmptyClsPlanGrp = TRUE;
+    else
+        *p_IsEmptyClsPlanGrp = FALSE;
 
-    /* extracted OR mask on Qid */
-    for( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
-    {
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
 
-        p_Scheme->extractedOrs = TRUE;
-        /*  configure kgse_gec[i]  */
-        p_ExtractOr = &p_SchemeParams->extractedOrs[i];
-        switch(p_ExtractOr->type)
-        {
-            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
-                code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
-                offset = 0;
-                break;
-            case(e_FM_PCD_EXTRACT_BY_HDR):
-                /* get the header code for the generic extract */
-                code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
-                /* set generic register fields */
-                offset = p_ExtractOr->extractionOffset;
-                break;
-            case(e_FM_PCD_EXTRACT_NON_HDR):
-                /* get the field code for the generic extract */
-                offset = 0;
-                code = GetGenCode(p_ExtractOr->src, &offset);
-                offset += p_ExtractOr->extractionOffset;
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-        }
+   /* increment owners number */
+    p_ClsPlanGrp->owners++;
 
-        /* set generic register fields */
-        if(!code)
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
-        genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
-        genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
-        genTmp |= offset;
-        if(!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
+    /* copy options array for port */
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
 
-        /************************************************************************************
-            bitOffsetInFqid and bitOffsetInPolicerProfile are translated to rotate parameter
-            in the following way:
+    /* bind port to the new or existing group */
+    err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
-            Driver API and implementation:
-            ==============================
-            FQID: extracted OR byte may be shifted right 1-31 bits to effect parts of the FQID.
-            if shifted less than 8 bits, or more than 24 bits a mask is set on the bits that
-            are not overlapping FQID.
-                     ------------------------
-                    |      FQID (24)         |
-                     ------------------------
-            --------
-           |        |  extracted OR byte
-            --------
+    return E_OK;
+}
 
-            Policer Profile: extracted OR byte may be shifted right 1-15 bits to effect parts of the
-            PP id. Unless shifted exactly 8 bits to overlap the PP id, a mask is set on the bits that
-            are not overlapping PP id.
+t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+    t_FmPcdKgInterModuleClsPlanSet  *p_ClsPlanSet;
+    t_Error                         err;
 
-                     --------
-                    | PP (8) |
-                     --------
-            --------
-           |        |  extracted OR byte
-            --------
+    /* This function is issued only from FM_PORT_DeletePcd which locked all PCD modules,
+       so no need for lock here */
 
-            HW implementation
-            =================
-            FQID and PP construct a 32 bit word in the way describe below. Extracted byte is located
-            as the highest byte of that word and may be rotated to effect any part os the FQID or
-            the PP.
-             ------------------------  --------
-            |      FQID (24)         || PP (8) |
-             ------------------------  --------
-             --------
-            |        |  extracted OR byte
-             --------
+    UnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
 
-        ************************************************************************************/
+    /* decrement owners number */
+    ASSERT_COND(p_ClsPlanGrp->owners);
+    p_ClsPlanGrp->owners--;
 
-        if(p_ExtractOr->bitOffsetInFqid)
+    if (!p_ClsPlanGrp->owners)
+    {
+        if (p_FmPcd->h_Hc)
         {
-            if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
-            if(p_ExtractOr->bitOffsetInFqid<8)
-                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
-            else
-                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
-            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInFqid, TRUE);
+            err = FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
+            return err;
         }
-        else /* effect policer profile */
+        else
         {
-            if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
-            p_Scheme->bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
-            genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
-            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInPlcrProfile, FALSE);
-        }
+            /* clear clsPlan entries in memory */
+            p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
+            if (!p_ClsPlanSet)
+            {
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
+            }
+            memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
 
-        genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
-        /* clear bits that need masking */
-        genTmp &= ~KG_SCH_GEN_MASK ;
-        /* set mask bits */
-        genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
-        p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
+            p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
+            p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
+            KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
+            XX_Free(p_ClsPlanSet);
 
+            FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
+       }
     }
-    /* clear all unused GEC registers */
-    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
-        p_SchemeRegs->kgse_gec[i] = 0;
-
-    /* add base Qid for this scheme */
-    /* add configuration for kgse_fqb */
-    if(p_SchemeParams->baseFqid & ~0x00FFFFFF)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
-
-    fqbTmp |= p_SchemeParams->baseFqid;
-    p_SchemeRegs->kgse_fqb = fqbTmp;
-
-    p_Scheme->nextEngine = p_SchemeParams->nextEngine;
-    p_Scheme->doneAction = p_SchemeParams->kgNextEngineParams.doneAction;
-
     return E_OK;
 }
 
@@ -2627,7 +2633,7 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
 
    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
 
-    if((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
+    if ((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
         p_FmPcd->p_FmPcdKg->schemes[schemeId].bitOffsetInPlcrProfile) ||
         p_FmPcd->p_FmPcdKg->schemes[schemeId].nextRelativePlcrProfile)
         return TRUE;
@@ -2769,11 +2775,11 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t     i;
 
-    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
-        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+    for (i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if (p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
             return i;
 
-    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if (i == p_FmPcd->p_FmPcdKg->numOfSchemes)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
 
     return FM_PCD_KG_NUM_OF_SCHEMES;
@@ -2816,10 +2822,10 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     {
         if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
+            switch (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
             {
-                case(e_FM_PCD_DONE):
-                    if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
+                case (e_FM_PCD_DONE):
+                    if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
                     {
                         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
                         intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2833,8 +2839,8 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                     }
                 break;
-                case(e_FM_PCD_PLCR):
-                    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
+                case (e_FM_PCD_PLCR):
+                    if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
                        (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs &&
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
@@ -2842,7 +2848,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
-                        if(err)
+                        if (err)
                         {
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
@@ -2851,7 +2857,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,("in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"));
             }
         }
-        if(requiredAction & UPDATE_KG_NIA_CC_WA)
+        if (requiredAction & UPDATE_KG_NIA_CC_WA)
         {
             if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_CC)
             {
@@ -2868,7 +2874,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                 KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
            }
         }
-        if(requiredAction & UPDATE_KG_OPT_MODE)
+        if (requiredAction & UPDATE_KG_OPT_MODE)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2879,7 +2885,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
             WriteKgarWait(p_FmPcd, tmpKgarReg);
             KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         }
-        if(requiredAction & UPDATE_KG_NIA)
+        if (requiredAction & UPDATE_KG_NIA)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2900,20 +2906,18 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
 
     return E_OK;
 }
-
-
-
 /*********************** End of inter-module routines ************************/
 
 
 /****************************************/
 /*  API routines                        */
 /****************************************/
+
 t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemeParams)
 {
     t_FmPcd                             *p_FmPcd;
-    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
-    t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
+    t_FmPcdKgSchemeRegs                 schemeRegs;
+    t_FmPcdKgSchemeRegs                 *p_MemRegs;
     uint8_t                             i;
     t_Error                             err = E_OK;
     uint32_t                            tmpKgarReg;
@@ -2953,14 +2957,14 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
 
         relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
-        if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        if (relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
         {
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
             return NULL;
         }
 
         p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-        if(FmPcdKgIsSchemeValidSw(p_Scheme))
+        if (FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
                          ("Scheme is already used"));
@@ -2975,10 +2979,25 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
             REPORT_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM KG Scheme lock obj!"));
     }
 
+    err = BuildSchemeRegs((t_Handle)p_Scheme, p_SchemeParams, &schemeRegs);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        if (p_SchemeParams->modify)
+            KgSchemeFlagUnlock(p_Scheme);
+        if (!p_SchemeParams->modify &&
+            p_Scheme->p_Lock)
+            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
+        return NULL;
+    }
+
     if (p_FmPcd->h_Hc)
     {
-        err = FmHcPcdKgSetScheme(p_FmPcd->h_Hc, (t_Handle)p_Scheme, p_SchemeParams);
-        if(p_SchemeParams->modify)
+        err = FmHcPcdKgSetScheme(p_FmPcd->h_Hc,
+                                 (t_Handle)p_Scheme,
+                                 &schemeRegs,
+                                 p_SchemeParams->schemeCounter.update);
+        if (p_SchemeParams->modify)
             KgSchemeFlagUnlock(p_Scheme);
         if (err)
         {
@@ -2994,18 +3013,6 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
 
     physicalSchemeId = p_Scheme->schemeId;
 
-    err = FmPcdKgBuildScheme((t_Handle)p_Scheme, p_SchemeParams, &schemeRegs);
-    if (err)
-    {
-        REPORT_ERROR(MAJOR, err, NO_MSG);
-        if(p_SchemeParams->modify)
-            KgSchemeFlagUnlock(p_Scheme);
-        if (!p_SchemeParams->modify &&
-            p_Scheme->p_Lock)
-            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
-        return NULL;
-    }
-
     /* configure all 21 scheme registers */
     p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -3024,7 +3031,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
     WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
     WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
-    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for (i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
@@ -3055,7 +3062,7 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     /* check that no port is bound to this scheme */
     err = InvalidateSchemeSw(h_Scheme);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     if (p_FmPcd->h_Hc)
@@ -3098,7 +3105,7 @@ uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
 
-    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
@@ -3130,7 +3137,7 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
     /* check that schemeId is in range */
-    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     /* read specified scheme into scheme registers */
@@ -3166,7 +3173,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
 
     WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
@@ -3187,10 +3194,10 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
 
-    if(valueId == 0)
+    if (valueId == 0)
         WRITE_UINT32(p_Regs->kggdv0r,value);
     else
         WRITE_UINT32(p_Regs->kggdv1r,value);
@@ -3211,25 +3218,8 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
-        p_FmPcd->h_IpcSession)
-    {
-        t_FmPcdIpcMsg       msg;
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_KG_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
+                               p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs), E_INVALID_OPERATION);
 
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
@@ -3251,10 +3241,10 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
 
     DUMP_SUBTITLE(("\n"));
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    for (j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
     {
         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
@@ -3289,7 +3279,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
@@ -3299,14 +3289,14 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
 
     DUMP_SUBTITLE(("\n"));
-    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    for (j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
     {
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
         tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         DUMP_SUBSTRUCT_ARRAY(i, 8)
             DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index ba120f5..a3be4cf 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -58,7 +58,7 @@
 
 #define WRITE_UINT16(addr, val)     \
     do{                             \
-            if((int)&(addr) % 4)    \
+            if ((int)&(addr) % 4)    \
                 WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
                         ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
             else                    \
@@ -140,10 +140,11 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
 {
     uint8_t dataSize, remain, tableSize = 0;
 
-    if(p_FmPcdManipParams->u.hdr.rmv)
+    if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        switch(p_FmPcdManipParams->u.hdr.rmvParams.type){
-            case(e_FM_PCD_MANIP_RMV_GENERIC):
+        switch (p_FmPcdManipParams->u.hdr.rmvParams.type){
+            case (e_FM_PCD_MANIP_RMV_GENERIC):
+            case (e_FM_PCD_MANIP_RMV_BY_HDR):
                 /* As long as the only rmv command is the L2, no check on type is required */
                 tableSize +=  HMCD_BASIC_SIZE;
             break;
@@ -153,22 +154,75 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
         }
     }
 
-    if(p_FmPcdManipParams->u.hdr.insrt)
+    if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        switch(p_FmPcdManipParams->u.hdr.insrtParams.type){
-            case(e_FM_PCD_MANIP_INSRT_GENERIC):
+        switch (p_FmPcdManipParams->u.hdr.insrtParams.type){
+            case (e_FM_PCD_MANIP_INSRT_GENERIC):
                 remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
-                if(remain)
+                if (remain)
                     dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
                 else
                     dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
                 tableSize += (uint8_t)(HMCD_BASIC_SIZE + dataSize);
             break;
+            case (e_FM_PCD_MANIP_INSRT_BY_HDR):
+                /* As long as the only insert command is the internal L2, no check on type is required */
+                tableSize +=  HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
             default:
                 REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
                 return 0;
         }
     }
+    if (p_FmPcdManipParams->u.hdr.fieldUpdate)
+    {
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+                tableSize += HMCD_BASIC_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    tableSize += HMCD_PTR_SIZE;
+            break;
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+                tableSize += HMCD_BASIC_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                    tableSize += HMCD_PARAM_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                    tableSize += HMCD_IPV4_ADDR_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                    tableSize += HMCD_IPV4_ADDR_SIZE;
+            break;
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+                tableSize += HMCD_BASIC_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
+                    tableSize += HMCD_IPV6_ADDR_SIZE;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
+                    tableSize += HMCD_IPV6_ADDR_SIZE;
+            break;
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                    /* we implement this case with the update-checksum descriptor */
+                    tableSize += HMCD_BASIC_SIZE;
+                else
+                    /* we implement this case with the TCP/UDP-update descriptor */
+                    tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE;
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+                return 0;
+        }
+    }
+
+    if (p_FmPcdManipParams->u.hdr.custom)
+    {
+        switch (p_FmPcdManipParams->u.hdr.customParams.type){
+            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+                tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+                return 0;
+        }
+    }
 
     return tableSize;
 }
@@ -179,9 +233,8 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     uint32_t        *p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
     uint32_t        tmpReg=0, *p_Last=NULL;
     uint8_t         remain, i, size=0, origSize, *p_Data=NULL;
-
-    SANITY_CHECK_RETURN_ERROR((p_FmPcdManipParams->u.hdr.insrt ||
-                               p_FmPcdManipParams->u.hdr.rmv), E_INVALID_VALUE);
+    t_Handle        h_FmPcd = p_Manip->h_FmPcd;
+    uint8_t         j=0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
@@ -193,6 +246,34 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
         }
+        else if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
+        {
+            uint8_t     hmcdOpt;
+            if (!p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2)
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+            /* initialize HMCD */
+            tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
+
+            switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
+            {
+                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
+                    hmcdOpt = HMCD_RMV_L2_ETHERNET;
+                    break;
+                case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
+                    hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
+                    break;
+                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
+                    hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
+                    break;
+                case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
+                    hmcdOpt = HMCD_RMV_L2_MPLS;
+                    break;
+                default:
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+            }
+            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+        }
         else
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
 
@@ -208,8 +289,8 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
         if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
-            if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
-                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
+            if (p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
+                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE) << HMCD_OC_SHIFT;
             else
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
 
@@ -240,18 +321,307 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_TmpData = (uint32_t*)p_Data;
 
             /* initialize data and advance pointer to next command */
-            for (i = 0; i<size/4 ; i++, p_TmpPtr++)
+            for (i = 0; i<size/4 ; i++, p_TmpPtr += HMCD_BASIC_SIZE/4)
                 WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
 
             if (remain)
                 XX_Free(p_TmpData);
+        }
+
+        else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
+        {
+            uint8_t     hmcdOpt;
+            if (!p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+            /* initialize HMCD */
+            tmpReg = (uint32_t)(HMCD_OPCODE_L2_INSRT) << HMCD_OC_SHIFT;
+
+            switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+            {
+                case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                    if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.update)
+                        hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
+                    else
+                        hmcdOpt = HMCD_INSRT_L2_MPLS;
+                default:
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+            }
+            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+
+            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            /* save a pointer to the "last" indication word */
+            p_Last = p_TmpPtr;
 
             p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+            /* set size and pointer of user's data */
+            size = (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+            p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, size, 4);
+            if (!p_TmpData)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+
+            memcpy((uint8_t*)p_TmpData, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data, size);
+            tmpReg = (size << HMCD_INSRT_L2_SIZE_SHIFT) | (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            p_TmpPtr += HMCD_PTR_SIZE/4;
+            p_Manip->p_InsertData = (uint8_t*)p_TmpData;
         }
         else
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
     }
 
+    if (p_FmPcdManipParams->u.hdr.fieldUpdate)
+    {
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+                /* set opcode */
+                tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE) << HMCD_OC_SHIFT;
+
+                /* set mode & table pointer */
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                {
+                    /* set Mode */
+                    tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI) << HMCD_VLAN_PRI_REP_MODE_SHIFT;
+                    /* set VPRI default */
+                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
+                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    /* save a pointer to the "last" indication word */
+                    p_Last = p_TmpPtr;
+                    /* write the table pointer into the Manip descriptor */
+                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+                    /* Allocate MURAM for translation table and set its content. */
+                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, DSCP_TO_VLAN_TABLE_SIZE, 4);
+                    if (!p_TmpData)
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+
+                    tmpReg = 0;
+                    for (i=0; i<FM_PCD_MANIP_DSCP_VALUES; i++)
+                    {
+                        /* first we build from each 8 values a 32bit register */
+                        tmpReg |= (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]) << (32-4*(j+1));
+                        j++;
+                        /* Than we write this register to the next table word
+                         * (i=7-->word 0, i=15-->word 1,... i=63-->word 7) */
+                        if ((i%8) == 7)
+                        {
+                            WRITE_UINT32(*(p_TmpData + (i+1)/8-1), tmpReg);
+                            tmpReg = 0;
+                            j = 0;
+                        }
+                    }
+                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    p_TmpPtr += HMCD_PTR_SIZE/4;
+
+                    /* Save data pointer so it can later be freed */
+                    p_Manip->p_UpdateData = (uint8_t*)p_TmpData;
+                }
+
+                else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                {
+                    /* set Mode */
+                    /* TODO - line commented out as it has no-side-effect ('0' value). */
+                    /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
+                    /* set VPRI parameter */
+                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
+                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    /* save a pointer to the "last" indication word */
+                    p_Last = p_TmpPtr;
+                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+                }
+                break;
+
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+                /* set opcode */
+                tmpReg = (uint32_t)(HMCD_OPCODE_IPV4_UPDATE) << HMCD_OC_SHIFT;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TTL)
+                    tmpReg |= HMCD_IPV4_UPDATE_TTL;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TOS)
+                {
+                    tmpReg |= HMCD_IPV4_UPDATE_TOS;
+                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.tos << HMCD_IPV4_UPDATE_TOS_SHIFT;
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                    tmpReg |= HMCD_IPV4_UPDATE_ID;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                    tmpReg |= HMCD_IPV4_UPDATE_SRC;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                    tmpReg |= HMCD_IPV4_UPDATE_DST;
+                /* write the first 4 bytes of the descriptor */
+                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                /* save a pointer to the "last" indication word */
+                p_Last = p_TmpPtr;
+
+                p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                {
+                    /* Allocate MURAM for IP ID and copy its content. */
+                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, 2, 4);
+                    if (!p_TmpData)
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+
+                    *(uint16_t*)p_TmpData = p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id;
+                    p_Manip->p_UpdateData = (uint8_t*)p_TmpData;
+                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                    p_TmpPtr += HMCD_PTR_SIZE/4;
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                {
+                    WRITE_UINT32(*p_TmpPtr, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
+                    p_TmpPtr += HMCD_IPV4_ADDR_SIZE/4;
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                {
+                    WRITE_UINT32(*p_TmpPtr, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
+                    p_TmpPtr += HMCD_IPV4_ADDR_SIZE/4;
+                }
+                break;
+
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+                /* set opcode */
+                tmpReg = (uint32_t)(HMCD_OPCODE_IPV6_UPDATE) << HMCD_OC_SHIFT;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
+                    tmpReg |= HMCD_IPV6_UPDATE_HL;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
+                {
+                    tmpReg |= HMCD_IPV6_UPDATE_TC;
+                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass << HMCD_IPV6_UPDATE_TC_SHIFT;
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                    tmpReg |= HMCD_IPV6_UPDATE_SRC;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                    tmpReg |= HMCD_IPV6_UPDATE_DST;
+                /* write the first 4 bytes of the descriptor */
+                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                /* save a pointer to the "last" indication word */
+                p_Last = p_TmpPtr;
+
+                p_TmpPtr += HMCD_BASIC_SIZE/4;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                    for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                    {
+                        WRITE_UINT32(*p_TmpPtr, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
+                        p_TmpPtr += HMCD_PTR_SIZE/4;
+                    }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                    for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                    {
+                        WRITE_UINT32(*p_TmpPtr, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
+                        p_TmpPtr += HMCD_PTR_SIZE/4;
+                    }
+                break;
+
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                {
+                    /* we implement this case with the update-checksum descriptor */
+                    /* set opcode */
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM) << HMCD_OC_SHIFT;
+                    /* write the first 4 bytes of the descriptor */
+                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    /* save a pointer to the "last" indication word */
+                    p_Last = p_TmpPtr;
+
+                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+                }
+                else
+                {
+                    /* we implement this case with the TCP/UDP update descriptor */
+                    /* set opcode */
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE) << HMCD_OC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                         tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                         tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
+                    /* write the first 4 bytes of the descriptor */
+                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    /* save a pointer to the "last" indication word */
+                    p_Last = p_TmpPtr;
+
+                    p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+                    tmpReg = 0;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
+                    WRITE_UINT32(*p_TmpPtr, tmpReg);
+                    p_TmpPtr += HMCD_PTR_SIZE/4;
+                }
+                break;
+
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+        }
+    }
+
+    if (p_FmPcdManipParams->u.hdr.custom)
+    {
+        switch (p_FmPcdManipParams->u.hdr.customParams.type)
+        {
+            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+                /* set opcode */
+                tmpReg = (uint32_t)(HMCD_OPCODE_REPLACE_IP) << HMCD_OC_SHIFT;
+
+                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.decTtlHl)
+                    tmpReg |= HMCD_IP_REPLACE_TTL_HL;
+                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
+                    /* TODO - line commented out as it has no-side-effect ('0' value). */
+                    /*tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV4*/;
+                else if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                {
+                    tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV6;
+                    if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id)
+                        tmpReg |= HMCD_IP_REPLACE_ID;
+                }
+                else
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                                 ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
+
+                /* write the first 4 bytes of the descriptor */
+                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                /* save a pointer to the "last" indication word */
+                p_Last = p_TmpPtr;
+
+                p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+                size = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                /* Allocate MURAM for IP ID and copy its content. */
+                p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, size, 4);
+                if (!p_TmpData)
+                    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+
+                memcpy(p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr, size);
+                p_Manip->p_CustomData1 = (uint8_t*)p_TmpData;
+                tmpReg = (uint32_t)(size << HMCD_IP_REPLACE_L3HDRSIZE_SHIFT);
+                tmpReg |= (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                WRITE_UINT32(*p_TmpPtr, tmpReg);
+                p_TmpPtr += HMCD_PTR_SIZE/4;
+
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                {
+                    /* Allocate MURAM for IP ID and copy its content. */
+                    p_TmpData = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)h_FmPcd)->h_FmMuram, 2, 4);
+                    if (!p_TmpData)
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
+
+                    *(uint16_t*)p_TmpData = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id;
+                    p_Manip->p_CustomData2 = (uint8_t*)p_TmpData;
+                    WRITE_UINT32(*p_TmpPtr, (uint32_t)(PTR_TO_UINT(XX_VirtToPhys(p_TmpData)) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                }
+                p_TmpPtr += HMCD_PTR_SIZE/4;
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+        }
+    }
+
+
 
     /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
        the old table and should be freed */
@@ -279,9 +649,9 @@ static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_Fm
     uint16_t    tmpReg, tmpSize;
 
     /* set Manip structure */
-    if(p_FmPcdManipParams->h_NextManip)
+    if (p_FmPcdManipParams->h_NextManip)
     {
-        if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+        if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
             p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
         else
             p_Manip->cascadedNext = TRUE;
@@ -291,7 +661,7 @@ static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_Fm
     /* Allocate new table */
     /* calculate table size according to manip parameters */
     tmpSize = CalculateTableSize(p_FmPcdManipParams);
-    if(tmpSize == 0)
+    if (tmpSize == 0)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CalculateTableSize Failed"));
 
     p_Manip->tableSize += tmpSize;
@@ -336,11 +706,11 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+           if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
             {
                 tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
                 tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
@@ -350,15 +720,15 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
             }
             else
             {
-                if(p_Manip->icOffset != icOffset)
+                if (p_Manip->icOffset != icOffset)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
             }
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if(p_Manip->h_Frag)
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if (p_Manip->h_Frag)
             {
-                if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+                if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
                 {
                     p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
                     tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
@@ -369,7 +739,7 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
                 }
                 else
                 {
-                    if(p_Manip->icOffset != icOffset)
+                    if (p_Manip->icOffset != icOffset)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
                 }
             }
@@ -394,9 +764,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     SANITY_CHECK_RETURN_ERROR((p_Manip->type & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+        if ((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
            (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
@@ -405,9 +775,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
@@ -415,7 +785,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     }
     else if (validate)
     {
-         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
            (p_Manip->updateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
@@ -423,14 +793,14 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 
     }
 
-   if(p_Manip->updateParams & OFFSET_OF_PR)
+   if (p_Manip->updateParams & OFFSET_OF_PR)
    {
         tmpReg32 = 0;
         tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
@@ -441,7 +811,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
    else if (validate)
    {
         tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
-        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+        if ((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
    }
 
@@ -462,14 +832,14 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
 
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+        if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if(!p_SavedManipParams)
+        if (!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
         p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
@@ -484,9 +854,9 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
    {
 
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if(!p_SavedManipParams)
+        if (!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if(p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
+        if (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
    }
 
@@ -551,14 +921,14 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
     }
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
         tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
@@ -624,7 +994,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -653,7 +1023,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -698,7 +1068,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
                                             4);
 
-           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+           if (!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
@@ -714,7 +1084,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
                                             4);
 
-            if(!p_Manip->fragParams.p_TimeOutTbl)
+            if (!p_Manip->fragParams.p_TimeOutTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
             IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
@@ -799,7 +1169,6 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 {
     uint32_t    tmpReg32 = 0, i;
     uint64_t    tmpReg64, size;
-    bool        couplingPort;
     t_FmPcd     *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
     t_Error     err = E_OK;
 
@@ -817,7 +1186,6 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 
     IOMemSet32(p_Manip->ipReassmParams.p_IpReassCommonTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
 
-    couplingPort = (bool)(p_Manip->ipReassmParams.h_CouplingFmPort ? TRUE : FALSE);
     /* Setting the TimeOut Mode.*/
     tmpReg32 = 0;
     if (p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
@@ -826,8 +1194,6 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     /* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.
     In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
     tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
-    if (couplingPort)
-        tmpReg32 |= FM_PCD_MANIP_IP_REASM_COUPLING_ENABLE;
     WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeoutModeAndFqid, tmpReg32);
 
     /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 128.*/
@@ -852,8 +1218,6 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 
     /* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
     tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)) - p_FmPcd->physicalMuramBase);
-    if (couplingPort)
-        tmpReg32 |= ((FmPortGetHardwarePortId(p_Manip->ipReassmParams.h_CouplingFmPort) << FM_PCD_MANIP_IP_REASM_COUPLING_SHIFT) & FM_PCD_MANIP_IP_REASM_COUPLING_MASK);
     WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
 
     /* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.
@@ -861,7 +1225,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
         PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
 
-    if(!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+    if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 32));
@@ -878,12 +1242,12 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.timeOutTblAddr =
         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
 
-    if(!p_Manip->ipReassmParams.timeOutTblAddr)
+    if (!p_Manip->ipReassmParams.timeOutTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
 
-    /* Sets the TimeOut table offset from MURAM*/
+    /* Sets the TimeOut table offset from MURAM */
     tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr)) - p_FmPcd->physicalMuramBase);
     WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeOutTblPtr, tmpReg32);
 
@@ -906,7 +1270,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
 {
     t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
     uint32_t                tmpReg32, autoLearnHashTblSize;
-    uint32_t                numOfWays, setSize, setSizeCode, tmpSetSize;
+    uint32_t                numOfWays, setSize, setSizeCode, tmpSetSize, keySize;
     uint32_t                waySize, numOfSets, tmpNumOfSets, numOfEntries;
     uint64_t                tmpReg64;
     uint16_t                minFragSize;
@@ -920,7 +1284,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
         p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr;
         minFragSize = p_Manip->ipReassmParams.minFragSize[0];
         numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[0];
-        waySize = ROUND_UP(((4 + 4 + 1 + 2)),8);
+        keySize = 4 + 4 + 1 + 2; /* 3-tuple + IP-Id */
     }
     else
     {
@@ -929,16 +1293,21 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
         p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr;
         minFragSize = p_Manip->ipReassmParams.minFragSize[1];
         numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[1];
-        waySize = ROUND_UP(((16 + 16 + 4) /* * numOfWays*/),8);
+        keySize = 16 + 16 + 4; /* 2-tuple + IP-Id */
         if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
     }
+    keySize += 2; /* 2 bytes reserved for RFDIndex */
+#if (DPAA_VERSION >= 11)
+    keySize += 2; /* 2 bytes reserved */
+#endif /* (DPAA_VERSION >= 11) */
+    waySize = ROUND_UP(keySize, 8);
 
     /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
     *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-    if(!*p_IpReassTbl)
+    if (!*p_IpReassTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
     memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
 
@@ -976,7 +1345,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     autoLearnHashTblSize = numOfSets * setSize;
 
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
-    if(!*p_AutoLearnHashTblAddr)
+    if (!*p_AutoLearnHashTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -995,7 +1364,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
     This table resides in external memory and its base address should be 4-byte aligned */
     *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
-    if(!*p_AutoLearnSetLockTblAddr)
+    if (!*p_AutoLearnSetLockTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -1025,124 +1394,62 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
                                  t_Handle       h_Ad,
                                  bool           validate)
 {
-    t_AdOfTypeContLookup        *p_Ipv4Ad = NULL, *p_Ipv6Ad = NULL;
     t_FmPortGetSetCcParams      fmPortGetSetCcParams;
     uint32_t                    tmpReg32;
     t_Error                     err;
+#if (DPAA_VERSION == 10)
     t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
+#else
+    uint8_t                     *p_Ptr;
+#endif /* (DPAA_VERSION == 10) */
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams, E_INVALID_HANDLE);
 
     UNUSED(h_Ad);
 
     if (!p_Manip->updateParams)
         return E_OK;
 
-    if( p_Manip->ipReassmParams.h_Ipv4Ad != NULL)
-         p_Ipv4Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
-    if( p_Manip->ipReassmParams.h_Ipv6Ad != NULL)
-         p_Ipv6Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
-
-    if(p_Manip->h_FmPcd != h_FmPcd)
+    if (p_Manip->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
 
-    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
-
-    fmPortGetSetCcParams.setCcParams.type = 0;
-    fmPortGetSetCcParams.getCcParams.type = FM_REV;
-    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
-    {
-        if (p_Manip->ipReassmParams.h_CouplingFmPort)
-        {
-            fmPortGetSetCcParams.getCcParams.type = 0;
-            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FNE;
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_SWITCH_PORT | NIA_ENG_FM_CTL;
-            fmPortGetSetCcParams.setCcParams.immediateWrite = TRUE;
-            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-                RETURN_ERROR(MINOR, err, NO_MSG);
-        }
-        /* set special operational mode bits: KOMV=1(valid), OVOM=0(setting one), NENQ=1, NL=1, CWD=1.
-         * set the scheme NIA to BMI */
-        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    if(p_Manip->ipReassmParams.h_Ipv4Scheme)
-    {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
-    if(p_Manip->ipReassmParams.h_Ipv6Scheme)
-    {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
-
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
-           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
+        if ((!(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))) ||
+            ((p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.setCcParams.type = 0;
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
     else if (validate)
     {
-        if((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) ||
-           ((p_Manip->updateParams & OFFSET_OF_DATA)))
+        if ((!(p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))) ||
+            ((p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
 
-         fmPortGetSetCcParams.setCcParams.type = 0;
-         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-             RETURN_ERROR(MAJOR, err, NO_MSG);
-         if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
+        fmPortGetSetCcParams.setCcParams.type = 0;
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if(p_Manip->updateParams & OFFSET_OF_DATA)
-        {
-            p_Manip->ipReassmParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
-            if (p_Ipv4Ad != NULL)
-            {
-                tmpReg32 = GET_UINT32(p_Ipv4Ad->matchTblPtr);
-                tmpReg32 |= (p_Manip->ipReassmParams.dataOffset << 16);
-                WRITE_UINT32(p_Ipv4Ad->matchTblPtr, tmpReg32);
-            }
-            if (p_Ipv6Ad != NULL)
-            {
-                tmpReg32 = GET_UINT32(p_Ipv6Ad->matchTblPtr);
-                tmpReg32 |= (p_Manip->ipReassmParams.dataOffset << 16);
-                WRITE_UINT32(p_Ipv6Ad->matchTblPtr, tmpReg32);
-            }
-            p_Manip->updateParams &= ~OFFSET_OF_DATA;
-            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
-        }
         if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
         {
             t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
             uint8_t     *p_Ptr, i, totalNumOfTnums;
-            uint32_t    tmpReg32;
 
             totalNumOfTnums = (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks +
                                         fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
@@ -1178,11 +1485,52 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
         }
     }
-    else if(validate)
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+    fmPortGetSetCcParams.setCcParams.type = 0;
+    fmPortGetSetCcParams.getCcParams.type = FM_REV;
+    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#if (DPAA_VERSION == 10)
+    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
+    {
+        if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+        if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+    }
+    else
+    {
+#else
+    if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    tmpReg32 = NIA_ENG_KG;
+    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+    {
+        tmpReg32 |= NIA_KG_DIRECT;
+        tmpReg32 |= NIA_KG_CC_EN;
+        tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
+        WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET), tmpReg32);
+    }
+    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
     {
-        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->ipReassmParams.dataOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value"));
+        tmpReg32 &= ~NIA_AC_MASK;
+        tmpReg32 |= NIA_KG_DIRECT;
+        tmpReg32 |= NIA_KG_CC_EN;
+        tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
+        WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
     }
+#endif /* (DPAA_VERSION == 10) */
+#if (DPAA_VERSION == 10)
+    }
+#endif /* (DPAA_VERSION == 10) */
 
     return E_OK;
 }
@@ -1229,28 +1577,28 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
-    if(p_Manip->h_Ad)
+    if (p_Manip->h_Ad)
     {
-        if(p_Manip->muramAllocate)
+        if (p_Manip->muramAllocate)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
         else
             XX_Free(p_Manip->h_Ad);
         p_Manip->h_Ad = NULL;
     }
-    if(p_Manip->p_Template)
+    if (p_Manip->p_Template)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
         p_Manip->p_Template = NULL;
     }
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
-        if(p_Manip->fragParams.p_AutoLearnHashTbl)
+        if (p_Manip->fragParams.p_AutoLearnHashTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
-        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+        if (p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
-        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+        if (p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
-        if(p_Manip->fragParams.p_TimeOutTbl)
+        if (p_Manip->fragParams.p_TimeOutTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
@@ -1270,34 +1618,39 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
     {
         FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
 
-        if(p_Manip->ipReassmParams.timeOutTblAddr)
+        if (p_Manip->ipReassmParams.timeOutTblAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
-        if(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+        if (p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
             XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
 
-        if(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
+        if (p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
             XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
-        if(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
+        if (p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
             XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
-        if(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
+        if (p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
             XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
-        if(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
+        if (p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
             XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
-        if(p_Manip->ipReassmParams.p_Ipv4ReassTbl)
+        if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
-        if(p_Manip->ipReassmParams.p_Ipv6ReassTbl)
+        if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv6ReassTbl);
-        if(p_Manip->ipReassmParams.p_IpReassCommonTbl)
+        if (p_Manip->ipReassmParams.p_IpReassCommonTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
-        if(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
+        if (p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr));
-        if(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
+        if (p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr));
-        if(p_Manip->ipReassmParams.internalBufferPoolAddr)
+        if (p_Manip->ipReassmParams.internalBufferPoolAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr));
+
+        if (p_Manip->ipReassmParams.h_Ipv6Ad)
+            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv6Ad);
+        if (p_Manip->ipReassmParams.h_Ipv4Ad)
+            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv4Ad);
     }
 
-    if(p_Manip->p_StatsTbl)
+    if (p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
@@ -1305,30 +1658,30 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
 
-    if(p_ManipParams->u.hdr.rmv)
+    if (p_ManipParams->u.hdr.rmv)
     {
-        switch(p_ManipParams->u.hdr.rmvParams.type)
+        switch (p_ManipParams->u.hdr.rmvParams.type)
         {
-            case(e_FM_PCD_MANIP_RMV_BY_HDR):
-                switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            case (e_FM_PCD_MANIP_RMV_BY_HDR):
+                switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                 {
-                    case(e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
-                        if(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                        if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                         {
-                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case(HEADER_TYPE_CAPWAP_DTLS) :
+                                case (HEADER_TYPE_CAPWAP_DTLS) :
                                     p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
                                     p_Manip->muramAllocate = TRUE;
-                                    if(p_ManipParams->u.hdr.insrt)
+                                    if (p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-                                    if(p_ManipParams->fragOrReasm)
+                                    if (p_ManipParams->fragOrReasm)
                                     {
-                                        if(!p_ManipParams->fragOrReasmParams.frag)
+                                        if (!p_ManipParams->fragOrReasmParams.frag)
                                         {
-                                            switch(p_ManipParams->fragOrReasmParams.hdr)
+                                            switch (p_ManipParams->fragOrReasmParams.hdr)
                                             {
-                                                case(HEADER_TYPE_CAPWAP):
+                                                case (HEADER_TYPE_CAPWAP):
                                                     p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
                                                     break;
                                                 default:
@@ -1345,10 +1698,10 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                         }
                         else
                         {
-                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case(HEADER_TYPE_CAPWAP_DTLS) :
-                                case(HEADER_TYPE_CAPWAP) :
+                                case (HEADER_TYPE_CAPWAP_DTLS) :
+                                case (HEADER_TYPE_CAPWAP) :
                                     if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
                                     p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -1368,21 +1721,21 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
-    else if(p_ManipParams->u.hdr.insrt)
+    else if (p_ManipParams->u.hdr.insrt)
     {
-        switch(p_ManipParams->u.hdr.insrtParams.type)
+        switch (p_ManipParams->u.hdr.insrtParams.type)
         {
-            case(e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
+            case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
                 p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
                 p_Manip->muramAllocate = FALSE;
-                if(p_ManipParams->fragOrReasm)
+                if (p_ManipParams->fragOrReasm)
                 {
-                    if(p_ManipParams->fragOrReasmParams.frag)
+                    if (p_ManipParams->fragOrReasmParams.frag)
                     {
-                           switch(p_ManipParams->fragOrReasmParams.hdr)
+                           switch (p_ManipParams->fragOrReasmParams.hdr)
                            {
-                                case(HEADER_TYPE_CAPWAP):
+                                case (HEADER_TYPE_CAPWAP):
                                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
                                     break;
                                 default:
@@ -1398,13 +1751,13 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
     }
-    else if(p_ManipParams->fragOrReasm)
+    else if (p_ManipParams->fragOrReasm)
     {
-        if(p_ManipParams->fragOrReasmParams.frag)
+        if (p_ManipParams->fragOrReasmParams.frag)
         {
-            switch(p_ManipParams->fragOrReasmParams.hdr)
+            switch (p_ManipParams->fragOrReasmParams.hdr)
             {
-                case(HEADER_TYPE_CAPWAP):
+                case (HEADER_TYPE_CAPWAP):
                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
                     p_Manip->muramAllocate = FALSE;
                     break;
@@ -1416,7 +1769,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
-                case(HEADER_TYPE_CAPWAP):
+                case (HEADER_TYPE_CAPWAP):
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
                 default:
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
@@ -1438,11 +1791,22 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
     switch (p_ManipParams->type)
     {
         case e_FM_PCD_MANIP_HDR :
-            if(p_ManipParams->u.hdr.rmv)
+            if (p_ManipParams->u.hdr.rmv)
             {
-                switch(p_ManipParams->u.hdr.rmvParams.type)
+                switch (p_ManipParams->u.hdr.rmvParams.type)
                 {
-                   case(e_FM_PCD_MANIP_RMV_GENERIC):
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR):
+                        switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+                        {
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
+                                p_Manip->type = HMAN_OC;
+                                p_Manip->muramAllocate = TRUE;
+                                break;
+                            default :
+                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                        }
+                        break;
+                   case (e_FM_PCD_MANIP_RMV_GENERIC):
                        p_Manip->type = HMAN_OC;
                        p_Manip->muramAllocate = TRUE;
                        break;
@@ -1451,11 +1815,12 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->rmv = TRUE;
             }
-            else if(p_ManipParams->u.hdr.insrt)
+            else if (p_ManipParams->u.hdr.insrt)
             {
-                switch(p_ManipParams->u.hdr.insrtParams.type)
+                switch (p_ManipParams->u.hdr.insrtParams.type)
                 {
-                    case(e_FM_PCD_MANIP_INSRT_GENERIC):
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
+                    case (e_FM_PCD_MANIP_INSRT_GENERIC):
                         p_Manip->type = HMAN_OC;
                         p_Manip->muramAllocate = TRUE;
                         break;
@@ -1464,42 +1829,70 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->insrt = TRUE;
             }
+            else if (p_ManipParams->u.hdr.fieldUpdate)
+            {
+                /* Check parameters */
+                if (p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+                {
+                    if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                        && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri > 7))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpri should get values of 0-7 "));
+                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    {
+                        int i;
+
+                        if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpriDefVal should get values of 0-7 "));
+                        for(i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
+                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
+                                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dscpToVpriTabl value out of range (0-15)"));
+                    }
+
+                }
+
+                p_Manip->type = HMAN_OC;
+                p_Manip->muramAllocate = TRUE;
+                p_Manip->fieldUpdate = TRUE;
+            }
+            else if (p_ManipParams->u.hdr.custom)
+            {
+                p_Manip->type = HMAN_OC;
+                p_Manip->muramAllocate = TRUE;
+                p_Manip->custom = TRUE;
+            }
             break;
         case e_FM_PCD_MANIP_REASSEM :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
-            switch(p_ManipParams->u.reassem.hdr)
+            switch (p_ManipParams->u.reassem.hdr)
             {
-                case(HEADER_TYPE_IPv4):
-                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
-                    p_Manip->muramAllocate = TRUE;
+                case (HEADER_TYPE_IPv4):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
                     break;
-                case(HEADER_TYPE_IPv6):
-                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
-                    p_Manip->muramAllocate = TRUE;
+                case (HEADER_TYPE_IPv6):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for reassembly"));
              }
+            p_Manip->type = HMAN_OC_IP_REASSEMBLY;
             break;
         case e_FM_PCD_MANIP_FRAG :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
-            switch(p_ManipParams->u.frag.hdr)
+            switch (p_ManipParams->u.frag.hdr)
             {
-                case(HEADER_TYPE_IPv4):
-                case(HEADER_TYPE_IPv6):
-                    p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
-                    p_Manip->muramAllocate = TRUE;
+                case (HEADER_TYPE_IPv4):
+                case (HEADER_TYPE_IPv6):
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
              }
+            p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
+            p_Manip->muramAllocate = TRUE;
             break;
         case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
-            switch(p_ManipParams->u.specialOffload.type)
+            switch (p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
                     p_Manip->type = HMAN_OC_IPSEC_MANIP;
@@ -1536,19 +1929,19 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
     p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if(p_Manip->h_FmPcd != h_FmPcd)
+    if (p_Manip->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
                      ("handler of PCD previously was initiated by different value"));
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
-    if(!p_Manip->p_StatsTbl)
+    if (!p_Manip->p_StatsTbl)
     {
 
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
@@ -1557,14 +1950,14 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
             (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                         (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
                                         4);
-        if(!p_Manip->p_StatsTbl)
+        if (!p_Manip->p_StatsTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
         IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
-        if(p_Manip->cnia)
+        if (p_Manip->cnia)
             tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
 
         tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
@@ -1575,7 +1968,7 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1601,27 +1994,27 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if(!p_Manip->h_Frag)
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (!p_Manip->h_Frag)
                 break;
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
             break;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             if (p_Manip->h_Frag)
                 err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
             break;
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
             break;
         default:
@@ -1639,11 +2032,11 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 
     UNUSED(level);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
            if (p_Manip->h_Frag)
            {
@@ -1654,8 +2047,8 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
            }
            break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if(p_Manip->h_Frag)
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (p_Manip->h_Frag)
             {
                 err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
             }
@@ -1676,30 +2069,30 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     bool            byField     = p_HdrInfo->byField;
     t_FmPcdFields   field;
 
-    if(byField)
+    if (byField)
         field = p_HdrInfo->fullField;
 
-    if(byField)
+    if (byField)
     {
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_ETH):
-                switch(field.eth)
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
                         break;
                     default:
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
                 }
                 break;
-            case(HEADER_TYPE_VLAN):
-                switch(field.vlan)
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
                 {
-                    case(NET_HEADER_FIELD_VLAN_TCI) :
-                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case (NET_HEADER_FIELD_VLAN_TCI) :
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                              *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                         break;
                     default:
@@ -1712,51 +2105,51 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     }
     else
     {
-        switch(hdr){
-             case(HEADER_TYPE_ETH):
+        switch (hdr){
+             case (HEADER_TYPE_ETH):
                  *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
                 break;
-            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
                 break;
-            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
                 break;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
                 break;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
                 break;
-            case(HEADER_TYPE_MPLS):
-                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                         *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
                 break;
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+              if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+              else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
                 break;
-            case(HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_MINENCAP):
                 *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
                 break;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
                 break;
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_DCCP):
-            case(HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_SCTP):
                 *parseArrayOffset = CC_PC_PR_L4_OFFSET;
                 break;
-            case(HEADER_TYPE_CAPWAP):
-            case(HEADER_TYPE_CAPWAP_DTLS):
+            case (HEADER_TYPE_CAPWAP):
+            case (HEADER_TYPE_CAPWAP_DTLS):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
                 break;
             default:
@@ -1781,14 +2174,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
     if (p_Manip->rmv)
     {
         err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 |= (uint32_t)prsArrayOffset << 24;
         tmpReg32 |= HMAN_RMV_HDR;
     }
 
-    if(p_Manip->insrt)
+    if (p_Manip->insrt)
         tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
 
     tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -1846,7 +2239,7 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
 
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
         p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
@@ -1940,7 +2333,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-        if(((j / i)  % 2)== 0)
+        if (((j / i)  % 2)== 0)
             WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
@@ -1981,7 +2374,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                   FM_PCD_CC_AD_ENTRY_SIZE,
                                                   FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Manip->h_Frag)
+    if (!p_Manip->h_Frag)
          RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
     IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
@@ -1991,7 +2384,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
-    if(p_ManipParams->headerOptionsCompr)
+    if (p_ManipParams->headerOptionsCompr)
         tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
     tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
@@ -2038,12 +2431,14 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-    /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID) and Scatter/Gather table offset*/
+    /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID for V2) and Scatter/Gather table offset*/
     /* mark the Scatter/Gather table offset to be set later on when the port will be known */
-    p_Manip->updateParams = (OFFSET_OF_DATA | NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
+    p_Manip->updateParams = (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
 
+#if (DPAA_VERSION == 10)
     tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
     WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+#endif /* (DPAA_VERSION == 10) */
 
     /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
     tmpReg32 = 0;
@@ -2060,34 +2455,17 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv4 Action descriptor */
-    if(p_Manip->muramAllocate)
+    p_Manip->ipReassmParams.h_Ipv4Ad =
+        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
+                                 p_Manip->ipReassmParams.dataMemId,
+                                 FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->ipReassmParams.h_Ipv4Ad)
     {
-        p_Manip->ipReassmParams.h_Ipv4Ad =
-            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                        FM_PCD_CC_AD_ENTRY_SIZE,
-                                        FM_PCD_CC_AD_TABLE_ALIGN);
-        if(!p_Manip->ipReassmParams.h_Ipv4Ad)
-        {
-           ReleaseManipHandler(p_Manip, p_FmPcd);
-           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for IPv4 table descriptor"));
-        }
-
-        IOMemSet32(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
     }
-    else
-    {
-        p_Manip->ipReassmParams.h_Ipv4Ad =
-            (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t),
-                                     p_Manip->ipReassmParams.dataMemId,
-                                     0);
-        if(!p_Manip->ipReassmParams.h_Ipv4Ad)
-        {
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
-        }
 
-        memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-    }
+    memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
     return FillReassmManipParams(p_Manip, TRUE);
@@ -2098,31 +2476,17 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv6 Action descriptor */
-    if(p_Manip->muramAllocate)
-    {
-        p_Manip->ipReassmParams.h_Ipv6Ad =
-            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                        FM_PCD_CC_AD_ENTRY_SIZE,
-                                        FM_PCD_CC_AD_TABLE_ALIGN);
-        if(!p_Manip->ipReassmParams.h_Ipv6Ad)
-        {
-           ReleaseManipHandler(p_Manip, p_FmPcd);
-           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for IPv6 table descriptor"));
-        }
-
-        IOMemSet32(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-    }
-    else
-    {
-         p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
-         if(!p_Manip->ipReassmParams.h_Ipv6Ad)
-         {
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
-         }
+     p_Manip->ipReassmParams.h_Ipv6Ad =
+        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
+                                 p_Manip->ipReassmParams.dataMemId,
+                                 FM_PCD_CC_AD_TABLE_ALIGN);
+     if (!p_Manip->ipReassmParams.h_Ipv6Ad)
+     {
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
+     }
 
-        memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-    }
+    memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
     return FillReassmManipParams(p_Manip, FALSE);
@@ -2165,7 +2529,9 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
     p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
     p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+#if (DPAA_VERSION == 10)
     p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
+#endif /* (DPAA_VERSION == 10) */
     /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonTable(p_Manip);
 
@@ -2314,7 +2680,7 @@ static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
-    if(p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
         tmpReg32 |= (uint32_t)0x16 << 16;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
@@ -2346,25 +2712,25 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if(p_Manip->insrt)
+    if (p_Manip->insrt)
     {
-        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
              (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
 
          if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
 
-         if(p_InsrtByTemplate->size > 128)
+         if (p_InsrtByTemplate->size > 128)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
 
-         if(p_InsrtByTemplate->size)
+         if (p_InsrtByTemplate->size)
          {
              p_Manip->p_Template =
                 (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                              p_InsrtByTemplate->size,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->p_Template)
+             if (!p_Manip->p_Template)
                  RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for manipulation header template"));
 
              tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
@@ -2376,39 +2742,39 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
         p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
 
-        if(!p_Template)
+        if (!p_Template)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of manipulation header template"));
 
         memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
 
 
-         if(p_InsrtByTemplate->modifyOuterIp)
+         if (p_InsrtByTemplate->modifyOuterIp)
          {
              ipModify = TRUE;
 
              tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
 
-             if((tmpReg8 & 0xf0) == 0x40)
+             if ((tmpReg8 & 0xf0) == 0x40)
                  tmpReg8 = 4;
-             else if((tmpReg8 & 0xf0) == 0x60)
+             else if ((tmpReg8 & 0xf0) == 0x60)
                  tmpReg8 = 6;
              else
                  tmpReg8 = 0xff;
 
-             if(tmpReg8 == 4)
+             if (tmpReg8 == 4)
              {
-                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                 if ((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
 
                  p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
                  {
 
-                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                     if ((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
                             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
                      extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
                      blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
@@ -2418,14 +2784,14 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
                      in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
                      second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
                  }
-                 if(blockSize)
+                 if (blockSize)
                  {
                      if (!POWER_OF_2(blockSize))
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
                      blockSize -= 1;
                  }
 
-                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                 if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
 
                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
@@ -2441,9 +2807,9 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
 
                  /*UDP checksum has to be 0*/
-                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
                  {
-                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
 
                     p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
@@ -2451,7 +2817,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
                  }
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
 
                  tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
@@ -2484,7 +2850,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     }
 
     tmpReg32 = 0;
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
         tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
         tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
@@ -2492,7 +2858,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     else
           tmpReg32 = 0xffff0000;
 
-    if(ipModify)
+    if (ipModify)
         tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
     else
         tmpReg32 |= (uint32_t)0x0000ff00;
@@ -2541,9 +2907,8 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
     p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                                                              FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Manip->ipFragParams.p_Frag)
+    if (!p_Manip->ipFragParams.p_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
-
     IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
@@ -2551,19 +2916,26 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
 
     /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
     ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
-    ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_OFFSET);
+    ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
+
+#ifdef ALU_CUSTOM
+    if (p_ManipParams->optionsCounterEn)
+        ccAdBaseReg |= FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN;
+#endif /* ALU_CUSTOM */
 
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
     {
          ccAdBaseReg     |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
-         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
     }
 
     /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
     gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
 #if (DPAA_VERSION == 10)
     gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#else
+    gmaskReg |= (0xFF) << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
 #endif /* (DPAA_VERSION == 10) */
 
     /* Set all Ad registers */
@@ -2604,17 +2976,20 @@ static t_Error IPManip(t_FmPcdManip *p_Manip)
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-    if(p_Manip->frag == TRUE)
+    tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
+    if (p_Manip->frag == TRUE)
     {
         tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_FRAG_MTU_OFFSET;
+        tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_MTU_SHIFT;
     }
-    else
-        tmpReg32 = FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION;
 
     tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     tmpReg32  |= HMAN_OC_IP_MANIP;
 
+#if (DPAA_VERSION >= 11)
+    tmpRegNia |= FM_PCD_MANIP_IP_CNIA;
+#endif /* (DPAA_VERSION >= 11) */
+
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
     WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
     WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
@@ -2635,6 +3010,13 @@ static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
 
     p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
 
+    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpHdrLen ||
+                              p_IPSecParams->decryption, E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
+                              !p_IPSecParams->decryption, E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
+                              p_IPSecParams->outerIPHdrLen, E_INVALID_VALUE);
+
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
@@ -2642,10 +3024,11 @@ static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
     tmpReg32 |= (p_IPSecParams->ecnCopy)?FM_PCD_MANIP_IPSEC_ECN_EN:0;
     tmpReg32 |= (p_IPSecParams->dscpCopy)?FM_PCD_MANIP_IPSEC_DSCP_EN:0;
     tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
-
+    tmpReg32 |= (p_IPSecParams->variableIpVersion)?FM_PCD_MANIP_IPSEC_VIPV_EN:0;
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
     tmpReg32 = HMAN_OC_IPSEC_MANIP;
+    tmpReg32 |= p_IPSecParams->outerIPHdrLen << FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT;
     if (p_ManipParams->h_NextManip)
     {
         WRITE_UINT32(p_Ad->matchTblPtr,
@@ -2663,9 +3046,9 @@ static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
 static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
 {
 
-    switch(p_StatsParams->type)
+    switch (p_StatsParams->type)
     {
-        case(e_FM_PCD_STATS_PER_FLOWID):
+        case (e_FM_PCD_STATS_PER_FLOWID):
             p_Manip->type = HMAN_OC_CAPWAP_INDEXED_STATS;
             p_Manip->muramAllocate = TRUE;
             break;
@@ -2720,7 +3103,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
             p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                         FM_PCD_CC_AD_ENTRY_SIZE,
                                                         FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->h_Ad)
+             if (!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -2733,7 +3116,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         else
         {
             p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-             if(!p_Manip->h_Ad)
+             if (!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -2755,22 +3138,6 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-bool FmPcdManipIsIpPresent(t_FmPcd *p_FmPcd, uint8_t netEnvId, bool ipv6)
-{
-    uint8_t         res;
-
-    ASSERT_COND(p_FmPcd);
-
-    if (ipv6)
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv6, FALSE, IPV6_FRAG_1);
-    else
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv4, FALSE, IPV4_FRAG_1);
-    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
-        return TRUE;
-    else
-        return FALSE;
-}
-
 t_Error FmPcdManipUpdate(t_Handle h_FmPcd,
                          t_Handle h_PcdParams,
                          t_Handle h_FmPort,
@@ -2797,10 +3164,10 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 
     ASSERT_COND(h_Manip);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             return UPDATE_NIA_ENQ_WITHOUT_DMA;
         default:
             return 0;
@@ -2810,7 +3177,7 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
 {
 
-    if(add)
+    if (add)
         ((t_FmPcdManip *)h_Manip)->owner++;
     else
     {
@@ -2830,59 +3197,57 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-            if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
                p_Manip->cnia = TRUE;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             p_Manip->ownerTmp++;
             break;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
+                !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
             p_Manip->ownerTmp++;
             break;
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
-               (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
+                (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
             err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
             break;
-        case(HMAN_OC_IP_MANIP):
-
-            if((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
-               !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-               p_Manip->cnia = FALSE;
-            else
-               p_Manip->cnia = TRUE;
-            if(!p_Manip->h_Frag)
-            {
-                p_Manip->ownerTmp++;
-                break;
-            }
-        case(HMAN_OC_IP_FRAGMENTATION):
-            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+        case (HMAN_OC_IP_FRAGMENTATION):
+#if (DPAA_VERSION == 10)
+            if (!(p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                 ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+#else
+            if (!((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) ||
+                  (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_PLCR)))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("For this type of header manipulation has to be nextEngine "
+                              "e_FM_PCD_DONE or e_FM_PCD_PLCR"));
+#endif /* (DPAA_VERSION == 10) */
             p_Manip->ownerTmp++;
             break;
-        case(HMAN_OC_IP_REASSEMBLY):
-            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+        case (HMAN_OC_IP_REASSEMBLY):
+            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
             p_Manip->ownerTmp++;
             break;
-        case(HMAN_OC_IPSEC_MANIP):
+        case (HMAN_OC_IPSEC_MANIP):
             p_Manip->ownerTmp++;
             break;
-        case(HMAN_OC):
-            if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
+        case (HMAN_OC):
+            if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
             break;
 
@@ -2901,19 +3266,19 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
             break;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if(p_Manip->h_Frag)
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if (p_Manip->h_Frag)
             {
-                if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
                 err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
-                if(err)
+                if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
             break;
@@ -2924,7 +3289,10 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     return err;
 }
 
-void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNewPtr)
+void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
+                                   t_FmPcdCcNextEngineParams    *p_CcNextEngineParams,
+                                   t_Handle                     p_Ad,
+                                   t_Handle                     *p_AdNewPtr)
 {
     t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
 
@@ -2933,30 +3301,40 @@ void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_
      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
 
     ASSERT_COND(p_Manip);
+    ASSERT_COND(p_CcNextEngineParams);
+    ASSERT_COND(p_Ad);
+    ASSERT_COND(p_AdNewPtr);
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
     /* According to "type", either build & initialize a new AD (p_AdNew) or initialize
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            *p_AdNewPtr = p_Manip->h_Ad;
-            break;
-        case(HMAN_OC_IPSEC_MANIP):
+        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case(HMAN_OC_IP_FRAGMENTATION):
+        case (HMAN_OC_IPSEC_MANIP):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case(HMAN_OC_IP_REASSEMBLY):
-            if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4)
+        case (HMAN_OC_IP_FRAGMENTATION):
+            if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
+                (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
             {
-                *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
+                memcpy((uint8_t *)p_Ad, (uint8_t *)p_Manip->h_Ad, sizeof(t_AdOfTypeContLookup));
+#if (DPAA_VERSION >= 11)
+                WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                             GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) & ~FM_PCD_MANIP_IP_CNIA);
+#endif /* (DPAA_VERSION >= 11) */
+                *p_AdNewPtr = NULL;
             }
-            if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
+            else
+                *p_AdNewPtr = p_Manip->h_Ad;
+            break;
+        case (HMAN_OC_IP_REASSEMBLY):
+            if (FmPcdManipIpReassmIsIpv6Hdr(p_Manip))
             {
                 if (!p_Manip->ipReassmParams.ipv6Assigned)
                 {
@@ -2965,28 +3343,24 @@ void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_
                     FmPcdManipUpdateOwner(h_Manip, FALSE);
                 }
                 else
+                {
                     *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
+                    p_Manip->ipReassmParams.ipv6Assigned = FALSE;
+                }
             }
-            break;
-        case(HMAN_OC_IP_MANIP):
-            if (p_Manip->cnia)
-                *p_AdNewPtr = p_Manip->h_Ad;
             else
-            {
-                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
-                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
-                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
-                *p_AdNewPtr = NULL;
-            }
+                *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
+            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr, sizeof(t_AdOfTypeContLookup));
+            *p_AdNewPtr = NULL;
             break;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
             *p_AdNewPtr = NULL;
             break;
-        case(HMAN_OC):
+        case (HMAN_OC):
             /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
@@ -3005,9 +3379,9 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
@@ -3016,7 +3390,7 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             *p_AdNewPtr = NULL;
             break;
 
-        case(HMAN_OC):
+        case (HMAN_OC):
             /* Initialize HMTD within the match table*/
             IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
             /* copy the existing HMTD */ /* ask Alla - memcpy??? */
@@ -3044,6 +3418,10 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
     ASSERT_COND(h_NetEnv);
     ASSERT_COND(p_Manip);
 
+    /* scheme was already build, no need to check for IPv6 */
+    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+        return E_OK;
+
     p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
     if (!p_SchemeParams)
        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation failed for scheme"));
@@ -3055,6 +3433,9 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
     p_SchemeParams->schemeCounter.update = TRUE;
     p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
     p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+#if (DPAA_VERSION >= 11)
+    p_SchemeParams->alwaysDirect = TRUE;
+#endif /* (DPAA_VERSION >= 11) */
 
     setReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
 
@@ -3084,6 +3465,15 @@ t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
     return E_OK;
 }
 
+bool FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip)
+{
+    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    return (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6);
+}
+
 #ifdef FM_CAPWAP_SUPPORT
 t_Handle FmPcdManipApplSpecificBuild(void)
 {
@@ -3101,7 +3491,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-     if(!p_Manip->h_Ad)
+     if (!p_Manip->h_Ad)
      {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
         XX_Free(p_Manip);
@@ -3113,7 +3503,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
     SEC errors check*/
-    if(MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
+    if (MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
     {
         XX_Free(p_Manip->h_Ad);
         XX_Free(p_Manip);
@@ -3147,15 +3537,15 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
-    if(!p_Manip)
+    if (!p_Manip)
         return NULL;
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
             err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3163,28 +3553,27 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             break;
-       case(HMAN_OC_IP_FRAGMENTATION):
+       case (HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
             err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
             }
-        case(HMAN_OC_IP_MANIP) :
             err = IPManip(p_Manip);
             break;
-        case(HMAN_OC_IPSEC_MANIP) :
+        case (HMAN_OC_IPSEC_MANIP) :
             err = IPSecManip(p_ManipParams, p_Manip);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             /* HmanType1 */
             err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
             break;
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
                                       p_Manip,
                                       p_FmPcd,
@@ -3196,36 +3585,36 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if(p_Manip->insrt)
+            if (p_Manip->insrt)
                 p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case(HMAN_OC_CAPWAP_REASSEMBLY):
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
             err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
                                    p_Manip,
                                    p_FmPcd,
                                    p_ManipParams->fragOrReasmParams.sgBpid);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if(p_Manip->rmv)
+            if (p_Manip->rmv)
                 p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+       case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
             err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
-       case(HMAN_OC):
+       case (HMAN_OC):
            /* New Manip */
            err = CreateManipAction(p_Manip, p_ManipParams);
            break;
@@ -3261,16 +3650,20 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
 
-    if(p_Manip->owner)
+    if (p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-    if(p_Manip->h_NextManip)
+    if (p_Manip->h_NextManip)
     {
         MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if(p_Manip->p_HmcdTbl)
+    if (p_Manip->p_InsertData)
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_InsertData);
+    if (p_Manip->p_UpdateData)
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_UpdateData);
+    if (p_Manip->p_HmcdTbl)
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_HmcdTbl);
 
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
@@ -3287,13 +3680,13 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
 
-    switch(p_Manip->type)
+    switch (p_Manip->type)
     {
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
-       case(HMAN_OC_IP_FRAGMENTATION):
+        case (HMAN_OC_IP_FRAGMENTATION):
             return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
-       default:
+        default:
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
     }
 
@@ -3311,12 +3704,12 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
     SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
-    if(!p_Manip)
+    if (!p_Manip)
         return NULL;
 
-     switch(p_Manip->type)
+     switch (p_Manip->type)
      {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             /* Indexed statistics */
             err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
             break;
@@ -3327,7 +3720,7 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
             return NULL;
      }
 
-     if(err)
+     if (err)
      {
          REPORT_ERROR(MAJOR, err, NO_MSG);
          ReleaseManipHandler(p_Manip, p_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index b07f40c..9becfea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -111,20 +111,29 @@
 #define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
 #define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
 
-#define FM_PCD_MANIP_IP_FRAG_DF_OFFSET                      28
+#define FM_PCD_MANIP_IP_MTU_SHIFT                           16
+#define FM_PCD_MANIP_IP_NO_FRAGMENTATION                    0xFFFF0000
+#define FM_PCD_MANIP_IP_CNIA                                0x20000000
+
+#define FM_PCD_MANIP_IP_FRAG_DF_SHIFT                       28
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
-#define FM_PCD_MANIP_IP_FRAG_MTU_OFFSET                     16
-#define FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION                0xFFFF0000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK                   0xFF000000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET                 24
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT                  24
+#ifdef ALU_CUSTOM
+#define FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN                   0x04000000
+#endif /* ALU_CUSTOM */
 
 #define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
+#define FM_PCD_MANIP_IPSEC_VIPV_EN                          0x08000000
 #define FM_PCD_MANIP_IPSEC_ECN_EN                           0x04000000
 #define FM_PCD_MANIP_IPSEC_DSCP_EN                          0x02000000
 #define FM_PCD_MANIP_IPSEC_VIPL_EN                          0x01000000
 #define FM_PCD_MANIP_IPSEC_NADEN                            0x20000000
 
+#define FM_PCD_MANIP_IPSEC_IP_HDR_LEN_MASK                  0x00FF0000
+#define FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT                 16
+
 #define e_FM_MANIP_IP_INDX                                  1
 
 #define HMCD_OPCODE_GENERIC_RMV                 0x01
@@ -170,6 +179,8 @@
 #define HMCD_INSRT_N_UPDATE_L2_MPLS             1
 #define HMCD_INSRT_L2_SIZE_SHIFT                24
 
+#define HMCD_L2_MODE_SHIFT                      16
+
 #define HMCD_VLAN_PRI_REP_MODE_SHIFT            16
 #define HMCD_VLAN_PRI_UPDATE                    0
 #define HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI       1
@@ -196,6 +207,8 @@
 #define HMCD_IP_REPLACE_TTL_HL                  0x00200000
 #define HMCD_IP_REPLACE_ID                      0x00400000
 
+#define HMCD_IP_REPLACE_L3HDRSIZE_SHIFT         24
+
 #define MANIP_IS_CASCADE(h_Manip)               (((t_FmPcdManip *)h_Manip)->cascadedNext)
 #define MANIP_GET_HMCT_SIZE(h_Manip)            (((t_FmPcdManip *)h_Manip)->tableSize)
 #define MANIP_GET_HMCT_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
@@ -328,7 +341,6 @@ typedef struct t_IpReassmParams
     t_Handle                        h_Ipv6Ad;
     bool                            ipv6Assigned;
     e_NetHeaderType                 hdr; /* Header selection */
-    uint16_t                        dataOffset;
     t_IpReassCommonTbl              *p_IpReassCommonTbl;
     t_IpReassTbl                    *p_Ipv4ReassTbl;
     t_IpReassTbl                    *p_Ipv6ReassTbl;
@@ -342,7 +354,6 @@ typedef struct t_IpReassmParams
     uintptr_t                       internalBufferPoolManagementIndexAddr;
     uintptr_t                       internalBufferPoolAddr;
     uint32_t                        maxNumFramesInProcess;
-    t_Handle                        h_CouplingFmPort;
     uint8_t                         sgBpid;
     uint8_t                         dataMemId;
     uint16_t                        dataLiodnOffset;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 481c929..73923c9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -59,24 +59,24 @@
 
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
-    if(!p_FmPcd->h_Fm)
+    if (!p_FmPcd->h_Fm)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
-        if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
+        if (p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
 
-        if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+        if (p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
 
-        if(!p_FmPcd->f_Exception)
+        if (!p_FmPcd->f_Exception)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
 
-        if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
+        if ((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
 
-        if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
+        if (p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
     }
 
@@ -117,7 +117,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
     memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_PCD_MAX_REPLY_SIZE));
     *p_ReplyLength = 0;
 
-    switch(p_IpcMsg->msgId)
+    switch (p_IpcMsg->msgId)
     {
         case (FM_PCD_MASTER_IS_ALIVE):
             *(uint8_t*)(p_IpcReply->replyBody) = 1;
@@ -126,14 +126,14 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             break;
         case (FM_PCD_MASTER_IS_ENABLED):
             /* count partitions registrations */
-            if(p_FmPcd->enabled)
+            if (p_FmPcd->enabled)
                 p_FmPcd->numOfEnabledGuestPartitionsPcds++;
             *(uint8_t*)(p_IpcReply->replyBody)  = (uint8_t)p_FmPcd->enabled;
             p_IpcReply->error = E_OK;
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         case (FM_PCD_GUEST_DISABLE):
-            if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
+            if (p_FmPcd->numOfEnabledGuestPartitionsPcds)
             {
                 p_FmPcd->numOfEnabledGuestPartitionsPcds--;
                 p_IpcReply->error = E_OK;
@@ -145,7 +145,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             }
             *p_ReplyLength = sizeof(uint32_t);
             break;
-        case(FM_PCD_GET_COUNTER):
+        case (FM_PCD_GET_COUNTER):
         {
             e_FmPcdCounters inCounter;
             uint32_t        outCounter;
@@ -210,83 +210,28 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
         }
         case (FM_PCD_ALLOC_PROFILES):
         {
-            t_FmPcdIpcPlcrAllocParams   ipcPlcrAllocParams;
-            uint16_t                    profilesBase;
-
-            memcpy((uint8_t*)&ipcPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcPlcrAllocParams));
-            err = PlcrAllocProfiles(h_FmPcd,
-                                    ipcPlcrAllocParams.hardwarePortId,
-                                    ipcPlcrAllocParams.num,
-                                    &profilesBase);
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&profilesBase, sizeof(uint16_t));
-            p_IpcReply->error = err;
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint16_t);
+            t_FmPcdIpcResourceAllocParams   ipcVspAllocParams;
+            uint8_t                         base;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcResourceAllocParams));
+            base =  PlcrAllocProfilesForPartition(h_FmPcd,
+                                                  ipcVspAllocParams.base,
+                                                  ipcVspAllocParams.num,
+                                                  ipcVspAllocParams.guestId);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&base, sizeof(uint8_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         }
         case (FM_PCD_FREE_PROFILES):
         {
-            t_FmPcdIpcPlcrAllocParams   ipcPlcrAllocParams;
-
-            memcpy((uint8_t*)&ipcPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcPlcrAllocParams));
-            err = PlcrFreeProfiles(h_FmPcd,
-                                   ipcPlcrAllocParams.hardwarePortId,
-                                   ipcPlcrAllocParams.num,
-                                   ipcPlcrAllocParams.plcrProfilesBase);
-            p_IpcReply->error = err;
-            *p_ReplyLength = sizeof(uint32_t);
-            break;
-        }
-        case (FM_PCD_ALLOC_SHARED_PROFILES):
-        {
-            uint16_t            numOfProfiles;
-            uint16_t            profilesIds[FM_PCD_PLCR_NUM_ENTRIES];
-            uint32_t            profilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
-            int                 i;
-
-            memset(profilesMask, 0, FM_PCD_PLCR_NUM_ENTRIES/32 * sizeof(uint32_t));
-            memcpy((uint8_t*)&numOfProfiles, p_IpcMsg->msgBody, sizeof(uint16_t));
-            err =  PlcrAllocSharedProfiles(h_FmPcd,
-                                           numOfProfiles,
-                                           profilesIds);
-            p_IpcReply->error = err;
-
-            /* translate the allocated profile id's to a 32bit * 8regs mask */
-            for(i = 0;i<numOfProfiles;i++)
-                profilesMask[profilesIds[i]/32] |= (0x80000000 >> (profilesIds[i] % 32));
-
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&profilesMask, sizeof(profilesMask));
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(profilesMask); /* num-of-shared-profiles */
-            break;
-        }
-        case (FM_PCD_FREE_SHARED_PROFILES):
-        {
-            t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrAllocParams;
-            uint16_t                            profilesIds[FM_PCD_PLCR_NUM_ENTRIES];
-            int                                 i,j, index = 0;
-            uint32_t                            walking1Mask = 0x80000000;
-
-            memset(profilesIds, 0, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
-            memcpy((uint8_t*)&ipcSharedPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcSharedPlcrAllocParams));
-            for(i = 0; i<FM_PCD_PLCR_NUM_ENTRIES/32 ; i++)
-            {
-                if(ipcSharedPlcrAllocParams.sharedProfilesMask[i])
-                {
-                    for(j = 0 ; j<32 ; j++)
-                    {
-                        if(ipcSharedPlcrAllocParams.sharedProfilesMask[i] & walking1Mask)
-                            profilesIds[index++] = (uint16_t)(i*32+j);
-                        walking1Mask >>= 1;
-                    }
-                    walking1Mask = 0x80000000;
-                }
-            }
-
-            PlcrFreeSharedProfiles(h_FmPcd,
-                                   ipcSharedPlcrAllocParams.num,
-                                   profilesIds);
+            t_FmPcdIpcResourceAllocParams   ipcVspAllocParams;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcResourceAllocParams));
+            PlcrFreeProfilesForPartition(h_FmPcd,
+                                         ipcVspAllocParams.base,
+                                         ipcVspAllocParams.num,
+                                         ipcVspAllocParams.guestId);
             break;
         }
-        case(FM_PCD_GET_SW_PRS_OFFSET):
+        case (FM_PCD_GET_SW_PRS_OFFSET):
         {
             t_FmPcdIpcSwPrsLable   ipcSwPrsLable;
             uint32_t               swPrsOffset;
@@ -300,7 +245,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
         }
-        case(FM_PCD_PRS_INC_PORT_STATS):
+        case (FM_PCD_PRS_INC_PORT_STATS):
         {
             t_FmPcdIpcPrsIncludePort   ipcPrsIncludePort;
 
@@ -310,29 +255,6 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
                                        ipcPrsIncludePort.include);
            break;
         }
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-       case(FM_PCD_KG_DUMP_REGS):
-            if((err = FM_PCD_KgDumpRegs(h_FmPcd)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-       case(FM_PCD_PLCR_DUMP_REGS):
-            if((err = FM_PCD_PlcrDumpRegs(h_FmPcd)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-       case(FM_PCD_PLCR_PROFILE_DUMP_REGS):
-       {
-            t_Handle h_Profile;
-            memcpy((uint8_t*)&h_Profile, p_IpcMsg->msgBody, sizeof(t_Handle));
-            if((err = FM_PCD_PlcrProfileDumpRegs(h_Profile)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-
-       }
-       case(FM_PCD_PRS_DUMP_REGS):
-            if((err = FM_PCD_PrsDumpRegs(h_FmPcd)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
         default:
             *p_ReplyLength = 0;
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
@@ -410,6 +332,20 @@ static t_Error FillFreeLocksLst(t_FmPcd *p_FmPcd)
     return E_OK;
 }
 
+static void ReleaseFreeLocksLst(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdLock *p_Lock;
+
+    p_Lock = DequeueLockFromFreeLst(p_FmPcd);
+    while (p_Lock)
+    {
+        XX_FreeSpinlock(p_Lock->h_Spinlock);
+        XX_Free(p_Lock);
+        p_Lock = DequeueLockFromFreeLst(p_FmPcd);
+    }
+}
+
+
 
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
@@ -427,7 +363,7 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     int     i, k, j;
 
     ASSERT_COND(p_FmPcd);
-    if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
+    if (p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
     {
         p_GrpParams->grpExists = TRUE;
         p_GrpParams->clsPlanGrpId = p_FmPcd->netEnvs[netEnvId].clsPlanGrpId;
@@ -441,16 +377,16 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
                    (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)); k++)
         {
             /* if an option exists, add it to the opts list */
-            if(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+            if (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
             {
                 /* check if this option already exists, add if it doesn't */
                 for(j = 0;j<p_GrpParams->numOfOptions;j++)
                 {
-                    if(p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    if (p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                         break;
                 }
                 p_GrpParams->optVectors[j] |= p_FmPcd->netEnvs[netEnvId].unitsVectors[i];
-                if(j == p_GrpParams->numOfOptions)
+                if (j == p_GrpParams->numOfOptions)
                 {
                     p_GrpParams->options[p_GrpParams->numOfOptions] = p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt;
                     p_GrpParams->numOfOptions++;
@@ -459,9 +395,9 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         }
     }
 
-    if(p_GrpParams->numOfOptions == 0)
+    if (p_GrpParams->numOfOptions == 0)
     {
-        if(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
+        if (p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
         {
             p_GrpParams->grpExists = TRUE;
             p_GrpParams->clsPlanGrpId = p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
@@ -506,7 +442,7 @@ t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
     p_Params->vector = 0;
     for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
     {
-        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+        if (p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
         ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
         p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
@@ -531,7 +467,7 @@ bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t uni
                   (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
                  k++)
                 /* check that no option exists */
-                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                if ((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                     return FALSE;
             break;
         }
@@ -581,7 +517,7 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
             for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS) &&
                      (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
-                if((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
+                if ((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
                     (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt == opt))
 
                 return i;
@@ -637,7 +573,7 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (2):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
         case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Disable Timeout Task with invalid IPRCPT"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
         case (4):
             RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
         case (5):
@@ -890,8 +826,11 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd->h_Fm = p_FmPcdParams->h_Fm;
     p_FmPcd->guestId = FmGetGuestId(p_FmPcd->h_Fm);
     p_FmPcd->h_FmMuram = FmGetMuramHandle(p_FmPcd->h_Fm);
-    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
-    p_FmPcd->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+    if (p_FmPcd->h_FmMuram)
+    {
+        FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
+        p_FmPcd->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+    }
 
     for(i = 0; i<FM_MAX_NUM_OF_PORTS; i++)
         p_FmPcd->netEnvs[i].clsPlanGrpId = ILLEGAL_CLS_PLAN;
@@ -915,10 +854,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No Host Command defined for a guest partition."));
 
-    if(p_FmPcdParams->kgSupport)
+    if (p_FmPcdParams->kgSupport)
     {
         p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdKg)
+        if (!p_FmPcd->p_FmPcdKg)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Keygen"));
             FM_PCD_Free(p_FmPcd);
@@ -926,10 +865,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if(p_FmPcdParams->plcrSupport)
+    if (p_FmPcdParams->plcrSupport)
     {
         p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdPlcr)
+        if (!p_FmPcd->p_FmPcdPlcr)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer"));
             FM_PCD_Free(p_FmPcd);
@@ -937,10 +876,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if(p_FmPcdParams->prsSupport)
+    if (p_FmPcdParams->prsSupport)
     {
         p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdPrs)
+        if (!p_FmPcd->p_FmPcdPrs)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Parser"));
             FM_PCD_Free(p_FmPcd);
@@ -990,7 +929,7 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     FM_GetRevision(p_FmPcd->h_Fm, &p_FmPcd->fmRevInfo);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
@@ -1036,21 +975,21 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     if (p_FmPcd->p_FmPcdKg)
     {
         err = KgInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPlcr)
     {
         err = PlcrInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPrs)
     {
         err = PrsInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1058,18 +997,13 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     {
          /* register to inter-core messaging mechanism */
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
+        if (Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
         err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, IpcMsgHandlerCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    XX_Free(p_FmPcd->p_FmPcdDriverParam);
-    p_FmPcd->p_FmPcdDriverParam = NULL;
-
-    FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
-
     /* IPv6 Frame-Id used for fragmentation */
     p_FmPcd->ipv6FrameIdAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, 4, 4));
     if (!p_FmPcd->ipv6FrameIdAddr)
@@ -1077,9 +1011,13 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
         FM_PCD_Free(p_FmPcd);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for IPv6 Frame-Id"));
     }
-
     IOMemSet32(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr), 0,  4);
 
+    XX_Free(p_FmPcd->p_FmPcdDriverParam);
+    p_FmPcd->p_FmPcdDriverParam = NULL;
+
+    FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
+
     return E_OK;
 }
 
@@ -1091,34 +1029,34 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if (p_FmPcd->ipv6FrameIdAddr)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
 
-    if(p_FmPcd->enabled)
+    if (p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
-    if(p_FmPcd->p_FmPcdDriverParam)
+    if (p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
         p_FmPcd->p_FmPcdDriverParam = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdKg)
+    if (p_FmPcd->p_FmPcdKg)
     {
-        if((err = KgFree(p_FmPcd)) != E_OK)
+        if ((err = KgFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdKg);
         p_FmPcd->p_FmPcdKg = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdPlcr)
+    if (p_FmPcd->p_FmPcdPlcr)
     {
-        if((err = PlcrFree(p_FmPcd)) != E_OK)
+        if ((err = PlcrFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdPrs)
+    if (p_FmPcd->p_FmPcdPrs)
     {
-        if(p_FmPcd->guestId == NCSW_MASTER_ID)
+        if (p_FmPcd->guestId == NCSW_MASTER_ID)
             PrsFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPrs);
         p_FmPcd->p_FmPcdPrs = NULL;
@@ -1130,13 +1068,18 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         p_FmPcd->h_Hc = NULL;
     }
 
-    if (p_FmPcd->h_Spinlock)
-        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
-
     XX_IpcUnregisterMsgHandler(p_FmPcd->fmPcdModuleName);
 
     FmUnregisterPcd(p_FmPcd->h_Fm);
 
+    ReleaseFreeLocksLst(p_FmPcd);
+
+    if (p_FmPcd->h_Spinlock)
+        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
+
+    if (p_FmPcd->h_ShadowSpinlock)
+        XX_FreeSpinlock(p_FmPcd->h_ShadowSpinlock);
+
     XX_Free(p_FmPcd);
 
     return E_OK;
@@ -1149,11 +1092,11 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
@@ -1356,7 +1299,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 for (j = 0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
                 {
-                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                    if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
                         REPORT_ERROR(MINOR, E_FULL,
@@ -1473,9 +1416,9 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     for (i = 0; i < p_NetEnvParams->numOfDistinctionUnits; i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
+            switch (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
             {
-                case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                case (HEADER_TYPE_USER_DEFINED_SHIM1):
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
@@ -1484,7 +1427,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     shim1Selected = TRUE;
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
                 break;
-                case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                case (HEADER_TYPE_USER_DEFINED_SHIM2):
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
                     break;
                 default:
@@ -1494,7 +1437,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         {
             p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
 
-            if(IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if (IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
                 p_FmPcd->netEnvs[netEnvCurrId].macsecVector = p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
         }
     }
@@ -1542,7 +1485,7 @@ t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* check that no port is bound to this netEnv */
-    if(p_FmPcd->netEnvs[netEnvId].owners)
+    if (p_FmPcd->netEnvs[netEnvId].owners)
     {
         RETURN_ERROR(MINOR, E_INVALID_STATE,
                 ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
@@ -1584,7 +1527,10 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
 
     if ((err = FM_GetFmanCtrlCodeRevision(p_FmPcd->h_Fm, &revInfo)) != E_OK)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+    {
+        DBG(WARNING, ("FM in guest-mode without IPC, can't validate firmware revision."));
+        revInfo.packageRev = IP_OFFLOAD_PACKAGE_NUMBER;
+    }
     if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
 
@@ -1602,10 +1548,10 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+            if (!p_FmPcd->p_FmPcdKg)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("KeyGen is not activated"));
                 return 0;
@@ -1614,62 +1560,59 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
                 !p_FmPcd->h_IpcSession)
             {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
                              ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
                 return 0;
             }
             break;
 
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
             if (!p_FmPcd->p_FmPcdPlcr)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Policer is not activated"));
                 return 0;
             }
-            if (p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+                !p_FmPcd->h_IpcSession)
             {
-                /* check that counters are enabled */
-                if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
-                {
-                    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-                    return 0;
-                }
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
             }
-            else
+
+            /* check that counters are enabled */
+            if (p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+                !(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
             {
-                ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
-                if (!p_FmPcd->h_IpcSession)
-                {
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
-                                 ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
-                    return 0;
-                }
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                return 0;
             }
             break;
 
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if (!p_FmPcd->p_FmPcdPrs)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Parser is not activated"));
                 return 0;
@@ -1678,7 +1621,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
                 !p_FmPcd->h_IpcSession)
             {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
                              ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
                 return 0;
             }
@@ -1714,58 +1657,58 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         return outCounter;
     }
 
-    switch(counter)
+    switch (counter)
     {
         /* Parser statistics */
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
                return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
 
         /* Policer statistics */
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
 
         default:
@@ -1817,35 +1760,35 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
 
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
         else
             p_FmPcd->exceptions &= ~bitMask;
 
-        switch(exception)
+        switch (exception)
         {
-            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-                if(!p_FmPcd->p_FmPcdKg)
+            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+                if (!p_FmPcd->p_FmPcdKg)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-                if(!p_FmPcd->p_FmPcdPlcr)
+            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if (!p_FmPcd->p_FmPcdPlcr)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-                if(!p_FmPcd->p_FmPcdPrs)
+            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                if (!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
             break;
             default:
@@ -1853,67 +1796,67 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
         }
 
-        switch(exception)
+        switch (exception)
         {
-            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_KG_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
                 else
                     tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
                 break;
-            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PRS_SINGLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 else
                     tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
@@ -1924,12 +1867,12 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
            Driver may disable them automatically, depending on driver's status */
-        if(enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmEnableRamsEcc(p_FmPcd->h_Fm);
-        if(!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
@@ -1948,33 +1891,33 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ForceIntr - guest mode!"));
 
-    switch(exception)
+    switch (exception)
     {
-        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            if (!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
             break;
-        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-            if(!p_FmPcd->p_FmPcdPlcr)
+        case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+        case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if (!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-           if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+           if (!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
 
     }
-    switch(exception)
+    switch (exception)
     {
         case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
@@ -2031,123 +1974,123 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ModifyCounter - guest mode!"));
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+            if (!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - KeyGen is not working"));
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-            if(!p_FmPcd->p_FmPcdPlcr)
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if (!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - Policer is not working"));
-            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if (!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
     }
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
              break;
-       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+       case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
              break;
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
             WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
             break;
 
         /*Policer counters*/
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
             break;
         default:
@@ -2156,4 +2099,3 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
 
 return E_OK;
 }
-
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 57e6ba9..0fc2463 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -153,7 +153,7 @@ typedef _Packed struct {
 } _PackedType t_FmPcdKgClsPlanRegs;
 
 typedef _Packed union {
-    t_FmPcdKgInterModuleSchemeRegs  schemeRegs;
+    t_FmPcdKgSchemeRegs             schemeRegs;
     t_FmPcdKgPortConfigRegs         portRegs;
     t_FmPcdKgClsPlanRegs            clsPlanRegs;
 } _PackedType u_FmPcdKgIndirectAccessRegs;
@@ -204,7 +204,7 @@ typedef _Packed struct {
     volatile uint32_t fmpl_res0[21];    /* 0x038 - 0x08B Reserved */
 /* Profile RAM Access Registers */
     volatile uint32_t fmpl_par;         /* 0x08C FMPL_PAR    - FM Policer Profile Action Register*/
-    t_FmPcdPlcrInterModuleProfileRegs profileRegs;
+    t_FmPcdPlcrProfileRegs profileRegs;
 /* Error Capture Registers */
     volatile uint32_t fmpl_serc;        /* 0x100 FMPL_SERC - FM Policer Soft Error Capture */
     volatile uint32_t fmpl_upcr;        /* 0x104 FMPL_UPCR - FM Policer Uninitialized Profile Capture Register */
@@ -367,13 +367,14 @@ typedef struct {
 
 typedef struct {
     t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
+    uint8_t                         partPlcrProfilesBase;
+    uint16_t                        partNumOfPlcrProfiles;
     t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
     uint16_t                        numOfSharedProfiles;
     uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
     t_FmPcdPlcrMapParam             portsMapping[FM_MAX_NUM_OF_PORTS];
     t_Handle                        h_HwSpinlock;
     t_Handle                        h_SwSpinlock;
-
 } t_FmPcdPlcr;
 
 typedef struct {
@@ -457,7 +458,11 @@ typedef struct {
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
 } t_FmPcd;
 
-
+#if (DPAA_VERSION >= 11)
+typedef uint8_t t_FmPcdFrmReplicUpdateType;
+#define FRM_REPLIC_UPDATE_COUNTER             0x01
+#define FRM_REPLIC_UPDATE_INFO                0x02
+#endif /* (DPAA_VERSION >= 11) */
 /***********************************************************************/
 /*  PCD internal routines                                              */
 /***********************************************************************/
@@ -473,7 +478,7 @@ uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeader
 
 t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId);
 t_Error     FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip);
-bool        FmPcdManipIsIpPresent(t_FmPcd *p_FmPcd, uint8_t netEnvId, bool ipv6);
+bool        FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip);
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     KgInit(t_FmPcd *p_FmPcd);
@@ -499,10 +504,8 @@ t_Error     PlcrInit(t_FmPcd *p_FmPcd);
 t_Error     PlcrFree(t_FmPcd *p_FmPcd);
 void        PlcrEnable(t_FmPcd *p_FmPcd);
 void        PlcrDisable(t_FmPcd *p_FmPcd);
-t_Error     PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num, uint16_t base);
-t_Error     PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base);
-t_Error     PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
-void        PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+uint8_t     PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId);
+void        PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId);
 
 t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
 t_Error     PrsInit(t_FmPcd *p_FmPcd);
@@ -515,11 +518,14 @@ t_Error     FmPcdCcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpB
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint16_t    FmPcdCcGetNumOfKeys(t_Handle h_CcNode);
-t_Error     ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, e_FmPcdCcStatsMode supportedStatsMode);
 
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
 t_Error     FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_InfoForManip, uint32_t *requiredAction);
-void        FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew);
+void        FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
+                                          t_FmPcdCcNextEngineParams    *p_CcNextEngineParams,
+                                          t_Handle                     p_Ad,
+                                          t_Handle                     *p_AdNewPtr);
 void        FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset);
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
 t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode);
@@ -528,9 +534,9 @@ t_Handle    FmPcdManipApplSpecificBuild(void);
 bool        FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip);
 #endif /* FM_CAPWAP_SUPPORT */
 #if (DPAA_VERSION >= 11)
-void *      FrmReplicGetSourceTableDescriptor(t_Handle h_ReplicGroup);
-void        FrmReplicUpdateGroupOwner(t_Handle h_ReplicGroup, bool add, bool fullUpdate, t_Handle h_FmPcdCcNode);
-void        FrmReplicUpdateAdContLookupForCc(t_Handle h_ReplicGroup, t_Handle p_Ad, t_Handle *h_AdNew);
+void *      FrmReplicGroupGetSourceTableDescriptor(t_Handle h_ReplicGroup);
+void        FrmReplicGroupUpdateOwner(t_Handle h_ReplicGroup, bool add);
+void        FrmReplicGroupUpdateAd(t_Handle h_ReplicGroup, void *p_Ad, t_Handle *h_AdNew);
 
 void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
                                                      t_Handle   h_ReplicGroup,
@@ -543,8 +549,19 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
 t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock);
 
 
-void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd);
-void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams);
+void NextStepAd(t_Handle                     h_Ad,
+                t_Handle                     h_StatsAd,
+                t_Handle                     h_StatsCounters,
+                t_Handle                     h_StatsFrameLengthRanges,
+                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                t_FmPcd                      *p_FmPcd);
+
+void FillAdOfTypeResult(t_Handle                    h_Ad,
+                        t_Handle                    h_StatsAd,
+                        t_Handle                    h_StatsCounters,
+                        t_Handle                    h_StatsFrameLengthRanges,
+                        t_FmPcd                     *p_FmPcd,
+                        t_FmPcdCcNextEngineParams   *p_CcNextEngineParams);
 void ReleaseLst(t_List *p_List);
 
 static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index c0a47b6..1ac58b7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -94,47 +94,29 @@ typedef  struct t_FmPcdIpcKgClsPlanParams
     uint8_t     clsPlanBase;
 } _PackedType t_FmPcdIpcKgClsPlanParams;
 
-typedef _Packed struct t_FmPcdIpcPlcrAllocParams
-{
-    uint16_t    num;
-    uint8_t     hardwarePortId;
-    uint16_t    plcrProfilesBase;
-} _PackedType t_FmPcdIpcPlcrAllocParams;
-
-typedef _Packed struct t_FmPcdIpcSharedPlcrAllocParams
-{
-    uint16_t    num;
-    uint32_t    sharedProfilesMask[8];
-} _PackedType t_FmPcdIpcSharedPlcrAllocParams;
-
 typedef _Packed struct t_FmPcdIpcPrsIncludePort
 {
     uint8_t     hardwarePortId;
     bool        include;
 } _PackedType t_FmPcdIpcPrsIncludePort;
 
-#if (DPAA_VERSION >= 11)
-typedef _Packed struct t_FmPcdIpcSpAllocParams
-{
+typedef _Packed struct t_FmPcdIpcResourceAllocParams {
+    uint8_t     guestId;
+    uint8_t     base;
     uint16_t    num;
-    uint8_t     hardwarePortId;
-    uint16_t    spProfilesBase;
-} _PackedType t_FmPcdIpcSpAllocParams;
-#endif /* (DPAA_VERSION >= 11) */
+}_PackedType t_FmPcdIpcResourceAllocParams;
 
 
 #define FM_PCD_MAX_REPLY_SIZE           16
 #define FM_PCD_MAX_MSG_SIZE             36
 #define FM_PCD_MAX_REPLY_BODY_SIZE      36
 
-typedef _Packed struct
-{
+typedef _Packed struct {
     uint32_t    msgId;
     uint8_t     msgBody[FM_PCD_MAX_MSG_SIZE];
 } _PackedType t_FmPcdIpcMsg;
 
-typedef _Packed struct t_FmPcdIpcReply
-{
+typedef _Packed struct t_FmPcdIpcReply {
     uint32_t    error;
     uint8_t     replyBody[FM_PCD_MAX_REPLY_BODY_SIZE];
 } _PackedType t_FmPcdIpcReply;
@@ -201,24 +183,6 @@ typedef _Packed struct t_FmPcdIpcReply
 #define FM_PCD_GET_SW_PRS_OFFSET                8
 
 /**************************************************************************//**
- @Function      FM_PCD_ALLOC_SHARED_PROFILES
-
- @Description   Used by FM PCD front-end in order to allocate shared profiles
-
- @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
-*//***************************************************************************/
-#define FM_PCD_ALLOC_SHARED_PROFILES            9
-
-/**************************************************************************//**
- @Function      FM_PCD_FREE_SHARED_PROFILES
-
- @Description   Used by FM PCD front-end in order to free shared profiles
-
- @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
-*//***************************************************************************/
-#define FM_PCD_FREE_SHARED_PROFILES             10
-
-/**************************************************************************//**
  @Function      FM_PCD_MASTER_IS_ENABLED
 
  @Description   Used by FM front-end in order to verify
@@ -239,42 +203,6 @@ typedef _Packed struct t_FmPcdIpcReply
 #define FM_PCD_GUEST_DISABLE                    16
 
 /**************************************************************************//**
- @Function      FM_PCD_KG_DUMP_REGS
-
- @Description   Used by FM front-end to dump KG registers
-
- @Param[in]     None
-*//***************************************************************************/
-#define FM_PCD_KG_DUMP_REGS                     18
-
-/**************************************************************************//**
- @Function      FM_PCD_PLCR_DUMP_REGS
-
- @Description   Used by FM front-end to dump PLCR registers
-
- @Param[in]     None
-*//***************************************************************************/
-#define FM_PCD_PLCR_DUMP_REGS                   19
-
-/**************************************************************************//**
- @Function      FM_PCD_PLCR_PROFILE_DUMP_REGS
-
- @Description   Used by FM front-end to dump PLCR specified profile registers
-
- @Param[in]     t_Handle Pointer
-*//***************************************************************************/
-#define FM_PCD_PLCR_PROFILE_DUMP_REGS           20
-
-/**************************************************************************//**
- @Function      FM_PCD_PRS_DUMP_REGS
-
- @Description   Used by FM front-end to dump PRS registers
-
- @Param[in]     None
-*//***************************************************************************/
-#define FM_PCD_PRS_DUMP_REGS                    21
-
-/**************************************************************************//**
  @Function      FM_PCD_FREE_KG_CLSPLAN
 
  @Description   Used by FM PCD front-end in order to Free KG classification plan entries
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index fc8546a..265d4ee 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -50,6 +50,10 @@
 #include "fm_plcr.h"
 
 
+/****************************************/
+/*       static functions               */
+/****************************************/
+
 static uint32_t PlcrProfileLock(t_Handle h_Profile)
 {
     ASSERT_COND(h_Profile);
@@ -105,8 +109,8 @@ static bool IsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
 
-    for(i=0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
-        if(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] == absoluteProfileId)
+    for (i=0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
+        if (p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] == absoluteProfileId)
             return TRUE;
     return FALSE;
 }
@@ -121,10 +125,10 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
 
     switch (nextEngine)
     {
-        case e_FM_PCD_DONE :
+        case e_FM_PCD_DONE:
             switch (p_NextEngineParams->action)
             {
-                case e_FM_PCD_DROP_FRAME :
+                case e_FM_PCD_DROP_FRAME:
                     nia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                     break;
                 case e_FM_PCD_ENQ_FRAME:
@@ -137,19 +141,19 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
         case e_FM_PCD_KG:
             physicalSchemeId = FmPcdKgGetSchemeId(p_NextEngineParams->h_DirectScheme);
             relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
-            if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
             if (!FmPcdKgIsSchemeValidSw(p_NextEngineParams->h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+            if (!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
             nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicalSchemeId;
             break;
         case e_FM_PCD_PLCR:
             absoluteProfileId = ((t_FmPcdPlcrProfile *)p_NextEngineParams->h_Profile)->absoluteProfileId;
-            if(!IsProfileShared(p_FmPcd, absoluteProfileId))
+            if (!IsProfileShared(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
-            if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+            if (!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
             nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
             break;
@@ -250,7 +254,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
      * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
      * limited by the 10G physical port.
      */
-    if(temp != 0)
+    if (temp != 0)
     {
         /* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
          * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
@@ -271,7 +275,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
             temp = temp << 1;
             fppShift++;
         }
-        if(fppShift > 15)
+        if (fppShift > 15)
         {
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
             return;
@@ -280,7 +284,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
     else
     {
         temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
-        if(!temp)
+        if (!temp)
             /* integer and fraction are 0, we set FP to its max val */
             fppShift = 31;
         else
@@ -328,169 +332,499 @@ static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
     while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
 }
 
-/*********************************************/
-/*............Policer Exception..............*/
-/*********************************************/
-static void EventsCB(t_Handle h_FmPcd)
+static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
+                                t_FmPcdPlcrProfileParams    *p_ProfileParams,
+                                t_FmPcdPlcrProfileRegs      *p_PlcrRegs)
 {
-    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t event, mask, force;
+    t_Error                 err = E_OK;
+    uint32_t                pemode, gnia, ynia, rnia;
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+    ASSERT_COND(p_FmPcd);
 
-    event &= mask;
+/* Set G, Y, R Nia */
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnYellow, &(p_ProfileParams->paramsOnYellow), &ynia);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnRed,    &(p_ProfileParams->paramsOnRed), &rnia);
+   if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr);
-    if(force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, force & ~event);
+/* Mode fmpl_pemode */
+    pemode = FM_PCD_PLCR_PEMODE_PI;
 
+    switch (p_ProfileParams->algSelection)
+    {
+        case e_FM_PCD_PLCR_PASS_THROUGH:
+            p_PlcrRegs->fmpl_pecir         = 0;
+            p_PlcrRegs->fmpl_pecbs         = 0;
+            p_PlcrRegs->fmpl_pepepir_eir   = 0;
+            p_PlcrRegs->fmpl_pepbs_ebs     = 0;
+            p_PlcrRegs->fmpl_pelts         = 0;
+            p_PlcrRegs->fmpl_pects         = 0;
+            p_PlcrRegs->fmpl_pepts_ets     = 0;
+            pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
+            switch (p_ProfileParams->colorMode)
+            {
+                case e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    switch (p_ProfileParams->color.dfltColor)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
 
-    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
+                    break;
+                case e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
 
-    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
-    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
-}
+        case e_FM_PCD_PLCR_RFC_2698:
+            /* Select algorithm MODE[ALG] = "01" */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
+            if (p_ProfileParams->nonPassthroughAlgParams.comittedInfoRate > p_ProfileParams->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
+            goto cont_rfc;
+        case e_FM_PCD_PLCR_RFC_4115:
+            /* Select algorithm MODE[ALG] = "10" */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
+cont_rfc:
+            /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
+            switch (p_ProfileParams->colorMode)
+            {
+                case e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                case e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    /*In color aware more select override color interpretation (MODE[OVCLR]) */
+                    switch (p_ProfileParams->color.override)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_G_NC;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
+            switch (p_ProfileParams->nonPassthroughAlgParams.rateMode)
+            {
+                case e_FM_PCD_PLCR_BYTE_MODE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
+                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
+                        {
+                            case e_FM_PCD_PLCR_L2_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
+                                break;
+                            case e_FM_PCD_PLCR_L3_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L3;
+                                break;
+                            case e_FM_PCD_PLCR_L4_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L4;
+                                break;
+                            case e_FM_PCD_PLCR_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_FULL;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
+                        {
+                            case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
+                                pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            case e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                    break;
+                case e_FM_PCD_PLCR_PACKET_MODE:
+                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
+               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
+               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
 
-/* ..... */
+            /* Configure Traffic Parameters*/
+            {
+                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
 
-static void ErrorExceptionsCB(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t            event, force, captureReg, mask;
+                CalcRates(p_FmPcd, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                /*  Set Committed Information Rate (CIR) */
+                p_PlcrRegs->fmpl_pecir = cir;
+                /*  Set Committed Burst Size (CBS). */
+                p_PlcrRegs->fmpl_pecbs =  cbs;
+                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
+                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
+                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
+                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
 
-    event &= mask;
+                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
+                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
+                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
+                /* Committed Rate Token Bucket Size (CTS) */
+                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
 
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr);
-    if(force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, force & ~event);
+                /* Set the FPP based on calculation */
+                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
+            }
+            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
 
-    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
+    p_PlcrRegs->fmpl_pemode = pemode;
 
-    if (event & FM_PCD_PLCR_DOUBLE_ECC)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC);
-    if (event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
-    {
-        captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
-        /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
-        p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
-        p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
-        p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
-        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
-        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
-    }
-}
+    p_PlcrRegs->fmpl_pegnia = gnia;
+    p_PlcrRegs->fmpl_peynia = ynia;
+    p_PlcrRegs->fmpl_pernia = rnia;
 
+    /* Zero Counters */
+    p_PlcrRegs->fmpl_pegpc     = 0;
+    p_PlcrRegs->fmpl_peypc     = 0;
+    p_PlcrRegs->fmpl_perpc     = 0;
+    p_PlcrRegs->fmpl_perypc    = 0;
+    p_PlcrRegs->fmpl_perrpc    = 0;
 
+    return E_OK;
+}
 
-t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+static t_Error AllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
 {
-    t_FmPcdPlcr *p_FmPcdPlcr;
-    /*uint8_t i=0;*/
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        profilesFound, log2Num, tmpReg32;
+    uint32_t        intFlags;
+    uint16_t        first, i;
 
-    UNUSED(p_FmPcd);
-    UNUSED(p_FmPcdParams);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
-    if (!p_FmPcdPlcr)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
-        return NULL;
-    }
-    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        p_FmPcdPlcr->p_FmPcdPlcrRegs  = (t_FmPcdPlcrRegs *)UINT_TO_PTR(FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm));
-        p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
-        p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
-    }
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if (!numOfProfiles)
+        return E_OK;
 
-    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
+    ASSERT_COND(hardwarePortId);
 
-    return p_FmPcdPlcr;
-}
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
-t_Error PlcrInit(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdDriverParam              *p_Param = p_FmPcd->p_FmPcdDriverParam;
-    t_FmPcdPlcr                     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
-    uint32_t                        tmpReg32 = 0;
-    t_Error                         err = E_OK;
-    t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    if (!POWER_OF_2(numOfProfiles))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
-    p_FmPcdPlcr->h_HwSpinlock = XX_InitSpinlock();
-    if (!p_FmPcdPlcr->h_HwSpinlock)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer HW spinlock"));
 
-    p_FmPcdPlcr->h_SwSpinlock = XX_InitSpinlock();
-    if (!p_FmPcdPlcr->h_SwSpinlock)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer SW spinlock"));
+    if (GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
 
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        (p_FmPcdPlcr->numOfSharedProfiles))
-    {
-        t_FmPcdIpcMsg                   msg;
-        uint32_t                        replyLength;
-        t_FmPcdIpcReply                 reply;
-        int         i, j, index = 0;
-        uint32_t    walking1Mask = 0x80000000;
-        uint32_t    sharedProfilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
+    first = 0;
+    profilesFound = 0;
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
 
-        memset(sharedProfilesMask, 0, FM_PCD_PLCR_NUM_ENTRIES/32 * sizeof(uint32_t));
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_ALLOC_SHARED_PROFILES;
-        memcpy(msg.msgBody, (uint8_t *)&p_FmPcdPlcr->numOfSharedProfiles, sizeof(uint16_t));
-        replyLength = sizeof(uint32_t) + sizeof(sharedProfilesMask);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+ sizeof(p_FmPcdPlcr->numOfSharedProfiles),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(sharedProfilesMask)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    for (i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
+    {
+        if (!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if (profilesFound == numOfProfiles)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfProfiles);
+        }
+    }
 
-        memcpy(sharedProfilesMask, reply.replyBody, sizeof(sharedProfilesMask));
-        /* translate 8 regs of 32 bits masks into an array of up to 256 indexes. */
-        for(i = 0; i<FM_PCD_PLCR_NUM_ENTRIES/32 ; i++)
+    if (profilesFound == numOfProfiles)
+    {
+        for (i=first; i<first + numOfProfiles; i++)
         {
-            if(sharedProfilesMask[i])
-            {
-                for(j = 0 ; j<32 ; j++)
-                {
-                    if(sharedProfilesMask[i] & walking1Mask)
-                        p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[index++] = (uint16_t)(i*32+j);
-                    walking1Mask >>= 1;
-                }
-                walking1Mask = 0x80000000;
-            }
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
         }
-        return (t_Error)reply.error;
     }
+    else
+    {
+        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    /**********************FMPL_PMRx******************/
+    LOG2((uint64_t)numOfProfiles, log2Num);
+    tmpReg32 = first;
+    tmpReg32 |= log2Num << 16;
+    tmpReg32 |= FM_PCD_PLCR_PMR_V;
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
+
+    *p_Base = first;
+
+    return E_OK;
+}
+
+static t_Error FreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint16_t        i;
+    uint32_t        intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPcdPlcr->numOfSharedProfiles)
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
+
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+    for (i = base; i<base+numOfProfiles;i++)
     {
-        err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
-        if(err)
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
+
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+    }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    return E_OK;
+}
+
+static t_Error AllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint32_t        profilesFound;
+    uint16_t        i, k=0;
+    uint32_t        intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if (!numOfProfiles)
+        return E_OK;
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+    /* Find numOfProfiles free profiles (may be spread) */
+    profilesFound = 0;
+    for (i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+        if (!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            profilesIds[k] = i;
+            k++;
+            if (profilesFound == numOfProfiles)
+                break;
+        }
+
+    if (profilesFound != numOfProfiles)
+    {
+        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
+    }
+
+    for (i = 0;i<k;i++)
+    {
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
+    }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    return E_OK;
+}
+
+static void FreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(numOfProfiles);
+
+    for (i=0; i<numOfProfiles; i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
+    }
+}
+
+/*********************************************/
+/*............Policer Exception..............*/
+/*********************************************/
+static void EventsCB(t_Handle h_FmPcd)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t event, mask, force;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+
+    event &= mask;
+
+    /* clear the forced events */
+    force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr);
+    if (force & event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, force & ~event);
+
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
+
+    if (event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
+    if (event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
+}
+
+/* ..... */
+
+static void ErrorExceptionsCB(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event, force, captureReg, mask;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+
+    event &= mask;
+
+    /* clear the forced events */
+    force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr);
+    if (force & event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, force & ~event);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
+
+    if (event & FM_PCD_PLCR_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC);
+    if (event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
+    {
+        captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
+        /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
+        p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
+        p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
+        p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
+        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
+    }
+}
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
+t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPlcr *p_FmPcdPlcr;
+    uint16_t    i=0;
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
+    if (!p_FmPcdPlcr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        p_FmPcdPlcr->p_FmPcdPlcrRegs  = (t_FmPcdPlcrRegs *)UINT_TO_PTR(FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
+        p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
+    }
+
+    p_FmPcdPlcr->numOfSharedProfiles    = DEFAULT_numOfSharedPlcrProfiles;
+
+    p_FmPcdPlcr->partPlcrProfilesBase   = p_FmPcdParams->partPlcrProfilesBase;
+    p_FmPcdPlcr->partNumOfPlcrProfiles  = p_FmPcdParams->partNumOfPlcrProfiles;
+    /* for backward compatabilty. if no policer profile, will set automatically to the max */
+    if ((p_FmPcd->guestId == NCSW_MASTER_ID) &&
+        (p_FmPcdPlcr->partNumOfPlcrProfiles == 0))
+        p_FmPcdPlcr->partNumOfPlcrProfiles = FM_PCD_PLCR_NUM_ENTRIES;
+
+    for (i=0; i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+        p_FmPcdPlcr->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
+
+    return p_FmPcdPlcr;
+}
+
+t_Error PlcrInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam              *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPlcr                     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    t_Error                         err = E_OK;
+    uint32_t                        tmpReg32 = 0;
+
+    if ((p_FmPcdPlcr->partPlcrProfilesBase + p_FmPcdPlcr->partNumOfPlcrProfiles) > FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partPlcrProfilesBase+partNumOfPlcrProfiles out of range!!!"));
+
+    p_FmPcdPlcr->h_HwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcdPlcr->h_HwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer HW spinlock"));
+
+    p_FmPcdPlcr->h_SwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcdPlcr->h_SwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer SW spinlock"));
+
+    if (p_FmPcdPlcr->numOfSharedProfiles)
+    {
+        err = AllocSharedProfiles(p_FmPcd,
+                                  p_FmPcdPlcr->numOfSharedProfiles,
+                                  p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+        if (err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
 
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        return E_OK;
+
     /**********************FMPL_GCR******************/
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
-    if(p_Param->plcrAutoRefresh)
+    if (p_Param->plcrAutoRefresh)
         tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
     tmpReg32 |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
 
@@ -502,12 +836,12 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     /**********************FMPL_EEVR******************/
     /**********************FMPL_EIER******************/
     tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+    if (p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+    if (p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
         tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
     WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
     /**********************FMPL_EIER******************/
@@ -517,16 +851,26 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     /**********************FMPL_EVR******************/
     /**********************FMPL_IER******************/
     tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+    if (p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
         tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+    if (p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE)
         tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
     WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
     /**********************FMPL_IER******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, ErrorExceptionsCB, p_FmPcd);
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, EventsCB, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm,
+                   e_FM_MOD_PLCR,
+                   0,
+                   e_FM_INTR_TYPE_ERR,
+                   ErrorExceptionsCB,
+                   p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm,
+                   e_FM_MOD_PLCR,
+                   0,
+                   e_FM_INTR_TYPE_NORMAL,
+                   EventsCB,
+                   p_FmPcd);
 
     /* driver initializes one DFLT profile at the last entry*/
     /**********************FMPL_DPMR******************/
@@ -539,42 +883,20 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
 
 t_Error PlcrFree(t_FmPcd *p_FmPcd)
 {
-    t_Error                             err;
-
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
 
-    if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
-    {
-        if(p_FmPcd->guestId != NCSW_MASTER_ID)
-        {
-            t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-            t_FmPcdIpcMsg                       msg;
-            int                                 i;
-
-            memset(ipcSharedPlcrParams.sharedProfilesMask, 0, sizeof(ipcSharedPlcrParams.sharedProfilesMask));
-            /* Free resources using IPC messaging */
-            ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
-
-            /* translate the allocated profile id's to a 32bit * 8regs mask */
-            for(i = 0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
-                ipcSharedPlcrParams.sharedProfilesMask[p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i]/32] |= (0x80000000 >> (p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] % 32));
-
-            memset(&msg, 0, sizeof(msg));
-            msg.msgId = FM_PCD_FREE_SHARED_PROFILES;
-            memcpy(msg.msgBody, &ipcSharedPlcrParams, sizeof(ipcSharedPlcrParams));
-            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId)+sizeof(ipcSharedPlcrParams),
-                                         NULL,
-                                         NULL,
-                                         NULL,
-                                         NULL)) != E_OK)
-                RETURN_ERROR(MAJOR, err,NO_MSG);
-        }
-       /* else
-            PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);*/
-    }
+    if (p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+        FreeSharedProfiles(p_FmPcd,
+                           p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles,
+                           p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+
+    if (p_FmPcd->p_FmPcdPlcr->h_SwSpinlock)
+        XX_FreeSpinlock(p_FmPcd->p_FmPcdPlcr->h_SwSpinlock);
+
+    if (p_FmPcd->p_FmPcdPlcr->h_HwSpinlock)
+        XX_FreeSpinlock(p_FmPcd->p_FmPcdPlcr->h_HwSpinlock);
+
     return E_OK;
 }
 
@@ -592,6 +914,136 @@ void PlcrDisable(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
 }
 
+uint8_t PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId)
+{
+    uint8_t     profilesFound = 0;
+    int         i = 0;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr);
+
+    if (!numOfProfiles)
+        return E_OK;
+
+    if ((numOfProfiles > FM_PCD_PLCR_NUM_ENTRIES) ||
+        (base + numOfProfiles > FM_PCD_PLCR_NUM_ENTRIES))
+        return (uint8_t)ILLEGAL_BASE;
+
+    if (p_FmPcd->h_IpcSession)
+    {
+        t_FmPcdIpcResourceAllocParams   ipcProfilesAllocParams;
+        t_FmPcdIpcMsg                   msg;
+        t_FmPcdIpcReply                 reply;
+        t_Error                         err;
+        uint32_t                        replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmPcdIpcResourceAllocParams));
+        ipcProfilesAllocParams.guestId         = p_FmPcd->guestId;
+        ipcProfilesAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
+        ipcProfilesAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
+        msg.msgId                              = FM_PCD_ALLOC_PROFILES;
+        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmPcdIpcResourceAllocParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmPcdIpcResourceAllocParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if ((err != E_OK) ||
+            (replyLength != (sizeof(uint32_t) + sizeof(uint8_t))))
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return (uint8_t)ILLEGAL_BASE;
+        }
+        else
+            memcpy((uint8_t*)&p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase, reply.replyBody, sizeof(uint8_t));
+        if (p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase == ILLEGAL_BASE)
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return (uint8_t)ILLEGAL_BASE;
+        }
+    }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+        return (uint8_t)ILLEGAL_BASE;
+    }
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    for (i = base; i < base + numOfProfiles; i++)
+        if (p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
+            profilesFound++;
+        else
+            break;
+
+    if (profilesFound == numOfProfiles)
+        for (i = base; i<base + numOfProfiles; i++)
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = guestId;
+    else
+    {
+        XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+        return (uint8_t)ILLEGAL_BASE;
+    }
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+
+    return base;
+}
+
+void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId)
+{
+    int     i = 0;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr);
+
+    if (p_FmPcd->h_IpcSession)
+    {
+        t_FmPcdIpcResourceAllocParams   ipcProfilesAllocParams;
+        t_FmPcdIpcMsg                   msg;
+        t_FmPcdIpcReply                 reply;
+        t_Error                         err;
+        uint32_t                        replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmPcdIpcResourceAllocParams));
+        ipcProfilesAllocParams.guestId         = p_FmPcd->guestId;
+        ipcProfilesAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
+        ipcProfilesAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
+        msg.msgId                              = FM_PCD_FREE_PROFILES;
+        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmPcdIpcResourceAllocParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmPcdIpcResourceAllocParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+        return;
+    }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+        return;
+    }
+
+    for (i=base; i<numOfProfiles; i++)
+    {
+        if (p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == guestId)
+           p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
+        else
+            DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
+    }
+}
+
 t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
 {
     t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
@@ -605,7 +1057,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
 
-    if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileIndx))
+    if (!FmPcdPlcrIsProfileValid(p_FmPcd, profileIndx))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
 
     /*intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);*/
@@ -627,12 +1079,12 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     intFlags = PlcrHwLock(p_FmPcdPlcr);
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
-    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
+    if (!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
        !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
     {
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
+            if ((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
             {
@@ -641,10 +1093,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -657,10 +1109,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 WritePar(p_FmPcd, tmpReg32);
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -674,10 +1126,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 PlcrHwUnlock(p_FmPcdPlcr, intFlags);
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -702,514 +1154,95 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     return E_OK;
 }
 
-void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    /* this routine is protected by calling routine */
-
-    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
-
-    if(add)
-        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
-    else
-        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
-}
-
-uint32_t FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
-
-    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners;
-}
-
-uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
-
-    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
-}
-
-t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-    t_Error                     err = E_OK;
-    uint16_t                    base;
-    uint16_t                    swPortIndex = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    if(!numOfProfiles)
-        return E_OK;
-
-    memset(&ipcPlcrParams, 0, sizeof(ipcPlcrParams));
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        t_FmPcdIpcMsg               msg;
-        uint32_t                    replyLength;
-        t_FmPcdIpcReply             reply;
-
-        /* Allocate resources using IPC messaging */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        ipcPlcrParams.num = numOfProfiles;
-        ipcPlcrParams.hardwarePortId = hardwarePortId;
-        msg.msgId = FM_PCD_ALLOC_PROFILES;
-        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
-        replyLength = sizeof(uint32_t) + sizeof(uint16_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != sizeof(uint32_t) + sizeof(uint16_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MAJOR, (t_Error)reply.error, ("PLCR profiles allocation failed"));
-
-        memcpy((uint8_t*)&base, reply.replyBody, sizeof(uint16_t));
-    }
-    else /* master */
-    {
-        err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
-        if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-    }
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
-
-    return E_OK;
-}
-
-t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-    t_Error                     err = E_OK;
-    uint16_t                    swPortIndex = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        t_FmPcdIpcMsg               msg;
-        uint32_t                    replyLength;
-        t_FmPcdIpcReply             reply;
-
-        /* Allocate resources using IPC messaging */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
-        ipcPlcrParams.hardwarePortId = hardwarePortId;
-        ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
-        msg.msgId = FM_PCD_FREE_PROFILES;
-        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
-        replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if ((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MINOR, (t_Error)reply.error, ("PLCR Free Profiles failed"));
-    }
-    else /* master */
-    {
-        err = PlcrFreeProfiles(p_FmPcd,
-                               hardwarePortId,
-                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles,
-                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
-        if (err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-    }
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
-
-    return E_OK;
-}
-
-bool FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
-
-    ASSERT_COND(absoluteProfileId < FM_PCD_PLCR_NUM_ENTRIES);
-
-    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
-}
-
-t_Error PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
-{
-    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint32_t        profilesFound, log2Num, tmpReg32;
-    uint32_t        intFlags;
-    uint16_t        first, i;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    if(!numOfProfiles)
-        return E_OK;
-
-    ASSERT_COND(hardwarePortId);
-
-    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
-
-    if (!POWER_OF_2(numOfProfiles))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
-
-
-    if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
-
-    first = 0;
-    profilesFound = 0;
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-
-    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
-    {
-        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
-        {
-            profilesFound++;
-            i++;
-            if(profilesFound == numOfProfiles)
-                break;
-        }
-        else
-        {
-            profilesFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfProfiles);
-        }
-    }
-    if(profilesFound == numOfProfiles)
-    {
-        for(i = first; i<first + numOfProfiles; i++)
-        {
-            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
-            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
-        }
-    }
-    else
-    {
-        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
-    }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
-    /**********************FMPL_PMRx******************/
-    LOG2((uint64_t)numOfProfiles, log2Num);
-    tmpReg32 = first;
-    tmpReg32 |= log2Num << 16;
-    tmpReg32 |= FM_PCD_PLCR_PMR_V;
-    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
-
-    *p_Base = first;
-
-    return E_OK;
-}
-
-t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
-{
-    uint32_t        profilesFound;
-    uint16_t        i, k=0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC, so no need for lock */
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    if(!numOfProfiles)
-        return E_OK;
-
-    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
-
-    /* Find numOfProfiles free profiles (may be spread) */
-    profilesFound = 0;
-    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
-    {
-        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
-        {
-            profilesFound++;
-            profilesIds[k] = i;
-            k++;
-            if(profilesFound == numOfProfiles)
-                break;
-        }
-    }
-    if(profilesFound != numOfProfiles)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
-
-    for(i = 0;i<k;i++)
-    {
-        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
-        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
-    }
-
-    return E_OK;
-}
-
-t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
-{
-    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint16_t        i;
-    uint32_t        intFlags;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
-    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
-
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-    for(i = base; i<base+numOfProfiles;i++)
-    {
-        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
-        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
-
-        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
-        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
-    }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
-    return E_OK;
-}
-
-void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add)
 {
-    uint16_t        i;
-
-    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    /* this routine is protected by calling routine */
 
-    /* This routine is issued only on master core of master partition -
-       either directly or through IPC, so no need for lock */
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    for(i=0;i<numOfProfiles; i++)
-    {
-        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
-        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
-    }
+    if (add)
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
+    else
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
 }
 
-t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_ProfileParams, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
+uint32_t FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                 err = E_OK;
-    uint32_t                pemode, gnia, ynia, rnia;
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners;
+}
 
-/* Set G, Y, R Nia */
-    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnYellow, &(p_ProfileParams->paramsOnYellow), &ynia);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnRed,    &(p_ProfileParams->paramsOnRed), &rnia);
-   if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-/* Mode fmpl_pemode */
-    pemode = FM_PCD_PLCR_PEMODE_PI;
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    switch (p_ProfileParams->algSelection)
-    {
-        case    e_FM_PCD_PLCR_PASS_THROUGH:
-            p_PlcrRegs->fmpl_pecir         = 0;
-            p_PlcrRegs->fmpl_pecbs         = 0;
-            p_PlcrRegs->fmpl_pepepir_eir   = 0;
-            p_PlcrRegs->fmpl_pepbs_ebs     = 0;
-            p_PlcrRegs->fmpl_pelts         = 0;
-            p_PlcrRegs->fmpl_pects         = 0;
-            p_PlcrRegs->fmpl_pepts_ets     = 0;
-            pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
-            switch (p_ProfileParams->colorMode)
-            {
-                case    e_FM_PCD_PLCR_COLOR_BLIND:
-                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
-                    switch (p_ProfileParams->color.dfltColor)
-                    {
-                        case e_FM_PCD_PLCR_GREEN:
-                            pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
-                            break;
-                        case e_FM_PCD_PLCR_YELLOW:
-                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_Y;
-                            break;
-                        case e_FM_PCD_PLCR_RED:
-                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_R;
-                            break;
-                        case e_FM_PCD_PLCR_OVERRIDE:
-                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE;
-                            break;
-                        default:
-                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-                    }
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
+}
 
-                    break;
-                case    e_FM_PCD_PLCR_COLOR_AWARE:
-                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
-                    break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-            break;
+t_Error FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                     err = E_OK;
+    uint16_t                    base;
+    uint16_t                    swPortIndex = 0;
 
-        case    e_FM_PCD_PLCR_RFC_2698:
-            /* Select algorithm MODE[ALG] = "01" */
-            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
-            if (p_ProfileParams->nonPassthroughAlgParams.comittedInfoRate > p_ProfileParams->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
-                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
-            goto cont_rfc;
-        case    e_FM_PCD_PLCR_RFC_4115:
-            /* Select algorithm MODE[ALG] = "10" */
-            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
-cont_rfc:
-            /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
-            switch (p_ProfileParams->colorMode)
-            {
-                case    e_FM_PCD_PLCR_COLOR_BLIND:
-                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
-                    break;
-                case    e_FM_PCD_PLCR_COLOR_AWARE:
-                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
-                    /*In color aware more select override color interpretation (MODE[OVCLR]) */
-                    switch (p_ProfileParams->color.override)
-                    {
-                        case e_FM_PCD_PLCR_GREEN:
-                            pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
-                            break;
-                        case e_FM_PCD_PLCR_YELLOW:
-                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_Y;
-                            break;
-                        case e_FM_PCD_PLCR_RED:
-                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_R;
-                            break;
-                        case e_FM_PCD_PLCR_OVERRIDE:
-                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_G_NC;
-                            break;
-                        default:
-                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-                    }
-                    break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-            /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
-            switch (p_ProfileParams->nonPassthroughAlgParams.rateMode)
-            {
-                case e_FM_PCD_PLCR_BYTE_MODE :
-                    pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
-                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
-                        {
-                            case e_FM_PCD_PLCR_L2_FRM_LEN:
-                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
-                                break;
-                            case e_FM_PCD_PLCR_L3_FRM_LEN:
-                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L3;
-                                break;
-                            case e_FM_PCD_PLCR_L4_FRM_LEN:
-                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L4;
-                                break;
-                            case e_FM_PCD_PLCR_FULL_FRM_LEN:
-                                pemode |= FM_PCD_PLCR_PEMODE_FLS_FULL;
-                                break;
-                            default:
-                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-                        }
-                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
-                        {
-                            case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
-                                pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
-                                break;
-                            case e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN:
-                                pemode |= FM_PCD_PLCR_PEMODE_RBFLS;
-                                break;
-                            default:
-                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-                        }
-                    break;
-                case e_FM_PCD_PLCR_PACKET_MODE :
-                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
-                    break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
-               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
-               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-            /* Configure Traffic Parameters*/
-            {
-                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
+    if (!numOfProfiles)
+        return E_OK;
 
-                CalcRates(h_FmPcd, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+    err = AllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+    if (err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
 
-                /*  Set Committed Information Rate (CIR) */
-                p_PlcrRegs->fmpl_pecir = cir;
-                /*  Set Committed Burst Size (CBS). */
-                p_PlcrRegs->fmpl_pecbs =  cbs;
-                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
-                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
-                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
-                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
-                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
-                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
-                /* Committed Rate Token Bucket Size (CTS) */
-                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
 
-                /* Set the FPP based on calculation */
-                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
-            }
-            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-    }
+    return E_OK;
+}
 
-    p_PlcrRegs->fmpl_pemode = pemode;
+t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                     err = E_OK;
+    uint16_t                    swPortIndex = 0;
 
-    p_PlcrRegs->fmpl_pegnia = gnia;
-    p_PlcrRegs->fmpl_peynia = ynia;
-    p_PlcrRegs->fmpl_pernia = rnia;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    /* Zero Counters */
-    p_PlcrRegs->fmpl_pegpc     = 0;
-    p_PlcrRegs->fmpl_peypc     = 0;
-    p_PlcrRegs->fmpl_perpc     = 0;
-    p_PlcrRegs->fmpl_perypc    = 0;
-    p_PlcrRegs->fmpl_perrpc    = 0;
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    err = FreeProfiles(p_FmPcd,
+                       hardwarePortId,
+                       p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles,
+                       p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+    if (err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
 
     return E_OK;
 }
 
+bool FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+
+    ASSERT_COND(absoluteProfileId < FM_PCD_PLCR_NUM_ENTRIES);
+
+    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+}
+
 void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1239,11 +1272,11 @@ uint16_t     FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile)
         return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
 }
 
-t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
-                                          e_FmPcdProfileTypeSelection   profileType,
-                                          t_Handle                      h_FmPort,
-                                          uint16_t                      relativeProfile,
-                                          uint16_t                      *p_AbsoluteId)
+t_Error FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
+                                              e_FmPcdProfileTypeSelection   profileType,
+                                              t_Handle                      h_FmPort,
+                                              uint16_t                      relativeProfile,
+                                              uint16_t                      *p_AbsoluteId)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
@@ -1253,26 +1286,27 @@ t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle
     {
         case e_FM_PCD_PLCR_PORT_PRIVATE:
             /* get port PCD id from port handle */
-            for(i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+            for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+                if (p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
                     break;
             if (i ==  FM_MAX_NUM_OF_PORTS)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
 
-            if(!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+            if (!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
-            if(relativeProfile >= p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+            if (relativeProfile >= p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
             *p_AbsoluteId = (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[i].profilesBase + relativeProfile);
             break;
         case e_FM_PCD_PLCR_SHARED:
-            if(relativeProfile >= p_FmPcdPlcr->numOfSharedProfiles)
+            if (relativeProfile >= p_FmPcdPlcr->numOfSharedProfiles)
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
             *p_AbsoluteId = (uint16_t)(p_FmPcdPlcr->sharedProfilesIds[relativeProfile]);
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Invalid policer profile type"));
     }
+
     return E_OK;
 }
 
@@ -1312,7 +1346,7 @@ uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
 bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
 {
 
-    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+    if (profileModeReg & FM_PCD_PLCR_PEMODE_PI)
         return TRUE;
     else
         return FALSE;
@@ -1351,11 +1385,11 @@ uint32_t FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red)
 
     uint32_t tmpReg32 = 0;
 
-    if(green)
+    if (green)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
-    if(yellow)
+    if (yellow)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
-    if(red)
+    if (red)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
 
     return tmpReg32;
@@ -1371,6 +1405,7 @@ void FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId,
 
     p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction |= requiredAction;
 }
+/*********************** End of inter-module routines ************************/
 
 
 /**************************************************/
@@ -1385,7 +1420,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
 
     p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
@@ -1415,11 +1450,11 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
 
     tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
-    if(enable)
+    if (enable)
         tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
     else
         tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
@@ -1440,28 +1475,11 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
-        p_FmPcd->h_IpcSession)
-    {
-        t_FmPcdIpcMsg       msg;
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_PLCR_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
+                               p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs), E_INVALID_OPERATION);
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FM-PCD policer regs"));
 
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
@@ -1482,7 +1500,6 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
 
-
     DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
     DUMP_SUBSTRUCT_ARRAY(i, 63)
     {
@@ -1498,7 +1515,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 {
     t_FmPcd                             *p_FmPcd;
     t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs;
-    t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
+    t_FmPcdPlcrProfileRegs              plcrProfileReg;
     uint32_t                            intFlags;
     uint16_t                            absoluteProfileId;
     t_Error                             err = E_OK;
@@ -1507,7 +1524,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    if(p_ProfileParams->modify)
+    if (p_ProfileParams->modify)
     {
         p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
         p_FmPcd = p_Profile->h_FmPcd;
@@ -1535,13 +1552,12 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
 
-
         /* SMP: needs to be protected only if another core now changes the windows */
         err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
-                                             p_ProfileParams->id.newParams.profileType,
-                                             p_ProfileParams->id.newParams.h_FmPort,
-                                             p_ProfileParams->id.newParams.relativeProfileId,
-                                             &absoluteProfileId);
+                                                    p_ProfileParams->id.newParams.profileType,
+                                                    p_ProfileParams->id.newParams.h_FmPort,
+                                                    p_ProfileParams->id.newParams.relativeProfileId,
+                                                    &absoluteProfileId);
 
          if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
          {
@@ -1549,7 +1565,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
              return NULL;
          }
 
-         if(FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+         if (FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
          {
              REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer Profile is already used"));
              return NULL;
@@ -1576,12 +1592,29 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     p_Profile->nextEngineOnRed = p_ProfileParams->nextEngineOnRed;
     memcpy(&p_Profile->paramsOnRed, &(p_ProfileParams->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
 
+    memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrProfileRegs));
+
+    /* build the policer profile registers */
+    err =  BuildProfileRegs(h_FmPcd, p_ProfileParams, &plcrProfileReg);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        if (p_ProfileParams->modify)
+            /* unlock */
+            PlcrProfileFlagUnlock(p_Profile);
+        if (!p_ProfileParams->modify &&
+                p_Profile->p_Lock)
+            /* release allocated Profile lock */
+            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
+        return NULL;
+    }
+
     if (p_FmPcd->h_Hc)
     {
-         err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, p_ProfileParams);
-         if(p_ProfileParams->modify)
+         err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, &plcrProfileReg);
+         if (p_ProfileParams->modify)
              PlcrProfileFlagUnlock(p_Profile);
-         if(err)
+         if (err)
          {
              /* release the allocated scheme lock */
              if (!p_ProfileParams->modify &&
@@ -1598,23 +1631,6 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
 
-    memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
-
-    /* build the policer profile registers */
-    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_ProfileParams, &plcrProfileReg);
-    if(err)
-    {
-        REPORT_ERROR(MAJOR, err, NO_MSG);
-        if(p_ProfileParams->modify)
-            /* unlock */
-            PlcrProfileFlagUnlock(p_Profile);
-        if (!p_ProfileParams->modify &&
-                p_Profile->p_Lock)
-            /* release allocated Profile lock */
-            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
-        return NULL;
-    }
-
     intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode , plcrProfileReg.fmpl_pemode);
     WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia , plcrProfileReg.fmpl_pegnia);
@@ -1801,7 +1817,7 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
 {
     t_FmPcdPlcrProfile                  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
     t_FmPcd                             *p_FmPcd;
-    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    t_FmPcdPlcrProfileRegs              *p_ProfilesRegs;
     uint16_t                            profileIndx;
     uint32_t                            tmpReg, intFlags;
 
@@ -1812,30 +1828,10 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
-        p_FmPcd->h_IpcSession)
-    {
-        t_FmPcdIpcMsg                       msg;
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_PLCR_PROFILE_DUMP_REGS;
-        memcpy(msg.msgBody, (uint8_t *)&h_Profile, sizeof(uint32_t));
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId) + sizeof(uint32_t),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
-
     profileIndx = p_Profile->absoluteProfileId;
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FM-PCD policer-profile regs"));
 
     p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 2263bf8..5ccd8ea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -48,36 +48,6 @@
 #include "fm_prs.h"
 
 
-t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
-{
-    t_FmPcdPrs  *p_FmPcdPrs;
-    uintptr_t   baseAddr;
-
-    UNUSED(p_FmPcd);
-    UNUSED(p_FmPcdParams);
-
-    p_FmPcdPrs = (t_FmPcdPrs *) XX_Malloc(sizeof(t_FmPcdPrs));
-    if (!p_FmPcdPrs)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Parser structure allocation FAILED"));
-        return NULL;
-    }
-    memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
-
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
-        p_FmPcdPrs->p_SwPrsCode  = (uint32_t *)UINT_TO_PTR(baseAddr);
-        p_FmPcdPrs->p_FmPcdPrsRegs  = (t_FmPcdPrsRegs *)UINT_TO_PTR(baseAddr + PRS_REGS_OFFSET);
-    }
-
-    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
-    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
-    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
-
-    return p_FmPcdPrs;
-}
-
 static void PcdPrsErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
@@ -125,43 +95,56 @@ static void PcdPrsException(t_Handle h_FmPcd)
     p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
 }
 
-static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t  indexPerHdr)
+t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                     i;
-    t_FmPcdPrsLabelParams   *p_Label;
-
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
+    t_FmPcdPrs  *p_FmPcdPrs;
+    uintptr_t   baseAddr;
 
-    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
-    ASSERT_COND(p_FmPcd->p_FmPcdPrs->currLabel < FM_PCD_PRS_NUM_OF_LABELS);
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
 
-    for (i=0; i < p_FmPcd->p_FmPcdPrs->currLabel; i++)
+    p_FmPcdPrs = (t_FmPcdPrs *) XX_Malloc(sizeof(t_FmPcdPrs));
+    if (!p_FmPcdPrs)
     {
-        p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i];
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Parser structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
 
-        if ((hdr == p_Label->hdr) && (indexPerHdr == p_Label->indexPerHdr))
-            return p_Label->instructionOffset;
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
+        p_FmPcdPrs->p_SwPrsCode  = (uint32_t *)UINT_TO_PTR(baseAddr);
+        p_FmPcdPrs->p_FmPcdPrsRegs  = (t_FmPcdPrsRegs *)UINT_TO_PTR(baseAddr + PRS_REGS_OFFSET);
     }
 
-    REPORT_ERROR(MAJOR, E_NOT_FOUND, ("Sw Parser attachment Not found"));
-    return (uint32_t)ILLEGAL_BASE;
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
+
+    return p_FmPcdPrs;
 }
 
 t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-    uint32_t            tmpReg, i, j;
-    uint32_t            *p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
-                                                            FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+    uint32_t            *p_TmpCode, tmpReg, i,
+                        *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
+                                                             FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
     uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    ASSERT_COND(sizeof(swPrsPatch) <= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
+
+    /* nothing to do in guest-partition */
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         return E_OK;
 
-    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch),4), 0, sizeof(uint32_t));
+    if (!p_TmpCode)
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch),4));
+    memcpy((uint8_t *)p_TmpCode, (uint8_t *)swPrsPatch, sizeof(swPrsPatch));
 
     /**********************RPCLIM******************/
     WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
@@ -178,7 +161,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /**********************PEVR******************/
 
     /**********************PEVER******************/
-    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
+    if (p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
@@ -189,7 +172,6 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 
     /**********************PERR******************/
     WRITE_UINT32(p_Regs->perr, FM_PCD_PRS_DOUBLE_ECC);
-
     /**********************PERR******************/
 
     /**********************PERER******************/
@@ -202,25 +184,15 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->perer, tmpReg);
     /**********************PERER******************/
 
-    /**********************PPCS******************/
+    /**********************PPSC******************/
     WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
-    /**********************PPCS******************/
+    /**********************PPSC******************/
 
-    ASSERT_COND(sizeof(swPrsPatch)<= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
     /* load sw parser Ip-Frag patch */
-    if (p_FmPcd->fmRevInfo.majorRev >= 2)
-    {
-        for(i=0; i < (sizeof(swPrsPatch) / 4);i++)
-        {
-           tmpReg = 0;
-           for (j=0; j < 4; j++)
-           {
-              tmpReg <<= 8;
-              tmpReg |= swPrsPatch[i*4+j];
-           }
-           WRITE_UINT32(*(p_SwPrsCode + i), tmpReg);
-        }
-    }
+    for (i=0; i<DIV_CEIL(sizeof(swPrsPatch),4); i++)
+        WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
+
+    XX_FreeSmart(p_TmpCode);
 
     return E_OK;
 }
@@ -291,13 +263,14 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PRS_INC_PORT_STATS;
         memcpy(msg.msgBody, &prsIncludePortParams, sizeof(prsIncludePortParams));
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(prsIncludePortParams),
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) +sizeof(prsIncludePortParams),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         return E_OK;
     }
@@ -311,11 +284,17 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
 uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_Error                 err = E_OK;
-    t_FmPcdIpcSwPrsLable    labelParams;
+    t_FmPcdPrsLabelParams   *p_Label;
+    int                     i;
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
+
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
+        t_Error                 err = E_OK;
+        t_FmPcdIpcSwPrsLable    labelParams;
         t_FmPcdIpcMsg           msg;
         uint32_t                prsOffset = 0;
         t_FmPcdIpcReply         reply;
@@ -328,13 +307,14 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
         msg.msgId = FM_PCD_GET_SW_PRS_OFFSET;
         memcpy(msg.msgBody, &labelParams, sizeof(labelParams));
         replyLength = sizeof(uint32_t) + sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(labelParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) +sizeof(labelParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
@@ -342,8 +322,22 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
         memcpy((uint8_t*)&prsOffset, reply.replyBody, sizeof(uint32_t));
         return prsOffset;
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
 
-    return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
+    ASSERT_COND(p_FmPcd->p_FmPcdPrs->currLabel < FM_PCD_PRS_NUM_OF_LABELS);
+
+    for (i=0; i<p_FmPcd->p_FmPcdPrs->currLabel; i++)
+    {
+        p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i];
+
+        if ((hdr == p_Label->hdr) && (indexPerHdr == p_Label->indexPerHdr))
+            return p_Label->instructionOffset;
+    }
+
+    REPORT_ERROR(MAJOR, E_NOT_FOUND, ("Sw Parser attachment Not found"));
+    return (uint32_t)ILLEGAL_BASE;
 }
 
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
@@ -368,9 +362,9 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
 t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                *p_LoadTarget, tmpReg;
-    uint8_t                 *p_TmpCode;
-    int                     i, j;
+    uint32_t                *p_LoadTarget;
+    uint32_t                *p_TmpCode;
+    int                     i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
@@ -378,58 +372,50 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_PrsLoadSw - guest mode!"));
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM in guest-mode!"));
 
-    if(!p_SwPrs->override)
+    if (!p_SwPrs->override)
     {
         if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
     }
-    if(p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
+    else
+        p_FmPcd->p_FmPcdPrs->currLabel = 0;
+
+    if (p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
 
-    p_TmpCode = p_SwPrs->p_Code;
-    if(p_SwPrs->size % 4)
-    {
-        p_TmpCode = (uint8_t *)XX_Malloc(p_SwPrs->size + 2);
-        if (!p_TmpCode)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
-        memset(p_TmpCode, 0, p_SwPrs->size + 2);
-        memcpy(p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
-    }
+    if (p_FmPcd->p_FmPcdPrs->currLabel + p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
+
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(p_SwPrs->size,4), 0, sizeof(uint32_t));
+    if (!p_TmpCode)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(p_SwPrs->size,4));
+    memcpy((uint8_t *)p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
 
     /* save sw parser labels */
-    if(p_SwPrs->override)
-        p_FmPcd->p_FmPcdPrs->currLabel = 0;
-    if(p_FmPcd->p_FmPcdPrs->currLabel+ p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
-    memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel], p_SwPrs->labelsTable, p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
+    memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel],
+           p_SwPrs->labelsTable,
+           p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
     p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
+
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for(i=0;i<DIV_CEIL(p_SwPrs->size,4);i++)
-    {
-        tmpReg = 0;
-        for(j =0;j<4;j++)
-        {
-            tmpReg <<= 8;
-            tmpReg |= *(p_TmpCode+i*4+j);
-        }
-        WRITE_UINT32(*(p_LoadTarget + i), tmpReg);
-    }
-    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + DIV_CEIL(p_SwPrs->size,4);
+    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
+        WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
+        p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
 
     /* copy data parameters */
     for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
         WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
 
-
     /* Clear last 4 bytes */
     WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-FM_PCD_PRS_SW_TAIL_SIZE)/4), 0);
 
-    if(p_SwPrs->size % 4)
-        XX_Free(p_TmpCode);
+    XX_FreeSmart(p_TmpCode);
 
     return E_OK;
 }
@@ -449,7 +435,6 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
     return E_OK;
 }
 
-
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
 {
@@ -460,28 +445,11 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
-        p_FmPcd->h_IpcSession)
-    {
-        t_FmPcdIpcMsg       msg;
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_PRS_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
+                               p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs), E_INVALID_OPERATION);
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FM-PCD parser regs"));
 
     DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
     DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index b0240e7..99613c0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -47,98 +47,103 @@
 /***********************************************************************/
 
 #if (DPAA_VERSION == 10)
-/* Version: 106.1.6 */
+/* Version: 106.1.7 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
     0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
-    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
-    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
-    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
-    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
-    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x23,0x33,0xF1, \
+    0x00,0xF9,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
+    0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x06,0x00, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F,0x00,0x00, \
+    0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x00,0x40, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x96,0x00,0x00, \
+    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x30,0x7E,0x43,0x49,0x00,0x00,0x30,0x7E, \
+    0x43,0x49,0x00,0x3C,0x1B,0x63,0x32,0x11,0x28,0x41, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+    0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
+    0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
+    0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x42,0x30,0x7E, \
+    0x53,0x79,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+    0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0x8D,0x00,0x00, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
+    0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+    0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x1B,0xCE, \
+    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x30,0x7E,0x43,0xBE,0x00,0x2C,0x32,0x11, \
+    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+    0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0xA1, \
+    0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00, \
+    0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+    0x1F,0xFF,0x00,0x01,0x1B,0xFE,                     \
 };
 
 #else
-/* version: 106.5 */
+/* version: 106.3.8 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
     0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2F,0x34,0xF5, \
     0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
     0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
-    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3,0x29,0x8F, \
+    0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00, \
+    0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x43,0x3B,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x53,0xA2,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
     0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
-    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x55, \
+    0x00,0x00,0x30,0x7E,0x43,0x55,0x00,0x3C,0x1B,0x6F, \
     0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
     0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
     0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
     0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
     0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
+    0x1B,0x4E,0x30,0x7E,0x53,0x85,0x00,0x2B,0x32,0x11, \
     0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
     0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
     0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
     0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
-    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x53,0x99,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
     0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
     0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
     0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
     0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x43,0x1B,0xE6,0x32,0xC1,0x00,0x55,0x00,0x06, \
     0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xCA, \
     0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
     0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
     0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
     0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
     0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
+    0x06,0x00,0x1B,0xAD,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
     0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
     0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
-    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
-    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
+    0x2B,0x97,0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9, \
+    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
+    0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE, \
     0x00,0x01,0x1B,0xFE,                               \
 };
 #endif /* (DPAA_VERSION == 10) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index a31ef75..f450fa1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -41,10 +41,10 @@
 #include "string_ext.h"
 #include "sprint_ext.h"
 #include "debug_ext.h"
+#include "fm_muram_ext.h"
 
 #include "fm_port.h"
 
-
 /****************************************/
 /*       static functions               */
 /****************************************/
@@ -57,8 +57,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
     if (p_FmPort->imEn)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if(p_FmPort->fifoDeqPipelineDepth > 2)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            if (p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
@@ -69,25 +69,25 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
-            if(!p_Params->extBufPools.numOfPoolsUsed)
+            if (!p_Params->extBufPools.numOfPoolsUsed)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if(FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
+            if (FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if(p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
+            if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
-            if(p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+            if (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
@@ -97,19 +97,19 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         else
         {
-            if(p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
+            if (p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+            if ((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
 
-            if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
                     /* in O/H DEFAULT_notSupported indicates that it is not suppported and should not be checked */
                     || (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+                if ((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
@@ -117,13 +117,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
 
-            if(!p_Params->dfltFqid)
+            if (!p_Params->dfltFqid)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
-            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
+            if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
 #endif /* defined(FM_CAPWAP_SUPPORT) && ... */
         }
@@ -133,46 +133,46 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /* common BMI registers values */
         /* Check that Queue Id is not larger than 2^24, and is not 0 */
-        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+        if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
-        if(p_Params->dfltFqid & ~0x00FFFFFF)
+        if (p_Params->dfltFqid & ~0x00FFFFFF)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
     }
 
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+        if (p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+        if (p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
         /* Check that not larger than 16 */
-        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+        if (p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        if(FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+        if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+        if (p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
-        if(p_Params->bufPoolDepletion.poolsGrpModeEnable &&
+        if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
-            if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            if (p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
@@ -193,17 +193,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+        if (p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+        if (p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
-        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+        if (p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
-        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if(p_FmPort->fifoDeqPipelineDepth > 2)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if (p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
     /****************************************/
@@ -266,29 +266,29 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
 
     /* Check that not larger than 16 */
-    if((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
 
-    if(FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+    if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS))
+    if ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if(p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
+    if (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS))
+    if ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if(p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
+    if (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if(p_FmPort->explicitUserSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
+    if (p_FmPort->explicitUserSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
+    if (p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        if(p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+        if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
             /* this is an indication that user called config for this mode which is not supported in this integration */
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
@@ -306,17 +306,12 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
-
+        minFifoSizeRequired = (uint32_t)DIV_CEIL(p_FmPort->maxFrameLength, BMI_FIFO_UNITS);
         if (p_FmPort->imEn)
-            minFifoSizeRequired = (uint32_t)((p_FmPort->maxFrameLength % BMI_FIFO_UNITS ?
-                                              (p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
-                                              p_FmPort->maxFrameLength) +
-                                                (3*BMI_FIFO_UNITS));
+            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
         else
-            minFifoSizeRequired = (uint32_t)((p_FmPort->maxFrameLength % BMI_FIFO_UNITS ?
-                                   (p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
-                                   p_FmPort->maxFrameLength) +
-                                   (p_FmPort->fifoDeqPipelineDepth+3)*BMI_FIFO_UNITS);
+            minFifoSizeRequired += (p_FmPort->fifoDeqPipelineDepth+3)*BMI_FIFO_UNITS;
+
         /* add some margin for back to back capability to improve performance
          * allows the hardware to pipeline new frame dma while the previous
          * frame not yet transmitted). */
@@ -332,9 +327,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
              p_FmPort->imEn)
-        minFifoSizeRequired = (uint32_t)(((p_FmPort->maxFrameLength % BMI_FIFO_UNITS) ?
-                                         ((p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                         p_FmPort->maxFrameLength) +
+        minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) +
                                          (4*BMI_FIFO_UNITS));
 
     /*************************/
@@ -344,23 +337,19 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
              !p_FmPort->imEn)
     {
-
 #ifdef FM_FIFO_ALLOCATION_ALG
-        if(p_FmPort->fmRevInfo.majorRev == 4)
+        if (p_FmPort->fmRevInfo.majorRev == 4)
         {
-            if(p_FmPort->rxPoolsParams.numOfPools == 1)
+            if (p_FmPort->rxPoolsParams.numOfPools == 1)
                 minFifoSizeRequired = 8*BMI_FIFO_UNITS;
             else
-                minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.secondLargestBufSize % BMI_FIFO_UNITS) ?
-                                    ((p_FmPort->rxPoolsParams.secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                    p_FmPort->rxPoolsParams.secondLargestBufSize) +
-                                    (7*BMI_FIFO_UNITS));
+                minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) +
+                                                 (7*BMI_FIFO_UNITS));
         }
         else
 #endif /* FM_FIFO_ALLOCATION_ALG */
-            minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.largestBufSize % BMI_FIFO_UNITS) ?
-                                    ((p_FmPort->rxPoolsParams.largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                    p_FmPort->rxPoolsParams.largestBufSize) + (7*BMI_FIFO_UNITS));
+            minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.largestBufSize, BMI_FIFO_UNITS) +
+                                             (7*BMI_FIFO_UNITS));
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
             minFifoSizeRequired += 12*BMI_FIFO_UNITS;
@@ -375,7 +364,9 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
     /* for all ports - verify size  */
     if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("User defined FIFO size should be enlarged to %d",
+                      minFifoSizeRequired));
 
     /* check if pool size is not too big */
     /* This is a definition problem in which if the fifo for the RX port
@@ -386,9 +377,10 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
         && !p_FmPort->imEn)
     {
         if (p_FmPort->rxPoolsParams.largestBufSize > p_FmPort->fifoBufs.num)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)",
-                    p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
-
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("Frame larger than port Fifo size (%u) will be split to more "\
+                          "than a single buffer (S/G) even if shorter than largest buffer size (%u)",
+                          p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
     }
 
     return E_OK;
@@ -396,7 +388,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 {
-    if(p_FmPort->p_FmPortDriverParam)
+    if (p_FmPort->p_FmPortDriverParam)
     {
         XX_Free(p_FmPort->p_FmPortDriverParam);
         p_FmPort->p_FmPortDriverParam = NULL;
@@ -446,9 +438,9 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
         tmpReg |= sizesArray[orderedArray[i]];
         /* functionality available only for some deriviatives (limited by config) */
-        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
-                if(orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+                if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
                     break;
@@ -456,13 +448,13 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         WRITE_UINT32(*(p_ExtBufRegs+i), tmpReg);
     }
 
-    if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+    if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
 
     numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
 
     /* clear unused pools */
-    for(i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
+    for (i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
         WRITE_UINT32(*(p_ExtBufRegs+i), 0);
 
     /* save pools parameters for later use */
@@ -472,13 +464,13 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     /* FMBM_RMPD reg. - pool depletion */
     tmpReg = 0;
-    if(p_BufPoolDepletion->poolsGrpModeEnable)
+    if (p_BufPoolDepletion->poolsGrpModeEnable)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
         for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if(p_BufPoolDepletion->poolsToConsider[i])
+            if (p_BufPoolDepletion->poolsToConsider[i])
             {
                 for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
@@ -495,13 +487,13 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         tmpReg |= vector;
     }
 
-    if(p_BufPoolDepletion->singlePoolModeEnable)
+    if (p_BufPoolDepletion->singlePoolModeEnable)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
         for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
+            if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
                 for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
@@ -578,7 +570,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaWriteOptimize)
+    if (p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
     WRITE_UINT32(p_Regs->fmbm_rda, tmpReg);
@@ -616,6 +608,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         /* Call the external Buffer routine which also checks fifo
            size and updates it if necessary */
         /* define external buffer pools and pool depletion*/
+
         /* check if the largest external buffer pool is large enough */
         if ((p_Params->bufMargins.startMargins +
              MIN_EXT_BUF_SIZE +
@@ -666,7 +659,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     if (!p_FmPort->imEn)
     {
         tmpReg |= BMI_CMD_ATTR_ORDER;
-        if(p_Params->syncReq)
+        if (p_Params->syncReq)
             tmpReg |= BMI_CMD_ATTR_SYNC;
         tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
@@ -687,7 +680,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     performanceContersParams.queueCompVal   = 1;
     performanceContersParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
     performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    if((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
+    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
@@ -766,7 +759,7 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         /* The line bellow is a trick so the FM will not release the buffer
            to BM nor will try to enq the frame to QM */
-        if(!p_Params->dfltFqid && p_Params->dontReleaseBuf)
+        if (!p_Params->dfltFqid && p_Params->dontReleaseBuf)
         {
             /* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to
              * act acording to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
@@ -792,7 +785,7 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     /* default queues */
     if (!p_FmPort->imEn)
     {
-        if(p_Params->dfltFqid || !p_Params->dontReleaseBuf)
+        if (p_Params->dfltFqid || !p_Params->dontReleaseBuf)
             WRITE_UINT32(p_Regs->fmbm_tcfqid, p_Params->dfltFqid);
         WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
     }
@@ -828,7 +821,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaWriteOptimize)
+    if (p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
     WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
@@ -855,7 +848,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     else
         tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
 
-    if(p_Params->syncReq)
+    if (p_Params->syncReq)
         tmpReg |= BMI_CMD_ATTR_SYNC;
     tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
@@ -867,7 +860,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
     WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
 
-    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
 
@@ -885,7 +878,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         {
             /* define external buffer pools */
             t_Error err = SetExtBufferPools(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 #endif /* FM_NO_OP_OBSERVED_POOLS */
@@ -926,7 +919,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 #endif /* FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
 #ifdef FM_FRAME_END_PARAMS_FOR_OP
-    if(p_FmPort->fmRevInfo.majorRev >= 6)
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
         /* frame end parameters */
         tmpReg = 0;
@@ -947,7 +940,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     p_Params = p_FmPort->p_FmPortDriverParam;
 
     /* check that port is not busy */
-    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if (((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
        (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
@@ -956,10 +949,10 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
 
     /* The following is  done for non-Rx ports only */
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
-        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
                         (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         {
             /* define dequeue NIA */
@@ -976,7 +969,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
 
         /* configure dequeue */
         tmpReg = 0;
-        if(p_Params->deqHighPriority)
+        if (p_Params->deqHighPriority)
             tmpReg |= QMI_DEQ_CFG_PRI;
 
         switch(p_Params->deqType)
@@ -995,7 +988,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-        if(p_FmPort->fmRevInfo.majorRev != 4)
+        if (p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
         switch(p_Params->deqPrefetchOption)
         {
@@ -1048,7 +1041,7 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
         case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+            if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
          default:
@@ -1129,7 +1122,7 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_LENGTH_ERR):
         case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+            if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -1197,13 +1190,13 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_LENGTH_ERR):
         case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
             /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
             ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
-            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -1268,44 +1261,44 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     u_FmPcdHdrPrsOpts           *p_prsOpts;
     uint32_t                    tmpReg = 0, tmpPrsOffset;
 
-    if(IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+    if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
 
-    if(p_HdrParams->errDisable)
+    if (p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
 
     /* Set parser options */
-    if(p_HdrParams->usePrsOpts)
+    if (p_HdrParams->usePrsOpts)
     {
         p_prsOpts = &p_HdrParams->prsOpts;
         switch(p_HdrParams->hdr)
         {
             case(HEADER_TYPE_MPLS):
-                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+                if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
                 GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
-                if(hdrNum == ILLEGAL_HDR_NUM)
+                if (hdrNum == ILLEGAL_HDR_NUM)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
                 GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
-                if(hdrNum < Ipv4HdrNum)
+                if (hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                         ("Header must be equal or higher than IPv4"));
                 tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
             case(HEADER_TYPE_PPPoE):
-                if(p_prsOpts->pppoePrsOptions.enableMTUCheck)
+                if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
                     tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
                 break;
             case(HEADER_TYPE_IPv6):
-                if(p_prsOpts->ipv6PrsOptions.routingHdrEnable)
+                if (p_prsOpts->ipv6PrsOptions.routingHdrEnable)
                     tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_EN;
                 break;
             case(HEADER_TYPE_TCP):
-                if(p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
+                if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 break;
             case(HEADER_TYPE_UDP):
-                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+                if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 break;
             default:
@@ -1314,10 +1307,10 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     }
 
     /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
-    if(p_HdrParams->swPrsEnable)
+    if (p_HdrParams->swPrsEnable)
     {
         tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
-        if(tmpPrsOffset == ILLEGAL_BASE)
+        if (tmpPrsOffset == ILLEGAL_BASE)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
     }
@@ -1341,7 +1334,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     {
         while (tmp)
         {
-            if(tmp & walking1Mask)
+            if (tmp & walking1Mask)
             {
                 p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = idx;
                 p_SchemeBind->numOfSchemes++;
@@ -1422,6 +1415,11 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
         case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
@@ -1479,7 +1477,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     }
 
     /* set PCD port parameter */
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
                               p_PcdParams,
@@ -1493,9 +1491,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
-        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
+        if (p_PcdParams->p_KgParams->numOfSchemes == 0)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
@@ -1525,7 +1523,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 #if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
-            if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+            if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
 #endif
         }
@@ -1546,12 +1544,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
          (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
-        if(!p_PcdParams->p_PlcrParams->h_Profile)
+        if (!p_PcdParams->p_PlcrParams->h_Profile)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
 
         absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
 
-        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+        if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
@@ -1597,20 +1595,21 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                 tmpReg = NIA_KG_CC_EN;
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
-                if(p_PcdParams->p_KgParams->directScheme)
+                if (p_PcdParams->p_KgParams->directScheme)
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
                     for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                        if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
-                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
+                    if (i == p_PcdParams->p_KgParams->numOfSchemes)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
                 WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
@@ -1706,13 +1705,13 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
         {
             GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
-            if(hdrNum== ILLEGAL_HDR_NUM)
+            if (hdrNum== ILLEGAL_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-            if(hdrNum==NO_HDR_NUM)
+            if (hdrNum==NO_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
 
             err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpReg);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             tmpHxs[hdrNum] |= tmpReg;
@@ -1724,10 +1723,10 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
            /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4_LABEL);
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
         }
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd) &&
             (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
@@ -1735,7 +1734,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
         }
 
         for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
@@ -1749,12 +1748,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         /* set tpid. */
         tmpReg = PRS_TPID_DFLT;
-        if(p_PcdParams->p_PrsParams->setVlanTpid1)
+        if (p_PcdParams->p_PrsParams->setVlanTpid1)
         {
             tmpReg &= PRS_TPID2_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
         }
-        if(p_PcdParams->p_PrsParams->setVlanTpid2)
+        if (p_PcdParams->p_PrsParams->setVlanTpid2)
         {
             tmpReg &= PRS_TPID1_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
@@ -1809,7 +1808,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    if(!p_FmPort->pcdEngines)
+    if (!p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
 
     /* get PCD registers pointers */
@@ -1828,13 +1827,13 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if ((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
 
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
 
-    if(p_FmPort->pcdEngines | FM_PCD_PRS)
+    if (p_FmPort->pcdEngines | FM_PCD_PRS)
     {
         WRITE_UINT32(*p_BmiPrsStartOffset, 0);
 
@@ -1844,7 +1843,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
         t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
 
@@ -1852,20 +1851,20 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         /* unbind - we need to get the treeId too */
         err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1897,8 +1896,8 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* check that current NIA is BMI to BMI */
@@ -1908,29 +1907,29 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
     }
-    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
     }
-    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
@@ -1962,7 +1961,7 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
 /*TODO - not atomic - it seems that port has to be disabled*/
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
     {
         switch(p_FmPort->portType)
         {
@@ -1981,7 +1980,7 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
         switch(p_FmPort->portType)
         {
@@ -1998,16 +1997,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
-    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     return E_OK;
@@ -2029,7 +2028,7 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
         return;
@@ -2089,6 +2088,66 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
     return ((t_FmPort*)h_FmPort)->pcdEngines;
 }
 
+#if (DPAA_VERSION >= 11)
+t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t            muramPageOffset;
+
+    ASSERT_COND(p_FmPort);
+    ASSERT_COND(p_Value);
+
+    if (p_FmPort->gprFunc != e_FM_PORT_GPR_EMPTY)
+    {
+        if (p_FmPort->gprFunc != gprFunc)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("gpr was assigned with different func"));
+    }
+    else
+    {
+        switch(gprFunc)
+        {
+            case (e_FM_PORT_GPR_MURAM_PAGE):
+                p_FmPort->p_MuramPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
+                                                          256,
+                                                          8);
+                if (!p_FmPort->p_MuramPage)
+                    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for page"));
+
+                IOMemSet32(p_FmPort->p_MuramPage, 0, 256);
+                muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_MuramPage) -
+                                             p_FmPort->fmMuramPhysBaseAddr);
+                switch(p_FmPort->portType)
+                {
+                    case(e_FM_PORT_TYPE_RX_10G):
+                    case(e_FM_PORT_TYPE_RX):
+                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
+                        break;
+                    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
+                        break;
+                    default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+                }
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+        }
+        p_FmPort->gprFunc = gprFunc;
+    }
+
+    switch(p_FmPort->gprFunc)
+    {
+        case (e_FM_PORT_GPR_MURAM_PAGE):
+            *p_Value = p_FmPort->p_MuramPage;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    return E_OK;
+}
+#endif /* (DPAA_VERSION >= 11) */
+
 t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2132,12 +2191,19 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne);
         else
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
         p_CcParams->getCcParams.type &= ~GET_NIA_FPNE;
     }
+    if (p_CcParams->getCcParams.type & GET_NIA_PNDN)
+    {
+        if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
+        p_CcParams->getCcParams.type &= ~GET_NIA_PNDN;
+    }
 
     if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) &&
         !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
@@ -2154,7 +2220,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
     {
-       if(p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
     }
 
@@ -2166,19 +2232,20 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
     {
-        if(p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+        if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
     }
 
     if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_FENE))
+        (p_CcParams->setCcParams.overwrite ||
+         !(p_FmPort->requiredAction & UPDATE_NIA_FENE)))
     {
         p_FmPort->savedBmiFene = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_FENE;
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
     {
-       if(p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
     }
 
@@ -2190,7 +2257,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
     {
-       if(p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
     }
 
@@ -2202,18 +2269,10 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
     {
-       if(p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
     }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FNE) &&
-        p_CcParams->setCcParams.immediateWrite)
-    {
-        if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("port type must be e_FM_PORT_TYPE_OH_OFFLINE_PARSING"));
-        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne, p_CcParams->setCcParams.nia);
-    }
-
     if ((p_CcParams->setCcParams.type & UPDATE_PSO) &&
         !(p_FmPort->requiredAction & UPDATE_PSO))
     {
@@ -2232,7 +2291,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
          }
         /* set start parsing offset */
         tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
-        if(tmpInt>0)
+        if (tmpInt>0)
             WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
 
         p_FmPort->requiredAction |= UPDATE_PSO;
@@ -2241,7 +2300,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_PSO)
     {
-        if(p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
+        if (p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
     }
 
@@ -2380,7 +2439,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
         p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-        if(p_FmPort->fmRevInfo.majorRev < 6)
+        if (p_FmPort->fmRevInfo.majorRev < 6)
             p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
@@ -2398,7 +2457,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_FmPort->fmRevInfo.majorRev == 4)
+    if (p_FmPort->fmRevInfo.majorRev == 4)
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
@@ -2443,7 +2502,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
 
     memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-    if(Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
+    if (Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
                FmGetId(p_FmPort->h_Fm),
                ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
                  (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
@@ -2507,7 +2566,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
     p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
 
-    if  ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         if (!p_FmPort->imEn)
         {
@@ -2519,7 +2578,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
-
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -2531,7 +2589,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
     err = VerifySizeOfFifo(p_FmPort);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
@@ -2554,13 +2612,14 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
 
     err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* get params for use in init */
-    p_Params->fmMuramPhysBaseAddr =
+    p_FmPort->fmMuramPhysBaseAddr =
         (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
                    ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
+    p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
     /**********************/
     /* Init BMI Registers */
@@ -2570,19 +2629,19 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX_10G):
         case(e_FM_PORT_TYPE_RX):
             err = BmiRxPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
         case(e_FM_PORT_TYPE_TX_10G):
         case(e_FM_PORT_TYPE_TX):
             err = BmiTxPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             err = BmiOhPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
         default:
@@ -2621,7 +2680,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    if(p_FmPort->pcdEngines)
+    if (p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
     if (p_FmPort->enabled)
@@ -2642,11 +2701,15 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
 #if (DPAA_VERSION >= 11)
-    if(FmVSPFree( p_FmPort->h_Fm,
-                  p_FmPort->portType,
-                  p_FmPort->portId) != E_OK)
+    if (FmVSPFreeForPort(p_FmPort->h_Fm,
+                        p_FmPort->portType,
+                        p_FmPort->portId) != E_OK)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSP free of port FAILED"));
+
+    if (p_FmPort->p_MuramPage)
+        FM_MURAM_FreeMem(p_FmPort->h_FmMuram, p_FmPort->p_MuramPage);
 #endif
+
     if (p_FmPort->h_Spinlock)
         XX_FreeSpinlock(p_FmPort->h_Spinlock);
 
@@ -2703,7 +2766,7 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
@@ -2717,7 +2780,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqType = deqType;
@@ -2731,7 +2794,7 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
     p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
     return E_OK;
@@ -2743,11 +2806,11 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_Backup
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
-    if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+    if (!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
     memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
 
@@ -2760,7 +2823,7 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
@@ -2801,7 +2864,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
@@ -2815,7 +2878,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -2830,7 +2893,7 @@ t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedB
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -2851,7 +2914,7 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
@@ -2865,7 +2928,7 @@ t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
@@ -2891,7 +2954,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
@@ -2906,7 +2969,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
@@ -2920,7 +2983,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
                                                             (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
@@ -2984,13 +3047,14 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
 
     return E_OK;
 }
+
 #if (DPAA_VERSION >= 11)
 t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 {
@@ -3007,6 +3071,7 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
     return E_OK;
 }
 #endif /* (DPAA_VERSION >= 11) */
+
 t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -3014,7 +3079,7 @@ t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReus
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
@@ -3038,14 +3103,13 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
 /*       Hidden-DEBUG Only API                      */
 /****************************************************/
 
-
 t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
@@ -3060,7 +3124,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
 
     if (p_FmPort->imEn)
@@ -3077,7 +3141,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
@@ -3091,7 +3155,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
@@ -3105,7 +3169,7 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
@@ -3124,12 +3188,12 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
+    if ((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if(p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
+    if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
     err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfOpenDmas->num, (uint8_t)p_NumOfOpenDmas->extra, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     memcpy(&p_FmPort->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
@@ -3148,13 +3212,13 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
     ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
-    if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
+    if ((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if(p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
+    if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
 
     err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfTasks->num, (uint8_t)p_NumOfTasks->extra, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* update driver's struct */
@@ -3177,11 +3241,11 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
-         if(p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+         if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
     }
     else
-        if(p_SizeOfFifo->extra)
+        if (p_SizeOfFifo->extra)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
@@ -3189,11 +3253,15 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     p_FmPort->explicitUserSizeOfFifo = TRUE;
     /* we do not change user's parameter */
     err = VerifySizeOfFifo(p_FmPort);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_SizeOfFifo->num, p_SizeOfFifo->extra, FALSE);
-    if(err)
+    err = FmSetSizeOfFifo(p_FmPort->h_Fm,
+                          p_FmPort->hardwarePortId,
+                          p_SizeOfFifo->num,
+                          p_SizeOfFifo->extra,
+                          FALSE);
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
@@ -3294,11 +3362,11 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
     /* check if port is already disabled */
-    if(!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
+    if (!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
+            if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
                 /* port is disabled */
                 return E_OK;
             else
@@ -3381,11 +3449,11 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     }
 
     /* check if port is already enabled */
-    if(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
+    if (GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
+            if (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
                 /* port is enabled */
                 return E_OK;
             else
@@ -3422,7 +3490,7 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
@@ -3461,12 +3529,12 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
     tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
 
-    if(!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
+    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
 
     tmpRateLimitScale = ((31 - (uint32_t)countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
 
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
     else
     {
@@ -3495,10 +3563,10 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
-            if(p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+            if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
                     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
-            if(p_RateLimit->maxBurstSize % 1000)
+            if (p_RateLimit->maxBurstSize % 1000)
             {
                 p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
                 DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
@@ -3523,7 +3591,7 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
@@ -3558,7 +3626,7 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
-    if(enable)
+    if (enable)
         tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
     else
         tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
@@ -3594,7 +3662,7 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if(enable)
+    if (enable)
         WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
     else
         WRITE_UINT32(*p_BmiPcReg, 0);
@@ -3804,7 +3872,7 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 
     tmpReg = GET_UINT32(*p_BmiStcReg);
 
-    if(enable)
+    if (enable)
         tmpReg |= BMI_COUNTERS_EN;
     else
         tmpReg &= ~BMI_COUNTERS_EN;
@@ -3852,7 +3920,7 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
@@ -3860,7 +3928,7 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
         {
-            if(enable)
+            if (enable)
                 tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
             else
                 tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
@@ -3889,7 +3957,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
         case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
                 return 0;
@@ -3903,13 +3971,13 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             break;
     }
 
-    if(bmiCounter)
+    if (bmiCounter)
     {
         switch(p_FmPort->portType)
         {
             case(e_FM_PORT_TYPE_RX_10G):
             case(e_FM_PORT_TYPE_RX):
-                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
@@ -3917,7 +3985,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 break;
             case(e_FM_PORT_TYPE_TX_10G):
             case(e_FM_PORT_TYPE_TX):
-                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
@@ -3925,7 +3993,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 break;
             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
@@ -3941,7 +4009,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     {
 
         /* check that counters are enabled */
-        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
         {
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             return 0;
@@ -3980,7 +4048,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
         case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
         case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
         case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
@@ -3990,23 +4058,23 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
             break;
     }
 
-    if(bmiCounter)
+    if (bmiCounter)
     {
         switch(p_FmPort->portType)
         {
             case(e_FM_PORT_TYPE_RX_10G):
             case(e_FM_PORT_TYPE_RX):
-               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+               if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
             case(e_FM_PORT_TYPE_TX_10G):
             case(e_FM_PORT_TYPE_TX):
-               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+               if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+               if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                  break;
             default:
@@ -4018,7 +4086,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     {
 
         /* check that counters are enabled */
-        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
 
         /* Set counter */
@@ -4054,7 +4122,7 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
@@ -4066,9 +4134,9 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if(tmpPool == poolId)
+            if (tmpPool == poolId)
             {
-                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                     return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
                 else
                 {
@@ -4092,7 +4160,7 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
 
@@ -4102,9 +4170,9 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if(tmpPool == poolId)
+            if (tmpPool == poolId)
             {
-                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                 {
                     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
                     return E_OK;
@@ -4127,7 +4195,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
 
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
-    if(err != E_OK)
+    if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
         return TRUE;
@@ -4200,10 +4268,10 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->pcdEngines, E_INVALID_STATE);
 
     /*alloc window of VSPs for this port*/
-    err = FmVSPAlloc(p_FmPort->h_Fm,
-                             p_FmPort->portType,
-                             p_FmPort->portId,
-                             p_VSPParams->numOfProfiles);
+    err = FmVSPAllocForPort(p_FmPort->h_Fm,
+                            p_FmPort->portType,
+                            p_FmPort->portId,
+                            p_VSPParams->numOfProfiles);
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -4274,7 +4342,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     if (numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     /* set the port handle within the PCD policer, even if no profiles defined */
@@ -4300,7 +4368,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 
     RELEASE_LOCK(p_FmPort->lock);
 
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err,NO_MSG);
 
     return E_OK;
@@ -4339,24 +4407,24 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     }
 
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
-    if(p_FmPcdKgScheme->direct)
+    if (p_FmPcdKgScheme->direct)
     {
         physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
-        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        if (!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
         }
 
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
         }
 
-        if(!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
+        if (!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
@@ -4385,7 +4453,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
-    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+    if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
     switch(p_FmPort->portType)
@@ -4411,7 +4479,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
          return ERROR_CODE(E_BUSY);
     }
 
-    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
@@ -4419,7 +4487,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
 
-    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
     {
         /* update BMI HPNIA */
         WRITE_UINT32(*p_BmiHpnia, tmpReg);
@@ -4447,7 +4515,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
     switch(p_FmPort->portType)
@@ -4464,7 +4532,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     }
 
     /* check that current NIA is BMI to BMI */
-    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
     /*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
@@ -4472,7 +4540,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
     p_FmPort->requiredAction = 0;
 
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
         {
@@ -4505,7 +4573,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
              return ERROR_CODE(E_BUSY);
         }
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
-        if(err)
+        if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -4586,6 +4654,9 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
     t_FmPortPcdCcParams     fmPortPcdCcParams;
     t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+#ifdef ALU_CUSTOM
+    void                    *p_MuramPage;
+#endif /* ALU_CUSTOM */
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4626,12 +4697,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
             /* No user-tree, need to build internal tree */
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
-            if(!p_FmPcdCcTreeParams)
+            if (!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
 
-            memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
-
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
             p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
             if (!p_FmPort->h_IpReassemblyTree)
@@ -4644,6 +4713,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             else
                 p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
 
+            memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
             fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
 
@@ -4719,13 +4789,30 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
+#ifdef ALU_CUSTOM
+            FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, &p_MuramPage);
+#endif /* ALU_CUSTOM */
+
+#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+            if ((p_FmPort->fmRevInfo.majorRev < 6) &&
+                (p_FmPort->pcdEngines & FM_PCD_KG))
+            {
+                int i;
+                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                    /* The following function must be locked */
+                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
+                                          p_PcdParams->p_KgParams->h_Schemes[i],
+                                          UPDATE_KG_NIA_CC_WA,
+                                          0);
+            }
+#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
+
             /* Set post-bmi-fetch nia */
             p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
             p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH | NIA_ENG_FM_CTL);
 
             /* Set pre-bmi-fetch nia */
-            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
-            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
+            fmPortGetSetCcParams.getCcParams.type = GET_NIA_PNDN;
             if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
             {
                 DeletePcd(p_FmPort);
@@ -4738,18 +4825,23 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
-#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
-            if ((p_FmPort->fmRevInfo.majorRev < 6) &&
-                (p_FmPort->pcdEngines & FM_PCD_KG))
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+            if (fmPortGetSetCcParams.getCcParams.nia == (NIA_ENG_BMI | NIA_BMI_AC_FETCH))
+                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
+            else
+                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME | NIA_ENG_FM_CTL);
+            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
             {
-                int i;
-                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
-                                          p_PcdParams->p_KgParams->h_Schemes[i],
-                                          UPDATE_KG_NIA_CC_WA,
-                                          0);
+                DeletePcd(p_FmPort);
+                if (p_FmPort->h_IpReassemblyTree)
+                {
+                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                    p_FmPort->h_IpReassemblyTree = NULL;
+                }
+                FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MINOR, err, NO_MSG);
             }
-#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
         }
 
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
@@ -4782,14 +4874,30 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             RETURN_ERROR(MINOR, err, NO_MSG);
         }
 
+        /* Set post-bmi-prepare-to-enq nia */
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ | NIA_ENG_FM_CTL);
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+
         if (p_FmPort->h_IpReassemblyManip)
         {
 #if (DPAA_VERSION == 10)
             if (p_FmPort->fmRevInfo.majorRev < 6)
             {
+                /* Overwrite post-bmi-prepare-to-enq nia */
                 fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
-                /* Set frag-check nia */
-                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
+                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ_ORR | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
+                fmPortGetSetCcParams.setCcParams.overwrite = TRUE;
             }
             else
             {
@@ -4817,7 +4925,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
     err = AttachPCD(h_FmPort);
-    if(err)
+    if (err)
     {
         DeletePcd(p_FmPort);
         if (p_FmPort->h_IpReassemblyTree)
@@ -4934,13 +5042,13 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
         p_FmPort->schemesPerPortVector |= tmpScmVec;
-#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
 
+#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
     if ((FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)) &&
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
     {
-        for(i = 0; i<p_PortScheme->numOfSchemes; i++)
+        for (i = 0; i<p_PortScheme->numOfSchemes; i++)
             FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
     }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
@@ -5094,7 +5202,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
 
     err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     switch(flag)
@@ -5105,6 +5213,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oicp);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
@@ -5112,6 +5221,9 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oim);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofed);
 
         DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
         DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
@@ -5261,7 +5373,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
 
-    if(flag !=1)
+    if (flag !=1)
     {
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
@@ -5293,13 +5405,10 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
 
-
-
 #ifdef FM_NO_OP_OBSERVED_CGS
-
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
     {
-        if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
                 (p_FmPort->portType != e_FM_PORT_TYPE_RX))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
     }
@@ -5321,19 +5430,15 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
     for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
     {
-
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
 #if (DPAA_VERSION >= 11)
         for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
-        {
-            if(p_CongestionGrps->pfcPrioritiesEn[i][j])
-            {
+            if (p_CongestionGrps->pfcPrioritiesEn[i][j])
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
-            }
-        }
 #endif /* (DPAA_VERSION >= 11) */
     }
+
     for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
     {
         mod = (uint8_t)(i%32);
@@ -5344,9 +5449,8 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
         /* set in the register, the bit representing the relevant congestion group. */
 
-        if(tmpArray[i])
+        if (tmpArray[i])
         {
-
             tmpReg |=  (0x00000001 << (uint32_t)mod);
 
 #if (DPAA_VERSION >= 11)
@@ -5382,8 +5486,6 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
 
-
-
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
@@ -5417,7 +5519,7 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
                                 GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
 
         /* set in the register, the bit representing the relevant congestion group. */
-        if(tmpArray[i])
+        if (tmpArray[i])
         {
             tmpReg &=  ~(0x00000001 << (uint32_t)mod);
 
@@ -5431,7 +5533,7 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
         }
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
         {
-            if(opPort)
+            if (opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
@@ -5441,3 +5543,19 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     return  E_OK;
 }
 
+#ifdef ALU_CUSTOM
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_MuramPage, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Ipv4OptionsCount, E_NULL_POINTER);
+
+    *p_Ipv4OptionsCount = GET_UINT32(*(uint32_t*)PTR_MOVE(p_FmPort->p_MuramPage,
+                                                          IPF_OPTIONS_COUNT_OFFSET));
+
+    return E_OK;
+}
+#endif /* ALU_CUSTOM */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 3684bab..8fdcc68 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -164,6 +164,21 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_PCD_MANIP                                0x08000000          /**< Manipulation indicated */
 /* @} */
 
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS       8
+#define FM_PORT_MAX_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS 256
+#define FM_PORT_CG_REG_NUM(_cgId) (((FM_PORT_NUM_OF_CONGESTION_GRPS/32)-1)-_cgId/32)
+
+/***********************************************************************/
+/*          SW parser IP-fragmentation labels (offsets)                */
+/***********************************************************************/
+#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
+#if (DPAA_VERSION == 10)
+#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
+#else
+#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x031
+#endif /* (DPAA_VERSION == 10) */
+#define IP_FRAG_SW_PATCH_IPv6_LABEL             \
+    (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
 
 /**************************************************************************//**
  @Description       Memory Mapped Registers
@@ -173,9 +188,6 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-#define FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS   8
-#define FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS 256
-
 typedef _Packed struct
 {
     volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
@@ -201,7 +213,7 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rfsdm;     /**< Rx Frame Status Discard Mask*/
     volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
     volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
-    volatile uint32_t   reserved2[0x02];/**< (0x074 0x078)  */
+    volatile uint32_t   reserved2[0x02];/**< (0x074-0x078) */
     volatile uint32_t   fmbm_rcmne;     /**< Rx Frame Continuous Mode Next Engine */
     volatile uint32_t   reserved3[0x20];/**< (0x080 0x0FF)  */
     volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
@@ -210,7 +222,7 @@ typedef _Packed struct
                                         /**< Allocate Counter-*/
     volatile uint32_t   reserved4[0x08];
                                         /**< 0x130/0x140 - 0x15F reserved -*/
-    volatile uint32_t   fmbm_rcgm[FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
+    volatile uint32_t   fmbm_rcgm[FM_PORT_MAX_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
                                         /**< Congestion Group Map*/
     volatile uint32_t   fmbm_rmpd;      /**< BM Pool Depletion  */
     volatile uint32_t   reserved5[0x1F];/**< (0x184 0x1FF) */
@@ -234,9 +246,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rfuc;      /**< Rx FIFO Utilization Counter*/
     volatile uint32_t   fmbm_rpac;      /**< Rx Pause Activation Counter*/
     volatile uint32_t   reserved7[0x18];/**< (0x2A0-0x2FF) */
-    volatile uint32_t   fmbm_rdcfg;     /**< Rx Debug-*/
-    volatile uint32_t   fmbm_rgpr;      /**< TODO */
-    volatile uint32_t   reserved8[0x3c];/**< (0x310-0x3FF) */
+    volatile uint32_t   fmbm_rdcfg[0x3];/**< Rx Debug-*/
+    volatile uint32_t   fmbm_rgpr;      /**< Rx General Purpose Register. */
+    volatile uint32_t   reserved8[0x3a];/**< (0x310-0x3FF) */
 } _PackedType t_FmPortRxBmiRegs;
 
 typedef _Packed struct
@@ -275,9 +287,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_tduc;      /**< Tx DMA Utilization Counter*/
     volatile uint32_t   fmbm_tfuc;      /**< Tx FIFO Utilization Counter*/
     volatile uint32_t   reserved4[16];  /**< (0x29C-0x2FF) */
-    volatile uint32_t   fmbm_tdcfg;     /**< Tx Debug-*/
-    volatile uint32_t   fmbm_tgpr;      /**< TODO */
-    volatile uint32_t   reserved5[0x3c];/**< (0x310-0x3FF) */
+    volatile uint32_t   fmbm_tdcfg[0x3];/**< Tx Debug-*/
+    volatile uint32_t   fmbm_tgpr;      /**< O/H General Purpose Register */
+    volatile uint32_t   reserved5[0x3a];/**< (0x310-0x3FF) */
 } _PackedType t_FmPortTxBmiRegs;
 
 typedef _Packed struct
@@ -332,10 +344,10 @@ typedef _Packed struct
     volatile uint32_t   fmbm_otuc;      /**< O/H Tasks Utilization Counter  */
     volatile uint32_t   fmbm_oduc;      /**< O/H DMA Utilization Counter */
     volatile uint32_t   fmbm_ofuc;      /**< O/H FIFO Utilization Counter */
-    volatile uint32_t   reserved6[17];  /**< (0x298-0x2FF) */
-    volatile uint32_t   fmbm_odcfg;     /**< O/H Debug-*/
-    volatile uint32_t   fmbm_ogpr;      /**< TODO */
-    volatile uint32_t   reserved7[0x3c];/**< (0x310 0x3FF) */
+    volatile uint32_t   reserved6[26];  /**< (0x298-0x2FF) */
+    volatile uint32_t   fmbm_odcfg[0x3];/**< O/H Debug (only 1 in P1023) */
+    volatile uint32_t   fmbm_ogpr;      /**< O/H General Purpose Register. */
+    volatile uint32_t   reserved7[0x3a];/**< (0x310 0x3FF) */
 } _PackedType t_FmPortOhBmiRegs;
 
 typedef _Packed union
@@ -480,7 +492,6 @@ typedef _Packed struct
                                                              FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
                                                              FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
                                                              FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
-                                                             FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
                                                              FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW))
 
 #define BMI_STATUS_OP_MASK_UNUSED               (uint32_t)(BMI_STATUS_RX_MASK_UNUSED &                \
@@ -510,7 +521,6 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
                                                  FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
                                                  FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
-                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW       | \
                                                  FM_PORT_FRM_ERR_IPRE                   | \
                                                  FM_PORT_FRM_ERR_IPFE)
@@ -716,6 +726,14 @@ typedef _Packed struct
 #define IM_EV_BSY                               0x40000000
 #define IM_EV_RX                                0x80000000
 
+
+/**************************************************************************//**
+ @Description       Additional defines
+*//***************************************************************************/
+#ifdef ALU_CUSTOM
+#define IPF_OPTIONS_COUNT_OFFSET                0x30
+#endif /* ALU_CUSTOM */
+
 typedef struct {
     t_Handle                    h_FmMuram;
     t_FmPortImPram              *p_FmPortImPram;
@@ -774,13 +792,12 @@ typedef struct {
     uint32_t                            txFifoLowComfLevel;
     uint32_t                            rxFifoPriElevationLevel;
     uint32_t                            rxFifoThreshold;
-    t_FmSpBufMargins                  bufMargins;
+    t_FmSpBufMargins                    bufMargins;
     t_FmSpIntContextDataCopy            intContext;
     bool                                syncReq;
     e_FmPortColor                       color;
     fmPortFrameErrSelect_t              errorsToDiscard;
     fmPortFrameErrSelect_t              errorsToEnq;
-    uint64_t                            fmMuramPhysBaseAddr;
     bool                                forwardReuseIntContext;
     t_FmBufferPrefixContent             bufferPrefixContent;
      t_FmBackupBmPools                   *p_BackupBmPools;
@@ -802,6 +819,7 @@ typedef struct t_FmPortRxPoolsParams
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmPcd;
+    t_Handle                    h_FmMuram;
     t_FmRevisionInfo            fmRevInfo;
     uint8_t                     portId;
     e_FmPortType                portType;
@@ -855,8 +873,11 @@ typedef struct {
     bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
     t_Handle                    h_IpReassemblyTree;
+    uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
     bool                        vspe;
+    e_FmPortGprFuncType         gprFunc;
+    void                        *p_MuramPage;
 #endif /* (DPAA_VERSION >= 11) */
 
     t_FmPortDriverParam         *p_FmPortDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index f07bed9..6ddb040 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -378,7 +378,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
 
         WRITE_UINT32(p_FmPort->im.p_FmPortImPram->rxQdPtr,
                      (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
-                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
+                                p_FmPort->fmMuramPhysBaseAddr + 0x20));
 
         LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
         WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
@@ -391,7 +391,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
                      (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
-                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+                                p_FmPort->fmMuramPhysBaseAddr));
         if (!p_FmPort->polling || p_FmPort->exceptions)
         {
             /* Allocate, configure and register interrupts */
@@ -443,7 +443,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
 
         WRITE_UINT32(p_FmPort->im.p_FmPortImPram->txQdPtr,
                      (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
-                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x40));
+                                p_FmPort->fmMuramPhysBaseAddr + 0x40));
 
         /* Initialize Tx QD */
         tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
@@ -453,7 +453,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
                      (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
-                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+                                p_FmPort->fmMuramPhysBaseAddr));
     }
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
index 7bf04b7..5cfe4b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -173,6 +173,17 @@ static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
     WRITE_UINT32(sp_regs->fm_sp_spliodn, liodn_offset);
 }
 
+static t_Error CheckParamsGeneratedInternally(t_FmVspEntry *p_FmVspEntry)
+{
+    t_Error err = E_OK;
+
+    if ((err = FmSpCheckIntContextParams(&p_FmVspEntry->intContext))!= E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if ((err =  FmSpCheckBufMargins(&p_FmVspEntry->bufMargins)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    return err;
+
+}
 static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
 {
     t_Error err = E_OK;
@@ -187,14 +198,14 @@ static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
 
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if ((err = FmSpCheckIntContextParams(&p_FmVspEntry->intContext))!= E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if ((err =  FmSpCheckBufMargins(&p_FmVspEntry->bufMargins)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
     if (p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset & ~FM_LIODN_OFFSET_MASK)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
+    err = FmVSPCheckRelativeProfile(p_FmVspEntry->h_Fm,
+                                    p_FmVspEntry->portType,
+                                    p_FmVspEntry->portId,
+                                    p_FmVspEntry->relativeProfileId);
+
     return err;
 }
 #endif /* (DPAA_VERSION >= 11) */
@@ -579,6 +590,8 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams,E_INVALID_HANDLE);
 
+    CHECK_INIT_PARAMETERS(p_FmVspEntry, CheckParams);
+
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
 
@@ -590,20 +603,11 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    err = CheckParams(p_FmVspEntry);
-    if (err != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    err = FmVSPGetAbsoluteProfileId(p_FmVspEntry->h_Fm,
-                                   p_FmVspEntry->portType,
-                                   p_FmVspEntry->portId,
-                                   p_FmVspEntry->relativeProfileId,
-                                   &absoluteProfileId);
+    err = CheckParamsGeneratedInternally(p_FmVspEntry);
     if (err != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("storage profileId too Big "));
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if (absoluteProfileId >= FM_VSP_MAX_NUM_OF_ENTRIES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("storage profileId too Big "));
 
     p_FmVspEntry->p_FmSpRegsBase =
         (fm_pcd_storage_profile_regs *)FmGetVSPBaseAddr(p_FmVspEntry->h_Fm);
@@ -640,6 +644,13 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     fm_vsp_params.buf_margins                = &p_FmVspEntry->bufMargins;
     fm_vsp_params.int_context                = &p_FmVspEntry->intContext;
 
+   /*no check on err - it was checked earlier*/
+    FmVSPGetAbsoluteProfileId(p_FmVspEntry->h_Fm,
+                                   p_FmVspEntry->portType,
+                                   p_FmVspEntry->portId,
+                                   p_FmVspEntry->relativeProfileId,
+                                   &absoluteProfileId);
+
     /*set all registers related to VSP*/
     fm_vsp_fill_entry(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 5c45d07..92b2d0f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -76,39 +76,37 @@ static bool IsFmanCtrlCodeLoaded(t_Fm *p_Fm)
 
 static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
-
     if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old FMan CTRL code is loaded; FM must be reset!"));
-    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+    if (!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
-    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+    if (p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
-    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+    if (!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
-    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
+    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
         ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||(p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaDbgCntMode not supported by this integration."));
 
-
-    if(!p_Fm->p_FmStateStruct->fmClkFreq)
+    if (!p_Fm->p_FmStateStruct->fmClkFreq)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
     if (USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq) > DMA_MAX_WATCHDOG)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
@@ -117,118 +115,131 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 #if (DPAA_VERSION >= 11)
     if ((p_Fm->partVSPBase + p_Fm->partNumOfVSPs) > FM_VSP_MAX_NUM_OF_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partVSPBase+partNumOfVSPs out of range!!!"));
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
-    if(p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
+    if (p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
-    if(!p_Fm->p_FmStateStruct->totalFifoSize || (p_Fm->p_FmStateStruct->totalFifoSize > BMI_MAX_FIFO_SIZE))
+    if (!p_Fm->p_FmStateStruct->totalFifoSize ||
+        (p_Fm->p_FmStateStruct->totalFifoSize > BMI_MAX_FIFO_SIZE))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
-    if(!p_Fm->p_FmStateStruct->totalNumOfTasks || (p_Fm->p_FmStateStruct->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
+    if (!p_Fm->p_FmStateStruct->totalNumOfTasks ||
+        (p_Fm->p_FmStateStruct->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
-#ifndef FM_NO_TOTAL_DMAS
-    if(!p_Fm->p_FmStateStruct->maxNumOfOpenDmas || (p_Fm->p_FmStateStruct->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
+
+#ifdef FM_HAS_TOTAL_DMAS
+    if (!p_Fm->p_FmStateStruct->maxNumOfOpenDmas ||
+        (p_Fm->p_FmStateStruct->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
-#endif /* FM_NO_TOTAL_DMAS */
+#endif /* FM_HAS_TOTAL_DMAS */
 
-    if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
+    if (p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
 
-    if(!p_Fm->f_Exception)
+    if (!p_Fm->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
-    if(!p_Fm->f_BusError)
+    if (!p_Fm->f_BusError)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
 
 #ifdef FM_NO_WATCHDOG
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 2) && (p_Fm->p_FmDriverParam->dmaWatchdog))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("watchdog!"));
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 2) &&
+        (p_Fm->p_FmDriverParam->dmaWatchdog))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("watchdog!"));
 #endif /* FM_NO_WATCHDOG */
 
 #ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) && (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
+        (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
 #endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
+
 #ifdef FM_NO_TNUM_AGING
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-        if(p_Fm->p_FmDriverParam->tnumAgingPeriod)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Tnum aging!"));
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
+        (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+        if (p_Fm->p_FmDriverParam->tnumAgingPeriod)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Tnum aging!"));
 #endif /* FM_NO_TNUM_AGING */
 
     /* check that user did not set revision-dependent exceptions */
 #ifdef FM_NO_DISPATCH_RAM_ECC
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-        if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
+        (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+        if (p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
-        if(p_Fm->p_FmDriverParam->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
+        if (p_Fm->p_FmDriverParam->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
 #ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
+        if (p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
 #endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
 
     return E_OK;
 }
 
+
 static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
 {
-    t_Error     err;
-    t_FmIpcIsr  fmIpcIsr;
-    t_FmIpcMsg  msg;
-
     ASSERT_COND(p_Fm->guestId == NCSW_MASTER_ID);
-    ASSERT_COND(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId]);
-    if (p_Fm->intrMng[macEvent].guestId != NCSW_MASTER_ID)
+
+    if (p_Fm->intrMng[macEvent].guestId == NCSW_MASTER_ID)
+        p_Fm->intrMng[macEvent].f_Isr(p_Fm->intrMng[macEvent].h_SrcHandle);
+
+    /* If the MAC is running on guest-partition and we have IPC session with it,
+       we inform him about the event through IPC; otherwise, we ignore the event. */
+    else if (p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId])
     {
+        t_Error     err;
+        t_FmIpcIsr  fmIpcIsr;
+        t_FmIpcMsg  msg;
+
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_GUEST_ISR;
         fmIpcIsr.pendingReg = pendingReg;
         fmIpcIsr.boolErr = FALSE;
         memcpy(msg.msgBody, &fmIpcIsr, sizeof(fmIpcIsr));
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(fmIpcIsr),
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL);
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(fmIpcIsr),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
         if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
-        return;
     }
     else
-        p_Fm->intrMng[macEvent].f_Isr(p_Fm->intrMng[macEvent].h_SrcHandle);
+        DBG(TRACE, ("FM Guest mode, without IPC - can't call ISR!"));
 }
 
-static void    BmiErrEvent(t_Fm *p_Fm)
+static void BmiErrEvent(t_Fm *p_Fm)
 {
     uint32_t    event, mask, force;
 
-    event = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
-    mask = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+    event  = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
+    mask   = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
     event &= mask;
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, force & ~event);
 
-
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
 
-    if(event & BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC)
+    if (event & BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STORAGE_PROFILE_ECC);
-    if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
+    if (event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
-    if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
+    if (event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
-    if(event & BMI_ERR_INTR_EN_DISPATCH_RAM_ECC)
+    if (event & BMI_ERR_INTR_EN_DISPATCH_RAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_DISPATCH_RAM_ECC);
 }
 
@@ -243,15 +254,15 @@ static void    QmiErrEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
 
-    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+    if (event & QMI_ERR_INTR_EN_DOUBLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
-    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+    if (event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID);
 }
 
@@ -294,7 +305,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
                          tnum,
                          liodn);
     }
-    if(mask & DMA_MODE_ECC)
+    if (mask & DMA_MODE_ECC)
     {
         if (status & DMA_STATUS_FM_SPDAT_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SINGLE_PORT_ECC);
@@ -311,16 +322,16 @@ static void    FpmErrEvent(t_Fm *p_Fm)
 {
     uint32_t    event;
 
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
 
     /* clear the all occurred events */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, event);
 
-    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+    if ((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
-    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+    if ((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
-    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+    if ((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
 }
 
@@ -328,14 +339,14 @@ static void    MuramErrIntr(t_Fm *p_Fm)
 {
     uint32_t    event, mask;
 
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
 
     ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
 
     /* clear MURAM event bit */
     /* Prior to V3 this event bit clearing does not work ! ) */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, event & ~FPM_RAM_CTL_IRAM_ECC);
 
     ASSERT_COND(event & FPM_RAM_CTL_RAMS_ECC_EN);
 
@@ -347,14 +358,14 @@ static void IramErrIntr(t_Fm *p_Fm)
 {
     uint32_t    event, mask;
 
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr) ;
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
 
     ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
 
     /* clear the acknowledged events (do not clear IRAM event) */
     /* Prior to V3 this event bit clearing does not work ! ) */
-   WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
+   WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, event & ~FPM_RAM_CTL_MURAM_ECC);
 
     ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
 
@@ -373,13 +384,13 @@ static void QmiEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
 
-    if(event & QMI_INTR_EN_SINGLE_ECC)
+    if (event & QMI_INTR_EN_SINGLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
 }
 
@@ -397,13 +408,16 @@ static void UnimplementedFmanCtrlIsr(t_Handle h_Arg, uint32_t event)
     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
 }
 
-static void FmEnableTimeStamp(t_Fm *p_Fm)
+static void EnableTimeStamp(t_Fm *p_Fm)
 {
-    uint32_t                tmpReg;
     uint64_t                fraction;
-    uint32_t                integer;
-    uint8_t                 count1MicroBit = 8;
-    uint32_t                tsFrequency = (uint32_t)(1<<count1MicroBit); /* in Mhz */
+    uint32_t                integer, tsFrequency, tmpReg;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmStateStruct);
+    ASSERT_COND(p_Fm->p_FmStateStruct->count1MicroBit);
+
+    tsFrequency = (uint32_t)(1<<p_Fm->p_FmStateStruct->count1MicroBit); /* in Mhz */
 
     /* configure timestamp so that bit 8 will count 1 microsecond */
     /* Find effective count rate at TIMESTAMP least significant bits:
@@ -414,18 +428,17 @@ static void FmEnableTimeStamp(t_Fm *p_Fm)
     integer = tsFrequency/p_Fm->p_FmStateStruct->fmClkFreq;
     /* we multiply by 2^16 to keep the fraction of the division */
     /* we do not divid back, since we write this value as fraction - see spec */
-    fraction = ((tsFrequency << 16) - (integer << 16)*p_Fm->p_FmStateStruct->fmClkFreq)/p_Fm->p_FmStateStruct->fmClkFreq;
+    fraction = ((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) / p_Fm->p_FmStateStruct->fmClkFreq;
     /* we check remainder of the division in order to round up if not integer */
-    if(((tsFrequency << 16) - (integer << 16)*p_Fm->p_FmStateStruct->fmClkFreq) % p_Fm->p_FmStateStruct->fmClkFreq)
+    if (((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) % p_Fm->p_FmStateStruct->fmClkFreq)
         fraction++;
 
     tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc2, tmpReg);
 
     /* enable timestamp with original clock */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, FPM_TS_CTL_EN);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc1, FPM_TS_CTL_EN);
 
-    p_Fm->p_FmStateStruct->count1MicroBit = count1MicroBit;
     p_Fm->p_FmStateStruct->enabledTimeStamp = TRUE;
 }
 
@@ -479,7 +492,7 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
 
     compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
-    if(compTo16)
+    if (compTo16)
         for (i=0; i < ((16-compTo16) / 4); i++)
             WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
@@ -581,110 +594,39 @@ do {                                    \
         FM_G_CALL_10G_MAC_ISR(0);
     if (pending & INTR_EN_10G_MAC1)
         FM_G_CALL_10G_MAC_ISR(1);
-    if(pending & INTR_EN_TMR)
+    if (pending & INTR_EN_TMR)
         p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 }
 
-t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
-                                        uint32_t     congestionGroupId,
-                                        uint8_t      priorityBitMap)
-{
-    t_Fm         *p_Fm  = (t_Fm *)h_Fm;
-
-    ASSERT_COND(h_Fm);
-
-    if (congestionGroupId > FM_PORT_NUM_OF_CONGESTION_GRPS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Congestion group ID bigger than %d \n!",FM_PORT_NUM_OF_CONGESTION_GRPS));
-
-    if (p_Fm->guestId == NCSW_MASTER_ID)
-    {
-        uint32_t      *p_Cpg = (uint32_t*)p_Fm->baseAddr+FM_MM_CGP;
-        uint32_t      tmpReg;
-        uint32_t      reg_num;
-        uint32_t      offset;
-
-        ASSERT_COND(p_Fm->baseAddr);
-        reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
-        offset  = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))%4;
-
-
-        tmpReg = GET_UINT32(p_Cpg[reg_num]);
-
-        if(priorityBitMap)//adding priority
-        {
-            if(tmpReg & (0xFF<<(28-(offset*8))))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PFC priority for the congestion group is already set!"));
-
-        }
-        tmpReg |= (uint32_t)priorityBitMap <<(28-(offset*8));
-            WRITE_UINT32(p_Cpg[reg_num], tmpReg);
-    }
-    else if (p_Fm->h_IpcSessions)
-    {
-        t_Error                              err;
-        t_FmIpcMsg                           msg;
-        t_FmIpcSetCongestionGroupPfcPriority FmIpcSetCongestionGroupPfcPriority;
-
-        ASSERT_COND(p_Fm->guestId < FM_MAX_NUM_OF_GUESTS);
-
-        memset(&msg, 0, sizeof(msg));
-        memset(&FmIpcSetCongestionGroupPfcPriority, 0, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
-        FmIpcSetCongestionGroupPfcPriority.congestionGroupId = congestionGroupId;
-        FmIpcSetCongestionGroupPfcPriority.priorityBitMap    = priorityBitMap;
-
-        msg.msgId                               = FM_SET_CONG_GRP_PFC_PRIO;
-        memcpy(msg.msgBody, &FmIpcSetCongestionGroupPfcPriority, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
-
-        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->guestId],
-                                (uint8_t*)&msg,
-                                sizeof(msg.msgId),
-                                NULL,
-                                NULL,
-                                NULL,
-                                NULL);
-        if (err != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("guest without IPC!"));
-
-    return E_OK;
-}
-
 #if (DPAA_VERSION >= 11)
-t_Error FmVSPSetWindow(t_Handle  h_Fm,
-                                  uint8_t   hardwarePortId,
-                                  uint8_t   baseStorageProfile,
-                       uint8_t  log2NumOfProfiles)
+static t_Error SetVSPWindow(t_Handle  h_Fm,
+                            uint8_t   hardwarePortId,
+                            uint8_t   baseStorageProfile,
+                            uint8_t   log2NumOfProfiles)
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
     uint32_t                tmpReg;
-    t_Error                 err = E_OK;
 
     ASSERT_COND(h_Fm);
     ASSERT_COND(hardwarePortId);
 
-    if (p_Fm->p_FmBmiRegs)
-    {
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1]);
-        tmpReg |= (uint32_t)((uint32_t)baseStorageProfile & 0x3f) << 16;
-        tmpReg |= (uint32_t)log2NumOfProfiles << 28;
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], tmpReg);
-    }
-    else if ((p_Fm->guestId != NCSW_MASTER_ID) && p_Fm->h_IpcSessions)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->p_FmBmiRegs &&
+        p_Fm->h_IpcSessions[0])
     {
-
-        t_FmIpcMsg          msg;
         t_FmIpcVspSetPortWindow fmIpcVspSetPortWindow;
+        t_FmIpcMsg              msg;
+        t_Error                 err = E_OK;
+
         memset(&msg, 0, sizeof(msg));
         memset(&fmIpcVspSetPortWindow, 0, sizeof(t_FmIpcVspSetPortWindow));
         fmIpcVspSetPortWindow.hardwarePortId      = hardwarePortId;
         fmIpcVspSetPortWindow.baseStorageProfile  = baseStorageProfile;
         fmIpcVspSetPortWindow.log2NumOfProfiles   = log2NumOfProfiles;
-        msg.msgId                               = FM_VSP_SET_PORT_WINDOW;
+        msg.msgId                                 = FM_VSP_SET_PORT_WINDOW;
         memcpy(msg.msgBody, &fmIpcVspSetPortWindow, sizeof(t_FmIpcVspSetPortWindow));
 
-        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->guestId],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                 (uint8_t*)&msg,
                                 sizeof(msg.msgId),
                                 NULL,
@@ -693,36 +635,81 @@ t_Error FmVSPSetWindow(t_Handle  h_Fm,
                                 NULL);
         if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
     }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Guest without either registers address or IPC!"));
-    return err;
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1]);
+    tmpReg |= (uint32_t)((uint32_t)baseStorageProfile & 0x3f) << 16;
+    tmpReg |= (uint32_t)log2NumOfProfiles << 28;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], tmpReg);
+
+    return E_OK;
 }
 
-static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfiles, uint8_t guestId)
+static uint8_t AllocVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProfiles, uint8_t guestId)
 {
     t_Fm        *p_Fm = (t_Fm *)h_Fm;
     uint8_t     profilesFound = 0;
-    int         i     = 0;
+    int         i = 0;
     uint32_t    intFlags;
 
-    if (!numOfStorageProfiles)
+    if (!numOfProfiles)
         return E_OK;
 
-    if ((numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES) ||
-        (base + numOfStorageProfiles > FM_VSP_MAX_NUM_OF_ENTRIES))
+    if ((numOfProfiles > FM_VSP_MAX_NUM_OF_ENTRIES) ||
+        (base + numOfProfiles > FM_VSP_MAX_NUM_OF_ENTRIES))
         return (uint8_t)ILLEGAL_BASE;
 
-    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    if (p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcResourceAllocParams  ipcProfilesAllocParams;
+        t_FmIpcMsg                  msg;
+        t_FmIpcReply                reply;
+        t_Error                     err;
+        uint32_t                    replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcProfilesAllocParams.guestId         = p_Fm->guestId;
+        ipcProfilesAllocParams.num             = p_Fm->partNumOfVSPs;
+        ipcProfilesAllocParams.base            = p_Fm->partVSPBase;
+        msg.msgId                              = FM_VSP_ALLOC;
+        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if ((err != E_OK) ||
+            (replyLength != (sizeof(uint32_t) + sizeof(uint8_t))))
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        else
+            memcpy((uint8_t*)&p_Fm->partVSPBase, reply.replyBody, sizeof(uint8_t));
+        if (p_Fm->partVSPBase == ILLEGAL_BASE)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+        return (uint8_t)ILLEGAL_BASE;
+    }
 
-    for (i = base; i < base + numOfStorageProfiles; i++)
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    for (i = base; i < base + numOfProfiles; i++)
         if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
             profilesFound++;
         else
             break;
 
-    if (profilesFound == numOfStorageProfiles)
-        for (i = base; i<base + numOfStorageProfiles; i++)
+    if (profilesFound == numOfProfiles)
+        for (i = base; i<base + numOfProfiles; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = guestId;
     else
     {
@@ -734,24 +721,58 @@ static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStoragePro
     return base;
 }
 
-static void FmVSPsFree(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfiles, uint8_t guestId)
+static void FreeVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProfiles, uint8_t guestId)
 {
     t_Fm    *p_Fm = (t_Fm *)h_Fm;
-    int i = 0;
+    int     i = 0;
 
     ASSERT_COND(p_Fm);
+
+    if (p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcResourceAllocParams  ipcProfilesAllocParams;
+        t_FmIpcMsg                  msg;
+        t_FmIpcReply                reply;
+        uint32_t                    replyLength;
+        t_Error                     err;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcProfilesAllocParams.guestId         = p_Fm->guestId;
+        ipcProfilesAllocParams.num             = p_Fm->partNumOfVSPs;
+        ipcProfilesAllocParams.base            = p_Fm->partVSPBase;
+        msg.msgId                              = FM_VSP_FREE;
+        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+        return;
+    }
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+        return;
+    }
+
     ASSERT_COND(p_Fm->p_FmSp);
 
-    for (i = base; i < numOfStorageProfiles; i++)
+    for (i=base; i<numOfProfiles; i++)
     {
-        if(p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
+        if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
            p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
         else
             DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
     }
 }
-#endif /*(DPAA_VERSION >= 11)*/
-
+#endif /* (DPAA_VERSION >= 11) */
 
 static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
                                      uint8_t   *p_Msg,
@@ -781,7 +802,7 @@ static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcIsr ipcIsr;
 
             memcpy((uint8_t*)&ipcIsr, p_IpcMsg->msgBody, sizeof(t_FmIpcIsr));
-            if(ipcIsr.boolErr)
+            if (ipcIsr.boolErr)
                 GuestErrorIsr(p_Fm, ipcIsr.pendingReg);
             else
                 GuestEventIsr(p_Fm, ipcIsr.pendingReg);
@@ -851,10 +872,11 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcPortRsrcParams   ipcPortRsrcParams;
 
             memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
-            p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm, ipcPortRsrcParams.hardwarePortId,
-                                                                ipcPortRsrcParams.val,
-                                                                ipcPortRsrcParams.extra,
-                                                               (bool)ipcPortRsrcParams.boolInitialConfig);
+            p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm,
+                                                          ipcPortRsrcParams.hardwarePortId,
+                                                          ipcPortRsrcParams.val,
+                                                          ipcPortRsrcParams.extra,
+                                                          (bool)ipcPortRsrcParams.boolInitialConfig);
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
         }
@@ -891,7 +913,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             uint8_t guestId = p_IpcMsg->msgBody[0];
             /* build the FM master partition IPC address */
             memset(p_Fm->fmIpcHandlerModuleName[guestId], 0, (sizeof(char)) * MODULE_NAME_SIZE);
-            if(Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
+            if (Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
             p_Fm->h_IpcSessions[guestId] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[guestId], p_Fm->fmModuleName);
             if (p_Fm->h_IpcSessions[guestId] == NULL)
@@ -936,41 +958,42 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 #if (DPAA_VERSION >= 11)
         case (FM_VSP_ALLOC) :
         {
-            t_FmIpcVspAllocParams   ipcVspAllocParams;
-            uint8_t                 vspBase;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcVspAllocParams));
-            vspBase =  FmVSPsAlloc(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.numOfProfiles, ipcVspAllocParams.guestId);
+            t_FmIpcResourceAllocParams  ipcVspAllocParams;
+            uint8_t                     vspBase;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            vspBase =  AllocVSPsForPartition(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.num, ipcVspAllocParams.guestId);
             memcpy(p_IpcReply->replyBody, (uint8_t*)&vspBase, sizeof(uint8_t));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         }
         case (FM_VSP_FREE) :
         {
-            t_FmIpcVspAllocParams   ipcVspAllocParams;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcVspAllocParams));
-            FmVSPsFree(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.numOfProfiles, ipcVspAllocParams.guestId);
+            t_FmIpcResourceAllocParams   ipcVspAllocParams;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            FreeVSPsForPartition(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.num, ipcVspAllocParams.guestId);
             break;
         }
-        case(FM_VSP_SET_PORT_WINDOW) :
+        case (FM_VSP_SET_PORT_WINDOW) :
         {
             t_FmIpcVspSetPortWindow   ipcVspSetPortWindow;
             memcpy(&ipcVspSetPortWindow, p_IpcMsg->msgBody, sizeof(t_FmIpcVspSetPortWindow));
-            err = FmVSPSetWindow(h_Fm,
+            err = SetVSPWindow(h_Fm,
                                             ipcVspSetPortWindow.hardwarePortId,
                                             ipcVspSetPortWindow.baseStorageProfile,
                                             ipcVspSetPortWindow.log2NumOfProfiles);
             return err;
         }
-        case(FM_SET_CONG_GRP_PFC_PRIO) :
+        case (FM_SET_CONG_GRP_PFC_PRIO) :
         {
-            t_FmIpcSetCongestionGroupPfcPriority    FmIpcSetCongestionGroupPfcPriority;
-            memcpy(&FmIpcSetCongestionGroupPfcPriority, p_IpcMsg->msgBody, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+            t_FmIpcSetCongestionGroupPfcPriority    fmIpcSetCongestionGroupPfcPriority;
+            memcpy(&fmIpcSetCongestionGroupPfcPriority, p_IpcMsg->msgBody, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
             err = FmSetCongestionGroupPFCpriority(h_Fm,
-                                                  FmIpcSetCongestionGroupPfcPriority.congestionGroupId,
-                                                  FmIpcSetCongestionGroupPfcPriority.priorityBitMap);
+                                                  fmIpcSetCongestionGroupPfcPriority.congestionGroupId,
+                                                  fmIpcSetCongestionGroupPfcPriority.priorityBitMap);
             return err;
         }
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
+
         case (FM_FREE_PORT):
         {
             t_FmInterModulePortFreeParams   portParams;
@@ -991,22 +1014,6 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             p_Fm->intrMng[ipcRegIntr.event].guestId = ipcRegIntr.guestId;
             break;
         }
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-        case (FM_DUMP_REGS):
-        {
-            err = FM_DumpRegs(h_Fm);
-            if (err != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-        }
-        case (FM_DUMP_PORT_REGS):
-        {
-            err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0]);
-            if (err != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
-        }
-#endif /* (defined(DEBUG_ERRORS) && ... */
         case (FM_GET_PARAMS):
         {
              t_FmIpcParams  ipcParams;
@@ -1183,53 +1190,53 @@ static void ErrorIsrCB(t_Handle h_Fm)
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
     /* error interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmepi);
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi);
     if (!pending)
         return;
 
-    if(pending & ERR_INTR_EN_BMI)
+    if (pending & ERR_INTR_EN_BMI)
         BmiErrEvent(p_Fm);
-    if(pending & ERR_INTR_EN_QMI)
+    if (pending & ERR_INTR_EN_QMI)
         QmiErrEvent(p_Fm);
-    if(pending & ERR_INTR_EN_FPM)
+    if (pending & ERR_INTR_EN_FPM)
         FpmErrEvent(p_Fm);
-    if(pending & ERR_INTR_EN_DMA)
+    if (pending & ERR_INTR_EN_DMA)
         DmaErrEvent(p_Fm);
-    if(pending & ERR_INTR_EN_IRAM)
+    if (pending & ERR_INTR_EN_IRAM)
         IramErrIntr(p_Fm);
-    if(pending & ERR_INTR_EN_MURAM)
+    if (pending & ERR_INTR_EN_MURAM)
         MuramErrIntr(p_Fm);
-    if(pending & ERR_INTR_EN_PRS)
+    if (pending & ERR_INTR_EN_PRS)
         p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
-    if(pending & ERR_INTR_EN_PLCR)
+    if (pending & ERR_INTR_EN_PLCR)
         p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
-    if(pending & ERR_INTR_EN_KG)
+    if (pending & ERR_INTR_EN_KG)
         p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
 
     /* MAC events may belong to different partitions */
-    if(pending & ERR_INTR_EN_1G_MAC0)
+    if (pending & ERR_INTR_EN_1G_MAC0)
         FM_M_CALL_1G_MAC_ERR_ISR(0);
-    if(pending & ERR_INTR_EN_1G_MAC1)
+    if (pending & ERR_INTR_EN_1G_MAC1)
         FM_M_CALL_1G_MAC_ERR_ISR(1);
-    if(pending & ERR_INTR_EN_1G_MAC2)
+    if (pending & ERR_INTR_EN_1G_MAC2)
         FM_M_CALL_1G_MAC_ERR_ISR(2);
-    if(pending & ERR_INTR_EN_1G_MAC3)
+    if (pending & ERR_INTR_EN_1G_MAC3)
         FM_M_CALL_1G_MAC_ERR_ISR(3);
-    if(pending & ERR_INTR_EN_1G_MAC4)
+    if (pending & ERR_INTR_EN_1G_MAC4)
         FM_M_CALL_1G_MAC_ERR_ISR(4);
-    if(pending & ERR_INTR_EN_1G_MAC5)
+    if (pending & ERR_INTR_EN_1G_MAC5)
         FM_M_CALL_1G_MAC_ERR_ISR(5);
-    if(pending & ERR_INTR_EN_1G_MAC6)
+    if (pending & ERR_INTR_EN_1G_MAC6)
         FM_M_CALL_1G_MAC_ERR_ISR(6);
-    if(pending & ERR_INTR_EN_1G_MAC7)
+    if (pending & ERR_INTR_EN_1G_MAC7)
         FM_M_CALL_1G_MAC_ERR_ISR(7);
-    if(pending & ERR_INTR_EN_10G_MAC0)
+    if (pending & ERR_INTR_EN_10G_MAC0)
         FM_M_CALL_10G_MAC_ERR_ISR(0);
-    if(pending & ERR_INTR_EN_10G_MAC1)
+    if (pending & ERR_INTR_EN_10G_MAC1)
         FM_M_CALL_10G_MAC_ERR_ISR(1);
 
 #ifdef FM_MACSEC_SUPPORT
-    if(pending & ERR_INTR_EN_MACSEC_MAC0)
+    if (pending & ERR_INTR_EN_MACSEC_MAC0)
     {
        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].guestId)
             SendIpcIsr(p_Fm, e_FM_EV_ERR_MACSEC_MAC0, pending);
@@ -1283,9 +1290,9 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
                      ("MAC should be initialized prior to rx and tx ports!"));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmextc, 0x40000000);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc, 0x40000000);
     CORE_MemoryBarrier();
-    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fpmextc) & 0x40000000) &&
+    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc) & 0x40000000) &&
            --timeout) ;
     if (!timeout)
         return ERROR_CODE(E_TIMEOUT);
@@ -1293,6 +1300,72 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
 }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
+t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
+                                        uint32_t     congestionGroupId,
+                                        uint8_t      priorityBitMap)
+{
+    t_Fm         *p_Fm  = (t_Fm *)h_Fm;
+
+    ASSERT_COND(h_Fm);
+
+    if (congestionGroupId > FM_PORT_NUM_OF_CONGESTION_GRPS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("Congestion group ID bigger than %d \n!",
+                      FM_PORT_NUM_OF_CONGESTION_GRPS));
+
+    if (p_Fm->guestId == NCSW_MASTER_ID)
+    {
+        uint32_t      *p_Cpg = (uint32_t*)p_Fm->baseAddr+FM_MM_CGP;
+        uint32_t      tmpReg;
+        uint32_t      reg_num;
+        uint32_t      offset;
+
+        ASSERT_COND(p_Fm->baseAddr);
+        reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
+        offset  = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))%4;
+
+        tmpReg = GET_UINT32(p_Cpg[reg_num]);
+
+        if (priorityBitMap)//adding priority
+        {
+            if (tmpReg & (0xFF<<(28-(offset*8))))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("PFC priority for the congestion group is already set!"));
+        }
+        tmpReg |= (uint32_t)priorityBitMap << (28-(offset*8));
+            WRITE_UINT32(p_Cpg[reg_num], tmpReg);
+    }
+
+    else if (p_Fm->h_IpcSessions[0])
+    {
+        t_Error                              err;
+        t_FmIpcMsg                           msg;
+        t_FmIpcSetCongestionGroupPfcPriority fmIpcSetCongestionGroupPfcPriority;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&fmIpcSetCongestionGroupPfcPriority, 0, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+        fmIpcSetCongestionGroupPfcPriority.congestionGroupId = congestionGroupId;
+        fmIpcSetCongestionGroupPfcPriority.priorityBitMap    = priorityBitMap;
+
+        msg.msgId = FM_SET_CONG_GRP_PFC_PRIO;
+        memcpy(msg.msgBody, &fmIpcSetCongestionGroupPfcPriority, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("guest without IPC!"));
+
+    return E_OK;
+}
+
 uintptr_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -1350,7 +1423,7 @@ uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
 
     return p_Fm->vspBaseAddr;
 }
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
 t_Handle FmGetMuramHandle(t_Handle h_Fm)
 {
@@ -1364,14 +1437,25 @@ t_Handle FmGetMuramHandle(t_Handle h_Fm)
 void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    t_Error         err;
-    t_FmIpcMsg      msg;
-    t_FmIpcReply    reply;
-    uint32_t        replyLength;
-    t_FmIpcPhysAddr ipcPhysAddr;
 
-    if (p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->fmMuramPhysBaseAddr)
+    {
+        /* General FM driver initialization */
+        p_FmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
+        p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
+        return;
+    }
+
+    ASSERT_COND(p_Fm->guestId != NCSW_MASTER_ID);
+
+    if (p_Fm->h_IpcSessions[0])
     {
+        t_Error         err;
+        t_FmIpcMsg      msg;
+        t_FmIpcReply    reply;
+        uint32_t        replyLength;
+        t_FmIpcPhysAddr ipcPhysAddr;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_PHYS_MURAM_BASE;
@@ -1396,66 +1480,35 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
         memcpy((uint8_t*)&ipcPhysAddr, reply.replyBody, sizeof(t_FmIpcPhysAddr));
         p_FmPhysAddr->high = ipcPhysAddr.high;
         p_FmPhysAddr->low  = ipcPhysAddr.low;
-        return ;
     }
-
-    /* General FM driver initialization */
-    p_FmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
-    p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
+    else
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 }
 
 #if (DPAA_VERSION >= 11)
-t_Error FmVSPFree(  t_Handle        h_Fm,
-                    e_FmPortType    portType,
-                    uint8_t         portId)
+t_Error FmVSPAllocForPort (t_Handle        h_Fm,
+                           e_FmPortType    portType,
+                           uint8_t         portId,
+                           uint8_t         numOfVSPs)
 {
-    t_Fm            *p_Fm = (t_Fm *)h_Fm;
-    uint8_t         swPortIndex, hardwarePortId, first, numOfVSPs, i;
-    uint32_t        intFlags;
+    t_Fm           *p_Fm = (t_Fm *)h_Fm;
+    t_Error        err = E_OK;
+    uint32_t       profilesFound, intFlags;
+    uint8_t        first, i;
+    uint8_t        log2Num;
+    uint8_t        swPortIndex=0, hardwarePortId;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+     if (!numOfVSPs)
+        return E_OK;
 
-    numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
-    first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
+    if (numOfVSPs > FM_VSP_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles can not be bigger than %d.",FM_VSP_MAX_NUM_OF_ENTRIES));
 
-    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
-
-    for(i = first; i < first + numOfVSPs; i++)
-           p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
-
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
-
-    p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = 0;
-    p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = 0;
-
-    return E_OK;
-
-}
-t_Error FmVSPAlloc          (t_Handle  h_Fm,
-                           e_FmPortType    portType,
-                           uint8_t         portId,
-                           uint8_t   numOfVSPs)
-{
-    t_Fm           *p_Fm = (t_Fm *)h_Fm;
-    t_Error        err = E_OK;
-    uint32_t       profilesFound, intFlags;
-    uint8_t        first, i;
-    uint8_t        log2Num;
-    uint8_t        swPortIndex, hardwarePortId;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-
-     if (!numOfVSPs)
-        return E_OK;
-
-    if (numOfVSPs>FM_VSP_MAX_NUM_OF_ENTRIES)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
-
-    if (!POWER_OF_2(numOfVSPs))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+    if (!POWER_OF_2(numOfVSPs))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
     LOG2((uint64_t)numOfVSPs, log2Num);
 
@@ -1467,23 +1520,22 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     if (first > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
          RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
 
-    if (first<p_Fm->partVSPBase)
+    if (first < p_Fm->partVSPBase)
         while(first < p_Fm->partVSPBase)
             first = first + numOfVSPs;
 
-    if ((first + numOfVSPs ) > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
+    if ((first + numOfVSPs) > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
-
     profilesFound = 0;
-    for (i=first; i < p_Fm->partVSPBase + p_Fm->partNumOfVSPs;)
+    for (i=first; i < p_Fm->partVSPBase + p_Fm->partNumOfVSPs; )
     {
         if (!p_Fm->p_FmSp->profiles[i].profilesMng.allocated)
         {
             profilesFound++;
             i++;
-            if(profilesFound == numOfVSPs)
+            if (profilesFound == numOfVSPs)
                 break;
         }
         else
@@ -1508,7 +1560,7 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = numOfVSPs;
     p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = first;
 
-    if ((err = FmVSPSetWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
+    if ((err = SetVSPWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
         for(i = first; i < first + numOfVSPs; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
 
@@ -1517,20 +1569,49 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     return err;
 }
 
+t_Error FmVSPFreeForPort(t_Handle        h_Fm,
+                         e_FmPortType    portType,
+                         uint8_t         portId)
+{
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+    uint8_t         swPortIndex=0, hardwarePortId, first, numOfVSPs, i;
+    uint32_t        intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
+    first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
+
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    for(i = first; i < first + numOfVSPs; i++)
+           p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
-#endif /* UNDER_CONSTRUCTION_FM_STORAGE_PRFL */
+    p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = 0;
+
+    return E_OK;
+}
+#endif /* (DPAA_VERSION >= 11) */
 
 t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
     uint8_t         i;
-    t_Error         err;
-    t_FmIpcMsg      msg;
-    t_FmIpcReply    reply;
-    uint32_t        replyLength;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error         err;
+        t_FmIpcMsg      msg;
+        t_FmIpcReply    reply;
+        uint32_t        replyLength;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_ALLOC_FMAN_CTRL_EVENT_REG;
@@ -1551,8 +1632,11 @@ t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
 
         return (t_Error)(reply.error);
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
 
-    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+    for (i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
         if (!p_Fm->usedEventRegs[i])
         {
             p_Fm->usedEventRegs[i] = TRUE;
@@ -1569,11 +1653,15 @@ t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
 void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    t_Error     err;
-    t_FmIpcMsg  msg;
 
-    if(((t_Fm *)h_Fm)->guestId != NCSW_MASTER_ID)
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error     err;
+        t_FmIpcMsg  msg;
+
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_FREE_FMAN_CTRL_EVENT_REG;
         msg.msgBody[0] = eventId;
@@ -1588,84 +1676,28 @@ void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
-
-    ((t_Fm*)h_Fm)->usedEventRegs[eventId] = FALSE;
-}
-
-void FmRegisterIntr(t_Handle                h_Fm,
-                    e_FmEventModules        module,
-                    uint8_t                 modId,
-                    e_FmIntrType            intrType,
-                    void                    (*f_Isr) (t_Handle h_Arg),
-                    t_Handle                h_Arg)
-{
-    t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_FmIpcRegisterIntr fmIpcRegisterIntr;
-    t_Error             err;
-    t_FmIpcMsg          msg;
-    int                 event = 0;
-
-    ASSERT_COND(h_Fm);
-
-    GET_FM_MODULE_EVENT(module, modId, intrType, event);
-    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
-
-    /* register in local FM structure */
-    p_Fm->intrMng[event].f_Isr = f_Isr;
-    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
-
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-        if(p_Fm->h_IpcSessions[0])
-        {
-            /* register in Master FM structure */
-            fmIpcRegisterIntr.event = (uint32_t)event;
-            fmIpcRegisterIntr.guestId = p_Fm->guestId;
-            memset(&msg, 0, sizeof(msg));
-            msg.msgId = FM_REGISTER_INTR;
-            memcpy(msg.msgBody, &fmIpcRegisterIntr, sizeof(fmIpcRegisterIntr));
-            err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                    (uint8_t*)&msg,
-                                    sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
-                                    NULL,
-                                    NULL,
-                                    NULL,
-                                    NULL);
-            if (err != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-        }
-        else
-            DBG(WARNING,("'Register interrupt' - unavailable - No IPC"));
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
+        return;
     }
 
+    ((t_Fm*)h_Fm)->usedEventRegs[eventId] = FALSE;
 }
 
-void FmUnregisterIntr(t_Handle                  h_Fm,
-                        e_FmEventModules        module,
-                        uint8_t                 modId,
-                        e_FmIntrType            intrType)
-{
-    t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    int         event = 0;
-
-    ASSERT_COND(h_Fm);
-
-    GET_FM_MODULE_EVENT(module, modId,intrType, event);
-    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
-
-    p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
-    p_Fm->intrMng[event].h_SrcHandle = NULL;
-}
-
-void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvents)
+void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, uint32_t enableEvents)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_FmIpcFmanEvents   fmanCtrl;
-    t_Error             err;
-    t_FmIpcMsg          msg;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->p_FmFpmRegs &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_FmIpcFmanEvents   fmanCtrl;
+        t_Error             err;
+        t_FmIpcMsg          msg;
+
         fmanCtrl.eventRegId = eventRegId;
         fmanCtrl.enableEvents = enableEvents;
         memset(&msg, 0, sizeof(msg));
@@ -1682,21 +1714,30 @@ void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvent
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+        return;
+    }
 
     ASSERT_COND(eventRegId < FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId], enableEvents);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[eventRegId], enableEvents);
 }
 
 uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    t_Error         err;
-    t_FmIpcMsg      msg;
-    t_FmIpcReply    reply;
-    uint32_t        replyLength, ctrlIntr;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->p_FmFpmRegs &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error         err;
+        t_FmIpcMsg      msg;
+        t_FmIpcReply    reply;
+        uint32_t        replyLength, ctrlIntr;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_FMAN_CTRL_EVENTS_ENABLE;
@@ -1722,8 +1763,78 @@ uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
         memcpy((uint8_t*)&ctrlIntr, reply.replyBody, sizeof(uint32_t));
         return ctrlIntr;
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+        return 0;
+    }
+
+    return GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[eventRegId]);
+}
+
+void FmRegisterIntr(t_Handle                h_Fm,
+                    e_FmEventModules        module,
+                    uint8_t                 modId,
+                    e_FmIntrType            intrType,
+                    void                    (*f_Isr) (t_Handle h_Arg),
+                    t_Handle                h_Arg)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    int                 event = 0;
+
+    ASSERT_COND(h_Fm);
+
+    GET_FM_MODULE_EVENT(module, modId, intrType, event);
+    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
+
+    /* register in local FM structure */
+    p_Fm->intrMng[event].f_Isr = f_Isr;
+    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcRegisterIntr fmIpcRegisterIntr;
+        t_Error             err;
+        t_FmIpcMsg          msg;
+
+        /* register in Master FM structure */
+        fmIpcRegisterIntr.event = (uint32_t)event;
+        fmIpcRegisterIntr.guestId = p_Fm->guestId;
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_REGISTER_INTR;
+        memcpy(msg.msgBody, &fmIpcRegisterIntr, sizeof(fmIpcRegisterIntr));
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
+}
+
+void FmUnregisterIntr(t_Handle                  h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    int         event = 0;
+
+    ASSERT_COND(h_Fm);
+
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
 
-    return GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId]);
+    p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
+    p_Fm->intrMng[event].h_SrcHandle = NULL;
 }
 
 void  FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Arg, uint32_t event), t_Handle    h_Arg)
@@ -1732,10 +1843,10 @@ void  FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t
 
     ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-        ASSERT_COND(0);
-        /* TODO */
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM in guest-mode"));
+        return;
     }
 
     p_Fm->fmanCtrlIntr[eventRegId].f_Isr = f_Isr;
@@ -1748,10 +1859,10 @@ void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
 
     ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-        ASSERT_COND(0);
-        /* TODO */
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM in guest-mode"));
+        return;
     }
 
     p_Fm->fmanCtrlIntr[eventRegId].f_Isr = UnimplementedFmanCtrlIsr;
@@ -1762,25 +1873,23 @@ void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
 
-    if(p_Fm->h_Pcd)
+    if (p_Fm->h_Pcd)
         REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
 
     p_Fm->h_Pcd = h_FmPcd;
-
 }
 
 void  FmUnregisterPcd(t_Handle h_Fm)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
 
-    if(!p_Fm->h_Pcd)
-        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("No PCD"));
+    if (!p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("PCD handle!"));
 
     p_Fm->h_Pcd = NULL;
-
 }
 
-t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+t_Handle FmGetPcdHandle(t_Handle h_Fm)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
 
@@ -1796,51 +1905,57 @@ uint8_t FmGetId(t_Handle h_Fm)
     return p_Fm->p_FmStateStruct->fmId;
 }
 
-t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl)
+t_Error FmSetNumOfRiscsPerPort(t_Handle     h_Fm,
+                               uint8_t      hardwarePortId,
+                               uint8_t      numOfFmanCtrls,
+                               t_FmFmanCtrl orFmanCtrl)
 {
 
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                    tmpReg = 0, intFlags;
-    t_Error                     err;
-    t_FmIpcPortNumOfFmanCtrls   params;
-    t_FmIpcMsg                  msg;
+    uint32_t                    tmpReg = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->p_FmFpmRegs &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error                     err;
+        t_FmIpcPortNumOfFmanCtrls   params;
+        t_FmIpcMsg                  msg;
+
         memset(&msg, 0, sizeof(msg));
         params.hardwarePortId = hardwarePortId;
         params.numOfFmanCtrls = numOfFmanCtrls;
         params.orFmanCtrl = orFmanCtrl;
         msg.msgId = FM_SET_NUM_OF_FMAN_CTRL;
         memcpy(msg.msgBody, &params, sizeof(params));
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(params),
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) +sizeof(params),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         return E_OK;
     }
-
-    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
 
-    /*TODO - maybe to put CTL# according to another criteria*/
-
-    if(numOfFmanCtrls == 2)
+    /* TODO - maybe to put CTL# according to another criteria */
+    if (numOfFmanCtrls == 2)
         tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
 
     /* order restoration */
     tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
 
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
 
     return E_OK;
 }
@@ -1848,29 +1963,31 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_Error                 err;
     uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
-    t_FmIpcPortInInitParams portInParams;
-    t_FmIpcPhysAddr         ipcPhysAddr;
-    t_Error                 err;
-    t_FmIpcMsg              msg;
-    t_FmIpcReply            reply;
-    uint32_t                replyLength;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-        portInParams.hardwarePortId = p_PortParams->hardwarePortId;
-        portInParams.enumPortType = (uint32_t)p_PortParams->portType;
-        portInParams.boolIndependentMode = (uint8_t)p_PortParams->independentMode;
-        portInParams.liodnOffset = p_PortParams->liodnOffset;
-        portInParams.numOfTasks = p_PortParams->numOfTasks;
-        portInParams.numOfExtraTasks = p_PortParams->numOfExtraTasks;
-        portInParams.numOfOpenDmas = p_PortParams->numOfOpenDmas;
+        t_FmIpcPortInInitParams portInParams;
+        t_FmIpcPhysAddr         ipcPhysAddr;
+        t_FmIpcMsg              msg;
+        t_FmIpcReply            reply;
+        uint32_t                replyLength;
+
+        portInParams.hardwarePortId     = p_PortParams->hardwarePortId;
+        portInParams.enumPortType       = (uint32_t)p_PortParams->portType;
+        portInParams.boolIndependentMode= (uint8_t)p_PortParams->independentMode;
+        portInParams.liodnOffset        = p_PortParams->liodnOffset;
+        portInParams.numOfTasks         = p_PortParams->numOfTasks;
+        portInParams.numOfExtraTasks    = p_PortParams->numOfExtraTasks;
+        portInParams.numOfOpenDmas      = p_PortParams->numOfOpenDmas;
         portInParams.numOfExtraOpenDmas = p_PortParams->numOfExtraOpenDmas;
-        portInParams.sizeOfFifo = p_PortParams->sizeOfFifo;
-        portInParams.extraSizeOfFifo = p_PortParams->extraSizeOfFifo;
-        portInParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
-        portInParams.liodnBase = p_PortParams->liodnBase;
+        portInParams.sizeOfFifo         = p_PortParams->sizeOfFifo;
+        portInParams.extraSizeOfFifo    = p_PortParams->extraSizeOfFifo;
+        portInParams.deqPipelineDepth   = p_PortParams->deqPipelineDepth;
+        portInParams.liodnBase          = p_PortParams->liodnBase;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_SET_PORT_PARAMS;
@@ -1894,19 +2011,19 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
-    if(p_PortParams->independentMode)
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    if (p_PortParams->independentMode)
     {
         /* set port parameters */
         p_Fm->independentMode = p_PortParams->independentMode;
         /* disable dispatch limit */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, 0);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, 0);
     }
 
-    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
-        if(p_Fm->hcPortInitialized)
+        if (p_Fm->hcPortInitialized)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
@@ -1917,16 +2034,17 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
-    if(err)
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
+       (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
         uint8_t     enqTh;
@@ -1938,7 +2056,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
         enqTh = (uint8_t)(tmpReg>>8);
         /* if enqTh is too big, we reduce it to the max value that is still OK */
-        if(enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums))
+        if (enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums))
         {
             enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums - 1);
             tmpReg &= ~QMI_CFG_ENQ_MASK;
@@ -1949,21 +2067,21 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         deqTh = (uint8_t)tmpReg;
         /* if deqTh is too small, we enlarge it to the min value that is still OK.
          deqTh may not be larger than 63 (QMI_MAX_NUM_OF_TNUMS-1). */
-        if((deqTh <= p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
+        if ((deqTh <= p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
         {
             deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
             tmpReg &= ~QMI_CFG_DEQ_MASK;
             tmpReg |= (uint32_t)deqTh;
             update = TRUE;
         }
-        if(update)
+        if (update)
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
 
 #ifdef FM_LOW_END_RESTRICTION
-    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+    if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
     {
-        if(p_Fm->p_FmStateStruct->lowEndRestriction)
+        if (p_Fm->p_FmStateStruct->lowEndRestriction)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
@@ -1974,31 +2092,35 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 #endif /* FM_LOW_END_RESTRICTION */
 
     err = FmSetSizeOfFifo(p_Fm,
-                            p_PortParams->hardwarePortId,
-                            p_PortParams->sizeOfFifo,
-                            p_PortParams->extraSizeOfFifo,
-                            TRUE);
-    if(err)
+                          p_PortParams->hardwarePortId,
+                          p_PortParams->sizeOfFifo,
+                          p_PortParams->extraSizeOfFifo,
+                          TRUE);
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = FmSetNumOfOpenDmas(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfOpenDmas, p_PortParams->numOfExtraOpenDmas, TRUE);
-    if(err)
+    err = FmSetNumOfOpenDmas(p_Fm,
+                             p_PortParams->hardwarePortId,
+                             p_PortParams->numOfOpenDmas,
+                             p_PortParams->numOfExtraOpenDmas,
+                             TRUE);
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], (uint32_t)p_PortParams->liodnOffset);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], (uint32_t)p_PortParams->liodnOffset);
 
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-        if(p_PortParams->independentMode)
+        if (p_PortParams->independentMode)
         {
-            if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
+            if ((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
@@ -2008,29 +2130,27 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
 
             /* order restoration */
-            if(hardwarePortId%2)
+            if (hardwarePortId%2)
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
         }
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
     }
 
+    /* set LIODN base for this port */
+    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
+    if (hardwarePortId%2)
     {
-        /* set LIODN base for this port */
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
-        if(hardwarePortId%2)
-        {
-            tmpReg &= ~FM_LIODN_BASE_MASK;
-            tmpReg |= (uint32_t)p_PortParams->liodnBase;
-        }
-        else
-        {
-            tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
-            tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
-        }
-        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+        tmpReg &= ~FM_LIODN_BASE_MASK;
+        tmpReg |= (uint32_t)p_PortParams->liodnBase;
+    }
+    else
+    {
+        tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
+        tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
     }
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -2069,8 +2189,8 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
@@ -2092,10 +2212,15 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -=
         (((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
 
-    /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
-    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
-    tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+#ifdef FM_HAS_TOTAL_DMAS
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    {
+        /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+    }
+#endif /* FM_HAS_TOTAL_DMAS */
 
     /* free sizeOfFifo */
     tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
@@ -2107,10 +2232,10 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     /* clear registers */
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], 0);
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
-    /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0); */
+    /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], 0); */
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
         (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
@@ -2154,20 +2279,23 @@ t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled
     t_FmIpcReply    reply;
     uint32_t        replyLength;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_IS_PORT_STALLED;
         msg.msgBody[0] = hardwarePortId;
         replyLength = sizeof(uint32_t) + sizeof(uint8_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(hardwarePortId),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(hardwarePortId),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
@@ -2176,6 +2304,9 @@ t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled
 
         return (t_Error)(reply.error);
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
     tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
     *p_IsStalled = (bool)!!(tmpReg & FPM_PS_STALLED);
@@ -2189,39 +2320,49 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
     uint32_t        tmpReg;
     t_Error         err;
     bool            isStalled;
-    t_FmIpcMsg      msg;
-    t_FmIpcReply    reply;
-    uint32_t        replyLength;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_FmIpcMsg      msg;
+        t_FmIpcReply    reply;
+        uint32_t        replyLength;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_RESUME_STALLED_PORT;
         msg.msgBody[0] = hardwarePortId;
         replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(hardwarePortId),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(hardwarePortId),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
         if (replyLength != sizeof(uint32_t))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Not available for this FM revision!"));
 
     /* Get port status */
     err = FmIsPortStalled(h_Fm, hardwarePortId, &isStalled);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't get port status"));
     if (!isStalled)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is not stalled"));
+        return E_OK;
 
     tmpReg = (uint32_t)((hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT) | FPM_PRC_REALSE_STALLED);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
 
     return E_OK;
 }
@@ -2230,46 +2371,51 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     uint32_t            bitMask, timeout = 1000;
-    t_FmIpcMacParams    macParams;
-    t_Error             err;
-    t_FmIpcMsg          msg;
-    t_FmIpcReply        reply;
-    uint32_t            replyLength;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+#if (DPAA_VERSION >= 11)
+    return E_OK;
+#endif /*(DPAA_VERSION >= 11)*/
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
-        if(p_Fm->h_IpcSessions[0])
-        {
-            memset(&msg, 0, sizeof(msg));
-            memset(&reply, 0, sizeof(reply));
-            macParams.id = macId;
-            macParams.enumType = (uint32_t)type;
-            msg.msgId = FM_RESET_MAC;
-            memcpy(msg.msgBody,  &macParams, sizeof(macParams));
-            replyLength = sizeof(uint32_t);
-            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId)+sizeof(macParams),
-                                         (uint8_t*)&reply,
-                                         &replyLength,
-                                         NULL,
-                                         NULL)) != E_OK)
-                RETURN_ERROR(MINOR, err, NO_MSG);
-            if (replyLength != sizeof(uint32_t))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            return (t_Error)(reply.error);
-        }
-        else
-            if(!p_Fm->p_FmFpmRegs)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("No IPC and no registers address"));
+        t_FmIpcMacParams    macParams;
+        t_Error             err;
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        macParams.id = macId;
+        macParams.enumType = (uint32_t)type;
+        msg.msgId = FM_RESET_MAC;
+        memcpy(msg.msgBody,  &macParams, sizeof(macParams));
+        replyLength = sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(macParams),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
     /* Get the relevant bit mask */
     if (type == e_FM_MAC_10G)
     {
         switch(macId)
         {
-            case(0):
+            case (0):
                 bitMask = FPM_RSTC_10G0_RESET;
                 break;
             default:
@@ -2280,19 +2426,19 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     {
         switch(macId)
         {
-            case(0):
+            case (0):
                 bitMask = FPM_RSTC_1G0_RESET;
                 break;
-            case(1):
+            case (1):
                 bitMask = FPM_RSTC_1G1_RESET;
                 break;
-            case(2):
+            case (2):
                 bitMask = FPM_RSTC_1G2_RESET;
                 break;
-            case(3):
+            case (3):
                 bitMask = FPM_RSTC_1G3_RESET;
                 break;
-            case(4):
+            case (4):
                 bitMask = FPM_RSTC_1G4_RESET;
                 break;
             default:
@@ -2301,8 +2447,8 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     }
 
     /* reset */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, bitMask);
-    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fmrstc) & bitMask) &&
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, bitMask);
+    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fm_rstc) & bitMask) &&
            --timeout) ;
     if (!timeout)
         return ERROR_CODE(E_TIMEOUT);
@@ -2312,28 +2458,34 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu)
 {
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
-    t_FmIpcMacMaxFrameParams    macMaxFrameLengthParams;
-    t_Error                     err;
-    t_FmIpcMsg                  msg;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_FmIpcMacMaxFrameParams    macMaxFrameLengthParams;
+        t_Error                     err;
+        t_FmIpcMsg                  msg;
+
         memset(&msg, 0, sizeof(msg));
         macMaxFrameLengthParams.macParams.id = macId;
         macMaxFrameLengthParams.macParams.enumType = (uint32_t)type;
         macMaxFrameLengthParams.maxFrameLength = (uint16_t)mtu;
         msg.msgId = FM_SET_MAC_MAX_FRAME;
         memcpy(msg.msgBody,  &macMaxFrameLengthParams, sizeof(macMaxFrameLengthParams));
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(macMaxFrameLengthParams),
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(macMaxFrameLengthParams),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         return E_OK;
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
 
 #if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
     if (type == e_FM_MAC_10G)
@@ -2350,7 +2502,8 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
 uint16_t FmGetClockFreq(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
-    /* for MC environment: this depends on the
+
+    /* for multicore environment: this depends on the
      * fact that fmClkFreq was properly initialized at "init". */
     return p_Fm->p_FmStateStruct->fmClkFreq;
 }
@@ -2358,13 +2511,16 @@ uint16_t FmGetClockFreq(t_Handle h_Fm)
 uint32_t FmGetTimeStampScale(t_Handle h_Fm)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_Error             err;
-    t_FmIpcMsg          msg;
-    t_FmIpcReply        reply;
-    uint32_t            replyLength, timeStamp;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error             err;
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength, timeStamp;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_TIMESTAMP_SCALE;
@@ -2377,31 +2533,26 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
         memcpy((uint8_t*)&timeStamp, reply.replyBody, sizeof(uint32_t));
         return timeStamp;
     }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr)
+    {
+        if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc1) & FPM_TS_CTL_EN))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("timestamp is not enabled!"));
 
-    if(!p_Fm->p_FmStateStruct->enabledTimeStamp)
-        FmEnableTimeStamp(p_Fm);
+        return p_Fm->p_FmStateStruct->count1MicroBit;
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        DBG(WARNING, ("No Ipc - can't validate FM if timestamp enabled."));
 
     return p_Fm->p_FmStateStruct->count1MicroBit;
 }
 
-bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
-{
-    t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    tmpReg;
-
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-        return TRUE;
-    else
-        return FALSE;
-}
-
 t_Error FmEnableRamsEcc(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -2423,11 +2574,12 @@ t_Error FmDisableRamsEcc(t_Handle h_Fm)
     ASSERT_COND(p_Fm->p_FmStateStruct->ramsEccOwners);
     p_Fm->p_FmStateStruct->ramsEccOwners--;
 
-    if(p_Fm->p_FmStateStruct->ramsEccOwners==0)
+    if (p_Fm->p_FmStateStruct->ramsEccOwners==0)
     {
         p_Fm->p_FmStateStruct->internalCall = TRUE;
         return FM_DisableRamsEcc(p_Fm);
     }
+
     return E_OK;
 }
 
@@ -2452,14 +2604,16 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
                         bool        initialConfig)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint16_t                oldVal;
     t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
     uint32_t                tmpReg = 0;
+    uint16_t                oldVal = 0;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
         t_FmIpcMsg          msg;
         t_FmIpcReply        reply;
@@ -2487,36 +2641,44 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr)
+    {
+        DBG(WARNING, ("No Ipc - can't validate FM total-fifo size."));
 
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+        tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
+                            ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if(initialConfig)
-        oldVal = 0;
-    else
+    if (!initialConfig)
     {
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
         /* read into oldVal the current extra fifo size */
-        oldVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
+        oldVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
     }
 
-    if(extraSizeOfFifo > oldVal)
+    if (extraSizeOfFifo > oldVal)
     {
-        if(extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
+        if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
             /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
              * must be initialized to 1 buffer per port
              */
-            p_Fm->p_FmStateStruct->extraFifoPoolSize    = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+            p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
         p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
     }
 
-    if(!initialConfig)
+    if (!initialConfig)
         /* read into oldVal the current num of tasks */
-        oldVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS);
+        oldVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
 
     /* check that there are enough uncommitted fifo size */
-    if((p_Fm->p_FmStateStruct->accumulatedFifoSize - oldVal + sizeOfFifo) >
-       (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
+    if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - oldVal + sizeOfFifo) >
+        (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
     else
     {
@@ -2540,16 +2702,20 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
                         bool        initialConfig)
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint8_t                 oldVal;
-    uint32_t                tmpReg = 0;
-    t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
+    uint32_t                tmpReg = 0;
+    uint8_t                 oldVal = 0;
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
-        t_FmIpcMsg          msg;
-        t_FmIpcReply        reply;
-        uint32_t            replyLength;
+        t_FmIpcPortRsrcParams   rsrcParams;
+        t_FmIpcMsg              msg;
+        t_FmIpcReply            reply;
+        uint32_t                replyLength;
 
         rsrcParams.hardwarePortId = hardwarePortId;
         rsrcParams.val = numOfTasks;
@@ -2573,27 +2739,38 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr)
+    {
+        DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
 
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+        /* calculate reg */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
+        tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                    (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if(initialConfig)
-        oldVal = 0;
-    else
+    if (!initialConfig)
     {
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
         /* read into oldVal the current extra tasks */
         oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
     }
 
-    if(numOfExtraTasks > oldVal)
-        p_Fm->p_FmStateStruct->extraTasksPoolSize = (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+    if (numOfExtraTasks > oldVal)
+        p_Fm->p_FmStateStruct->extraTasksPoolSize =
+            (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
 
-    if(!initialConfig)
+    if (!initialConfig)
         /* read into oldVal the current num of tasks */
         oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
 
     /* check that there are enough uncommitted tasks */
-    if((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - oldVal + numOfTasks) >
+    if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - oldVal + numOfTasks) >
        (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                      ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
@@ -2622,16 +2799,20 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint8_t                 oldVal;
+    uint8_t                 oldVal = 0;
     uint32_t                tmpReg = 0;
-    t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
-        t_FmIpcMsg          msg;
-        t_FmIpcReply        reply;
-        uint32_t            replyLength;
+        t_FmIpcPortRsrcParams   rsrcParams;
+        t_FmIpcMsg              msg;
+        t_FmIpcReply            reply;
+        uint32_t                replyLength;
 
         rsrcParams.hardwarePortId = hardwarePortId;
         rsrcParams.val = numOfOpenDmas;
@@ -2655,20 +2836,38 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
+#ifdef FM_HAS_TOTAL_DMAS
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
+#else
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr &&
+             (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
+    {
+        /*DBG(WARNING, ("No Ipc - can't validate FM total-num-of-dmas."));*/
 
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+        /* calculate reg */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
+        tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                    (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+#endif /* FM_HAS_TOTAL_DMAS */
 
-    if(initialConfig)
-        oldVal = 0;
-    else
+    if (!initialConfig)
     {
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
         /* read into oldVal the current extra tasks */
         oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
     }
 
-    if(numOfExtraOpenDmas > oldVal)
-        p_Fm->p_FmStateStruct->extraOpenDmasPoolSize = (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
+    if (numOfExtraOpenDmas > oldVal)
+        p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
+            (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
 
     if (!initialConfig)
         /* read into oldVal the current num of tasks */
@@ -2676,20 +2875,20 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 
     /* check that there are enough uncommitted open DMA's */
     ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= oldVal);
-#ifndef FM_NO_TOTAL_DMAS
+#ifdef FM_HAS_TOTAL_DMAS
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
         (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas >
             p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                          ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
                          p_Fm->p_FmStateStruct->fmId));
-#else /* FM_NO_TOTAL_DMAS */
+#else
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
-        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ+1))
+        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ + 1))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                      ("Requested numOfOpenDmas for fm%d exceeds DMA Command queue (%d)",
                       p_Fm->p_FmStateStruct->fmId, DMA_THRESH_MAX_COMMQ+1));
-#endif /* FM_NO_TOTAL_DMAS */
+#endif /* FM_HAS_TOTAL_DMAS */
     else
     {
         /* update acummulated */
@@ -2702,23 +2901,25 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
                     (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
 
-
-        /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
-        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+#ifdef FM_HAS_TOTAL_DMAS
+        if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+        {
+            /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+            tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+        }
+#endif /* FM_HAS_TOTAL_DMAS */
     }
 
     return E_OK;
 }
 
 #if (DPAA_VERSION >= 11)
-
-t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
+t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
                                   e_FmPortType    portType,
                                   uint8_t         portId,
-                                  uint16_t        relativeProfile,
-                                  uint16_t        *p_AbsoluteId)
+                                  uint16_t        relativeProfile)
 {
     t_Fm         *p_Fm;
     t_FmSp      *p_FmPcdSp;
@@ -2735,130 +2936,561 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     ASSERT_COND(p_FmPcdSp);
 
     if (!p_FmPcdSp->portsMapping[swPortIndex].numOfProfiles)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Port has no allocated profiles"));
     if (relativeProfile >= p_FmPcdSp->portsMapping[swPortIndex].numOfProfiles)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
-    *p_AbsoluteId = (uint16_t)(p_FmPcdSp->portsMapping[swPortIndex].profilesBase + relativeProfile);
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE , ("Profile id is out of range"));
 
     return E_OK;
 }
 
-void VspInvalidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
-{
-    t_Fm     *p_Fm = (t_Fm*)h_Fm;
-
-    ASSERT_COND(p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
-    p_Fm->p_FmSp->profiles[absoluteProfileId].valid = FALSE;
-}
-
-void VspValidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
-{
-    t_Fm     *p_Fm = (t_Fm*)h_Fm;
-
-    ASSERT_COND(!p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
-    p_Fm->p_FmSp->profiles[absoluteProfileId].valid = TRUE;
-}
-#endif /*(DPAA_VERSION >= 11)*/
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint16_t        relativeProfile,
+                                  uint16_t        *p_AbsoluteId)
 {
-    t_Fm            *p_Fm = (t_Fm *)h_Fm;
-    t_FmIpcMsg      msg;
-    t_Error         err;
-
-    DECLARE_DUMP;
+    t_Fm         *p_Fm;
+    t_FmSp      *p_FmPcdSp;
+    uint8_t     swPortIndex=0, hardwarePortId;
+    t_Error     err;
 
-    if (p_Fm->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_DUMP_PORT_REGS;
-        msg.msgBody[0] = hardwarePortId;
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                    (uint8_t*)&msg,
-                                    sizeof(msg.msgId)+sizeof(hardwarePortId),
-                                    NULL,
-                                    NULL,
-                                    NULL,
-                                    NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        return E_OK;
-    }
+    ASSERT_COND(h_Fm);
+    p_Fm = (t_Fm*)h_Fm;
 
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    err = FmVSPCheckRelativeProfile(h_Fm, portType, portId, relativeProfile);
+    if (err != E_OK)
+        return err;
 
-    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], ("fmbm_pp for port %u", (hardwarePortId)));
-    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], sizeof(uint32_t));
+    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    ASSERT_COND(hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %u", (hardwarePortId )));
-    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
+    p_FmPcdSp = p_Fm->p_FmSp;
+    ASSERT_COND(p_FmPcdSp);
 
-    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], ("bm_ppid for port %u", (hardwarePortId)));
-    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], sizeof(uint32_t));
+    *p_AbsoluteId = (uint16_t)(p_FmPcdSp->portsMapping[swPortIndex].profilesBase + relativeProfile);
 
     return E_OK;
 }
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
-
+#endif /* (DPAA_VERSION >= 11) */
 
-/*****************************************************************************/
-/*                      API Init unit functions                              */
-/*****************************************************************************/
-t_Handle FM_Config(t_FmParams *p_FmParam)
+static t_Error InitFmDma(t_Fm *p_Fm)
 {
-    t_Fm                *p_Fm;
-    uint8_t             i;
-    uintptr_t           baseAddr;
+    t_FmDriverParam         *p_FmDriverParam = NULL;
+    uint32_t                tmpReg;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
-    SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
-                               (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
-                              E_INVALID_VALUE, NULL);
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmDriverParam);
 
-    baseAddr = p_FmParam->baseAddr;
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
 
-    /* Allocate FM structure */
-    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
-    if (!p_Fm)
+    /* clear status reg events */
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        tmpReg = DMA_STATUS_FM_SPDAT_ECC;
+    else
+        tmpReg = DMA_STATUS_FM_ECC;
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
+
+    /* configure mode register */
+    tmpReg = 0;
+    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
+    if (p_FmDriverParam->dmaAidOverride)
+        tmpReg |= DMA_MODE_AID_OR;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
+        tmpReg |= DMA_MODE_BER;
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
-        return NULL;
+        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
+            tmpReg |= DMA_MODE_ECC;
     }
-    memset(p_Fm, 0, sizeof(t_Fm));
-
-    p_Fm->p_FmStateStruct = (t_FmStateStruct *) XX_Malloc(sizeof(t_FmStateStruct));
-    if (!p_Fm->p_FmStateStruct)
+    else
     {
-        XX_Free(p_Fm);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Status structure"));
-        return NULL;
+        if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+            tmpReg |= DMA_MODE_ECC;
     }
-    memset(p_Fm->p_FmStateStruct, 0, sizeof(t_FmStateStruct));
-
-    /* Initialize FM parameters which will be kept by the driver */
-    p_Fm->p_FmStateStruct->fmId = p_FmParam->fmId;
-    p_Fm->guestId               = p_FmParam->guestId;
 
-    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
-        p_Fm->p_FmStateStruct->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
-
-    /* Allocate the FM driver's parameters structure */
-    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
-    if (!p_Fm->p_FmDriverParam)
+    if (p_FmDriverParam->dmaStopOnBusError)
+        tmpReg |= DMA_MODE_SBER;
+    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
+    if (p_FmDriverParam->dmaEnEmergency)
     {
-        XX_Free(p_Fm->p_FmStateStruct);
-        XX_Free(p_Fm);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
-        return NULL;
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
+        if (p_FmDriverParam->dmaEnEmergencySmoother)
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
     }
-    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
 
-    /* Initialize FM parameters which will be kept by the driver */
-    p_Fm->p_FmStateStruct->fmId                 = p_FmParam->fmId;
-    p_Fm->h_FmMuram                             = p_FmParam->h_FmMuram;
-    p_Fm->h_App                                 = p_FmParam->h_App;
-    p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
-    p_Fm->f_Exception                           = p_FmParam->f_Exception;
+    tmpReg |= DMA_MODE_SECURE_PROT;
+    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
+
+#ifdef FM_PEDANTIC_DMA
+    tmpReg |= DMA_MODE_EMERGENCY_READ;
+#endif /* FM_PEDANTIC_DMA */
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+
+    /* configure thresholds register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
+
+    /* configure hysteresis register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
+
+    /* configure emergency threshold */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
+
+    /* configure Watchdog */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq));
+
+    /* Allocate MURAM for CAM */
+    p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                      (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
+                                                      DMA_CAM_ALIGN));
+    if (!p_Fm->camBaseAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+    WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
+                0,
+                (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 2)
+    {
+        FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
+
+        p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                          (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
+                                                          64));
+        if (!p_Fm->camBaseAddr)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+        WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
+                   0,
+                   (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
+
+        switch(p_FmDriverParam->dmaCamNumOfEntries)
+        {
+            case (8):
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
+                break;
+            case (16):
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffff0000);
+                break;
+            case (24):
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffff00);
+                break;
+            case (32):
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffffff);
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
+        }
+    }
+
+    /* VirtToPhys */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
+                 (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
+
+    return E_OK;
+}
+
+static t_Error InitFmFpm(t_Fm *p_Fm)
+{
+    t_FmDriverParam         *p_FmDriverParam = NULL;
+    uint32_t                tmpReg;
+    int                     i;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmDriverParam);
+
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
+
+    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis1, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis2, tmpReg);
+
+    /* define exceptions and error behavior */
+    tmpReg = 0;
+    /* Clear events */
+    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
+    /* enable interrupts */
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_STALL_ON_TASKS)
+        tmpReg |= FPM_EV_MASK_STALL_EN;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_SINGLE_ECC)
+        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_DOUBLE_ECC)
+        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
+    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
+    if (!p_Fm->p_FmDriverParam->haltOnExternalActivation)
+        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
+    if (!p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
+        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
+
+    /* clear all fmCtls event registers */
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[i], 0xFFFFFFFF);
+
+    /* RAM ECC -  enable and clear events */
+    /* first we need to clear all parser memory, as it is uninitialized and
+       may cause ECC errors
+     */
+    tmpReg = 0;
+    /* event bits */
+    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
+    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
+    if (p_Fm->p_FmDriverParam->externalEccRamsEnable)
+        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
+
+    /* enable test mode */
+    if (p_FmDriverParam->enMuramTestMode)
+        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
+    if (p_FmDriverParam->enIramTestMode)
+        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg);
+
+    tmpReg = 0;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_IRAM_ECC)
+    {
+        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_MURAM_ECC)
+    {
+        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
+
+    return E_OK;
+}
+
+static t_Error InitFmBmi(t_Fm *p_Fm)
+{
+    uint32_t                tmpReg;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmDriverParam);
+
+    tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = tmpReg / BMI_FIFO_ALIGN;
+
+    tmpReg |= ((p_Fm->p_FmStateStruct->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
+
+    tmpReg =  ((uint32_t)(p_Fm->p_FmStateStruct->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT);
+#ifdef FM_HAS_TOTAL_DMAS
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->maxNumOfOpenDmas - 1) << BMI_CFG2_DMAS_SHIFT;
+#endif /* FM_HAS_TOTAL_DMAS */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+
+    /* define unmaskable exceptions, enable and clear events */
+    tmpReg = 0;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
+                                                BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC |
+                                                BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
+                                                BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+
+    return E_OK;
+}
+
+static t_Error InitFmQmi(t_Fm *p_Fm)
+{
+    uint32_t                tmpReg;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmDriverParam);
+
+     /* Clear error interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
+    tmpReg = 0;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
+        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
+        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+
+    if (p_Fm->p_FmDriverParam->tnumAgingPeriod)
+    {
+        uint16_t                periodInFmClocks;
+        uint8_t                 remainder;
+
+        /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
+        periodInFmClocks = (uint16_t)(p_Fm->p_FmDriverParam->tnumAgingPeriod*p_Fm->p_FmStateStruct->fmClkFreq);
+        /* periodInFmClocks must be a 64 multiply */
+        remainder = (uint8_t)(periodInFmClocks % 64);
+        if (remainder > 64)
+            tmpReg = (uint32_t)((periodInFmClocks/64) + 1);
+        else
+        {
+            tmpReg = (uint32_t)(periodInFmClocks/64);
+            if (!tmpReg)
+                tmpReg = 1;
+        }
+        tmpReg <<= QMI_TAPC_TAP;
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_tapc, tmpReg);
+
+    }
+
+    tmpReg = 0;
+    /* Clear interrupt events */
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+    {
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
+        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
+            tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+        /* enable events */
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+    }
+
+    return E_OK;
+}
+
+static t_Error InitGuestMode(t_Fm *p_Fm)
+{
+    t_Error                 err = E_OK;
+    int                     i;
+    t_FmIpcMsg              msg;
+    t_FmIpcReply            reply;
+    uint32_t                replyLength;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->guestId != NCSW_MASTER_ID);
+
+    /* build the FM guest partition IPC address */
+    if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, p_Fm->guestId) != (p_Fm->guestId<10 ? 6:7))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+    /* build the FM master partition IPC address */
+    memset(p_Fm->fmIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+    if (Sprint (p_Fm->fmIpcHandlerModuleName[0], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+        p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+
+    p_Fm->h_IpcSessions[0] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[0], p_Fm->fmModuleName);
+    if (p_Fm->h_IpcSessions[0])
+    {
+        uint8_t                 isMasterAlive;
+        t_FmIpcParams           ipcParams;
+
+        err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmGuestHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_MASTER_IS_ALIVE;
+        msg.msgBody[0] = p_Fm->guestId;
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        do
+        {
+            blockingFlag = TRUE;
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                         (uint8_t*)&msg,
+                                         sizeof(msg.msgId)+sizeof(p_Fm->guestId),
+                                         (uint8_t*)&reply,
+                                         &replyLength,
+                                         IpcMsgCompletionCB,
+                                         p_Fm)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            while(blockingFlag) ;
+            if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            isMasterAlive = *(uint8_t*)(reply.replyBody);
+        } while (!isMasterAlive);
+
+        /* read FM parameters and save */
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_PARAMS;
+        replyLength = sizeof(uint32_t) + sizeof(t_FmIpcParams);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
+
+        p_Fm->p_FmStateStruct->fmClkFreq = ipcParams.fmClkFreq;
+        p_Fm->p_FmStateStruct->revInfo.majorRev = ipcParams.majorRev;
+        p_Fm->p_FmStateStruct->revInfo.minorRev = ipcParams.minorRev;
+    }
+    else
+    {
+        uint32_t    tmpReg;
+
+        DBG(WARNING, ("FM Guest mode - without IPC"));
+        if (!p_Fm->p_FmStateStruct->fmClkFreq)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No fmClkFreq configured for guest without IPC"));
+        if (p_Fm->baseAddr)
+        {
+            /* read revision register 1 */
+            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+            p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+            p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+        }
+    }
+
+#if (DPAA_VERSION >= 11)
+    p_Fm->partVSPBase = AllocVSPsForPartition(p_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
+    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+        DBG(WARNING, ("partition VSPs allocation is FAILED"));
+#endif /* (DPAA_VERSION >= 11) */
+
+    /* General FM driver initialization */
+    if (p_Fm->baseAddr)
+        p_Fm->fmMuramPhysBaseAddr =
+            (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
+
+    XX_Free(p_Fm->p_FmDriverParam);
+    p_Fm->p_FmDriverParam = NULL;
+
+    if ((p_Fm->guestId == NCSW_MASTER_ID) ||
+        (p_Fm->h_IpcSessions[0]))
+    {
+        FM_DisableRamsEcc(p_Fm);
+        FmMuramClear(p_Fm->h_FmMuram);
+        FM_EnableRamsEcc(p_Fm);
+    }
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Fm->guestId == NCSW_MASTER_ID) ||
+                               p_Fm->baseAddr), E_INVALID_OPERATION);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], ("fmbm_pp for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %u", (hardwarePortId )));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], ("bm_ppid for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], sizeof(uint32_t));
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+
+/*****************************************************************************/
+/*                      API Init unit functions                              */
+/*****************************************************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm                *p_Fm;
+    uint8_t             i;
+    uintptr_t           baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
+    SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
+                               (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
+                              E_INVALID_VALUE, NULL);
+
+    baseAddr = p_FmParam->baseAddr;
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    p_Fm->p_FmStateStruct = (t_FmStateStruct *) XX_Malloc(sizeof(t_FmStateStruct));
+    if (!p_Fm->p_FmStateStruct)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Status structure"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmStateStruct, 0, sizeof(t_FmStateStruct));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->p_FmStateStruct->fmId = p_FmParam->fmId;
+    p_Fm->guestId               = p_FmParam->guestId;
+
+    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
+        p_Fm->p_FmStateStruct->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+
+    /* Allocate the FM driver's parameters structure */
+    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
+    if (!p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm->p_FmStateStruct);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+
+#if (DPAA_VERSION >= 11)
+    p_Fm->p_FmSp = (t_FmSp *)XX_Malloc(sizeof(t_FmSp));
+    if (!p_Fm->p_FmSp)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm->p_FmStateStruct);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("allocation for internal data structure failed"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmSp, 0, sizeof(t_FmSp));
+
+    for (i=0; i<FM_VSP_MAX_NUM_OF_ENTRIES; i++)
+        p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
+#endif /* (DPAA_VERSION >= 11) */
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->p_FmStateStruct->fmId                 = p_FmParam->fmId;
+    p_Fm->h_FmMuram                             = p_FmParam->h_FmMuram;
+    p_Fm->h_App                                 = p_FmParam->h_App;
+    p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
+    p_Fm->f_Exception                           = p_FmParam->f_Exception;
     p_Fm->f_BusError                            = p_FmParam->f_BusError;
     p_Fm->p_FmFpmRegs                           = (t_FmFpmRegs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
     p_Fm->p_FmBmiRegs                           = (t_FmBmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
@@ -2959,7 +3591,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->partVSPBase   = p_FmParam->partVSPBase;
     p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
     p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
     return p_Fm;
 }
@@ -2980,153 +3612,15 @@ t_Error FM_Init(t_Handle h_Fm)
     t_Error                 err = E_OK;
     uint32_t                tmpReg, cfgReg = 0;
     int                     i;
-    uint16_t                periodInFmClocks;
-    uint8_t                 remainder;
-
-    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
-
-#if (DPAA_VERSION >= 11)
-    p_Fm->p_FmSp = (t_FmSp*)XX_Malloc(sizeof(t_FmSp));
-    if (!p_Fm->p_FmSp)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation for internal data structure failed"));
-
-    memset(p_Fm->p_FmSp, 0, sizeof(t_FmSp));
-    for (i = 0; i < FM_VSP_MAX_NUM_OF_ENTRIES; i++)
-        p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
-#endif /*(DPAA_VERSION >= 11)*/
-
-    if (p_Fm->guestId != NCSW_MASTER_ID)
-    {
-        uint8_t             isMasterAlive;
-        t_FmIpcMsg          msg;
-        t_FmIpcReply        reply;
-        uint32_t            replyLength;
-        t_FmIpcParams       ipcParams;
-
-        /* build the FM guest partition IPC address */
-        if(Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, p_Fm->guestId) != (p_Fm->guestId<10 ? 6:7))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-
-        /* build the FM master partition IPC address */
-        memset(p_Fm->fmIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if(Sprint (p_Fm->fmIpcHandlerModuleName[0], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-
-        for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
-            p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
-
-        p_Fm->h_IpcSessions[0] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[0], p_Fm->fmModuleName);
-        if (p_Fm->h_IpcSessions[0])
-        {
-            err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmGuestHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-            if(err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-
-            memset(&msg, 0, sizeof(msg));
-            memset(&reply, 0, sizeof(reply));
-            msg.msgId = FM_MASTER_IS_ALIVE;
-            msg.msgBody[0] = p_Fm->guestId;
-            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
-            do
-            {
-                blockingFlag = TRUE;
-                if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                             (uint8_t*)&msg,
-                                             sizeof(msg.msgId)+sizeof(p_Fm->guestId),
-                                             (uint8_t*)&reply,
-                                             &replyLength,
-                                             IpcMsgCompletionCB,
-                                             h_Fm)) != E_OK)
-                    REPORT_ERROR(MINOR, err, NO_MSG);
-                while(blockingFlag) ;
-                if(replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
-                    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-                isMasterAlive = *(uint8_t*)(reply.replyBody);
-            } while (!isMasterAlive);
-
-            /* read FM parameters and save */
-            memset(&msg, 0, sizeof(msg));
-            memset(&reply, 0, sizeof(reply));
-            msg.msgId = FM_GET_PARAMS;
-            replyLength = sizeof(uint32_t) + sizeof(t_FmIpcParams);
-            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId),
-                                         (uint8_t*)&reply,
-                                         &replyLength,
-                                         NULL,
-                                         NULL)) != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            if(replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
-
-            p_Fm->p_FmStateStruct->fmClkFreq = ipcParams.fmClkFreq;
-            p_Fm->p_FmStateStruct->revInfo.majorRev = ipcParams.majorRev;
-            p_Fm->p_FmStateStruct->revInfo.minorRev = ipcParams.minorRev;
-
-        }
-        else
-        {
-            DBG(WARNING, ("FM Guest mode - without IPC"));
-            if (!p_Fm->p_FmStateStruct->fmClkFreq )
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No fmClkFreq configured for guest without IPC"));
-            if (!p_Fm->baseAddr)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
-        }
-
-#if (DPAA_VERSION >= 11)
-        if (p_Fm->h_IpcSessions[p_Fm->guestId])
-        {
-            t_FmIpcVspAllocParams   fmIpcVspAllocParams;
-
-            memset(&msg, 0, sizeof(msg));
-            memset(&reply, 0, sizeof(reply));
-            memset(&fmIpcVspAllocParams, 0, sizeof(t_FmIpcVspAllocParams));
-            fmIpcVspAllocParams.guestId         = p_Fm->guestId;
-            fmIpcVspAllocParams.numOfProfiles   = p_Fm->partNumOfVSPs;
-            fmIpcVspAllocParams.base            = p_Fm->partVSPBase;
-            msg.msgId                           = FM_VSP_ALLOC;
-            memcpy(msg.msgBody, &fmIpcVspAllocParams, sizeof(t_FmIpcVspAllocParams));
-            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
-            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                             (uint8_t*)&msg,
-                                             sizeof(msg.msgId) + sizeof(t_FmIpcVspAllocParams),
-                                             (uint8_t*)&reply,
-                                             &replyLength,
-                                             NULL,
-                                             NULL)) != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-
-            if ((err != E_OK) ||
-                (replyLength != (sizeof(uint32_t) + sizeof(uint8_t))))
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            else
-                memcpy((uint8_t*)&p_Fm->partVSPBase, reply.replyBody, sizeof(uint8_t));
-            if (p_Fm->partVSPBase == ILLEGAL_BASE)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-        else
-            DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
-#endif /*(DPAA_VERSION >= 11)*/
-
-        XX_Free(p_Fm->p_FmDriverParam);
-        p_Fm->p_FmDriverParam = NULL;
-
-        if ((p_Fm->guestId == NCSW_MASTER_ID) ||
-            (p_Fm->h_IpcSessions[0]))
-        {
-            FM_DisableRamsEcc(p_Fm);
-            FmMuramClear(p_Fm->h_FmMuram);
-            FM_EnableRamsEcc(p_Fm);
-        }
-
-        return E_OK;
-    }
-
 
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+    p_Fm->p_FmStateStruct->count1MicroBit = FM_TIMESTAMP_1_USEC_BIT;
+
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+        return InitGuestMode(p_Fm);
+
     /* read revision register 1 */
     tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
     p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
@@ -3135,7 +3629,7 @@ t_Error FM_Init(t_Handle h_Fm)
     /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
      * according to chip. otherwise, we use user's configuration.
      */
-    if(p_Fm->p_FmStateStruct->totalFifoSize == 0)
+    if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
         p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
@@ -3144,7 +3638,8 @@ t_Error FM_Init(t_Handle h_Fm)
 
     /* clear revision-dependent non existing exception */
 #ifdef FM_NO_DISPATCH_RAM_ECC
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
+        (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
         p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
@@ -3186,12 +3681,12 @@ t_Error FM_Init(t_Handle h_Fm)
         XX_UDelay(100);
 
         /* reset FMAN */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
         XX_UDelay(100);
 
         /* verify breakpoint debug status register */
         debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
-        if(!debug_reg)
+        if (!debug_reg)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
 
         /*************************************/
@@ -3205,15 +3700,17 @@ t_Error FM_Init(t_Handle h_Fm)
          XX_UDelay(100);
 
         /* reset FMAN again to start the microcode */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
         XX_UDelay(1000);
     }
     else
     {
 #endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
-    if(p_FmDriverParam->resetOnInit)
+
+    /* Reset the FM if required. */
+    if (p_FmDriverParam->resetOnInit)
     {
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
         XX_UDelay(100);
     }
 
@@ -3239,209 +3736,39 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* FM_CAPWAP_SUPPORT */
 
 #if (DPAA_VERSION >= 11)
-    p_Fm->partVSPBase = FmVSPsAlloc(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
+    p_Fm->partVSPBase = AllocVSPsForPartition(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
     if (p_Fm->partVSPBase == ILLEGAL_BASE)
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
     /* General FM driver initialization */
-    p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
-    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+    p_Fm->fmMuramPhysBaseAddr =
+        (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
+
+    for (i=0;i<e_FM_EV_DUMMY_LAST;i++)
         p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
-    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+    for (i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
         p_Fm->fmanCtrlIntr[i].f_Isr = UnimplementedFmanCtrlIsr;
 
     /**********************/
     /* Init DMA Registers */
     /**********************/
-    /* clear status reg events */
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        tmpReg = DMA_STATUS_FM_SPDAT_ECC;
-    else
-        tmpReg = DMA_STATUS_FM_ECC;
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
-
-    /* configure mode register */
-    tmpReg = 0;
-    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
-    if(p_FmDriverParam->dmaAidOverride)
-        tmpReg |= DMA_MODE_AID_OR;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
-        tmpReg |= DMA_MODE_BER;
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-    {
-        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
-            tmpReg |= DMA_MODE_ECC;
-    }
-    else
-    {
-        if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
-            tmpReg |= DMA_MODE_ECC;
-    }
-    if(p_FmDriverParam->dmaStopOnBusError)
-        tmpReg |= DMA_MODE_SBER;
-    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
-    if (p_FmDriverParam->dmaEnEmergency)
-    {
-        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
-        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
-        if(p_FmDriverParam->dmaEnEmergencySmoother)
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
-     }
-    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
-
-    tmpReg |= DMA_MODE_SECURE_PROT;
-    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
-    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
-
-#ifdef FM_PEDANTIC_DMA
-    tmpReg |= DMA_MODE_EMERGENCY_READ;
-#endif /* FM_PEDANTIC_DMA */
-
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
-
-    /* configure thresholds register */
-    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
-
-    /* configure hysteresis register */
-    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
-
-    /* configure emergency threshold */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
-
-    /* configure Watchdog */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq));
-
-    /* Allocate MURAM for CAM */
-    p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
-                                                      (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
-                                                      DMA_CAM_ALIGN));
-    if (!p_Fm->camBaseAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
-
-    WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
-                0,
-                (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
-
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 2)
+    err = InitFmDma(p_Fm);
+    if (err != E_OK)
     {
-        FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
-
-        p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
-                                                          (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
-                                                          64));
-        if (!p_Fm->camBaseAddr)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
-
-        WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
-                   0,
-                   (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
-
-        switch(p_FmDriverParam->dmaCamNumOfEntries)
-        {
-            case(8):
-                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
-                break;
-            case(16):
-                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffff0000);
-                break;
-            case(24):
-                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffff00);
-                break;
-            case(32):
-                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffffff);
-                break;
-            default:
-                FreeInitResources(p_Fm);
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
-        }
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    /* VirtToPhys */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
-                 (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
-
     /**********************/
     /* Init FPM Registers */
     /**********************/
-    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, tmpReg);
-
-    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis1, tmpReg);
-
-    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis2, tmpReg);
-
-
-    /* define exceptions and error behavior */
-    tmpReg = 0;
-    /* Clear events */
-    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
-    /* enable interrupts */
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_STALL_ON_TASKS)
-        tmpReg |= FPM_EV_MASK_STALL_EN;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_SINGLE_ECC)
-        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_DOUBLE_ECC)
-        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
-    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
-    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
-    if(!p_Fm->p_FmDriverParam->haltOnExternalActivation)
-        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
-    if(!p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
-        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
-
-    /* clear all fmCtls event registers */
-    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
-
-    /* RAM ECC -  enable and clear events*/
-    /* first we need to clear all parser memory, as it is uninitialized and
-    may cause ECC errors */
-    tmpReg = 0;
-    /* event bits */
-    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
-    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
-    if(p_Fm->p_FmDriverParam->externalEccRamsEnable)
-        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
-
-    /* enable test mode */
-    if(p_FmDriverParam->enMuramTestMode)
-        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
-    if(p_FmDriverParam->enIramTestMode)
-        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
-
-    tmpReg = 0;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_IRAM_ECC)
-    {
-        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
-        FmEnableRamsEcc(p_Fm);
-    }
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_MURAM_ECC)
+    err = InitFmFpm(p_Fm);
+    if (err != E_OK)
     {
-        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
-        FmEnableRamsEcc(p_Fm);
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
-
-    /**********************/
-    /* Init BMI Registers */
-    /**********************/
 
     /* define common resources */
     /* allocate MURAM for FIFO according to total size */
@@ -3454,83 +3781,41 @@ t_Error FM_Init(t_Handle h_Fm)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for BMI FIFO failed"));
     }
 
-    tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
-    tmpReg = tmpReg / BMI_FIFO_ALIGN;
-
-    tmpReg |= ((p_Fm->p_FmStateStruct->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
-
-    tmpReg =  ((uint32_t)(p_Fm->p_FmStateStruct->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT );
-    /* num of DMA's will be dynamically updated when each port is set */
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
-
-    /* define unmaskable exceptions, enable and clear events */
-    tmpReg = 0;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
-                                                BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC |
-                                                BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
-                                                BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+    err = InitFmBmi(p_Fm);
+    if (err != E_OK)
+    {
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
     /**********************/
     /* Init QMI Registers */
     /**********************/
-     /* Clear error interrupt events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
-    tmpReg = 0;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
-        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
-        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
-    /* enable events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
-
-    if(p_Fm->p_FmDriverParam->tnumAgingPeriod)
+    err = InitFmQmi(p_Fm);
+    if (err != E_OK)
     {
-        /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
-        periodInFmClocks = (uint16_t)(p_Fm->p_FmDriverParam->tnumAgingPeriod*p_Fm->p_FmStateStruct->fmClkFreq);
-        /* periodInFmClocks must be a 64 multiply */
-        remainder = (uint8_t)(periodInFmClocks % 64);
-        if (remainder > 64)
-            tmpReg = (uint32_t)((periodInFmClocks/64) + 1);
-        else
-        {
-            tmpReg = (uint32_t)(periodInFmClocks/64);
-            if(!tmpReg)
-                tmpReg = 1;
-        }
-        tmpReg <<= QMI_TAPC_TAP;
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_tapc, tmpReg);
-
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-    tmpReg = 0;
-    /* Clear interrupt events */
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+
+    /* build the FM master partition IPC address */
+    if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
     {
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
-        if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
-            tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-        /* enable events */
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
     }
 
-    /* clear & enable global counters  - calculate reg and save for later,
-       because it's the same reg for QMI enable */
-    if(p_Fm->p_FmDriverParam->enCounters)
-        cfgReg = QMI_CFG_EN_COUNTERS;
-#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
-        cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
-#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
+    err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
+    if (err)
+    {
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
+    /* Register the FM interrupts handlers */
     if (p_Fm->p_FmStateStruct->irq != NO_IRQ)
     {
         XX_SetIntr(p_Fm->p_FmStateStruct->irq, FM_EventIsr, p_Fm);
@@ -3543,33 +3828,29 @@ t_Error FM_Init(t_Handle h_Fm)
         XX_EnableIntr(p_Fm->p_FmStateStruct->errIrq);
     }
 
-    /* build the FM master partition IPC address */
-    if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
-    {
-        FreeInitResources(p_Fm);
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-    }
-
-    err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-    if(err)
-    {
-        FreeInitResources(p_Fm);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
     /**********************/
     /* Enable all modules */
     /**********************/
+    /* clear & enable global counters  - calculate reg and save for later,
+       because it's the same reg for QMI enable */
+    if (p_Fm->p_FmDriverParam->enCounters)
+        cfgReg = QMI_CFG_EN_COUNTERS;
+#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+        cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) | (uint32_t)QMI_DEF_TNUMS_THRESH);
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
+
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, BMI_INIT_START);
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, cfgReg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN);
 
+    EnableTimeStamp(p_Fm);
+
     if (p_Fm->p_FmDriverParam->firmware.p_Code)
     {
         XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
         p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
     }
 
-
     XX_Free(p_Fm->p_FmDriverParam);
     p_Fm->p_FmDriverParam = NULL;
 
@@ -3596,38 +3877,17 @@ t_Error FM_Free(t_Handle h_Fm)
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
 #if (DPAA_VERSION >= 11)
-        if (p_Fm->h_IpcSessions[0])
-        {
-            t_FmIpcMsg          msg;
-            t_FmIpcReply        reply;
-            uint32_t            replyLength;
-            t_FmIpcVspAllocParams   fmIpcVspAllocParams;
-            t_Error             err;
-
-            memset(&msg, 0, sizeof(msg));
-            memset(&reply, 0, sizeof(reply));
-            memset(&fmIpcVspAllocParams, 0, sizeof(t_FmIpcVspAllocParams));
-            fmIpcVspAllocParams.guestId         = p_Fm->guestId;
-            fmIpcVspAllocParams.numOfProfiles   = p_Fm->partNumOfVSPs;
-            fmIpcVspAllocParams.base            = p_Fm->partVSPBase;
-            msg.msgId                           = FM_VSP_FREE;
-            memcpy(msg.msgBody, &fmIpcVspAllocParams, sizeof(t_FmIpcVspAllocParams));
-            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
-            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                             (uint8_t*)&msg,
-                                             sizeof(msg.msgId) + sizeof(t_FmIpcVspAllocParams),
-                                             (uint8_t*)&reply,
-                                             &replyLength,
-                                             NULL,
-                                             NULL)) != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+        FreeVSPsForPartition(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
 
-            if (err != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (p_Fm->p_FmSp)
+        {
+            XX_Free(p_Fm->p_FmSp);
+            p_Fm->p_FmSp = NULL;
         }
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
-        XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
+        if (p_Fm->fmModuleName)
+            XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
         if (!p_Fm->recoveryMode)
             XX_Free(p_Fm->p_FmStateStruct);
@@ -3646,7 +3906,7 @@ t_Error FM_Free(t_Handle h_Fm)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, 0);
 
     /* disable ECC */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, 0);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, 0);
 
     if ((p_Fm->guestId == NCSW_MASTER_ID) && (p_Fm->fmModuleName[0] != 0))
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
@@ -3666,14 +3926,14 @@ t_Error FM_Free(t_Handle h_Fm)
     }
 
 #if (DPAA_VERSION >= 11)
-    FmVSPsFree(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
+    FreeVSPsForPartition(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
 
     if (p_Fm->p_FmSp)
     {
         XX_Free(p_Fm->p_FmSp);
         p_Fm->p_FmSp = NULL;
     }
-#endif /*(DPAA_VERSION >= 11)*/
+#endif /* (DPAA_VERSION >= 11) */
 
     if (p_Fm->h_Spinlock)
         XX_FreeSpinlock(p_Fm->h_Spinlock);
@@ -3707,32 +3967,33 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->resetOnInit = enable;
 
     return E_OK;
 }
 
-
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmStateStruct->totalFifoSize = totalFifoSize;
 
     return E_OK;
 }
 
-
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaCacheOverride = cacheOverride;
 
@@ -3745,6 +4006,7 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaAidOverride = aidOverride;
 
@@ -3757,6 +4019,7 @@ t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaAidMode = aidMode;
 
@@ -3769,6 +4032,7 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
 
@@ -3781,73 +4045,79 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaCamNumOfEntries = numOfEntries;
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
-    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
+    p_Fm->p_FmDriverParam->enCounters = TRUE;
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
-
-    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
-    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
+    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
+    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
+    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
+    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
 
     return E_OK;
 }
 
-t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->enCounters = TRUE;
+    if (!p_Fm->p_FmDriverParam->dmaEnEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
+
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
+    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
 
     return E_OK;
 }
@@ -3858,6 +4128,7 @@ t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaErr = dmaErr;
 
@@ -3870,6 +4141,7 @@ t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophic
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->catastrophicErr = catastrophicErr;
 
@@ -3882,9 +4154,10 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigEnableMuramTestMode!"));
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
     p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
 
@@ -3897,9 +4170,10 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE );
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigEnableMuramTestMode!"));
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
     p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
 
@@ -3912,6 +4186,7 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
 
@@ -3924,9 +4199,10 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigHaltOnUnrecoverableEccError"));
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
     p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
     return E_OK;
@@ -3938,9 +4214,11 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     uint32_t            bitMask = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Fm->p_FmDriverParam->userSetExceptions |= bitMask;
@@ -3958,6 +4236,8 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->externalEccRamsEnable = enable;
 
@@ -3969,80 +4249,85 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
     t_Fm             *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->tnumAgingPeriod = tnumAgingPeriod;
 
     return E_OK;
-
 }
 
 /****************************************************/
 /*       Hidden-DEBUG Only API                      */
 /****************************************************/
 
-t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Functionality not supported on this integration."));
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
-    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
 
     return E_OK;
 }
 
-t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
-
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Functionality not supported on this integration."));
-
-    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
 
     return E_OK;
 }
 
-t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
 
     return E_OK;
 }
@@ -4053,66 +4338,13 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
 
     return E_OK;
 }
 
-t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-
-    switch(exception)
-    {
-        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
-            break;
-        case e_FM_EX_QMI_SINGLE_ECC:
-            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC not supported on this integration."));
-
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
-            break;
-        case e_FM_EX_QMI_DOUBLE_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
-            break;
-        case e_FM_EX_BMI_LIST_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
-            break;
-        case e_FM_EX_BMI_STORAGE_PROFILE_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC);
-            break;
-        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
-            break;
-        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
-    }
-
-    return E_OK;
-}
-
 
 /****************************************************/
 /*       API Run-time Control uint functions        */
@@ -4123,23 +4355,25 @@ void FM_EventIsr(t_Handle h_Fm)
     {                                   \
         if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].guestId)    \
             SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id), pending);                 \
-        else                                                                                            \
+        else                                                                                        \
             p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].h_SrcHandle);\
     }
 #define FM_M_CALL_10G_MAC_ISR(_id)   \
     {                                   \
         if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].guestId)    \
             SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id), pending);                 \
-        else                                                                                            \
+        else                                                                                         \
             p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].h_SrcHandle);\
     }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending, event;
 
-    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     /* normal interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_npi);
     ASSERT_COND(pending);
     if (pending & INTR_EN_QMI)
         QmiEvent(p_Fm);
@@ -4175,8 +4409,8 @@ void FM_EventIsr(t_Handle h_Fm)
     /* IM port events may belong to different partitions */
     if (pending & INTR_EN_REV0)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[0]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[0]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[0], event);
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[0]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[0]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[0], event);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_0].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -4187,8 +4421,8 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV1)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[1]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[1]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[1], event);
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[1]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[1]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[1], event);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_1].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -4199,8 +4433,8 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV2)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[2]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[2]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[2], event);
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[2]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[2]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[2], event);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_2].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -4210,8 +4444,8 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV3)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[3]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[3]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[3], event);
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[3]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[3]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[3], event);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_3].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -4235,12 +4469,15 @@ t_Error FM_ErrorIsr(t_Handle h_Fm)
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     /* error interrupts */
-    if (GET_UINT32(p_Fm->p_FmFpmRegs->fmepi) == 0)
+    if (GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi) == 0)
         return ERROR_CODE(E_EMPTY);
 
     ErrorIsrCB(p_Fm);
+
     return E_OK;
 }
 
@@ -4255,6 +4492,7 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     /* check that all ports add up to 100% */
     sum = 0;
@@ -4291,14 +4529,14 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
         shift = (uint8_t)(32-4*(relativePortId+1));
 
 
-        if(weight > 1)
+        if (weight > 1)
             /* Add this port to tmpReg */
             /* (each 8 ports result in one register)*/
             tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
     }
 
-    for(i=0;i<8;i++)
-        if(tmpRegs[i])
+    for (i=0;i<8;i++)
+        if (tmpRegs[i])
             WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i], tmpRegs[i]);
 
     return E_OK;
@@ -4311,40 +4549,38 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         t_FmIpcMsg      msg;
         t_Error         err;
 
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_ENABLE_RAM_ECC;
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId),
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         return E_OK;
     }
 
-    if(!p_Fm->p_FmStateStruct->internalCall)
+    if (!p_Fm->p_FmStateStruct->internalCall)
         p_Fm->p_FmStateStruct->explicitEnable = TRUE;
     p_Fm->p_FmStateStruct->internalCall = FALSE;
 
-    if(p_Fm->p_FmStateStruct->ramsEccEnable)
+    if (p_Fm->p_FmStateStruct->ramsEccEnable)
         return E_OK;
     else
     {
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-        {
-           // DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
-        }
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
+        if (tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
         else
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
         p_Fm->p_FmStateStruct->ramsEccEnable = TRUE;
     }
 
@@ -4360,7 +4596,7 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         t_Error             err;
         t_FmIpcMsg          msg;
@@ -4378,30 +4614,31 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
         return E_OK;
     }
 
-    if(!p_Fm->p_FmStateStruct->internalCall)
+    if (!p_Fm->p_FmStateStruct->internalCall)
         explicitDisable = TRUE;
     p_Fm->p_FmStateStruct->internalCall = FALSE;
 
     /* if rams are already disabled, or if rams were explicitly enabled and are
        currently called indirectly (not explicitly), ignore this call. */
-    if(!p_Fm->p_FmStateStruct->ramsEccEnable || (p_Fm->p_FmStateStruct->explicitEnable && !explicitDisable))
+    if (!p_Fm->p_FmStateStruct->ramsEccEnable ||
+        (p_Fm->p_FmStateStruct->explicitEnable && !explicitDisable))
         return E_OK;
     else
     {
-        if(p_Fm->p_FmStateStruct->explicitEnable)
+        if (p_Fm->p_FmStateStruct->explicitEnable)
             /* This is the case were both explicit are TRUE.
                Turn off this flag for cases were following ramsEnable
                routines are called */
             p_Fm->p_FmStateStruct->explicitEnable = FALSE;
 
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
+        if (tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
         {
             DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~FPM_RAM_CTL_IRAM_ECC_EN);
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg & ~FPM_RAM_CTL_IRAM_ECC_EN);
         }
         else
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
         p_Fm->p_FmStateStruct->ramsEccEnable = FALSE;
     }
 
@@ -4416,9 +4653,10 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Fm->p_FmStateStruct->exceptions |= bitMask;
@@ -4427,65 +4665,66 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
         switch(exception)
         {
-             case(e_FM_EX_DMA_BUS_ERROR):
+             case (e_FM_EX_DMA_BUS_ERROR):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if(enable)
+                if (enable)
                     tmpReg |= DMA_MODE_BER;
                 else
                     tmpReg &= ~DMA_MODE_BER;
                 /* disable bus error */
                 WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
                 break;
-             case(e_FM_EX_DMA_READ_ECC):
-             case(e_FM_EX_DMA_SYSTEM_WRITE_ECC):
-             case(e_FM_EX_DMA_FM_WRITE_ECC):
+             case (e_FM_EX_DMA_READ_ECC):
+             case (e_FM_EX_DMA_SYSTEM_WRITE_ECC):
+             case (e_FM_EX_DMA_FM_WRITE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if(enable)
+                if (enable)
                     tmpReg |= DMA_MODE_ECC;
                 else
                     tmpReg &= ~DMA_MODE_ECC;
                 WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
                 break;
-             case(e_FM_EX_FPM_STALL_ON_TASKS):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
-                if(enable)
+             case (e_FM_EX_FPM_STALL_ON_TASKS):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_STALL_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_STALL_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
                 break;
-             case(e_FM_EX_FPM_SINGLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
-                if(enable)
+             case (e_FM_EX_FPM_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
                 break;
-            case( e_FM_EX_FPM_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
-                if(enable)
+            case ( e_FM_EX_FPM_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
                 break;
-            case( e_FM_EX_QMI_SINGLE_ECC):
+            case ( e_FM_EX_QMI_SINGLE_ECC):
 #if defined(FM_QMI_NO_ECC_EXCEPTIONS) || defined(FM_QMI_NO_SINGLE_ECC_EXCEPTION)
-               if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) || (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
+               if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) ||
+                   (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
                 {
                    REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
                    return E_OK;
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_INTR_EN_SINGLE_ECC;
                 else
                     tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
                 break;
-             case(e_FM_EX_QMI_DOUBLE_ECC):
+             case (e_FM_EX_QMI_DOUBLE_ECC):
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
                 if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
                 {
@@ -4494,47 +4733,47 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
                 break;
-             case(e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
+             case (e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
                 break;
-             case(e_FM_EX_BMI_LIST_RAM_ECC):
+             case (e_FM_EX_BMI_LIST_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-             case(e_FM_EX_BMI_STORAGE_PROFILE_ECC):
+             case (e_FM_EX_BMI_STORAGE_PROFILE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-             case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
+             case (e_FM_EX_BMI_STATISTICS_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-             case(e_FM_EX_BMI_DISPATCH_RAM_ECC):
+             case (e_FM_EX_BMI_DISPATCH_RAM_ECC):
                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-               if(enable)
+               if (enable)
                {
 #ifdef FM_NO_DISPATCH_RAM_ECC
                    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
@@ -4549,9 +4788,9 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                    tmpReg &= ~BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                break;
-             case(e_FM_EX_IRAM_ECC):
-                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
-                if(enable)
+             case (e_FM_EX_IRAM_ECC):
+                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
+                if (enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -4564,12 +4803,12 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     FmDisableRamsEcc(p_Fm);
                     tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
                 }
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
                 break;
 
-             case(e_FM_EX_MURAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
-                if(enable)
+             case (e_FM_EX_MURAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
+                if (enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -4583,7 +4822,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg &= ~FPM_MURAM_ECC_ERR_EX_EN;
                 }
 
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
                 break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
@@ -4609,17 +4848,20 @@ t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_Re
 {
     t_Fm                            *p_Fm = (t_Fm*)h_Fm;
     t_FMIramRegs                    *p_Iram;
-    t_Error                         err;
-    t_FmIpcMsg                      msg;
-    t_FmIpcReply                    reply;
-    uint32_t                        replyLength, revInfo;
-    t_FmIpcFmanCtrlCodeRevisionInfo ipcRevInfo;
+    uint32_t                        revInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_RevisionInfo, E_NULL_POINTER);
 
-    if (p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_Error                         err;
+        t_FmIpcMsg                      msg;
+        t_FmIpcReply                    reply;
+        uint32_t                        replyLength;
+        t_FmIpcFmanCtrlCodeRevisionInfo ipcRevInfo;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_FMAN_CTRL_CODE_REV;
@@ -4640,6 +4882,9 @@ t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_Re
         p_RevisionInfo->minorRev = ipcRevInfo.minorRev;
         return (t_Error)(reply.error);
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
 
     p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
     WRITE_UINT32(p_Iram->iadd, 0x4);
@@ -4657,52 +4902,59 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     t_Error             err;
     uint32_t            counterValue;
-    t_FmIpcMsg          msg;
-    t_FmIpcReply        reply;
-    uint32_t            replyLength, outCounter;
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength, outCounter;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_COUNTER;
         memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
         replyLength = sizeof(uint32_t) + sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId) +sizeof(counterValue),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
-                                     NULL)) != E_OK)
+                                     NULL);
+        if (err != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
 
         return outCounter;
-     }
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
 
     /* When applicable (when there is an 'enable counters' bit,
     check that counters are enabled */
     switch(counter)
     {
-        case(e_FM_COUNTERS_DEQ_1):
-        case(e_FM_COUNTERS_DEQ_2):
-        case(e_FM_COUNTERS_DEQ_3):
-              if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        case (e_FM_COUNTERS_DEQ_1):
+        case (e_FM_COUNTERS_DEQ_2):
+        case (e_FM_COUNTERS_DEQ_3):
+              if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
-        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_0):
-        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
-        case(e_FM_COUNTERS_DEQ_FROM_FD):
-        case(e_FM_COUNTERS_DEQ_CONFIRM):
-            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_0):
+        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case (e_FM_COUNTERS_DEQ_FROM_FD):
+        case (e_FM_COUNTERS_DEQ_CONFIRM):
+            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -4711,25 +4963,25 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 
     switch(counter)
     {
-        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
-        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
-        case(e_FM_COUNTERS_DEQ_0):
+        case (e_FM_COUNTERS_DEQ_0):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0);
-        case(e_FM_COUNTERS_DEQ_1):
+        case (e_FM_COUNTERS_DEQ_1):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1);
-        case(e_FM_COUNTERS_DEQ_2):
+        case (e_FM_COUNTERS_DEQ_2):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2);
-        case(e_FM_COUNTERS_DEQ_3):
+        case (e_FM_COUNTERS_DEQ_3):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3);
-        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc);
-        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc);
-        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case (e_FM_COUNTERS_DEQ_FROM_FD):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
-        case(e_FM_COUNTERS_DEQ_CONFIRM):
+        case (e_FM_COUNTERS_DEQ_CONFIRM):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
             break;
     }
@@ -4743,26 +4995,27 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
-   SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-   SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     /* When applicable (when there is an 'enable counters' bit,
     check that counters are enabled */
     switch(counter)
     {
-        case(e_FM_COUNTERS_DEQ_1):
-        case(e_FM_COUNTERS_DEQ_2):
-        case(e_FM_COUNTERS_DEQ_3):
-             if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        case (e_FM_COUNTERS_DEQ_1):
+        case (e_FM_COUNTERS_DEQ_2):
+        case (e_FM_COUNTERS_DEQ_3):
+             if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
                  RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
-        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_0):
-        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
-        case(e_FM_COUNTERS_DEQ_FROM_FD):
-        case(e_FM_COUNTERS_DEQ_CONFIRM):
-            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_0):
+        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case (e_FM_COUNTERS_DEQ_FROM_FD):
+        case (e_FM_COUNTERS_DEQ_CONFIRM):
+            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -4772,34 +5025,34 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
     /* Set counter */
     switch(counter)
     {
-        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
             break;
-        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc, val);
             break;
-        case(e_FM_COUNTERS_DEQ_0):
+        case (e_FM_COUNTERS_DEQ_0):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0, val);
             break;
-        case(e_FM_COUNTERS_DEQ_1):
+        case (e_FM_COUNTERS_DEQ_1):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1, val);
             break;
-        case(e_FM_COUNTERS_DEQ_2):
+        case (e_FM_COUNTERS_DEQ_2):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2, val);
             break;
-        case(e_FM_COUNTERS_DEQ_3):
+        case (e_FM_COUNTERS_DEQ_3):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3, val);
             break;
-        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc, val);
             break;
-        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc, val);
             break;
-        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case (e_FM_COUNTERS_DEQ_FROM_FD):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc, val);
             break;
-        case(e_FM_COUNTERS_DEQ_CONFIRM):
+        case (e_FM_COUNTERS_DEQ_CONFIRM):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
             break;
         default:
@@ -4816,10 +5069,11 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
 
-    if(enable)
+    if (enable)
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
     else /* disable */
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
@@ -4833,6 +5087,7 @@ void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri)
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | ((uint32_t)pri << DMA_MODE_BUS_PRI_SHIFT) );
 
@@ -4843,17 +5098,20 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     uint32_t            tmpReg;
-    t_Error             err;
-    t_FmIpcMsg          msg;
-    t_FmIpcReply        reply;
-    uint32_t            replyLength;
-    t_FmIpcDmaStatus    ipcDmaStatus;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
     {
+        t_FmIpcDmaStatus    ipcDmaStatus;
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        t_Error             err;
+        uint32_t            replyLength;
+
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_DMA_STAT;
@@ -4885,12 +5143,18 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         p_FmDmaStatus->singlePortEccError = (bool)ipcDmaStatus.boolSinglePortEccError;     /**< Double ECC error on buffer write from FM side */
         return;
     }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+        return;
+    }
 
     tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
 
     p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
     p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         p_FmDmaStatus->singlePortEccError = (bool)(tmpReg & DMA_STATUS_FM_SPDAT_ECC);
     else
     {
@@ -4898,8 +5162,6 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
         p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
     }
-
-    return;
 }
 
 void FM_Resume(t_Handle h_Fm)
@@ -4909,27 +5171,24 @@ void FM_Resume(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->guestId == NCSW_MASTER_ID)
-    {
-        tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
-        /* clear tmpReg event bits in order not to clear standing events */
-        tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
-    }
-    else
-        ASSERT_COND(0); /* TODO */
+    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+    /* clear tmpReg event bits in order not to clear standing events */
+    tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg | FPM_EV_MASK_RELEASE_FM);
 }
 
-t_Error FM_GetSpecialOperationCoding(t_Handle h_Fm,
-                                     fmSpecialOperations_t spOper,
-                                     uint8_t *p_SpOperCoding)
+t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
+                                     fmSpecialOperations_t  spOper,
+                                     uint8_t                *p_SpOperCoding)
 {
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
     t_FmCtrlCodeRevisionInfo    revInfo;
     t_Error                     err;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_SpOperCoding, E_NULL_POINTER);
 
     if (!spOper)
@@ -4937,10 +5196,15 @@ t_Error FM_GetSpecialOperationCoding(t_Handle h_Fm,
         *p_SpOperCoding = 0;
         return E_OK;
     }
+
     if ((err = FM_GetFmanCtrlCodeRevision(p_Fm, &revInfo)) != E_OK)
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
+    {
+        DBG(WARNING, ("FM in guest-mode without IPC, can't validate firmware revision."));
+        revInfo.packageRev = IP_OFFLOAD_PACKAGE_NUMBER;
+    }
+    else if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
+
     if (revInfo.packageRev == IP_OFFLOAD_PACKAGE_NUMBER)
     {
         switch (spOper)
@@ -4965,6 +5229,9 @@ t_Error FM_GetSpecialOperationCoding(t_Handle h_Fm,
             case (FM_SP_OP_IPSEC):
                     *p_SpOperCoding = 2;
                     break;
+            case (FM_SP_OP_DCL4C):
+                    *p_SpOperCoding = 7;
+                    break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         }
@@ -4980,7 +5247,7 @@ t_Error FM_CtrlMonStart(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
         fmCtrlNum = 2;
@@ -5013,7 +5280,7 @@ t_Error FM_CtrlMonStop(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
         fmCtrlNum = 2;
@@ -5038,7 +5305,7 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
     SANITY_CHECK_RETURN_ERROR(p_Mon, E_NULL_POINTER);
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
@@ -5058,6 +5325,7 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
             ((uint64_t)GET_UINT32(p_MonRegs->tpc1h) << 32 | GET_UINT32(p_MonRegs->tpc1l));
 
     p_Mon->percentCnt[0] = (uint8_t)((clkCnt - monValue) * 100 / clkCnt);
+
     return E_OK;
 }
 
@@ -5066,84 +5334,68 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm *)h_Fm;
     uint8_t         i = 0;
-    t_Error         err;
-    t_FmIpcMsg      msg;
 
     DECLARE_DUMP;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-
-    if(p_Fm->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_DUMP_REGS;
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                    (uint8_t*)&msg,
-                                    sizeof(msg.msgId),
-                                    NULL,
-                                    NULL,
-                                    NULL,
-                                    NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        return E_OK;
-    }
-
+    SANITY_CHECK_RETURN_ERROR(((p_Fm->guestId == NCSW_MASTER_ID) ||
+                               p_Fm->baseAddr), E_INVALID_OPERATION);
 
     DUMP_SUBTITLE(("\n"));
 
     DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FM-FPM Regs"));
 
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtnc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmpr);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,brkc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmflc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmepi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrie);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tnc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_prc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_brkc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_mxd);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dis1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dis2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_epi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rie);
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcev, ("fmfpfcev"));
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_fcev, ("fmfp_fcev"));
     DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcev[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_fcev[i], sizeof(uint32_t));
     }
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcee, ("fmfpfcee"));
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_cee, ("fmfp_cee"));
     DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcee[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_cee[i], sizeof(uint32_t));
     }
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsp);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsf);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrcr);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmextc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext2);
-
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmdrd, ("fpmdrd"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsc1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsc2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsp);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsf);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rcr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_extc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext2);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_drd, ("fmfp_drd"));
     DUMP_SUBSTRUCT_ARRAY(i, 16)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmdrd[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_drd[i], sizeof(uint32_t));
     }
 
     DUMP_SUBTITLE(("\n"));
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdra);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dra);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrstc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmcld);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmnpi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmem);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rstc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_cld);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_npi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_em);
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmcev, ("fpmcev"));
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_cev, ("fmfp_cev"));
     DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmcev[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_cev[i], sizeof(uint32_t));
     }
 
     DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps, ("fmfp_ps"));
@@ -5206,3 +5458,62 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
+
+
+/****************************************************/
+/*       Hidden-DEBUG Only API                      */
+/****************************************************/
+
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+            break;
+        case e_FM_EX_QMI_SINGLE_ECC:
+            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC not supported on this integration."));
+
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            break;
+        case e_FM_EX_QMI_DOUBLE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            break;
+        case e_FM_EX_BMI_LIST_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_STORAGE_PROFILE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC);
+            break;
+        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index 5854b9b..ca2df27 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -175,6 +175,8 @@ switch(exception){                                          \
 #define DEFAULT_dmaWatchdog                 0 /* disabled */
 #define DEFAULT_mtu                         9600
 
+#define FM_TIMESTAMP_1_USEC_BIT             8
+
 /**************************************************************************//**
  @Collection   Defines used for enabling/disabling FM interrupts
  @{
@@ -255,40 +257,40 @@ typedef uint32_t t_FmBlockIntrEnable;
 
 typedef _Packed struct
 {
-    volatile uint32_t   fpmtnc;         /**< FPM TNUM Control */
-    volatile uint32_t   fpmpr;          /**< FPM Port_ID FmCtl Association */
-    volatile uint32_t   brkc;           /**< FPM Breakpoint Control */
-    volatile uint32_t   fpmflc;         /**< FPM Flush Control */
-    volatile uint32_t   fpmdis1;        /**< FPM Dispatch Thresholds1 */
-    volatile uint32_t   fpmdis2;        /**< FPM Dispatch Thresholds2  */
-    volatile uint32_t   fmepi;          /**< FM Error Pending Interrupts */
-    volatile uint32_t   fmrie;          /**< FM Error Interrupt Enable */
-    volatile uint32_t   fmfpfcev[4];    /**< FPM FMan-Controller Event 1-4 */
+    volatile uint32_t   fmfp_tnc;       /**< FPM TNUM Control */
+    volatile uint32_t   fmfp_prc;       /**< FPM Port_ID FmCtl Association */
+    volatile uint32_t   fmfp_brkc;      /**< FPM Breakpoint Control */
+    volatile uint32_t   fmfp_mxd;       /**< FPM Maximum dispatch */
+    volatile uint32_t   fmfp_dis1;      /**< FPM Dispatch Thresholds1 */
+    volatile uint32_t   fmfp_dis2;      /**< FPM Dispatch Thresholds2  */
+    volatile uint32_t   fm_epi;         /**< FM Error Pending Interrupts */
+    volatile uint32_t   fm_rie;         /**< FM Error Interrupt Enable */
+    volatile uint32_t   fmfp_fcev[4];   /**< FPM FMan-Controller Event 1-4 */
     volatile uint8_t    res1[16];       /**< reserved */
-    volatile uint32_t   fmfpfcee[4];    /**< PM FMan-Controller Event 1-4 */
+    volatile uint32_t   fmfp_cee[4];    /**< PM FMan-Controller Event 1-4 */
     volatile uint8_t    res2[16];       /**< reserved */
-    volatile uint32_t   fpmtsc1;        /**< FPM TimeStamp Control1 */
-    volatile uint32_t   fpmtsc2;        /**< FPM TimeStamp Control2 */
-    volatile uint32_t   fpmtsp;         /**< FPM Time Stamp */
-    volatile uint32_t   fpmtsf;         /**< FPM Time Stamp Fraction */
-    volatile uint32_t   fmrcr;          /**< FM Rams Control */
-    volatile uint32_t   fpmextc;        /**< FPM External Requests Control */
-    volatile uint32_t   fpmext1;        /**< FPM External Requests Config1 */
-    volatile uint32_t   fpmext2;        /**< FPM External Requests Config2 */
-    volatile uint32_t   fpmdrd[16];     /**< FPM Data_Ram Data 0-15 */
-    volatile uint32_t   fpmdra;         /**< FPM Data Ram Access */
+    volatile uint32_t   fmfp_tsc1;      /**< FPM TimeStamp Control1 */
+    volatile uint32_t   fmfp_tsc2;      /**< FPM TimeStamp Control2 */
+    volatile uint32_t   fmfp_tsp;       /**< FPM Time Stamp */
+    volatile uint32_t   fmfp_tsf;       /**< FPM Time Stamp Fraction */
+    volatile uint32_t   fm_rcr;         /**< FM Rams Control */
+    volatile uint32_t   fmfp_extc;      /**< FPM External Requests Control */
+    volatile uint32_t   fmfp_ext1;      /**< FPM External Requests Config1 */
+    volatile uint32_t   fmfp_ext2;      /**< FPM External Requests Config2 */
+    volatile uint32_t   fmfp_drd[16];   /**< FPM Data_Ram Data 0-15 */
+    volatile uint32_t   fmfp_dra;       /**< FPM Data Ram Access */
     volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
     volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
-    volatile uint32_t   fmrstc;         /**< FM Reset Command */
-    volatile uint32_t   fmcld;          /**< FM Classifier Debug */
-    volatile uint32_t   fmnpi;          /**< FM Normal Pending Interrupts  */
+    volatile uint32_t   fm_rstc;        /**< FM Reset Command */
+    volatile uint32_t   fm_cld;         /**< FM Classifier Debug */
+    volatile uint32_t   fm_npi;         /**< FM Normal Pending Interrupts  */
     volatile uint32_t   fmfp_exte;      /**< FPM External Requests Enable */
-    volatile uint32_t   fpmem;          /**< FPM Event & Mask */
-    volatile uint32_t   fpmcev[4];      /**< FPM CPU Event 1-4 */
+    volatile uint32_t   fmfp_em;        /**< FPM Event & Mask */
+    volatile uint32_t   fmfp_cev[4];    /**< FPM CPU Event 1-4 */
     volatile uint8_t    res4[16];       /**< reserved */
     volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
     volatile uint8_t    reserved1[0x260];
-    volatile uint32_t   fpmts[128];     /**< 0x400: FPM Task Status */
+    volatile uint32_t   fmfp_ts[128];     /**< 0x400: FPM Task Status */
 } _PackedType t_FmFpmRegs;
 
 #define NUM_OF_DBG_TRAPS    3
@@ -314,7 +316,7 @@ typedef _Packed struct
    volatile uint32_t   reserved4;
    volatile uint32_t   fmbm_pfs[63];    /**< BMI Port FIFO Size */
    volatile uint32_t   reserved5;
-   volatile uint32_t   fmbm_ppid[63];   /**< Port Partition ID */
+   volatile uint32_t   fmbm_spliodn[63];   /**< Port Partition ID */
 } _PackedType t_FmBmiRegs;
 
 typedef _Packed struct
@@ -815,7 +817,6 @@ typedef struct t_Fm
 #endif /* (DPAA_VERSION >= 11) */
 
 /* un-needed for recovery */
-    t_FmDriverParam             *p_FmDriverParam;
     t_Handle                    h_FmMuram;
     uint64_t                    fmMuramPhysBaseAddr;
     bool                        independentMode;
@@ -825,6 +826,8 @@ typedef struct t_Fm
     uintptr_t                   fifoBaseAddr;                   /* save for freeing */
     t_FmanCtrlIntrSrc           fmanCtrlIntr[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];    /* FM exceptions user callback */
     bool                        usedEventRegs[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];
+
+    t_FmDriverParam             *p_FmDriverParam;
 } t_Fm;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 6220908..9e65778 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -207,25 +207,25 @@ typedef _Packed struct t_FmIpcPortNumOfFmanCtrls {
  @Description   structure for setting Fman contriller events
 *//***************************************************************************/
 typedef _Packed struct t_FmIpcFmanEvents {
-    uint8_t         eventRegId;               /**< IN: Fman controller event register id */
-    uint32_t        enableEvents;             /**< IN/OUT: required enabled events mask */
+    uint8_t     eventRegId;               /**< IN: Fman controller event register id */
+    uint32_t    enableEvents;             /**< IN/OUT: required enabled events mask */
 } _PackedType t_FmIpcFmanEvents;
 
-typedef _Packed struct t_FmIpcVspAllocParams {
-    uint8_t guestId;
-    uint8_t numOfProfiles;
-    uint8_t base;
-}_PackedType t_FmIpcVspAllocParams;
+typedef _Packed struct t_FmIpcResourceAllocParams {
+    uint8_t     guestId;
+    uint8_t     base;
+    uint8_t     num;
+}_PackedType t_FmIpcResourceAllocParams;
 
 typedef _Packed struct t_FmIpcVspSetPortWindow {
-    uint8_t hardwarePortId;
-    uint8_t baseStorageProfile;
-    uint8_t log2NumOfProfiles;
+    uint8_t     hardwarePortId;
+    uint8_t     baseStorageProfile;
+    uint8_t     log2NumOfProfiles;
 }_PackedType t_FmIpcVspSetPortWindow;
 
 typedef _Packed struct t_FmIpcSetCongestionGroupPfcPriority {
-        uint32_t     congestionGroupId;
-        uint8_t      priorityBitMap;
+    uint32_t     congestionGroupId;
+    uint8_t      priorityBitMap;
 }_PackedType t_FmIpcSetCongestionGroupPfcPriority;
 
 #define FM_IPC_MAX_REPLY_BODY_SIZE  16
@@ -272,16 +272,6 @@ typedef _Packed struct t_FmIpcReply
 #define FM_GET_COUNTER              2
 
 /**************************************************************************//**
- @Function      FM_DUMP_REGS
-
- @Description   Used by FM front-end for the PORT module in order to set and get
-                parameters in/from master FM module on FM PORT initialization time.
-
- @Param         None
-*//***************************************************************************/
-#define FM_DUMP_REGS                3
-
-/**************************************************************************//**
  @Function      FM_GET_SET_PORT_PARAMS
 
  @Description   Used by FM front-end for the PORT module in order to set and get
@@ -331,16 +321,6 @@ typedef _Packed struct t_FmIpcReply
 #define FM_IS_PORT_STALLED          8
 
 /**************************************************************************//**
- @Function      FM_DUMP_PORT_REGS
-
- @Description   Used by FM front-end for the PORT module in order to dump
-                all port registers.
-
- @Param[in]     uint8_t Pointer
-*//***************************************************************************/
-#define FM_DUMP_PORT_REGS           9
-
-/**************************************************************************//**
  @Function      FM_GET_PARAMS
 
  @Description   Used by FM front-end for the PORT module in order to dump
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 0694de5..6b7436c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -166,7 +166,7 @@ typedef enum e_FmInterModuleEvent
 /**************************************************************************//**
  @Description   PCD KG scheme registers
 *//***************************************************************************/
-typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
+typedef _Packed struct t_FmPcdPlcrProfileRegs {
     volatile uint32_t fmpl_pemode;      /* 0x090 FMPL_PEMODE - FM Policer Profile Entry Mode*/
     volatile uint32_t fmpl_pegnia;      /* 0x094 FMPL_PEGNIA - FM Policer Profile Entry GREEN Next Invoked Action*/
     volatile uint32_t fmpl_peynia;      /* 0x098 FMPL_PEYNIA - FM Policer Profile Entry YELLOW Next Invoked Action*/
@@ -184,12 +184,12 @@ typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
     volatile uint32_t fmpl_perypc;      /* 0x0C8 FMPL_PERYPC - FM Policer Profile Entry Recolored YELLOW Packet Counter*/
     volatile uint32_t fmpl_perrpc;      /* 0x0CC FMPL_PERRPC - FM Policer Profile Entry Recolored RED Packet Counter*/
     volatile uint32_t fmpl_res1[12];    /* 0x0D0-0x0FF Reserved */
-} _PackedType t_FmPcdPlcrInterModuleProfileRegs;
+} _PackedType t_FmPcdPlcrProfileRegs;
 
 /**************************************************************************//**
  @Description   PCD KG scheme registers
 *//***************************************************************************/
-typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
+typedef _Packed struct t_FmPcdKgSchemeRegs {
     volatile uint32_t kgse_mode;    /**< MODE */
     volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
     volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
@@ -207,7 +207,7 @@ typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
     volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
     volatile uint32_t kgse_om;      /**< KeyGen Scheme Entry Operation Mode bits */
     volatile uint32_t kgse_vsp;     /**< KeyGen Scheme Entry Virtual Storage Profile */
-} _PackedType t_FmPcdKgInterModuleSchemeRegs;
+} _PackedType t_FmPcdKgSchemeRegs;
 
 typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
     volatile uint32_t                       portIdAndCapwapReassmTbl;
@@ -295,8 +295,8 @@ typedef struct {
     uint32_t        type;
     int             psoSize;
     uint32_t        nia;
-    bool            immediateWrite;
     t_FmFmanCtrl    orFmanCtrl;
+    bool            overwrite;
 } t_SetCcParams;
 
 typedef struct {
@@ -345,7 +345,8 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define HW_PORT_ID                              0x04000000
 #define FM_REV                                  0x02000000
 #define GET_NIA_FPNE                            0x01000000
-#define NUM_OF_EXTRA_TASKS                      0x00800000
+#define GET_NIA_PNDN                            0x00800000
+#define NUM_OF_EXTRA_TASKS                      0x00400000
 
 #define UPDATE_NIA_PNEN                         0x80000000
 #define UPDATE_PSO                              0x40000000
@@ -354,7 +355,6 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_NIA_FENE                         0x04000000
 #define UPDATE_NIA_CMNE                         0x02000000
 #define UPDATE_NIA_FPNE                         0x01000000
-#define UPDATE_NIA_FNE                          0x00800000
 /* @} */
 
 /**************************************************************************//**
@@ -405,10 +405,9 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_FM_CTL_AC_POST_BMI_FETCH            0x00000012
 #define NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME         0x0000001A
 #define NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME     0x0000001E
-#define NIA_FM_CTL_AC_FRAG_CHECK                0x00000014
+#define NIA_FM_CTL_AC_POST_BMI_ENQ_ORR          0x00000014
+#define NIA_FM_CTL_AC_POST_BMI_ENQ              0x00000022
 #define NIA_FM_CTL_AC_PRE_CC                    0x00000020
-#define NIA_FM_CTL_AC_SWITCH_PORT               0x00000020
-
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -425,11 +424,16 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA    0x00000202
 
 #define GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)   \
-    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd))?(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME): \
-                                                          (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME) : \
+                (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
 #define GET_NIA_BMI_AC_DISCARD_FRAME(h_FmPcd)   \
-    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd))?(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME): \
-                                                          (NIA_ENG_BMI | NIA_BMI_AC_DISCARD))
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME) : \
+                (NIA_ENG_BMI | NIA_BMI_AC_DISCARD))
+
+#define NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET       0x10
+#define NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET       0x14
 
 /**************************************************************************//**
  @Description       Port Id defines
@@ -620,21 +624,9 @@ switch(hdr)                                                 \
         num = ILLEGAL_HDR_NUM; break;                       \
 }
 
-/***********************************************************************/
-/*          SW parser patch flags                                      */
-/***********************************************************************/
-#if (DPAA_VERSION == 10)
-#define IP_FRAG_SW_PATCH_IPv4                   0x300
-#define IP_FRAG_SW_PATCH_IPv6                   0x31E
-
-#else
-#define IP_FRAG_SW_PATCH_IPv4                   0x300
-#define IP_FRAG_SW_PATCH_IPv6                   0x32C
-#endif /* (DPAA_VERSION == 10) */
-
-
 #define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
 
+
 /**************************************************************************//**
  @Description   A structure for initializing a keygen classification plan group
 *//***************************************************************************/
@@ -690,7 +682,6 @@ uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
 
-t_Error     FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 uint8_t     FmPcdKgGetSchemeId(t_Handle h_Scheme);
 #if (DPAA_VERSION >= 11)
 bool        FmPcdKgGetVspe(t_Handle h_Scheme);
@@ -739,7 +730,6 @@ uint32_t    FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
 uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
-t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
 uint16_t    FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile);
 t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
                                           e_FmPcdProfileTypeSelection   profileType,
@@ -756,7 +746,9 @@ uint32_t    FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red);
 void        FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId, uint32_t requiredAction);
 t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
 
-/* FM-PCD Coarse-Classification API routines */
+/***********************************************************************/
+/*          Common API for FM-PCD CC module                            */
+/***********************************************************************/
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
 uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
@@ -774,9 +766,24 @@ t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_Ne
 t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
+/***********************************************************************/
+/*          Common API for FM-PCD Manip module                            */
+/***********************************************************************/
 t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
 uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
 
+/***********************************************************************/
+/*          Common API for FM-Port module                            */
+/***********************************************************************/
+#if (DPAA_VERSION >= 11)
+typedef enum e_FmPortGprFuncType
+{
+    e_FM_PORT_GPR_EMPTY = 0,
+    e_FM_PORT_GPR_MURAM_PAGE
+} e_FmPortGprFuncType;
+
+t_Error     FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value);
+#endif /* DPAA_VERSION >= 11) */
 t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
@@ -1092,7 +1099,6 @@ t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
 void        FmUnregisterPcd(t_Handle h_Fm);
 t_Handle    FmGetPcdHandle(t_Handle h_Fm);
-bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
 t_Error     FmEnableRamsEcc(t_Handle h_Fm);
 t_Error     FmDisableRamsEcc(t_Handle h_Fm);
 void        FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
@@ -1131,20 +1137,24 @@ t_Error     FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
                                             uint8_t     priorityBitMap);
 
 #if (DPAA_VERSION >= 11)
-t_Error     FmVSPAlloc(t_Handle         h_Fm,
-                               e_FmPortType     portType,
-                               uint8_t          portId,
-                               uint8_t          numOfStorageProfiles);
+t_Error     FmVSPAllocForPort(t_Handle         h_Fm,
+                              e_FmPortType     portType,
+                              uint8_t          portId,
+                              uint8_t          numOfStorageProfiles);
 
-t_Error     FmVSPFree(  t_Handle        h_Fm,
-                        e_FmPortType    portType,
-                        uint8_t         portId);
+t_Error     FmVSPFreeForPort(t_Handle        h_Fm,
+                             e_FmPortType    portType,
+                             uint8_t         portId);
 
 t_Error     FmVSPGetAbsoluteProfileId(t_Handle      h_Fm,
                                       e_FmPortType  portType,
                                       uint8_t       portId,
                                       uint16_t      relativeProfile,
                                       uint16_t      *p_AbsoluteId);
+t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint16_t        relativeProfile);
 
 uintptr_t   FmGetVSPBaseAddr(t_Handle h_Fm);
 #endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index 8f45906..2220a1b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -56,7 +56,10 @@ t_Error     FmHcDumpRegs(t_Handle h_FmHc);
 
 void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
-t_Error     FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgSetScheme(t_Handle             h_FmHc,
+                               t_Handle             h_Scheme,
+                               t_FmPcdKgSchemeRegs  *p_SchemeRegs,
+                               bool                 updateCounter);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
@@ -69,7 +72,7 @@ uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
 
 t_Error     FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint32_t newAdAddrOffset);
 
-t_Error     FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
+t_Error     FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileRegs *p_PlcrRegs);
 t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
 
 t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 25eaf92..b266242 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -55,7 +55,7 @@
 /**************************************************************************//**
  @Group         FM_lib_grp FM library
 
- @Description   FM API functions, definitions and enum's.
+ @Description   FM API functions, definitions and enums
 
                 The FM module is the main driver module and is a mandatory module
                 for FM driver users. This module must be initialized first prior
@@ -64,7 +64,7 @@
                 HW modules: FPM, DMA, common QMI and common BMI initializations and
                 run-time control routines. This module must be initialized always
                 when working with any of the FM modules.
-                NOTE - We assume that the FMlibrary will be initialize only by core No. 0!
+                NOTE - We assume that the FM library will be initialized only by core No. 0!
 
  @{
 *//***************************************************************************/
@@ -144,16 +144,73 @@ typedef _Packed struct t_FmPrsResult {
 /**************************************************************************//**
  @Collection   FM Frame descriptor macros
 *//***************************************************************************/
-#define FM_FD_CMD_FCO               0x80000000  /**< Frame queue Context Override */
-#define FM_FD_CMD_RPD               0x40000000  /**< Read Prepended Data */
-#define FM_FD_CMD_UPD               0x20000000  /**< Update Prepended Data */
-#define FM_FD_CMD_DTC               0x10000000  /**< Do L4 Checksum */
-#define FM_FD_CMD_DCL4C             0x10000000  /**< Didn't calculate L4 Checksum */
-#define FM_FD_CMD_CFQ               0x00ffffff  /**< Confirmation Frame Queue */
-
-#define FM_FD_TX_STATUS_ERR_MASK    0x07000000  /**< TX Error FD bits */
-#define FM_FD_RX_STATUS_ERR_MASK    0x073ee3f8  /**< RX Error FD bits */
-#define FM_FD_RX_STATUS_ERR_NON_FM  0x00400000  /**< non Frame-Manager error */
+#define FM_FD_CMD_FCO                   0x80000000  /**< Frame queue Context Override */
+#define FM_FD_CMD_RPD                   0x40000000  /**< Read Prepended Data */
+#define FM_FD_CMD_UPD                   0x20000000  /**< Update Prepended Data */
+#define FM_FD_CMD_DTC                   0x10000000  /**< Do L4 Checksum */
+#define FM_FD_CMD_DCL4C                 0x10000000  /**< Didn't calculate L4 Checksum */
+#define FM_FD_CMD_CFQ                   0x00ffffff  /**< Confirmation Frame Queue */
+
+#define FM_FD_ERR_UNSUPPORTED_FORMAT    0x04000000  /**< Not for Rx-Port! Unsupported Format */
+#define FM_FD_ERR_LENGTH                0x02000000  /**< Not for Rx-Port! Length Error */
+#define FM_FD_ERR_DMA                   0x01000000  /**< DMA Data error */
+
+#define FM_FD_IPR                       0x00000001  /**< IPR frame (not error) */
+
+#define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
+#define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
+#define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
+#define FM_FD_ERR_IPF                   0x00100000                  /**< IPF error */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_FD_ERR_CRE                   0x00200000
+#define FM_FD_ERR_CHE                   0x00100000
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_FD_ERR_PHYSICAL              0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                         Sequence error, PHY error control character detected. */
+#define FM_FD_ERR_SIZE                  0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_FD_ERR_CLS_DISCARD           0x00020000  /**< classification discard */
+#define FM_FD_ERR_EXTRACTION            0x00008000  /**< Extract Out of Frame */
+#define FM_FD_ERR_NO_SCHEME             0x00004000  /**< No Scheme Selected */
+#define FM_FD_ERR_KEYSIZE_OVERFLOW      0x00002000  /**< Keysize Overflow */
+#define FM_FD_ERR_COLOR_RED             0x00000800  /**< Frame color is red */
+#define FM_FD_ERR_COLOR_YELLOW          0x00000400  /**< Frame color is yellow */
+#define FM_FD_ERR_ILL_PLCR              0x00000200  /**< Illegal Policer Profile selected */
+#define FM_FD_ERR_PLCR_FRAME_LEN        0x00000100  /**< Policer frame length error */
+#define FM_FD_ERR_PRS_TIMEOUT           0x00000080  /**< Parser Time out Exceed */
+#define FM_FD_ERR_PRS_ILL_INSTRUCT      0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_FD_ERR_PRS_HDR_ERR           0x00000020  /**< Header error was identified during parsing */
+#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008  /**< Frame parsed beyind 256 first bytes */
+
+#define FM_FD_TX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA) /**< TX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA                  | \
+                                         FM_FD_ERR_IPR                  | \
+                                         FM_FD_ERR_IPR_TO               | \
+                                         FM_FD_ERR_IPR_NCSP             | \
+                                         FM_FD_ERR_IPF                  | \
+                                         FM_FD_ERR_PHYSICAL             | \
+                                         FM_FD_ERR_SIZE                 | \
+                                         FM_FD_ERR_CLS_DISCARD          | \
+                                         FM_FD_ERR_COLOR_RED            | \
+                                         FM_FD_ERR_COLOR_YELLOW         | \
+                                         FM_FD_ERR_ILL_PLCR             | \
+                                         FM_FD_ERR_PLCR_FRAME_LEN       | \
+                                         FM_FD_ERR_EXTRACTION           | \
+                                         FM_FD_ERR_NO_SCHEME            | \
+                                         FM_FD_ERR_KEYSIZE_OVERFLOW     | \
+                                         FM_FD_ERR_PRS_TIMEOUT          | \
+                                         FM_FD_ERR_PRS_ILL_INSTRUCT     | \
+                                         FM_FD_ERR_PRS_HDR_ERR          | \
+                                         FM_FD_ERR_BLOCK_LIMIT_EXCEEDED) /**< RX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_NON_FM      0x00400000  /**< non Frame-Manager error */
 /* @} */
 
 /**************************************************************************//**
@@ -402,7 +459,7 @@ typedef struct t_FmBufPoolDepletion {
 } t_FmBufPoolDepletion;
 
 /**************************************************************************//**
- @Description   A Structure for defining Ucode patch for loading.
+ @Description   A structure for defining Ucode patch for loading.
 *//***************************************************************************/
 typedef struct t_FmFirmwareParams {
     uint32_t                size;                   /**< Size of uCode */
@@ -415,30 +472,25 @@ typedef struct t_FmFirmwareParams {
 typedef struct t_FmParams {
     uint8_t                 fmId;                   /**< Index of the FM */
     uint8_t                 guestId;                /**< FM Partition Id */
-    uintptr_t               baseAddr;               /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         A pointer to base of memory mapped FM registers (virtual);
+    uintptr_t               baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual);
                                                          NOTE that this should include ALL common registers of the FM including
                                                          the PCD registers area (i.e. until the VSP pages - 880KB). */
-    t_Handle                h_FmMuram;              /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         A handle of an initialized MURAM object,
-                                                         to be used by the FM */
-    uint16_t                fmClkFreq;              /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         In Mhz */
-    t_FmExceptionsCallback  *f_Exception;           /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         An application callback routine to
-                                                         handle exceptions.*/
-    t_FmBusErrorCallback    *f_BusError;            /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         An application callback routine to
-                                                         handle exceptions.*/
-    t_Handle                h_App;                  /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         A handle to an application layer object; This handle will
-                                                         be passed by the driver upon calling the above callbacks */
-    int                     irq;                    /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         FM interrupt source for normal events */
-    int                     errIrq;                 /**< Relevant when guestId = NCSW_MASTER_ID only;
-                                                         FM interrupt source for errors */
-    t_FmFirmwareParams      firmware;               /**< The firmware parameters structure;
-                                                         Relevant when guestId = NCSW_MASTER_ID only. */
+    t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
+                                                         to be used by the FM. */
+    uint16_t                fmClkFreq;              /**< In Mhz. */
+
+    t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to handle exceptions. */
+
+    t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to handle exceptions. */
+
+    t_Handle                h_App;                  /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks. */
+
+    int                     irq;                    /**< FM interrupt source for normal events. */
+
+    int                     errIrq;                 /**< FM interrupt source for errors. */
+
+    t_FmFirmwareParams      firmware;               /**< The firmware parameters structure. */
 
 #if (DPAA_VERSION >= 11)
     uintptr_t               vspBaseAddr;            /**< A pointer to base of memory mapped FM VSP registers (virtual);
@@ -591,6 +643,42 @@ typedef struct t_FmDmaEmergency {
 } t_FmDmaEmergency;
 
 /**************************************************************************//**
+ @Description   structure for defining FM threshold
+*//***************************************************************************/
+typedef struct t_FmThresholds {
+    uint8_t                 dispLimit;                      /**< The number of times a frames may
+                                                                 be passed in the FM before assumed to
+                                                                 be looping. */
+    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the parser dispatch queue*/
+    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
+                                                                 queued in the policer dispatch queue*/
+    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
+                                                                 queued in the keygen dispatch queue*/
+    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the BMI dispatch queue*/
+    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI enqueue dispatch queue*/
+    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI dequeue dispatch queue*/
+    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl1 dispatch queue*/
+    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl2 dispatch queue*/
+} t_FmThresholds;
+
+/**************************************************************************//**
+ @Description   structure for defining DMA thresholds
+*//***************************************************************************/
+typedef struct t_FmDmaThresholds {
+    uint8_t                     assertEmergency;            /**< When this value is reached,
+                                                                 assert emergency (Threshold)*/
+    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
+                                                                 until this value is reached (Hystheresis) */
+} t_FmDmaThresholds;
+
+
+/**************************************************************************//**
  @Function      FM_ConfigResetOnInit
 
  @Description   Define whether to reset the FM before initialization.
@@ -602,8 +690,6 @@ typedef struct t_FmDmaEmergency {
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
@@ -620,8 +706,6 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
 
@@ -638,8 +722,6 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
 
@@ -656,8 +738,6 @@ t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverr
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
 
@@ -674,8 +754,6 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
 
@@ -692,8 +770,6 @@ t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 
@@ -710,8 +786,6 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
 
@@ -727,8 +801,6 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
 
@@ -745,8 +817,6 @@ t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
 
@@ -765,8 +835,6 @@ t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
                 Only if bus error is enabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
 
@@ -784,8 +852,6 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
 
@@ -804,8 +870,6 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 
@@ -823,8 +887,6 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
 
@@ -842,8 +904,6 @@ t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
 
@@ -853,14 +913,13 @@ t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophic
  @Description   Enable MURAM test mode.
                 Calling this routine changes the internal driver data base
                 from its default selection of test mode where it's disabled.
+                This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm    A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
 
@@ -870,14 +929,13 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
  @Description   Enable IRAM test mode.
                 Calling this routine changes the internal driver data base
                 from its default selection of test mode where it's disabled.
+                This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm    A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
 
@@ -896,8 +954,6 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
 
@@ -908,6 +964,7 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
                 Calling this routine changes the FM behavior on unrecoverable
                 ECC error in the internal driver data base from its default
                 [FALSE].
+                This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     enable          TRUE to enable halt on unrecoverable Ecc error
@@ -915,8 +972,6 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
 
@@ -934,8 +989,6 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
@@ -954,8 +1007,6 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 
@@ -976,48 +1027,10 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
-
-/**************************************************************************//*
- @Description   structure for defining FM threshold
-*//***************************************************************************/
-typedef struct t_FmThresholds {
-    uint8_t                 dispLimit;                      /**< The number of times a frames may
-                                                                 be passed in the FM before assumed to
-                                                                 be looping. */
-    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
-                                                                 queued in the parser dispatch queue*/
-    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
-                                                                 queued in the policer dispatch queue*/
-    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
-                                                                 queued in the keygen dispatch queue*/
-    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
-                                                                 queued in the BMI dispatch queue*/
-    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in the QMI enqueue dispatch queue*/
-    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in the QMI dequeue dispatch queue*/
-    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in fmCtl1 dispatch queue*/
-    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in fmCtl2 dispatch queue*/
-} t_FmThresholds;
-
-/**************************************************************************//*
- @Description   structure for defining DMA thresholds
-*//***************************************************************************/
-typedef struct t_FmDmaThresholds {
-    uint8_t                     assertEmergency;            /**< When this value is reached,
-                                                                 assert emergency (Threshold)*/
-    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
-                                                                 until this value is reached (Hystheresis) */
-} t_FmDmaThresholds;
-
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ConfigThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1032,19 +1045,16 @@ typedef struct t_FmDmaThresholds {
                     fmCtl1DispTh: [16]
                     fmCtl2DispTh: [16]
 
-
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     p_FmThresholds  A structure of threshold parameters.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ConfigDmaSosEmergencyThreshold
 
  @Description   Calling this routine changes the internal driver data base
@@ -1056,18 +1066,17 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ConfigDmaWriteBufThresholds
 
  @Description   Calling this routine changes the internal driver data base
                 from its default configuration of DMA write buffer threshold
                 assertEmergency: [DMA_THRESH_MAX_BUF]
                 clearEmergency:  [DMA_THRESH_MAX_BUF]
+                This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
@@ -1077,12 +1086,10 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
- /**************************************************************************//*
+ /**************************************************************************//**
  @Function      FM_ConfigDmaCommQThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1098,18 +1105,17 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ConfigDmaReadBufThresholds
 
  @Description   Calling this routine changes the internal driver data base
                 from its default configuration of DMA read buffer threshold
                 assertEmergency: [DMA_THRESH_MAX_BUF]
                 clearEmergency:  [DMA_THRESH_MAX_BUF]
+                This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
@@ -1119,12 +1125,10 @@ t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThr
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ConfigDmaWatchdog
 
  @Description   Calling this routine changes the internal driver data base
@@ -1137,8 +1141,6 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
 
@@ -1149,7 +1151,7 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
 /**************************************************************************//**
  @Group         FM_runtime_control_grp FM Runtime Control Unit
 
- @Description   FM Runtime control unit API functions, definitions and enum's.
+ @Description   FM Runtime control unit API functions, definitions and enums.
                 The FM driver provides a set of control routines.
                 These routines may only be called after the module was fully
                 initialized (both configuration and initialization routines were
@@ -1171,7 +1173,7 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
 /* @} */
 
 /**************************************************************************//**
- @Description   A Structure for Port bandwidth requirement. Port is identified
+ @Description   A structure for Port bandwidth requirement. Port is identified
                 by type and relative id.
 *//***************************************************************************/
 typedef struct t_FmPortBandwidth {
@@ -1219,7 +1221,7 @@ typedef enum e_FmCounters {
 } e_FmCounters;
 
 /**************************************************************************//**
- @Description   A Structure for returning FM revision information
+ @Description   A structure for returning FM revision information
 *//***************************************************************************/
 typedef struct t_FmRevisionInfo {
     uint8_t         majorRev;               /**< Major revision */
@@ -1227,7 +1229,7 @@ typedef struct t_FmRevisionInfo {
 } t_FmRevisionInfo;
 
 /**************************************************************************//**
- @Description   A Structure for returning FM ctrl code revision information
+ @Description   A structure for returning FM ctrl code revision information
 *//***************************************************************************/
 typedef struct t_FmCtrlCodeRevisionInfo {
     uint16_t        packageRev;             /**< Package revision */
@@ -1236,7 +1238,7 @@ typedef struct t_FmCtrlCodeRevisionInfo {
 } t_FmCtrlCodeRevisionInfo;
 
 /**************************************************************************//**
- @Description   A Structure for defining DMA status
+ @Description   A structure for defining DMA status
 *//***************************************************************************/
 typedef struct t_FmDmaStatus {
     bool    cmqNotEmpty;            /**< Command queue is not empty */
@@ -1282,8 +1284,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
@@ -1299,8 +1299,6 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
 
@@ -1320,8 +1318,6 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_EnableRamsEcc(t_Handle h_Fm);
 
@@ -1341,8 +1337,6 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_DisableRamsEcc(t_Handle h_Fm);
 
@@ -1403,8 +1397,6 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
 
@@ -1418,8 +1410,6 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_Resume(t_Handle h_Fm);
 
@@ -1435,8 +1425,6 @@ void FM_Resume(t_Handle h_Fm);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
 
@@ -1451,8 +1439,6 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
 
@@ -1580,8 +1566,7 @@ t_Error FM_CtrlMonStop(t_Handle h_Fm);
 *//***************************************************************************/
 t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
 
-
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
@@ -1593,8 +1578,6 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
                 or is not able to create interrupt.
 
  @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 62459c0..1c188e6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -336,6 +336,9 @@ t_Error FM_MAC_ConfigWan(t_Handle h_FmMac, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+                Not supported on 10G-MAC (i.e. CRC & PAD are added automatically
+                by HW); on mEMAC, this routine supports only PAD (i.e. CRC is
+                added automatically by HW).
 *//***************************************************************************/
 t_Error FM_MAC_ConfigPadAndCrc(t_Handle h_FmMac, bool enable);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 85e2824a..9231103 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -65,7 +65,7 @@
                 and the policer global and common registers.
                 In addition, the FM PCD SW module will initialize all required
                 key generator schemes, coarse classification flows, and policer
-                profiles. When FM module is configured to work with one of these
+                profiles. When an FM module is configured to work with one of these
                 entities, it will register to it using the FM PORT API. The PCD
                 module will manage the PCD resources - i.e. resource management of
                 KeyGen schemes, etc.
@@ -231,17 +231,21 @@ typedef struct t_FmPcdParams {
     bool                        kgSupport;              /**< TRUE if KeyGen will be used for any of the FM ports. */
     bool                        plcrSupport;            /**< TRUE if Policer will be used for any of the FM ports. */
     t_Handle                    h_Fm;                   /**< A handle to the FM module. */
-    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
+    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition.
+                                                             this parameter is relevant if 'kgSupport'=TRUE. */
     bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
-    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if useHostCommand = TRUE. */
-
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions;
-                                                             Relevant for master (or single) partition only. */
-    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or Policer profile
-                                                             exceptions; Relevant for master (or single) partition only. */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand' = TRUE. */
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions. */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or
+                                                             Policer profile exceptions. */
     t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
-                                                             be passed by the driver upon calling the above callbacks;
-                                                             Relevant for master (or single) partition only. */
+                                                             be passed by the driver upon calling the above callbacks. */
+    uint8_t                     partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
+                                                             this parameter is relevant if 'plcrSupport'=TRUE.
+                                                             NOTE: this parameter relevant only when working with multiple partitions. */
+    uint16_t                    partNumOfPlcrProfiles;  /**< Number of policer-profiles dedicated to this partition.
+                                                             this parameter is relevant if 'plcrSupport'=TRUE.
+                                                             NOTE: this parameter relevant only when working with multiple partitions. */
 } t_FmPcdParams;
 
 
@@ -293,24 +297,20 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd);
  @Function      FM_PCD_ConfigException
 
  @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enabling.
-                [4].
+                from its default selection of all exceptions being enabled.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
  @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
 
  @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
 /**************************************************************************//**
  @Function      FM_PCD_ConfigHcFramesDataMemory
 
- @Description   Configures memory partition for FMan-Controller Host-Command
+ @Description   Configures memory-partition-id for FMan-Controller Host-Command
                 frames. Calling this routine changes the internal driver data
                 base from its default configuration [0].
 
@@ -321,8 +321,6 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
 
  @Cautions      This routine may be called only if 'useHostCommand' was TRUE
                 when FM_PCD_Config() routine was called.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
 
@@ -346,15 +344,12 @@ t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSha
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
-                By default auto-refresh is enabled.
+                By default auto-refresh is [disabled].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     enable          TRUE to enable, FALSE to disable
 
  @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
 
@@ -370,9 +365,6 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
                                 maximum parsing time.
 
  @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
 
@@ -392,7 +384,6 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
                 of PCD modules such as KeyGen schemes, coarse classification nodes
                 and Policer profiles.
 
-
                 In order to explain the programming model of the PCD driver interface
                 a few terms should be explained, and will be used below.
                   - Distinction Header - One of the 16 protocols supported by the FM parser,
@@ -517,8 +508,6 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
 @Return         E_OK on success; Error code otherwise.
 
 @Cautions       Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
 
@@ -533,8 +522,6 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
 @Return        E_OK on success; Error code otherwise.
 
 @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
 
@@ -553,8 +540,6 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
 
@@ -570,8 +555,6 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
 
@@ -587,8 +570,6 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
@@ -604,8 +585,6 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
 
@@ -621,8 +600,6 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -637,8 +614,6 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
  @Return        None
 
  @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -654,8 +629,6 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
                 or is not able to create interrupt.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
 
@@ -756,7 +729,7 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 
 
 /**************************************************************************//**
- KeyGen         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
+ @Group         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
 
  @Description   Frame Manager PCD Runtime Building API
 
@@ -775,10 +748,11 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 #define FM_PCD_MAX_NUM_OF_CC_GROUPS             16
 #define FM_PCD_MAX_NUM_OF_CC_UNITS              4
 #define FM_PCD_MAX_NUM_OF_KEYS                  256
+#define FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
 #define FM_PCD_MAX_SIZE_OF_KEY                  56
 #define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
 #define FM_PCD_LAST_KEY_INDEX                   0xffff
-
+#define FM_PCD_MANIP_DSCP_VALUES                64
 /* @} */
 
 /**************************************************************************//**
@@ -817,6 +791,44 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
                                                      environment with IPV6 header and IPV6_FRAG_1 option  */
 /* @} */
 
+#define FM_PCD_MANIP_MAX_HDR_SIZE               256
+#define FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+/**************************************************************************//**
+ @Collection    A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t                hdrManipFlags_t;            /**< A general type to define a HMan update command flags. */
+
+typedef hdrManipFlags_t         ipv4HdrManipUpdateFlags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV4_TOS      0x80000000                  /**< update TOS with the given value ('tos' field
+                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_ID       0x40000000                  /**< update IP ID with the given value ('id' field
+                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_TTL      0x20000000                  /**< Decrement TTL by 1 */
+#define HDR_MANIP_IPV4_SRC      0x10000000                  /**< update IP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_DST      0x08000000                  /**< update IP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+
+typedef hdrManipFlags_t         ipv6HdrManipUpdateFlags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV6_TC       0x80000000                  /**< update Traffic Class address with the given value
+                                                                 ('trafficClass' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_HL       0x40000000                  /**< Decrement Hop Limit by 1 */
+#define HDR_MANIP_IPV6_SRC      0x20000000                  /**< update IP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_DST      0x10000000                  /**< update IP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+
+typedef hdrManipFlags_t         tcpUdpHdrManipUpdateFlags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define HDR_MANIP_TCP_UDP_SRC       0x80000000              /**< update TCP/UDP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_DST       0x40000000              /**< update TCP/UDP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000             /**< update TCP/UDP checksum */
+
+/* @} */
 
 /**************************************************************************//**
  @Description   A type used for returning the order of the key extraction.
@@ -957,10 +969,10 @@ typedef enum e_FmPcdPlcrColorMode {
  @Description   Enumeration type for selecting a policer profile color
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrColor {
-    e_FM_PCD_PLCR_GREEN,                /**< Green color code */
-    e_FM_PCD_PLCR_YELLOW,               /**< Yellow color code */
-    e_FM_PCD_PLCR_RED,                  /**< Red color code */
-    e_FM_PCD_PLCR_OVERRIDE              /**< Color override code */
+    e_FM_PCD_PLCR_GREEN,                /**< Green */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
+    e_FM_PCD_PLCR_RED,                  /**< Red */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
 } e_FmPcdPlcrColor;
 
 /**************************************************************************//**
@@ -1022,9 +1034,7 @@ typedef enum e_FmPcdAction {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtType {
     e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
-#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 #ifdef FM_CAPWAP_SUPPORT
     e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
@@ -1035,22 +1045,76 @@ typedef enum e_FmPcdManipHdrInsrtType {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvType {
     e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 } e_FmPcdManipHdrRmvType;
 
+/**************************************************************************//**
+ @Description   An enum for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrRmvSpecificL2 {
+    e_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
+    e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
+    e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
+                                                         the header which follows the MPLS header */
+    e_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+} e_FmPcdManipHdrRmvSpecificL2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrFieldUpdateType {
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,               /**< VLAN updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,               /**< IPV4 updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,               /**< IPV6 updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,            /**< TCP_UDP updates */
+} e_FmPcdManipHdrFieldUpdateType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrFieldUpdateVlan {
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
+} e_FmPcdManipHdrFieldUpdateVlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
+    e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+} e_FmPcdManipHdrInsrtSpecificL2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrInsrtByHdrType {
+    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+} e_FmPcdManipHdrInsrtByHdrType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific customCommand
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrCustomType {
+    e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
+} e_FmPcdManipHdrCustomType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific customCommand
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrCustomIpReplace {
+    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6,           /**< Replace IPv4 by IPv6 */
+    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4            /**< Replace IPv6 by IPv4 */
+} e_FmPcdManipHdrCustomIpReplace;
 
-#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvByHdrType {
 #ifdef FM_CAPWAP_SUPPORT
-    e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
+    e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
 #endif /* FM_CAPWAP_SUPPORT */
+    e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2           /**< Specific L2 fields removal */
 } e_FmPcdManipHdrRmvByHdrType;
-#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of timeout mode
@@ -1098,8 +1162,10 @@ typedef enum e_FmPcdManipType {
  @Description   Enumeration type for selecting type of statistics mode
 *//***************************************************************************/
 typedef enum e_FmPcdCcStatsMode {
-    e_FM_PCD_CC_STATS_MODE_NONE = 0,    /**< No statistics support */
-    e_FM_PCD_CC_STATS_MODE_FRAME        /**< Frame count statistics */
+    e_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
+    e_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
+    e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+    e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
 } e_FmPcdCcStatsMode;
 
 /**************************************************************************//**
@@ -1108,7 +1174,7 @@ typedef enum e_FmPcdCcStatsMode {
 *//***************************************************************************/
 typedef enum e_FmPcdManipDontFragAction {
     e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,  /**< Discard packet */
-    e_FM_PCD_MANIP_FRAGMENT_PACKECT,                    /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_FRAGMENT_PACKET,                     /**< Fragment packet and continue normal processing */
     e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
 } e_FmPcdManipDontFragAction;
 
@@ -1289,8 +1355,7 @@ typedef struct t_FmPcdDistinctionUnit {
                 by a specific PCD Network Environment Characteristics module.
 
                 Each unit represent a protocol or a group of protocols that may
-                be used later by the different PCD engined to distinguish
-                between flows.
+                be used later by the different PCD engines to distinguish between flows.
 *//***************************************************************************/
 typedef struct t_FmPcdNetEnvParams {
     uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
@@ -1558,6 +1623,14 @@ typedef struct t_FmPcdKgSchemeParams {
 } t_FmPcdKgSchemeParams;
 
 /**************************************************************************//**
+ @Collection
+*//***************************************************************************/
+#define FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
+#define FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
+#define FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
  @Description   Parameters for defining CC as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextCcParams {
@@ -1650,11 +1723,9 @@ typedef struct t_FmPcdCcNextEngineParams {
         t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
 #endif /* (DPAA_VERSION >= 11) */
     } params;                                           /**< union used for all the next-engine parameters options */
-
     t_Handle                            h_Manip;        /**< Handle to Manipulation object.
                                                              Relevant if next engine is of type result
                                                              (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
-
     bool                                statisticsEn;   /**< If TRUE, statistics counters are incremented
                                                              for each frame passing through this
                                                              Coarse Classification entry. */
@@ -1707,6 +1778,17 @@ typedef struct t_KeysParams {
     e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
                                                      the requested statistics mode will be allocated according to
                                                      'maxNumOfKeys'. */
+    uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics
+                                                     mode.
+                                                     Holds a list of programmable thresholds. For each received frame,
+                                                     its length in bytes is examined against these range thresholds and
+                                                     the appropriate counter is incremented by 1. For example, to belong
+                                                     to range i, the following should hold:
+                                                     range i-1 threshold < frame length <= range i threshold
+                                                     Each range threshold must be larger then its preceding range
+                                                     threshold. Last range threshold must be 0xFFFF. */
+
     uint16_t                    numOfKeys;      /**< Number of initial keys;
                                                      Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
                                                      this field should be power-of-2 of the number of bits that are
@@ -1795,6 +1877,27 @@ typedef struct t_FmPcdCcTreeParams {
 } t_FmPcdCcTreeParams;
 
 /**************************************************************************//**
+ @Description   CC key statistics structure
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyStatistics {
+    uint32_t    byteCount;      /**< This counter reflects byte count of frames that
+                                     were matched this key. */
+    uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                /**< These counters reflect how many frames passed that
+                                     were matched this key.
+                                     For 'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FLR'
+                                     statistics mode:
+                                     Each counter holds the number of frames of a
+                                     specific frames length range, according to the
+                                     ranges provided at initialization.
+                                     For 'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME'
+                                     statistics mode:
+                                     The first counter holds the number of frames that
+                                     were matched to this key.
+                                   */
+} t_FmPcdCcKeyStatistics;
+
+/**************************************************************************//**
  @Description   Parameters for defining policer byte rate
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrByteRateModeParams {
@@ -1865,6 +1968,7 @@ typedef struct t_FmPcdPlcrProfileParams {
     bool                                trapProfileOnFlowC;         /**< Trap on flow C */
 } t_FmPcdPlcrProfileParams;
 
+#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
@@ -1876,7 +1980,6 @@ typedef struct t_FmManipHdrInfo
     t_FmPcdFields                       fullField;      /**< Relevant only when byField = TRUE: Extract field */
 } t_FmManipHdrInfo;
 
-#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Description   Parameters for defining an insertion manipulation
                 of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
@@ -1969,7 +2072,6 @@ typedef struct t_FmPcdManipFragOrReasmParams {
 
 #endif /* FM_CAPWAP_SUPPORT */
 
-#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Parameters for defining header removal by header type
 *//***************************************************************************/
@@ -1983,9 +2085,10 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
             t_FmManipHdrInfo            hdrInfo;
         } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
 #endif /* FM_CAPWAP_SUPPORT */
+        e_FmPcdManipHdrRmvSpecificL2    specificL2;     /**< Relevant when type = e_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+                                                             Defines which L2 headers to remove. */
     } u;
 } t_FmPcdManipHdrRmvByHdrParams;
-#endif /* defined(FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Parameters for configuring IP fragmentation manipulation
@@ -2004,9 +2107,15 @@ typedef struct t_FmPcdManipFragIpParams {
                                                              of this pool need to be allocated in the same memory area as the received buffers.
                                                              If the received buffers arrive from different sources, the Scatter/Gather BP id should be
                                                              mutual to all these sources. */
-    e_FmPcdManipDontFragAction  dontFragAction;         /**< Dont Fragment Action - If an IP packet is larger
+    e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
                                                              than MTU and its DF bit is set, then this field will
                                                              determine the action to be taken.*/
+#ifdef ALU_CUSTOM
+    bool                        optionsCounterEn;       /**< If TRUE, A counter is incremented each time an IPv4 frame with IPv4 Options
+                                                             is encountered and the COPIED flag on one of the options is cleared.
+                                                             The counter is located on the port page */
+#endif /* ALU_CUSTOM */
+
 } t_FmPcdManipFragIpParams;
 
 /**************************************************************************//**
@@ -2021,13 +2130,21 @@ typedef struct t_FmPcdManipReassemIpParams {
                                                                  relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
                                                                  relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassemblys schemes will be first match.
+                                                                 the user schemes id to ensure that the reassembly's schemes will be first match;
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
+#if (DPAA_VERSION >= 11)
+    uint32_t                        nonConsistentSpFqid;    /**< In case that other fragments of the frame corresponds to different storage
+                                                                 profile than the opening fragment (Non-Consistent-SP state)
+                                                                 then one of two possible scenarios occurs:
+                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
     uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* (DPAA_VERSION >= 11) */
     uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
     uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
     uint16_t                        minFragSize[2];         /**< Minimum fragment size:
-                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+                                                                 minFragSize[0] - for IPv4, minFragSize[1] - for IPv6 */
     e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
                                                             /**< Number of frames per hash entry needed for reassembly process:
                                                                  numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
@@ -2046,16 +2163,20 @@ typedef struct t_FmPcdManipReassemIpParams {
 } t_FmPcdManipReassemIpParams;
 
 /**************************************************************************//**
- @Description   structure for defining IPSEC manipulation
+ @Description   Parameters for defining IPSEC manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
-    bool    decryption;                     /**< TRUE if being used in decryption direction;
-                                                 FALSE if being used in encryption direction. */
-    bool    ecnCopy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
-                                                 (direction depends on the 'decryption' field). */
-    bool    dscpCopy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
-                                                 (direction depends on the 'decryption' field). */
-    bool    variableIpHdrLen;               /**< TRUE for supporting variable IP header length in decryption. */
+    bool        decryption;                     /**< TRUE if being used in decryption direction;
+                                                     FALSE if being used in encryption direction. */
+    bool        ecnCopy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                     (direction depends on the 'decryption' field). */
+    bool        dscpCopy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                     (direction depends on the 'decryption' field). */
+    bool        variableIpHdrLen;               /**< TRUE for supporting variable IP header length in decryption. */
+    bool        variableIpVersion;              /**< TRUE for supporting both IP version on the same SA in encryption */
+    uint8_t     outerIPHdrLen;                  /**< if 'variableIpVersion == TRUE' than this field must be set to non-zero value;
+                                                     It is specifies the length of the outer IP header that was configured in the
+                                                     corresponding SA. */
 } t_FmPcdManipSpecialOffloadIPSecParams;
 
 /**************************************************************************//**
@@ -2091,6 +2212,138 @@ typedef struct t_FmPcdManipHdrInsrtGenericParams {
     uint8_t                         *p_Data;        /**< Pointer to data to be inserted */
 } t_FmPcdManipHdrInsrtGenericParams;
 
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateVlanDscpToVpri {
+    uint8_t                         dscpToVpriTable[FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+                                                        /**< A table of VPri values for each DSCP value;
+                                                             The index is the DSCP value (0-0x3F) and the
+                                                             value is the corresponding VPRI (0-15). */
+    uint8_t                         vpriDefVal;         /**< 0-7, Relevant only if if updateType =
+                                                             e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+                                                             this field is the Q Tag default value if the
+                                                             IP header is not found. */
+} t_FmPcdManipHdrFieldUpdateVlanDscpToVpri;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateVlan {
+    e_FmPcdManipHdrFieldUpdateVlan  updateType;         /**< Selects VLAN update type */
+    union {
+        uint8_t                                     vpri;       /**< 0-7, Relevant only if If updateType =
+                                                                     e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+                                                                     is the new VLAN pri. */
+        t_FmPcdManipHdrFieldUpdateVlanDscpToVpri    dscpToVpri;/**<  Parameters structure, Relevant only if updateType
+                                                                     = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+    } u;
+} t_FmPcdManipHdrFieldUpdateVlan;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateIpv4 {
+    ipv4HdrManipUpdateFlags_t       validUpdates;       /**< ORed flag, selecting the required updates */
+    uint8_t                         tos;                /**< 8 bit New TOS; Relevant if validUpdates contains
+                                                             HDR_MANIP_IPV4_TOS */
+    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_ID */
+    uint32_t                        src;                /**< 32 bit New IP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_SRC */
+    uint32_t                        dst;                /**< 32 bit New IP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_DST */
+} t_FmPcdManipHdrFieldUpdateIpv4;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateIpv6 {
+    ipv6HdrManipUpdateFlags_t   validUpdates;           /**< ORed flag, selecting the required updates */
+    uint8_t                     trafficClass;           /**< 8 bit New Traffic Class; Relevant if validUpdates contains
+                                                             HDR_MANIP_IPV6_TC */
+    uint8_t                     src[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                        /**< 16 byte new IP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV6_SRC */
+    uint8_t                     dst[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                        /**< 16 byte new IP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV6_DST */
+} t_FmPcdManipHdrFieldUpdateIpv6;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateTcpUdp {
+    tcpUdpHdrManipUpdateFlags_t     validUpdates;       /**< ORed flag, selecting the required updates */
+    uint16_t                        src;                /**< 16 bit New TCP/UDP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_TCP_UDP_SRC */
+    uint16_t                        dst;                /**< 16 bit New TCP/UDP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_TCP_UDP_DST */
+} t_FmPcdManipHdrFieldUpdateTcpUdp;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateParams {
+    e_FmPcdManipHdrFieldUpdateType                  type;           /**< Type of header field update manipulation */
+    union {
+        t_FmPcdManipHdrFieldUpdateVlan              vlan;           /**< Parameters for VLAN update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+        t_FmPcdManipHdrFieldUpdateIpv4              ipv4;           /**< Parameters for IPv4 update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+        t_FmPcdManipHdrFieldUpdateIpv6              ipv6;           /**< Parameters for IPv6 update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+        t_FmPcdManipHdrFieldUpdateTcpUdp            tcpUdp;         /**< Parameters for TCP/UDP update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+    } u;
+} t_FmPcdManipHdrFieldUpdateParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrCustomIpHdrReplace {
+    e_FmPcdManipHdrCustomIpReplace  replaceType;        /**< Selects replace update type */
+    bool                            decTtlHl;           /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1  */
+    bool                            updateIpv4Id;       /**< Relevant when replaceType =
+                                                             e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if
+                                                             updateIpv4Id = TRUE */
+    uint8_t                         hdrSize;            /**< The size of the new IP header */
+    uint8_t                         hdr[FM_PCD_MANIP_MAX_HDR_SIZE];
+                                                        /**< The new IP header */
+} t_FmPcdManipHdrCustomIpHdrReplace;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrCustomParams {
+    e_FmPcdManipHdrCustomType               type;           /**< Type of header field update manipulation */
+    union {
+        t_FmPcdManipHdrCustomIpHdrReplace   ipHdrReplace;   /**< Parameters IP header replacement */
+    } u;
+} t_FmPcdManipHdrCustomParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
+    e_FmPcdManipHdrInsrtSpecificL2  specificL2;     /**< Selects which L2 headers to insert */
+    bool                            update;         /**< TRUE to update MPLS header */
+    uint8_t                         size;           /**< size of inserted section */
+    uint8_t                         *p_Data;        /**< data to be inserted */
+} t_FmPcdManipHdrInsrtSpecificL2Params;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtByHdrParams {
+    e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
+    union {
+       t_FmPcdManipHdrInsrtSpecificL2Params     specificL2Params;
+                                                        /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                             Selects which L2 headers to remove */
+    } u;
+} t_FmPcdManipHdrInsrtByHdrParams;
 
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation
@@ -2098,6 +2351,8 @@ typedef struct t_FmPcdManipHdrInsrtGenericParams {
 typedef struct t_FmPcdManipHdrInsrtParams {
     e_FmPcdManipHdrInsrtType                    type;       /**< Type of insertion manipulation */
     union {
+        t_FmPcdManipHdrInsrtByHdrParams         byHdr;      /**< Parameters for defining header insertion manipulation by header type,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_HDR */
         t_FmPcdManipHdrInsrtGenericParams       generic;    /**< Parameters for defining generic header insertion manipulation,
                                                                  relevant if 'type' = e_FM_PCD_MANIP_INSRT_GENERIC */
 #ifdef FM_CAPWAP_SUPPORT
@@ -2113,10 +2368,8 @@ typedef struct t_FmPcdManipHdrInsrtParams {
 typedef struct t_FmPcdManipHdrRmvParams {
     e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
     union {
-#if defined(FM_CAPWAP_SUPPORT)
         t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
-#endif /* defined (FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
         t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
     } u;
@@ -2132,6 +2385,11 @@ typedef struct t_FmPcdManipHdrParams {
     bool                                        insrt;              /**< TRUE, to define insertion manipulation */
     t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
 
+    bool                                        fieldUpdate;        /**< TRUE, to define field update manipulation */
+    t_FmPcdManipHdrFieldUpdateParams            fieldUpdateParams;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
+
+    bool                                        custom;             /**< TRUE, to define custom manipulation */
+    t_FmPcdManipHdrCustomParams                 customParams;       /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
 
     bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
                                                                          completing the manipulation on the frame */
@@ -2170,7 +2428,6 @@ typedef struct t_FmPcdManipParams {
         t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
         t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
     } u;
-
     t_Handle                                h_NextManip;        /**< Handle to another (previously defined) manipulation node;
                                                                      Allows concatenation of manipulation actions;
                                                                      This parameter is optional and may be NULL. */
@@ -2475,8 +2732,8 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_CcRootBuild (t_Handle             h_FmPcd,
-                             t_FmPcdCcTreeParams  *p_Params);
+t_Handle FM_PCD_CcRootBuild(t_Handle             h_FmPcd,
+                            t_FmPcdCcTreeParams  *p_Params);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcRootDelete
@@ -2503,7 +2760,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcBuildTree().
+ @Cautions      Allowed only following FM_PCD_CcRootBuild().
 *//***************************************************************************/
 t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                       uint8_t                   grpId,
@@ -2575,9 +2832,9 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
 
  @Description   Add the key (including next engine parameters of this key in the
                 index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
-                may be used by user that don't care about the position of the
+                may be used when the user doesn't care about the position of the
                 key in the table - in that case, the key will be automatically
-                add by the driver in the last available entry.
+                added by the driver in the last available entry.
 
  @Param[in]     h_CcNode     A handle to the node
  @Param[in]     keyIndex     Key index for adding.
@@ -2774,6 +3031,65 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
 *//***************************************************************************/
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex);
 
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics);
+
+/**************************************************************************//**
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+				Note that this routine will search the node to locate the index
+                of the required key based on received key parameters.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keySize         Size of the requested key
+ @Param[in]     p_Key           A pointer to the requested key
+ @Param[in]     p_Mask          A pointer to the mask if relevant,
+                                otherwise pointer to NULL
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
+                                               uint8_t                  keySize,
+		                                       uint8_t                  *p_Key,
+		                                       uint8_t                  *p_Mask,
+						   t_FmPcdCcKeyStatistics   *p_KeyStatistics);
+
 /**************************************************************************//*
  @Function      FM_PCD_MatchTableGetNextEngine
 
@@ -2793,7 +3109,7 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
                                        uint16_t                     keyIndex,
                                        t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_PCD_MatchTableGetIndexedHashBucket
 
  @Description   This routine simulates KeyGen operation on the provided key and
@@ -2960,6 +3276,36 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
                                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
+ @Description   This routine may be used to get statistics counters of specific key
+                in a hash table.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+				Note that this routine will identify the bucket of this key in
+				the hash table and will search the bucket to locate the index
+                of the required key based on received key parameters.
+
+ @Param[in]     h_HashTbl       A handle to a hash table
+ @Param[in]     keySize         Size of the requested key
+ @Param[in]     p_Key           A pointer to the requested key
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
+                                              uint8_t                  keySize,
+                                              uint8_t                  *p_Key,
+                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics);
+
+/**************************************************************************//**
  @Function      FM_PCD_ManipNodeSet
 
  @Description   This routine should be called for defining a manipulation
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 7b3a393..8f254da 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -1,5 +1,5 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -62,7 +62,7 @@
 
                 The FM uses a general module called "port" to represent a Tx port
                 (MAC), an Rx port (MAC) or Offline Parsing port.
-                The number of ports in an FM varies between SOC's.
+                The number of ports in an FM varies between SOCs.
                 The SW driver manages these ports as sub-modules of the FM, i.e.
                 after an FM is initialized, its ports may be initialized and
                 operated upon.
@@ -72,7 +72,9 @@
                 verifies coherence and returns error if applicable.
 
                 On initialization, user specifies the port type and it's index
-                (relative to the port's type) - always starting at 0.
+                (relative to the port's type). Host command and offline parsing
+                ports share the same id range, i.e. the user may only initialize
+                port 0 as either host command or offline parsing, but not both.
 
  @{
 *//***************************************************************************/
@@ -100,6 +102,7 @@ typedef enum e_FmPortPcdSupport {
                                                     /**< Use all PCD engines */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
 #ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
@@ -126,39 +129,39 @@ typedef enum e_FmPortExceptions {
 *//***************************************************************************/
 typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
 
-#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
-#define FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
-#define FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT      FM_FD_ERR_UNSUPPORTED_FORMAT    /**< Not for Rx-Port! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH                  FM_FD_ERR_LENGTH                /**< Not for Rx-Port! Length Error */
+#define FM_PORT_FRM_ERR_DMA                     FM_FD_ERR_DMA                   /**< DMA Data error */
 #ifdef FM_DISABLE_SEC_ERRORS
-#define FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non Frame-Manager error; probably come from SEC that
-                                                                         was chained to FM */
+#define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /*< non Frame-Manager error; probably come from SEC that
+                                                                                    was chained to FM */
 #endif /* FM_DISABLE_SEC_ERRORS */
-
-#define FM_PORT_FRM_ERR_IPRE                            0x00200000
-#define FM_PORT_FRM_ERR_IPFE                            0x00100000
+#define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)    /**< IPR error */
+#define FM_PORT_FRM_ERR_IPR_TO                  (FM_FD_ERR_IPR_TO & ~FM_FD_IPR) /**< IPR timeout */
+#define FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                   /**< IPF error */
 
 #ifdef FM_CAPWAP_SUPPORT
-#define FM_PORT_FRM_ERR_CRE                             0x00200000
-#define FM_PORT_FRM_ERR_CHE                             0x00100000
+#define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
+#define FM_PORT_FRM_ERR_CHE                     FM_FD_ERR_CHE
 #endif /* FM_CAPWAP_SUPPORT */
 
-#define FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
-                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
-                                                                         Sequence error, PHY error control character detected. */
-#define FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
-#define FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
-#define FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
-#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< Keysize Overflow */
-#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< Frame color is yellow */
-#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< Frame color is red */
-#define FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
-#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Policer frame length error */
-#define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
-#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
-#define FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
-#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
-#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPM Frame Processing Timeout Exceeded */
+#define FM_PORT_FRM_ERR_PHYSICAL                FM_FD_ERR_PHYSICAL              /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                                     error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                                     Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE                    FM_FD_ERR_SIZE                  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< classification discard */
+#define FM_PORT_FRM_ERR_EXTRACTION              FM_FD_ERR_EXTRACTION            /**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME               FM_FD_ERR_NO_SCHEME             /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW        FM_FD_ERR_KEYSIZE_OVERFLOW      /**< Keysize Overflow */
+#define FM_PORT_FRM_ERR_COLOR_RED               FM_FD_ERR_COLOR_RED             /**< Frame color is red */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW            FM_FD_ERR_COLOR_YELLOW          /**< Frame color is yellow */
+#define FM_PORT_FRM_ERR_ILL_PLCR                FM_FD_ERR_ILL_PLCR              /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN          FM_FD_ERR_PLCR_FRAME_LEN        /**< Policer frame length error */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT             FM_FD_ERR_PRS_TIMEOUT           /**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT        FM_FD_ERR_PRS_ILL_INSTRUCT      /**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR             FM_FD_ERR_PRS_HDR_ERR           /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED    FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001       /**< FPM Frame Processing Timeout Exceeded */
 /* @} */
 
 
@@ -237,7 +240,7 @@ typedef struct t_FmPortRxParams {
 *//***************************************************************************/
 typedef struct t_FmPortNonRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
-    uint32_t                dfltFqid;           /**< For Tx - Default Confirmation queue,
+    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
                                                      0 means no Tx confirmation for processed
                                                      frames. For OP port - default Rx queue. */
     uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
@@ -407,19 +410,19 @@ typedef struct t_FmPortObservedBufPoolDepletion {
  @Description   A structure for defining Tx rate limiting
 *//***************************************************************************/
 typedef struct t_FmPortRateLimit {
-    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
-                                                                     for OP ports. (note that
+    uint16_t                            maxBurstSize;           /**< in kBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
                                                                      for early chips burst size is
                                                                      rounded up to a multiply of 1000 frames).*/
     uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     OP ports. Rate limit refers to
+                                                                     offline parsing ports. Rate limit refers to
                                                                      data rate (rather than line rate). */
-    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For OP ports only. Not-valid
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For offline parsing ports only. Not-valid
                                                                      for some earlier chip revisions */
 } t_FmPortRateLimit;
 
 /**************************************************************************//**
- @Description   A structure for defining define the parameters of
+ @Description   A structure for defining the parameters of
                 the Rx port performance counters
 *//***************************************************************************/
 typedef struct t_FmPortPerformanceCnt {
@@ -575,9 +578,9 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
                 application buffer, and to offset.
                 Calling this routine changes the buffer margins definitions
                 in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+                configuration: Data size:  [0]
+                               Pass Parser result: [FALSE].
+                               Pass timestamp: [FALSE].
 
                 May be used for all ports
 
@@ -660,7 +663,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
                 Note: Available for some chips only
 
-                May be used for OP ports only
+                May be used for offline parsing ports only
 
  @Param[in]     h_FmPort                            A handle to a FM Port module.
  @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
@@ -669,20 +672,20 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort,
-                                            t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion);
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle                            h_FmPort,
+                                            t_FmPortObservedBufPoolDepletion    *p_FmPortObservedBufPoolDepletion);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigExtBufPools
 
- @Description   This routine should be called for OP ports
+ @Description   This routine should be called for offline parsing ports
                 that internally use BM buffer pools. In such cases, e.g. for fragmentation and
                 re-assembly, the FM needs new BM buffers. By calling this routine the user
                 specifies the BM buffer pools that should be used.
 
                 Note: Available for some chips only
 
-                May be used for OP ports only
+                May be used for offline parsing ports only
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     p_FmExtPools        A structure of parameters for the external pools.
@@ -720,7 +723,7 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPort
                 in the internal driver data base from its default configuration:
                 override = [FALSE]
 
-                May be used for Rx and OP ports only
+                May be used for Rx and offline parsing ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     override    TRUE to override discarding of error frames and
@@ -743,7 +746,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
                 Errors that were not defined either as "ErrorsToEnqueue" nor as
                 "ErrorsToDiscard", will be forwarded to CPU.
 
-                May be used for Rx and OP ports only
+                May be used for Rx and offline parsing ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to discard
@@ -759,7 +762,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
  @Description   Calling this routine changes the DMA swap data aparameter
                 in the internal driver data base from its default
-                configuration  [DEFAULT_FM_SP_dmaSwapData]
+                configuration  [e_FM_PORT_DMA_NO_SWP]
 
                 May be used for all port types
 
@@ -777,7 +780,7 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
 
  @Description   Calling this routine changes the internal context cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
+                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
 
                 May be used for all port types
 
@@ -795,7 +798,7 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
 
  @Description   Calling this routine changes the header cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
+                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
 
                 May be used for all port types
 
@@ -813,7 +816,7 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
 
  @Description   Calling this routine changes the scatter gather cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
+                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
 
                 May be used for all port types
 
@@ -831,7 +834,7 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  By default optimize = [DEFAULT_FM_SP_dmaWriteOptimize].
+                from its default configuration:  optimize = [TRUE]
                 Note:
 
                 1. For head optimization, data alignment must be >= 16 (supported by default).
@@ -907,7 +910,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 /**************************************************************************//**
  @Function      FM_PORT_ConfigForwardReuseIntContext
 
- @Description   This routine is relevant for Rx ports that are routed to OP port.
+ @Description   This routine is relevant for Rx ports that are routed to offline parsing port.
                 It changes the internal context reuse option in the internal
                 driver data base from its default configuration:
                 reuse = [FALSE]
@@ -916,7 +919,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     reuse           TRUE to reuse internal context on frames
-                                forwarded to OP port.
+                                forwarded to offline parsing port.
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1011,7 +1014,7 @@ t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
                 data structures (e.g. BD rings).
                 Calling this routine changes the internal driver data base
                 from its default configuration
-                [0 , MEMORY_ATTR_CACHEABLE].
+                [0, MEMORY_ATTR_CACHEABLE].
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     memId           Memory partition ID.
@@ -1042,8 +1045,10 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
 
  @Description   Changes the definition of the max size of frame that should be
                 transmitted/received on this port from its default value [9600].
-                This parameter is used for minimum Fifo size calculations and
-                only for Tx ports or ports working in independent mode.
+                This parameter is used for confirmation of the minimum Fifo
+                size calculations and only for Tx ports or ports working in
+                independent mode. This should be larger than the maximum possible
+                MTU that will be used for this port (i.e. its MAC).
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     length          Max size of frame
@@ -1055,7 +1060,7 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_PORT_ConfigTxFifoMinFillLevel
 
  @Description   Calling this routine changes the fifo minimum
@@ -1073,7 +1078,7 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_PORT_ConfigFifoDeqPipelineDepth
 
  @Description   Calling this routine changes the fifo dequeue
@@ -1093,12 +1098,12 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
 *//***************************************************************************/
 t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_PORT_ConfigTxFifoLowComfLevel
 
  @Description   Calling this routine changes the fifo low comfort level
                 parameter in internal driver data base
-                from its default configuration  [5]
+                from its default configuration [5]
 
                 May be used for Tx ports only
 
@@ -1135,7 +1140,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
 
-/**************************************************************************//*
+/**************************************************************************//**
  @Function      FM_PORT_ConfigRxFifoPriElevationLevel
 
  @Description   Calling this routine changes the priority elevation level
@@ -1223,7 +1228,7 @@ typedef enum e_FmPortCounters {
                 Fields commented 'OUT' will be filled by FM before returning to port.
 *//***************************************************************************/
 typedef struct t_FmPortCongestionGrps {
-    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required CGs
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
                                                              to define the size of the following array */
     uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
                                                         /**< An array of CG indexes;
@@ -1379,7 +1384,7 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort);
                 The selected rate limit specified here would be
                 rounded DOWN to the nearest 16M.
 
-                May be used for Tx and OP ports only
+                May be used for Tx and offline parsing ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_RateLimit     A structure of rate limit parameters
@@ -1396,7 +1401,7 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
  @Description   Calling this routine disables and clears rate limit
                 initialization.
 
-                May be used for Tx and OP ports only
+                May be used for Tx and offline parsing ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
 
@@ -1639,6 +1644,8 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort);
 
  @Description   This routine may be called in case the port was stalled and may
                 now be released.
+                Note that this routine is available only on older FMan revisions
+                (FMan v2, DPAA v1.0 only).
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
 
@@ -1676,7 +1683,7 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
                 Errors that were configured to be discarded (at initialization)
                 may not be selected here.
 
-                May be used for Rx and OP ports only
+                May be used for Rx and offline parsing ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to enqueue to error queue
@@ -1699,8 +1706,6 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
 
@@ -1803,8 +1808,7 @@ typedef struct t_FmPortPcdPrsParams {
                                                                          incoming frames. */
     uint8_t                         parsingOffset;                  /**< Number of bytes from beginning of packet to start parsing */
     e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header expected at 'parsingOffset' */
-    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
-                                                                         NOTE: this field is not valid when the FN is in "guest" mode. */
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics */
     uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
                                                                          special parameters */
     t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
@@ -1901,7 +1905,7 @@ typedef struct t_FmPortVSPAllocParams {
                 disabled (BMI to BMI) and configures it according to the passed
                 parameters.
 
-                May be used for Rx and OP ports only
+                May be used for Rx and offline parsing ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
@@ -1920,7 +1924,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
                 The port returns to its default configuration which is PCD
                 disabled (BMI to BMI) and all PCD configuration is removed.
 
-                May be used for Rx and OP ports which are
+                May be used for Rx and offline parsing ports which are
                 in PCD mode  only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -1939,7 +1943,7 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
                 The couple of routines are used to allow PCD configuration changes
                 that demand that PCD will not be used while changes take place.
 
-                May be used for Rx and OP ports which are
+                May be used for Rx and offline parsing ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -1956,7 +1960,7 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
  @Description   Calling this routine detaches the port from its PCD functionality.
                 The port returns to its default flow which is BMI to BMI.
 
-                May be used for Rx and OP ports which are
+                May be used for Rx and offline parsing ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -2119,6 +2123,10 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
 *//***************************************************************************/
 t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
 
+#ifdef ALU_CUSTOM
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
+#endif /* ALU_CUSTOM */
+
 /** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of FM_PORT_runtime_control_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index 3c6bbc6..9728af5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -206,6 +206,7 @@ typedef enum e_FmMacsecInterModuleEvent {
 #define FM_QMI_NO_DEQ_OPTIONS_SUPPORT
 #define FM_FIFO_ALLOCATION_ALG
 #define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_HAS_TOTAL_DMAS
 
 /* FM erratas */
 #define FM_RX_PREAM_4_ERRATA_DTSEC_A001
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 270b61e..4673d0f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -188,6 +188,8 @@ typedef enum
 #define FM_MAX_NUM_OF_SUB_PORTALS               12
 #define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
 
+#define FM_IPSEC_SUPPORT
+
 /* RAMs defines */
 #define FM_MURAM_SIZE                   (160 * KILOBYTE)
 #define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
@@ -229,7 +231,6 @@ typedef enum
 #define FM_NO_THRESHOLD_REG
 
 /* p4080 unique features */
-#define FM_QMI_DEQ_OPTIONS_SUPPORT
 #define FM_NO_DISPATCH_RAM_ECC
 #define FM_FIFO_ALLOCATION_OLD_ALG
 #define FM_NO_WATCHDOG
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
index 2652ab3..3457d32 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
@@ -668,14 +668,12 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 								   TRUE);
 		if (errCode != E_OK)
 			RETURN_ERROR(MAJOR, errCode, NO_MSG);
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 		errCode =
 		FM_PORT_ConfigDeqPrefetchOption(p_LnxWrpFmPortDev->h_Dev,
 						e_FM_PORT_DEQ_FULL_PREFETCH);
 		if (errCode
 		    != E_OK)
 			RETURN_ERROR(MAJOR, errCode, NO_MSG);
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 	}
 
 /* Call the driver's advanced configuration routines, if requested:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 846f31e..5de155a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -3057,27 +3057,47 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
 
             return FM_PORT_PcdCcModifyTree(p_LnxWrpFmPortDev->h_Dev, id.obj);
         }
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-        case FM_PORT_SET_OP_WORKAROUNDS:
+
+        case FM_PORT_IOC_ADD_CONGESTION_GRPS:
+        case FM_PORT_IOC_REMOVE_CONGESTION_GRPS:
         {
-            fmOpPortWorkaroundsSelect_t workarounds; /* uint32_t type */
+            ioc_fm_port_congestion_groups_t *param;
+
+            param = (ioc_fm_port_congestion_groups_t*) XX_Malloc(sizeof(ioc_fm_port_congestion_groups_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            memset(param, 0, sizeof(ioc_fm_port_congestion_groups_t));
 
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                if (get_user(workarounds, (fmOpPortWorkaroundsSelect_t *) compat_ptr(arg)))
-                    break;
+                if (copy_from_user(param, (t_FmPortCongestionGrps*) compat_ptr(arg),
+                            sizeof(t_FmPortCongestionGrps)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
             }
             else
-#endif
+#endif /* CONFIG_COMPAT */
             {
-                if (get_user(workarounds, (fmOpPortWorkaroundsSelect_t *)arg))
-                    break;
+                if (copy_from_user(param, (t_FmPortCongestionGrps*) arg,
+                            sizeof(t_FmPortCongestionGrps)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
             }
 
-            return FM_PORT_SetOpWorkarounds(p_LnxWrpFmPortDev->h_Dev, workarounds);
+            err = (cmd == FM_PORT_IOC_ADD_CONGESTION_GRPS)
+                ? FM_PORT_AddCongestionGrps(p_LnxWrpFmPortDev->h_Dev, (t_FmPortCongestionGrps*) param)
+                : FM_PORT_RemoveCongestionGrps(p_LnxWrpFmPortDev->h_Dev, (t_FmPortCongestionGrps*) param)
+                ;
+
+            XX_Free(param);
+            return err;
         }
-#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION,
                 ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index de89318..227ea37 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -632,7 +632,7 @@ void compat_copy_fm_pcd_kg_scheme(
                sizeof(ioc_fm_pcd_kg_key_extract_and_hash_params_t));
         param->bypass_fqid_generation = compat_param->bypass_fqid_generation;
         param->base_fqid = compat_param->base_fqid;
-        param->numOfUsedExtractedOrs = compat_param->numOfUsedExtractedOrs;
+        param->num_of_used_extracted_ors = compat_param->num_of_used_extracted_ors;
 		memcpy(param->extracted_ors,
                compat_param->extracted_ors,
                IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS * sizeof(ioc_fm_pcd_kg_extracted_or_params_t));
@@ -679,7 +679,7 @@ void compat_copy_fm_pcd_kg_scheme(
         memcpy(&compat_param->key_extract_and_hash_params, &param->key_extract_and_hash_params, sizeof(ioc_fm_pcd_kg_key_extract_and_hash_params_t));
         compat_param->bypass_fqid_generation = param->bypass_fqid_generation;
         compat_param->base_fqid = param->base_fqid;
-        compat_param->numOfUsedExtractedOrs = param->numOfUsedExtractedOrs;
+        compat_param->num_of_used_extracted_ors = param->num_of_used_extracted_ors;
 		memcpy(compat_param->extracted_ors, param->extracted_ors, IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS * sizeof(ioc_fm_pcd_kg_extracted_or_params_t));
         compat_param->next_engine = param->next_engine;
 
@@ -738,7 +738,7 @@ void compat_copy_fm_pcd_kg_schemes_params(
     if (compat == COMPAT_US_TO_K) {
         param->num_of_schemes = compat_param->num_of_schemes;
         for(k=0; k < compat_param->num_of_schemes; k++)
-            param->scheme_ids[k] = compat_get_id2ptr(compat_param->schemes_ids[k], PCD_NODE);
+            param->scheme_ids[k] = compat_get_id2ptr(compat_param->scheme_ids[k], PCD_NODE);
     }
 }
 
@@ -762,8 +762,8 @@ void compat_copy_fm_port_pcd_kg(
 
         param->num_of_schemes = compat_param->num_of_schemes;
         for(k=0; k<compat_param->num_of_schemes; k++)
-            if (compat_param->schemes_ids[k])
-                param->schemes_ids[k] = compat_get_id2ptr(compat_param->schemes_ids[k], PCD_NODE);
+            if (compat_param->scheme_ids[k])
+                param->scheme_ids[k] = compat_get_id2ptr(compat_param->scheme_ids[k], PCD_NODE);
 
         param->direct_scheme = compat_param->direct_scheme;
         if (param->direct_scheme)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index f31f2c9..08656dc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -94,7 +94,7 @@ void *compat_get_id2ptr(compat_uptr_t comp, const unsigned char *);
 /* pcd compat structures { */
 typedef struct ioc_compat_fm_pcd_cc_node_remove_key_params_t {
     compat_uptr_t                       id;
-    uint8_t                             key_indx;
+    uint16_t                            key_indx;
 } ioc_compat_fm_pcd_cc_node_remove_key_params_t;
 
 typedef union ioc_compat_fm_pcd_plcr_next_engine_params_u {
@@ -149,7 +149,7 @@ typedef struct ioc_compat_fm_pcd_kg_scheme_select_t {
 
 typedef struct ioc_compat_fm_pcd_port_schemes_params_t {
     uint8_t        num_of_schemes;
-    compat_uptr_t  schemes_ids [FM_PCD_KG_NUM_OF_SCHEMES];
+    compat_uptr_t  scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
 } ioc_compat_fm_pcd_port_schemes_params_t;
 
 typedef struct ioc_compat_fm_pcd_net_env_params_t {
@@ -171,32 +171,37 @@ typedef struct ioc_compat_fm_pcd_prs_sw_params_t {
 typedef struct ioc_compat_fm_pcd_cc_next_kg_params_t {
     bool          override_fqid;
     uint32_t      new_fqid;
-    compat_uptr_t p_direct_scheme;
 #if DPAA_VERSION >= 11
     uint8_t       new_relative_storage_profile_id;
 #endif
+    compat_uptr_t p_direct_scheme;
 } ioc_compat_fm_pcd_cc_next_kg_params_t;
 
 typedef struct ioc_compat_fm_pcd_cc_next_cc_params_t {
-    compat_uptr_t        cc_node_id;
+    compat_uptr_t       cc_node_id;
 } ioc_compat_fm_pcd_cc_next_cc_params_t;
 
+#if DPAA_VERSION >= 11
+typedef struct ioc_compat_fm_pcd_cc_next_fr_params_t {
+    compat_uptr_t       frm_replic_id;
+} ioc_compat_fm_pcd_cc_next_fr_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
 typedef struct ioc_compat_fm_pcd_cc_next_engine_params_t {
-    ioc_fm_pcd_engine                                  next_engine;
+    ioc_fm_pcd_engine                          next_engine;
     union {
-            ioc_compat_fm_pcd_cc_next_cc_params_t      cc_params;      /**< compat structure*/
-            ioc_fm_pcd_cc_next_plcr_params_t           plcr_params;    /**< same structure*/
-            ioc_fm_pcd_cc_next_enqueue_params_t        enqueue_params; /**< same structure*/
-            ioc_compat_fm_pcd_cc_next_kg_params_t      kg_params;      /**< compat structure*/
-    } params;
+        ioc_compat_fm_pcd_cc_next_cc_params_t  cc_params;      /**< compat structure*/
+        ioc_fm_pcd_cc_next_plcr_params_t       plcr_params;    /**< same structure*/
+        ioc_fm_pcd_cc_next_enqueue_params_t    enqueue_params; /**< same structure*/
+        ioc_compat_fm_pcd_cc_next_kg_params_t  kg_params;      /**< compat structure*/
 #if DPAA_VERSION >= 11
-    compat_uptr_t                                        p_frm_replic_id;
+        ioc_compat_fm_pcd_cc_next_fr_params_t  fr_params;      /**< compat structure*/
 #endif /* DPAA_VERSION >= 11 */
+    } params;
     compat_uptr_t                               manip_id;
     bool                                        statistics_en;
 } ioc_compat_fm_pcd_cc_next_engine_params_t;
 
-
 typedef struct ioc_compat_fm_pcd_cc_grp_params_t {
     uint8_t                             num_of_distinction_units;
     uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
@@ -227,6 +232,7 @@ typedef struct ioc_compat_keys_params_t {
     uint16_t                                   max_num_of_keys;
     bool                                       mask_support;
     ioc_fm_pcd_cc_stats_mode                   statistics_mode;
+    uint16_t                                   frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
     uint16_t                                   num_of_keys;
     uint8_t                                    key_size;
     ioc_compat_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS]; /**< compat structure*/
@@ -248,31 +254,28 @@ typedef struct ioc_compat_fm_pcd_hash_table_params_t {
     uint16_t                    hash_res_mask;
     uint8_t                     hash_shift;
     uint8_t                     match_key_size;
-
     ioc_compat_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
-
     compat_uptr_t               id;
-
 } ioc_compat_fm_pcd_hash_table_params_t;
 
 typedef struct ioc_compat_fm_pcd_hash_table_add_key_params_t {
-    compat_uptr_t               p_hash_tbl;
-    uint8_t                     key_size;
+    compat_uptr_t                       p_hash_tbl;
+    uint8_t                             key_size;
     ioc_compat_fm_pcd_cc_key_params_t  *p_key_params;
 } ioc_compat_fm_pcd_hash_table_add_key_params_t;
 
 typedef struct ioc_compat_fm_pcd_cc_node_modify_key_params_t {
     compat_uptr_t                       id;
-    uint8_t                             key_indx;
+    uint16_t                            key_indx;
     uint8_t                             key_size;
     compat_uptr_t                       p_key;
     compat_uptr_t                       p_mask;
 } ioc_compat_fm_pcd_cc_node_modify_key_params_t;
 
 typedef struct ioc_compat_fm_pcd_hash_table_remove_key_params_t {
-    compat_uptr_t p_hash_tbl;
-    uint8_t key_size;
-    compat_uptr_t p_key;
+    compat_uptr_t   p_hash_tbl;
+    uint8_t         key_size;
+    compat_uptr_t   p_key;
 } ioc_compat_fm_pcd_hash_table_remove_key_params_t;
 
 typedef struct ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
@@ -292,7 +295,7 @@ typedef struct ioc_compat_fm_port_pcd_cc_params_t {
 
 typedef struct ioc_compat_fm_port_pcd_kg_params_t {
     uint8_t             num_of_schemes;
-    compat_uptr_t       schemes_ids[FM_PCD_KG_NUM_OF_SCHEMES];
+    compat_uptr_t       scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
     bool                direct_scheme;
     compat_uptr_t       direct_scheme_id;
 } ioc_compat_fm_port_pcd_kg_params_t;
@@ -317,14 +320,12 @@ typedef struct ioc_compat_fm_pcd_kg_cc_t {
 
 typedef struct ioc_compat_fm_pcd_kg_scheme_params_t {
     bool                                modify;
-    union
-    {
+    union {
         uint8_t                         relative_scheme_id;
         compat_uptr_t                   scheme_id;
     } scm_id;
     bool                                always_direct;
-    struct
-    {
+    struct {
         compat_uptr_t                   net_env_id;
         uint8_t                         num_of_distinction_units;
         uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
@@ -333,11 +334,11 @@ typedef struct ioc_compat_fm_pcd_kg_scheme_params_t {
     ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
     bool                                bypass_fqid_generation;
     uint32_t                            base_fqid;
-    uint8_t                             numOfUsedExtractedOrs;
+    uint8_t                             num_of_used_extracted_ors;
     ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
 #if DPAA_VERSION >= 11
     bool                                override_storage_profile;
-    ioc_fm_pcd_kg_storage_profile       storage_profile;
+    ioc_fm_pcd_kg_storage_profile_t     storage_profile;
 #endif /* DPAA_VERSION >= 11 */
     ioc_fm_pcd_engine                   next_engine;
     union{
@@ -351,7 +352,7 @@ typedef struct ioc_compat_fm_pcd_kg_scheme_params_t {
 
 typedef struct ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t {
     compat_uptr_t                       id;
-    uint8_t                             key_indx;
+    uint16_t                            key_indx;
     uint8_t                             key_size;
     ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
 } ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t;
@@ -381,21 +382,20 @@ typedef struct ioc_compat_fm_pcd_manip_hdr_params_t {
     bool                                        dont_parse_after_manip;
 } ioc_compat_fm_pcd_manip_hdr_params_t;
 
-/**************************************************************************//**
- @Description   Parameters for defining a manipulation node
-*//***************************************************************************/
 typedef struct ioc_compat_fm_pcd_manip_params_t {
     ioc_fm_pcd_manip_type                         type;
-    union{
+    union {
         ioc_compat_fm_pcd_manip_hdr_params_t      hdr;
         ioc_fm_pcd_manip_reassem_params_t         reassem;
         ioc_fm_pcd_manip_frag_params_t            frag;
         ioc_fm_pcd_manip_special_offload_params_t special_offload;
     } u;
-     compat_uptr_t                                p_next_manip;
+    compat_uptr_t                                 p_next_manip;
 #ifdef FM_CAPWAP_SUPPORT
-#warning "feature not supported!"
-#endif
+#error "FM_CAPWAP_SUPPORT feature not supported!"
+    bool                                          frag_or_reasm;
+    ioc_fm_pcd_manip_frag_or_reasm_params_t       frag_or_reasm_params;
+#endif /* FM_CAPWAP_SUPPORT */
     compat_uptr_t                                 id;
 } ioc_compat_fm_pcd_manip_params_t;
 
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
index cee9d19..8480222 100644
--- a/include/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -59,7 +59,6 @@
 #define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
 #define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
 
-
 #define FM_IOC_NUM(n)       n
 #define FM_PCD_IOC_NUM(n)   (n+20)
 #define FM_PORT_IOC_NUM(n)  (n+50)
@@ -67,39 +66,9 @@
 
 #define IOC_FM_MAX_NUM_OF_PORTS         64
 
-/**************************************************************************//**
- @Collection   FM Frame error
-*//***************************************************************************/
-typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
-
-#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
-#define IOC_FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
-#define IOC_FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
-#ifdef FM_CAPWAP_SUPPORT
-#define IOC_FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non FMan error; probably come from SEC chained to FM */
-#endif /* FM_CAPWAP_SUPPORT */
-#define IOC_FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
-                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
-                                                                         Sequence error, PHY error control character detected. */
-#define IOC_FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
-#define IOC_FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
-#define IOC_FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
-#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
-#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< */
-#define IOC_FM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< */
-#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
-#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
-#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
-#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
-#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
-#define IOC_FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
-#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
-/* @} */
-
 
 /**************************************************************************//**
- @Description   enum for defining port types
+ @Description   Enum for defining port types
                 (must match enum e_FmPortType defined in fm_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_port_type {
@@ -113,6 +82,79 @@ typedef enum ioc_fm_port_type {
 
 
 /**************************************************************************//**
+ @Collection   FM Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_CMD_FCO                   0x80000000  /**< Frame queue Context Override */
+#define FM_FD_CMD_RPD                   0x40000000  /**< Read Prepended Data */
+#define FM_FD_CMD_UPD                   0x20000000  /**< Update Prepended Data */
+#define FM_FD_CMD_DTC                   0x10000000  /**< Do L4 Checksum */
+#define FM_FD_CMD_DCL4C                 0x10000000  /**< Didn't calculate L4 Checksum */
+#define FM_FD_CMD_CFQ                   0x00ffffff  /**< Confirmation Frame Queue */
+
+#define FM_FD_ERR_UNSUPPORTED_FORMAT    0x04000000  /**< Not for Rx-Port! Unsupported Format */
+#define FM_FD_ERR_LENGTH                0x02000000  /**< Not for Rx-Port! Length Error */
+#define FM_FD_ERR_DMA                   0x01000000  /**< DMA Data error */
+
+#define FM_FD_IPR                       0x00000001  /**< IPR frame (not error) */
+
+#define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
+#define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
+#define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
+#define FM_FD_ERR_IPF                   0x00100000                  /**< IPF error */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_FD_ERR_CRE                   0x00200000
+#define FM_FD_ERR_CHE                   0x00100000
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_FD_ERR_PHYSICAL              0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                         Sequence error, PHY error control character detected. */
+#define FM_FD_ERR_SIZE                  0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_FD_ERR_CLS_DISCARD           0x00020000  /**< classification discard */
+#define FM_FD_ERR_EXTRACTION            0x00008000  /**< Extract Out of Frame */
+#define FM_FD_ERR_NO_SCHEME             0x00004000  /**< No Scheme Selected */
+#define FM_FD_ERR_KEYSIZE_OVERFLOW      0x00002000  /**< Keysize Overflow */
+#define FM_FD_ERR_COLOR_RED             0x00000800  /**< Frame color is red */
+#define FM_FD_ERR_COLOR_YELLOW          0x00000400  /**< Frame color is yellow */
+#define FM_FD_ERR_ILL_PLCR              0x00000200  /**< Illegal Policer Profile selected */
+#define FM_FD_ERR_PLCR_FRAME_LEN        0x00000100  /**< Policer frame length error */
+#define FM_FD_ERR_PRS_TIMEOUT           0x00000080  /**< Parser Time out Exceed */
+#define FM_FD_ERR_PRS_ILL_INSTRUCT      0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_FD_ERR_PRS_HDR_ERR           0x00000020  /**< Header error was identified during parsing */
+#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008  /**< Frame parsed beyind 256 first bytes */
+
+#define FM_FD_TX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA) /**< TX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA                  | \
+                                         FM_FD_ERR_IPR                  | \
+                                         FM_FD_ERR_IPR_TO               | \
+                                         FM_FD_ERR_IPR_NCSP             | \
+                                         FM_FD_ERR_IPF                  | \
+                                         FM_FD_ERR_PHYSICAL             | \
+                                         FM_FD_ERR_SIZE                 | \
+                                         FM_FD_ERR_CLS_DISCARD          | \
+                                         FM_FD_ERR_COLOR_RED            | \
+                                         FM_FD_ERR_COLOR_YELLOW         | \
+                                         FM_FD_ERR_ILL_PLCR             | \
+                                         FM_FD_ERR_PLCR_FRAME_LEN       | \
+                                         FM_FD_ERR_EXTRACTION           | \
+                                         FM_FD_ERR_NO_SCHEME            | \
+                                         FM_FD_ERR_KEYSIZE_OVERFLOW     | \
+                                         FM_FD_ERR_PRS_TIMEOUT          | \
+                                         FM_FD_ERR_PRS_ILL_INSTRUCT     | \
+                                         FM_FD_ERR_PRS_HDR_ERR          | \
+                                         FM_FD_ERR_BLOCK_LIMIT_EXCEEDED) /**< RX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_NON_FM      0x00400000  /**< non Frame-Manager error */
+/* @} */
+
+
+/**************************************************************************//**
  @Group         lnx_ioctl_FM_lib_grp FM library
 
  @Description   FM API functions, definitions and enums
@@ -222,7 +264,8 @@ typedef struct ioc_fm_obj_t {
 } ioc_fm_obj_t;
 
 /**************************************************************************//**
- @Description   structure for returning revision information
+ @Description   A structure for returning revision information
+                (must match struct t_FmRevisionInfo declared in fm_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_revision_info_t {
     uint8_t         major;               /**< Major revision */
@@ -230,7 +273,7 @@ typedef struct ioc_fm_revision_info_t {
 } ioc_fm_revision_info_t;
 
 /**************************************************************************//**
- @Description   structure for FM counters
+ @Description   A structure for FM counters
 *//***************************************************************************/
 typedef struct ioc_fm_counters_params_t {
     ioc_fm_counters cnt;                /**< The requested counter */
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 23d65cf..cdf870a 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd_ioctls.h
 
@@ -43,9 +44,10 @@
 
 
 /**************************************************************************//**
+
  @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
 
- @Description   FM Linux ioctls definitions and enums
+ @Description   Frame Manager Linux ioctls definitions and enums
 
  @{
 *//***************************************************************************/
@@ -53,18 +55,18 @@
 /**************************************************************************//**
  @Group         lnx_ioctl_FM_PCD_grp FM PCD
 
- @Description   FM PCD API functions, definitions and enums
+ @Description   Frame Manager PCD API functions, definitions and enums
 
                 The FM PCD module is responsible for the initialization of all
                 global classifying FM modules. This includes the parser general and
                 common registers, the key generator global and common registers,
-                and the Policer global and common registers.
+                and the policer global and common registers.
                 In addition, the FM PCD SW module will initialize all required
-                key generator schemes, coarse classification flows, and Policer
-                profiles. When An FM module is configured to work with one of these
+                key generator schemes, coarse classification flows, and policer
+                profiles. When an FM module is configured to work with one of these
                 entities, it will register to it using the FM PORT API. The PCD
                 module will manage the PCD resources - i.e. resource management of
-                Keygen schemes, etc.
+                KeyGen schemes, etc.
 
  @{
 *//***************************************************************************/
@@ -106,41 +108,103 @@
 #if DPAA_VERSION >= 11
 #define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
 #endif /* DPAA_VERSION >= 11 */
-
 /* @} */
 
+#ifdef FM_CAPWAP_SUPPORT
+#error "FM_CAPWAP_SUPPORT not implemented!"
+#endif
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+                (must match enum e_FmPcdCounters defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
+} ioc_fm_pcd_exceptions;
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_init_grp group */
+
+
 /**************************************************************************//**
  @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
 
- @Description   FM PCD Runtime Unit
+ @Description   Frame Manager PCD Runtime Unit
 
                 The runtime control allows creation of PCD infrastructure modules
                 such as Network Environment Characteristics, Classification Plan
                 Groups and Coarse Classification Trees.
                 It also allows on-the-fly initialization, modification and removal
-                of PCD modules such as Keygen schemes, coarse classification nodes
+                of PCD modules such as KeyGen schemes, coarse classification nodes
                 and Policer profiles.
 
-
                 In order to explain the programming model of the PCD driver interface
                 a few terms should be explained, and will be used below.
-                  * Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the shim headers (1 or 2). May be a header with a special
+                  - Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the SHIM headers (1 or 2). May be a header with a special
                     option (see below).
-                  * Interchangeable Headers Group- This is a group of Headers recognized
+                  - Interchangeable Headers Group - This is a group of Headers recognized
                     by either one of them. For example, if in a specific context the user
                     chooses to treat IPv4 and IPV6 in the same way, they may create an
                     interchangeable Headers Unit consisting of these 2 headers.
-                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
                     Group.
-                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
-                    ipv6, includes multicast, broadcast and other protocol specific options.
+                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+                    IPv6, includes multicast, broadcast and other protocol specific options.
                     In terms of hardware it relates to the options available in the classification
                     plan.
-                  * Network Environment Characteristics - a set of Distinction Units that define
+                  - Network Environment Characteristics - a set of Distinction Units that define
                     the total recognizable header selection for a certain environment. This is
                     NOT the list of all headers that will ever appear in a flow, but rather
-                    everything that needs distinction in a flow, where distinction is made by keygen
+                    everything that needs distinction in a flow, where distinction is made by KeyGen
                     schemes and coarse classification action descriptors.
 
                 The PCD runtime modules initialization is done in stages. The first stage after
@@ -149,55 +213,9 @@
                 Later, when needed, the application will have to state, for some of its modules,
                 to which single environment it belongs.
 
-
  @{
 *//***************************************************************************/
 
-/**************************************************************************//**
- @Description   PCD counters
-                (must match enum e_FmPcdCounters defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_counters {
-    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
-} ioc_fm_pcd_counters;
-
-/**************************************************************************//**
- @Description   PCD interrupts
-                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_exceptions {
-    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
-    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
-    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
-    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                       /**< Parser single ECC */
-} ioc_fm_pcd_exceptions;
 
 /**************************************************************************//**
  @Description   structure for FM counters
@@ -216,38 +234,38 @@ typedef struct ioc_fm_pcd_exception_params_t {
 } ioc_fm_pcd_exception_params_t;
 
 /**************************************************************************//**
- @Description   A structure for sw parser labels
+ @Description   A structure for SW parser labels
                 (must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
  *//***************************************************************************/
 typedef struct ioc_fm_pcd_prs_label_params_t {
     uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
                                                                  resolution), relative to Parser RAM. */
-    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
-                                                                 the sw parser code. */
-    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
+    ioc_net_header_type     hdr;                            /**< The existence of this header will invoke
+                                                                 the SW parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one SW parser
                                                                  attachments for the same header, use this
                                                                  index to distinguish between them. */
 } ioc_fm_pcd_prs_label_params_t;
 
 /**************************************************************************//**
- @Description   A structure for sw parser
-                (must be identical to struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
+ @Description   A structure for SW parser
+                (Must match struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
  *//***************************************************************************/
 typedef struct ioc_fm_pcd_prs_sw_params_t {
-    bool                            override;           /**< FALSE to invoke a check that nothing else
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
                                                              was loaded to this address, including
-                                                             internal patched.
+                                                             internal patches.
                                                              TRUE to override any existing code.*/
-    uint32_t                        size;               /**< SW parser code size */
-    uint16_t                        base;               /**< SW parser base (in instruction counts!
-                                                             muat be larger than 0x20)*/
-    uint8_t                         *p_code;            /**< SW parser code */
-    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             must be larger than 0x20)*/
+    uint8_t                 *p_code;                    /**< SW parser code */
+    uint32_t                sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
                                                         /**< SW parser data (parameters) */
-    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
-    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
-                                                        /**< SW parser labels table, containing n
-                                                             umOfLabels entries */
+    uint8_t                 num_of_labels;              /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table,
+                                                             containing num_of_labels entries */
 } ioc_fm_pcd_prs_sw_params_t;
 
 /**************************************************************************//**
@@ -260,32 +278,32 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
 
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_ENABLE
+ @Function      FM_PCD_Enable
 
  @Description   This routine should be called after PCD is initialized for enabling all
                 PCD engines according to their existing configuration.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+ @Cautions      Allowed only when PCD is disabled.
 *//***************************************************************************/
 #define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_DISABLE
+ @Function      FM_PCD_Disable
 
  @Description   This routine may be called when PCD is enabled in order to
                 disable all PCD engines. It may be called
                 only when none of the ports in the system are using the PCD.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+ @Cautions      Allowed only when PCD is enabled.
 *//***************************************************************************/
 #define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
 
  /**************************************************************************//**
- @Function      FM_PCD_IOC_PRS_LOAD_SW
+ @Function      FM_PCD_PrsLoadSw
 
  @Description   This routine may be called only when all ports in the
                 system are actively using the classification plan scheme.
@@ -297,9 +315,9 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
 
  @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+ @Cautions      Allowed only when PCD is disabled.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
@@ -307,62 +325,56 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
 #define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
+ @Function      FM_PCD_KgSetDfltValue
 
  @Description   Calling this routine sets a global default value to be used
-                by the keygen when parser does not recognize a required
+                by the KeyGen when parser does not recognize a required
                 field/header.
                 By default default values are 0.
 
  @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+ @Cautions      Allowed only when PCD is disabled.
 *//***************************************************************************/
 #define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
+ @Function      FM_PCD_KgSetAdditionalDataAfterParsing
 
  @Description   Calling this routine allows the keygen to access data past
                 the parser finishing point.
 
  @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
 
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+ @Return        0 on success; Error code otherwise.
 
+ @Cautions      Allowed only when PCD is disabled.
 *//***************************************************************************/
 #define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_SET_EXCEPTION
+ @Function      FM_PCD_SetException
 
  @Description   Calling this routine enables/disables PCD interrupts.
 
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
-
- @Return        E_OK on success; Error code otherwise.
+ @Param[in]     ioc_fm_pcd_exception_params_t     Arguments struct with exception to be enabled/disabled.
 
- @Cautions      Allowed only following PCD_Init().
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_GET_COUNTER
+ @Function      FM_PCD_GetCounter
 
  @Description   Reads one of the FM PCD counters.
 
  @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
 
- @Return        Counter's current value.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
-                Note that it is user's responsibilty to call this routine only
+ @Cautions      Note that it is user's responsibilty to call this routine only
                 for enabled counters, and there will be no indication if a
                 disabled counter is accessed.
 *//***************************************************************************/
@@ -371,47 +383,44 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
 #if 0
 TODO: unused IOCTL
 /**************************************************************************//**
- @Function      FM_PCD_IOC_SET_COUNTER
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+ @Function      FM_PCD_ModifyCounter
 
- @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
+ @Description   Writes a value to an enabled counter. Use "0" to reset the counter.
 
- @Return        E_OK on success; Error code otherwise.
+ @Param[in]     ioc_fm_pcd_counters_params_t - The requested counter parameters.
 
- @Cautions      Allowed only following PCD_Init().
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
-#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#define FM_PCD_IOC_MODIFY_COUNTER   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#define FM_PCD_IOC_SET_COUNTER      FM_PCD_IOC_MODIFY_COUNTER
 #endif
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_FORCE_INTR
+ @Function      FM_PCD_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
 
- @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
+ @Param[in]     ioc_fm_pcd_exceptions - An exception to be forced.
 
- @Return        E_OK on success; Error code if the exception is not enabled,
+ @Return        0 on success; error code if the exception is not enabled,
                 or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
 #define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
 
 /**************************************************************************//**
- @Collection    Definitions of coarse classification
-                parameters as required by keygen (when coarse classification
-                is the next engine after this scheme).
+ @Collection    Definitions of coarse classification parameters as required by KeyGen
+                (when coarse classification is the next engine after this scheme).
 *//***************************************************************************/
 #define IOC_FM_PCD_MAX_NUM_OF_CC_NODES              255
 #define IOC_FM_PCD_MAX_NUM_OF_CC_TREES              8
 #define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS             16
 #define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS              4
 #define IOC_FM_PCD_MAX_NUM_OF_KEYS                  256
+#define IOC_FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
 #define IOC_FM_PCD_MAX_SIZE_OF_KEY                  56
 #define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
 #define IOC_FM_PCD_LAST_KEY_INDEX                   0xffff
-
+#define IOC_FM_PCD_MANIP_DSCP_VALUES                64
 /* @} */
 
 /**************************************************************************//**
@@ -425,10 +434,10 @@ typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol opti
 #define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
 
 typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
-#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Stacked VLAN. */
 
 typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
-#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
+#define IOC_MPLS_STACKED                0x10000000   /**< Stacked MPLS. */
 
 typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
 #define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
@@ -436,18 +445,57 @@ typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options.
 #define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
 #define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-#define IOC_IPV4_FRAG_1                 0x00000008
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#define IOC_IPV4_FRAG_1                 0x00000008   /**< IPV4 reassembly option.
+                                                          IPV4 Reassembly manipulation requires network
+                                                          environment with IPV4 header and IPV4_FRAG_1 option  */
 
 typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
 #define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
 #define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
 #define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-#define IOC_IPV6_FRAG_1                 0x00000004
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#define IOC_IPV6_FRAG_1                 0x00000004   /**< IPV6 reassembly option.
+                                                          IPV6 Reassembly manipulation requires network
+                                                          environment with IPV6 header and IPV6_FRAG_1 option  */
+
+/* @} */
+
+#define IOC_FM_PCD_MANIP_MAX_HDR_SIZE               256
+#define IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+/**************************************************************************//**
+ @Collection    A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t                        ioc_hdr_manip_flags_t;              /**< A general type to define a HMan update command flags. */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv4_hdr_manip_update_flags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV4_TOS          0x80000000          /**< update TOS with the given value ('tos' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_ID           0x40000000          /**< update IP ID with the given value ('id' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_TTL          0x20000000          /**< Decrement TTL by 1 */
+#define IOC_HDR_MANIP_IPV4_SRC          0x10000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_DST          0x08000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv6_hdr_manip_update_flags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV6_TC           0x80000000          /**< update Traffic Class address with the given value
+                                                                 ('traffic_class' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_HL           0x40000000          /**< Decrement Hop Limit by 1 */
+#define IOC_HDR_MANIP_IPV6_SRC          0x20000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_DST          0x10000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_tcp_udp_hdr_manip_update_flags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_TCP_UDP_SRC       0x80000000          /**< update TCP/UDP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_DST       0x40000000          /**< update TCP/UDP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000          /**< update TCP/UDP checksum */
 
 /* @} */
 
@@ -465,17 +513,21 @@ typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRAC
                 (must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_engine {
-    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
     e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
-    e_IOC_FM_PCD_KG,            /**< Keygen indicated */
-    e_IOC_FM_PCD_CC,            /**< Coarse classification indicated */
-    e_IOC_FM_PCD_PLCR,          /**< Policer indicated */
-    e_IOC_FM_PCD_PRS            /**< Parser indicated */
+    e_IOC_FM_PCD_KG,            /**< KeyGen */
+    e_IOC_FM_PCD_CC,            /**< Coarse Classifier */
+    e_IOC_FM_PCD_PLCR,          /**< Policer */
+    e_IOC_FM_PCD_PRS,           /**< Parser */
+#if DPAA_VERSION >= 11
+    e_IOC_FM_PCD_FR,            /**< Frame Replicator */
+#endif /* DPAA_VERSION >= 11 */
+    e_IOC_FM_PCD_HASH           /**< Hash Table */
 } ioc_fm_pcd_engine;
 
 /**************************************************************************//**
  @Description   An enum for selecting extraction by header types
-                (must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
+                (Must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_extract_by_hdr_type {
     e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
@@ -484,9 +536,8 @@ typedef enum ioc_fm_pcd_extract_by_hdr_type {
 } ioc_fm_pcd_extract_by_hdr_type;
 
 /**************************************************************************//**
- @Description   An enum for selecting extraction source
-                (when it is not the header)
-                (must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
+ @Description   An enum for selecting extraction source (when it is not the header)
+                (Must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_extract_from {
     e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
@@ -520,9 +571,8 @@ typedef enum ioc_fm_pcd_kg_extract_dflt_select {
 } ioc_fm_pcd_kg_extract_dflt_select;
 
 /**************************************************************************//**
- @Description   An enum defining all default groups -
-                each group shares a default value, one of 4 user
-                initialized values.
+ @Description   Enumeration type defining all default groups - each group shares
+                a default value, one of four user-initialized values.
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
     e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
@@ -538,18 +588,19 @@ typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
     e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
     e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
     e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
                                                  any data extraction that is not the full
                                                  field described above  */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
                                                  any data extraction without validation */
-    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
                                                  extraction from parser result or
                                                  direct use of default value  */
 } ioc_fm_pcd_kg_known_fields_dflt_types;
 
 /**************************************************************************//**
- @Description   enum for defining header index when headers may repeat
+ @Description   Enumeration type for defining header index for scenarios with
+                multiple (tunneled) headers
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_hdr_index {
     e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
@@ -561,7 +612,7 @@ typedef enum ioc_fm_pcd_hdr_index {
 } ioc_fm_pcd_hdr_index;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile functional type
+ @Description   Enumeration type for selecting the policer profile functional type
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_profile_type_selection {
     e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
@@ -569,16 +620,16 @@ typedef enum ioc_fm_pcd_profile_type_selection {
 } ioc_fm_pcd_profile_type_selection;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile algorithem
+ @Description   Enumeration type for selecting the policer profile algorithm
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_algorithm_selection {
     e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
-    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
-    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorithm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorithm RFC 4115 */
 } ioc_fm_pcd_plcr_algorithm_selection;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile color mode
+ @Description   Enumeration type for selecting a policer profile color mode
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_color_mode {
     e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
@@ -586,7 +637,7 @@ typedef enum ioc_fm_pcd_plcr_color_mode {
 } ioc_fm_pcd_plcr_color_mode;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile color functional mode
+ @Description   Enumeration type for selecting a policer profile color
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_color {
     e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
@@ -596,7 +647,7 @@ typedef enum ioc_fm_pcd_plcr_color {
 } ioc_fm_pcd_plcr_color;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile packet frame length selector
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_frame_length_select {
   e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
@@ -606,7 +657,7 @@ typedef enum ioc_fm_pcd_plcr_frame_length_select {
 } ioc_fm_pcd_plcr_frame_length_select;
 
 /**************************************************************************//**
- @Description   An enum for selecting rollback frame
+ @Description   Enumeration type for selecting roll-back frame
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
   e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
@@ -614,7 +665,7 @@ typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
 } ioc_fm_pcd_plcr_roll_back_frame_select;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile packet or byte mode
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_rate_mode {
     e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
@@ -622,15 +673,15 @@ typedef enum ioc_fm_pcd_plcr_rate_mode {
 } ioc_fm_pcd_plcr_rate_mode;
 
 /**************************************************************************//**
- @Description   An enum for defining action of frame
+ @Description   Enumeration type for defining action of frame
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_done_action {
-    e_IOC_FM_PCD_ENQ_FRAME = 0,    /**< Enqueue frame */
-    e_IOC_FM_PCD_DROP_FRAME    /**< Drop frame */
+    e_IOC_FM_PCD_ENQ_FRAME = 0,     /**< Enqueue frame */
+    e_IOC_FM_PCD_DROP_FRAME         /**< Drop frame */
 } ioc_fm_pcd_done_action;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer counter
+ @Description   Enumeration type for selecting the policer counter
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_plcr_profile_counters {
     e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
@@ -641,7 +692,7 @@ typedef enum ioc_fm_pcd_plcr_profile_counters {
 } ioc_fm_pcd_plcr_profile_counters;
 
 /**************************************************************************//**
- @Description   A structure for selecting action
+ @Description   Enumeration type for selecting the PCD action after extraction
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_action {
     e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
@@ -654,47 +705,117 @@ typedef enum ioc_fm_pcd_action {
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
     e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
     e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#ifdef FM_CAPWAP_SUPPORT
     e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_pcd_manip_hdr_insrt_type;
 
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of remove manipulation
+*//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
     e_IOC_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
     e_IOC_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-#endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_pcd_manip_hdr_rmv_type;
 
-#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   An enum for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
+                                                             the header which follows the MPLS header */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_rmv_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_type {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,           /**< VLAN updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,           /**< IPV4 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,           /**< IPV6 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,        /**< TCP_UDP updates */
+} ioc_fm_pcd_manip_hdr_field_update_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_vlan {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
+} ioc_fm_pcd_manip_hdr_field_update_vlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_type {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
+} ioc_fm_pcd_manip_hdr_custom_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6, /**< Replace IPv4 by IPv6 */
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4  /**< Replace IPv6 by IPv4 */
+} ioc_fm_pcd_manip_hdr_custom_ip_replace;
+
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
-    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
-} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
 #endif /* FM_CAPWAP_SUPPORT */
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2           /**< Specific L2 fields removal */
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
 
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of timeout mode
+*//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
-    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,
-    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,         /**< Limits the time of the reassembly process
+                                                             from the first fragment to the last */
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG            /**< Limits the time of receiving the fragment */
 } ioc_fm_pcd_manip_reassem_time_out_mode;
 
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of WaysNumber mode
+*//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_reassem_ways_number {
-    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,
-    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,
-    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH
+    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
+    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
+    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
+    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
+    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
+    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
+    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
+    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
 } ioc_fm_pcd_manip_reassem_ways_number;
 
 #ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
 typedef enum ioc_fm_pcd_stats {
-    e_IOC_FM_PCD_STATS_PER_FLOWID = 0
+    e_IOC_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
 } ioc_fm_pcd_stats;
 #endif
 
@@ -712,8 +833,10 @@ typedef enum ioc_fm_pcd_manip_type {
  @Description   Enumeration type for selecting type of statistics mode
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_cc_stats_mode {
-    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,    /**< No statistics support */
-    e_IOC_FM_PCD_CC_STATS_MODE_FRAME        /**< Frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
+    e_IOC_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
 } ioc_fm_pcd_cc_stats_mode;
 
 /**************************************************************************//**
@@ -734,7 +857,8 @@ typedef enum ioc_fm_pcd_manip_special_offload_type {
 } ioc_fm_pcd_manip_special_offload_type;
 
 /**************************************************************************//**
- @Description   A Union of protocol dependent special options
+ @Description   A union of protocol dependent special options
+                (Must match union u_FmPcdHdrProtocolOpt defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef union ioc_fm_pcd_hdr_protocol_opt_u {
     ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
@@ -748,26 +872,26 @@ typedef union ioc_fm_pcd_hdr_protocol_opt_u {
  @Description   A union holding all known protocol fields
 *//***************************************************************************/
 typedef union ioc_fm_pcd_fields_u {
-    ioc_header_field_eth_t              eth;        /**< eth      */
-    ioc_header_field_vlan_t             vlan;       /**< vlan     */
-    ioc_header_field_llc_snap_t         llc_snap;   /**< llcSnap  */
-    ioc_header_field_pppoe_t            pppoe;      /**< pppoe    */
-    ioc_header_field_mpls_t             mpls;       /**< mpls     */
-    ioc_header_field_ipv4_t             ipv4;       /**< ipv4     */
-    ioc_header_field_ipv6_t             ipv6;       /**< ipv6     */
-    ioc_header_field_udp_t              udp;        /**< udp      */
-    ioc_header_field_tcp_t              tcp;        /**< tcp      */
-    ioc_header_field_sctp_t             sctp;       /**< sctp     */
-    ioc_header_field_dccp_t             dccp;       /**< dccp     */
-    ioc_header_field_gre_t              gre;        /**< gre      */
-    ioc_header_field_minencap_t         minencap;   /**< minencap */
-    ioc_header_field_ipsec_ah_t         ipsec_ah;   /**< ipsecAh  */
-    ioc_header_field_ipsec_esp_t        ipsec_esp;  /**< ipsecEsp */
-    ioc_header_field_udp_encap_esp_t    udp_encap_esp;    /**< udpEncapEsp */
+    ioc_header_field_eth_t              eth;            /**< Ethernet               */
+    ioc_header_field_vlan_t             vlan;           /**< VLAN                   */
+    ioc_header_field_llc_snap_t         llc_snap;       /**< LLC SNAP               */
+    ioc_header_field_pppoe_t            pppoe;          /**< PPPoE                  */
+    ioc_header_field_mpls_t             mpls;           /**< MPLS                   */
+    ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
+    ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
+    ioc_header_field_udp_t              udp;            /**< UDP                    */
+    ioc_header_field_tcp_t              tcp;            /**< TCP                    */
+    ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
+    ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
+    ioc_header_field_gre_t              gre;            /**< GRE                    */
+    ioc_header_field_minencap_t         minencap;       /**< Minimal Encapsulation  */
+    ioc_header_field_ipsec_ah_t         ipsec_ah;       /**< IPSec AH               */
+    ioc_header_field_ipsec_esp_t        ipsec_esp;      /**< IPSec ESP              */
+    ioc_header_field_udp_encap_esp_t    udp_encap_esp;  /**< UDP Encapsulation ESP  */
 } ioc_fm_pcd_fields_u;
 
 /**************************************************************************//**
- @Description   structure for defining header extraction for key generation
+ @Description   Parameters for defining header extraction for key generation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_from_hdr_t {
     uint8_t             size;           /**< Size in byte */
@@ -775,7 +899,7 @@ typedef struct ioc_fm_pcd_from_hdr_t {
 } ioc_fm_pcd_from_hdr_t;
 
 /**************************************************************************//**
- @Description   structure for defining field extraction for key generation
+ @Description   Parameters for defining field extraction for key generation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_from_field_t {
     ioc_fm_pcd_fields_u field;          /**< Field selection */
@@ -784,62 +908,65 @@ typedef struct ioc_fm_pcd_from_field_t {
 } ioc_fm_pcd_from_field_t;
 
 /**************************************************************************//**
- @Description   A structure of parameters used to define a single network
-                environment unit.
-                A unit should be defined if it will later be used by one or
-                more PCD engines to distinguich between flows.
+ @Description   Parameters for defining a single network environment unit
+                A distinction unit should be defined if it will later be used
+                by one or more PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdDistinctionUnit defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_distinction_unit_t {
     struct {
-        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
-        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
+        ioc_net_header_type             hdr;                /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;                /**< Select only one option! */
     } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
 } ioc_fm_pcd_distinction_unit_t;
 
 /**************************************************************************//**
- @Description   A structure of parameters used to define the different
-                units supported by a specific PCD Network Environment
-                Characteristics module. Each unit represent
-                a protocol or a group of protocols that may be used later
-                by the different PCD engines to distinguish between flows.
-                (must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
+ @Description   Parameters for defining all different distinction units supported
+                by a specific PCD Network Environment Characteristics module.
+
+                Each unit represent a protocol or a group of protocols that may
+                be used later by the different PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_net_env_params_t {
-    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
+    uint8_t                         num_of_distinction_units;/**< Number of different units to be identified */
     ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                                /**< An array of numOfDistinctionUnits of the
+                                                            /**< An array of num_of_distinction_units of the
                                                                      different units to be identified */
-    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
+    void                            *id;                    /**< Output parameter; Returns the net-env Id to be used */
 } ioc_fm_pcd_net_env_params_t;
 
-
 /**************************************************************************//**
- @Description   structure for defining a single extraction action
-                when creating a key
+ @Description   Parameters for defining a single extraction action when
+                creating a key
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_extract_entry_t {
     ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
     union {
-        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
             ioc_net_header_type             hdr;            /**< Header selection */
-            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
-            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
-                                                                  IP. Otherwise should be cleared.*/
-            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
+            bool                            ignore_protocol_validation;
+                                                            /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled
+                                                                 IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;           /**< Header extraction type select */
             union {
-                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
-                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
-                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
+                ioc_fm_pcd_from_hdr_t       from_hdr;       /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;     /**< Extract bytes from field parameters */
+                ioc_fm_pcd_fields_u         full_field;     /**< Extract full field parameters */
             } extract_by_hdr_type;
-        } extract_by_hdr;
-        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+        } extract_by_hdr;                                   /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
             ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
             ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
-            uint16_t                        ic_indx_mask;   /**< Relevant only for CC where
-                                                                 action=e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP */
+            uint16_t                        ic_indx_mask;   /**< Relevant only for CC when
+                                                                 action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP;
+                                                                 Note that the number of bits that are set within
+                                                                 this mask must be log2 of the CC-node 'num_of_keys'.
+                                                                 Note that the mask cannot be set on the lower bits. */
             uint8_t                         offset;         /**< Byte offset */
-            uint8_t                         size;           /**< Size in byte */
-        } extract_non_hdr;
+            uint8_t                         size;           /**< Size in bytes */
+        } extract_non_hdr;                                  /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
     } extract_params;
 } ioc_fm_pcd_extract_entry_t;
 
@@ -862,27 +989,35 @@ typedef struct ioc_fm_pcd_kg_extract_dflt_t {
     ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
 } ioc_fm_pcd_kg_extract_dflt_t;
 
+
 /**************************************************************************//**
  @Description   A structure for defining all parameters needed for
                 generation a key and using a hash function
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
-    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
-    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
-    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
+    uint32_t                            private_dflt0;          /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;          /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;   /**< defines the valid size of the following array */
     ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
+                                                                /**< An array of extraction definitions. */
+    uint8_t                             num_of_used_dflts;      /**< defines the valid size of the following array */
     ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
-    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
+                                                                /**< For each extraction used in this scheme, specify the required
+                                                                     default register to be used when header is not found.
+                                                                     types not specified in this array will get undefined value. */
+    uint8_t                             num_of_used_masks;      /**< Defines the valid size of the following array */
     ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
-    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
+    uint8_t                             hash_shift;             /**< Hash result right shift.
+                                                                     Selects the 24 bits out of the 64 hash result.
+                                                                     0 means using the 24 LSB's, otherwise use the
+                                                                     24 LSB's after shifting right.*/
     uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
                                                                              of queues for the key and hash functionality */
     uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
-    bool                                symmetric_hash;                 /**< TRUE to generate the same hash for frames with swapped source and
-                                                                  destination fields on all layers; If TRUE, driver will check that for
-                                                                  all layers, if SRC extraction is selected, DST extraction must also be
-                                                                  selected, and vice versa. */
+    bool                                symmetric_hash;         /**< TRUE to generate the same hash for frames with swapped source and
+                                                                     destination fields on all layers; If TRUE, driver will check that for
+                                                                     all layers, if SRC extraction is selected, DST extraction must also be
+                                                                     selected, and vice versa. */
 } ioc_fm_pcd_kg_key_extract_and_hash_params_t;
 
 /**************************************************************************//**
@@ -891,8 +1026,8 @@ typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
     ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
-    union{
-        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+    union {
+        struct {                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
             ioc_net_header_type             hdr;
             ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
                                                                      IP. Otherwise should be cleared.*/
@@ -938,38 +1073,38 @@ typedef struct ioc_fm_pcd_kg_scheme_counter_t {
                                  and continue from that point, TRUE to update/reset
                                  the counter when the scheme is written. */
     uint32_t    value;      /**< If update=TRUE, this value will be written into the
-                                 counter. clear this field to reset the counter. */
+                                 counter; clear this field to reset the counter. */
 } ioc_fm_pcd_kg_scheme_counter_t;
 
 /**************************************************************************//**
- @Description   A structure for defining policer profile
-                parameters as required by keygen (when policer
-                is the next engine after this scheme).
+ @Description   A structure for defining policer profile parameters as required by keygen
+                (when policer is the next engine after this scheme).
+                (Must match struct t_FmPcdKgPlcrProfile defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_plcr_profile_t {
     bool                shared_profile;                 /**< TRUE if this profile is shared between ports
                                                              (i.e. managed by master partition) May not be TRUE
                                                              if profile is after Coarse Classification*/
-    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
-                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
-                                                             together with fqidOffsetShift and numOfProfiles
+    bool                direct;                         /**< If TRUE, direct_relative_profile_id only selects the profile
+                                                             id, if FALSE fqid_offset_relative_profile_id_base is used
+                                                             together with fqid_offset_shift and num_of_profiles
                                                              parameters, to define a range of profiles from
-                                                             which the keygen result will determine the
+                                                             which the KeyGen result will determine the
                                                              destination policer profile.  */
-    union{
+    union {
         uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
-                                                             This parameter should
-                                                             indicate the policer profile offset within the port's
+                                                             This parameter should indicate the policer profile offset within the port's
                                                              policer profiles or SHARED window. */
         struct {
-            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
-            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
-                                                             This parameter should
-                                                             indicate the policer profile offset within the port's
-                                                             policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     fqid_offset_shift;              /**< Shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                        /**< OR of KG results without the qid base
+                                                             This parameter should indicate the policer profile
+                                                             offset within the port's policer profiles window
+                                                             or SHARED window depends on shared_profile */
             uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
-        } indirect_profile_id;
-    } profile_select;
+        } indirect_profile;                             /**< Indirect profile parameters */
+    } profile_select;                                   /**< Direct/indirect profile selection and parameters */
 } ioc_fm_pcd_kg_plcr_profile_t;
 
 #if DPAA_VERSION >= 11
@@ -1001,7 +1136,8 @@ typedef struct ioc_fm_pcd_kg_storage_profile_t {
 #endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
- @Description   A structure for CC parameters if CC is the next engine after KG
+ @Description   Parameters for defining CC as the next engine after KeyGen
+                (Must match struct t_FmPcdKgCc defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_cc_t {
     void                            *tree_id;           /**< CC Tree id */
@@ -1009,59 +1145,61 @@ typedef struct ioc_fm_pcd_kg_cc_t {
     bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
                                                              policing is required. */
     bool                            bypass_plcr_profile_generation;
-                                                        /**< TRUE to bypass keygen policer profile
-                                                             generation (profile selected is the one selected at
-                                                             port initialization). */
-    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
+                                                        /**< TRUE to bypass KeyGen policer profile generation;
+                                                             selected profile is the one set at port initialization. */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< Valid only if plcr_next = TRUE and
+                                                             bypass_plcr_profile_generation = FALSE */
 } ioc_fm_pcd_kg_cc_t;
 
 /**************************************************************************//**
- @Description   A structure for initializing a keygen single scheme
-                (must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
+ @Description   Parameters for defining initializing a KeyGen scheme
+                (Must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_scheme_params_t {
-    bool                                modify;         /**< enables changing an existing scheme */
-    union
-    {
+    bool                                modify;         /**< TRUE to change an existing scheme */
+    union {
         uint8_t                         relative_scheme_id;
-                                                         /**< if modify=FALSE:Partition relative scheme id */
-        void                            *scheme_id;      /**< if modify=TRUE: a handle of the existing scheme */
+                                                        /**< if modify=FALSE: partition-relative scheme id */
+        void                            *scheme_id;     /**< if modify=TRUE: the id of an existing scheme */
     } scm_id;
-    bool                                always_direct;   /**< This scheme is reached only directly, i.e.
-                                                              no need for match vector. Keygen will ignore
-                                                              it when matching   */
-    struct {                                             /**< HL Relevant only if alwaysDirect = FALSE */
-        void                            *net_env_id;     /**< Network environment id  */
+    bool                                always_direct;  /**< This scheme is reached only directly, i.e. no need
+                                                             for match vector; KeyGen will ignore it when matching */
+    struct {                                            /**< HL relevant only if always_direct=FALSE */
+        void                            *net_env_id;    /**< The id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
         uint8_t                         num_of_distinction_units;
-                                                         /**< Number of netenv units listed in unit_ids array */
+                                                        /**< Number of NetEnv units listed in unit_ids array */
         uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                         /**< Indexes as passed to SetNetEnvCharacteristics array*/
+                                                        /**< Indexes as passed to SetNetEnvCharacteristics (?) array */
     } net_env_params;
-    bool                                use_hash;        /**< use the KG Hash functionality */
+    bool                                use_hash;       /**< use the KG Hash functionality */
     ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
-                                                         /**< used only if useHash = TRUE */
+                                                        /**< used only if useHash = TRUE */
     bool                                bypass_fqid_generation;
-                                                         /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
-                                                              In such a case FQID after KG will be the default FQID
-                                                              defined for the relevant port, or the FQID defined by CC
-                                                              in cases where CC was the previous engine. */
-    uint32_t                            base_fqid;       /**< Base FQID */
-    uint8_t                             numOfUsedExtractedOrs;
-                                                         /**< Number of Fqid masks listed in extractedOrs array*/
+                                                        /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                             In such a case FQID after KG will be the default FQID
+                                                             defined for the relevant port, or the FQID defined by CC
+                                                             in cases where CC was the previous engine. */
+    uint32_t                            base_fqid;      /**< Base FQID; Relevant only if bypass_fqid_generation = FALSE;
+                                                             If hash is used and an even distribution is expected
+                                                             according to hash_distribution_num_of_fqids, base_fqid must be aligned to
+                                                             hash_distribution_num_of_fqids. */
+    uint8_t                             num_of_used_extracted_ors;
+                                                        /**< Number of FQID masks listed in extracted_ors array*/
     ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                                         /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
-                                                              registers are shared between qidMasks
-                                                              functionality and some of the extraction
-                                                              actions; Normally only some will be used
-                                                              for qidMask. Driver will return error if
-                                                              resource is full at initialization time. */
+                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                             registers are shared between qid_masks
+                                                             functionality and some of the extraction
+                                                             actions; Normally only some will be used
+                                                             for qid_mask. Driver will return error if
+                                                             resource is full at initialization time. */
 #if DPAA_VERSION >= 11
-    bool                                override_storage_profile; /**< TRUE if KeyGen override previously decided storage profile */
-    ioc_fm_pcd_kg_storage_profile       storage_profile;        /**< Used when overrideStorageProfile TRUE */
+    bool                                override_storage_profile;
+                                                        /**< TRUE if KeyGen override previously decided storage profile */
+    ioc_fm_pcd_kg_storage_profile_t     storage_profile;/**< Used when override_storage_profile=TRUE */
 #endif /* DPAA_VERSION >= 11 */
-
     ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
-    union{                                               /**< depends on nextEngine */
+    union {                                              /**< depends on nextEngine */
         ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
         ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
         ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
@@ -1072,26 +1210,44 @@ typedef struct ioc_fm_pcd_kg_scheme_params_t {
 } ioc_fm_pcd_kg_scheme_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining CC params when CC is the
-                next engine after a CC node
+ @Collection
+*//***************************************************************************/
+#define IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
+#define IOC_FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
+#define IOC_FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextCcParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_next_cc_params_t {
     void        *cc_node_id;                             /**< Id of the next CC node */
 } ioc_fm_pcd_cc_next_cc_params_t;
 
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   A structure for defining Frame Replicator as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextFrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_fr_params_t {
+    void*       frm_replic_id;              /**< The id of the next frame replicator group */
+} ioc_fm_pcd_cc_next_fr_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
 /**************************************************************************//**
  @Description   A structure for defining PLCR params when PLCR is the
                 next engine after a CC node
+                (Must match struct t_FmPcdCcNextPlcrParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
     bool        override_params;            /**< TRUE if CC override previously decided parameters*/
     bool        shared_profile;             /**< Relevant only if overrideParams=TRUE:
                                                 TRUE if this profile is shared between ports */
-    uint16_t    new_relative_profileId;     /**< Relevant only if overrideParams=TRUE:
-                                                (otherwise profile id
-                                                is taken from keygen);
-                                                This parameter should
-                                                indicate the policer profile offset within the port's
+    uint16_t    new_relative_profile_id;    /**< Relevant only if overrideParams=TRUE:
+                                                (otherwise profile id is taken from keygen);
+                                                This parameter should indicate the policer
+                                                profile offset within the port's
                                                 policer profiles or from SHARED window.*/
     uint32_t    new_fqid;                   /**< Relevant only if overrideParams=TRUE:
                                                 FQID for enquing the frame;
@@ -1099,163 +1255,195 @@ typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
                                                 this parameter can be 0, because the KEYGEN always decides
                                                 the enqueue FQID.*/
 #if DPAA_VERSION >= 11
-    uint8_t     new_relative_storage_profileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
+    uint8_t     new_relative_storage_profile_id;
+                                            /**< Indicates the relative storage profile offset within
+                                                 the port's storage profiles window;
+                                                 Relevant only if the port was configured with VSP. */
 #endif /* DPAA_VERSION >= 11 */
-
 } ioc_fm_pcd_cc_next_plcr_params_t;
 
 /**************************************************************************//**
  @Description   A structure for defining enqueue params when BMI is the
                 next engine after a CC node
+                (Must match struct t_FmPcdCcNextEnqueueParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
     ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
-    bool                    override_fqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
-                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
-    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
-                                                 (otherwise FQID is taken from keygen),
+    bool                    override_fqid;  /**< TRUE if CC override previously decided fqid and vspid,
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME */
+    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
                                                  relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
 #if DPAA_VERSION >= 11
-    uint8_t              new_relative_storage_profile_id;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
+    uint8_t                 new_relative_storage_profile_id;
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
 #endif /* DPAA_VERSION >= 11 */
 
 } ioc_fm_pcd_cc_next_enqueue_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining KG params when KG is the
-                next engine after a CC node
+ @Description   A structure for defining KG params when KG is the next engine after a CC node
+                (Must match struct t_FmPcdCcNextKgParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_next_kg_params_t {
-    bool       override_fqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
-                                          Note - this parameters unrelevant for earlier chips*/
-    uint32_t   new_fqid;                 /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
-                                         (otherwise FQID is taken from keygen),
-                                          Note - this parameters unrelevant for earlier chips*/
-    void       *p_direct_scheme;        /**< Direct scheme handle to go to. */
+    bool       override_fqid;               /**< TRUE if CC override previously decided fqid and vspid,
+                                                 Note - this parameters are irrelevant for earlier chips */
+    uint32_t   new_fqid;                    /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
+                                                 Note - this parameters are irrelevant for earlier chips */
 #if DPAA_VERSION >= 11
     uint8_t              new_relative_storage_profile_id;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
 #endif /* DPAA_VERSION >= 11 */
+    void       *p_direct_scheme;            /**< Direct scheme id to go to. */
 } ioc_fm_pcd_cc_next_kg_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining next engine params after a CC node.
-                (must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
+ @Description   Parameters for defining the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_next_engine_params_t {
-    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
-                                                                     to nextEngine definition */
+    ioc_fm_pcd_engine                           next_engine;    /**< User has to initialize parameters
+                                                                     according to nextEngine definition */
     union {
             ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
             ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
             ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
             ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
-    } params;
 #if DPAA_VERSION >= 11
-    void                                        *p_frm_replic_id; /**< Handle to frame replicator group;
-                                                                       Relevant if next engine is e_FM_PCD_INVALID) */
+            ioc_fm_pcd_cc_next_fr_params_t      fr_params;      /**< Parameters in case next engine is FR */
 #endif /* DPAA_VERSION >= 11 */
-
+    } params;                                                   /**< Union used for all the next-engine parameters options */
     void                                        *manip_id;      /**< Handle to Manipulation object.
                                                                      Relevant if next engine is of type result
-                                                                     (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
-
+                                                                     (e_IOC_FM_PCD_PLCR, e_IOC_FM_PCD_KG, e_IOC_FM_PCD_DONE) */
     bool                                        statistics_en;   /**< If TRUE, statistics counters are incremented
                                                                       for each frame passing through this
                                                                       Coarse Classification entry. */
 } ioc_fm_pcd_cc_next_engine_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining a single CC Key parameters
+ @Description   Parameters for defining a single CC key
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_key_params_t {
-    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
-    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
-                                         in keySize. p_Key and p_Mask (if defined) has to be
-                                         of the same size defined in the keySize */
+    uint8_t                 *p_key;         /**< pointer to the key of the size defined in key_size */
+    uint8_t                 *p_mask;        /**< pointer to the Mask per key of the size defined
+                                                 in keySize. p_key and p_mask (if defined) has to be
+                                                 of the same size defined in the key_size */
     ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                    /**< parameters for the next for the defined Key in
-                                         the p_Key */
+                                            /**< parameters for the next for the defined Key in p_key */
 
 } ioc_fm_pcd_cc_key_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining CC Keys parameters
+ @Description   Parameters for defining CC keys parameters
+                The driver supports two methods for CC node allocation: dynamic and static.
+                Static mode was created in order to prevent runtime alloc/free
+                of FMan memory (MURAM), which may cause fragmentation; in this mode,
+                the driver automatically allocates the memory according to
+                'max_num_of_keys' parameter. The driver calculates the maximal memory
+                size that may be used for this CC-Node taking into consideration
+                'mask_support' and 'statistics_mode' parameters.
+                When 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'max_num_of_keys' must be equal to 'num_of_keys'.
+                In dynamic mode, 'max_num_of_keys' must be zero. At initialization,
+                all required structures are allocated according to 'num_of_keys'
+                parameter. During runtime modification, these structures are
+                re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'ic_indx_mask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractccparams.extractnonhdr).
 *//***************************************************************************/
 typedef struct ioc_keys_params_t {
-    uint16_t                            max_num_of_keys;
-    bool                                mask_support;   /**< This parameter is relevant only if a node is initialized with
-                                                             action = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
-                                                             Should be TRUE if the node was initialized 'empty' (no keys)
-                                                             or with keys without masks, and user wants to be able to add
-                                                             a mask to a key later on in run-time. */
-    ioc_fm_pcd_cc_stats_mode            statistics_mode;/**< If enabled, the required structures for the requested statistics
-                                                             mode will be allocated according to 'maxNumOfKeys'. */
-    uint16_t                            num_of_keys;      /**< Number of initial keys;
-                                                               Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP
-                                                              (but the 'src' is not e_FM_PCD_EXTRACT_FROM_HASH; in this case,
-                                                              'numOfKeys' should be zero), this field should be power-of-2
-                                                              of the number of bits that are set in 'icIndxMask'. */
-    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
-                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
-                                                             key. In the another type of extraction keySize has to be as size of extraction. */
-    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
-                                                        /**< it's array with numOfKeys entries each entry in
-                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
+    uint16_t                    max_num_of_keys;/**< Maximum number of keys that will (ever) be used in this CC-Node;
+                                                     A value of zero may be used for dynamic memory allocation. */
+    bool                        mask_support;   /**< This parameter is relevant only if a node is initialized with
+                                                     action = e_IOC_FM_PCD_ACTION_EXACT_MATCH and max_num_of_keys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime. */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;/**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for
+                                                     the requested statistics mode will be allocated according to 'max_num_of_keys'. */
+    uint16_t                    frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                                /**< Relevant only for 'e_IOC_FM_PCD_CC_STATS_MODE_RMON' statistics
+                                                     mode.
+                                                     Holds a list of programmable thresholds. For each received frame,
+                                                     its length in bytes is examined against these range thresholds and
+                                                     the appropriate counter is incremented by 1. For example, to belong
+                                                     to range i, the following should hold:
+                                                     range i-1 threshold < frame length <= range i threshold
+                                                     Each range threshold must be larger then its preceding range
+                                                     threshold. Last range threshold must be 0xFFFF. */
+    uint16_t                    num_of_keys;    /**< Number of initial keys;
+                                                     Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'ic_indx_mask'. */
+    uint8_t                     key_size;       /**< Size of key - for extraction of type FULL_FIELD, 'key_size' has
+                                                     to be the standard size of the selected key; For other extraction
+                                                     types, 'key_size' has to be as size of extraction; When 'action' =
+                                                     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+    ioc_fm_pcd_cc_key_params_t  key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< An array with 'num_of_keys' entries, each entry specifies the
+                                                     corresponding key parameters;
+                                                     When 'action' = e_IOC_FM_PCD_ACTION_EXACT_MATCH, this value must not
+                                                     exceed 255 (IOC_FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+                                                     for the 'miss' entry. */
     ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
-                                                        /**< parameters for the next step of
-                                                             unfound (or undefined) key */
+                                                /**< Parameters for defining the next engine when a key is not matched;
+                                                     Not relevant if action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP. */
 } ioc_keys_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining the CC node params
+ @Description   Parameters for defining a CC node
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_params_t {
-    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
-    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
-                                                                 extraction defined in  extractParams */
-    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< Extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< Keys definition matching the selected extraction */
+    void                                *id;                /**< Output parameter; returns the CC node Id to be used */
 } ioc_fm_pcd_cc_node_params_t;
 
 /**************************************************************************//**
  @Description   Parameters for defining a hash table
+                (Must match struct t_FmPcdHashTableParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_hash_table_params_t {
-    uint16_t                    max_num_of_keys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
-    ioc_fm_pcd_cc_stats_mode    statistics_mode;             /**< If enabled, the required structures for the requested statistics
-                                                                 mode will be allocated according to maxNumOfKeys. */
-    uint16_t                    hash_res_mask;                /**< Mask that will be used on the hash-result;
+    uint16_t                    max_num_of_keys;            /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;            /**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to max_num_of_keys. */
+    uint16_t                    hash_res_mask;              /**< Mask that will be used on the hash-result;
                                                                  The number-of-sets for this hash will be calculated
-                                                                 as (2^(number of bits set in 'hashResMask'));
+                                                                 as (2^(number of bits set in 'hash_res_mask'));
                                                                  The 4 lower bits must be cleared. */
-    uint8_t                     hash_shift;                  /**< Byte offset from the beginning of the KeyGen hash result to the
+    uint8_t                     hash_shift;                 /**< Byte offset from the beginning of the KeyGen hash result to the
                                                                  2-bytes to be used as hash index. */
-    uint8_t                     match_key_size;               /**< Size of the exact match keys held by the hash buckets */
-
-    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;  /**< Parameters for defining the next engine when a key is not matched */
+    uint8_t                     match_key_size;             /**< Size of the exact match keys held by the hash buckets */
 
+    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
+                                                            /**< Parameters for defining the next engine when a key is not matched */
     void                        *id;
-
 } ioc_fm_pcd_hash_table_params_t;
 
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableAddKey ioctl() call
+*//***************************************************************************/
 typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
-    void                        *p_hash_tbl;
+    void                       *p_hash_tbl;
     uint8_t                     key_size;
-    ioc_fm_pcd_cc_key_params_t  *p_key_params;
+    ioc_fm_pcd_cc_key_params_t *p_key_params;
 } ioc_fm_pcd_hash_table_add_key_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining each CC tree group in term of
-                NetEnv units and the action to be taken in each case.
-                the unit_ids list must be in order from lower to higher indexes.
+ @Description   Parameters for defining a CC tree group.
+
+                This structure defines a CC group in terms of NetEnv units
+                and the action to be taken in each case. The unit_ids list must
+                be given in order from low to high indices.
 
                 ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
                 structures where each defines the next action to be taken for
@@ -1272,29 +1460,29 @@ typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
                                                     unit 1 - found; unit 3 - found;
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_grp_params_t {
-    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             num_of_distinction_units;   /**< Up to 4 */
     uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
                                                                     /**< Indexes of the units as defined in
-                                                                         FM_PCD_SetNetEnvCharacteristics */
+                                                                         FM_PCD_NetEnvCharacteristicsSet() */
     ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
-                                                                    /**< Max size is 16 - if only one group used */
+                                                                    /**< Maximum entries per group is 16 */
 } ioc_fm_pcd_cc_grp_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining the CC tree groups
-                (must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
+ @Description   Parameters for defining the CC tree groups
+                (Must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_tree_params_t {
-        void                            *net_env_id;    /**< Id of the Network environment as returned
-                                                             by FM_PCD_SetNetEnvCharacteristics */
+        void                            *net_env_id;    /**< Id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
         uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
         ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
                                                         /**< Parameters for each group. */
-        void                            *id;            /**< output parameter; Returns the tree Id to be used */
+        void                            *id;            /**< Output parameter; Returns the tree Id to be used */
 } ioc_fm_pcd_cc_tree_params_t;
 
 /**************************************************************************//**
- @Description   A structure for defining parameters for byte rate
+ @Description   Parameters for defining policer byte rate
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
     ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
@@ -1303,8 +1491,8 @@ typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
 } ioc_fm_pcd_plcr_byte_rate_mode_param_t;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile RFC 2698 or
-                RFC 4115 parameters
+ @Description   Parameters for defining the policer profile (based on
+                RFC-2698 or RFC-4115 attributes).
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
     ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
@@ -1316,7 +1504,7 @@ typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
 } ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
 
 /**************************************************************************//**
- @Description   A union for defining Policer next engine parameters
+ @Description   Parameters for defining the next engine after policer
 *//***************************************************************************/
 typedef union ioc_fm_pcd_plcr_next_engine_params_u {
         ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
@@ -1331,39 +1519,39 @@ typedef struct fm_pcd_port_params_t {
 } fm_pcd_port_params_t;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile entry parameters
-                (must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
+ @Description   Parameters for defining the policer profile entry
+                (Must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_plcr_profile_params_t {
     bool                                        modify;                     /**< TRUE to change an existing profile */
     union {
         struct {
             ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
-            void                               *p_port;                     /**< Type of policer profile */
+            void                               *p_port;                     /**< Relevant for per-port profiles only */
             uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
-        } new_params;
+        } new_params;                                                       /**< Use it when modify = FALSE */
         void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
     } profile_select;
-    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
     ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
 
     union {
-        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
-                                                                                 any incoming packet with the deflt value. */
-        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode; the policer will re-color
+                                                                                 any incoming packet with the default value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes; the profile response to a
                                                                                  pre-color value of 2'b11. */
     } color;
 
-    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 parameters */
 
-    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Next engine for green-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Next engine parameters for green-colored frames  */
 
-    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Next engine for yellow-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Next engine parameters for yellow-colored frames  */
 
-    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Next engine for red-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Next engine parameters for red-colored frames  */
 
     bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
     bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
@@ -1377,9 +1565,9 @@ typedef struct ioc_fm_pcd_plcr_profile_params_t {
 typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
     void                                *id;                /**< CC tree Id to be used */
     uint8_t                             grp_indx;           /**< A Group index in the tree */
-    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
+    uint8_t                             indx;               /**< Entry index in the group defined by grp_index */
     ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                                            /**< parameters for the next for the defined Key in the p_Key */
+                                                            /**< Parameters for the next for the defined Key in the p_Key */
 } ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
 
 /**************************************************************************//**
@@ -1423,52 +1611,76 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
     uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
     uint8_t                             key_size;           /**< Key size of added key */
-    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
-    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
-                                                                 in keySize. p_Key and p_Mask (if defined) has to be
-                                                                 of the same size defined in the keySize */
+    uint8_t                             *p_key;             /**< Pointer to the key of the size defined in key_size */
+    uint8_t                             *p_mask;            /**< Pointer to the Mask per key of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) have to be
+                                                                 of the same size as defined in the key_size */
 } ioc_fm_pcd_cc_node_modify_key_params_t;
 
 /**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableRemoveKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
+    void       *p_hash_tbl;     /**< The id of the hash table */
+    uint8_t     key_size;       /**< The size of the key to remove */
+    uint8_t    *p_key;          /**< Pointer to the key to remove */
+} ioc_fm_pcd_hash_table_remove_key_params_t;
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
  @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_manip_hdr_info_t {
     ioc_net_header_type                 hdr;            /**< Header selection */
     ioc_fm_pcd_hdr_index                hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
     bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
-    ioc_fm_pcd_fields_u                 full_field;      /**< Relevant only when byField = TRUE: Extract field */
+    ioc_fm_pcd_fields_u                 full_field;     /**< Relevant only when by_field = TRUE: Extract field */
 } ioc_fm_manip_hdr_info_t;
+#endif /* FM_CAPWAP_SUPPORT */
 
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_by_hdr_type        type;  /**< Selection of header removal location */
+    union {
 #ifdef FM_CAPWAP_SUPPORT
-TODO: missing code
-#endif
-
-typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
-    void    *p_hash_tbl;
-    uint8_t key_size;
-    uint8_t *p_key;
-} ioc_fm_pcd_hash_table_remove_key_params_t;
+        struct {
+            bool                                include;/**< If FALSE, remove until the specified header (not including the header);
+                                                             If TRUE, remove also the specified header. */
+            ioc_fm_manip_hdr_info_t             hdr_info;
+        } from_start_by_hdr;                           /**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+        ioc_fm_pcd_manip_hdr_rmv_specific_l2    specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+                                                                 Defines which L2 headers to remove. */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t;
 
 /**************************************************************************//**
  @Description   Parameters for configuring IP fragmentation manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
-    uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
-                                                             IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 10)
-    uint8_t                     scratch_bpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 10) */
-    bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
-                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
-                                                             received frame's buffer. */
-    uint8_t                     sg_bpid;                 /**< Scatter/Gather buffer pool id;
-                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                             of this pool need to be allocated in the same memory area as the received buffers.
-                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                             mutual to all these sources. */
-    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;  /**< Dont Fragment Action - If an IP packet is larger
-                                                             than MTU and its DF bit is set, then this field will
-                                                             determine the action to be taken.*/
+    uint16_t                    size_for_fragmentation;     /**< If length of the frame is greater than this value,
+                                                                 IP fragmentation will be executed.*/
+#if DPAA_VERSION == 10
+    uint8_t                     scratch_bpid;               /**< Absolute buffer pool id according to BM configuration.*/
+#endif /* DPAA_VERSION == 10 */
+    bool                        sg_bpid_en;                 /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                                 If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                                 received frame's buffer. */
+    uint8_t                     sg_bpid;                    /**< Scatter/Gather buffer pool id;
+                                                                 Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                                 of this pool need to be allocated in the same memory area as the received buffers.
+                                                                 If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                                 mutual to all these sources. */
+    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;    /**< Dont Fragment Action - If an IP packet is larger
+                                                                 than MTU and its DF bit is set, then this field will
+                                                                 determine the action to be taken.*/
+#ifdef ALU_CUSTOM
+    bool                        options_counter_en;         /**< If TRUE, A counter is incremented each time an IPv4 frame with IPv4 Options
+                                                                 is encountered and the COPIED flag on one of the options is cleared.
+                                                                 The counter is located on the port page */
+#endif /* ALU_CUSTOM */
 } ioc_fm_pcd_manip_frag_ip_params_t;
 
 /**************************************************************************//**
@@ -1476,58 +1688,71 @@ typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
 
                 This is a common structure for both IPv4 and IPv6 reassembly
                 manipulation. For reassembly of both IPv4 and IPv6, make sure to
-                set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
+                set the 'hdr' field in ioc_fm_pcd_manip_reassem_params_t to IOC_HEADER_TYPE_IPv6.
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
     uint8_t                         relative_scheme_id[2];    /**< Partition relative scheme id:
                                                                  relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
                                                                  relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassemblys schemes will be first match.
-                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
-    uint8_t                         sg_bpid;                  /**< Buffer pool id for the S/G frame created by the reassembly process */
-    uint8_t                         data_mem_id;              /**< Memory partition ID for the IPR's external tables structure */
-    uint16_t                        data_liodn_offset;        /**< LIODN offset for access the IPR's external tables structure. */
-    uint16_t                        min_frag_size[2];         /**< Minimum fragment size:
+                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
+                                                                 The remaining schemes, if defined, should have higher relative scheme ID. */
+#if DPAA_VERSION >= 11
+    uint32_t                        non_consistent_sp_fqid; /**< In case that other fragments of the frame corresponds to different storage
+                                                                 profile than the opening fragment (Non-Consistent-SP state)
+                                                                 then one of two possible scenarios occurs:
+                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
+    uint8_t                         sg_bpid;                /**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* DPAA_VERSION >= 11 */
+    uint8_t                         data_mem_id;            /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;      /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        min_frag_size[2];       /**< Minimum fragment size:
                                                                  minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
     ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
                                                             /**< Number of frames per hash entry needed for reassembly process:
-                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
-                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_FM_PCD_MANIP_SIX_WAYS_HASH). */
-    uint16_t                        max_num_frames_in_process;  /**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        max_num_frames_in_process;/**< Number of frames which can be processed by Reassembly in the same time;
                                                                  Must be power of 2;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 4 - 512;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 8 - 2048. */
-    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqid_for_time_out_frames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;  /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;/**< FQID in which time out frames will enqueue during Time Out Process  */
     uint32_t                        timeout_threshold_for_reassm_process;
                                                             /**< Represents the time interval in microseconds which defines
                                                                  if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
 } ioc_fm_pcd_manip_reassem_ip_params_t;
 
 /**************************************************************************//**
- @Description   structure for defining IPSEC manipulation
+ @Description   Parameters for defining IPSEC manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
     bool    decryption;                     /**< TRUE if being used in decryption direction;
                                                  FALSE if being used in encryption direction. */
-    bool    ecn_copy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+    bool    ecn_copy;                       /**< TRUE to copy the ECN bits from inner/outer to outer/inner
                                                  (direction depends on the 'decryption' field). */
-    bool    dscp_copy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+    bool    dscp_copy;                      /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
                                                  (direction depends on the 'decryption' field). */
-    bool    variable_ip_hdr_len;               /**< TRUE for supporting variable IP header length in decryption. */
+    bool    variable_ip_hdr_len;            /**< TRUE for supporting variable IP header length in decryption. */
+    bool    variable_ip_version;            /**< TRUE for supporting both IP version on the same SA in encryption */
+    uint8_t outer_ip_hdr_len;               /**< If 'variable_ip_version == TRUE' than this field must be set to non-zero value;
+                                                 It is specifies the length of the outer IP header that was configured in the
+                                                 corresponding SA. */
 } ioc_fm_pcd_manip_special_offload_ipsec_params_t;
 
 /**************************************************************************//**
  @Description   Parameters for defining special offload manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_special_offload_params_t {
-    ioc_fm_pcd_manip_special_offload_type              type;       /**< Type of special offload manipulation */
+    ioc_fm_pcd_manip_special_offload_type               type;       /**< Type of special offload manipulation */
     union
     {
-        ioc_fm_pcd_manip_special_offload_ipsec_params_t   ipsec;
+        ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;      /**< Parameters for IPSec; Relevant when
+                                                                         type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
     } u;
 } ioc_fm_pcd_manip_special_offload_params_t;
 
@@ -1553,16 +1778,154 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
 } ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
 
 /**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t {
+    uint8_t                         dscp_to_vpri_table[IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+                                                    /**< A table of VPri values for each DSCP value;
+                                                         The index is the D_SCP value (0-0x3F) and the
+                                                         value is the corresponding VPRI (0-15). */
+    uint8_t                         vpri_def_val;   /**< 0-7, Relevant only if if update_type =
+                                                         e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+                                                         this field is the Q Tag default value if the
+                                                         IP header is not found. */
+} ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_t {
+    ioc_fm_pcd_manip_hdr_field_update_vlan  update_type;    /**< Selects VLAN update type */
+    union {
+        uint8_t                                     vpri;   /**< 0-7, Relevant only if If update_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+                                                                 is the new VLAN pri. */
+        ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t    dscp_to_vpri;
+                                                            /**<  Parameters structure, Relevant only if update_type =
+                                                                  e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_vlan_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv4_t {
+    ioc_ipv4_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 tos;            /**< 8 bit New TOS; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV4_TOS */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_ID */
+    uint32_t                                src;            /**< 32 bit New IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_SRC */
+    uint32_t                                dst;            /**< 32 bit New IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv4_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv6_t {
+    ioc_ipv6_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 traffic_class;  /**< 8 bit New Traffic Class; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV6_TC */
+    uint8_t                                 src[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_SRC */
+    uint8_t                                 dst[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv6_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t {
+    ioc_tcp_udp_hdr_manip_update_flags_t    valid_updates;  /**< ORed flag, selecting the required updates */
+    uint16_t                                src;            /**< 16 bit New TCP/UDP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_SRC */
+    uint16_t                                dst;            /**< 16 bit New TCP/UDP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_DST */
+} ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_params_t {
+    ioc_fm_pcd_manip_hdr_field_update_type          type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_field_update_vlan_t    vlan;   /**< Parameters for VLAN update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+        ioc_fm_pcd_manip_hdr_field_update_ipv4_t    ipv4;   /**< Parameters for IPv4 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+        ioc_fm_pcd_manip_hdr_field_update_ipv6_t    ipv6;   /**< Parameters for IPv6 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+        ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t tcp_udp;/**< Parameters for TCP/UDP update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t {
+    ioc_fm_pcd_manip_hdr_custom_ip_replace  replace_type;   /**< Selects replace update type */
+    bool                                    dec_ttl_hl;     /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1 */
+    bool                                    update_ipv4_id; /**< Relevant when replace_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if
+                                                                 update_ipv4_id = TRUE */
+    uint8_t                                 hdr_size;       /**< The size of the new IP header */
+    uint8_t                                 hdr[IOC_FM_PCD_MANIP_MAX_HDR_SIZE];
+                                                            /**< The new IP header */
+} ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_params_t {
+    ioc_fm_pcd_manip_hdr_custom_type                type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t    ip_hdr_replace;
+                                                            /**< Parameters IP header replacement */
+    } u;
+} ioc_fm_pcd_manip_hdr_custom_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_specific_l2  specific_l2;    /**< Selects which L2 headers to insert */
+    bool                                    update;         /**< TRUE to update MPLS header */
+    uint8_t                                 size;           /**< size of inserted section */
+    uint8_t                                *p_data;         /**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_by_hdr_type          type;   /**< Selects manipulation type */
+    union {
+       ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
+                                                            /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                                 Selects which L2 headers to remove */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
+
+/**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
     ioc_fm_pcd_manip_hdr_insrt_type                     type;   /**< Type of insertion manipulation */
     union {
-        ioc_fm_pcd_manip_hdr_insrt_generic_params_t       generic;
-                                                        /**< Parameters for defining generic header insertion manipulation,
-                                                             relevant if type = e_FM_PCD_MANIP_INSRT_GENERIC */
+        ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t      by_hdr; /**< Parameters for defining header insertion manipulation by header type,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
+        ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
+                                                                     relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
 #ifdef FM_CAPWAP_SUPPORT
-TODO:
+        ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
+                                                                /**< Parameters for defining header insertion manipulation by template,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
 } ioc_fm_pcd_manip_hdr_insrt_params_t;
@@ -1573,11 +1936,10 @@ TODO:
 typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
     ioc_fm_pcd_manip_hdr_rmv_type                  type;       /**< Type of header removal manipulation */
     union {
-#ifdef FM_CAPWAP_SUPPORT
-TODO:
-#endif /* FM_CAPWAP_SUPPORT */
-        ioc_fm_pcd_manip_hdr_rmv_generic_params_t     generic;    /**< Parameters for defining generic header removal manipulation,
-                                                             relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
+        ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t   by_hdr;     /**< Parameters for defining header removal manipulation by header type,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR */
+        ioc_fm_pcd_manip_hdr_rmv_generic_params_t  generic;    /**< Parameters for defining generic header removal manipulation,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_GENERIC */
     } u;
 } ioc_fm_pcd_manip_hdr_rmv_params_t;
 
@@ -1585,15 +1947,20 @@ TODO:
  @Description   Parameters for defining header manipulation node
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_hdr_params_t {
-    bool                                        rmv;                /**< TRUE, to define removal manipulation */
-    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;          /**< Parameters for removal manipulation, relevant if rmv = TRUE */
+    bool                                        rmv;                  /**< TRUE, to define removal manipulation */
+    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;           /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
+
+    bool                                        insrt;                /**< TRUE, to define insertion manipulation */
+    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;         /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
 
-    bool                                        insrt;              /**< TRUE, to define insertion manipulation */
-    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;        /**< Parameters for insertion manipulation, relevant if insrt = TRUE */
+    bool                                        field_update;         /**< TRUE, to define field update manipulation */
+    ioc_fm_pcd_manip_hdr_field_update_params_t  field_update_params;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
 
+    bool                                        custom;               /**< TRUE, to define custom manipulation */
+    ioc_fm_pcd_manip_hdr_custom_params_t        custom_params;        /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
 
     bool                                        dont_parse_after_manip;/**< FALSE to activate the parser a second time after
-                                                                         completing the manipulation on the frame */
+                                                                            completing the manipulation on the frame */
 } ioc_fm_pcd_manip_hdr_params_t;
 
 
@@ -1601,10 +1968,10 @@ typedef struct ioc_fm_pcd_manip_hdr_params_t {
  @Description   structure for defining fragmentation manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_frag_params_t {
-    ioc_net_header_type                 hdr;          /**< Header selection */
+    ioc_net_header_type                     hdr;            /**< Header selection */
     union {
-        ioc_fm_pcd_manip_frag_ip_params_t ip_frag;       /**< Parameters for defining IP fragmentation,
-                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+        ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;        /**< Parameters for defining IP fragmentation,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
 } ioc_fm_pcd_manip_frag_params_t;
 
@@ -1612,10 +1979,10 @@ typedef struct ioc_fm_pcd_manip_frag_params_t {
  @Description   structure for defining reassemble manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_reassem_params_t {
-    ioc_net_header_type                 hdr;          /**< Header selection */
+    ioc_net_header_type                         hdr;        /**< Header selection */
     union {
-        ioc_fm_pcd_manip_reassem_ip_params_t ip_reassem;    /**< Parameters for defining IP reassembly,
-                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+        ioc_fm_pcd_manip_reassem_ip_params_t    ip_reassem; /**< Parameters for defining IP reassembly,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
 } ioc_fm_pcd_manip_reassem_params_t;
 
@@ -1623,19 +1990,23 @@ typedef struct ioc_fm_pcd_manip_reassem_params_t {
  @Description   Parameters for defining a manipulation node
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_params_t {
-    ioc_fm_pcd_manip_type                         type;               /**< Selects type of manipulation node */
-    union{
-        ioc_fm_pcd_manip_hdr_params_t             hdr;                /**< Parameters for defining header manipulation node */
-        ioc_fm_pcd_manip_reassem_params_t         reassem;            /**< Parameters for defining reassembly manipulation node */
-        ioc_fm_pcd_manip_frag_params_t            frag;               /**< Parameters for defining fragmentation manipulation node */
-        ioc_fm_pcd_manip_special_offload_params_t special_offload;     /**< Parameters for defining special offload manipulation node */
+    ioc_fm_pcd_manip_type                           type;   /**< Selects type of manipulation node */
+    union {
+        ioc_fm_pcd_manip_hdr_params_t               hdr;    /**< Parameters for defining header manipulation node */
+        ioc_fm_pcd_manip_reassem_params_t           reassem;/**< Parameters for defining reassembly manipulation node */
+        ioc_fm_pcd_manip_frag_params_t              frag;   /**< Parameters for defining fragmentation manipulation node */
+        ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
     } u;
-     void*                                        p_next_manip;        /**< Handle to another (previously defined) manipulation node;
-                                                                            Allows concatenation of manipulation actions */
+    void*                                           p_next_manip;/**< Handle to another (previously defined) manipulation node;
+                                                                      Allows concatenation of manipulation actions
+                                                                      This parameter is optional and may be NULL. */
 #ifdef FM_CAPWAP_SUPPORT
-#warning "feature not supported!"
-#endif
-	void                                      *id;
+#error "FM_CAPWAP_SUPPORT feature not supported!"
+    bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
+    ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
+                                                                            relevant if frag_or_reasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+    void                                           *id;
 } ioc_fm_pcd_manip_params_t;
 
 /**************************************************************************//**
@@ -1696,7 +2067,7 @@ typedef struct ioc_fm_pcd_manip_frag_stats_t {
  @Description   structure for defining manipulation statistics
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_stats_t {
-    union{
+    union {
         ioc_fm_pcd_manip_reassem_stats_t  reassem;    /**< Structure for reassembly statistics */
         ioc_fm_pcd_manip_frag_stats_t     frag;       /**< Structure for fragmentation statistics */
     } u;
@@ -1709,26 +2080,28 @@ typedef struct ioc_fm_pcd_manip_stats_t {
 typedef struct ioc_fm_pcd_frm_replic_group_params_t {
     uint8_t                     max_num_of_entries;    /**< Maximal number of members in the group  - must be at least two */
     uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
-    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
 } ioc_fm_pcd_frm_replic_group_params_t;
 #endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
+ @Function      FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
 
- @Description   Define a set of Network Environment Charecteristics.
                 When setting an environment it is important to understand its
                 application. It is not meant to describe the flows that will run
                 on the ports using this environment, but what the user means TO DO
                 with the PCD mechanisms in order to parse-classify-distribute those
                 frames.
                 By specifying a distinction unit, the user means it would use that option
-                for distinction between frames at either a keygen scheme keygen or a coarse
+                for distinction between frames at either a KeyGen scheme or a coarse
                 classification action descriptor. Using interchangeable headers to define a
                 unit means that the user is indifferent to which of the interchangeable
-                headers is present in the frame, and they want the distinction to be based
+                headers is present in the frame, and wants the distinction to be based
                 on the presence of either one of them.
+
                 Depending on context, there are limitations to the use of environments. A
                 port using the PCD functionality is bound to an environment. Some or even
                 all ports may share an environment but also an environment per port is
@@ -1737,6 +2110,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
                 stated and related to. When a port is bound to a scheme, a classification
                 plan group, or a coarse classification tree, it MUST be bound to the same
                 environment.
+
                 The different PCD modules, may relate (for flows definition) ONLY on
                 distinction units as defined by their environment. When initializing a
                 scheme for example, it may not choose to select IPV4 as a match for
@@ -1744,110 +2118,113 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
                 fact, to guide the user through the configuration of the PCD, each module's
                 characterization in terms of flows is not done using protocol names, but using
                 environment indexes.
+
                 In terms of HW implementation, the list of distinction units sets the LCV vectors
                 and later used for match vector, classification plan vectors and coarse classification
                 indexing.
 
- @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   A structure defining the distiction units for this configuration.
 
  @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT   FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
+
 #endif
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
+ @Function      FM_PCD_NetEnvCharacteristicsDelete
 
  @Description   Deletes a set of Network Environment Charecteristics.
 
- @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
+ @Param[in]     ioc_fm_obj_t - The id of a Network Environment object.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS   FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_SCHEME
+ @Function      FM_PCD_KgSchemeSet
 
- @Description   Initializing or modifying and enabling a scheme for the keygen.
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
                 This routine should be called for adding or modifying a scheme.
                 When a scheme needs modifying, the API requires that it will be
-                rewritten. In such a case 'override' should be TRUE. If  the
-                routine is called for a valid scheme and 'override' is FALSE,
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
                 it will return error.
 
- @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+ @Param[in,out] ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
 
  @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#define FM_PCD_IOC_KG_SCHEME_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT     FM_PCD_IOC_KG_SCHEME_SET_COMPAT
 #endif
-#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+#define FM_PCD_IOC_KG_SCHEME_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+#define FM_PCD_IOC_KG_SET_SCHEME    FM_PCD_IOC_KG_SCHEME_SET
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_KG_DEL_SCHEME
+ @Function      FM_PCD_KgSchemeDelete
 
  @Description   Deleting an initialized scheme.
 
  @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
 
  @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT     FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+#define FM_PCD_IOC_KG_SCHEME_DELETE     _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+#define FM_PCD_IOC_KG_DEL_SCHEME        FM_PCD_IOC_KG_SCHEME_DELETE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_BUILD_TREE
+ @Function      FM_PCD_CcRootBuild
 
  @Description   This routine must be called to define a complete coarse
                 classification tree. This is the way to define coarse
-                classification to a certain flow - the keygen schemes
+                classification to a certain flow - the KeyGen schemes
                 may point only to trees defined in this way.
 
  @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
 
- @Return        0 on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 //#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_compat_fm_pcd_cc_tree_params_t)
-#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
 #endif
 //#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
-#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+#define FM_PCD_IOC_CC_ROOT_BUILD    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+#define FM_PCD_IOC_CC_BUILD_TREE    FM_PCD_IOC_CC_ROOT_BUILD
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_DELETE_TREE
-
- @Description   Deleting an built tree.
+ @Function      FM_PCD_CcRootDelete
 
- @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
+ @Description   Deleting a built tree.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Param[in]     ioc_fm_obj_t - The id of a CC tree.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT    FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+#define FM_PCD_IOC_CC_ROOT_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+#define FM_PCD_IOC_CC_DELETE_TREE    FM_PCD_IOC_CC_ROOT_DELETE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_MATCH_TABLE_SET
+ @Function      FM_PCD_MatchTableSet
 
  @Description   This routine should be called for each CC (coarse classification)
                 node. The whole CC tree should be built bottom up so that each
@@ -1856,10 +2233,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 
  @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
 
- @Return        0 on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_MATCH_TABLE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
@@ -1867,146 +2241,178 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 #define FM_PCD_IOC_MATCH_TABLE_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
 
 /**************************************************************************//**
- @Function      FM_PCD_CcDeleteNode
+ @Function      FM_PCD_MatchTableDelete
 
- @Description   Deleting an built node.
+ @Description   Deleting a built node.
 
- @Param[in]     ioc_fm_obj_t    An id of a CC-node.
+ @Param[in]     ioc_fm_obj_t - The id of a CC node.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+#define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+#define FM_PCD_IOC_CC_DELETE_NODE       FM_PCD_IOC_MATCH_TABLE_DELETE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
+ @Function      FM_PCD_CcRootModifyNextEngine
 
  @Description   Modify the Next Engine Parameters in the entry of the tree.
 
- @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcBuildTree().
+ @Cautions      Allowed only following FM_PCD_CcRootBuild().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT    FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
+ @Function      FM_PCD_MatchTableModifyNextEngine
 
  @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
 
  @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode().
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT       FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE       FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
+ @Function      FM_PCD_MatchTableModifyMissNextEngine
 
  @Description   Modify the Next Engine Parameters of the Miss key case of the node.
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode().
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT      FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE      FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
+ @Function      FM_PCD_MatchTableRemoveKey
 
- @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the index of the relevant node.
 
  @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY       FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
+ @Function      FM_PCD_MatchTableAddKey
 
- @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+ @Description   Add the key (including next engine parameters of this key in the
+                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+                may be used when the user doesn't care about the position of the
+                key in the table - in that case, the key will be automatically
+                added by the driver in the last available entry.
 
  @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_ADD_KEY      FM_PCD_IOC_MATCH_TABLE_ADD_KEY
+
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
+ @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
 
- @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by key_index.
 
  @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() not only of the relevnt node but also
                 the node that points to this node
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT        FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE       FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
+ @Function      FM_PCD_MatchTableModifyKey
 
- @Description   Modify the key  in the index defined by the keyIndex .
+ @Description   Modify the key at the index defined by key_index.
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  A pointer to a structure with the relevant parameters
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t - Pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT        FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
 #endif
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
-
-/**************************************************************************//*
- @Function      FM_PCD_IOC_HASH_TABLE_SET
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY       FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
 
- @Description   This routine simulates KeyGen operation on the provided key and
-                calculates to which hash bucket it will be mapped.
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableSet
 
- @Param[in]     TODO  A pointer to a structure with the relevant parameters
+ @Description   This routine initializes a hash table structure.
+                KeyGen hash result determines the hash bucket.
+                Next, KeyGen key is compared against all keys of this
+                bucket (exact match).
+                Number of sets (number of buckets) of the hash equals to the
+                number of 1-s in 'hash_res_mask' in the provided parameters.
+                Number of hash table ways is then calculated by dividing
+                'max_num_of_keys' equally between the hash sets. This is the maximal
+                number of keys that a hash bucket may hold.
+                The hash table is initialized empty and keys may be
+                added to it following the initialization. Keys masks are not
+                supported in current hash table implementation.
+                The initialized hash table can be integrated as a node in a
+                CC tree.
 
- @Return        E_OK on success; Error code otherwise.
+ @Param[in,out] ioc_fm_pcd_hash_table_params_t - Pointer to a structure with the relevant parameters
 
- @Cautions      Allowed only following FM_PCD_HashTableSet()
+ @Return        0 on success; Error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
@@ -2015,14 +2421,14 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_HASH_TABLE_DELETE
+ @Function      FM_PCD_HashTableDelete
 
  @Description   This routine deletes the provided hash table and released all
                 its allocated resources.
 
- @Param[in]     p_hash_tbl A handle to a hash table
+ @Param[in]     ioc_fm_obj_t - The ID of a hash table.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
@@ -2032,16 +2438,16 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 #define FM_PCD_IOC_HASH_TABLE_DELETE _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_HASH_TABLE_ADD_KEY
+ @Function      FM_PCD_HashTableAddKey
 
  @Description   This routine adds the provided key (including next engine
                 parameters of this key) to the hash table.
                 The key is added as the last key of the bucket that it is
                 mapped to.
 
- @Param[in]     TODO  A pointer to a structure with the relevant parameters
+ @Param[in]     ioc_fm_pcd_hash_table_add_key_params_t - Pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
@@ -2051,14 +2457,14 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 #define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_HASH_TABLE_REMOVE_KEY
+ @Function      FM_PCD_HashTableRemoveKey
 
  @Description   This routine removes the requested key (including next engine
                 parameters of this key) from the hash table.
 
- @Param[in]     TODO  A pointer to a structure with the relevant parameters
+ @Param[in]     ioc_fm_pcd_hash_table_remove_key_params_t - Pointer to a structure with the relevant parameters
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
@@ -2068,7 +2474,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 #define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_PLCR_SET_PROFILE
+ @Function      FM_PCD_PlcrProfileSet
 
  @Description   Sets a profile entry in the policer profile table.
                 The routine overrides any existing value.
@@ -2077,46 +2483,94 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
                                                     policer profile entry.
 
  @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
 #endif
-#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_PROFILE_SET     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_SET_PROFILE     FM_PCD_IOC_PLCR_PROFILE_SET
+
 
 /**************************************************************************//**
- @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
+ @Function      FM_PCD_PlcrProfileDelete
 
  @Description   Delete a profile entry in the policer profile table.
                 The routine set entry to invalid.
 
- @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
+ @Param[in]     ioc_fm_obj_t        The id of a policer profile.
 
  @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_fm_obj_t)
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_fm_obj_t)
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     FM_PCD_IOC_PLCR_PROFILE_DELETE
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
 
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+*//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_NODE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
 #endif
-#define FM_PCD_IOC_MANIP_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_SET_NODE   FM_PCD_IOC_MANIP_NODE_SET
 
 
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]     ioc_fm_obj_t       The id of the manipulation node to delete.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
 #endif
-#define FM_PCD_IOC_MANIP_DELETE_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
+#define FM_PCD_IOC_MANIP_NODE_DELETE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
+#define FM_PCD_IOC_MANIP_DELETE_NODE    FM_PCD_IOC_MANIP_NODE_DELETE
+
+/**************************************************************************//**
+@Function      FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
 
+@Return        0 on success; error code otherwise.
+
+@Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
 #define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
 
 #ifdef FM_CAPWAP_SUPPORT
 #warning "CAPWAP IOCTL not implemented"
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in,out] ioc_fm_pcd_stats_params_t A structure of parameters defining the statistics
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
 #endif
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
index 336a427..b61ad62 100644
--- a/include/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -44,6 +44,7 @@
 
 
 /**************************************************************************//**
+
  @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
 
  @Description   FM Linux ioctls definitions and enums
@@ -63,9 +64,11 @@
                 Host command/Offline parsing ports. The SW driver manages these
                 ports as sub-modules of the FM, i.e. after an FM is initialized,
                 its ports may be initialized and operated upon.
+
                 The port is initialized aware of its type, but other functions on
                 a port may be indifferent to its type. When necessary, the driver
                 verifies coherency and returns error if applicable.
+
                 On initialization, user specifies the port type and it's index
                 (relative to the port's type). Host command and Offline parsing
                 ports share the same id range, I.e user may not initialized host
@@ -75,27 +78,18 @@
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
-
- @Description   FM Port Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    General FM Port defines
-*//***************************************************************************/
-#ifdef CONFIG_FMAN_P1023
-#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS       32 /**< Total number of congestion groups in QM */
-#else
-#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
-#endif
-/* @} */
-
+ @Description   An enum for defining port PCD modes.
+                (Must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
 
-/**************************************************************************//**
- @Description   struct for defining port PCD modes
-                (must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+                Note: the first engine and the first engine after the parser (if
+                exists) should be in order, the order is important as it will
+                define the flow of the port. However, as for the rest engines
+                (the ones that follows), the order is not important anymore as
+                it is defined by the PCD graph itself.
 *//***************************************************************************/
 typedef enum ioc_fm_port_pcd_support {
       e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
@@ -105,9 +99,10 @@ typedef enum ioc_fm_port_pcd_support {
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
-                                                    /**< Use all PCD engines */
+                                                        /**< Use all PCD engines */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
 #ifdef FM_CAPWAP_SUPPORT
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
@@ -115,11 +110,102 @@ typedef enum ioc_fm_port_pcd_support {
 #endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_port_pcd_support;
 
+
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#ifdef CONFIG_FMAN_P1023
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS       32 /**< Total number of congestion groups in QM */
+#else
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
+#endif
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t; /**< typedef for defining Frame Descriptor errors */
+
+#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT      FM_FD_ERR_UNSUPPORTED_FORMAT    /**< Not for Rx-Port! Unsupported Format */
+#define IOC_FM_PORT_FRM_ERR_LENGTH                  FM_FD_ERR_LENGTH                /**< Not for Rx-Port! Length Error */
+#define IOC_FM_PORT_FRM_ERR_DMA                     FM_FD_ERR_DMA                   /**< DMA Data error */
+#ifdef FM_DISABLE_SEC_ERRORS
+#define IOC_FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /*< Non Frame-Manager error;
+                                                                                        probably come from SEC that was chained to FM */
+#endif /* FM_DISABLE_SEC_ERRORS */
+
+#define IOC_FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)    /**< IPR error */
+#define IOC_FM_PORT_FRM_ERR_IPR_TO                  (FM_FD_ERR_IPR_TO & ~FM_FD_IPR) /**< IPR timeout */
+#define IOC_FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                   /**< IPF error */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define IOC_FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
+#define IOC_FM_PORT_FRM_ERR_CHE                     FM_FD_ERR_CHE
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define IOC_FM_PORT_FRM_ERR_PHYSICAL                FM_FD_ERR_PHYSICAL              /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                                         error (SGMII and TBI modes), FIFO parity error, PHY
+                                                                                         Sequence error, PHY error control character detected. */
+#define IOC_FM_PORT_FRM_ERR_SIZE                    FM_FD_ERR_SIZE                  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< classification discard */
+#define IOC_FM_PORT_FRM_ERR_EXTRACTION              FM_FD_ERR_EXTRACTION            /**< Extract Out of Frame */
+#define IOC_FM_PORT_FRM_ERR_NO_SCHEME               FM_FD_ERR_NO_SCHEME             /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW        FM_FD_ERR_KEYSIZE_OVERFLOW      /**< Keysize Overflow */
+#define IOC_FM_PORT_FRM_ERR_COLOR_RED               FM_FD_ERR_COLOR_RED             /**< Frame color is red */
+#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW            FM_FD_ERR_COLOR_YELLOW          /**< Frame color is yellow */
+#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                FM_FD_ERR_ILL_PLCR              /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN          FM_FD_ERR_PLCR_FRAME_LEN        /**< Policer frame length error */
+#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT             FM_FD_ERR_PRS_TIMEOUT           /**< Parser Time out Exceed */
+#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT        FM_FD_ERR_PRS_ILL_INSTRUCT      /**< Invalid Soft Parser instruction */
+#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR             FM_FD_ERR_PRS_HDR_ERR           /**< Header error was identified during parsing */
+#define IOC_FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED    FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
+#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001                      /**< FPM Frame Processing Timeout Exceeded */
+/* @} */
+
+
 /**************************************************************************//**
- @Description   enum for defining FM Port counters
-                (must match enum e_FmPortCounters defined in fm_port_ext.h)
+ @Description   An enum for defining Dual Tx rate limiting scale.
+                (Must match e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
 *//***************************************************************************/
-typedef enum fm_port_counters {
+typedef enum ioc_fm_port_dual_rate_limiter_scale_down {
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} ioc_fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+                (Must match struct t_FmPortRateLimit defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit_t {
+    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    ioc_fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining FM Port counters.
+                (Must match enum e_FmPortCounters defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_counters {
     e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
     e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
     e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
@@ -142,108 +228,127 @@ typedef enum fm_port_counters {
     e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
     e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
     e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
-} fm_port_counters;
+} ioc_fm_port_counters;
 
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
+                (Description may be inaccurate;
+                must match struct t_FmPortCongestionGrps defined in fm_port_ext.h)
+
                 Fields commented 'IN' are passed by the port module to be used
                 by the FM module.
                 Fields commented 'OUT' will be filled by FM before returning to port.
 *//***************************************************************************/
 typedef struct ioc_fm_port_congestion_groups_t {
-    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
-    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
+    uint16_t    num_of_congestion_grps_to_consider;     /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of CG indexes;
+                                                             Note that the size of the array should be
+                                                             'num_of_congestion_grps_to_consider'. */
+#if DPAA_VERSION >= 11
+    bool        pfc_priorities_enable[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                        /**< A matrix that represents the map between the CG ids
+                                                             defined in 'congestion_grps_to_consider' to the priorities
+                                                             mapping array. */
+#endif /* DPAA_VERSION >= 11 */
 } ioc_fm_port_congestion_groups_t;
 
-/**************************************************************************//**
- @Description   struct for defining Dual Tx rate limiting scale
-                (identical to e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef enum fm_port_dual_rate_limiter_scale_down {
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
-} fm_port_dual_rate_limiter_scale_down;
-
-/**************************************************************************//**
- @Description   struct for defining Tx rate limiting
-                (identical to t_FmPortRateLimit defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_rate_limit {
-    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
-                                                                     for offline parsing ports. (note that
-                                                                     for early chips burst size is
-                                                                     rounded up to a multiply of 1000 frames).*/
-    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     offline parsing ports. Rate limit refers to
-                                                                     data rate (rather than line rate). */
-    fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
-                                                                     for some earlier chip revisions */
-} ioc_fm_port_rate_limit_t;
 
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_DISABLE
+ @Function      FM_PORT_Disable
 
  @Description   Gracefully disable an FM port. The port will not start new tasks after all
                 tasks associated with the port are terminated.
 
- @Return        0 on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init().
-                This is a blocking routine, it returns after port is
+ @Cautions      This is a blocking routine, it returns after port is
                 gracefully stopped, i.e. the port will not except new frames,
                 but it will finish all frames or tasks which were already began
 *//***************************************************************************/
 #define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_ENABLE
+ @Function      FM_PORT_Enable
 
  @Description   A runtime routine provided to allow disable/enable of port.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_SET_RATE_LIMIT
+ @Function      FM_PORT_SetRateLimit
 
  @Description   Calling this routine enables rate limit algorithm.
                 By default, this functionality is disabled.
                 Note that rate-limit mechanism uses the FM time stamp.
                 The selected rate limit specified here would be
-                rounded to the nearest power of 2 multiplication
-                (i.e. up to twice the required rate).
+                rounded DOWN to the nearest 16M.
 
                 May be used for Tx and offline parsing ports only
 
  @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
 
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_REMOVE_RATE_LIMIT
+ @Function      FM_PORT_DeleteRateLimit
 
  @Description   Calling this routine disables the previously enabled rate limit.
 
                 May be used for Tx and offline parsing ports only
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_RATE_LIMIT   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+#define FM_PORT_IOC_REMOVE_RATE_LIMIT   FM_PORT_IOC_DELETE_RATE_LIMIT
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define      FM_PORT_IOC_ADD_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(34), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
-#define FM_PORT_IOC_REMOVE_RATE_LIMIT _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+#define      FM_PORT_IOC_REMOVE_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(35), ioc_fm_port_congestion_groups_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
+ @Function      FM_PORT_SetErrorsRoute
 
  @Description   Errors selected for this routine will cause a frame with that error
                 to be enqueued to error queue.
@@ -257,12 +362,17 @@ typedef struct ioc_fm_port_rate_limit {
 
  @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                (szbs001: How is it possible to have one function that needs to be
+                          called BEFORE FM_PORT_Init() implemented as an ioctl,
+                          which will ALWAYS be called AFTER the FM_PORT_Init()
+                          for that port!?!?!?!???!?!??!?!?)
 *//***************************************************************************/
 #define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
 
+
 /**************************************************************************//**
  @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
 
@@ -272,40 +382,33 @@ typedef struct ioc_fm_port_rate_limit {
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   A structure of scheme parameters
-                (must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
+ @Description   A structure defining the KG scheme after the parser.
+                (Must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
+
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_scheme_select_t {
     bool        direct;                     /**< TRUE to use 'scheme_id' directly, FALSE to use LCV.*/
-    void        *scheme_id;                 /**< Relevant for 'direct'=TRUE only.
+    void       *scheme_id;                  /**< Relevant for 'direct'=TRUE only.
                                                  'scheme_id' selects the scheme after parser. */
 } ioc_fm_pcd_kg_scheme_select_t;
 
 /**************************************************************************//**
- @Description    A structure for defining the Parser starting point
-                (must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_start_t {
-    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
-                                             start parsing */
-    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
-                                             'parsing_offset' */
-} ioc_fm_pcd_prs_start_t;
-
-/**************************************************************************//**
  @Description   Scheme IDs structure
-                (must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
+                (Must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_port_schemes_params_t {
     uint8_t     num_of_schemes;                         /**< Number of schemes for port to be bound to. */
-    void        *scheme_ids [FM_PCD_KG_NUM_OF_SCHEMES];
-                                                        /**< Array of 'num_of_schemes' schemes for the
+    void        *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];  /**< Array of 'num_of_schemes' schemes for the
                                                              port to be bound to */
 } ioc_fm_pcd_port_schemes_params_t;
 
 /**************************************************************************//**
- @Description   Union for defining port protocol parameters for parser
-                (must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
+ @Description   A union for defining port protocol parameters for parser
+                (Must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef union ioc_fm_pcd_hdr_prs_opts_u {
     /* MPLS */
@@ -315,6 +418,7 @@ typedef union ioc_fm_pcd_hdr_prs_opts_u {
                                                              is cleared, the parser will advance to MPLS next parse */
         ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
     } mpls_prs_options;
+
     /* VLAN */
     struct {
         uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
@@ -322,6 +426,12 @@ typedef union ioc_fm_pcd_hdr_prs_opts_u {
         uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
                                                              on VLAN TAG on top of 0x8100 and 0x88A8 */
     } vlan_prs_options;
+
+    /* PPP */
+    struct{
+        bool                enable_mtu_check;           /**< Check validity of MTU according to RFC2516 */
+    } pppoe_prs_options;
+
     /* IPV6 */
     struct {
         bool                routing_hdr_disable;        /**< Disable routing header */
@@ -338,7 +448,6 @@ typedef union ioc_fm_pcd_hdr_prs_opts_u {
     } tcp_prs_options;
 } ioc_fm_pcd_hdr_prs_opts_u;
 
-
 /**************************************************************************//**
  @Description   A structure for defining each header for the parser
                 (must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
@@ -358,73 +467,73 @@ typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
 } ioc_fm_pcd_prs_additional_hdr_params_t;
 
 /**************************************************************************//**
- @Description   struct for defining port PCD parameters
-                (must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
+ @Description   A structure for defining port PCD parameters
+                (Must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_prs_params_t {
-    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
-                                                                             port information into the parser result. This information
-                                                                             may be extracted by Keygen and be used for frames
-                                                                             distribution when a per-port distinction is required,
-                                                                             it may also be used as a port logical id for analyazing
-                                                                             incoming frames. */
-    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
-                                                                             start parsing */
-    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
-                                                                             'parsingOffset' */
-    bool                                    includeInPrsStatistics;     /**< TRUE to include this port in the parser statistics;
-                                                                              NOTE: this field is not valid when the FN is in "guest" mode. */
-    uint8_t                                 num_of_hdrs_with_additional_params;
-                                                        /**< Normally 0, some headers may get
-                                                             special parameters */
+    uint8_t                         prs_res_priv_info;      /**< The private info provides a method of inserting
+                                                                 port information into the parser result. This information
+                                                                 may be extracted by KeyGen and be used for frames
+                                                                 distribution when a per-port distinction is required,
+                                                                 it may also be used as a port logical id for analyzing
+                                                                 incoming frames. */
+    uint8_t                         parsing_offset;         /**< Number of bytes from begining of packet to start parsing */
+    ioc_net_header_type             first_prs_hdr;          /**< The type of the first header axpected at 'parsing_offset' */
+    bool                            include_in_prs_statistics; /**< TRUE to include this port in the parser statistics */
+    uint8_t                         num_of_hdrs_with_additional_params;
+                                                            /**< Normally 0, some headers may get special parameters */
     ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
-                                                        /**< A structure of additional parameters
-                                                             for each header that requires them */
-    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
-                                                                             indicate a VLAN tag (in addition to the TPID values
-                                                                             0x8100 and 0x88A8). */
-    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
-    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
-                                                                             indicate a VLAN tag (in addition to the TPID values
-                                                                             0x8100 and 0x88A8). */
-    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+                                                            /**< 'num_of_hdrs_with_additional_params' structures
+                                                                  additional parameters for each header that requires them */
+    bool                            set_vlan_tpid1;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid1;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
+    bool                            set_vlan_tpid2;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid2;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
 } ioc_fm_port_pcd_prs_params_t;
 
 /**************************************************************************//**
- @Description   struct for defining coarse alassification parameters
-                (must match t_FmPortPcdCcParams defined in fm_port_ext.h)
+ @Description   A structure for defining coarse alassification parameters
+                (Must match t_FmPortPcdCcParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_cc_params_t {
     void                *cc_tree_id; /**< CC tree id */
 } ioc_fm_port_pcd_cc_params_t;
 
 /**************************************************************************//**
- @Description   struct for defining keygen parameters
-                (must match t_FmPortPcdKgParams defined in fm_port_ext.h)
+ @Description   A structure for defining keygen parameters
+                (Must match t_FmPortPcdKgParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_kg_params_t {
     uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
-    void                *schemes_ids[FM_PCD_KG_NUM_OF_SCHEMES];
-                                                        /**< Array of 'numOfSchemes' schemes for the
+    void               *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'num_of_schemes' schemes for the
                                                              port to be bound to */
     bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
                                                              regardless of parser result */
-    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
+    void               *direct_scheme_id;               /**< Scheme id, as returned by FM_PCD_KgSetScheme;
+                                                             relevant only if direct=TRUE. */
 } ioc_fm_port_pcd_kg_params_t;
 
 /**************************************************************************//**
- @Description   struct for defining policer parameters
-                (must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
+ @Description   A structure for defining policer parameters
+                (Must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_plcr_params_t {
-    void                *plcr_profile_id;               /**< relevant only if
-                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
-                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+    void                *plcr_profile_id;               /**< Selected profile handle;
+                                                             relevant in one of the following cases:
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                             or if any flow uses a KG scheme where policer
+                                                                profile is not generated (bypass_plcr_profile_generation selected) */
 } ioc_fm_port_pcd_plcr_params_t;
 
 /**************************************************************************//**
- @Description   struct for defining port PCD parameters
-                (must match struct t_FmPortPcdParams defined in fm_port_ext.h)
+ @Description   A structure for defining port PCD parameters
+                (Must match struct t_FmPortPcdParams defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_params_t {
     ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
@@ -434,9 +543,22 @@ typedef struct ioc_fm_port_pcd_params_t {
     ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
     ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
     ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
-    void                            *p_ip_reassembly_manip;
+    void                            *p_ip_reassembly_manip;/**< IP Reassembly manipulation */
 } ioc_fm_port_pcd_params_t;
 
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+                (Must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+
 /**************************************************************************//**
  @Description   FQID parameters structure
 *//***************************************************************************/
@@ -456,9 +578,7 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 
  @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
 
@@ -471,14 +591,13 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 
  @Param[in]		uint32_t	Base FQID of previously allocated range.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define FM_PORT_IOC_FREE_PCD_FQIDS   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), uint32_t)
 
+
 /**************************************************************************//**
- @Function      FM_PORT_IOC_SET_PCD
+ @Function      FM_PORT_SetPCD
 
  @Description   Calling this routine defines the port's PCD configuration.
                 It changes it from its default configuration which is PCD
@@ -490,9 +609,7 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
  @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
                                             configuration.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
@@ -500,80 +617,74 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_DELETE_PCD
+ @Function      FM_PORT_DeletePCD
 
  @Description   Calling this routine releases the port's PCD configuration.
                 The port returns to its default configuration which is PCD
                 disabled (BMI to BMI) and all PCD configuration is removed.
 
                 May be used for Rx and offline parsing ports which are
-                in PCD mode  only
-
- @Return        E_OK on success; Error code otherwise.
+                in PCD mode only
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_DETACH_PCD
+ @Function      FM_PORT_AttachPCD
 
- @Description   Calling this routine detaches the port from its PCD functionality.
-                The port returns to its default flow which is BMI to BMI.
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
 
                 May be used for Rx and offline parsing ports which are
                 in PCD mode only
 
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
-#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_ATTACH_PCD
+ @Function      FM_PORT_DetachPCD
 
- @Description   This routine may be called after FM_PORT_DetachPCD was called,
-                to return to the originally configured PCD support flow.
-                The couple of routines are used to allow PCD configuration changes
-                that demand that PCD will not be used while changes take place.
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
 
                 May be used for Rx and offline parsing ports which are
                 in PCD mode only
 
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
-#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
+ @Function      FM_PORT_PcdPlcrAllocProfiles
 
  @Description   This routine may be called only for ports that use the Policer in
                 order to allocate private policer profiles.
 
  @Param[in]     uint16_t       The number of required policer profiles
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
 *//***************************************************************************/
 #define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
+ @Function      FM_PORT_PcdPlcrFreeProfiles
 
  @Description   This routine should be called for freeing private policer profiles.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
 *//***************************************************************************/
 #define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
+ @Function      FM_PORT_PcdKgModifyInitialScheme
 
  @Description   This routine may be called only for ports that use the keygen in
                 order to change the initial scheme frame should be routed to.
@@ -583,9 +694,7 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
  @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
                                                 a scheme is direct/indirect, and if direct - scheme id.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
@@ -593,18 +702,16 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
 
- @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
-                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
-                should be routed to. The change may be of a profile and/or absolute/direct mode
-                selection.
+ @Description   This routine may be called for ports with flows
+                e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only,
+                to change the initial Policer profile frame should be routed to.
+                The change may be of a profile and/or absolute/direct mode selection.
 
  @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
@@ -612,16 +719,16 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
+ @Function      FM_PORT_PcdCcModifyTree
 
  @Description   This routine may be called to change this port connection to
                 a pre-initializes coarse classification Tree.
 
  @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
 
- @Return        0 on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Cautions      Allowed only following FM_PORT_SetPCD() and FM_PORT_DetachPCD()
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
@@ -629,7 +736,7 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
+ @Function      FM_PORT_PcdKgBindSchemes
 
  @Description   These routines may be called for modifying the binding of ports
                 to schemes. The scheme itself is not added,
@@ -637,9 +744,9 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 
  @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
 
- @Return        0 on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Cautions      Allowed only following FM_PORT_SetPCD().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
@@ -647,7 +754,7 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
+ @Function      FM_PORT_PcdKgUnbindSchemes
 
  @Description   These routines may be called for modifying the binding of ports
                 to schemes. The scheme itself is not removed or invalidated,
@@ -655,9 +762,9 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 
  @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
 
- @Return        0 on success; Error code otherwise.
+ @Return        0 on success; error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Cautions      Allowed only following FM_PORT_SetPCD().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
 #define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
@@ -665,37 +772,35 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 #define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
 
 /**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
+ @Function      FM_PORT_PcdPrsModifyStartOffset
 
  @Description   Runtime change of the parser start offset within the header.
 
  @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
                                         start point for the parser.
 
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
 #define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
 
+#if 0 /* Removed from LLD!?! */
 /**************************************************************************//**
- @Function      FM_PORT_SET_OP_WORKAROUNDS
+ @Function      FM_PORT_IOC_SET_OP_WORKAROUNDS
 
  @Description   Calling this routine sets the required offline port workaround.
 
- @Param[in]     h_FmPort        FM PORT module descriptor.
- @Param[in]     workarounds)    Reuired workaround.
+ @Param[in]     uint32_t    Required workaround.
 
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
+ @Return        0 on success; error code otherwise.
 *//***************************************************************************/
-#define      FM_PORT_SET_OP_WORKAROUNDS _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(33), uint32_t)
+#define      FM_PORT_IOC_SET_OP_WORKAROUNDS _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(33), uint32_t)
+#endif
+
+
 
 /** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+
 /** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
 /** @} */ /* end of lnx_ioctl_FM_grp group */
-
-
 #endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
index 287500e..aef7cb8 100644
--- a/include/linux/fmd/net_ioctls.h
+++ b/include/linux/fmd/net_ioctls.h
@@ -83,6 +83,7 @@ typedef uint8_t ioc_header_field_eth_t;
 #define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
 #define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
 
+#define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
 
 typedef uint16_t ioc_header_field_ipv4_t;
 
@@ -103,6 +104,9 @@ typedef uint16_t ioc_header_field_ipv4_t;
 #define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
 #define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
 
+#define IOC_NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
 
 typedef uint8_t ioc_header_field_ipv6_t;
 
@@ -115,6 +119,9 @@ typedef uint8_t ioc_header_field_ipv6_t;
 #define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
 #define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
 
+#define IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
 #define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
 #define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
 #define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
@@ -122,6 +129,9 @@ typedef uint8_t ioc_header_field_ipv6_t;
 #define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
 #define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
 
+#define IOC_NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
 #define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
 #define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
 #define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
@@ -144,6 +154,8 @@ typedef uint16_t ioc_header_field_tcp_t;
 #define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
 #define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
 
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
 
 typedef uint8_t ioc_header_field_sctp_t;
 
@@ -153,6 +165,7 @@ typedef uint8_t ioc_header_field_sctp_t;
 #define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
 #define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
 
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
 
 typedef uint8_t ioc_header_field_dccp_t;
 
@@ -160,6 +173,8 @@ typedef uint8_t ioc_header_field_dccp_t;
 #define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
 #define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
 
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
 
 typedef uint8_t ioc_header_field_udp_t;
 
@@ -169,15 +184,20 @@ typedef uint8_t ioc_header_field_udp_t;
 #define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
 #define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
 
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
 typedef uint8_t ioc_header_field_udp_encap_esp_t;
 
 #define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
 
 #define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
 #define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
@@ -318,14 +338,16 @@ typedef uint8_t ioc_header_field_ipsec_ah_t;
 
 #define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
 #define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
 
 
 typedef uint8_t ioc_header_field_ipsec_esp_t;
 
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM          (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
 
 
 typedef uint8_t ioc_header_field_mpls_t;
@@ -339,6 +361,7 @@ typedef uint8_t ioc_header_field_macsec_t;
 #define IOC_NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
 #define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
 
+
 typedef enum {
     e_IOC_NET_HEADER_TYPE_NONE = 0,
     e_IOC_NET_HEADER_TYPE_PAYLOAD,
-- 
1.7.9.7

