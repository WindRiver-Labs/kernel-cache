From beb015af6f19d8d164b2c81e5bae4b17ae25036e Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Fri, 11 May 2012 12:26:36 +0300
Subject: [PATCH 064/162] FMD16 sync with NCSW GA 4.5 RC 2

Added a check for insufficient FIFO size when using super jumbo Frames;
Additional fix in CC locking for SMP;
Fixes for few issues reported by static analysis;
Cosmetics, doxygen, whitespace, etc.

Signed-off-by: Andrei Pistirica <sorin.pistirica@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |  285 +++++++++-----------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |    3 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |   74 ++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |    8 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |   18 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |   62 +++--
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |    9 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |    7 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  121 +++++----
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   13 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |    4 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h  |    6 +-
 .../freescale/dpa/NetCommSw/src/xx/xx_linux.c      |    6 +-
 16 files changed, 317 insertions(+), 305 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
index 8169765..aa320a3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -58,7 +58,7 @@
  */
 struct crc64_t {
     uint64_t initial;                       /**< Initial seed */
-    uint64_t table[CRC64_TABLE_ENTRIES];    /**< crc table entries */
+    uint64_t table[CRC64_TABLE_ENTRIES];    /**< crc table entries*/
 };
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index f4a53e8..28a21ed 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -57,7 +57,7 @@
 
 static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
@@ -69,7 +69,7 @@ static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 
 static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
@@ -78,8 +78,12 @@ static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 
 static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 {
+    uint32_t    intFlags;
+
     ASSERT_COND(p_CcNode);
 
+    intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
+
     if(add)
         p_CcNode->owners++;
     else
@@ -87,6 +91,8 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
         ASSERT_COND(p_CcNode->owners);
         p_CcNode->owners--;
     }
+
+    XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 }
 
 static void FillAdOfTypeContLookup(t_Handle h_Ad,
@@ -172,25 +178,35 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
 
 static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 {
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t            intFlags;
 
     ASSERT_COND(p_CcNode);
 
-    if(!p_CcNode->h_Ad)
+    intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
+
+    if (!p_CcNode->h_Ad)
     {
         p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
                                            FM_PCD_CC_AD_ENTRY_SIZE,
                                            FM_PCD_CC_AD_TABLE_ALIGN);
+
+        XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
+
         if(!p_CcNode->h_Ad)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
 
         IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
         FillAdOfTypeContLookup(p_CcNode->h_Ad,
                                p_CcNode->h_FmPcd,
                                p_CcNode,
                                NULL,
                                NULL);
     }
+    else
+        XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
+
     return E_OK;
 }
 
@@ -237,7 +253,7 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
-                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo);
+                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
                     }
                     if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
@@ -245,7 +261,7 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 1);
                         if(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
-                        FmPcdCcDequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree);
+                        DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
                     }
                     if(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
@@ -347,7 +363,9 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         else
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-        p_CcNodeInformation = FmPcdCcFindNodeInfoInReleventLst(p_UpdateLst, p_AdditionalParams->h_CurrentNode);
+        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
+                                                        p_AdditionalParams->h_CurrentNode,
+                                                        p_FmPcdCcNextNode->h_Spinlock);
 
         if (p_CcNodeInformation)
             p_CcNodeInformation->index++;
@@ -356,7 +374,9 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
             ccNodeInfo.index = 1;
-            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo);
+            EnqueueNodeInfoToRelevantLst(p_UpdateLst,
+                                         &ccNodeInfo,
+                                         p_FmPcdCcNextNode->h_Spinlock);
         }
     }
 
@@ -400,7 +420,9 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         /* We remove from the subtree of the removed node tree because it wasn't done in the previous stage
            Update ccPrevNodesLst or ccTreeIdLst of the removed node
            Update of the node owner */
-        p_CcNodeInformation = FmPcdCcFindNodeInfoInReleventLst(p_UpdateLst, p_AdditionalParams->h_CurrentNode);
+        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
+                                                        p_AdditionalParams->h_CurrentNode,
+                                                        p_FmPcdCcNextNode->h_Spinlock);
 
         ASSERT_COND(p_CcNodeInformation);
         ASSERT_COND(p_CcNodeInformation->index);
@@ -408,7 +430,9 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         p_CcNodeInformation->index--;
 
         if (p_CcNodeInformation->index == 0)
-           FmPcdCcDequeueNodeInfoFromRelevantLst(p_UpdateLst,p_AdditionalParams->h_CurrentNode);
+           DequeueNodeInfoFromRelevantLst(p_UpdateLst,
+                                          p_AdditionalParams->h_CurrentNode,
+                                          p_FmPcdCcNextNode->h_Spinlock);
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
     }
@@ -625,15 +649,16 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
     t_FmPcdCcNextEngineParams   nextEngineParams;
     t_Handle                    h_Ad;
     uint32_t                    keySize;
-
-    t_Error     err = E_OK;
-    uint8_t     numOfModifiedPtr;
+    t_Error                     err = E_OK;
+    uint8_t                     numOfModifiedPtr;
 
     ASSERT_COND(h_FmPcd);
 
     SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_OldPointersLst) >= 1),E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_NewPointersLst) == 1),E_INVALID_STATE);
 
+    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
+
     numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
 
     p_PosNew = LIST_FIRST(h_NewPointersLst);
@@ -818,24 +843,6 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
     return E_OK;
 }
 
-static bool IsNodeInModifiedState(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-
-    ASSERT_COND(p_CcNode);
-
-    return p_CcNode->modifiedState;
-}
-
-static void UpdateNodeWithModifiedState(t_Handle h_CcNode, bool modifiedState)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-
-    ASSERT_COND(p_CcNode);
-
-    p_CcNode->modifiedState = modifiedState;
-}
-
 static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
 {
     switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
@@ -872,9 +879,6 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
 static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
 {
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
-    uint32_t        intFlags;
-
-    intFlags = XX_DisableAllIntr(); //TODO - replace by lock
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -882,8 +886,6 @@ static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List
         LIST_DelAndInit(&p_CcNodeInfo->node);
     }
 
-    XX_RestoreAllIntr(intFlags);
-
     return p_CcNodeInfo;
 }
 
@@ -922,31 +924,38 @@ void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
 
 static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 {
-    if(p_CcNode)
+    if (p_CcNode)
     {
-        if(p_CcNode->p_GlblMask)
+        if (p_CcNode->p_GlblMask)
         {
             XX_Free(p_CcNode->p_GlblMask);
             p_CcNode->p_GlblMask = NULL;
         }
 
-        if(p_CcNode->h_KeysMatchTable)
+        if (p_CcNode->h_KeysMatchTable)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
             p_CcNode->h_KeysMatchTable = NULL;
         }
 
-        if(p_CcNode->h_AdTable)
+        if (p_CcNode->h_AdTable)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
             p_CcNode->h_AdTable = NULL;
         }
 
-        if(p_CcNode->h_Ad)
+        if (p_CcNode->h_Ad)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
             p_CcNode->h_Ad = NULL;
         }
+
+        if (p_CcNode->h_Spinlock)
+        {
+            XX_FreeSpinlock(p_CcNode->h_Spinlock);
+            p_CcNode->h_Spinlock = NULL;
+        }
+
         ReleaseLst(&p_CcNode->ccPrevNodesLst);
         ReleaseLst(&p_CcNode->ccTreeIdLst);
         ReleaseLst(&p_CcNode->ccTreesLst);
@@ -2351,8 +2360,8 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
 
     /*check that new key is not require update of localMask*/
     UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
-                        p_Mask);
+                  p_CcNode->ccKeySizeAccExtraction,
+                  p_Mask);
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
@@ -2531,7 +2540,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     ASSERT_COND(p_Ad);
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
-    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     p_Ad = GetNewAd(h_FmPcdCcNodeOrTree, p_AdditionalInfo->tree);
@@ -2542,7 +2551,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (p_CcNextEngineParams)
         NextStepAd(p_Ad,p_CcNextEngineParams, h_FmPcd);
     ccNodeInfo.h_CcNode = p_Ad;
-    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
     p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
     p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
@@ -2656,7 +2665,7 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
 
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
-                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
                         *p_NextEngineParams = &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
@@ -2696,7 +2705,7 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
                     p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTableTmp;
-                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
                         *p_NextEngineParams = &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
@@ -2870,7 +2879,7 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
                p_NextEngineParams);
 
     ccNodeInfo.h_CcNode = h_NewAd;
-    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
     return E_OK;
 }
@@ -3193,9 +3202,6 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     if (keyIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
-    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
-
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
@@ -3244,12 +3250,14 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     uint8_t         tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
     uint16_t        i;
 
+    ASSERT_COND(p_Key);
     ASSERT_COND(p_KeyIndex);
+    ASSERT_COND(keySize < FM_PCD_MAX_SIZE_OF_KEY);
 
     if (keySize != p_CcNode->userSizeOfExtraction)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Key size doesn't match the extraction size of the node"));
 
-    /* If a user didn't passed a mask for this key, we'll look for full extraction mask */
+    /* If user didn't pass a mask for this key, we'll look for full extraction mask */
     if (!p_Mask)
         memset(tmpMask, 0xFF, keySize);
 
@@ -3269,7 +3277,7 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
             }
             else
             {
-                /* If a user didn't passed a mask for this key, checking if the existing key's mask is full extraction */
+                /* If user didn't pass a mask for this key, check if the existing key mask is full extraction */
                 if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
                 {
                     *p_KeyIndex = i;
@@ -3287,13 +3295,13 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info)
+t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation;
     t_List              *p_Pos;
     uint32_t            intFlags;
 
-    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
+    intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
     for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
@@ -3303,23 +3311,49 @@ t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h
 
         if(p_CcInformation->h_CcNode == h_Info)
         {
-            XX_RestoreAllIntr(intFlags);
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
             return p_CcInformation;
         }
     }
 
-    XX_RestoreAllIntr(intFlags);
+    XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 
     return NULL;
 }
 
-void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock)
+{
+    t_CcNodeInformation *p_CcInformation;
+    uint32_t            intFlags = 0;
+
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+
+    if (p_CcInformation)
+    {
+        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
+        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
+        INIT_LIST(&p_CcInformation->node);
+
+        if (h_Spinlock)
+            intFlags = XX_LockIntrSpinlock(h_Spinlock);
+
+        LIST_AddToTail(&p_CcInformation->node, p_List);
+
+        if (h_Spinlock)
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+    }
+    else
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
+}
+
+void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation = NULL;
-    uint32_t            intFlags;
+    uint32_t            intFlags = 0;
     t_List              *p_Pos;
 
-    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
+    if (h_Spinlock)
+        intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
     if (LIST_IsEmpty(p_List))
     {
@@ -3338,7 +3372,8 @@ void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
     if (p_CcInformation)
         LIST_DelAndInit(&p_CcInformation->node);
 
-    XX_RestoreAllIntr(intFlags);
+    if (h_Spinlock)
+        XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 }
 
 t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
@@ -3497,27 +3532,6 @@ uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
     return p_CcNode->numOfKeys;
 }
 
-void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
-{
-    t_CcNodeInformation *p_CcInformation;
-    uint32_t            intFlags;
-
-    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
-
-    if (p_CcInformation)
-    {
-        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
-        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
-        INIT_LIST(&p_CcInformation->node);
-
-        intFlags = XX_DisableAllIntr();  //TODO - replace by lock
-        LIST_AddToTail(&p_CcInformation->node, p_List);
-        XX_RestoreAllIntr(intFlags);
-    }
-    else
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
-}
-
 t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
                                          t_Handle                   h_FmPcdCcTree,
                                          uint8_t                    grpId,
@@ -3661,9 +3675,6 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     if (keyIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
-    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
-
     if (keySize != p_CcNode->userSizeOfExtraction)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
 
@@ -3807,6 +3818,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
     t_List                              h_OldPointersLst, h_NewPointersLst;
     bool                                useShadowStructs = FALSE;
+    uint16_t                            tmpKeyIndex;
     t_Error                             err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
@@ -3834,7 +3846,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                        keySize,
                        p_FmPcdCcKeyParams->p_Key,
                        p_FmPcdCcKeyParams->p_Mask,
-                       &keyIndex);
+                       &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
@@ -4097,7 +4109,7 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
 
         memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
         nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
-        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
+        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo, NULL);
     }
 
     return err;
@@ -4192,7 +4204,7 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
             p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = p_AdTable;
-            EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo);
+            EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo, NULL);
             (*p_NumOfAdTables)++;
         }
     }
@@ -4403,39 +4415,28 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
+                                                        (t_Handle)p_FmPcdCcTree,
+                                                        p_FmPcdCcNextNode->h_Spinlock);
 
-            if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            if(!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcTree;
                 ccNodeInfo.index = 1;
-                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccTreeIdLst, &ccNodeInfo);
-                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, TRUE);
+                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccTreeIdLst,
+                                             &ccNodeInfo,
+                                             p_FmPcdCcNextNode->h_Spinlock);
             }
             else
-            {
-                p_CcInformation = FmPcdCcFindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,(t_Handle)p_FmPcdCcTree);
-                ASSERT_COND(p_CcInformation);
                 p_CcInformation->index++;
-            }
         }
     }
 
     FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    for(i = 0; i < p_FmPcdCcTree->numOfEntries ; i++)
-    {
-        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-
-            if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
-                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
-        }
-    }
-
-    if (!FmPcdLockTryLockAll(p_FmPcd))
+     if (!FmPcdLockTryLockAll(p_FmPcd))
     {
         DeleteTree(p_FmPcdCcTree, p_FmPcd);
         XX_Free(p_Params);
@@ -4611,6 +4612,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     INIT_LIST(&p_CcNode->ccTreeIdLst);
     INIT_LIST(&p_CcNode->ccTreesLst);
 
+    p_CcNode->h_Spinlock = XX_InitSpinlock();
+    if (!p_CcNode->h_Spinlock)
+    {
+        DeleteNode(p_CcNode);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC node spinlock"));
+        return NULL;
+    }
+
     if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
         ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
         (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
@@ -4651,14 +4660,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
         else
         {
-            err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
+            err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
             if (p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
     }
     else
     {
-        err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
+        err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
         if (p_CcNode->glblMaskSize)
             glblMask = TRUE;
     }
@@ -4911,14 +4920,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
                 Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
-                            p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                                     p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
                             p_KeyParams->p_Mask,
                             p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
             }
             else if (p_CcNode->lclMask)
             {
                 IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
-                           p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                                    p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
                            0xff,
                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
             }
@@ -4932,6 +4941,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
     }
 
+    /* Update next engine for the 'miss' entry */
     NextStepAd(p_AdTableTmp, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
@@ -4939,37 +4949,25 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
-    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, FM_PCD_MAX_NUM_OF_KEYS); tmp++)
     {
         if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
-
-            if (!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
+                                                        (t_Handle)p_CcNode,
+                                                        p_FmPcdCcNextNode->h_Spinlock);
+            if (!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
                 ccNodeInfo.index = 1;
-                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst, &ccNodeInfo);
-                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, TRUE);
+                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
+                                             &ccNodeInfo,
+                                             p_FmPcdCcNextNode->h_Spinlock);
             }
             else
-            {
-                p_CcInformation = FmPcdCcFindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,(t_Handle)p_CcNode);
-                ASSERT_COND(p_CcInformation);
                 p_CcInformation->index++;
-            }
-        }
-    }
-
-    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
-    {
-        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
-
-            if (IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
-                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
         }
     }
 
@@ -4983,7 +4981,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
 
     /* Required action for each next engine */
-    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, FM_PCD_MAX_NUM_OF_KEYS); tmp++)
     {
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
@@ -4997,7 +4995,6 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
         if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
-
             err = FmPcdCcSetRequiredAction(h_FmPcd,
                                            p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
                                            &p_CcNode->keyAndNextEngineParams[tmp],
@@ -5015,24 +5012,6 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
 
-    /* Current node required action on 'miss' */
-    if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
-    {
-         err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                        p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
-                                        &p_CcNode->keyAndNextEngineParams[tmp],
-                                        p_AdTableTmp,
-                                        1,
-                                        NULL);
-         if (err)
-         {
-            FmPcdLockUnlockAll(h_FmPcd);
-            FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
-            REPORT_ERROR(MAJOR, err, NO_MSG);
-            return NULL;
-        }
-    }
-
     FmPcdLockUnlockAll(h_FmPcd);
     return p_CcNode;
 }
@@ -5048,7 +5027,7 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     if (p_CcNode->owners)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This node cannot be removed because it is occupied; first unbind this node"));
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -5682,7 +5661,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     t_FmPcdCcNodeParams     *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
     t_Handle                h_CcNode;
     t_FmPcdCcKeyParams      *p_HashKeyParams;
-    uint32_t                i;
+    int                     i;
     uint16_t                numOfSets, numOfWays, countMask, onesCount = 0;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index b88df15..5ae7bef 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -290,10 +290,11 @@ typedef struct
 
     t_Handle    h_FmPcd;
     uint32_t    shadowAction;
-    bool        modifiedState;
     uint8_t     userSizeOfExtraction;
     uint8_t     userOffset;
 
+    t_Handle    h_Spinlock;
+
     t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
 } t_FmPcdCcNode;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 57f8b17..05cc279 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -2939,7 +2939,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
 
         if (!KgSchemeFlagTryLock(p_Scheme))
         {
-		DBG(TRACE, ("Scheme Try Lock - BUSY"));
+            DBG(TRACE, ("Scheme Try Lock - BUSY"));
             /* Signal to caller BUSY condition */
             p_SchemeParams->id.h_Scheme = NULL;
             return NULL;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 37ffa8d..481c929 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -501,6 +501,8 @@ t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
     int                     i;
 
     ASSERT_COND(p_FmPcd);
+    ASSERT_COND(p_Params->netEnvId < FM_MAX_NUM_OF_PORTS);
+
     p_Params->vector = 0;
     for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
     {
@@ -684,6 +686,7 @@ e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeader
     int         i;
 
     ASSERT_COND(p_FmPcd);
+    ASSERT_COND(netEnvId < FM_MAX_NUM_OF_PORTS);
 
     for (i=0; (i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS)
         && (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE); i++)
@@ -815,8 +818,11 @@ bool FmPcdLockTryLockAll(t_Handle h_FmPcd)
     }
     FmPcdUnlock(h_FmPcd, intFlags);
 
+    CORE_MemoryBarrier();
+
     if (p_SavedPos)
         return FALSE;
+
     return TRUE;
 }
 
@@ -833,6 +839,8 @@ void FmPcdLockUnlockAll(t_Handle h_FmPcd)
         p_Lock->flag = FALSE;
     }
     FmPcdUnlock(h_FmPcd, intFlags);
+
+    CORE_MemoryBarrier();
 }
 
 t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
@@ -865,7 +873,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
     if (!p_FmPcd)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD"));
         return NULL;
     }
     memset(p_FmPcd, 0, sizeof(t_FmPcd));
@@ -874,7 +882,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     if (!p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Driver Param"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Driver Param"));
         return NULL;
     }
     memset(p_FmPcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
@@ -899,7 +907,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         p_FmPcd->h_Hc = FmHcConfigAndInit(&hcParams);
         if (!p_FmPcd->h_Hc)
         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd HC"));
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD HC"));
             FM_PCD_Free(p_FmPcd);
             return NULL;
         }
@@ -912,7 +920,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
         if(!p_FmPcd->p_FmPcdKg)
         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Keygen"));
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Keygen"));
             FM_PCD_Free(p_FmPcd);
             return NULL;
         }
@@ -923,7 +931,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
         if(!p_FmPcd->p_FmPcdPlcr)
         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Policer"));
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer"));
             FM_PCD_Free(p_FmPcd);
             return NULL;
         }
@@ -934,7 +942,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
         if(!p_FmPcd->p_FmPcdPrs)
         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Parser"));
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Parser"));
             FM_PCD_Free(p_FmPcd);
             return NULL;
         }
@@ -943,7 +951,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd->h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->h_Spinlock)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd spinlock"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD spinlock"));
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
@@ -963,7 +971,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd->h_ShadowSpinlock = XX_InitSpinlock();
     if (!p_FmPcd->h_ShadowSpinlock)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd shadow spinlock"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD shadow spinlock"));
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
@@ -1599,15 +1607,15 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
             if(!p_FmPcd->p_FmPcdKg)
             {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("KeyGen is not activated"));
                 return 0;
             }
             if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
                 !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
                 !p_FmPcd->h_IpcSession)
             {
-                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
                 return 0;
             }
             break;
@@ -1620,22 +1628,27 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
             if (!p_FmPcd->p_FmPcdPlcr)
             {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Policer is not activated"));
                 return 0;
             }
-            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-                !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
-                !p_FmPcd->h_IpcSession)
+            if (p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
             {
-                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
-                return 0;
+                /* check that counters are enabled */
+                if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+                {
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                    return 0;
+                }
             }
-            /* check that counters are enabled */
-            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            else
             {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-                return 0;
+                ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
+                if (!p_FmPcd->h_IpcSession)
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
+                    return 0;
+                }
             }
             break;
 
@@ -1658,24 +1671,24 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
             if(!p_FmPcd->p_FmPcdPrs)
             {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Parser is not activated"));
                 return 0;
             }
             if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
                 !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
                 !p_FmPcd->h_IpcSession)
             {
-                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
                 return 0;
             }
             break;
         default:
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
             return 0;
     }
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) && p_FmPcd->h_IpcSession)
     {
         t_FmPcdIpcMsg           msg;
         t_FmPcdIpcReply         reply;
@@ -1703,6 +1716,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 
     switch(counter)
     {
+        /* Parser statistics */
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
         case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
@@ -1740,7 +1754,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
                return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
 
-        /*Policer statictics*/
+        /* Policer statistics */
         case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
         case(e_FM_PCD_PLCR_COUNTERS_RED):
@@ -2024,7 +2038,7 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     {
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
             if(!p_FmPcd->p_FmPcdKg)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - keygen is not working"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - KeyGen is not working"));
             break;
         case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
         case(e_FM_PCD_PLCR_COUNTERS_RED):
@@ -2033,7 +2047,7 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
         case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
         case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
             if(!p_FmPcd->p_FmPcdPlcr)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - Policer is not working"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - Policer is not working"));
             if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 918e0a1..57e6ba9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -424,7 +424,6 @@ typedef struct {
 
     uint64_t                    physicalMuramBase;
 
-    volatile bool               lock;
     t_Handle                    h_Spinlock;
     t_List                      freeLocksLst;
     t_List                      acquiredLocksLst;
@@ -539,9 +538,10 @@ void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
                                                      uint32_t   *p_NumOfAdTables);
 #endif /* (DPAA_VERSION >= 11) */
 
-void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo);
-t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info);
-void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info);
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock);
+void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock);
+t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock);
+
 
 void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd);
 void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 470d86d..fc8546a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -755,7 +755,7 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
         uint32_t                    replyLength;
         t_FmPcdIpcReply             reply;
 
-        /* Alloc resources using IPC messaging */
+        /* Allocate resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
         ipcPlcrParams.num = numOfProfiles;
@@ -809,7 +809,7 @@ t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
         uint32_t                    replyLength;
         t_FmPcdIpcReply             reply;
 
-        /* Alloc resources using IPC messaging */
+        /* Allocate resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
         ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
@@ -846,15 +846,17 @@ t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
     return E_OK;
 }
 
-bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+bool FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
 
+    ASSERT_COND(absoluteProfileId < FM_PCD_PLCR_NUM_ENTRIES);
+
     return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
 }
 
-t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+t_Error PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
 {
     t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     uint32_t        profilesFound, log2Num, tmpReg32;
@@ -1521,7 +1523,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
         /* Try lock profile using flag */
          if (!PlcrProfileFlagTryLock(p_Profile))
          {
-		 DBG(TRACE, ("Profile Try Lock - BUSY"));
+             DBG(TRACE, ("Profile Try Lock - BUSY"));
              /* Signal to caller BUSY condition */
              p_ProfileParams->id.h_Profile = NULL;
              return NULL;
@@ -1779,7 +1781,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
              WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
              break;
         default:
-		PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+            PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
 
@@ -1838,7 +1840,7 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
     p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
 
     tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
-	intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     WritePar(p_FmPcd, tmpReg);
 
     DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
@@ -1859,7 +1861,7 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
     DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
     DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
     DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-	PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 9b8f8e9..2263bf8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -394,7 +394,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     {
         p_TmpCode = (uint8_t *)XX_Malloc(p_SwPrs->size + 2);
         if (!p_TmpCode)
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
         memset(p_TmpCode, 0, p_SwPrs->size + 2);
         memcpy(p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
     }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 62cef06..f8d49eb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -296,7 +296,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-static void VerifySizeOfFifo(t_FmPort *p_FmPort)
+static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 {
     uint32_t                minFifoSizeRequired = 0;
 
@@ -375,7 +375,7 @@ static void VerifySizeOfFifo(t_FmPort *p_FmPort)
 
     /* for all ports - verify size  */
     if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
-        DBG(WARNING, ("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
 
     /* check if pool size is not too big */
     /* This is a definition problem in which if the fifo for the RX port
@@ -386,10 +386,12 @@ static void VerifySizeOfFifo(t_FmPort *p_FmPort)
         && !p_FmPort->imEn)
     {
         if (p_FmPort->rxPoolsParams.largestBufSize > p_FmPort->fifoBufs.num)
-            DBG(WARNING, ("Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)",
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)",
                     p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
 
     }
+
+    return E_OK;
 }
 
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
@@ -614,10 +616,6 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         /* Call the external Buffer routine which also checks fifo
            size and updates it if necessary */
         /* define external buffer pools and pool depletion*/
-        err = SetExtBufferPools(p_FmPort);
-        if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-
         /* check if the largest external buffer pool is large enough */
         if ((p_Params->bufMargins.startMargins +
              MIN_EXT_BUF_SIZE +
@@ -2509,6 +2507,19 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
     p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
 
+    if  ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        if (!p_FmPort->imEn)
+        {
+            /* Call the external Buffer routine which also checks fifo
+             size and updates it if necessary */
+            /* define external buffer pools and pool depletion*/
+            err = SetExtBufferPools(p_FmPort);
+            if (err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -2519,8 +2530,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    if(p_FmPort->explicitUserSizeOfFifo)
-        VerifySizeOfFifo(p_FmPort);
+    err = VerifySizeOfFifo(p_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
     fmParams.independentMode    = p_FmPort->imEn;
@@ -4564,11 +4576,11 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                                 err = E_OK;
-    t_FmPortPcdParams                       modifiedPcdParams;
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error             err = E_OK;
+    t_FmPortPcdParams   modifiedPcdParams, *p_PcdParams;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4585,7 +4597,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
-    memcpy(&modifiedPcdParams, p_PcdParams, sizeof(t_FmPortPcdParams));
+    memcpy(&modifiedPcdParams, p_PcdParam, sizeof(t_FmPortPcdParams));
     p_PcdParams = &modifiedPcdParams;
     if (p_PcdParams->h_IpReassemblyManip)
     {
@@ -4598,14 +4610,19 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pcdSupport must have KG for supporting IPR"));
         }
         p_FmPort->h_IpReassemblyManip = p_PcdParams->h_IpReassemblyManip;
-        if (((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
-             (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)) &&
-             !p_PcdParams->p_CcParams)
+        if (!p_PcdParams->p_CcParams)
         {
             /* No user-tree, need to build internal tree */
             t_FmPcdCcTreeParams         *p_FmPcdCcTreeParams;
             t_FmPortPcdCcParams         fmPortPcdCcParams;
 
+            if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
+                  (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
+            {
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+            }
+
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
             if(!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
@@ -4630,16 +4647,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
             XX_Free(p_FmPcdCcTreeParams);
         }
-        if (!p_PcdParams->p_CcParams)
-        {
-            if (p_FmPort->h_IpReassemblyTree)
-            {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
-        }
+
         err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
                                 p_PcdParams->p_CcParams->h_CcTree,
                                 p_PcdParams->h_NetEnv,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 042e9b9..18d2274 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -624,6 +624,9 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
         t_Error                              err;
         t_FmIpcMsg                           msg;
         t_FmIpcSetCongestionGroupPfcPriority FmIpcSetCongestionGroupPfcPriority;
+
+        ASSERT_COND(p_Fm->guestId < FM_MAX_NUM_OF_GUESTS);
+
         memset(&msg, 0, sizeof(msg));
         memset(&FmIpcSetCongestionGroupPfcPriority, 0, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
         FmIpcSetCongestionGroupPfcPriority.congestionGroupId = congestionGroupId;
@@ -692,7 +695,7 @@ t_Error FmVSPSetWindow(t_Handle  h_Fm,
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
     else
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("guest without either regs or IPC!"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Guest without either registers address or IPC!"));
     return err;
 }
 
@@ -1605,7 +1608,7 @@ void FmRegisterIntr(t_Handle h_Fm,
     ASSERT_COND(h_Fm);
 
     GET_FM_MODULE_EVENT(module, modId,intrType, event);
-    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
 
     /* register in local FM structure */
     p_Fm->intrMng[event].f_Isr = f_Isr;
@@ -1648,7 +1651,7 @@ void FmUnregisterIntr(t_Handle h_Fm,
     ASSERT_COND(h_Fm);
 
     GET_FM_MODULE_EVENT(module, modId,intrType, event);
-    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
 
     p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
     p_Fm->intrMng[event].h_SrcHandle = NULL;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 0c279ae..25eaf92 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -336,10 +336,9 @@ typedef struct t_FmBufferPrefixContent {
                                          get the parser-result from a buffer. */
     bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
                                          AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment
-									 [DEFAULT_PORT_bufferPrefixContent_dataAlign], other value
-                                         for selecting a data alignment (must be a
-                                         power of 2); if write optimization is used, must be >= 16. */
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment [64],
+                                         other value for selecting a data alignment (must be a power of 2);
+                                         if write optimization is used, must be >= 16. */
     uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
                                          Note that this field impacts the size of the buffer-prefix
                                          (i.e. it pushes the data offset);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 39055c0..85e2824a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1135,104 +1135,104 @@ typedef union u_FmPcdHdrProtocolOpt {
  @Description   A union holding protocol fields
 
 
-				Fields supported as "full fields":
+                Fields supported as "full fields":
                     HEADER_TYPE_ETH:
-						NET_HEADER_FIELD_ETH_DA
-						NET_HEADER_FIELD_ETH_SA
-						NET_HEADER_FIELD_ETH_TYPE
+                        NET_HEADER_FIELD_ETH_DA
+                        NET_HEADER_FIELD_ETH_SA
+                        NET_HEADER_FIELD_ETH_TYPE
 
                     HEADER_TYPE_LLC_SNAP:
-					    NET_HEADER_FIELD_LLC_SNAP_TYPE
+                        NET_HEADER_FIELD_LLC_SNAP_TYPE
 
                     HEADER_TYPE_VLAN:
-						NET_HEADER_FIELD_VLAN_TCI
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_LAST)
-
-					HEADER_TYPE_MPLS:
-					    NET_HEADER_FIELD_MPLS_LABEL_STACK
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_2,
-								 e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_VLAN_TCI
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_MPLS:
+                        NET_HEADER_FIELD_MPLS_LABEL_STACK
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2,
+                                 e_FM_PCD_HDR_INDEX_LAST)
 
                     HEADER_TYPE_IPv4:
                         NET_HEADER_FIELD_IPv4_SRC_IP
                         NET_HEADER_FIELD_IPv4_DST_IP
                         NET_HEADER_FIELD_IPv4_PROTO
-						NET_HEADER_FIELD_IPv4_TOS
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_IPv4_TOS
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
                     HEADER_TYPE_IPv6:
                         NET_HEADER_FIELD_IPv6_SRC_IP
                         NET_HEADER_FIELD_IPv6_DST_IP
                         NET_HEADER_FIELD_IPv6_NEXT_HDR
-						NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
-					HEADER_TYPE_GRE:
+                    HEADER_TYPE_GRE:
                         NET_HEADER_FIELD_GRE_TYPE
 
                     HEADER_TYPE_MINENCAP
-						NET_HEADER_FIELD_MINENCAP_SRC_IP
-						NET_HEADER_FIELD_MINENCAP_DST_IP
-						NET_HEADER_FIELD_MINENCAP_TYPE
+                        NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        NET_HEADER_FIELD_MINENCAP_DST_IP
+                        NET_HEADER_FIELD_MINENCAP_TYPE
 
-					HEADER_TYPE_TCP:
+                    HEADER_TYPE_TCP:
                         NET_HEADER_FIELD_TCP_PORT_SRC
                         NET_HEADER_FIELD_TCP_PORT_DST
-						NET_HEADER_FIELD_TCP_FLAGS
+                        NET_HEADER_FIELD_TCP_FLAGS
 
-					HEADER_TYPE_UDP:
+                    HEADER_TYPE_UDP:
                         NET_HEADER_FIELD_UDP_PORT_SRC
                         NET_HEADER_FIELD_UDP_PORT_DST
 
-					HEADER_TYPE_IPSEC_AH:
+                    HEADER_TYPE_IPSEC_AH:
                         NET_HEADER_FIELD_IPSEC_AH_SPI
                         NET_HEADER_FIELD_IPSEC_AH_NH
 
-					HEADER_TYPE_IPSEC_ESP:
-					    NET_HEADER_FIELD_IPSEC_ESP_SPI
+                    HEADER_TYPE_IPSEC_ESP:
+                        NET_HEADER_FIELD_IPSEC_ESP_SPI
 
-					HEADER_TYPE_SCTP:
-					    NET_HEADER_FIELD_SCTP_PORT_SRC
-						NET_HEADER_FIELD_SCTP_PORT_DST
+                    HEADER_TYPE_SCTP:
+                        NET_HEADER_FIELD_SCTP_PORT_SRC
+                        NET_HEADER_FIELD_SCTP_PORT_DST
 
-					HEADER_TYPE_DCCP:
-					    NET_HEADER_FIELD_DCCP_PORT_SRC
-						NET_HEADER_FIELD_DCCP_PORT_DST
+                    HEADER_TYPE_DCCP:
+                        NET_HEADER_FIELD_DCCP_PORT_SRC
+                        NET_HEADER_FIELD_DCCP_PORT_DST
 
-					HEADER_TYPE_PPPoE:
+                    HEADER_TYPE_PPPoE:
                         NET_HEADER_FIELD_PPPoE_PID
-					    NET_HEADER_FIELD_PPPoE_SID
+                        NET_HEADER_FIELD_PPPoE_SID
 
-		*****************************************************************
-				Fields supported as "from fields":
+        *****************************************************************
+                Fields supported as "from fields":
                     HEADER_TYPE_ETH (with or without validation):
-						NET_HEADER_FIELD_ETH_TYPE
+                        NET_HEADER_FIELD_ETH_TYPE
 
                     HEADER_TYPE_VLAN (with or without validation):
-						NET_HEADER_FIELD_VLAN_TCI
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_VLAN_TCI
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_LAST)
 
                     HEADER_TYPE_IPv4 (without validation):
                         NET_HEADER_FIELD_IPv4_PROTO
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
                     HEADER_TYPE_IPv6 (without validation):
                         NET_HEADER_FIELD_IPv6_NEXT_HDR
-						        (index may apply:
-								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
 *//***************************************************************************/
 typedef union t_FmPcdFields {
@@ -1664,8 +1664,10 @@ typedef struct t_FmPcdCcNextEngineParams {
  @Description   Parameters for defining a single CC key
 *//***************************************************************************/
 typedef struct t_FmPcdCcKeyParams {
-    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize */
-    uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
+    uint8_t                     *p_Key;     /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
+                                                 pointer to the key of the size defined in keySize */
+    uint8_t                     *p_Mask;    /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
+                                                 pointer to the Mask per key  of the size defined
                                                  in keySize. p_Key and p_Mask (if defined) has to be
                                                  of the same size defined in the keySize */
     t_FmPcdCcNextEngineParams   ccNextEngineParams;
@@ -1715,7 +1717,10 @@ typedef struct t_KeysParams {
                                                      e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
                                                 /**< An array with 'numOfKeys' entries, each entry specifies the
-                                                     corresponding key parameters. */
+                                                     corresponding key parameters;
+                                                     When 'action' = e_FM_PCD_ACTION_EXACT_MATCH, this value must not
+                                                     exceed 255 (FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+                                                     for the 'miss' entry. */
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
                                                 /**< Parameters for defining the next engine when a key is not matched;
                                                      Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 64dc103..7b3a393 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -471,10 +471,11 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
 /**************************************************************************//**
  @Function      FM_PORT_ConfigSizeOfFifo
 
- @Description   Calling this routine changes the max FIFO size
-                available for this port. It changes this parameter in the
-                internal driver data base from its default configuration
-                [DEFAULT_PORT_sizeOfFifo]
+ @Description   Calling this routine changes the max FIFO size configured for this port.
+
+                This function changes the internal driver data base from its
+                default configuration. Please refer to the driver's User Guide for
+                information on default FIFO sizes in the various devices.
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_SizeOfFifo    A pointer to a structure of parameters defining
@@ -836,8 +837,8 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
                 1. For head optimization, data alignment must be >= 16 (supported by default).
 
                 3. For tail optimization, note that the optimization is performed by extending the write transaction
-				of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
-				is extended to be on 16/64 bytes aligned block (chip dependent).
+                of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
+                is extended to be on 16/64 bytes aligned block (chip dependent).
 
 
                 Relevant for non-Tx port types
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index 79d2e78..6e8bc1e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -76,7 +76,7 @@ typedef enum e_EnetInterface
     e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
     e_ENET_IF_XGMII = 0x00090000,   /**< XGMII interface */
     e_ENET_IF_QSGMII= 0x000a0000,   /**< QSGMII interface */
-    e_ENET_IF_XFI	= 0x000b0000    /**< XFI interface */
+    e_ENET_IF_XFI   = 0x000b0000    /**< XFI interface */
 } e_EnetInterface;
 
 /**************************************************************************//**
@@ -122,7 +122,7 @@ typedef enum e_EnetMode
     e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
     e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
     e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),    /**<  1000 Mbps QSGMII */
-    e_ENET_MODE_XFI_10000 	= (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
+    e_ENET_MODE_XFI_10000   = (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
 } e_EnetMode;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
index cab73f8..f8b6589 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          xx_ext.h
 
@@ -474,11 +475,12 @@ void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
 
  @Param[in]     msecs - The requested sleep time (in milliseconds).
 
- @Return        None.
+ @Return        Zero if the requested time has elapsed; Otherwise, the value
+                returned will be the unslept amount) in milliseconds.
 
  @Cautions      This routine enables interrupts during its wait time.
 *//***************************************************************************/
-void XX_Sleep(uint32_t msecs);
+uint32_t XX_Sleep(uint32_t msecs);
 
 /**************************************************************************//**
  @Function      XX_UDelay
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
index e439bc6..ea914fd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
@@ -675,15 +675,13 @@ int XX_TimerIsActive(t_Handle h_Timer)
   return timer_pending((struct timer_list *)h_Timer);
 }
 
-void XX_Sleep(uint32_t msecs)
+uint32_t XX_Sleep(uint32_t msecs)
 {
     int tmp_jiffies = (msecs*HZ)/1000;
 
     if ((msecs*HZ)%1000)
         tmp_jiffies++;
-    schedule_timeout(tmp_jiffies);
-
-    return;
+    return schedule_timeout(tmp_jiffies);
 }
 
 /*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
-- 
1.7.9.7

