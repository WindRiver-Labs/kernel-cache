From 7fc13329a3fd5c3d3cdd93a94aebcb86dd610c64 Mon Sep 17 00:00:00 2001
From: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Date: Tue, 28 Aug 2012 15:34:12 +0000
Subject: [PATCH 157/162] P1021RDB: Add QE TDM support

The P1021RDB-PC have PMC sockets that support QE-TDM function.
The patch enable Quicc Engine and the related signals of QE-TDM.

Signed-off-by: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Signed-off-by: Xie Xiaobo <X.Xie@freescale.com>
Signed-off-by: Li Yang <leoli@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball. Move the entry of
qe type to mpc85xx_common_ids id tables, and also fix a build error
when CONFIG_QUICC_ENGINE is not enabled.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/platforms/85xx/common.c      |    1 +
 arch/powerpc/platforms/85xx/mpc85xx_rdb.c |   82 ++++++++++++++++++++---------
 2 files changed, 59 insertions(+), 24 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/common.c b/arch/powerpc/platforms/85xx/common.c
index 67dac22..6ae5e80 100644
--- a/arch/powerpc/platforms/85xx/common.c
+++ b/arch/powerpc/platforms/85xx/common.c
@@ -18,6 +18,7 @@ static struct of_device_id __initdata mpc85xx_common_ids[] = {
 	{ .name = "cpm", },
 	{ .name = "localbus", },
 	{ .compatible = "gianfar", },
+	{ .type = "qe", },
 	{ .compatible = "fsl,qe", },
 	{ .compatible = "fsl,cpm2", },
 	{ .compatible = "fsl,srio", },
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
index 3d520f7..27ddf80 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
@@ -90,6 +90,13 @@ static void __init mpc85xx_rdb_setup_arch(void)
 	struct device_node *np;
 #endif
 
+#if defined(CONFIG_QUICC_ENGINE) && defined(CONFIG_SPI_FSL_SPI)
+	struct device_node *qe_spi;
+#endif
+#ifdef CONFIG_QUICC_ENGINE
+	struct ccsr_guts __iomem *guts;
+#endif
+
 	if (ppc_md.progress)
 		ppc_md.progress("mpc85xx_rdb_setup_arch()", 0);
 
@@ -119,39 +126,66 @@ static void __init mpc85xx_rdb_setup_arch(void)
 
 		for_each_node_by_name(ucc, "ucc")
 			par_io_of_config(ucc);
-
+#ifdef CONFIG_SPI_FSL_SPI
+		for_each_node_by_name(qe_spi, "spi")
+			par_io_of_config(qe_spi);
+#endif	/* CONFIG_SPI_FSL_SPI */
 	}
-#if defined(CONFIG_UCC_GETH) || defined(CONFIG_SERIAL_QE)
-	if (machine_is(p1025_rdb)) {
-
-		struct ccsr_guts __iomem *guts;
-
-		np = of_find_node_by_name(NULL, "global-utilities");
-		if (np) {
-			guts = of_iomap(np, 0);
-			if (!guts) {
 
-				pr_err("mpc85xx-rdb: could not map global utilities register\n");
-
-			} else {
-			/* P1025 has pins muxed for QE and other functions. To
-			* enable QE UEC mode, we need to set bit QE0 for UCC1
-			* in Eth mode, QE0 and QE3 for UCC5 in Eth mode, QE9
-			* and QE12 for QE MII management singals in PMUXCR
-			* register.
-			*/
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-rdb: could not map global "
+					"utilities register\n");
+		else {
+#if defined(CONFIG_UCC_GETH) || defined(CONFIG_SERIAL_QE)
+			if (machine_is(p1025_rdb)) {
+				/*
+				 * P1025 has pins muxed for QE and other
+				 * functions. To enable QE UEC mode, we
+				 * need to set bit QE0 for UCC1 in Eth mode,
+				 * QE0 and QE3 for UCC5 in Eth mode, QE9
+				 * and QE12 for QE MII management singals
+				 * in PMUXCR register.
+				 */
 				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
 						MPC85xx_PMUXCR_QE(3) |
 						MPC85xx_PMUXCR_QE(9) |
 						MPC85xx_PMUXCR_QE(12));
-				iounmap(guts);
 			}
-			of_node_put(np);
-		}
-
-	}
 #endif
 
+#ifdef CONFIG_FSL_UCC_TDM
+			if (machine_is(p1021_rdb_pc)) {
+
+				/* Clear QE12 for releasing the LBCTL */
+				clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+				/* TDMA */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(5) |
+						  MPC85xx_PMUXCR_QE(11));
+				/* TDMB */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
+						  MPC85xx_PMUXCR_QE(9));
+				/* TDMC */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0));
+				/* TDMD */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(8) |
+						  MPC85xx_PMUXCR_QE(7));
+			}
+#endif	/* CONFIG_FSL_UCC_TDM */
+
+#ifdef CONFIG_SPI_FSL_SPI
+			clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+			/*QE-SPI*/
+			setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(6) |
+					  MPC85xx_PMUXCR_QE(9) |
+					  MPC85xx_PMUXCR_QE(10));
+#endif	/* CONFIG_SPI_FSL_SPI */
+			iounmap(guts);
+		}
+		of_node_put(np);
+	}
 qe_fail:
 #endif	/* CONFIG_QUICC_ENGINE */
 
-- 
1.7.9.7

