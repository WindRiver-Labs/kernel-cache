From b512283241d4a9d69e243f40fae7e75680f814ca Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Fri, 29 Jun 2012 13:05:59 +0300
Subject: [PATCH 025/162] qman: Fix race condition in congestion state change
 handler

QMan's ISR handler must clear the CSCI bit *before* interrogating the
hardware for the current congestion status. Otherwise, a
quickly-switching state might leave the CGR indefinitely congested.

An example to this scenario is when the CGSCN handler is relatively
slow, while the CGR's congestion threshold is low enough to set the
CSCI bit in a very quick sequence.

Clearing the CSCI bit inside __poll_portal_slow() to avoid the said
race.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Signed-off-by: Alex Marginean <alexandru.marginean@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 2bae8e4..929f601 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -275,7 +275,11 @@ static inline unsigned int __poll_portal_fast(struct qman_portal *p,
 static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 {
 	struct qman_portal *p = ptr;
-	u32 clear = QM_DQAVAIL_MASK | p->irq_sources;
+	/* The CSCI source is cleared inside __poll_portal_slow(), because
+	 * it could race against a Query Congestion State command also given
+	 * as part of the handling of this interrupt source. We mustn't
+	 * clear it a second time in this top-level function. */
+	u32 clear = QM_DQAVAIL_MASK | (p->irq_sources & ~QM_PIRQ_CSCI);
 	u32 is = qm_isr_status_read(&p->p) & p->irq_sources;
 	/* DQRR-handling if it's interrupt-driven */
 	if (is & QM_PIRQ_DQRI)
@@ -605,6 +609,12 @@ static u32 __poll_portal_slow(struct qman_portal *p, u32 is)
 		unsigned long irqflags __maybe_unused;
 
 		spin_lock_irqsave(&p->cgr_lock, irqflags);
+		/* The CSCI bit must be cleared _before_ issuing the
+		 * Query Congestion State command, to ensure that a long
+		 * CGR State Change callback cannot miss an intervening
+		 * state change. */
+		qm_isr_status_clear(&p->p, QM_PIRQ_CSCI);
+
 		qm_mc_start(&p->p);
 		qm_mc_commit(&p->p, QM_MCC_VERB_QUERYCONGESTION);
 		while (!(mcr = qm_mc_result(&p->p)))
@@ -712,7 +722,10 @@ mr_done:
 		qm_mr_cci_consume(&p->p, num);
 	}
 
-	return is & (QM_PIRQ_CSCI | QM_PIRQ_EQCI | QM_PIRQ_EQRI | QM_PIRQ_MRI);
+	/* QM_PIRQ_CSCI has already been cleared, as part of its specific
+	 * processing. If that interrupt source has meanwhile been re-asserted,
+	 * we mustn't clear it here (or in the top-level interrupt handler). */
+	return is & (QM_PIRQ_EQCI | QM_PIRQ_EQRI | QM_PIRQ_MRI);
 }
 
 /* remove some slowish-path stuff from the "fast path" and make sure it isn't
-- 
1.7.9.7

