From 00dd4cc2dc06443702682c47ef20aca89473520c Mon Sep 17 00:00:00 2001
From: Sorin Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Mon, 18 Jun 2012 21:02:53 +0000
Subject: [PATCH 059/162] fmd: resource allocation algorithm unit test.

Added unit test for dynamic resource allocation algorithm.
Added Makefile for building on host machine.
Added macro for building the code for host machine as
application.

Signed-off-by: Andrei Pistirica
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |   15 ++
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.h   |   10 +
 .../NetCommSw/src/wrapper/lnxwrp_resources_ut.c    |  191 ++++++++++++++++++++
 .../NetCommSw/src/wrapper/lnxwrp_resources_ut.h    |  144 +++++++++++++++
 .../NetCommSw/src/wrapper/lnxwrp_resources_ut.make |   28 +++
 5 files changed, 388 insertions(+)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.make

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index 853ea3c..be0940d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -36,6 +36,7 @@
  @Description   FMD wrapper resource allocation functions.
 
 */
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 
 #include <linux/version.h>
 #if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
@@ -49,8 +50,11 @@
 #include <linux/of_platform.h>
 #include <linux/skbuff.h>
 
+#endif /*#if !defined(FMAN_RESOURCES_UNIT_TEST)*/
+
 #include "lnxwrp_resources.h"
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 static struct device_node *match_mac_to_dpaa_port(struct device_node
 						  *enet_mac_node)
 {
@@ -231,6 +235,7 @@ int fm_set_active_fman_ports(struct platform_device *of_dev,
 
 	return 0;
 }
+#endif /*!defined(FMAN_RESOURCES_UNIT_TEST)*/
 
 #ifdef FM_FIFO_ALLOCATION_OLD_ALG
 /* BPOOL size is constant and equal w/ DPA_BP_SIZE */
@@ -363,6 +368,7 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 
 	{
 #ifdef FM_FIFO_ALLOCATION_OLD_ALG
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 		uint8_t fm_rev_major = 0;
 		fm_rev_major =
 			(uint8_t) ((*
@@ -371,6 +377,9 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 						 0x000c30c4)) & 0xff00) >> 8);
 
 		if (fm_rev_major < 4)
+#else
+		if(1)
+#endif
 			min_rx_bufs =
 				get_largest_buf_size(max_frame_size,
 						     buf_size) + 7;
@@ -576,6 +585,7 @@ precalculated_fifosize_out:
 	return err;
 }
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
@@ -639,6 +649,7 @@ int fm_config_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	return 0;
 }
+#endif /*if !defined(FMAN_RESOURCES_UNIT_TEST)*/
 
 /* Compute FMan open DMA based on total number of open DMAs and
  * number of available FMan ports.
@@ -888,6 +899,7 @@ precalculated_open_dma_out:
 	return err;
 }
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
@@ -934,6 +946,7 @@ int fm_config_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	return 0;
 }
+#endif /*if !defined(FMAN_RESOURCES_UNIT_TEST)*/
 
 /* Compute FMan tnums based on available tnums and number of ports.
    Set defaults (minim tresholds) and then distribute leftovers.*/
@@ -1132,6 +1145,7 @@ precalculated_tnums_out:
 	return err;
 }
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
@@ -1177,3 +1191,4 @@ int fm_config_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	return 0;
 }
+#endif /*if !defined(FMAN_RESOURCES_UNIT_TEST)*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
index 47f3269..eb1517d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
@@ -40,7 +40,11 @@
 #ifndef LNXWRP_RESOURCES_H_
 #define LNXWRP_RESOURCES_H_
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 #include "lnxwrp_fm.h"
+#else
+#include "lnxwrp_resources_ut.h"
+#endif
 
 #define ROUND(X) ((2*(X)+1)/2)
 #define CEIL(X) ((X)+1)
@@ -80,7 +84,9 @@ int fm_set_active_fman_ports(struct platform_device *of_dev,
 int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev,
 			   int muram_fifo_size);
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+#endif
 
 /* Compute FMan open DMA based on total number of open DMAs and
  * number of available fman ports.
@@ -100,12 +106,16 @@ int fm_precalculate_open_dma(t_LnxWrpFmDev *p_LnxWrpFmDev,
 			  int default_rx_10g_dmas,
 			  int min_tx_10g_treshold, int min_rx_10g_treshold);
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+#endif
 
 /* Compute FMan tnums based on available tnums and number of ports.
  * Set defaults (minim tresholds) and then distribute leftovers.*/
 int fm_precalculate_tnums(t_LnxWrpFmDev *p_LnxWrpFmDev, int max_fm_tnums);
 
+#if !defined(FMAN_RESOURCES_UNIT_TEST)
 int fm_config_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+#endif
 
 #endif /* LNXWRP_RESOURCES_H_ */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.c
new file mode 100644
index 0000000..6c06a5a
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.c
@@ -0,0 +1,191 @@
+/* Copyright (c) 2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "lnxwrp_resources.h"
+#include "lnxwrp_resources_ut.h"
+
+#define KILOBYTE 0x400 /* 1024 */
+
+typedef enum e_board_type {
+	e_p3041,
+	e_p4080,
+	e_p5020,
+	e_p1023
+} e_board_type;
+
+uint8_t board_type;
+uint32_t muram_size = 0;
+uint32_t dmas_num = 0;
+uint32_t task_num = 0;
+uint32_t frame_size = 0;
+uint32_t oh_num = 0;
+uint32_t num_ports_1g = 0;
+uint32_t num_ports_10g = 0;
+uint32_t num_ports_2g5 = 0;
+uint32_t fsl_fman_phy_maxfrm = 0;
+uint32_t dpa_rx_extra_headroom = 0;
+
+void show_help(void){
+	printf(" help: \n");
+	printf(" -b <board_type> -f <max_fram_size(mtu)> -o <num_oh_ports> -g1"
+		" <num_1g_ports> -g10 <num_10g_ports> -g25 <num_2g5_ports>\n");
+	printf("    Maxim num of DMAS availbale:  P3/P4/P5:32 ,  P1023:16 \n");
+	printf("    Maxim num of TNUMs availbale: P3/P4/P5:128,  P1023:32 \n");
+	printf("    Muram size:                   P3/P4/P5:160K, P1023:64K \n");
+	printf("    Number of ports:\n");
+	printf("        P3/P5: 5p 1g, 1p 10g, 7p oh \n");
+	printf("        P4   : 4p 1g, 1p 10g, 7p oh \n");
+	printf("        P1   : 2p 1g, 0p 10g, 4p oh \n");
+	printf("    MTU: Default:1522, Jumbo:9600 \n");
+}
+
+int fm_set_param(t_LnxWrpFmDev *p_LnxWrpFmDev) {
+	struct fm_active_ports *fm_active_ports_info = NULL;
+	fm_active_ports_info = &p_LnxWrpFmDev->fm_active_ports_info;
+
+	switch(board_type){
+		case e_p3041:
+		case e_p5020:
+			muram_size = 160*KILOBYTE;
+			dmas_num = 32;
+			task_num = 128;
+			if ((num_ports_1g+num_ports_2g5) > 5 || num_ports_10g > 1 || oh_num > 7)
+				goto err_fm_set_param;
+		break;
+		case e_p4080:
+			muram_size = 160*KILOBYTE;
+			dmas_num = 32;
+			task_num = 128;
+			if ((num_ports_1g+num_ports_2g5) > 4 || num_ports_10g > 1 || oh_num > 7)
+				goto err_fm_set_param;
+		break;
+		case e_p1023:
+			muram_size = 64*KILOBYTE;
+			dmas_num = 16;
+			task_num = 128;
+			if ((num_ports_1g+num_ports_2g5) > 2 || oh_num > 4)
+				goto err_fm_set_param;
+		break;
+		default:
+			goto err_fm_set_param;
+		break;
+	}
+
+	p_LnxWrpFmDev->id = 0;
+	fsl_fman_phy_maxfrm = frame_size;
+	dpa_rx_extra_headroom = 0; /* ATTENTION: can be != 0 */
+	fm_active_ports_info->num_oh_ports = oh_num;
+	fm_active_ports_info->num_tx_ports = num_ports_1g;
+	fm_active_ports_info->num_rx_ports = num_ports_1g;
+	fm_active_ports_info->num_tx25_ports = num_ports_2g5;
+	fm_active_ports_info->num_rx25_ports = num_ports_2g5;
+	fm_active_ports_info->num_tx10_ports = num_ports_10g;
+	fm_active_ports_info->num_rx10_ports = num_ports_10g;
+
+	return 0;
+
+err_fm_set_param:
+	printf(" ERR: To many ports!!! \n");
+	return -1;
+}
+
+int main (int argc, char *argv[]){
+	t_LnxWrpFmDev LnxWrpFmDev;
+	t_LnxWrpFmDev *p_LnxWrpFmDev = &LnxWrpFmDev;
+	int tokens_cnt = 1;
+
+	char *token = NULL;
+
+	while(tokens_cnt < argc)
+	{
+	        token = argv[tokens_cnt++];
+		if (strcmp(token, "-b") == 0){
+			if(strcmp(argv[tokens_cnt],"p3") == 0)
+				board_type = e_p3041;
+			else if(strcmp(argv[tokens_cnt],"p4") == 0)
+				board_type = e_p4080;
+			else if(strcmp(argv[tokens_cnt],"p5") == 0)
+				board_type = e_p5020;
+			else if(strcmp(argv[tokens_cnt],"p1") == 0)
+				board_type = e_p1023;
+			else
+				show_help();
+			tokens_cnt++;
+		}
+		else if(strcmp(token, "-d") == 0){
+			dmas_num = atoi(argv[tokens_cnt++]);
+		}
+		else if(strcmp(token, "-t") == 0)
+			task_num = atoi(argv[tokens_cnt++]);
+		else if(strcmp(token, "-f") == 0)
+			frame_size = atoi(argv[tokens_cnt++]);
+		else if(strcmp(token, "-o") == 0)
+			oh_num = atoi(argv[tokens_cnt++]);
+		else if(strcmp(token, "-g1") == 0)
+			num_ports_1g = atoi(argv[tokens_cnt++]);
+		else if(strcmp(token, "-g10") == 0)
+			num_ports_10g = atoi(argv[tokens_cnt++]);
+		else if(strcmp(token, "-g25") == 0)
+			num_ports_2g5 = atoi(argv[tokens_cnt++]);
+		else {
+			show_help();
+			return -1;
+		}
+	}
+
+	if(fm_set_param(p_LnxWrpFmDev) < 0){
+		show_help();
+		return -1;
+	}
+
+	if(fm_precalculate_fifosizes(
+		p_LnxWrpFmDev,
+		128*KILOBYTE)
+		!= 0)
+		return -1;
+	if(fm_precalculate_open_dma(
+		p_LnxWrpFmDev,
+		dmas_num,                   /* max open dmas:dpaa_integration_ext.h */
+		FM_DEFAULT_TX10G_OPENDMA,   /* default TX 10g open dmas */
+		FM_DEFAULT_RX10G_OPENDMA,   /* default RX 10g open dmas */
+		FM_10G_OPENDMA_MIN_TRESHOLD,/* TX 10g minimum treshold */
+		FM_10G_OPENDMA_MIN_TRESHOLD)/* RX 10g minimum treshold */
+		!= 0)
+		return -1;
+	if(fm_precalculate_tnums(
+		p_LnxWrpFmDev,
+		task_num) /* max TNUMS: dpa integration file. */
+		!= 0)
+		 return -1;
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.h
new file mode 100644
index 0000000..063946e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.h
@@ -0,0 +1,144 @@
+/* Copyright (c) 2012 Freescale Semiconductor, Inc
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FM_RESS_TEST_H_
+#define FM_RESS_TEST_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define _Packed
+#define _PackedType __attribute__ ((packed))
+#define MAX(x, y) (((x) > (y)) ? (x) : (y))
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#define KERN_ALERT ""
+#define KERN_INFO ""
+#define ASSERT_COND assert
+#define printk printf
+#define NET_IP_ALIGN 0
+#define FM_FIFO_ALLOCATION_OLD_ALG
+
+#if defined(CONFIG_FMAN_DISABLE_OH_AND_DISTRIBUTE_RESOURCES)
+#define FM_10G_OPENDMA_MIN_TRESHOLD 8 /* 10g minimum treshold if only HC is enabled and no OH port enabled */
+#define FM_OPENDMA_RX_TX_RAPORT 2 /* RX = 2*TX */
+#else
+#define FM_10G_OPENDMA_MIN_TRESHOLD 7 /* 10g minimum treshold if 7 OH ports are enabled */
+#define FM_OPENDMA_RX_TX_RAPORT 1 /* RX = TX */
+#endif
+#define FM_DEFAULT_TX10G_OPENDMA 8 /* default TX 10g open dmas */
+#define FM_DEFAULT_RX10G_OPENDMA 8 /* default RX 10g open dmas */
+
+/* information about all active ports for an FMan.
+ * !Some ports may be disabled by u-boot, thus will not be available */
+struct fm_active_ports {
+    uint32_t num_oh_ports;
+    uint32_t num_tx_ports;
+    uint32_t num_rx_ports;
+    uint32_t num_tx25_ports;
+    uint32_t num_rx25_ports;
+    uint32_t num_tx10_ports;
+    uint32_t num_rx10_ports;
+};
+
+/* FMan resources precalculated at fm probe based
+ * on available FMan port. */
+struct fm_resource_settings {
+    /* buffers - fifo sizes */
+    uint32_t tx1g_num_buffers;
+    uint32_t rx1g_num_buffers;
+    uint32_t tx2g5_num_buffers; /* Not supported yet by LLD */
+    uint32_t rx2g5_num_buffers; /* Not supported yet by LLD */
+    uint32_t tx10g_num_buffers;
+    uint32_t rx10g_num_buffers;
+    uint32_t oh_num_buffers;
+    uint32_t shared_ext_buffers;
+
+
+    /* open DMAs */
+    uint32_t tx_1g_dmas;
+    uint32_t rx_1g_dmas;
+    uint32_t tx_2g5_dmas; /* Not supported yet by LLD */
+    uint32_t rx_2g5_dmas; /* Not supported yet by LLD */
+    uint32_t tx_10g_dmas;
+    uint32_t rx_10g_dmas;
+    uint32_t oh_dmas;
+    uint32_t shared_ext_open_dma;
+
+    /* Tnums */
+    uint32_t tx_1g_tnums;
+    uint32_t rx_1g_tnums;
+    uint32_t tx_2g5_tnums; /* Not supported yet by LLD */
+    uint32_t rx_2g5_tnums; /* Not supported yet by LLD */
+    uint32_t tx_10g_tnums;
+    uint32_t rx_10g_tnums;
+    uint32_t oh_tnums;
+    uint32_t shared_ext_tnums;
+};
+
+typedef struct {
+	uint8_t                     id;
+    struct fm_active_ports      fm_active_ports_info;
+    struct fm_resource_settings fm_resource_settings_info;
+} t_LnxWrpFmDev;
+
+typedef struct {
+	uint8_t                     id;
+} t_LnxWrpFmPortDev;
+
+typedef _Packed struct t_FmPrsResult {
+	volatile uint8_t     lpid;               /**< Logical port id */
+	volatile uint8_t     shimr;              /**< Shim header result  */
+	volatile uint16_t    l2r;                /**< Layer 2 result */
+	volatile uint16_t    l3r;                /**< Layer 3 result */
+	volatile uint8_t     l4r;                /**< Layer 4 result */
+	volatile uint8_t     cplan;              /**< Classification plan id */
+	volatile uint16_t    nxthdr;             /**< Next Header  */
+	volatile uint16_t    cksum;              /**< Checksum */
+	volatile uint32_t    lcv;                /**< LCV */
+	volatile uint8_t     shim_off[3];        /**< Shim offset */
+	volatile uint8_t     eth_off;            /**< ETH offset */
+	volatile uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
+	volatile uint8_t     vlan_off[2];        /**< VLAN offset */
+	volatile uint8_t     etype_off;          /**< ETYPE offset */
+	volatile uint8_t     pppoe_off;          /**< PPP offset */
+	volatile uint8_t     mpls_off[2];        /**< MPLS offset */
+	volatile uint8_t     ip_off[2];          /**< IP offset */
+	volatile uint8_t     gre_off;            /**< GRE offset */
+	volatile uint8_t     l4_off;             /**< Layer 4 offset */
+	volatile uint8_t     nxthdr_off;         /**< Parser end point */
+} _PackedType t_FmPrsResult;
+
+#endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.make b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.make
new file mode 100644
index 0000000..58009cd
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources_ut.make
@@ -0,0 +1,28 @@
+CC=gcc
+
+LNXWRP_RESS_UT=lnxwrp_resources_ut
+OBJ=lnxwrp_resources
+
+INC_PATH=
+LIB_PATH=
+
+INC=$(addprefix -I,$(INC_PATH))
+LIB=$(addprefix -L,$(LIB_PATH))
+
+CFLAGS= -gdwarf-2 -g -O0 -Wall
+XFLAGS= -DFMAN_RESOURCES_UNIT_TEST
+
+all: $(LNXWRP_RESS_UT)
+
+$(LNXWRP_RESS_UT):$(addsuffix .o,$(OBJ)) $(LNXWRP_RESS_UT).o
+	$(CC) -o $(LNXWRP_RESS_UT) $(LNXWRP_RESS_UT).o $(addsuffix .o,$(OBJ))
+
+%.o: %.c
+	@(echo "        (CC)  $@")
+	@($(CC) $(INC) $(CFLAGS) $(XFLAGS) -o $(@) -c $<)
+
+.PHONY: clean
+
+clean:
+	rm -f *.o
+	rm -f $(LNXWRP_RESS_UT)
-- 
1.7.9.7

