From a8c5bbd4d53b6c63dfa46c4a7358ae931a7cf790 Mon Sep 17 00:00:00 2001
From: Stefan Szabo <szbs001@freescale.com>
Date: Tue, 17 Jul 2012 16:18:16 +0300
Subject: [PATCH 074/162] fmd: FMD 17 integration (NCSW IR4 RC1)

- Integration of new NCSW IR4 RC1 code drop
- Align value used for OH port minimum FIFO size
  in the resource allocation algorithm with the default in LLD.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |    5 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |  257 ++++--
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |  104 ++-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h       |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |   17 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   27 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |   83 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |   11 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   40 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |  452 +++++-----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   41 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |    4 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  899 +++++++++++---------
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   11 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  775 ++++++++++++++---
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   13 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |   14 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   51 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |   46 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   70 +-
 .../inc/integrations/P1023/dpaa_integration_ext.h  |    3 +
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |   34 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |    4 +-
 25 files changed, 1908 insertions(+), 1071 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index c83d1e2..50392b2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -644,9 +644,6 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
     if (!i)
         return E_TIMEOUT;
 
-    tmpReg32 &= ~CMD_CFG_STAT_CLR;
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
-
     return E_OK;
 }
 
@@ -887,7 +884,7 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     t_Error err;
 
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
-    XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
+    XX_Print("Applying 10G TX ECC workaround (10GMAC-A004) ...");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
     WRITE_UINT32(p_Tgec->p_MemMap->command_config, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 4e5c65e..d03375c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -517,12 +517,13 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
                                                    t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
                                                    bool                                useShadowStructs)
 {
-    t_List                          *p_Pos;
-    t_Error                         err = E_OK;
-    t_CcNodeInformation             ccNodeInfo, *p_CcNodeInformation;
-    t_Handle                        h_Muram;
-    t_FmPcdCcNode                   *p_FmPcdCcNextNode;
-    t_List                          *p_UpdateLst;
+    t_List                  *p_Pos;
+    t_Error                 err = E_OK;
+    t_CcNodeInformation     ccNodeInfo, *p_CcNodeInformation;
+    t_Handle                h_Muram;
+    t_FmPcdCcNode           *p_FmPcdCcNextNode;
+    t_List                  *p_UpdateLst;
+    uint32_t                intFlags;
 
     UNUSED(numOfGoodChanges);
 
@@ -661,15 +662,21 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         if (p_AdditionalParams->p_AdTableNew)
             ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable = p_AdditionalParams->p_AdTableNew;
 
-        if (p_AdditionalParams->numOfKeys)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
-
         if (p_AdditionalParams->p_KeysMatchTableNew)
             ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable = p_AdditionalParams->p_KeysMatchTableNew;
 
+        /* Locking node's spinlock before updating 'keys and next engine' structure,
+           as it maybe used to retrieve keys statistics */
+        intFlags = XX_LockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
+
+        if (p_AdditionalParams->numOfKeys)
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
+
         memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                 &p_AdditionalParams->keyAndNextEngineParams,
                 sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
+
+        XX_UnlockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock, intFlags);
     }
     else
         memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
@@ -1428,7 +1435,9 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
 
     if ((supportedStatsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
         (p_FmPcdCcNextEngineParams->statisticsEn))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics supported was not requested upon this table initialization"));
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+                     ("Statistics are requested for a key, but statistics mode was set"
+                      "to 'NONE' upon initialization of this match table"));
 
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -1602,8 +1611,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return CC_PC_ILLEGAL;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
             }
 
         case (HEADER_TYPE_MPLS):
@@ -1617,10 +1626,10 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return CC_PC_ILLEGAL;
 
-               default:
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-             }
+            }
 
         case (HEADER_TYPE_IPv4):
             switch (field.ipv4)
@@ -1674,7 +1683,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             }
 
         case (HEADER_TYPE_IPv6):
-             switch (field.ipv6)
+            switch (field.ipv6)
             {
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
@@ -1725,7 +1734,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-           }
+            }
         case (HEADER_TYPE_MINENCAP):
             switch (field.minencap)
             {
@@ -1744,7 +1753,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-           }
+            }
 
         case (HEADER_TYPE_TCP):
             switch (field.tcp)
@@ -1791,7 +1800,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
             }
 
-         default:
+        default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             return CC_PC_ILLEGAL;
     }
@@ -1842,9 +1851,9 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
 
         case (HEADER_TYPE_MPLS):
             if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
             else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
             else
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
@@ -1885,7 +1894,7 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
             return CC_PC_ILLEGAL;
-     }
+    }
 
     if (offsetRelevant)
         return CC_PR_OFFSET;
@@ -1907,7 +1916,7 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
     switch (hdr)
     {
         case (HEADER_TYPE_NONE):
-                ASSERT_COND(FALSE);
+            ASSERT_COND(FALSE);
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -2023,7 +2032,7 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                        tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                       tmp |= p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     }
                     else
@@ -2045,7 +2054,7 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                     tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |= (p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                 }
                 else
@@ -2079,7 +2088,7 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |= (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
@@ -2696,7 +2705,7 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
     int                     size;
     int                     i = 0, j = 0;
     bool                    prvLclMask;
-    t_FmPcdStatsObj         *p_StatsObj;
+    t_FmPcdStatsObj         *p_StatsObj, tmpStatsObj;
     p_AdditionalInfo->numOfKeys =  p_CcNode->numOfKeys;
 
     prvLclMask = p_CcNode->lclMask;
@@ -2742,12 +2751,24 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
-                /* Store allocated statistics object */
-                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
-
                 UpdateStatsCounters(p_AdTableNewTmp,
                                     (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
 
+                tmpStatsObj.h_StatsAd = p_StatsObj->h_StatsAd;
+                tmpStatsObj.h_StatsCounters = p_StatsObj->h_StatsCounters;
+
+                /* As we need to replace only the counters, we build a new statistics
+                   object that holds the old AD and the new counters - this will be the
+                   currently used statistics object.
+                   The newly allocated AD is not required and may be released back to
+                   the available objects with the previous counters pointer. */
+                p_StatsObj->h_StatsAd = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+
+                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd = tmpStatsObj.h_StatsAd;
+
+                /* Store allocated statistics object */
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+
                 /* As statistics were previously enabled, store the old statistics object to be released */
                 p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
             }
@@ -2867,8 +2888,10 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+
 #if (DPAA_VERSION >= 11)
         if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
             (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
@@ -2958,7 +2981,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         ASSERT_COND(p_FmPcdCcNode1);
-        if(!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
+        if (!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
         {
             LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode1->ccTreesLst)
             {
@@ -3026,9 +3049,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if ((!p_AdditionalInfo->tree) &&
          (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
          (!p_CcNextEngineParams->statisticsEn))
+    {
         p_AdditionalInfo->p_StatsObjForRmv =
                 ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj;
 
+        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = NULL;
+    }
 #if (DPAA_VERSION >= 11)
         if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
             (p_CcNextEngineParams->params.frParams.h_FrmReplic) &&
@@ -3393,7 +3419,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     uint32_t                requiredAction = 0;
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
                                      p_CcNodeParam->keysParams.frameLengthRanges,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3512,7 +3538,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
                                      p_CcNodeParam->keysParams.frameLengthRanges,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3558,7 +3584,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
         err = ValidateNextEngineParams(h_FmPcd,
                                        &p_KeyParams->ccNextEngineParams,
-                                       p_CcNodeParam->keysParams.statisticsMode);
+                                       p_CcNode->statisticsMode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
@@ -3624,7 +3650,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNodeParam->keysParams.statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
                                      p_CcNodeParam->keysParams.frameLengthRanges,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3633,8 +3659,8 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
 
     err = ValidateNextEngineParams(h_FmPcd,
                                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNodeParam->keysParams.statisticsMode);
-    if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+                                   p_CcNode->statisticsMode);
+    if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
     for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
@@ -3648,7 +3674,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
         {
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
-                                           p_CcNodeParam->keysParams.statisticsMode);
+                                           p_CcNode->statisticsMode);
             if (err)
                 RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
 
@@ -3893,6 +3919,37 @@ static t_Error PreAllocStatsObjs(t_FmPcdCcNode *p_CcNode)
     return E_OK;
 }
 
+static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
+                                          uint16_t                keyIndex,
+                                          t_FmPcdCcKeyStatistics  *p_KeyStatistics)
+{
+    uint32_t    *p_StatsCounters, i;
+
+    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
+
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
+
+    if (!p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this key"));
+
+    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    ASSERT_COND(p_StatsCounters);
+
+    p_KeyStatistics->byteCount = GET_UINT32(*p_StatsCounters);
+
+    for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
+    {
+        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
+
+        p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
+    }
+
+    return E_OK;
+}
+
+
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
@@ -4298,13 +4355,8 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     if (p_CcNode->maxNumOfKeys)
-    {
-        if ((p_CcNode->numOfKeys + 1) > p_CcNode->maxNumOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
-
         if ((!p_CcNode->maskSupport) && (p_Mask))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
-    }
 
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
@@ -4390,7 +4442,7 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams =  ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -4441,10 +4493,10 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
     if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than 255"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_CC_NODES));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step."));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
@@ -5061,10 +5113,10 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
      if (!FmPcdLockTryLockAll(p_FmPcd))
     {
-        DeleteTree(p_FmPcdCcTree, p_FmPcd);
-        XX_Free(p_Params);
-        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
-        return NULL;
+         FM_PCD_CcRootDelete(p_FmPcdCcTree);
+         XX_Free(p_Params);
+         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+         return NULL;
     }
 
     for (i = 0; i < numOfEntries; i++)
@@ -5076,7 +5128,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             if (err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                FM_PCD_CcRootDelete(p_FmPcdCcTree);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
                 return NULL;
@@ -5089,13 +5141,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_FmPcdCcTree->p_Lock = FmPcdAcquireLock(p_FmPcd);
     if (!p_FmPcdCcTree->p_Lock)
     {
-        DeleteTree(p_FmPcdCcTree, p_FmPcd);
+        FM_PCD_CcRootDelete(p_FmPcdCcTree);
         XX_Free(p_Params);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC lock"));
         return NULL;
     }
 
     XX_Free(p_Params);
+
     return p_FmPcdCcTree;
 }
 
@@ -5227,6 +5280,13 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
     p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
 
+    /* For backward compatibility - even if statistics mode is nullified,
+       we'll fix it to frame mode so we can support per-key request for
+       statistics using 'statisticsEn' in next engine parameters */
+    if ((!p_CcNode->maxNumOfKeys) &&
+        (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
+            p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
+
     h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
     if (!h_FmMuram)
     {
@@ -5464,7 +5524,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             return NULL;
         }
 
-        if (p_CcNodeParam->keysParams.statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
+        if (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
         {
             err = PreAllocStatsObjs(p_CcNode);
             if (err != E_OK)
@@ -5481,7 +5541,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                                      FM_PCD_CC_AD_ENTRY_SIZE,
                                                      FM_PCD_CC_AD_TABLE_ALIGN);
-        if(!p_CcNode->h_Ad)
+        if (!p_CcNode->h_Ad)
         {
             DeleteNode(p_CcNode);
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
@@ -5492,7 +5552,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         numOfKeysToAlloc = p_CcNode->numOfKeys;
 
     /* If RMON statistics mode requested, allocate frame length ranges array */
-    if (p_CcNodeParam->keysParams.statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
+    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
         /* First counter is always 'byte count', so ranges count is smaller by 1 */
         p_CcNode->h_StatsFLRs =
@@ -5839,9 +5899,8 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
     uint32_t        intFlags;
     t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Mask, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
@@ -6246,22 +6305,16 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            *p_StatsCounters, *p_FrameCounter;
+    uint32_t            *p_StatsCounters, frameCount;
+    uint32_t            intFlags;
 
     SANITY_CHECK_RETURN_VALUE(p_CcNode, E_INVALID_HANDLE, 0);
 
-    if (keyIndex >= p_CcNode->numOfKeys)
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
-        return 0;
-    }
-
     if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
         return 0;
     }
-    ASSERT_COND(p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj);
 
     if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME) &&
         (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
@@ -6270,13 +6323,30 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
         return 0;
     }
 
+    intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
+
+    if (keyIndex >= p_CcNode->numOfKeys)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
+        return 0;
+    }
+
+    if (!p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this key"));
+        return 0;
+    }
+
     p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    ASSERT_COND(p_StatsCounters);
 
-    /* The first counter is byte counter */
-    p_FrameCounter = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
-    ASSERT_COND(p_FrameCounter);
+    /* The first counter is byte counter, so we need to advance to the next counter */
+    frameCount = GET_UINT32(*(uint32_t *)(PTR_MOVE(p_StatsCounters,
+                                                   FM_PCD_CC_STATS_FLR_COUNT_SIZE)));
+
+    XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
-    return GET_UINT32(*p_FrameCounter);
+    return frameCount;
 }
 
 t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
@@ -6284,31 +6354,22 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
                                           t_FmPcdCcKeyStatistics    *p_KeyStatistics)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            *p_StatsCounters, i;
-
-    if (keyIndex >= p_CcNode->numOfKeys)
-    {
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
-    }
-
-    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
-    {
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
-    }
+    uint32_t            intFlags;
+    t_Error             err;
 
-    ASSERT_COND(p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
 
-    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
-    ASSERT_COND(p_StatsCounters);
+    intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    p_KeyStatistics->byteCount = GET_UINT32(*p_StatsCounters);
+    err = MatchTableGetKeyStatistics(p_CcNode,
+                                     keyIndex,
+                                     p_KeyStatistics);
 
-    for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
-    {
-        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_FLR_COUNT_SIZE);
+    XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
-        p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
-    }
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -6321,21 +6382,29 @@ t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     uint16_t            keyIndex;
+    uint32_t            intFlags;
     t_Error             err;
 
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Mask, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
+
+    intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
     if (GET_ERROR_TYPE(err) != E_OK)
-    {
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
                                   "match table of the provided node"));
-    }
 
-    return FM_PCD_MatchTableGetKeyStatistics(h_CcNode, keyIndex, p_KeyStatistics);
+    err = MatchTableGetKeyStatistics(p_CcNode,
+                                     keyIndex,
+                                     p_KeyStatistics);
+
+    XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
+
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
 }
 
 t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 1a112c3..211fd62 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -153,6 +153,7 @@
 #if (DPAA_VERSION >= 11)
 #define FM_PCD_AD_RESULT_VSP_SHIFT           24
 #define FM_PCD_AD_RESULT_NO_OM_VSPE          0x02000000
+#define FM_PCD_AD_RESULT_VSP_MASK            0x3f
 #endif /* (DPAA_VERSION >= 11) */
 
 #define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index e6591f6..71484e8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -94,7 +94,7 @@ static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
 {
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
     /* Wait for GO to be idle and read error */
-    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO);
     if (kgar & FM_PCD_KG_KGAR_ERR)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
     return E_OK;
@@ -109,7 +109,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
         case (KG_SCH_GEN_PARSE_RESULT_N_FQID):
         case (KG_SCH_GEN_DEFAULT):
         case (KG_SCH_GEN_NEXTHDR):
-            for (i=0 ; i<numOfSwDefaults ; i++)
+            for (i = 0; i < numOfSwDefaults; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
             ASSERT_COND(FALSE);
@@ -128,7 +128,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
         case (KG_SCH_GEN_IP2_NO_V):
         case (KG_SCH_GEN_GRE_NO_V):
         case (KG_SCH_GEN_L4_NO_V):
-            for (i=0 ; i<numOfSwDefaults ; i++)
+            for (i = 0; i < numOfSwDefaults; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
 
@@ -155,7 +155,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
         case (KG_SCH_GEN_SCTP):
         case (KG_SCH_GEN_DCCP):
         case (KG_SCH_GEN_IPSEC_ESP):
-            for (i=0 ; i<numOfSwDefaults ; i++)
+            for (i = 0; i < numOfSwDefaults; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
         default:
@@ -403,8 +403,10 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
             }
 }
 
-static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
 {
+    UNUSED(p_FmPcd);
+
     switch (hdr)
     {
         case (HEADER_TYPE_NONE):
@@ -519,8 +521,14 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_PTYPE2;
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+#ifdef FM_KG_NO_IPPID_SUPPORT
+                    if (p_FmPcd->fmRevInfo.majorRev < 6)
+                        return KG_SCH_KN_PTYPE2;
+#endif /* FM_KG_NO_IPPID_SUPPORT */
+                        return KG_SCH_KN_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
@@ -661,10 +669,10 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
 
     /* bitOffset 1-7 --> mask 0x1-0x7F */
-    if (bitOffset<8)
+    if (bitOffset < 8)
     {
         mask = 0;
-        for (i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
+        for (i = 0; i < bitOffset; i++, walking1Mask <<= 1)
             mask |= walking1Mask;
     }
     else
@@ -678,7 +686,7 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
           /* bitOffset 9-15 --> mask 0xFE-0x80 */
           if (!fqid && bitOffset>8)
                numOfOnesToClear = (uint8_t)(bitOffset-8);
-       for (i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
+       for (i = 0; i < numOfOnesToClear; i++, walking1Mask <<= 1)
            mask &= ~walking1Mask;
        /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
     }
@@ -879,7 +887,7 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
                 if (schemeIndexes & 0x1)
                     p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
                 schemeIndexes >>= 1;
-                index+=1;
+                index += 1;
             }
         }
         else /* this should happen only when interrupt is forced. */
@@ -972,7 +980,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
                    p_FmPcd);
 
     /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
     {
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
@@ -989,7 +997,6 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
     WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
 
-
     if (p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
         err = FmPcdKgAllocSchemes(p_FmPcd,
@@ -1030,15 +1037,15 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
     uint8_t                             grpBase;
-    bool                                direct=TRUE, absolute=FALSE;
-    uint16_t                            profileId=0, numOfProfiles=0, relativeProfileId;
+    bool                                direct = TRUE, absolute = FALSE;
+    uint16_t                            profileId = 0, numOfProfiles = 0, relativeProfileId;
     t_Error                             err = E_OK;
     int                                 i = 0;
     t_NetEnvParams                      netEnvParams;
     uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
     t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash = NULL;
     uint8_t                             j, curr, idx;
-    uint8_t                             id, shift=0, code=0, offset=0, size=0;
+    uint8_t                             id, shift = 0, code = 0, offset = 0, size = 0;
     t_FmPcdExtractEntry                 *p_Extract = NULL;
     t_FmPcdKgExtractedOrParams          *p_ExtractOr;
     bool                                generic = FALSE;
@@ -1332,7 +1339,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         /*  configure kgse_ekdv  */
         tmpReg = 0;
-        for ( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
+        for (i = 0; i < p_KeyAndHash->numOfUsedDflts; i++)
         {
             switch (p_KeyAndHash->dflts[i].type)
             {
@@ -1402,7 +1409,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         /*  configure kgse_ekfc and  kgse_gec */
         knownTmp = 0;
-        for ( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        for (i = 0; i < p_KeyAndHash->numOfUsedExtracts; i++)
         {
             p_Extract = &p_KeyAndHash->extractArray[i];
             switch (p_Extract->type)
@@ -1446,7 +1453,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
-                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
+                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET; */
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
                                         case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
@@ -1510,7 +1517,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             if (!p_Extract->extractByHdr.ignoreProtocolValidation)
                             {
                                 /* if we have a known field for it - use it, otherwise use generic */
-                                bitMask = GetKnownProtMask(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
+                                bitMask = GetKnownProtMask(p_FmPcd, p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
                                             p_Extract->extractByHdr.extractByHdrType.fullField);
                                 if (bitMask)
                                 {
@@ -1583,7 +1590,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
-        for ( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        for (i = 0; i < p_KeyAndHash->numOfUsedMasks; i++)
         {
             /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
             id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
@@ -1597,7 +1604,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
             /* Get the shift of the offset field (depending on i) - may
                be in  kgse_bmch or in kgse_fqb (depending on i) */
             GET_MASK_OFFSET_SHIFT(shift,i);
-            if (i<=1)
+            if (i <= 1)
                 selectTmp |= p_KeyAndHash->masks[i].offset << shift;
             else
                 fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
@@ -1607,9 +1614,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
             /* pass all bits */
             maskTmp |= KG_SCH_BITMASK_MASK << shift;
             /* clear bits that need masking */
-            maskTmp &= ~(0xFF << shift) ;
+            maskTmp &= ~(0xFF << shift);
             /* set mask bits */
-            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift);
         }
         p_SchemeRegs->kgse_bmch = selectTmp;
         p_SchemeRegs->kgse_bmcl = maskTmp;
@@ -1649,11 +1656,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
            num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
            first_generic_index = num_of_known */
         curr = 0;
-        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        for (i = 0; i < p_KeyAndHash->numOfUsedExtracts; i++)
         {
             if (p_LocalExtractsArray->extractsArray[i].known)
             {
-                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
+                ASSERT_COND(curr < (p_KeyAndHash->numOfUsedExtracts - currGenId));
                 j = curr;
                 /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
                 index in the user's extractions array */
@@ -1697,7 +1704,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
 
     /*  configure kgse_spc  */
-    if ( p_SchemeParams->schemeCounter.update)
+    if (p_SchemeParams->schemeCounter.update)
         p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
 
@@ -1706,7 +1713,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
-    for ( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
+    for (i = 0; i < p_SchemeParams->numOfUsedExtractedOrs; i++)
     {
 
         p_Scheme->extractedOrs = TRUE;
@@ -1788,7 +1795,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         {
             if (p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
-            if (p_ExtractOr->bitOffsetInFqid<8)
+            if (p_ExtractOr->bitOffsetInFqid < 8)
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
             else
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
@@ -1805,14 +1812,14 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
         /* clear bits that need masking */
-        genTmp &= ~KG_SCH_GEN_MASK ;
+        genTmp &= ~KG_SCH_GEN_MASK;
         /* set mask bits */
         genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
         p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
 
     }
     /* clear all unused GEC registers */
-    for ( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for (i = currGenId; i < FM_PCD_KG_NUM_OF_GENERIC_REGS; i++)
         p_SchemeRegs->kgse_gec[i] = 0;
 
     /* add base Qid for this scheme */
@@ -1829,9 +1836,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     return E_OK;
 }
 
+
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
+
 t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1863,7 +1872,8 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
     p_ClsPlanGrp->owners = 0;
     FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
-    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+    if (p_Grp->numOfOptions != 0)
+        FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
 
     p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1 << p_Grp->numOfOptions);
     /* a minimal group of 8 is required */
@@ -1913,7 +1923,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
     oredVectors = 0;
-    for (i = 0; i<p_Grp->numOfOptions; i++)
+    for (i = 0; i < p_Grp->numOfOptions; i++)
     {
         oredVectors |= p_Grp->optVectors[i];
         /* save an array of used options - the indexes represent the power of 2 index */
@@ -1922,10 +1932,10 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     /* set the classification plan relevant entries so that all bits
      * relevant to the list of options is cleared
      */
-    for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+    for (j = 0; j < p_ClsPlanGrp->sizeOfGrp; j++)
         p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    for (i = 0; i<p_Grp->numOfOptions; i++)
+    for (i = 0; i < p_Grp->numOfOptions; i++)
     {
        /* option i got the place 2^i in the clsPlan array. all entries that
          * have bit i set, should have the vector bit cleared. So each option
@@ -1949,7 +1959,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         /* now for each option (i), we set their bits in all entries (j)
          * that contain bit 2^i.
          */
-        for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        for (j = 0; j < p_ClsPlanGrp->sizeOfGrp; j++)
         {
             if (j & (1<<i))
                 p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
@@ -1977,10 +1987,10 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 
     FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
 
-    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
-
     if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
         p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+    else
+        FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
 
     /* clear clsPlan driver structure */
     memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
@@ -2042,7 +2052,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* for each scheme */
-    for (i = 0; i<p_BindPort->numOfSchemes; i++)
+    for (i = 0; i < p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
         if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
@@ -2061,7 +2071,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
             HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
             if (p_Scheme->nextRelativePlcrProfile)
             {
-                for (j = 0;j<p_Scheme->numOfProfiles;j++)
+                for (j = 0; j < p_Scheme->numOfProfiles; j++)
                 {
                     ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
                     if (p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
@@ -2229,7 +2239,7 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     numOfBlocks, blocksFound = 0, first = 0;
     uint8_t     i, j;
 
     /* This routine is issued only on master core of master partition -
@@ -2293,7 +2303,7 @@ UNUSED(guestId);
     ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
 
     baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for (i=baseBlock;i<baseBlock+numOfBlocks;i++)
+    for (i = baseBlock; i < baseBlock + numOfBlocks; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
         ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
@@ -2330,7 +2340,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    for (i = p_Set->baseEntry; i < p_Set->baseEntry + p_Set->numOfClsPlanEntries; i += 8)
     {
         tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
@@ -2775,7 +2785,7 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t     i;
 
-    for (i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+    for (i = 0; i < p_FmPcd->p_FmPcdKg->numOfSchemes; i++)
         if (p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
             return i;
 
@@ -3031,7 +3041,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
     WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
     WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
-    for (i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for (i = 0; i < FM_PCD_KG_NUM_OF_GENERIC_REGS; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
@@ -3241,7 +3251,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
 
     DUMP_SUBTITLE(("\n"));
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for (j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    for (j = 0; j < FM_PCD_KG_NUM_OF_SCHEMES; j++)
     {
         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
         if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
@@ -3272,7 +3282,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
     DUMP_SUBTITLE(("\n"));
 
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
     {
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
@@ -3289,7 +3299,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
 
     DUMP_SUBTITLE(("\n"));
-    for (j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    for (j = 0; j < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP; j++)
     {
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
index 6aa4dc8..e0ad786 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
@@ -105,6 +105,7 @@ typedef uint32_t t_KnownFieldsMasks;
 #define KG_SCH_KN_GREPTYPE                  0x00000400
 #define KG_SCH_KN_IPSEC_SPI                 0x00000200
 #define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_IPPID                     0x00000080
 #define KG_SCH_KN_L4PSRC                    0x00000004
 #define KG_SCH_KN_L4PDST                    0x00000002
 #define KG_SCH_KN_TFLG                      0x00000001
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index a3be4cf..02b7458 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -58,7 +58,7 @@
 
 #define WRITE_UINT16(addr, val)     \
     do{                             \
-            if ((int)&(addr) % 4)    \
+            if ((int)&(addr) % 4)   \
                 WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
                         ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
             else                    \
@@ -168,6 +168,7 @@ static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
             case (e_FM_PCD_MANIP_INSRT_BY_HDR):
                 /* As long as the only insert command is the internal L2, no check on type is required */
                 tableSize +=  HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
+                break;
             default:
                 REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
                 return 0;
@@ -344,6 +345,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                         hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
                     else
                         hmcdOpt = HMCD_INSRT_L2_MPLS;
+                    break;
                 default:
                     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
             }
@@ -634,6 +636,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
         FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
         /* update old manip table pointer */
         MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
+        /* indicate that this manip node has no MURAM memory to be freed */
+        MANIP_SET_UNIFIED_TBL_PTR_INDICATION(p_FmPcdManipParams->h_NextManip);
+        /* advance pointer */
         p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
     }
     else
@@ -1906,9 +1911,11 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
-    /* TODO - Ganit */
-    if (p_Manip->owner && p_Manip->h_PrevManip)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No sharing on cascaded internal nodes"));
+    /* Check that next-manip is not already used */
+    if ((p_Manip->type == HMAN_OC) &&
+            p_ManipParams->h_NextManip &&
+            MANIP_GET_OWNERS(p_ManipParams->h_NextManip))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_NextManip is already used and may not be shared (no sharing of non-head manip nodes)"));
 
     return E_OK;
 }
@@ -3663,7 +3670,7 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_InsertData);
     if (p_Manip->p_UpdateData)
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_UpdateData);
-    if (p_Manip->p_HmcdTbl)
+    if (p_Manip->p_HmcdTbl && !p_Manip->unifiedTablePtr)
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_HmcdTbl);
 
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 9becfea..388be01 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -209,14 +209,16 @@
 
 #define HMCD_IP_REPLACE_L3HDRSIZE_SHIFT         24
 
-#define MANIP_IS_CASCADE(h_Manip)               (((t_FmPcdManip *)h_Manip)->cascadedNext)
-#define MANIP_GET_HMCT_SIZE(h_Manip)            (((t_FmPcdManip *)h_Manip)->tableSize)
-#define MANIP_GET_HMCT_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
-#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)   (((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
-#define MANIP_GET_HMTD_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->h_Ad)
-#define MANIP_DONT_REPARSE(h_Manip)             (((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
-#define MANIP_SET_PREV(h_Manip, h_Prev)         (((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
-#define MANIP_GET_MURAM(h_Manip)                (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
+#define MANIP_IS_CASCADE(h_Manip)                       (((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define MANIP_GET_HMCT_SIZE(h_Manip)                    (((t_FmPcdManip *)h_Manip)->tableSize)
+#define MANIP_GET_HMCT_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
+#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)           (((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
+#define MANIP_GET_HMTD_PTR(h_Manip)                     (((t_FmPcdManip *)h_Manip)->h_Ad)
+#define MANIP_DONT_REPARSE(h_Manip)                     (((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
+#define MANIP_SET_PREV(h_Manip, h_Prev)                 (((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
+#define MANIP_GET_OWNERS(h_Manip)                       (((t_FmPcdManip *)h_Manip)->owner)
+#define MANIP_SET_UNIFIED_TBL_PTR_INDICATION(h_Manip)   (((t_FmPcdManip *)h_Manip)->unifiedTablePtr = TRUE)
+#define MANIP_GET_MURAM(h_Manip)                        (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
 
 #define DSCP_TO_VLAN_TABLE_SIZE                 32
 /***********************************************************************/
@@ -370,10 +372,13 @@ typedef struct t_IpReassmParams
 typedef struct{
     bool                    muramAllocate;
     t_Handle                h_Ad;
-    uint32_t                *p_HmcdTbl;
     uint32_t                type;
     bool                    rmv;
     bool                    insrt;
+    t_Handle                h_NextManip;
+    t_Handle                h_PrevManip;
+    /* HdrManip parameters*/
+    uint32_t                *p_HmcdTbl;
     bool                    dontParseAfterManip;
     bool                    fieldUpdate;
     bool                    custom;
@@ -381,10 +386,10 @@ typedef struct{
     uint8_t                 *p_UpdateData;
     uint8_t                 *p_CustomData1;
     uint8_t                 *p_CustomData2;
-    t_Handle                h_NextManip;
-    t_Handle                h_PrevManip;
     uint16_t                tableSize;
     bool                    cascadedNext;
+    bool                    unifiedTablePtr;
+    /* end HdrManip */
     uint8_t                 *p_Template;
     t_Handle                h_Frag;
     bool                    frag;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 73923c9..a051a3d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -202,33 +202,51 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
 
             memcpy((uint8_t*)&ipcKgClsPlanParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcKgClsPlanParams));
             KgFreeClsPlanEntries(h_FmPcd,
-                                       ipcKgClsPlanParams.numOfClsPlanEntries,
-                                       ipcKgClsPlanParams.guestId,
-                                       ipcKgClsPlanParams.clsPlanBase);
+                                 ipcKgClsPlanParams.numOfClsPlanEntries,
+                                 ipcKgClsPlanParams.guestId,
+                                 ipcKgClsPlanParams.clsPlanBase);
             *p_ReplyLength = sizeof(uint32_t);
             break;
         }
         case (FM_PCD_ALLOC_PROFILES):
         {
-            t_FmPcdIpcResourceAllocParams   ipcVspAllocParams;
-            uint8_t                         base;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcResourceAllocParams));
+            t_FmIpcResourceAllocParams      ipcAllocParams;
+            uint16_t                        base;
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
             base =  PlcrAllocProfilesForPartition(h_FmPcd,
-                                                  ipcVspAllocParams.base,
-                                                  ipcVspAllocParams.num,
-                                                  ipcVspAllocParams.guestId);
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&base, sizeof(uint8_t));
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+                                                  ipcAllocParams.base,
+                                                  ipcAllocParams.num,
+                                                  ipcAllocParams.guestId);
+            memcpy(p_IpcReply->replyBody, (uint16_t*)&base, sizeof(uint16_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint16_t);
             break;
         }
         case (FM_PCD_FREE_PROFILES):
         {
-            t_FmPcdIpcResourceAllocParams   ipcVspAllocParams;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcResourceAllocParams));
+            t_FmIpcResourceAllocParams   ipcAllocParams;
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
             PlcrFreeProfilesForPartition(h_FmPcd,
-                                         ipcVspAllocParams.base,
-                                         ipcVspAllocParams.num,
-                                         ipcVspAllocParams.guestId);
+                                         ipcAllocParams.base,
+                                         ipcAllocParams.num,
+                                         ipcAllocParams.guestId);
+            break;
+        }
+        case (FM_PCD_SET_PORT_PROFILES):
+        {
+            t_FmIpcResourceAllocParams   ipcAllocParams;
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            PlcrSetPortProfiles(h_FmPcd,
+                                ipcAllocParams.guestId,
+                                ipcAllocParams.num,
+                                ipcAllocParams.base);
+            break;
+        }
+        case (FM_PCD_CLEAR_PORT_PROFILES):
+        {
+            t_FmIpcResourceAllocParams   ipcAllocParams;
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            PlcrClearPortProfiles(h_FmPcd,
+                                  ipcAllocParams.guestId);
             break;
         }
         case (FM_PCD_GET_SW_PRS_OFFSET):
@@ -1159,7 +1177,7 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
     }
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without IPC!"));
+                     ("running in guest-mode without IPC!"));
 
     if (p_FmPcd->p_FmPcdKg)
         KgEnable(p_FmPcd);
@@ -1213,7 +1231,7 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd)
     }
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without IPC!"));
+                     ("running in guest-mode without IPC!"));
 
     if (p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1244,7 +1262,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
     bool                    ipsecAhExists = FALSE, ipsecEspExists = FALSE, shim1Selected = FALSE;
     uint8_t                 hdrNum;
-    t_FmPcdNetEnvParams     modifiedNetEnvParams;
+    t_FmPcdNetEnvParams     *p_modifiedNetEnvParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
@@ -1257,7 +1275,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         if (!p_FmPcd->netEnvs[i].used)
             break;
 
-    if (i== FM_MAX_NUM_OF_PORTS)
+    if (i == FM_MAX_NUM_OF_PORTS)
     {
         REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
         FmPcdUnlock(p_FmPcd, intFlags);
@@ -1270,8 +1288,15 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     /* As anyone doesn't have handle of this netEnv yet, no need
        to protect it with spinlocks */
 
-    memcpy(&modifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
-    p_NetEnvParams = &modifiedNetEnvParams;
+    p_modifiedNetEnvParams = (t_FmPcdNetEnvParams *) XX_Malloc(sizeof(t_FmPcdNetEnvParams));
+    if (!p_modifiedNetEnvParams)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FmPcdNetEnvParams"));
+        return NULL;
+    }
+
+    memcpy(p_modifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
+    p_NetEnvParams = p_modifiedNetEnvParams;
 
     netEnvCurrId = (uint8_t)i;
 
@@ -1304,6 +1329,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     {
                         REPORT_ERROR(MINOR, E_FULL,
                                 ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
+                        XX_Free(p_modifiedNetEnvParams);
                         return NULL;
                     }
                 }
@@ -1327,6 +1353,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if (ipsecEspExists && (ipsecEspUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    XX_Free(p_modifiedNetEnvParams);
                     return NULL;
                 }
                 else
@@ -1340,6 +1367,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if (ipsecAhExists && (ipsecAhUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    XX_Free(p_modifiedNetEnvParams);
                     return NULL;
                 }
                 else
@@ -1409,6 +1437,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
+                XX_Free(p_modifiedNetEnvParams);
                 return NULL;
             }
     }
@@ -1422,6 +1451,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
+                        XX_Free(p_modifiedNetEnvParams);
                         return NULL;
                     }
                     shim1Selected = TRUE;
@@ -1458,12 +1488,14 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                    XX_Free(p_modifiedNetEnvParams);
                     return NULL;
                 }
                 p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
             }
         }
     }
+    XX_Free(p_modifiedNetEnvParams);
 
     p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock)
@@ -1561,7 +1593,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 !p_FmPcd->h_IpcSession)
             {
                 REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
+                             ("running in guest-mode without neither IPC nor mapped register!"));
                 return 0;
             }
             break;
@@ -1622,7 +1654,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 !p_FmPcd->h_IpcSession)
             {
                 REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("Running in \"guest-mode\" without neither IPC nor mapped registers"));
+                             ("running in guest-mode without neither IPC nor mapped register!"));
                 return 0;
             }
             break;
@@ -1631,7 +1663,8 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
             return 0;
     }
 
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) && p_FmPcd->h_IpcSession)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
         t_FmPcdIpcMsg           msg;
         t_FmPcdIpcReply         reply;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 0fc2463..1bf08ed 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -367,7 +367,7 @@ typedef struct {
 
 typedef struct {
     t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
-    uint8_t                         partPlcrProfilesBase;
+    uint16_t                        partPlcrProfilesBase;
     uint16_t                        partNumOfPlcrProfiles;
     t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
     uint16_t                        numOfSharedProfiles;
@@ -504,8 +504,13 @@ t_Error     PlcrInit(t_FmPcd *p_FmPcd);
 t_Error     PlcrFree(t_FmPcd *p_FmPcd);
 void        PlcrEnable(t_FmPcd *p_FmPcd);
 void        PlcrDisable(t_FmPcd *p_FmPcd);
-uint8_t     PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId);
-void        PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId);
+uint16_t    PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint16_t base, uint16_t numOfProfiles, uint8_t guestId);
+void        PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint16_t base, uint16_t numOfProfiles, uint8_t guestId);
+t_Error     PlcrSetPortProfiles(t_FmPcd    *p_FmPcd,
+                                uint8_t    hardwarePortId,
+                                uint16_t   numOfProfiles,
+                                uint16_t   base);
+t_Error     PlcrClearPortProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId);
 
 t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
 t_Error     PrsInit(t_FmPcd *p_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 1ac58b7..5184ce6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -100,12 +100,6 @@ typedef _Packed struct t_FmPcdIpcPrsIncludePort
     bool        include;
 } _PackedType t_FmPcdIpcPrsIncludePort;
 
-typedef _Packed struct t_FmPcdIpcResourceAllocParams {
-    uint8_t     guestId;
-    uint8_t     base;
-    uint16_t    num;
-}_PackedType t_FmPcdIpcResourceAllocParams;
-
 
 #define FM_PCD_MAX_REPLY_SIZE           16
 #define FM_PCD_MAX_MSG_SIZE             36
@@ -121,6 +115,12 @@ typedef _Packed struct t_FmPcdIpcReply {
     uint8_t     replyBody[FM_PCD_MAX_REPLY_BODY_SIZE];
 } _PackedType t_FmPcdIpcReply;
 
+typedef _Packed struct t_FmIpcResourceAllocParams {
+    uint8_t     guestId;
+    uint16_t    base;
+    uint16_t    num;
+}_PackedType t_FmIpcResourceAllocParams;
+
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -150,7 +150,7 @@ typedef _Packed struct t_FmPcdIpcReply {
 
  @Description   Used by FM PCD front-end in order to allocate Policer profiles
 
- @Param[in/out] t_FmPcdIpcKgSchemesParams Pointer
+ @Param[in/out] t_FmIpcResourceAllocParams Pointer
 *//***************************************************************************/
 #define FM_PCD_ALLOC_PROFILES                   5
 
@@ -159,18 +159,38 @@ typedef _Packed struct t_FmPcdIpcReply {
 
  @Description   Used by FM PCD front-end in order to Free Policer profiles
 
- @Param[in/out] t_FmPcdIpcPlcrAllocParams Pointer
+ @Param[in/out] t_FmIpcResourceAllocParams Pointer
 *//***************************************************************************/
 #define FM_PCD_FREE_PROFILES                    6
 
 /**************************************************************************//**
+ @Function      FM_PCD_SET_PORT_PROFILES
+
+ @Description   Used by FM PCD front-end in order to allocate Policer profiles
+                for specific port
+
+ @Param[in/out] t_FmIpcResourceAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_SET_PORT_PROFILES                7
+
+/**************************************************************************//**
+ @Function      FM_PCD_CLEAR_PORT_PROFILES
+
+ @Description   Used by FM PCD front-end in order to allocate Policer profiles
+                for specific port
+
+ @Param[in/out] t_FmIpcResourceAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_CLEAR_PORT_PROFILES              8
+
+/**************************************************************************//**
  @Function      FM_PCD_GET_PHYS_MURAM_BASE
 
  @Description   Used by FM PCD front-end in order to get MURAM base address
 
  @Param[in/out] t_FmPcdIcPhysAddr Pointer
 *//***************************************************************************/
-#define FM_PCD_GET_PHYS_MURAM_BASE              7
+#define FM_PCD_GET_PHYS_MURAM_BASE              9
 
 /**************************************************************************//**
  @Function      FM_PCD_GET_SW_PRS_OFFSET
@@ -180,7 +200,7 @@ typedef _Packed struct t_FmPcdIpcReply {
 
  @Param[in/out] t_FmPcdIpcSwPrsLable Pointer
 *//***************************************************************************/
-#define FM_PCD_GET_SW_PRS_OFFSET                8
+#define FM_PCD_GET_SW_PRS_OFFSET                10
 
 /**************************************************************************//**
  @Function      FM_PCD_MASTER_IS_ENABLED
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 265d4ee..c1e9862 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -526,108 +526,6 @@ cont_rfc:
     return E_OK;
 }
 
-static t_Error AllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
-{
-    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint32_t        profilesFound, log2Num, tmpReg32;
-    uint32_t        intFlags;
-    uint16_t        first, i;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    if (!numOfProfiles)
-        return E_OK;
-
-    ASSERT_COND(hardwarePortId);
-
-    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
-
-    if (!POWER_OF_2(numOfProfiles))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
-
-
-    if (GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
-
-    first = 0;
-    profilesFound = 0;
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-
-    for (i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
-    {
-        if (!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
-        {
-            profilesFound++;
-            i++;
-            if (profilesFound == numOfProfiles)
-                break;
-        }
-        else
-        {
-            profilesFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfProfiles);
-        }
-    }
-
-    if (profilesFound == numOfProfiles)
-    {
-        for (i=first; i<first + numOfProfiles; i++)
-        {
-            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
-            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
-        }
-    }
-    else
-    {
-        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
-    }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
-    /**********************FMPL_PMRx******************/
-    LOG2((uint64_t)numOfProfiles, log2Num);
-    tmpReg32 = first;
-    tmpReg32 |= log2Num << 16;
-    tmpReg32 |= FM_PCD_PLCR_PMR_V;
-    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
-
-    *p_Base = first;
-
-    return E_OK;
-}
-
-static t_Error FreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
-{
-    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint16_t        i;
-    uint32_t        intFlags;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
-    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
-
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-    for (i = base; i<base+numOfProfiles;i++)
-    {
-        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
-        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
-
-        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
-        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
-    }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
-    return E_OK;
-}
-
 static t_Error AllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
     uint32_t        profilesFound;
@@ -797,6 +695,7 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     t_Error                         err = E_OK;
     uint32_t                        tmpReg32 = 0;
+    uint16_t                        base;
 
     if ((p_FmPcdPlcr->partPlcrProfilesBase + p_FmPcdPlcr->partNumOfPlcrProfiles) > FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partPlcrProfilesBase+partNumOfPlcrProfiles out of range!!!"));
@@ -809,11 +708,18 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     if (!p_FmPcdPlcr->h_SwSpinlock)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer SW spinlock"));
 
+    base = PlcrAllocProfilesForPartition(p_FmPcd,
+                                         p_FmPcdPlcr->partPlcrProfilesBase,
+                                         p_FmPcdPlcr->partNumOfPlcrProfiles,
+                                         p_FmPcd->guestId);
+    if (base == (uint16_t)ILLEGAL_BASE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
     if (p_FmPcdPlcr->numOfSharedProfiles)
     {
         err = AllocSharedProfiles(p_FmPcd,
                                   p_FmPcdPlcr->numOfSharedProfiles,
-                                  p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+                                  p_FmPcdPlcr->sharedProfilesIds);
         if (err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
@@ -891,6 +797,12 @@ t_Error PlcrFree(t_FmPcd *p_FmPcd)
                            p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles,
                            p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
 
+    if (p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles)
+        PlcrFreeProfilesForPartition(p_FmPcd,
+                                     p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase,
+                                     p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles,
+                                     p_FmPcd->guestId);
+
     if (p_FmPcd->p_FmPcdPlcr->h_SwSpinlock)
         XX_FreeSpinlock(p_FmPcd->p_FmPcdPlcr->h_SwSpinlock);
 
@@ -914,25 +826,25 @@ void PlcrDisable(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
 }
 
-uint8_t PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId)
+uint16_t PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint16_t base, uint16_t numOfProfiles, uint8_t guestId)
 {
-    uint8_t     profilesFound = 0;
-    int         i = 0;
     uint32_t    intFlags;
+    uint16_t    profilesFound = 0;
+    int         i = 0;
 
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(p_FmPcd->p_FmPcdPlcr);
 
     if (!numOfProfiles)
-        return E_OK;
+        return 0;
 
     if ((numOfProfiles > FM_PCD_PLCR_NUM_ENTRIES) ||
         (base + numOfProfiles > FM_PCD_PLCR_NUM_ENTRIES))
-        return (uint8_t)ILLEGAL_BASE;
+        return (uint16_t)ILLEGAL_BASE;
 
     if (p_FmPcd->h_IpcSession)
     {
-        t_FmPcdIpcResourceAllocParams   ipcProfilesAllocParams;
+        t_FmIpcResourceAllocParams      ipcAllocParams;
         t_FmPcdIpcMsg                   msg;
         t_FmPcdIpcReply                 reply;
         t_Error                         err;
@@ -940,61 +852,61 @@ uint8_t PlcrAllocProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t n
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
-        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmPcdIpcResourceAllocParams));
-        ipcProfilesAllocParams.guestId         = p_FmPcd->guestId;
-        ipcProfilesAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
-        ipcProfilesAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
-        msg.msgId                              = FM_PCD_ALLOC_PROFILES;
-        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmPcdIpcResourceAllocParams));
-        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = p_FmPcd->guestId;
+        ipcAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
+        ipcAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
+        msg.msgId                      = FM_PCD_ALLOC_PROFILES;
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint16_t);
         err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
                                 (uint8_t*)&msg,
-                                sizeof(msg.msgId) + sizeof(t_FmPcdIpcResourceAllocParams),
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
                                 (uint8_t*)&reply,
                                 &replyLength,
                                 NULL,
                                 NULL);
         if ((err != E_OK) ||
-            (replyLength != (sizeof(uint32_t) + sizeof(uint8_t))))
+            (replyLength != (sizeof(uint32_t) + sizeof(uint16_t))))
         {
             REPORT_ERROR(MAJOR, err, NO_MSG);
-            return (uint8_t)ILLEGAL_BASE;
+            return (uint16_t)ILLEGAL_BASE;
         }
         else
-            memcpy((uint8_t*)&p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase, reply.replyBody, sizeof(uint8_t));
-        if (p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase == ILLEGAL_BASE)
+            memcpy((uint8_t*)&p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase, reply.replyBody, sizeof(uint16_t));
+        if (p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase == (uint16_t)ILLEGAL_BASE)
         {
             REPORT_ERROR(MAJOR, err, NO_MSG);
-            return (uint8_t)ILLEGAL_BASE;
+            return (uint16_t)ILLEGAL_BASE;
         }
     }
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
-        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
-        return (uint8_t)ILLEGAL_BASE;
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate Policer-profiles range!"));
+        return (uint16_t)ILLEGAL_BASE;
     }
 
     intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
-    for (i = base; i < base + numOfProfiles; i++)
+    for (i=base; i<(base+numOfProfiles); i++)
         if (p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
             profilesFound++;
         else
             break;
 
     if (profilesFound == numOfProfiles)
-        for (i = base; i<base + numOfProfiles; i++)
+        for (i=base; i<(base+numOfProfiles); i++)
             p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = guestId;
     else
     {
         XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
-        return (uint8_t)ILLEGAL_BASE;
+        return (uint16_t)ILLEGAL_BASE;
     }
     XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
 
     return base;
 }
 
-void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOfProfiles, uint8_t guestId)
+void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint16_t base, uint16_t numOfProfiles, uint8_t guestId)
 {
     int     i = 0;
 
@@ -1003,26 +915,22 @@ void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOf
 
     if (p_FmPcd->h_IpcSession)
     {
-        t_FmPcdIpcResourceAllocParams   ipcProfilesAllocParams;
+        t_FmIpcResourceAllocParams      ipcAllocParams;
         t_FmPcdIpcMsg                   msg;
-        t_FmPcdIpcReply                 reply;
         t_Error                         err;
-        uint32_t                        replyLength;
 
         memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmPcdIpcResourceAllocParams));
-        ipcProfilesAllocParams.guestId         = p_FmPcd->guestId;
-        ipcProfilesAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
-        ipcProfilesAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
-        msg.msgId                              = FM_PCD_FREE_PROFILES;
-        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmPcdIpcResourceAllocParams));
-        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = p_FmPcd->guestId;
+        ipcAllocParams.num             = p_FmPcd->p_FmPcdPlcr->partNumOfPlcrProfiles;
+        ipcAllocParams.base            = p_FmPcd->p_FmPcdPlcr->partPlcrProfilesBase;
+        msg.msgId                      = FM_PCD_FREE_PROFILES;
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
         err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
                                 (uint8_t*)&msg,
-                                sizeof(msg.msgId) + sizeof(t_FmPcdIpcResourceAllocParams),
-                                (uint8_t*)&reply,
-                                &replyLength,
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
+                                NULL,
+                                NULL,
                                 NULL,
                                 NULL);
         if (err != E_OK)
@@ -1031,11 +939,11 @@ void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOf
     }
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
-        DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+        DBG(WARNING, ("FM Guest mode, without IPC - can't validate Policer-profiles range!"));
         return;
     }
 
-    for (i=base; i<numOfProfiles; i++)
+    for (i=base; i<(base+numOfProfiles); i++)
     {
         if (p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == guestId)
            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
@@ -1044,6 +952,205 @@ void PlcrFreeProfilesForPartition(t_FmPcd *p_FmPcd, uint8_t base, uint16_t numOf
     }
 }
 
+t_Error PlcrSetPortProfiles(t_FmPcd    *p_FmPcd,
+                            uint8_t    hardwarePortId,
+                            uint16_t   numOfProfiles,
+                            uint16_t   base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        log2Num, tmpReg32;
+
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_Regs &&
+        p_FmPcd->h_IpcSession)
+    {
+        t_FmIpcResourceAllocParams      ipcAllocParams;
+        t_FmPcdIpcMsg                   msg;
+        t_Error                         err;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = hardwarePortId;
+        ipcAllocParams.num             = numOfProfiles;
+        ipcAllocParams.base            = base;
+        msg.msgId                              = FM_PCD_SET_PORT_PROFILES;
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        return E_OK;
+    }
+    else if (!p_Regs)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("Either IPC or 'baseAddress' is required!"));
+
+    if (GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("The requesting port has already an allocated profiles window."));
+
+    /**********************FMPL_PMRx******************/
+    LOG2((uint64_t)numOfProfiles, log2Num);
+    tmpReg32 = base;
+    tmpReg32 |= log2Num << 16;
+    tmpReg32 |= FM_PCD_PLCR_PMR_V;
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
+
+    return E_OK;
+}
+
+t_Error PlcrClearPortProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_Regs &&
+        p_FmPcd->h_IpcSession)
+    {
+        t_FmIpcResourceAllocParams      ipcAllocParams;
+        t_FmPcdIpcMsg                   msg;
+        t_Error                         err;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = hardwarePortId;
+        msg.msgId                              = FM_PCD_CLEAR_PORT_PROFILES;
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(t_FmIpcResourceAllocParams),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        return E_OK;
+    }
+    else if (!p_Regs)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("Either IPC or 'baseAddress' is required!"));
+
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
+
+    return E_OK;
+}
+
+t_Error FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                     err = E_OK;
+    uint32_t                    profilesFound;
+    uint32_t                    intFlags;
+    uint16_t                    i, first, swPortIndex = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if (!numOfProfiles)
+        return E_OK;
+
+    ASSERT_COND(hardwarePortId);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    if (!POWER_OF_2(numOfProfiles))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+
+    first = 0;
+    profilesFound = 0;
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+
+    for (i=0; i<FM_PCD_PLCR_NUM_ENTRIES; )
+    {
+        if (!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if (profilesFound == numOfProfiles)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            i = first = (uint16_t)(first + numOfProfiles);
+        }
+    }
+
+    if (profilesFound == numOfProfiles)
+    {
+        for (i=first; i<first + numOfProfiles; i++)
+        {
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
+        }
+    }
+    else
+    {
+        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    err = PlcrSetPortProfiles(p_FmPcd, hardwarePortId, numOfProfiles, first);
+    if (err)
+    {
+        /* TODO - rollback the allocated profiles! */
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = first;
+
+    return E_OK;
+}
+
+t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                     err = E_OK;
+    uint32_t                    intFlags;
+    uint16_t                    i, swPortIndex = 0;
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    err = PlcrClearPortProfiles(p_FmPcd, hardwarePortId);
+    if (err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+    for (i=p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
+         i<(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase +
+            p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles);
+         i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
+
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+    }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
+
+    return E_OK;
+}
+
 t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
 {
     t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
@@ -1186,53 +1293,6 @@ uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId
     return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
 }
 
-t_Error FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                     err = E_OK;
-    uint16_t                    base;
-    uint16_t                    swPortIndex = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    if (!numOfProfiles)
-        return E_OK;
-
-    err = AllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
-    if (err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
-
-    return E_OK;
-}
-
-t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                     err = E_OK;
-    uint16_t                    swPortIndex = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
-    err = FreeProfiles(p_FmPcd,
-                       hardwarePortId,
-                       p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles,
-                       p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
-    if (err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
-
-    return E_OK;
-}
-
 bool FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
@@ -1364,15 +1424,15 @@ uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
 {
     switch(counter)
     {
-        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+        case (e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
-        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+        case (e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
-        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PERPC;
-        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
-        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
        default:
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 5ccd8ea..5b401c6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -66,10 +66,10 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
 
-    DBG(TRACE, ("parser error - 0x%08x\n",event));
+    DBG(TRACE, ("parser error - 0x%08x\n", event));
 
     if(event & FM_PCD_PRS_DOUBLE_ECC)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+        p_FmPcd->f_Exception(p_FmPcd->h_App, e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
 }
 
 static void PcdPrsException(t_Handle h_FmPcd)
@@ -83,7 +83,7 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
 
-    DBG(TRACE, ("parser event - 0x%08x\n",event));
+    DBG(TRACE, ("parser event - 0x%08x\n", event));
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr);
@@ -92,10 +92,10 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
 
-    p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+    p_FmPcd->f_Exception(p_FmPcd->h_App, e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
 }
 
-t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
+t_Handle PrsConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdPrs  *p_FmPcdPrs;
     uintptr_t   baseAddr;
@@ -129,10 +129,11 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-    uint32_t            *p_TmpCode, tmpReg, i,
-                        *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
+    uint32_t            *p_TmpCode;
+    uint32_t            *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
                                                              FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
     uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
+    uint32_t            tmpReg, i;
 
     ASSERT_COND(sizeof(swPrsPatch) <= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
 
@@ -140,10 +141,10 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     if (p_FmPcd->guestId != NCSW_MASTER_ID)
         return E_OK;
 
-    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch),4), 0, sizeof(uint32_t));
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch), 4), 0, sizeof(uint32_t));
     if (!p_TmpCode)
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
-    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch),4));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch), 4));
     memcpy((uint8_t *)p_TmpCode, (uint8_t *)swPrsPatch, sizeof(swPrsPatch));
 
     /**********************RPCLIM******************/
@@ -189,7 +190,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /**********************PPSC******************/
 
     /* load sw parser Ip-Frag patch */
-    for (i=0; i<DIV_CEIL(sizeof(swPrsPatch),4); i++)
+    for (i = 0; i < DIV_CEIL(sizeof(swPrsPatch), 4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
 
     XX_FreeSmart(p_TmpCode);
@@ -226,7 +227,7 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     uint32_t    bitMask = 0;
     uint8_t     prsPortId;
 
-    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >= 1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
@@ -248,7 +249,7 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Error                     err;
 
-    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >= 1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
@@ -276,7 +277,7 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
     }
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in \"guest-mode\" without IPC!"));
+                     ("running in guest-mode without IPC!"));
 
     return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
 }
@@ -328,7 +329,7 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
 
     ASSERT_COND(p_FmPcd->p_FmPcdPrs->currLabel < FM_PCD_PRS_NUM_OF_LABELS);
 
-    for (i=0; i<p_FmPcd->p_FmPcdPrs->currLabel; i++)
+    for (i = 0; i < p_FmPcd->p_FmPcdPrs->currLabel; i++)
     {
         p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i];
 
@@ -389,10 +390,10 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     if (p_FmPcd->p_FmPcdPrs->currLabel + p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
 
-    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(p_SwPrs->size,4), 0, sizeof(uint32_t));
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(p_SwPrs->size, 4), 0, sizeof(uint32_t));
     if (!p_TmpCode)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
-    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(p_SwPrs->size,4));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(p_SwPrs->size, 4));
     memcpy((uint8_t *)p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
 
     /* save sw parser labels */
@@ -403,13 +404,13 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
+    for (i = 0; i < DIV_CEIL(p_SwPrs->size, 4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
     p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
-        p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
+        p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size, 4);
 
     /* copy data parameters */
-    for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
+    for (i = 0; i < FM_PCD_PRS_NUM_OF_HDRS; i++)
         WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
 
     /* Clear last 4 bytes */
@@ -420,7 +421,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     return E_OK;
 }
 
-t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd, uint16_t value)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index 99613c0..3dbc960 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -92,7 +92,7 @@
     0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00, \
     0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F,0x00,0x81, \
     0x1F,0xFF,0x00,0x01,0x1B,0xFE,                     \
-};
+}
 
 #else
 /* version: 106.3.8 */
@@ -145,7 +145,7 @@
     0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
     0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE, \
     0x00,0x01,0x1B,0xFE,                               \
-};
+}
 #endif /* (DPAA_VERSION == 10) */
 
 /****************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index f450fa1..3269080 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -162,7 +162,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if (p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+        if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
         if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
@@ -273,17 +273,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS))
+    if (p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
+    if (p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS))
+    if (p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
+    if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if (p_FmPort->explicitUserSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
+    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if (p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
+    if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
@@ -412,15 +412,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rmpd;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
             rxPort = FALSE;
@@ -432,14 +432,14 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
 
     /* build the register value */
-    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    for (i = 0; i < p_ExtBufPools->numOfPoolsUsed; i++)
     {
         tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
         tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
         tmpReg |= sizesArray[orderedArray[i]];
         /* functionality available only for some deriviatives (limited by config) */
         if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+            for (j = 0; j < p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools; j++)
                 if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
@@ -468,11 +468,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsider[i])
             {
-                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
                     {
@@ -491,11 +491,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
                      {
@@ -757,6 +757,13 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     {
         WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_QMI_DEQ);
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+#if (DPAA_VERSION >= 11)
+        WRITE_UINT32(p_Regs->fmbm_tfne,
+                     (!p_Params->dfltFqid ?
+                        BMI_EBD_EN | NIA_BMI_AC_FETCH_ALL_FRAME :
+                        NIA_BMI_AC_FETCH_ALL_FRAME));
+#endif /* (DPAA_VERSION >= 11) */
+
         /* The line bellow is a trick so the FM will not release the buffer
            to BM nor will try to enq the frame to QM */
         if (!p_Params->dfltFqid && p_Params->dontReleaseBuf)
@@ -767,6 +774,10 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
              */
             WRITE_UINT32(p_Regs->fmbm_tcfqid, 0xFFFFFF);
             WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+#if (DPAA_VERSION >= 11)
+        WRITE_UINT32(p_Regs->fmbm_tfne,
+                     (GET_UINT32(p_Regs->fmbm_tfne) & ~BMI_EBD_EN));
+#endif /* (DPAA_VERSION >= 11) */
         }
     }
 
@@ -972,15 +983,15 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         if (p_Params->deqHighPriority)
             tmpReg |= QMI_DEQ_CFG_PRI;
 
-        switch(p_Params->deqType)
+        switch (p_Params->deqType)
         {
-            case(e_FM_PORT_DEQ_TYPE1):
+            case (e_FM_PORT_DEQ_TYPE1):
                 tmpReg |= QMI_DEQ_CFG_TYPE1;
                 break;
-            case(e_FM_PORT_DEQ_TYPE2):
+            case (e_FM_PORT_DEQ_TYPE2):
                 tmpReg |= QMI_DEQ_CFG_TYPE2;
                 break;
-            case(e_FM_PORT_DEQ_TYPE3):
+            case (e_FM_PORT_DEQ_TYPE3):
                 tmpReg |= QMI_DEQ_CFG_TYPE3;
                 break;
             default:
@@ -990,15 +1001,15 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
         if (p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-        switch(p_Params->deqPrefetchOption)
+        switch (p_Params->deqPrefetchOption)
         {
-            case(e_FM_PORT_DEQ_NO_PREFETCH):
+            case (e_FM_PORT_DEQ_NO_PREFETCH):
                 /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
                 break;
-            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+            case (e_FM_PORT_DEQ_PARTIAL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
-            case(e_FM_PORT_DEQ_FULL_PREFETCH):
+            case (e_FM_PORT_DEQ_FULL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
             default:
@@ -1022,25 +1033,25 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
 
      /* check that counters are enabled */
-    switch(counter)
-    {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+    switch (counter)
+    {
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
@@ -1049,51 +1060,51 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
             *p_Ptr = &p_BmiRegs->fmbm_rccn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rtuc;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rrquc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rfuc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_Ptr = &p_BmiRegs->fmbm_rpac;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfcd;
             break;
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfbc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rlfc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rffc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_Ptr = &p_BmiRegs->fmbm_rfldec;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_rodc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_rbdc;
             break;
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_rpec;
             break;
         default:
@@ -1108,20 +1119,20 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
 
      /* check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
@@ -1130,36 +1141,36 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_tccn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ttuc;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tfuc;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfdc;
             break;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_tfledc;
             break;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_tbdc;
             break;
         default:
@@ -1174,26 +1185,26 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
 
     /* check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
             /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
             ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
             if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
@@ -1204,48 +1215,48 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_occn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_otuc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_oduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ofuc;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofdc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_offc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
             break;
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
            *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
             break;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_ofledc;
             break;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_obdc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_oodc;
             break;
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_opec;
             break;
         default:
@@ -1259,7 +1270,7 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
 {
     uint8_t                     hdrNum, Ipv4HdrNum;
     u_FmPcdHdrPrsOpts           *p_prsOpts;
-    uint32_t                    tmpReg = 0, tmpPrsOffset;
+    uint32_t                    tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
 
     if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
@@ -1271,9 +1282,9 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     if (p_HdrParams->usePrsOpts)
     {
         p_prsOpts = &p_HdrParams->prsOpts;
-        switch(p_HdrParams->hdr)
+        switch (p_HdrParams->hdr)
         {
-            case(HEADER_TYPE_MPLS):
+            case (HEADER_TYPE_MPLS):
                 if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
                 GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
@@ -1285,22 +1296,26 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
                         ("Header must be equal or higher than IPv4"));
                 tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
                     tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
                 break;
-            case(HEADER_TYPE_IPv6):
+            case (HEADER_TYPE_IPv6):
                 if (p_prsOpts->ipv6PrsOptions.routingHdrEnable)
                     tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_EN;
                 break;
-            case(HEADER_TYPE_TCP):
+            case (HEADER_TYPE_TCP):
                 if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                else
+                   tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
                 break;
-            case(HEADER_TYPE_UDP):
+            case (HEADER_TYPE_UDP):
                 if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
-                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
-                break;
+                   tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
+                else
+                   tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
+                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
         }
@@ -1382,58 +1397,58 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->pcdEngines = 0;
 
     /* initialize p_FmPort->pcdEngines field in port's structure */
-    switch(p_PcdParams->pcdSupport)
+    switch (p_PcdParams->pcdSupport)
     {
-        case(e_FM_PORT_PCD_SUPPORT_NONE):
+        case (e_FM_PORT_PCD_SUPPORT_NONE):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
-        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_CC_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
@@ -1455,17 +1470,17 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
@@ -1513,7 +1528,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
         /* for each scheme */
-        for(i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
             physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
@@ -1525,7 +1540,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
             if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
-#endif
+#endif /* (DPAA_VERSION >= 11) */
         }
 
         err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -1585,21 +1600,21 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
-        switch(p_PcdParams->pcdSupport)
+        switch (p_PcdParams->pcdSupport)
         {
-            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
                 WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
                 tmpReg = NIA_KG_CC_EN;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
                 if (p_PcdParams->p_KgParams->directScheme)
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
-                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                    for (i = 0 ; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
                         if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
                     if (i == p_PcdParams->p_KgParams->numOfSchemes)
@@ -1608,11 +1623,11 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
                 WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
@@ -1633,56 +1648,57 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
 
         /* set protocol options */
-        for(i=0;p_FmPort->optArray[i];i++)
-            switch(p_FmPort->optArray[i])
+        for (i = 0; p_FmPort->optArray[i]; i++)
+            switch (p_FmPort->optArray[i])
             {
-                case(ETH_BROADCAST):
+                case (ETH_BROADCAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
-                case(ETH_MULTICAST):
+                case (ETH_MULTICAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
-                case(VLAN_STACKED):
+                case (VLAN_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
                     tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
-                case(MPLS_STACKED):
+                case (MPLS_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
-                case(IPV4_BROADCAST_1):
+                case (IPV4_BROADCAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
-                case(IPV4_MULTICAST_1):
+                case (IPV4_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
-                case(IPV4_UNICAST_2):
+                case (IPV4_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
-                case(IPV4_MULTICAST_BROADCAST_2):
+                case (IPV4_MULTICAST_BROADCAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
-                case(IPV6_MULTICAST_1):
+                case (IPV6_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
-                case(IPV6_UNICAST_2):
+                case (IPV6_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
-                case(IPV6_MULTICAST_2):
+                case (IPV6_MULTICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
             }
 
-        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP))
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
+                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP))
         {
             p_PcdParams->p_PrsParams->additionalParams
                 [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr = HEADER_TYPE_UDP;
@@ -1695,14 +1711,21 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
         tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
         GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
-        tmpHxs[hdrNum] |= (uint32_t)L3HdrNum  << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+        tmpHxs[hdrNum] |= (uint32_t)L3HdrNum << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
 
         /* for GRE, disable errors */
         GET_PRS_HDR_NUM(greHdrNum, HEADER_TYPE_GRE);
         tmpHxs[greHdrNum] |= PRS_HDR_ERROR_DIS;
 
+        /* For UDP remove PAD from L4 checksum calculation */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_UDP);
+        tmpHxs[hdrNum] |= PRS_HDR_UDP_PAD_REMOVAL;
+        /* For TCP remove PAD from L4 checksum calculation */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_TCP);
+        tmpHxs[hdrNum] |= PRS_HDR_TCP_PAD_REMOVAL;
+
         /* config additional params for specific headers */
-        for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
+        for (i = 0; i < p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams; i++)
         {
             GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
             if (hdrNum== ILLEGAL_HDR_NUM)
@@ -1710,11 +1733,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             if (hdrNum==NO_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
 
-            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpReg);
+            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpHxs[hdrNum]);
             if (err)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-
-            tmpHxs[hdrNum] |= tmpReg;
         }
 
         /* Check if ip-reassembly port - need to update NIAs */
@@ -1812,14 +1833,14 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             break;
@@ -1883,13 +1904,13 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -1945,13 +1966,13 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -1963,16 +1984,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
 /*TODO - not atomic - it seems that port has to be disabled*/
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
                 break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_RX):
-            case(e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
                 break;
            default:
@@ -1982,14 +2003,14 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
                 break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
                 break;
             default:
@@ -2104,7 +2125,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     }
     else
     {
-        switch(gprFunc)
+        switch (gprFunc)
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
                 p_FmPort->p_MuramPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
@@ -2116,13 +2137,13 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
                 IOMemSet32(p_FmPort->p_MuramPage, 0, 256);
                 muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_MuramPage) -
                                              p_FmPort->fmMuramPhysBaseAddr);
-                switch(p_FmPort->portType)
+                switch (p_FmPort->portType)
                 {
-                    case(e_FM_PORT_TYPE_RX_10G):
-                    case(e_FM_PORT_TYPE_RX):
+                    case (e_FM_PORT_TYPE_RX_10G):
+                    case (e_FM_PORT_TYPE_RX):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
                         break;
-                    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
                         break;
                     default:
@@ -2135,7 +2156,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         p_FmPort->gprFunc = gprFunc;
     }
 
-    switch(p_FmPort->gprFunc)
+    switch (p_FmPort->gprFunc)
     {
         case (e_FM_PORT_GPR_MURAM_PAGE):
             *p_Value = p_FmPort->p_MuramPage;
@@ -2277,13 +2298,13 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
-         switch(p_FmPort->portType)
+         switch (p_FmPort->portType)
          {
-             case(e_FM_PORT_TYPE_RX_10G):
-             case(e_FM_PORT_TYPE_RX):
+             case (e_FM_PORT_TYPE_RX_10G):
+             case (e_FM_PORT_TYPE_RX):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
                  break;
-             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
                  break;
              default:
@@ -2317,6 +2338,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 {
     t_FmPort            *p_FmPort;
     uintptr_t           baseAddr = p_FmPortParams->baseAddr;
+    uint32_t            tmpReg;
 
     /* Allocate FM structure */
     p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
@@ -2351,9 +2373,13 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     /* calculate global portId number */
     SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
 
-
     /* Initialize FM port parameters for initialization phase only */
     p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    /* set memory map pointers */
+    p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(baseAddr + PRS_PORT_REGS_OFFSET);
+
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
@@ -2371,12 +2397,26 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
-    p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-    p_FmPort->fifoBufs.extra                                        = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-    p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
-    p_FmPort->openDmas.extra                                        = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-    p_FmPort->tasks.num                                             = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-    p_FmPort->tasks.extra                                           = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+    {
+        p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+        p_FmPort->fifoBufs.extra                                        = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
+        p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
+        p_FmPort->openDmas.extra                                        = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+        p_FmPort->tasks.num                                             = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+        p_FmPort->tasks.extra                                           = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+    }
+    else
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+    {
+        p_FmPort->fifoBufs.num                                          = 0;
+        p_FmPort->fifoBufs.extra                                        = 0;
+        p_FmPort->openDmas.num                                          = 0;
+        p_FmPort->openDmas.extra                                        = 0;
+        p_FmPort->tasks.num                                             = 0;
+        p_FmPort->tasks.extra                                           = 0;
+    }
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReqForHc;
@@ -2388,16 +2428,28 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-    case(e_FM_PORT_TYPE_RX):
-    case(e_FM_PORT_TYPE_RX_10G):
+    case (e_FM_PORT_TYPE_RX):
+    case (e_FM_PORT_TYPE_RX_10G):
         /* Initialize FM port parameters for initialization phase only */
         p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
         p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+    {
         p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
         p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
+    }
+    else
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+    {
+        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
+        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK) >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1) * BMI_FIFO_UNITS ;
+        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = (((tmpReg  & BMI_RX_FIFO_THRESHOLD_MASK) >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
+    }
+
         p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
         p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
@@ -2406,38 +2458,65 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 #endif /* (DPAA_VERSION >= 11) */
         break;
 
-    case(e_FM_PORT_TYPE_TX):
+    case (e_FM_PORT_TYPE_TX):
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
-        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
-        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
-        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_1G;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
-        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
-        break;
+    case (e_FM_PORT_TYPE_TX_10G):
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+        if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+        {
+            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
+            p_FmPort->fifoDeqPipelineDepth                              =
+                (uint8_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
+                          DEFAULT_PORT_fifoDeqPipelineDepth_1G :
+                          DEFAULT_PORT_fifoDeqPipelineDepth_10G);
+            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+        }
+        else
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+        {
+            tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
+            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
+                ((tmpReg & BMI_TX_FIFO_MIN_FILL_MASK) >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS ;
+            p_FmPort->fifoDeqPipelineDepth =
+                (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
+                (((tmpReg & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1) * BMI_FIFO_UNITS;
+        }
 
-    case(e_FM_PORT_TYPE_TX_10G):
-        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
-        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_10G;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_10G;
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_10G;
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              =
+            (bool)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
+                   DEFAULT_PORT_deqHighPriority_1G :
+                   DEFAULT_PORT_deqHighPriority_10G);
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   =
+            (uint16_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
+                       DEFAULT_PORT_deqByteCnt_1G :
+                       DEFAULT_PORT_deqByteCnt_10G);
         break;
 
-    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
 #if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
-        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+       p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+    else
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+    {
+        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
+        p_FmPort->fifoDeqPipelineDepth =
+            (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+    }
+
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
         if (p_FmPort->fmRevInfo.majorRev < 6)
             p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
@@ -2472,10 +2551,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
     else
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-        case(e_FM_PORT_TYPE_RX):
-        case(e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
             /* Initialize FM port parameters for initialization phase only */
             memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
                    &p_FmPortParams->specificParams.rxParams.extBufPools,
@@ -2484,10 +2563,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_TX):
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
                 (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
@@ -2561,13 +2640,8 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     p_Params = p_FmPort->p_FmPortDriverParam;
 
-    /* set memory map pointers */
-    p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(p_Params->baseAddr + QMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
-
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if  ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+         (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         if (!p_FmPort->imEn)
         {
             /* Call the external Buffer routine which also checks fifo
@@ -2588,15 +2662,19 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    err = VerifySizeOfFifo(p_FmPort);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (p_FmPort->fifoBufs.num)
+    {
+        err = VerifySizeOfFifo(p_FmPort);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
     fmParams.independentMode    = p_FmPort->imEn;
     fmParams.liodnOffset        = p_Params->liodnOffset;
     fmParams.liodnBase          = p_Params->liodnBase;
     fmParams.deqPipelineDepth   = p_FmPort->fifoDeqPipelineDepth;
+    fmParams.maxFrameLength     = p_FmPort->maxFrameLength;
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
     if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
@@ -2621,25 +2699,36 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
                    ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
+#ifndef FM_NO_GUARANTEED_RESET_VALUES
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
+    {
+        p_FmPort->tasks.num = fmParams.numOfTasks;
+        p_FmPort->tasks.extra = fmParams.numOfExtraTasks;
+        p_FmPort->openDmas.num = fmParams.numOfOpenDmas;
+        p_FmPort->openDmas.extra = fmParams.numOfExtraOpenDmas;
+        p_FmPort->fifoBufs.num = fmParams.sizeOfFifo;
+        p_FmPort->fifoBufs.extra = fmParams.extraSizeOfFifo;
+    }
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
     /**********************/
     /* Init BMI Registers */
     /**********************/
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             err = BmiRxPortInit(p_FmPort);
             if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             err = BmiTxPortInit(p_FmPort);
             if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             err = BmiOhPortInit(p_FmPort);
             if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2708,7 +2797,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     if (p_FmPort->p_MuramPage)
         FM_MURAM_FreeMem(p_FmPort->h_FmMuram, p_FmPort->p_MuramPage);
-#endif
+#endif /* (DPAA_VERSION >= 11) */
 
     if (p_FmPort->h_Spinlock)
         XX_FreeSpinlock(p_FmPort->h_Spinlock);
@@ -2730,6 +2819,7 @@ t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
+    p_FmPort->p_FmPortDriverParam->setNumOfOpenDmas = TRUE;
     memcpy(&p_FmPort->openDmas, p_OpenDmas, sizeof(t_FmPortRsrc));
 
     return E_OK;
@@ -2743,7 +2833,7 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     memcpy(&p_FmPort->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
-
+    p_FmPort->p_FmPortDriverParam->setNumOfTasks = TRUE;
     return E_OK;
 }
 
@@ -2754,7 +2844,7 @@ t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->explicitUserSizeOfFifo = TRUE;
+    p_FmPort->p_FmPortDriverParam->setSizeOfFifo = TRUE;
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
     return E_OK;
@@ -3192,7 +3282,7 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
     if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfOpenDmas->num, (uint8_t)p_NumOfOpenDmas->extra, FALSE);
+    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
     if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -3217,7 +3307,7 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
 
-    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfTasks->num, (uint8_t)p_NumOfTasks->extra, FALSE);
+    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
     if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -3250,7 +3340,6 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
-    p_FmPort->explicitUserSizeOfFifo = TRUE;
     /* we do not change user's parameter */
     err = VerifySizeOfFifo(p_FmPort);
     if (err)
@@ -3258,8 +3347,8 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
     err = FmSetSizeOfFifo(p_FmPort->h_Fm,
                           p_FmPort->hardwarePortId,
-                          p_SizeOfFifo->num,
-                          p_SizeOfFifo->extra,
+                          &p_SizeOfFifo->num,
+                          &p_SizeOfFifo->extra,
                           FALSE);
     if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
@@ -3340,21 +3429,21 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
              p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
             break;
@@ -3429,19 +3518,19 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             break;
         default:
@@ -3494,15 +3583,15 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             baseGran = 16000;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
             baseGran = 10000;
@@ -3542,17 +3631,17 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
         if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
-            switch(p_RateLimit->rateLimitDivider)
+            switch (p_RateLimit->rateLimitDivider)
             {
-                case(e_FM_PORT_DUAL_RATE_LIMITER_NONE):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_NONE):
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
                     break;
                 default:
@@ -3595,14 +3684,14 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
            break;
@@ -3644,18 +3733,18 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
             break;
         default:
@@ -3678,18 +3767,18 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
             break;
         default:
@@ -3716,26 +3805,26 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("performanceCnt.fifoCompVal has to be divisible by %d",
                       BMI_FIFO_UNITS));
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_RX_QUEUE_COMP));
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_TX_QUEUE_COMP));
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             if (p_FmPortPerformanceCnt->queueCompVal)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
             break;
@@ -3852,18 +3941,18 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
             break;
         default:
@@ -3887,14 +3976,14 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
             break;
@@ -3923,7 +4012,7 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
+    for (i = 0 ; i <  FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
     {
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
@@ -3951,11 +4040,11 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
             if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
@@ -3963,7 +4052,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 return 0;
             }
             bmiCounter = FALSE;
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -3973,26 +4062,26 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 
     if (bmiCounter)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
                 if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                 if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
                 if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
@@ -4016,15 +4105,15 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         }
 
         /* Set counter */
-        switch(counter)
+        switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
@@ -4042,15 +4131,15 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
             if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4060,20 +4149,20 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
 
     if (bmiCounter)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                  break;
@@ -4090,18 +4179,18 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
 
         /* Set counter */
-        switch(counter)
+        switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
                 break;
             default:
@@ -4128,7 +4217,7 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
         return 0;
     }
 
-    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
@@ -4164,7 +4253,7 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
 
-    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
@@ -4387,13 +4476,13 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
 
     tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             break;
         default:
@@ -4456,15 +4545,15 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             tmpReg = 0;
@@ -4518,13 +4607,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -4554,13 +4643,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
                 break;
             default:
@@ -4706,6 +4795,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             if (!p_FmPort->h_IpReassemblyTree)
             {
                 RELEASE_LOCK(p_FmPort->lock);
+                XX_Free(p_FmPcdCcTreeParams);
                 RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
             }
             if (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
@@ -4798,7 +4888,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 (p_FmPort->pcdEngines & FM_PCD_KG))
             {
                 int i;
-                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
                     /* The following function must be locked */
                     FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
                                           p_PcdParams->p_KgParams->h_Schemes[i],
@@ -5106,15 +5196,15 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
@@ -5205,9 +5295,9 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    switch(flag)
+    switch (flag)
     {
-        case(0):
+        case (0):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
@@ -5269,7 +5359,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
         break;
-    case(1):
+    case (1):
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
@@ -5331,7 +5421,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdcfg);
         break;
-    case(2):
+    case (2):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
@@ -5401,45 +5491,49 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+    /* un-necessary check of the indexes; probably will be needed in the future when there
+       will be more CGs available ....
+    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+    */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
-    if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
+    if ((p_FmPort->fmRevInfo.majorRev != 4) &&
+        (p_FmPort->fmRevInfo.majorRev < 6))
     {
         if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
     }
     else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
 
     opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
 
     /* to minimize memory access (groups may belong to the same regsiter, and may
-    be out of order), we first collect all information into a 256 booleans array,
-    representing each possible group. */
+       be out of order), we first collect all information into a 256 booleans array,
+       representing each possible group. */
 
     memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
     memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
 
-    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
 #if (DPAA_VERSION >= 11)
-        for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+        for (j = 0; j < FM_MAX_NUM_OF_PFC_PRIORITIES; j++)
             if (p_CongestionGrps->pfcPrioritiesEn[i][j])
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
 #endif /* (DPAA_VERSION >= 11) */
     }
 
-    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
         mod = (uint8_t)(i%32);
         /* each 32 congestion groups are represented by a register */
@@ -5482,9 +5576,12 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+    /* un-necessary check of the indexes; probably will be needed in the future when there
+       will be more CGs available ....
+    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+    */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
@@ -5496,10 +5593,10 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     }
     else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
 
     opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
 
@@ -5507,10 +5604,10 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     be out of order), we first collect all information into a 256 booleans array,
     representing each possible group. */
     memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
-    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
-    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
         mod = (uint8_t)(i%32);
         /* each 32 congestion groups are represented by a register */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 8fdcc68..55640a2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -442,6 +442,7 @@ typedef _Packed struct
 #define BMI_SP_ID_MASK                          0xff000000
 #define BMI_SP_ID_SHIFT                         24
 #define BMI_SP_EN                               0x01000000
+#define BMI_EBD_EN                              0x80000000
 #endif /* (DPAA_VERSION >= 11) */
 
 #define BMI_PORT_CFG_EN                         0x80000000
@@ -537,6 +538,12 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 #endif /* FM_DISABLE_SEC_ERRORS */
 
+#define BMI_RX_FIFO_PRI_ELEVATION_MASK          0x03FF0000
+#define BMI_RX_FIFO_THRESHOLD_MASK              0x000003FF
+#define BMI_TX_FIFO_MIN_FILL_MASK               0x03FF0000
+#define BMI_FIFO_PIPELINE_DEPTH_MASK            0x0000F000
+#define BMI_TX_LOW_COMF_MASK                    0x000003FF
+
 /* shifts */
 #define BMI_PORT_CFG_MS_SEL_SHIFT               16
 #define BMI_DMA_ATTR_SWP_SHIFT                  FM_SP_DMA_ATTR_SWP_SHIFT
@@ -802,6 +809,9 @@ typedef struct {
     t_FmBufferPrefixContent             bufferPrefixContent;
      t_FmBackupBmPools                   *p_BackupBmPools;
     bool                                dontReleaseBuf;
+    bool                                setNumOfTasks;
+    bool                                setNumOfOpenDmas;
+    bool                                setSizeOfFifo;
 #if (DPAA_VERSION >= 11)
     bool                                noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
@@ -870,7 +880,6 @@ typedef struct {
     t_FmPortRsrc                tasks;
     t_FmPortRsrc                fifoBufs;
     t_FmPortRxPoolsParams       rxPoolsParams;
-    bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
     t_Handle                    h_IpReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 92b2d0f..299227e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -637,9 +637,9 @@ static t_Error SetVSPWindow(t_Handle  h_Fm,
             RETURN_ERROR(MINOR, err, NO_MSG);
         return E_OK;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->p_FmBmiRegs)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
 
     tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1]);
     tmpReg |= (uint32_t)((uint32_t)baseStorageProfile & 0x3f) << 16;
@@ -665,7 +665,7 @@ static uint8_t AllocVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOf
 
     if (p_Fm->h_IpcSessions[0])
     {
-        t_FmIpcResourceAllocParams  ipcProfilesAllocParams;
+        t_FmIpcResourceAllocParams  ipcAllocParams;
         t_FmIpcMsg                  msg;
         t_FmIpcReply                reply;
         t_Error                     err;
@@ -673,12 +673,12 @@ static uint8_t AllocVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOf
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
-        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
-        ipcProfilesAllocParams.guestId         = p_Fm->guestId;
-        ipcProfilesAllocParams.num             = p_Fm->partNumOfVSPs;
-        ipcProfilesAllocParams.base            = p_Fm->partVSPBase;
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = p_Fm->guestId;
+        ipcAllocParams.num             = p_Fm->partNumOfVSPs;
+        ipcAllocParams.base            = p_Fm->partVSPBase;
         msg.msgId                              = FM_VSP_ALLOC;
-        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
         replyLength = sizeof(uint32_t) + sizeof(uint8_t);
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                 (uint8_t*)&msg,
@@ -730,7 +730,7 @@ static void FreeVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProf
 
     if (p_Fm->h_IpcSessions[0])
     {
-        t_FmIpcResourceAllocParams  ipcProfilesAllocParams;
+        t_FmIpcResourceAllocParams  ipcAllocParams;
         t_FmIpcMsg                  msg;
         t_FmIpcReply                reply;
         uint32_t                    replyLength;
@@ -738,12 +738,12 @@ static void FreeVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProf
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
-        memset(&ipcProfilesAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
-        ipcProfilesAllocParams.guestId         = p_Fm->guestId;
-        ipcProfilesAllocParams.num             = p_Fm->partNumOfVSPs;
-        ipcProfilesAllocParams.base            = p_Fm->partVSPBase;
+        memset(&ipcAllocParams, 0, sizeof(t_FmIpcResourceAllocParams));
+        ipcAllocParams.guestId         = p_Fm->guestId;
+        ipcAllocParams.num             = p_Fm->partNumOfVSPs;
+        ipcAllocParams.base            = p_Fm->partVSPBase;
         msg.msgId                              = FM_VSP_FREE;
-        memcpy(msg.msgBody, &ipcProfilesAllocParams, sizeof(t_FmIpcResourceAllocParams));
+        memcpy(msg.msgBody, &ipcAllocParams, sizeof(t_FmIpcResourceAllocParams));
         replyLength = sizeof(uint32_t) + sizeof(uint8_t);
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                 (uint8_t*)&msg,
@@ -844,7 +844,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         {
             t_FmIpcPortInInitParams         ipcInitParams;
             t_FmInterModulePortInitParams   initParams;
-            t_FmIpcPhysAddr                 ipcPhysAddr;
+            t_FmIpcPortOutInitParams        ipcOutInitParams;
 
             memcpy((uint8_t*)&ipcInitParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortInInitParams));
             initParams.hardwarePortId = ipcInitParams.hardwarePortId;
@@ -858,12 +858,20 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             initParams.sizeOfFifo = ipcInitParams.sizeOfFifo;
             initParams.extraSizeOfFifo = ipcInitParams.extraSizeOfFifo;
             initParams.deqPipelineDepth = ipcInitParams.deqPipelineDepth;
+            initParams.maxFrameLength = ipcInitParams.maxFrameLength;
             initParams.liodnBase = ipcInitParams.liodnBase;
 
             p_IpcReply->error = (uint32_t)FmGetSetPortParams(h_Fm, &initParams);
-            ipcPhysAddr.high = initParams.fmMuramPhysBaseAddr.high;
-            ipcPhysAddr.low = initParams.fmMuramPhysBaseAddr.low;
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcPhysAddr, sizeof(t_FmIpcPhysAddr));
+
+            ipcOutInitParams.ipcPhysAddr.high = initParams.fmMuramPhysBaseAddr.high;
+            ipcOutInitParams.ipcPhysAddr.low = initParams.fmMuramPhysBaseAddr.low;
+            ipcOutInitParams.sizeOfFifo = initParams.sizeOfFifo;
+            ipcOutInitParams.extraSizeOfFifo = initParams.extraSizeOfFifo;
+            ipcOutInitParams.numOfTasks = initParams.numOfTasks;
+            ipcOutInitParams.numOfExtraTasks = initParams.numOfExtraTasks;
+            ipcOutInitParams.numOfOpenDmas = initParams.numOfOpenDmas;
+            ipcOutInitParams.numOfExtraOpenDmas = initParams.numOfExtraOpenDmas;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcOutInitParams, sizeof(ipcOutInitParams));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcPhysAddr);
             break;
         }
@@ -874,8 +882,8 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
             p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm,
                                                           ipcPortRsrcParams.hardwarePortId,
-                                                          ipcPortRsrcParams.val,
-                                                          ipcPortRsrcParams.extra,
+                                                          &ipcPortRsrcParams.val,
+                                                          &ipcPortRsrcParams.extra,
                                                           (bool)ipcPortRsrcParams.boolInitialConfig);
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
@@ -886,8 +894,8 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 
             memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
             p_IpcReply->error = (uint32_t)FmSetNumOfTasks(h_Fm, ipcPortRsrcParams.hardwarePortId,
-                                                          (uint8_t)ipcPortRsrcParams.val,
-                                                          (uint8_t)ipcPortRsrcParams.extra,
+                                                          (uint8_t*)&ipcPortRsrcParams.val,
+                                                          (uint8_t*)&ipcPortRsrcParams.extra,
                                                           (bool)ipcPortRsrcParams.boolInitialConfig);
             *p_ReplyLength = sizeof(uint32_t);
             break;
@@ -898,8 +906,8 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 
             memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
             p_IpcReply->error = (uint32_t)FmSetNumOfOpenDmas(h_Fm, ipcPortRsrcParams.hardwarePortId,
-                                                               (uint8_t)ipcPortRsrcParams.val,
-                                                               (uint8_t)ipcPortRsrcParams.extra,
+                                                               (uint8_t*)&ipcPortRsrcParams.val,
+                                                               (uint8_t*)&ipcPortRsrcParams.extra,
                                                                (bool)ipcPortRsrcParams.boolInitialConfig);
             *p_ReplyLength = sizeof(uint32_t);
             break;
@@ -958,19 +966,19 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 #if (DPAA_VERSION >= 11)
         case (FM_VSP_ALLOC) :
         {
-            t_FmIpcResourceAllocParams  ipcVspAllocParams;
+            t_FmIpcResourceAllocParams  ipcAllocParams;
             uint8_t                     vspBase;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            vspBase =  AllocVSPsForPartition(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.num, ipcVspAllocParams.guestId);
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            vspBase =  AllocVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
             memcpy(p_IpcReply->replyBody, (uint8_t*)&vspBase, sizeof(uint8_t));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         }
         case (FM_VSP_FREE) :
         {
-            t_FmIpcResourceAllocParams   ipcVspAllocParams;
-            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            FreeVSPsForPartition(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.num, ipcVspAllocParams.guestId);
+            t_FmIpcResourceAllocParams   ipcAllocParams;
+            memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
+            FreeVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
             break;
         }
         case (FM_VSP_SET_PORT_WINDOW) :
@@ -1714,10 +1722,10 @@ void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, uint32_t enableEvents)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->p_FmFpmRegs)
     {
         REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
         return;
     }
 
@@ -1763,10 +1771,10 @@ uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
         memcpy((uint8_t*)&ctrlIntr, reply.replyBody, sizeof(uint32_t));
         return ctrlIntr;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->p_FmFpmRegs)
     {
         REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
         return 0;
     }
 
@@ -1942,9 +1950,9 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle     h_Fm,
             RETURN_ERROR(MINOR, err, NO_MSG);
         return E_OK;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->p_FmFpmRegs)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
 
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
 
@@ -1965,15 +1973,15 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_Error                 err;
     uint32_t                tmpReg, intFlags;
-    uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t                 hardwarePortId = p_PortParams->hardwarePortId, macId;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-        t_FmIpcPortInInitParams portInParams;
-        t_FmIpcPhysAddr         ipcPhysAddr;
-        t_FmIpcMsg              msg;
-        t_FmIpcReply            reply;
-        uint32_t                replyLength;
+        t_FmIpcPortInInitParams     portInParams;
+        t_FmIpcPortOutInitParams    portOutParams;
+        t_FmIpcMsg                  msg;
+        t_FmIpcReply                reply;
+        uint32_t                    replyLength;
 
         portInParams.hardwarePortId     = p_PortParams->hardwarePortId;
         portInParams.enumPortType       = (uint32_t)p_PortParams->portType;
@@ -1986,13 +1994,14 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         portInParams.sizeOfFifo         = p_PortParams->sizeOfFifo;
         portInParams.extraSizeOfFifo    = p_PortParams->extraSizeOfFifo;
         portInParams.deqPipelineDepth   = p_PortParams->deqPipelineDepth;
+        portInParams.maxFrameLength     = p_PortParams->maxFrameLength;
         portInParams.liodnBase          = p_PortParams->liodnBase;
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_SET_PORT_PARAMS;
         memcpy(msg.msgBody, &portInParams, sizeof(portInParams));
-        replyLength = (sizeof(uint32_t) + sizeof(p_PortParams->fmMuramPhysBaseAddr));
+        replyLength = (sizeof(uint32_t) + sizeof(t_FmIpcPortOutInitParams));
         if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId) +sizeof(portInParams),
@@ -2003,9 +2012,16 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             RETURN_ERROR(MINOR, err, NO_MSG);
         if (replyLength != (sizeof(uint32_t) + sizeof(p_PortParams->fmMuramPhysBaseAddr)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        memcpy((uint8_t*)&ipcPhysAddr, reply.replyBody, sizeof(t_FmIpcPhysAddr));
-        p_PortParams->fmMuramPhysBaseAddr.high = ipcPhysAddr.high;
-        p_PortParams->fmMuramPhysBaseAddr.low  = ipcPhysAddr.low;
+        memcpy((uint8_t*)&portOutParams, reply.replyBody, sizeof(t_FmIpcPortOutInitParams));
+
+        p_PortParams->fmMuramPhysBaseAddr.high = portOutParams.ipcPhysAddr.high;
+        p_PortParams->fmMuramPhysBaseAddr.low  = portOutParams.ipcPhysAddr.low;
+        p_PortParams->numOfTasks = portOutParams.numOfTasks;
+        p_PortParams->numOfExtraTasks = portOutParams.numOfExtraTasks;
+        p_PortParams->numOfOpenDmas = portOutParams.numOfOpenDmas;
+        p_PortParams->numOfExtraOpenDmas = portOutParams.numOfExtraOpenDmas;
+        p_PortParams->sizeOfFifo = portOutParams.sizeOfFifo;
+        p_PortParams->extraSizeOfFifo = portOutParams.extraSizeOfFifo;
 
         return (t_Error)(reply.error);
     }
@@ -2033,7 +2049,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
-    err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
+    err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
     if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -2093,8 +2109,8 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     err = FmSetSizeOfFifo(p_Fm,
                           p_PortParams->hardwarePortId,
-                          p_PortParams->sizeOfFifo,
-                          p_PortParams->extraSizeOfFifo,
+                          &p_PortParams->sizeOfFifo,
+                          &p_PortParams->extraSizeOfFifo,
                           TRUE);
     if (err)
     {
@@ -2104,8 +2120,8 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     err = FmSetNumOfOpenDmas(p_Fm,
                              p_PortParams->hardwarePortId,
-                             p_PortParams->numOfOpenDmas,
-                             p_PortParams->numOfExtraOpenDmas,
+                             &p_PortParams->numOfOpenDmas,
+                             &p_PortParams->numOfExtraOpenDmas,
                              TRUE);
     if (err)
     {
@@ -2152,6 +2168,28 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
 
+    HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
+
+#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if (p_PortParams->maxFrameLength >= p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId])
+            p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] = p_PortParams->maxFrameLength;
+        else
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Port maxFrameLength is smaller than MAC current MTU"));
+    }
+    else
+#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+    if ((p_PortParams->portType == e_FM_PORT_TYPE_TX) ||
+        (p_PortParams->portType == e_FM_PORT_TYPE_RX))
+    {
+        if (p_PortParams->maxFrameLength >= p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId])
+            p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] = p_PortParams->maxFrameLength;
+        else
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Port maxFrameLength is smaller than MAC current MTU"));
+    }
+
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
@@ -2163,7 +2201,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
-    uint8_t                 numOfTasks;
+    uint8_t                 numOfTasks, macId;
     t_Error                 err;
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
@@ -2263,6 +2301,18 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
 
+    HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
+
+#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
+        p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] = 0;
+    else
+#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+    if ((p_PortParams->portType == e_FM_PORT_TYPE_TX) ||
+        (p_PortParams->portType == e_FM_PORT_TYPE_RX))
+        p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] = 0;
+
 #ifdef FM_LOW_END_RESTRICTION
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
         p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
@@ -2304,9 +2354,9 @@ t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled
 
         return (t_Error)(reply.error);
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->baseAddr)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
 
     tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
     *p_IsStalled = (bool)!!(tmpReg & FPM_PS_STALLED);
@@ -2347,9 +2397,9 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->baseAddr)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+                     ("Either IPC or 'baseAddress' is required!"));
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Not available for this FM revision!"));
@@ -2370,11 +2420,12 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
 t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    uint32_t            bitMask, timeout = 1000;
+    uint32_t            bitMask;
 
-#if (DPAA_VERSION >= 11)
-    return E_OK;
-#endif /*(DPAA_VERSION >= 11)*/
+#ifndef FM_MAC_RESET
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        return E_OK;
+#endif /* FM_MAC_RESET */
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
@@ -2406,9 +2457,9 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+    else if (!p_Fm->baseAddr)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("Either IPC or 'baseAddress' is required!"));
 
     /* Get the relevant bit mask */
     if (type == e_FM_MAC_10G)
@@ -2448,10 +2499,7 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 
     /* reset */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, bitMask);
-    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fm_rstc) & bitMask) &&
-           --timeout) ;
-    if (!timeout)
-        return ERROR_CODE(E_TIMEOUT);
+
     return E_OK;
 }
 
@@ -2487,14 +2535,29 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without IPC!"));
 
+    /* if port is already initialized, check that MaxFrameLength is smaller
+     * or equal to the port's max */
 #if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
     if (type == e_FM_MAC_10G)
-        p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId] = mtu;
+    {
+        if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])
+           || (p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] &&
+              (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])))
+               p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId] = mtu;
+        else
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("MAC maxFrameLength is larger than Port maxFrameLength"));
+
+    }
     else
 #else
     UNUSED(type);
 #endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+    if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])
+       || (p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] &&
+          (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])))
         p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId] = mtu;
+    else
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("MAC maxFrameLength is larger than Port maxFrameLength"));
 
     return E_OK;
 }
@@ -2597,16 +2660,17 @@ bool FmIsMaster(t_Handle h_Fm)
     return (p_Fm->guestId == NCSW_MASTER_ID);
 }
 
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
 t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
-                        uint32_t    sizeOfFifo,
-                        uint32_t    extraSizeOfFifo,
+                        uint32_t    *p_SizeOfFifo,
+                        uint32_t    *p_ExtraSizeOfFifo,
                         bool        initialConfig)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
-    uint32_t                tmpReg = 0;
+    uint32_t                tmpReg = 0, sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
     uint16_t                oldVal = 0;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
@@ -2682,7 +2746,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
     else
     {
-        /* update acummulated */
+        /* update accumulated */
         ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= oldVal);
         p_Fm->p_FmStateStruct->accumulatedFifoSize -= oldVal;
         p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
@@ -2694,17 +2758,167 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
 
     return E_OK;
 }
+#else /*FM_NO_GUARANTEED_RESET_VALUES*/
+t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
+                        uint8_t     hardwarePortId,
+                        uint32_t    *p_SizeOfFifo,
+                        uint32_t    *p_ExtraSizeOfFifo,
+                        bool        initialConfig)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_FmIpcPortRsrcParams   rsrcParams;
+    t_Error                 err;
+    uint32_t                tmpReg = 0, sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
+    uint16_t                currentVal, currentExtraVal;
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+    /* it's illegal to be in a state where this is not the first set and no value is specified */
+    ASSERT_COND(initialConfig || sizeOfFifo);
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = sizeOfFifo;
+        rsrcParams.extra = extraSizeOfFifo;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
 
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_SIZE_OF_FIFO;
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr)
+    {
+        DBG(WARNING, ("No Ipc - can't validate FM total-fifo size."));
+
+        if (sizeOfFifo)
+        {
+            /* whether it is the first time with explicit value, or runtime "set" - write register */
+            tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
+                                ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+        }
+        else /* first config without explicit value: Do Nothing - reset value shouldn't be
+                changed, read register for port save */
+        {
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+            /* read into oldVal the current extra fifo size */
+            *p_ExtraSizeOfFifo = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
+            *p_SizeOfFifo = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
+        }
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+
+    if (!initialConfig || !sizeOfFifo)
+    {
+        /* !initialConfig - runtime change of existing value.
+         * !numOfTasks - first configuration according to values in regs.
+         * In both cases: read the current FIFO size */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+        /* read into oldVal the current extra fifo size */
+        currentExtraVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
+        currentVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
+    }
+    else /* first time and sizeOfFifo explicitly specified */
+        currentVal = currentExtraVal = 0;
+
+    if (!sizeOfFifo)
+    {
+        /* This is the first configuration and user did not specify value (!numOfTasks),
+         * reset values will be used and we just save these values for resource management */
+        if (currentExtraVal)
+        {
+            if (!p_Fm->p_FmStateStruct->extraFifoPoolSize)
+                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
+                 * must be initialized to 1 buffer per port
+                 */
+                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+
+            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
+        }
+        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize + currentVal) >
+            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Total port's fifo size and extra size exceed total available FIFO size."));
+
+        p_Fm->p_FmStateStruct->accumulatedFifoSize += currentVal;
+
+        *p_SizeOfFifo = currentVal;
+        *p_ExtraSizeOfFifo = currentExtraVal;
+
+    }
+    else
+    {
+        /* user requires a specific value.
+         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
+         * otherwise they hold the value written in the register.
+         */
+        if (extraSizeOfFifo > currentExtraVal)
+        {
+            if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
+                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
+                 * must be initialized to 1 buffer per port
+                 */
+                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+
+            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
+        }
+
+        /* check that there are enough uncommitted fifo size */
+        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - currentVal + sizeOfFifo) >
+            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
+        else
+        {
+            /* update accumulated */
+            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
+            p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
+            p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
+            /* calculate reg */
+            tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
+                                ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+        }
+        *p_SizeOfFifo = sizeOfFifo;
+        *p_ExtraSizeOfFifo = extraSizeOfFifo;
+
+    }
+
+    return E_OK;
+}
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
 t_Error FmSetNumOfTasks(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
-                        uint8_t     numOfTasks,
-                        uint8_t     numOfExtraTasks,
+                        uint8_t     *p_NumOfTasks,
+                        uint8_t     *p_NumOfExtraTasks,
                         bool        initialConfig)
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
     t_Error                 err;
     uint32_t                tmpReg = 0;
-    uint8_t                 oldVal = 0;
+    uint8_t                 oldVal = 0, numOfTasks = *p_NumOfTasks, numOfExtraTasks = *p_NumOfExtraTasks;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
@@ -2790,16 +3004,152 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
 
     return E_OK;
 }
+#else /*FM_NO_GUARANTEED_RESET_VALUES*/
+t_Error FmSetNumOfTasks(t_Handle    h_Fm,
+                        uint8_t     hardwarePortId,
+                        uint8_t     *p_NumOfTasks,
+                        uint8_t     *p_NumOfExtraTasks,
+                        bool        initialConfig)
+{
+    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
+    t_Error                 err;
+    uint32_t                tmpReg = 0;
+    uint8_t                 currentVal, currentExtraVal,numOfTasks = *p_NumOfTasks, numOfExtraTasks = *p_NumOfExtraTasks;
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+    /* it's illegal to be in a state where this is not the first set and no value is specified */
+    ASSERT_COND(initialConfig || numOfTasks);
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcPortRsrcParams   rsrcParams;
+        t_FmIpcMsg              msg;
+        t_FmIpcReply            reply;
+        uint32_t                replyLength;
 
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = numOfTasks;
+        rsrcParams.extra = numOfExtraTasks;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_NUM_OF_TASKS;
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr)
+    {
+        DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
+
+        if (numOfTasks)
+        {
+            /* whether it is the first time with explicit value, or runtime "set" - write register */
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
+            tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                        (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+        }
+        else /* first config without explicit value: Do Nothing - reset value shouldn't be
+                 changed, read register for port save */
+         {
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+            *p_NumOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+            *p_NumOfExtraTasks = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
+         }
+
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+
+    if (!initialConfig || !numOfTasks)
+    {
+        /* !initialConfig - runtime change of existing value.
+         * !numOfTasks - first configuration according to values in regs.
+         * In both cases: read the current number of tasks */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+        currentVal = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+        currentExtraVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
+    }
+    else /* first time and numOfTasks explicitly specified */
+        currentVal = currentExtraVal = 0;
+
+    if (!numOfTasks)
+    {
+        /* This is the first configuration and user did not specify value (!numOfTasks),
+         * reset values will be used and we just save these values for resource management */
+         p_Fm->p_FmStateStruct->extraTasksPoolSize =
+                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
+         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
+                 (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                                      ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
+                                       p_Fm->p_FmStateStruct->fmId));
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += currentVal;
+        *p_NumOfTasks = currentVal;
+        *p_NumOfExtraTasks = currentExtraVal;
+    }
+    else
+    {
+        /* user requires a specific value.
+         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
+         * otherwise they hold the value written in the register.
+         */
+        if (numOfExtraTasks > currentExtraVal)
+             p_Fm->p_FmStateStruct->extraTasksPoolSize =
+                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+
+        /* check that there are enough uncommitted tasks */
+        if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
+           (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                         ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
+                          p_Fm->p_FmStateStruct->fmId));
+        else
+        {
+            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
+            /* update acummulated */
+            p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
+            p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
+            /* calculate reg */
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
+            tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                        (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+        }
+        *p_NumOfTasks = numOfTasks;
+        *p_NumOfExtraTasks = numOfExtraTasks;
+    }
+
+    return E_OK;
+}
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
 t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
                             uint8_t hardwarePortId,
-                            uint8_t numOfOpenDmas,
-                            uint8_t numOfExtraOpenDmas,
+                            uint8_t *p_NumOfOpenDmas,
+                            uint8_t *p_NumOfExtraOpenDmas,
                             bool    initialConfig)
 
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint8_t                 oldVal = 0;
+    uint8_t                 oldVal = 0, numOfOpenDmas = *p_NumOfOpenDmas, numOfExtraOpenDmas = *p_NumOfExtraOpenDmas;
     uint32_t                tmpReg = 0;
     t_Error                 err;
 
@@ -2912,8 +3262,171 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 #endif /* FM_HAS_TOTAL_DMAS */
     }
 
+
+    return E_OK;
+}
+#else /* FM_NO_GUARANTEED_RESET_VALUES */
+t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
+                            uint8_t hardwarePortId,
+                            uint8_t *p_NumOfOpenDmas,
+                            uint8_t *p_NumOfExtraOpenDmas,
+                            bool    initialConfig)
+
+{
+    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
+    uint32_t                tmpReg = 0;
+    t_Error                 err;
+    uint8_t                 currentVal, currentExtraVal, numOfOpenDmas = *p_NumOfOpenDmas, numOfExtraOpenDmas = *p_NumOfExtraOpenDmas;
+
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
+    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+        !p_Fm->baseAddr &&
+        p_Fm->h_IpcSessions[0])
+    {
+        t_FmIpcPortRsrcParams   rsrcParams;
+        t_FmIpcMsg              msg;
+        t_FmIpcReply            reply;
+        uint32_t                replyLength;
+
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = numOfOpenDmas;
+        rsrcParams.extra = numOfExtraOpenDmas;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_NUM_OF_OPEN_DMAS;
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+#ifdef FM_HAS_TOTAL_DMAS
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
+#else
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
+             p_Fm->baseAddr &&
+             (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
+    {
+        /*DBG(WARNING, ("No Ipc - can't validate FM total-num-of-dmas."));*/
+
+        if (numOfOpenDmas)
+        {
+            /* whether it is the first time with explicit value, or runtime "set" - write register */
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
+            tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                        (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
+        }
+        else /* first config without explicit value: Do Nothing - reset value shouldn't be
+                changed, read register for port save */
+        {
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+            /* read into oldVal the current extra tasks */
+            *p_NumOfOpenDmas = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
+            *p_NumOfExtraOpenDmas = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+        }
+    }
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without neither IPC nor mapped register!"));
+#endif /* FM_HAS_TOTAL_DMAS */
+
+    /* it's illegal to be in a state where this is not the first set and no value is specified */
+    ASSERT_COND(initialConfig || numOfOpenDmas);
+
+    if (!initialConfig || !numOfOpenDmas)
+    {
+        /* !initialConfig - runtime change of existing value.
+         * !numOfTasks - first configuration according to values in regs.
+         * In both cases: read the current number of open Dma's */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+        /* read into oldVal the current extra tasks */
+        currentExtraVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
+        currentVal = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+    }
+    else /* first time and numOfTasks explicitly specified */
+        currentVal = currentExtraVal = 0;
+
+    if (!numOfOpenDmas)
+    {
+        /* This is the first configuration and user did not specify value (!numOfOpenDmas),
+         * reset values will be used and we just save these values for resource management */
+        p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
+                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, currentExtraVal);
+        p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += currentVal;
+        *p_NumOfOpenDmas = currentVal;
+        *p_NumOfExtraOpenDmas = currentExtraVal;
+    }
+    else
+    {
+        /* user requires a specific value.
+         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
+         * otherwise they hold the value written in the register.
+         */
+        if (numOfExtraOpenDmas > currentExtraVal)
+             p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
+                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
+
+
+        /* read into oldVal the current num of tasks */
+#ifdef FM_HAS_TOTAL_DMAS
+        if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
+            (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - currentVal + numOfOpenDmas >
+                p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                             ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
+                             p_Fm->p_FmStateStruct->fmId));
+#else
+        if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
+            (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - currentVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ + 1))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                         ("Requested numOfOpenDmas for fm%d exceeds DMA Command queue (%d)",
+                          p_Fm->p_FmStateStruct->fmId, DMA_THRESH_MAX_COMMQ+1));
+#endif /* FM_HAS_TOTAL_DMAS */
+        else
+        {
+            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= currentVal);
+            /* update acummulated */
+            p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= currentVal;
+            p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += numOfOpenDmas;
+
+            /* calculate reg */
+            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
+            tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                        (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
+#ifdef FM_HAS_TOTAL_DMAS
+            if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+            {
+                /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+                tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+            }
+#endif /* FM_HAS_TOTAL_DMAS */
+
+        }
+        *p_NumOfOpenDmas = numOfOpenDmas;
+        *p_NumOfExtraOpenDmas = numOfExtraOpenDmas;
+    }
+
+
     return E_OK;
 }
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
 
 #if (DPAA_VERSION >= 11)
 t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
@@ -3425,6 +3938,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     t_Fm                *p_Fm;
     uint8_t             i;
     uintptr_t           baseAddr;
+    uint32_t            tmpReg;
 
     SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
     SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
@@ -3501,20 +4015,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->errIrq               = p_FmParam->errIrq;
     p_Fm->hcPortInitialized                     = FALSE;
     p_Fm->independentMode                       = FALSE;
-    p_Fm->p_FmStateStruct->ramsEccEnable        = FALSE;
-    p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
-    p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
-    p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
-    p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
-    /* Chip dependent, will be configured in Init */
-    p_Fm->p_FmStateStruct->totalFifoSize        = 0;
-
-    for(i = 0;i<FM_MAX_NUM_OF_1G_MACS;i++)
-        p_Fm->p_FmStateStruct->macMaxFrameLengths1G[i] = DEFAULT_mtu;
-#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
-    for(i = 0;i<FM_MAX_NUM_OF_10G_MACS;i++)
-        p_Fm->p_FmStateStruct->macMaxFrameLengths10G[i] = DEFAULT_mtu;
-#endif /*defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)*/
 
     p_Fm->h_Spinlock = XX_InitSpinlock();
     if (!p_Fm->h_Spinlock)
@@ -3526,8 +4026,18 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         return NULL;
     }
 
+#if (DPAA_VERSION >= 11)
+    p_Fm->partVSPBase   = p_FmParam->partVSPBase;
+    p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
+    p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
+#endif /* (DPAA_VERSION >= 11) */
+
+
+
+    p_Fm->p_FmStateStruct->ramsEccEnable        = FALSE;
+    p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
+    p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
     /*p_Fm->p_FmDriverParam->numOfPartitions                    = p_FmParam->numOfPartitions;    */
-    p_Fm->p_FmDriverParam->enCounters                           = FALSE;
     p_Fm->p_FmDriverParam->tnumAgingPeriod                      = 0;
     p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
 
@@ -3550,8 +4060,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
     p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
 
-    p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
-    p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
     p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
     p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
     p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
@@ -3587,11 +4095,39 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
 
-#if (DPAA_VERSION >= 11)
-    p_Fm->partVSPBase   = p_FmParam->partVSPBase;
-    p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
-    p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
-#endif /* (DPAA_VERSION >= 11) */
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+        return p_Fm;
+
+    /* read revision register 1 */
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+    p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+    p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+    /* Chip dependent, will be configured in Init */
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    {
+        p_Fm->p_FmStateStruct->totalFifoSize        = 0;
+        p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
+        p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
+        p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
+        p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
+    }
+    else
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1);
+        p_Fm->p_FmStateStruct->totalFifoSize =
+            (((tmpReg & BMI_TOTAL_FIFO_SIZE_MASK) >> BMI_CFG1_FIFO_SIZE_SHIFT) + 1) * BMI_FIFO_UNITS;
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2);
+        p_Fm->p_FmStateStruct->totalNumOfTasks =
+            (uint8_t)(((tmpReg & BMI_TOTAL_NUM_OF_TASKS_MASK) >> BMI_CFG2_TASKS_SHIFT) + 1);
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
+        p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency =
+            (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmhy);
+        p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency =
+            (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
+    }
 
     return p_Fm;
 }
@@ -3610,7 +4146,7 @@ t_Error FM_Init(t_Handle h_Fm)
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_FmDriverParam         *p_FmDriverParam = NULL;
     t_Error                 err = E_OK;
-    uint32_t                tmpReg, cfgReg = 0;
+    uint32_t                cfgReg = 0;
     int                     i;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
@@ -3621,16 +4157,15 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return InitGuestMode(p_Fm);
 
-    /* read revision register 1 */
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
-    p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
-    p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
 
-    /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
+    /* if user didn't configure totalFifoSize - (totalFifoSize=0) we configure default
      * according to chip. otherwise, we use user's configuration.
      */
     if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
         p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
+#endif  /* FM_NO_GUARANTEED_RESET_VALUES */
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
 
@@ -3833,8 +4368,7 @@ t_Error FM_Init(t_Handle h_Fm)
     /**********************/
     /* clear & enable global counters  - calculate reg and save for later,
        because it's the same reg for QMI enable */
-    if (p_Fm->p_FmDriverParam->enCounters)
-        cfgReg = QMI_CFG_EN_COUNTERS;
+    cfgReg = QMI_CFG_EN_COUNTERS;
 #ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
         cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) | (uint32_t)QMI_DEF_TNUMS_THRESH);
@@ -4052,19 +4586,6 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
     return E_OK;
 }
 
-t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
-
-    p_Fm->p_FmDriverParam->enCounters = TRUE;
-
-    return E_OK;
-}
-
 t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -4934,9 +5455,9 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 
         return outCounter;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+    else if (!p_Fm->baseAddr)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("Either IPC or 'baseAddress' is required!"));
 
     /* When applicable (when there is an 'enable counters' bit,
     check that counters are enabled */
@@ -5143,10 +5664,10 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         p_FmDmaStatus->singlePortEccError = (bool)ipcDmaStatus.boolSinglePortEccError;     /**< Double ECC error on buffer write from FM side */
         return;
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
+    else if (!p_Fm->baseAddr)
     {
-        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("Either IPC or 'baseAddress' is required!"));
         return;
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index ca2df27..29e62b7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -173,7 +173,6 @@ switch(exception){                                          \
 #define DEFAULT_VerifyUcode                 FALSE
 #define DEFAULT_tnumAgingPeriod             0
 #define DEFAULT_dmaWatchdog                 0 /* disabled */
-#define DEFAULT_mtu                         9600
 
 #define FM_TIMESTAMP_1_USEC_BIT             8
 
@@ -614,14 +613,17 @@ typedef _Packed struct t_FmTrbRegs
 #define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
 #define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
 #define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC    0x10000000
-#define BMI_NUM_OF_TASKS_MASK               0x3F000000
+
+#define BMI_NUM_OF_TASKS_MASK               0x3F000000 /* port */
 #define BMI_NUM_OF_EXTRA_TASKS_MASK         0x000F0000
 #define BMI_NUM_OF_DMAS_MASK                0x00000F00
 #define BMI_NUM_OF_EXTRA_DMAS_MASK          0x0000000F
-#define BMI_FIFO_SIZE_MASK                  0x000003FF
+#define BMI_FIFO_SIZE_MASK                  0x000003FF /* port */
 #define BMI_EXTRA_FIFO_SIZE_MASK            0x03FF0000
 #define BMI_CFG2_DMAS_MASK                  0x0000003F
 
+#define BMI_TOTAL_FIFO_SIZE_MASK           0x07FF0000
+#define BMI_TOTAL_NUM_OF_TASKS_MASK        0x007F0000
 /* shifts */
 #define BMI_CFG2_TASKS_SHIFT            16
 #define BMI_CFG2_DMAS_SHIFT             0
@@ -681,7 +683,6 @@ typedef struct
 {
  /*   uint8_t                     numOfPartitions; */
     bool                        resetOnInit;
-    bool                        enCounters;
     t_FmThresholds              thresholds;
     e_FmDmaCacheOverride        dmaCacheOverride;
     e_FmDmaAidMode              dmaAidMode;
@@ -748,8 +749,10 @@ typedef struct
     uint8_t                     extraTasksPoolSize;
     uint8_t                     extraOpenDmasPoolSize;
 #if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    uint16_t                    portMaxFrameLengths10G[FM_MAX_NUM_OF_10G_MACS];
     uint16_t                    macMaxFrameLengths10G[FM_MAX_NUM_OF_10G_MACS];
-#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS) */
+#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+    uint16_t                    portMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
     uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
 } t_FmStateStruct;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 9e65778..61f5961 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -94,6 +94,17 @@ typedef _Packed struct t_FmIpcPhysAddr
     volatile uint32_t   low;
 } _PackedType t_FmIpcPhysAddr;
 
+
+typedef _Packed struct t_FmIpcPortOutInitParams {
+    uint8_t             numOfTasks;         /**< OUT */
+    uint8_t             numOfExtraTasks;    /**< OUT */
+    uint8_t             numOfOpenDmas;      /**< OUT */
+    uint8_t             numOfExtraOpenDmas; /**< OUT */
+    uint32_t            sizeOfFifo;         /**< OUT */
+    uint32_t            extraSizeOfFifo;    /**< OUT */
+    t_FmIpcPhysAddr     ipcPhysAddr;        /**< OUT */
+} _PackedType t_FmIpcPortOutInitParams;
+
 /**************************************************************************//**
  @Description   Structure for IPC communication during FM_PORT_Init.
 *//***************************************************************************/
@@ -109,6 +120,7 @@ typedef _Packed struct t_FmIpcPortInInitParams {
     uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
     uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
     uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            maxFrameLength;     /**< IN. Port's max frame length. */
     uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
                                                  LIODN base for this port, to be
                                                  used together with LIODN offset. */
@@ -213,8 +225,8 @@ typedef _Packed struct t_FmIpcFmanEvents {
 
 typedef _Packed struct t_FmIpcResourceAllocParams {
     uint8_t     guestId;
-    uint8_t     base;
-    uint8_t     num;
+    uint16_t    base;
+    uint16_t    num;
 }_PackedType t_FmIpcResourceAllocParams;
 
 typedef _Packed struct t_FmIpcVspSetPortWindow {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 6b7436c..6a29d6a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -416,6 +416,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_BMI_AC_TX               0x00000274
 #define NIA_BMI_AC_FETCH            0x00000208
 #define NIA_BMI_AC_MASK             0x000003FF
+#define NIA_BMI_AC_FETCH_ALL_FRAME  0x0000020c
 
 #define NIA_KG_DIRECT               0x00000100
 #define NIA_KG_CC_EN                0x00000200
@@ -879,6 +880,7 @@ typedef struct t_FmInterModulePortInitParams {
     uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
     uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
     uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            maxFrameLength;     /**< IN. Port's max frame length. */
     uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
                                                  LIODN base for this port, to be
                                                  used together with LIODN offset. */
@@ -1118,18 +1120,18 @@ t_Error     Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId);
 void        FmMuramClear(t_Handle h_FmMuram);
 t_Error     FmSetNumOfOpenDmas(t_Handle h_Fm,
                                uint8_t  hardwarePortId,
-                               uint8_t  numOfOpenDmas,
-                               uint8_t  numOfExtraOpenDmas,
+                               uint8_t  *p_NumOfOpenDmas,
+                               uint8_t  *p_NumOfExtraOpenDmas,
                                bool     initialConfig);
 t_Error     FmSetNumOfTasks(t_Handle    h_Fm,
                             uint8_t     hardwarePortId,
-                            uint8_t     numOfTasks,
-                            uint8_t     numOfExtraTasks,
+                            uint8_t     *p_NumOfTasks,
+                            uint8_t     *p_NumOfExtraTasks,
                             bool        initialConfig);
 t_Error     FmSetSizeOfFifo(t_Handle    h_Fm,
                             uint8_t     hardwarePortId,
-                            uint32_t    sizeOfFifo,
-                            uint32_t    extraSizeOfFifo,
+                            uint32_t    *p_SizeOfFifo,
+                            uint32_t    *p_ExtraSizeOfFifo,
                             bool        initialConfig);
 
 t_Error     FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index b266242..4bbd3b8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -790,21 +790,6 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
 
 /**************************************************************************//**
- @Function      FM_ConfigEnableCounters
-
- @Description   Enable counters.
-                Calling this routine changes the internal driver data
-                base from its default configuration where counters are disabled.
-
- @Param[in]     h_Fm    A handle to an FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
-
-/**************************************************************************//**
  @Function      FM_ConfigDmaDbgCounter
 
  @Description   Define DMA debug counter.
@@ -856,24 +841,6 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
 
 /**************************************************************************//**
- @Function      FM_ConfigDmaEmergencySmoother
-
- @Description   Define DMA emergency smoother.
-                Calling this routine changes the definition of the minimum
-                amount of DATA beats transferred on the AXI READ and WRITE
-                ports before lowering the emergency level.
-                By default smoother is disabled.
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     emergencyCnt    emergency switching counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
-
-/**************************************************************************//**
  @Function      FM_ConfigDmaErr
 
  @Description   DMA error treatment.
@@ -1031,6 +998,24 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
 /**************************************************************************//**
+ @Function      FM_ConfigDmaEmergencySmoother
+
+ @Description   Define DMA emergency smoother.
+                Calling this routine changes the definition of the minimum
+                amount of DATA beats transferred on the AXI READ and WRITE
+                ports before lowering the emergency level.
+                By default smoother is disabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     emergencyCnt    emergency switching counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
+
+/**************************************************************************//**
  @Function      FM_ConfigThresholds
 
  @Description   Calling this routine changes the internal driver data base
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 9231103..1b0d5f0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -618,6 +618,20 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 
 /**************************************************************************//**
+ @Function      FM_PCD_HcTxConf
+
+ @Description   This routine should be called to confirm frames that were
+                 received on the HC confirmation queue.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_Fd            Frame descriptor of the received frame.
+
+ @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
+                option was selected in the initialization.
+*//***************************************************************************/
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
+
+/**************************************************************************//**
  @Function      FM_PCD_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
@@ -632,20 +646,6 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 *//***************************************************************************/
 t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
 
-/**************************************************************************//**
- @Function      FM_PCD_HcTxConf
-
- @Description   This routine should be called to confirm frames that were
-                 received on the HC confirmation queue.
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     p_Fd            Frame descriptor of the received frame.
-
- @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
-                option was selected in the initialization.
-*//***************************************************************************/
-void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
-
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
  @Function      FM_PCD_DumpRegs
@@ -1241,6 +1241,11 @@ typedef union u_FmPcdHdrProtocolOpt {
                                  e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
                                  e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
 
+                                (Note that starting DPAA 11, NET_HEADER_FIELD_IPv6_NEXT_HDR applies to
+                                 the last next header indication, meaning the next L4, which may be
+                                 present at the Ipv6 last extension. On earlier revisions this field
+                                 applies to the Next-Header field of the main IPv6 header)
+
                     HEADER_TYPE_GRE:
                         NET_HEADER_FIELD_GRE_TYPE
 
@@ -2129,6 +2134,7 @@ typedef struct t_FmPcdManipReassemIpParams {
     uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
                                                                  relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
                                                                  relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+                                                                 NOTE: The following is relevant only for v2 devices
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
                                                                  the user schemes id to ensure that the reassembly's schemes will be first match;
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
@@ -3070,7 +3076,7 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
                 If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
                 frame count will be separated to frame length counters, based on
                 provided frame length ranges.
-				Note that this routine will search the node to locate the index
+                Note that this routine will search the node to locate the index
                 of the required key based on received key parameters.
 
  @Param[in]     h_CcNode        A handle to the node
@@ -3086,9 +3092,9 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
                                                uint8_t                  keySize,
-		                                       uint8_t                  *p_Key,
-		                                       uint8_t                  *p_Mask,
-						   t_FmPcdCcKeyStatistics   *p_KeyStatistics);
+                                               uint8_t                  *p_Key,
+                                               uint8_t                  *p_Mask,
+                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics);
 
 /**************************************************************************//*
  @Function      FM_PCD_MatchTableGetNextEngine
@@ -3287,8 +3293,8 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
                 If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
                 frame count will be separated to frame length counters, based on
                 provided frame length ranges.
-				Note that this routine will identify the bucket of this key in
-				the hash table and will search the bucket to locate the index
+                Note that this routine will identify the bucket of this key in
+                the hash table and will search the bucket to locate the index
                 of the required key based on received key parameters.
 
  @Param[in]     h_HashTbl       A handle to a hash table
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 8f254da..5add10f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -136,6 +136,7 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /*< non Frame-Manager error; probably come from SEC that
                                                                                     was chained to FM */
 #endif /* FM_DISABLE_SEC_ERRORS */
+
 #define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)    /**< IPR error */
 #define FM_PORT_FRM_ERR_IPR_TO                  (FM_FD_ERR_IPR_TO & ~FM_FD_IPR) /**< IPR timeout */
 #define FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                   /**< IPF error */
@@ -1446,41 +1447,6 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
 
 /**************************************************************************//**
- @Function      FM_PORT_SetPerformanceCounters
-
- @Description   Calling this routine enables/disables port's performance counters.
-                By default, counters are enabled.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     enable                  TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetPerformanceCounters
-
- @Description   Calling this routine defines port's performance
-                counters parameters.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
-                                        counters parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
-
-/**************************************************************************//**
  @Function      FM_PORT_AnalyzePerformanceParams
 
  @Description   User may call this routine to so the driver will analyze if the
@@ -1709,6 +1675,40 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
 *//***************************************************************************/
 t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
 
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     enable                  TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCountersParams
+
+ @Description   Calling this routine defines port's performance
+                counters parameters.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
+                                        counters parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
 
 /**************************************************************************//**
  @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index 9728af5..ca912b8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -207,6 +207,9 @@ typedef enum e_FmMacsecInterModuleEvent {
 #define FM_FIFO_ALLOCATION_ALG
 #define FM_DEQ_PIPELINE_PARAMS_FOR_OP
 #define FM_HAS_TOTAL_DMAS
+#define FM_KG_NO_IPPID_SUPPORT
+#define FM_NO_GUARANTEED_RESET_VALUES
+#define FM_MAC_RESET
 
 /* FM erratas */
 #define FM_RX_PREAM_4_ERRATA_DTSEC_A001
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 4673d0f..c34b731 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -30,8 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
-
+/**************************************************************************//**
  @File          dpaa_integration_ext.h
 
  @Description   P3040/P4080/P5020 FM external definitions and structures.
@@ -81,11 +80,11 @@ typedef enum
 /*****************************************************************************
  QMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
-#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
-#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
-#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
-                                                /**< FQIDs range - 24 bits */
+#define QM_MAX_NUM_OF_POOL_CHANNELS 15              /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ            8               /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_SWP_AS        4
+#define QM_MAX_NUM_OF_CGS           256             /**< Number of congestion groups */
+#define QM_MAX_NUM_OF_FQIDS         (16 * MEGABYTE) /**< FQIDs range - 24 bits */
 
 /**************************************************************************//**
  @Description   Work Queue Channel assignments in QMan.
@@ -156,9 +155,6 @@ typedef enum
                                                      connected to RAID */
 } e_QmFQChannel;
 
-/* p4080-rev1 unique features */
-#define QM_CGS_NO_FRAME_MODE
-
 /*****************************************************************************
  BMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
@@ -206,7 +202,6 @@ typedef enum
 
 /* QMI defines */
 #define QMI_MAX_NUM_OF_TNUMS            64
-#define MAX_QMI_DEQ_SUBPORTAL           12
 #define QMI_DEF_TNUMS_THRESH            48
 
 /* FPM defines */
@@ -226,26 +221,25 @@ typedef enum
 #define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
 
 /* p4080-rev1 unique features */
-#define FM_PARTITION_ARRAY
-#define FM_PPPOE_NO_MTU_CHECK
-#define FM_NO_THRESHOLD_REG
+#define QM_CGS_NO_FRAME_MODE
 
 /* p4080 unique features */
 #define FM_NO_DISPATCH_RAM_ECC
 #define FM_FIFO_ALLOCATION_OLD_ALG
 #define FM_NO_WATCHDOG
 #define FM_NO_TNUM_AGING
-#define FM_NO_TGEC_LOOPBACK
 #define FM_KG_NO_BYPASS_FQID_GEN
 #define FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
 #define FM_NO_BACKUP_POOLS
 #define FM_NO_OP_OBSERVED_POOLS
 #define FM_NO_ADVANCED_RATE_LIMITER
 #define FM_NO_OP_OBSERVED_CGS
-#define FM_OP_QMI_FRAG_OPTION
+#define FM_HAS_TOTAL_DMAS
+#define FM_KG_NO_IPPID_SUPPORT
+#define FM_NO_GUARANTEED_RESET_VALUES
+#define FM_MAC_RESET
 
 /* FM erratas */
-
 #define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 #define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
 #define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
@@ -254,7 +248,6 @@ typedef enum
 #define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
 
 #define FM_RX_PREAM_4_ERRATA_DTSEC_A001
-#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
 #define FM_GRS_ERRATA_DTSEC_A002
 #define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
 #define FM_GTS_ERRATA_DTSEC_A004
@@ -269,12 +262,11 @@ typedef enum
 
 #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
 
-#define FM_LEN_CHECK_ERRATA_FMAN_SW002
-#define FM_PRS_MEM_ERRATA_FMAN_SW003
 #define FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
 
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+
 #define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
 #define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
 
-
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index 00dd846..63ebb2c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -356,9 +356,7 @@ int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev, int muram_fifo_size)
 			+ gb10g * num_10g_ports;	/* divide it by 10 */
 
 	/* Base buffer calculus */
-	oh_buff = DPDE_1G + 4;	/* should be:
-		get_largest_buf_size(max_frame_size, buf_size),
-		but LLD: DPDE + 4 */
+	oh_buff = 8;
 	total_no_buffers = muram_fifo_size / buf_size;
 
 	min_tx_1g_2g5_bufs = CEIL_DIV(max_frame_size, buf_size)
-- 
1.7.9.7

